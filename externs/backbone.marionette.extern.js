/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/backbone.marionette/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: NamespaceExportDeclaration in  */

/* TODO: ExportAssignment in  */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "backbone"

/**
 * @constructor
 * @struct
 * @param {!Array<?>=} initialViews
 */
tsickle_declare_module.backbone.ChildViewContainer = function(initialViews) {};

/**
 * @param {TView} view
 * @param {number=} customIndex
 * @return {void}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.add = function(view, customIndex) {};

/**
 * @template TModel
 * @param {TModel} model
 * @return {TView}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.findByModel = function(model) {};

/**
 * @param {string} modelCid
 * @return {TView}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.findByModelCid = function(modelCid) {};

/**
 * @param {number} index
 * @return {TView}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.findByCustom = function(index) {};

/**
 * @param {number} index
 * @return {TView}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.findByIndex = function(index) {};

/**
 * @param {string} cid
 * @return {TView}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.findByCid = function(cid) {};

/**
 * @param {TView} view
 * @return {void}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.remove = function(view) {};

/**
 * @param {function(TView, number): boolean} iterator
 * @param {?=} context
 * @return {boolean}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.all = function(iterator, context) {};

/**
 * @param {function(TView, number): boolean} iterator
 * @param {?=} context
 * @return {boolean}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.any = function(iterator, context) {};

/**
 * @param {?} value
 * @return {boolean}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.contains = function(value) {};

/**
 * @param {function(?): boolean} iterator
 * @param {?=} context
 * @return {?}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.detect = function(iterator, context) {};

/**
 * @param {function(TView, number, ?): void} iterator
 * @param {?=} context
 * @return {?}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.each = function(iterator, context) {};

/**
 * @param {function(TView, number): boolean} iterator
 * @param {?=} context
 * @return {boolean}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.every = function(iterator, context) {};

/**
 * @param {function(TView, number): boolean} iterator
 * @param {?=} context
 * @return {!Array<TView>}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.filter = function(iterator, context) {};

/**
 * @param {function(TView, number): boolean} iterator
 * @param {?=} context
 * @return {TView}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.find = function(iterator, context) {};

/**
 * @return {TView}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.first = function() {};

/**
 * @param {function(TView, number, ?): void} iterator
 * @param {?=} context
 * @return {void}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.forEach = function(iterator, context) {};

/**
 * @param {?} value
 * @return {boolean}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.include = function(value) {};

/**
 * @param {number=} n
 * @return {TView|!Array<TView>}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.initial = function(n) {};

/**
 * @param {string} methodName
 * @param {!Array<?>=} args
 * @return {?}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.invoke = function(methodName, args) {};

/**
 * @param {?} object
 * @return {boolean}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.isEmpty = function(object) {};

/**
 * @param {number=} n
 * @return {TView|!Array<TView>}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.last = function(n) {};

/**
 * @param {TView} element
 * @param {number=} fromIndex
 * @return {number}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.lastIndexOf = function(element, fromIndex) {};

/**
 * @template U
 * @param {function(TView, number, ?): U} iterator
 * @param {?=} context
 * @return {!Array<U>}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.map = function(iterator, context) {};

/**
 * @param {string} attribute
 * @return {!Array<?>}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.pluck = function(attribute) {};

/**
 * @param {function(TView, number): boolean} iterator
 * @param {?=} context
 * @return {!Array<TView>}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.reject = function(iterator, context) {};

/**
 * @param {number=} n
 * @return {TView|!Array<TView>}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.rest = function(n) {};

/**
 * @param {?} iterator
 * @param {?=} context
 * @return {!Array<?>}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.select = function(iterator, context) {};

/**
 * @param {function(TView, number): boolean} iterator
 * @param {?=} context
 * @return {boolean}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.some = function(iterator, context) {};

/**
 * @return {!Array<?>}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.toArray = function() {};

/**
 * @param {...?} values
 * @return {!Array<TView>}
 */
tsickle_declare_module.backbone.ChildViewContainer.prototype.without = function(values) {};
/** @const */
tsickle_declare_module.backbone.Wreqr = {};
/** @const */
tsickle_declare_module.backbone.Wreqr.radio = {};

/**
 * @param {string} channelName
 * @return {!Wreqr.Channel}
 */
tsickle_declare_module.backbone.Wreqr.radio.channel = function(channelName) {};

/**
 * @constructor
 * @struct
 * @param {string} channelName
 */
tsickle_declare_module.backbone.Wreqr.Channel = function(channelName) {};
 /** @type {!Wreqr.EventAggregator} */
tsickle_declare_module.backbone.Wreqr.Channel.prototype.vent;
 /** @type {!Wreqr.RequestResponse} */
tsickle_declare_module.backbone.Wreqr.Channel.prototype.reqres;
 /** @type {!Wreqr.Commands} */
tsickle_declare_module.backbone.Wreqr.Channel.prototype.commands;
 /** @type {string} */
tsickle_declare_module.backbone.Wreqr.Channel.prototype.channelName;

/**
 * @return {!Wreqr.Channel}
 */
tsickle_declare_module.backbone.Wreqr.Channel.prototype.reset = function() {};

/**
 * @param {string} hash
 * @param {?} context
 * @return {!Wreqr.Channel}
 */
tsickle_declare_module.backbone.Wreqr.Channel.prototype.connectEvents = function(hash, context) {};

/**
 * @param {string} hash
 * @param {?} context
 * @return {!Wreqr.Channel}
 */
tsickle_declare_module.backbone.Wreqr.Channel.prototype.connectCommands = function(hash, context) {};

/**
 * @param {string} hash
 * @param {?} context
 * @return {!Wreqr.Channel}
 */
tsickle_declare_module.backbone.Wreqr.Channel.prototype.connectRequests = function(hash, context) {};

/**
 * @constructor
 * @struct
 * @param {?=} options
 */
tsickle_declare_module.backbone.Wreqr.Handlers = function(options) {};
 /** @type {?} */
tsickle_declare_module.backbone.Wreqr.Handlers.prototype.options;

/**
 * @param {string} name
 * @param {?} handler
 * @param {?=} context
 * @return {void}
 */
tsickle_declare_module.backbone.Wreqr.Handlers.prototype.setHandler = function(name, handler, context) {};

/**
 * @param {string} name
 * @return {boolean}
 */
tsickle_declare_module.backbone.Wreqr.Handlers.prototype.hasHandler = function(name) {};

/**
 * @param {string} name
 * @return {!Function}
 */
tsickle_declare_module.backbone.Wreqr.Handlers.prototype.getHandler = function(name) {};

/**
 * @param {string} name
 * @return {void}
 */
tsickle_declare_module.backbone.Wreqr.Handlers.prototype.removeHandler = function(name) {};

/**
 * @return {void}
 */
tsickle_declare_module.backbone.Wreqr.Handlers.prototype.removeAllHandlers = function() {};

/**
 * @constructor
 * @struct
 * @param {?=} options
 */
tsickle_declare_module.backbone.Wreqr.CommandStorage = function(options) {};

/**
 * @param {string} commandName
 * @return {!Wreqr.Commands}
 */
tsickle_declare_module.backbone.Wreqr.CommandStorage.prototype.getCommands = function(commandName) {};

/**
 * @param {string} commandName
 * @param {?} args
 * @return {void}
 */
tsickle_declare_module.backbone.Wreqr.CommandStorage.prototype.addCommand = function(commandName, args) {};

/**
 * @param {string} commandName
 * @return {void}
 */
tsickle_declare_module.backbone.Wreqr.CommandStorage.prototype.clearCommands = function(commandName) {};

/**
 * @constructor
 * @struct
 * @param {?=} options
 */
tsickle_declare_module.backbone.Wreqr.Commands = function(options) {};
 /** @type {!Wreqr.CommandStorage} */
tsickle_declare_module.backbone.Wreqr.Commands.prototype.storageType;

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
tsickle_declare_module.backbone.Wreqr.Commands.prototype.execute = function(name, args) {};

/**
 * @constructor
 * @struct
 * @param {?=} options
 */
tsickle_declare_module.backbone.Wreqr.RequestResponse = function(options) {};

/**
 * @param {...?} args
 * @return {?}
 */
tsickle_declare_module.backbone.Wreqr.RequestResponse.prototype.request = function(args) {};

/**
 * @constructor
 * @struct
 * @param {?=} options
 */
tsickle_declare_module.backbone.Wreqr.EventAggregator = function(options) {};
/** @const */
var Marionette = {};

/**
 * Retrieve an object's attribute either directly from the object, or
 * from the object's this.options, with this.options taking precedence.
 * @param {?} target
 * @param {string} optionName
 * @return {?}
 */
Marionette.getOption = function(target, optionName) {};

/**
 * Trigger an event and a corresponding method on the target object.
 * All arguments that are passed to the triggerMethod call are passed along
 * to both the event and the method, with the exception of the event name not
 * being passed to the corresponding method.
 * @param {string} name
 * @param {...?} args
 * @return {?}
 */
Marionette.triggerMethod = function(name, args) {};

/**
 * Invoke triggerMethod on a specific context.
 * This is useful when it's not clear that the object has triggerMethod defined.
 * @param {?} ctx
 * @param {string} name
 * @param {...?} args
 * @return {?}
 */
Marionette.triggerMethodOn = function(ctx, name, args) {};

/**
 * Monitor a view's state, and after it has been rendered and shown in the DOM,
 * trigger a "dom:refresh" event every time it is re-rendered.
 * @param {!Backbone.View<!Backbone.Model>} view
 * @return {void}
 */
Marionette.MonitorDOMRefresh = function(view) {};

/**
 * This method is used to bind a backbone "entity" (collection/model) to methods on a target object.
 * @param {?} target An object that must have a listenTo method from the EventBinder object.
 * @param {?} entity The entity (Backbone.Model or Backbone.Collection) to bind the events from.
 * @param {?} bindings a hash of { "event:name": "eventHandler" } configuration. Multiple handlers can be separated by a space. A function can be supplied instead of a string handler name.
 * @return {void}
 */
Marionette.bindEntityEvents = function(target, entity, bindings) {};

/**
 * This method can be used to unbind callbacks from entities' (collection/model) events. It's the opposite of bindEntityEvents
 * @param {?} target An object that must have a listenTo method from the EventBinder object.
 * @param {?} entity The entity (Backbone.Model or Backbone.Collection) to bind the events from.
 * @param {?} bindings a hash of { "event:name": "eventHandler" } configuration. Multiple handlers can be separated by a space. A function can be supplied instead of a string handler name.
 * @return {void}
 */
Marionette.unbindEntityEvents = function(target, entity, bindings) {};
/**
 * @constructor
 * @struct
 */
Marionette.Callbacks = function() {};

/**
 * @param {!Function} callback
 * @param {?} contextOverride
 * @return {void}
 */
Marionette.Callbacks.prototype.add = function(callback, contextOverride) {};

/**
 * @param {?} options
 * @param {?} context
 * @return {void}
 */
Marionette.Callbacks.prototype.run = function(options, context) {};

/**
 * @return {void}
 */
Marionette.Callbacks.prototype.reset = function() {};
/**
 * @extends {Backbone.Events}
 * @constructor
 * @struct
 */
Marionette.Object = function() {};
 /** @type {string} */
Marionette.Object.prototype.channelName;
 /** @type {?} */
Marionette.Object.prototype.radioEvents;
 /** @type {?} */
Marionette.Object.prototype.radioRequests;

/**
 * Returns a Radio.Channel instance using 'channelName'
 * @return {!Radio.Channel}
 */
Marionette.Object.prototype.getChannel = function() {};

/**
 * Initialize is called immediately after the Object has been instantiated,
 * and is invoked with the same arguments that the constructor received.
 * @param {?=} options
 * @return {void}
 */
Marionette.Object.prototype.initialize = function(options) {};

/**
 * Retrieve an object's attribute either directly from the object, or from
 * the object's this.options, with this.options taking precedence.
 * @param {string} optionName the name of the option to retrieve.
 * @return {?}
 */
Marionette.Object.prototype.getOption = function(optionName) {};

/**
 * Objects have a destroy method that unbind the events that are directly
 * attached to the instance. Invoking the destroy method will trigger a
 * "before:destroy" event and corresponding onBeforeDestroy method call.
 * These calls will be passed any arguments destroy was invoked with.
 * @param {...?} args any arguments to pass to the "before:destory" event and call to
 * onBeforeDestroy.
 * @return {void}
 */
Marionette.Object.prototype.destroy = function(args) {};

/**
 * @constructor
 * @struct
 * @param {?=} options Options that should be stored in this options. Can be retreived via
 * getOption.
 */
Marionette.Controller = function(options) {};

/**
 * Handles unbinding all of the events that are directly attached to the
 * controller instance, as well as those that are bound using the
 * EventBinder from the controller.
 * 
 * Invoking the destroy method will trigger the "before:destroy" and
 * "destroy" events and the corresponding onBeforeDestory and onDestroy
 * method calls. These calls will be passed any arguments destroy was
 * invoked with.
 * @param {...?} args
 * @return {void}
 */
Marionette.Controller.prototype.destroy = function(args) {};

/**
 * Retrieve an object's attribute either directly from the object, or from
 * the object's this.options, with this.options taking precedence.
 * @param {string} optionName the name of the option to retrieve.
 * @return {?}
 */
Marionette.Controller.prototype.getOption = function(optionName) {};

/**
 * @param {string} name
 * @param {...?} args
 * @return {?}
 */
Marionette.Controller.prototype.triggerMethod = function(name, args) {};
/**
 * @record
 * @struct
 */
Marionette.RegionConstructionOptions = function() {};
 /** @type {?} */
Marionette.RegionConstructionOptions.prototype.el;
/**
 * @record
 * @struct
 */
Marionette.RegionShowOptions = function() {};
 /** @type {boolean} */
Marionette.RegionShowOptions.prototype.preventDestroy;
 /** @type {boolean} */
Marionette.RegionShowOptions.prototype.forceShow;
 /** @type {boolean} */
Marionette.RegionShowOptions.prototype.triggerBeforeAttach;
 /** @type {boolean} */
Marionette.RegionShowOptions.prototype.triggerAttach;
/**
 * @record
 * @struct
 */
Marionette.RegionEmptyOptions = function() {};
 /** @type {boolean} */
Marionette.RegionEmptyOptions.prototype.preventDestroy;

/**
 * @constructor
 * @struct
 * You can specify an el for the region to manage at the time the region
 * is instantiated.
 * @param {!Marionette.RegionConstructionOptions=} options
 */
Marionette.Region = function(options) {};
 /** @type {?} */
Marionette.Region.prototype.el;
 /** @type {!Backbone.View<!Backbone.Model>} */
Marionette.Region.prototype.currentView;

/**
 * Build an instance of a region by passing in a configuration object and
 * a default region class to use if none is specified in the config.
 * The config object should either be a string as a jQuery DOM selector,
 * a Region class directly, or an object literal that specifies a selector,
 * a custom regionClass, and any options to be supplied to the region
 * @param {?} regionConfig
 * @param {?} defaultRegionType
 * @return {!Marionette.Region}
 */
Marionette.Region.buildRegion = function(regionConfig, defaultRegionType) {};

/**
 * Renders and displays the specified view in this region.
 * @template TModel
 * @param {!Backbone.View<TModel>} view the view to display.
 * @param {!Marionette.RegionShowOptions=} options
 * @return {void}
 */
Marionette.Region.prototype.show = function(view, options) {};

/**
 * Attaches an existing view to a region, without rendering or showing the view,
 * and without replacing the HTML content of the region.
 * @template TModel
 * @param {!Backbone.View<TModel>} view
 * @param {!Marionette.RegionShowOptions=} options
 * @return {?}
 */
Marionette.Region.prototype.attachView = function(view, options) {};

/**
 * Override this method to change how the new view is
 * appended to the `$el` that the region is managing
 * @template TModel
 * @param {!Backbone.View<TModel>} view
 * @return {void}
 */
Marionette.Region.prototype.attachHtml = function(view) {};

/**
 * A region can be reset at any time. This destroys any existing view
 * being displayed, and deletes the cached el. The next time the region
 * shows a view, the region's el is queried from the DOM.
 * @return {?}
 */
Marionette.Region.prototype.reset = function() {};

/**
 * If you wish to check whether a region has a view, you can use the hasView function. This will return a boolean value depending whether or not the region is showing a view.
 * @return {boolean}
 */
Marionette.Region.prototype.hasView = function() {};

/**
 * Empties the current view from the region.
 * @param {!Marionette.RegionEmptyOptions=} options
 * @return {?}
 */
Marionette.Region.prototype.empty = function(options) {};
/**
 * @record
 * @struct
 */
Marionette.RegionDefaults = function() {};
 /** @type {string} */
Marionette.RegionDefaults.prototype.selector;
 /** @type {?} */
Marionette.RegionDefaults.prototype.el;
 /** @type {?} */
Marionette.RegionDefaults.prototype.regionClass;
 /** @type {boolean} */
Marionette.RegionDefaults.prototype.allowMissingEl;

/**
 * @constructor
 * @struct
 * Constructor.
 * @param {?=} options May contain an optional `regions` option. These regions
 * are passed directly into addRegions for this instance.
 */
Marionette.RegionManager = function(options) {};

/**
 * Adds one or more regions to this RegionManager instance.
 * Adds one or more regions to this RegionManager instance.
 * @param {!Function|!Object<string,?>} regionDefinitions a function returning an object literal with the region definitions. The function will
 * be called with the RegionManager instance context and all the arguments passed to addRegions. / an object literal containing region names as keys and region
 * definitions as values.
 * @param {!Marionette.RegionDefaults=} defaults Specifies default options that will be applied to every region added.
 * @return {?} an object literal with all the created regions.
 */
Marionette.RegionManager.prototype.addRegions = function(regionDefinitions, defaults) {};

/**
 * Adds a region to this RegionManager.
 * @param {string} name the region name.
 * @param {?} definition the region definition. This may be a selector, object literal
 * with various region creation options or an instance of a region object.
 * @return {!Marionette.Region}
 */
Marionette.RegionManager.prototype.addRegion = function(name, definition) {};

/**
 * Gets the region with the specified name from this RegionManager.
 * @param {string} name
 * @return {!Marionette.Region}
 */
Marionette.RegionManager.prototype.get = function(name) {};

/**
 * Removes the region with the specified name from this RegionManager.
 * @param {string} name
 * @return {void}
 */
Marionette.RegionManager.prototype.removeRegion = function(name) {};

/**
 * Removes all regions from the RegionManager.
 * @return {void}
 */
Marionette.RegionManager.prototype.removeRegions = function() {};

/**
 * Empties all regions from the RegionManager instance.
 * @return {void}
 */
Marionette.RegionManager.prototype.emptyRegions = function() {};

/**
 * Destroys the RegionManager instance entierly which both destroys and
 * removes all regions from the RegionManager instance.
 * @return {void}
 */
Marionette.RegionManager.prototype.destroy = function() {};

/**
 * Returns true if all of the values in the list pass the predicate truth test.
 * \@alias every
 * @param {function(!Marionette.Region, number): boolean} iterator
 * @param {?=} context
 * @return {boolean}
 */
Marionette.RegionManager.prototype.all = function(iterator, context) {};

/**
 * Returns true if any of the values in the list pass the predicate truth test. Short-circuits and stops traversing the list if a true element is found.
 * @param {function(!Marionette.Region, number): boolean} iterator
 * @param {?=} context
 * @return {boolean}
 */
Marionette.RegionManager.prototype.any = function(iterator, context) {};

/**
 * Returns true if the value is present in the list.
 * \@alias include
 * @param {?} value
 * @return {boolean}
 */
Marionette.RegionManager.prototype.contains = function(value) {};

/**
 * Looks through each value in the list, returning the first one that passes a truth test (predicate), or undefined if no value passes the test.The function returns as soon as it finds an acceptable element, and doesn't traverse the entire list.
 * \@alias find
 * @param {function(?): boolean} iterator
 * @param {?=} context
 * @return {?}
 */
Marionette.RegionManager.prototype.detect = function(iterator, context) {};

/**
 * Iterates over the regions in this instance, yielding each in turn to an
 * iterator function. The iterator is bound to the context object, if one
 * is passed.
 * \@alias forEach
 * @param {function(!Marionette.Region, number, ?): void} iterator
 * @param {?=} context
 * @return {void}
 */
Marionette.RegionManager.prototype.each = function(iterator, context) {};

/**
 * Returns true if all of the values in the list pass the predicate truth test.
 * \@alias all
 * @param {function(!Marionette.Region, number): boolean} iterator
 * @param {?=} context
 * @return {boolean}
 */
Marionette.RegionManager.prototype.every = function(iterator, context) {};

/**
 * Looks through each Region in the collection, returning an array of all
 * the values that pass a truth test (predicate).
 * \@alias select
 * @param {function(!Marionette.Region, number): boolean} iterator
 * @param {?=} context
 * @return {!Array<!Marionette.Region>}
 */
Marionette.RegionManager.prototype.filter = function(iterator, context) {};

/**
 * Looks through each Region in this instance, returning the first one that passes a truth test (predicate), or undefined if no value passes the test.The function returns as soon as it finds an acceptable element, and doesn't traverse the entire list.
 * \@alias detect
 * @param {function(!Marionette.Region, number): boolean} iterator
 * @param {?=} context
 * @return {!Marionette.Region}
 */
Marionette.RegionManager.prototype.find = function(iterator, context) {};

/**
 * Returns the first Region of this RegionManager.
 * Returns the first n Regions of this RegionManager.
 * @param {number=} n
 * @return {!Marionette.Region|!Array<!Marionette.Region>}
 */
Marionette.RegionManager.prototype.first = function(n) {};

/**
 * Iterates over the regions in this instance, yielding each in turn to an
 * iterator function. The iterator is bound to the context object, if one
 * is passed.
 * \@alias each
 * @param {function(!Marionette.Region, number, ?): void} iterator
 * @param {?=} context
 * @return {void}
 */
Marionette.RegionManager.prototype.forEach = function(iterator, context) {};

/**
 * Returns true if the value is present in the list.
 * \@alias contains
 * @param {?} value
 * @return {boolean}
 */
Marionette.RegionManager.prototype.include = function(value) {};

/**
 * Returns everything but the last n Regions of this instance.
 * @param {number} n if specified determines the number of regions to exclude,
 * otherwise only the last element is excluded.
 * @return {!Array<!Marionette.Region>}
 */
Marionette.RegionManager.prototype.initial = function(n) {};

/**
 * Calls the method named by methodName on each value in the collection. Any extra
 * arguments passed to invoke will be forwarded on to the method invocation.
 * @param {string} methodName
 * @param {!Array<?>=} args
 * @return {?}
 */
Marionette.RegionManager.prototype.invoke = function(methodName, args) {};

/**
 * Returns true if the RegionManager contains no regions.
 * @param {?} object
 * @return {boolean}
 */
Marionette.RegionManager.prototype.isEmpty = function(object) {};

/**
 * Returns the last element of a collection.
 * Returns the last n elements of the collection.
 * @param {number=} n
 * @return {!Marionette.Region|!Array<!Marionette.Region>}
 */
Marionette.RegionManager.prototype.last = function(n) {};

/**
 * Returns the index of the last occurrence of element in the collection, or -1 if
 * element is not present.
 * @param {!Marionette.Region} element
 * @param {number=} fromIndex if specified starts the search at the given index.
 * @return {number}
 */
Marionette.RegionManager.prototype.lastIndexOf = function(element, fromIndex) {};

/**
 * Produces a new array of values by mapping each value in the collection through a
 * transformation function (iterator).
 * \@alias collect
 * @param {function(!Marionette.Region, number, ?): !Array<?>} iterator
 * @param {?=} context
 * @return {!Array<?>}
 */
Marionette.RegionManager.prototype.map = function(iterator, context) {};

/**
 * Pluck an attribute from each model in the collection. Equivalent to
 * calling map and returning a single attribute from the iterator.
 * @param {string} attribute
 * @return {!Array<?>}
 */
Marionette.RegionManager.prototype.pluck = function(attribute) {};

/**
 * Returns the values in the collection without the elements that the truth test
 * (predicate) passes. The opposite of filter.
 * @param {function(!Marionette.Region, number): boolean} iterator
 * @param {?=} context
 * @return {!Array<!Marionette.Region>}
 */
Marionette.RegionManager.prototype.reject = function(iterator, context) {};

/**
 * Returns the rest of the elements of the collection.
 * Pass an index to return the values of the array from that index onward. If not
 * specified the first item in the collection is dropped.
 * \@alias tail, drop
 * @param {number} n
 * @return {!Array<!Marionette.Region>}
 */
Marionette.RegionManager.prototype.rest = function(n) {};

/**
 * Looks through each value in the collection, returning an array of all
 * the values that pass a truth test (predicate).
 * \@alias filter
 * @param {?} iterator
 * @param {?=} context
 * @return {!Array<!Marionette.Region>}
 */
Marionette.RegionManager.prototype.select = function(iterator, context) {};

/**
 * Returns true if any of the values in the list pass the predicate truth test. Short-circuits and stops traversing the list if a true element is found.
 * \@alias any
 * @param {function(!Marionette.Region, number): boolean} iterator
 * @param {?=} context
 * @return {boolean}
 */
Marionette.RegionManager.prototype.some = function(iterator, context) {};

/**
 * Creates an array containing the regions in this instance.
 * @return {!Array<!Marionette.Region>}
 */
Marionette.RegionManager.prototype.toArray = function() {};

/**
 * Returns an array of all the regions in the RegionManager except the ones specified.
 * @param {...?} values
 * @return {!Array<!Marionette.Region>}
 */
Marionette.RegionManager.prototype.without = function(values) {};
/**
 * @constructor
 * @struct
 */
Marionette.TemplateCache = function() {};

/**
 * To use the TemplateCache, call the get method on TemplateCache directly. Internally, instances of the TemplateCache class will be created and stored but you do not have to manually create these instances yourself. get will return a compiled template function.
 * @param {string} templateId
 * @return {?}
 */
Marionette.TemplateCache.get = function(templateId) {};

/**
 * You can clear one or more, or all items from the cache using the clear
 * method. Clearing a template from the cache will force it to re-load
 * from the DOM the next time it is retrieved.
 * @param {...string} templateId
 * @return {void}
 */
Marionette.TemplateCache.clear = function(templateId) {};

/**
 * The default template retrieval is to select the template contents from the
 * DOM using jQuery. If you wish to change the way this works, you can
 * override this method on the TemplateCache object.
 * @param {string} templateId
 * @return {?}
 */
Marionette.TemplateCache.prototype.loadTemplate = function(templateId) {};

/**
 * he default template compilation passes the results from loadTemplate to
 * the compileTemplate function, which returns an underscore.js compiled
 * template function. When overriding compileTemplate remember that it
 * must return a function which takes an object of parameters and values
 * and returns a formatted HTML string.
 * @param {?} rawTemplate
 * @return {?}
 */
Marionette.TemplateCache.prototype.compileTemplate = function(rawTemplate) {};
/**
 * @constructor
 * @struct
 */
Marionette.Renderer = function() {};

/**
 *  This method returns a string containing the result of applying the
 * template using the data object as the context.
 * @param {?} template The template to render. If this is a function this is
 * treated as a pre-compiled template and does not try to compile it again. This
 * allows any view that supports a template parameter to specify a pre-compiled
 * template function as the template setting. The template function does not
 * have to be any specific template engine. It only needs to be a function
 * that returns valid HTML as a string from the data parameter passed to
 * the function.
 * @param {?} data
 * @return {string}
 */
Marionette.Renderer.render = function(template, data) {};

/**
 * @constructor
 * @struct
 * @param {!Backbone.ViewOptions<TModel>=} options
 */
Marionette.View = function(options) {};
 /** @type {?} */
Marionette.View.prototype.behaviors;
 /** @type {!Object<string,?>} */
Marionette.View.prototype.triggers;
 /** @type {?} */
Marionette.View.prototype.modelEvents;
 /** @type {?} */
Marionette.View.prototype.collectionEvents;
 /** @type {?} */
Marionette.View.prototype.ui;
 /** @type {boolean} */
Marionette.View.prototype.supportsRenderLifecycle;
 /** @type {boolean} */
Marionette.View.prototype.supportsDestroyLifecycle;
 /** @type {?} */
Marionette.View.prototype.regionClass;
 /** @type {string} */
Marionette.View.prototype.childViewEventPrefix;

/**
 * There may be some cases where you need to change the template that is
 * used for a view, based on some simple logic such as the value of a
 * specific attribute in the view's model. To do this, you can provide a
 * getTemplate function on your views and use this to return the template
 * that you need.
 * @return {?}
 */
Marionette.View.prototype.getTemplate = function() {};

/**
 * Retrieve an object's attribute either directly from the object, or
 * from the object's this.options, with this.options taking precedence.
 * @template T
 * @param {string} optionName
 * @return {T}
 */
Marionette.View.prototype.getOption = function(optionName) {};

/**
 * @param {?=} target
 * @return {?}
 */
Marionette.View.prototype.mixinTemplateHelpers = function(target) {};

/**
 * @return {?}
 */
Marionette.View.prototype.configureTriggers = function() {};

/**
 * View implements a destroy method, which is called by the region managers automatically. As part of the implementation.
 * @param {...?} args
 * @return {!Marionette.View}
 */
Marionette.View.prototype.destroy = function(args) {};

/**
 * In several cases you need to access ui elements inside the view to
 * retrieve their data or manipulate them. For example you have a certain
 * div element you need to show/hide based on some state, or other ui
 * element that you wish to set a css class to it. Instead of having jQuery
 * selectors hanging around in the view's code you can define a ui hash
 * that contains a mapping between the ui element's name and its jQuery
 * selector. Afterwards you can simply access it via this.ui.elementName.
 * This functionality is provided via the bindUIElements method.
 * Since View doesn't implement the render method, then if you directly
 * extend from View you will need to invoke this method from your render
 * method. In ItemView and CompositeView this is already taken care of.
 * @return {?}
 */
Marionette.View.prototype.bindUIElements = function() {};

/**
 * @return {?}
 */
Marionette.View.prototype.unbindUIElements = function() {};

/**
 * @param {string} name
 * @param {...?} args
 * @return {?}
 */
Marionette.View.prototype.triggerMethod = function(name, args) {};

/**
 * Item views will serialize a model or collection, by default, by calling
 * .toJSON on either the model or collection. If both a model and
 * collection are attached to an item view, the model will be used as the
 * data source. The results of the data serialization will be passed to
 * the template that is rendered.
 * 
 * If you need custom serialization for your data, you can provide a serializeData
 * method on your view. It must return a valid JSON object, as if you had
 * called .toJSON on a model or collection.
 * @return {?}
 */
Marionette.View.prototype.serializeData = function() {};

/**
 * Renders the view. It is unwise to override the render method of any
 * Marionette view. Instead, you should use the onBeforeRender and
 * onRender callbacks to layer in additional functionality to the
 * rendering of your view.
 * @return {?}
 */
Marionette.View.prototype.render = function() {};

/**
 * Triggered before an ItemView is rendered.
 * @return {void}
 */
Marionette.View.prototype.onBeforeRender = function() {};

/**
 * Triggered after the view has been rendered. You can implement this in
 * your view to provide custom code for dealing with the view's el after
 * it has been rendered.
 * @return {void}
 */
Marionette.View.prototype.onRender = function() {};

/**
 * Triggered just after the view has been destroyed.
 * @return {void}
 */
Marionette.View.prototype.onDestroy = function() {};

/**
 * When destroying a view, an onBeforeDestroy method will be called, if
 * it has been provided, just before the view destroys. It will be passed
 * any arguments that destroy was invoked with.
 * @param {...?} args
 * @return {void}
 */
Marionette.View.prototype.onBeforeDestroy = function(args) {};

/**
 * Called anytime that showing the view in a Region causes it to be
 * attached to the document.
 * @return {void}
 */
Marionette.View.prototype.onAttach = function() {};

/**
 * Triggered right before the view is attached to the document.
 * @return {void}
 */
Marionette.View.prototype.onBeforeAttach = function() {};

/**
 * Triggered after the view has been rendered, has been shown in the DOM via a Marionette.Region, and has been re-rendered.
 * This event / callback is useful for DOM-dependent UI plugins such as jQueryUI or KendoUI.
 * @return {void}
 */
Marionette.View.prototype.onDomRefresh = function() {};

/**
 * Internal properties extended in Marionette.View.
 * @return {boolean}
 */
Marionette.View.prototype.isDestroyed = function() {};

/**
 * @return {boolean}
 */
Marionette.View.prototype.isRendered = function() {};

/**
 * @return {boolean}
 */
Marionette.View.prototype.isAttached = function() {};

/**
 * @return {!Marionette.View}
 */
Marionette.View.prototype.delegateEntityEvents = function() {};

/**
 * Regions hash or a method returning the regions hash that maps
 * regions/selectors to methods on your View.
 * 
 * @return {?}
 */
Marionette.View.prototype.regions = function() {};

/**
 * Adds a region to the layout view.
 * @param {string} name
 * @param {?} definition
 * @return {!Marionette.Region}
 */
Marionette.View.prototype.addRegion = function(name, definition) {};

/**
 * Add multiple regions as a {name: definition, name2: def2} object literal.
 * @param {?} regions
 * @return {?}
 */
Marionette.View.prototype.addRegions = function(regions) {};

/**
 * Returns a region from the layout view
 * @param {string} name
 * @return {!Marionette.Region}
 */
Marionette.View.prototype.getRegion = function(name) {};

/**
 * Removes the region with the specified name.
 * @param {string} name the name of the region to remove.
 * @return {!Marionette.Region}
 */
Marionette.View.prototype.removeRegion = function(name) {};

/**
 * Enable easy overriding of the default `RegionManager`
 * for customized region interactions and business specific
 * view logic for better control over single regions.
 * @return {!Marionette.RegionManager}
 */
Marionette.View.prototype.getRegionManager = function() {};

/**
 * Show a view into the region specified by `regionName`.
 * @param {string} regionName
 * @param {?} view
 * @param {!Marionette.RegionShowOptions=} options
 * @return {void}
 */
Marionette.View.prototype.showChildView = function(regionName, view, options) {};

/**
 * Get the current view that is shown in the region specified by
 * `regionName`.
 * @param {string} regionName
 * @return {!Backbone.View<TModel>}
 */
Marionette.View.prototype.getChildView = function(regionName) {};

/**
 * Returns all regions from the layout view. The results contains an
 * Object hash that has `string`s as keys and `Region`s as values.
 * @return {!Object<string,!Marionette.Region>}
 */
Marionette.View.prototype.getRegions = function() {};
/**
 * @extends {Backbone.ViewOptions}
 * @record
 * @struct
 */
Marionette.CollectionViewOptions = function() {};
 /** @type {boolean} */
Marionette.CollectionViewOptions.prototype.sort;
 /** @type {boolean} */
Marionette.CollectionViewOptions.prototype.reorderOnSort;

/**
 * @constructor
 * @struct
 * @param {!Marionette.CollectionViewOptions<TModel>=} options
 */
Marionette.CollectionView = function(options) {};
 /** @type {function(new: (TView), !Array<?>): ?} */
Marionette.CollectionView.prototype.childView;
 /** @type {?} */
Marionette.CollectionView.prototype.childViewOptions;
 /** @type {string} */
Marionette.CollectionView.prototype.childViewEventPrefix;
 /** @type {?} */
Marionette.CollectionView.prototype.childViewEvents;
 /** @type {?} */
Marionette.CollectionView.prototype.emptyView;
 /** @type {?} */
Marionette.CollectionView.prototype.emptyViewOptions;
 /** @type {!ChildViewContainer<TView>} */
Marionette.CollectionView.prototype.children;

/**
 * The render method of the collection view is responsible for rendering the
 * entire collection. It loops through each of the children in the collection
 * and renders them individually as an childView.
 * @return {!Marionette.CollectionView}
 */
Marionette.CollectionView.prototype.render = function() {};

/**
 * The addChild method is responsible for rendering the childViews and
 * adding them to the HTML for the collectionView instance. It is also
 * responsible for triggering the events per ChildView. In most cases you
 * should not override this method.
 * @param {?} item
 * @param {TView} ChildView
 * @param {!Number} index
 * @return {void}
 */
Marionette.CollectionView.prototype.addChild = function(item, ChildView, index) {};

/**
 * Render the child view
 * @param {TView} view
 * @param {!Number} index
 * @return {void}
 */
Marionette.CollectionView.prototype.renderChildView = function(view, index) {};

/**
 * When a custom view instance needs to be created for the childView that
 * represents a child, override the buildChildView method. This method
 * takes three parameters and returns a view instance to be used as the
 * child view.
 * @param {?} child
 * @param {?} ItemViewType
 * @param {?} itemViewOptions
 * @return {TView}
 */
Marionette.CollectionView.prototype.buildChildView = function(child, ItemViewType, itemViewOptions) {};

/**
 * Remove the child view and destroy it. This function also updates the indices of
 * later views in the collection in order to keep the children in sync with the collection.
 * @param {TView} view
 * @return {TView}
 */
Marionette.CollectionView.prototype.removeChildView = function(view) {};

/**
 * Determines if the view is empty. If you want to control when the empty
 * view is rendered, you can override isEmpty.
 * @return {boolean}
 */
Marionette.CollectionView.prototype.isEmpty = function() {};

/**
 * If empty, show the empty view
 * @return {void}
 */
Marionette.CollectionView.prototype.checkEmpty = function() {};

/**
 * Destroy the child views that this collection view
 * is holding on to, if any. This returns destroyed children.
 * @return {!ChildViewContainer<TView>}
 */
Marionette.CollectionView.prototype.destroyChildren = function() {};

/**
 * By default the CollectionView will maintain the order of its collection
 * in the DOM. However on occasions the view may need to re-render to make
 * this possible, for example if you were to change the comparator on the
 * collection. By default CollectionView will call render when this happens,
 * but there are cases where this may not be suitable. For instance when
 * sorting the children in a CompositeView, you want to only render the
 * internal collection.
 * @return {void}
 */
Marionette.CollectionView.prototype.resortView = function() {};

/**
 * By default the collection view will append the HTML of each ChildView
 * into the element buffer, and then call jQuery's .append once at the end
 * to move the HTML into the collection view's el.
 * You can override this by specifying an attachHtml method in your view
 * definition.
 * @param {!Marionette.CollectionView} collectionView the instance of the collection view that will receive the HTML.
 * @param {TView} childView the current child view instance.
 * @param {number} index he index of the model that this childView instance represents,
 * in the collection that the model came from. This is useful for sorting
 * a collection and displaying the sorted list in the correct order on the
 * screen.
 * @return {void}
 */
Marionette.CollectionView.prototype.attachHtml = function(collectionView, childView, index) {};

/**
 * Serialize a collection by serializing each of its models.
 * @return {?}
 */
Marionette.CollectionView.prototype.serializeCollection = function() {};

/**
 * Reorder DOM after sorting. When your element's rendering
 * do not use their index, you can pass reorderOnSort: true
 * to only reorder the DOM after a sort instead of rendering
 * all the collectionView
 * @return {void}
 */
Marionette.CollectionView.prototype.reorder = function() {};

/**
 * Render and show the emptyView. Similar to addChild method
 * but "add:child" events are not fired, and the event from
 * emptyView are not forwarded
 * @param {TModel} child
 * @param {function(new: (?), !Array<?>): ?} EmptyView
 * @return {void}
 */
Marionette.CollectionView.prototype.addEmptyView = function(child, EmptyView) {};

/**
 * Handle cleanup and other destroying needs for the collection of views
 * @return {!Marionette.CollectionView}
 */
Marionette.CollectionView.prototype.destroy = function() {};

/**
 * Set up the child view event forwarding. Uses a "childview:"
 * prefix in front of all forwarded events.
 * @param {?} view it might be ChildView or EmptyView.
 * @return {void}
 */
Marionette.CollectionView.prototype.proxyChildEvents = function(view) {};

/**
 * Called just prior to rendering the collection view.
 * @return {void}
 */
Marionette.CollectionView.prototype.onBeforeRender = function() {};

/**
 * Triggered after the view has been rendered. You can implement this in
 * your view to provide custom code for dealing with the view's el after
 * it has been rendered.
 * @return {void}
 */
Marionette.CollectionView.prototype.onRender = function() {};

/**
 * This callback function allows you to know when a child / child view
 * instance is about to be added to the collection view. It provides
 * access to the view instance for the child that was added.
 * @param {TView} childView
 * @return {void}
 */
Marionette.CollectionView.prototype.onBeforeAddChild = function(childView) {};

/**
 * This callback function allows you to know when a child / child view
 * instance has been added to the collection view. It provides access to
 * the view instance for the child that was added.
 * @param {TView} childView
 * @return {void}
 */
Marionette.CollectionView.prototype.onAddChild = function(childView) {};

/**
 * This callback function allows you to know when a childView instance is
 * about to be removed from the collectionView. It provides access to the
 * view instance for the child that was removed.
 * @param {TView} childView
 * @return {void}
 */
Marionette.CollectionView.prototype.onBeforeRemoveChild = function(childView) {};

/**
 * This callback function allows you to know when a child / childView
 * instance has been deleted or removed from the collection.
 * @param {TView} childView
 * @return {void}
 */
Marionette.CollectionView.prototype.onRemoveChild = function(childView) {};
/**
 * @extends {Backbone.RouterOptions}
 * @record
 * @struct
 */
Marionette.AppRouterOptions = function() {};
 /** @type {?} */
Marionette.AppRouterOptions.prototype.appRoutes;
 /** @type {?} */
Marionette.AppRouterOptions.prototype.controller;

/**
 * @constructor
 * @struct
 * Configure an AppRouter with appRoutes. The route definition
 * is passed on to Backbone's standard routing handlers. This means
 * that you define routes like you normally would. However, instead of
 * providing a callback method that exists on the router, you provide a
 * callback method that exists on the controller, which you specify for
 * the router instance (see below.)
 * @param {!Marionette.AppRouterOptions=} options
 */
Marionette.AppRouter = function(options) {};

/**
 * You can specify a controller with the multiple routes at runtime with
 * this method. However, In this case the current controller of AppRouter
 * will not change.
 * @param {?} controller
 * @param {?} appRoutes
 * @return {void}
 */
Marionette.AppRouter.prototype.processAppRoutes = function(controller, appRoutes) {};

/**
 * Adds an app route at runtime to this instance. It works the same as the
 * built-in router.route() call from Backbone's Router, but has all the
 * same semantics and behavior of the appRoutes configuration.
 * @param {string} route
 * @param {string} methodName
 * @return {void}
 */
Marionette.AppRouter.prototype.appRoute = function(route, methodName) {};

/**
 * @constructor
 * @struct
 * @param {?=} options
 */
Marionette.Application = function(options) {};
 /** @type {!Wreqr.EventAggregator} */
Marionette.Application.prototype.vent;
 /** @type {!Wreqr.Commands} */
Marionette.Application.prototype.commands;
 /** @type {!Wreqr.RequestResponse} */
Marionette.Application.prototype.reqres;
 /** @type {?} */
Marionette.Application.prototype.submodules;
 /** @type {string} */
Marionette.Application.prototype.region;

/**
 * Command execution, facilitated by Backbone.Wreqr.Commands
 * @param {...?} args
 * @return {void}
 */
Marionette.Application.prototype.execute = function(args) {};

/**
 * Request/response, facilitated by Backbone.Wreqr.RequestResponse
 * @param {...?} args
 * @return {?}
 */
Marionette.Application.prototype.request = function(args) {};

/**
 * Deprecated! Initializers, you should use events to manage start-up logic.
 * @param {?} initializer
 * @return {void}
 */
Marionette.Application.prototype.addInitializer = function(initializer) {};

/**
 * Once you have your application configured, you can kick everything off
 * by calling this method.
 * @param {?=} options This parameter will be passed to each of your initializer functions, as well as the initialize events. This allows you to provide extra configuration for various parts of your app throughout the initialization sequence.
 * @return {void}
 */
Marionette.Application.prototype.start = function(options) {};

/**
 * Get the root region
 * @return {!Marionette.Region}
 */
Marionette.Application.prototype.getRegion = function() {};

/**
 * Show a view in the root region
 * @param {!Backbone.View<!Backbone.Model>} view
 * @return {void}
 */
Marionette.Application.prototype.showView = function(view) {};

/**
 * Get the view from the root region
 * @return {?}
 */
Marionette.Application.prototype.getView = function() {};

/**
 * @param {?} moduleNames
 * @param {?} moduleDefinition
 * @return {!Marionette.Module}
 */
Marionette.Application.prototype.module = function(moduleNames, moduleDefinition) {};

/**
 * Called just before the Application starts and before the initializers are executed.
 * @param {?=} options
 * @return {void}
 */
Marionette.Application.prototype.onBeforeStart = function(options) {};

/**
 * Called after the Application has started and after the initializers have been executed.
 * @param {?=} options
 * @return {void}
 */
Marionette.Application.prototype.onStart = function(options) {};

/**
 * @constructor
 * @struct
 * @param {string} moduleName
 * @param {!Marionette.Application} app
 */
Marionette.Module = function(moduleName, app) {};
 /** @type {?} */
Marionette.Module.prototype.submodules;

/**
 * @param {string} name
 * @param {...?} args
 * @return {?}
 */
Marionette.Module.prototype.triggerMethod = function(name, args) {};

/**
 * @param {?} callback
 * @return {void}
 */
Marionette.Module.prototype.addInitializer = function(callback) {};

/**
 * @param {?} callback
 * @return {void}
 */
Marionette.Module.prototype.addFinalizer = function(callback) {};

/**
 * @param {?=} options
 * @return {void}
 */
Marionette.Module.prototype.start = function(options) {};

/**
 * @param {?} moduleDefinition
 * @param {?} customArgs
 * @return {?}
 */
Marionette.Module.prototype.addDefinition = function(moduleDefinition, customArgs) {};

/**
 * @constructor
 * @struct
 * @param {?=} options
 * @param {?=} view
 */
Marionette.Behavior = function(options, view) {};
 /** @type {?} */
Marionette.Behavior.prototype.options;
 /** @type {?} */
Marionette.Behavior.prototype.ui;
 /** @type {?} */
Marionette.Behavior.prototype.triggers;
 /** @type {?} */
Marionette.Behavior.prototype.modelEvents;
 /** @type {?} */
Marionette.Behavior.prototype.collectionEvents;
 /** @type {?} */
Marionette.Behavior.prototype.behaviors;
 /** @type {?} */
Marionette.Behavior.prototype.defaults;
 /** @type {?} */
Marionette.Behavior.prototype.el;
 /** @type {?<!HTMLElement>} */
Marionette.Behavior.prototype.$el;
 /** @type {?} */
Marionette.Behavior.prototype.view;

/**
 * $ is a direct proxy of the views $ lookup method.
 * @param {?} selector
 * @return {?<!HTMLElement>}
 */
Marionette.Behavior.prototype.$ = function(selector) {};
/**
 * @constructor
 * @struct
 */
Marionette.Behaviors = function() {};

/**
 * This method defines where your behavior classes are stored. Override this to provide another lookup.
 * @return {?}
 */
Marionette.Behaviors.behaviorsLookup = function() {};

/**
 * This method has a default implementation that is simple to override. It
 * is responsible for the lookup of single behavior from within the
 * Behaviors.behaviorsLookup or elsewhere. Note that it should return the type of the
 * class to instantiate, not an instance of that class.
 * @param {?} options
 * @param {string} key
 * @return {?}
 */
Marionette.Behaviors.getBehaviorClass = function(options, key) {};
