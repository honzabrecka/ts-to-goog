/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/browserify/index.d.ts:

/* TODO: ImportEqualsDeclaration in  */
 /** @type {!browserify.BrowserifyConstructor} */
var browserify;

/* TODO: ExportAssignment in  */
/**
 * @record
 * @struct
 */
browserify.FileOptions = function() {};
 /** @type {boolean} */
browserify.FileOptions.prototype.entry;
 /** @type {string} */
browserify.FileOptions.prototype.expose;
 /** @type {string} */
browserify.FileOptions.prototype.basedir;
 /** @type {string} */
browserify.FileOptions.prototype.file;
 /** @type {boolean} */
browserify.FileOptions.prototype.external;
 /** @type {boolean} */
browserify.FileOptions.prototype.transform;
 /** @type {string} */
browserify.FileOptions.prototype.id;

/** @typedef {(string|!NodeJS.ReadableStream|!browserify.FileOptions)} */
browserify.InputFile;
/**
 * @record
 * @struct
 */
browserify.CustomOptions = function() {};

/* TODO: IndexSignature: browserify */
 /** @type {string} */
browserify.CustomOptions.prototype.basedir;
/**
 * @extends {browserify.CustomOptions}
 * @record
 * @struct
 */
browserify.Options = function() {};
 /** @type {(string|!NodeJS.ReadableStream|!browserify.FileOptions|!Array<(string|!NodeJS.ReadableStream|!browserify.FileOptions)>)} */
browserify.Options.prototype.entries;
 /** @type {!Array<string>} */
browserify.Options.prototype.noParse;
 /** @type {!Array<string>} */
browserify.Options.prototype.extensions;
 /** @type {!Array<string>} */
browserify.Options.prototype.paths;
 /** @type {boolean} */
browserify.Options.prototype.commondir;
 /** @type {boolean} */
browserify.Options.prototype.fullPaths;
 /** @type {(boolean|!Array<string>|!Object<string,string>)} */
browserify.Options.prototype.builtins;
 /** @type {boolean} */
browserify.Options.prototype.bundleExternal;
 /** @type {boolean} */
browserify.Options.prototype.insertGlobals;
 /** @type {boolean} */
browserify.Options.prototype.detectGlobals;
 /** @type {boolean} */
browserify.Options.prototype.debug;
 /** @type {string} */
browserify.Options.prototype.standalone;
 /** @type {!InsertModuleGlobals.VarsOption} */
browserify.Options.prototype.insertGlobalVars;
 /** @type {string} */
browserify.Options.prototype.externalRequireName;
/**
 * @record
 * @struct
 */
browserify.BrowserifyConstructor = function() {};

/* TODO: CallSignature: browserify */

/* TODO: CallSignature: browserify */

/* TODO: CallSignature: browserify */

/* TODO: ConstructSignature: browserify */

/* TODO: ConstructSignature: browserify */

/* TODO: ConstructSignature: browserify */
/**
 * @record
 * @struct
 */
browserify.BrowserifyObject = function() {};
 /** @type {?} */
browserify.BrowserifyObject.prototype.pipeline;

/**
 * Add an entry file from file that will be executed when the bundle loads.
 * If file is an array, each item in file will be added as an entry file.
 * @param {!Array<(string|!NodeJS.ReadableStream|!browserify.FileOptions)>|(string|!NodeJS.ReadableStream|!browserify.FileOptions)} file
 * @param {!browserify.FileOptions=} opts
 * @return {!browserify.BrowserifyObject}
 */
browserify.BrowserifyObject.prototype.add = function(file, opts) {};

/**
 * Make file available from outside the bundle with require(file).
 * The file param is anything that can be resolved by require.resolve().
 * file can also be a stream, but you should also use opts.basedir so that relative requires will be resolvable.
 * If file is an array, each item in file will be required. In file array form, you can use a string or object for each item. Object items should have a file property and the rest of the parameters will be used for the opts.
 * Use the expose property of opts to specify a custom dependency name. require('./vendor/angular/angular.js', {expose: 'angular'}) enables require('angular')
 * @param {(string|!NodeJS.ReadableStream|!browserify.FileOptions)} file
 * @param {!browserify.FileOptions=} opts
 * @return {!browserify.BrowserifyObject}
 */
browserify.BrowserifyObject.prototype.require = function(file, opts) {};

/**
 * Bundle the files and their dependencies into a single javascript file.
 * Return a readable stream with the javascript file contents or optionally specify a cb(err, buf) to get the buffered results.
 * @param {function(?, ?): ?=} cb
 * @return {!NodeJS.ReadableStream}
 */
browserify.BrowserifyObject.prototype.bundle = function(cb) {};

/**
 * Prevent file from being loaded into the current bundle, instead referencing from another bundle.
 * If file is an array, each item in file will be externalized.
 * If file is another bundle, that bundle's contents will be read and excluded from the current bundle as the bundle in file gets bundled.
 * @param {!Array<string>|string|!browserify.BrowserifyObject} file
 * @param {!browserify.CustomOptions=} opts
 * @return {!browserify.BrowserifyObject}
 */
browserify.BrowserifyObject.prototype.external = function(file, opts) {};

/**
 * Prevent the module name or file at file from showing up in the output bundle.
 * Instead you will get a file with module.exports = {}.
 * @param {string} file
 * @param {!browserify.CustomOptions=} opts
 * @return {!browserify.BrowserifyObject}
 */
browserify.BrowserifyObject.prototype.ignore = function(file, opts) {};

/**
 * Prevent the module name or file at file from showing up in the output bundle.
 * If your code tries to require() that file it will throw unless you've provided another mechanism for loading it.
 * @param {string} file
 * @param {!browserify.CustomOptions=} opts
 * @return {!browserify.BrowserifyObject}
 */
browserify.BrowserifyObject.prototype.exclude = function(file, opts) {};

/**
 * Transform source code before parsing it for require() calls with the transform function or module name tr.
 * If tr is a function, it will be called with tr(file) and it should return a through-stream that takes the raw file contents and produces the transformed source.
 * If tr is a string, it should be a module name or file path of a transform module
 * @template T
 * @param {string|function(string, T): !NodeJS.ReadWriteStream} tr
 * @param {T=} opts
 * @return {!browserify.BrowserifyObject}
 */
browserify.BrowserifyObject.prototype.transform = function(tr, opts) {};

/**
 * Register a plugin with opts. Plugins can be a string module name or a function the same as transforms.
 * plugin(b, opts) is called with the Browserify instance b.
 * @template T
 * @param {string|function(!browserify.BrowserifyObject, T): ?} plugin
 * @param {T=} opts
 * @return {!browserify.BrowserifyObject}
 */
browserify.BrowserifyObject.prototype.plugin = function(plugin, opts) {};

/**
 * Reset the pipeline back to a normal state. This function is called automatically when bundle() is called multiple times.
 * This function triggers a 'reset' event.
 * @param {!browserify.Options=} opts
 * @return {void}
 */
browserify.BrowserifyObject.prototype.reset = function(opts) {};

/**
 * When a file is resolved for the bundle, the bundle emits a 'file' event with the full file path, the id string passed to require(), and the parent object used by browser-resolve.
 * You could use the file event to implement a file watcher to regenerate bundles when files change.
 * When a package.json file is read, this event fires with the contents.
 * The package directory is available at pkg.__dirname.
 * When .bundle() is called, this event fires with the bundle output stream.
 * When the .reset() method is called or implicitly called by another call to .bundle(), this event fires.
 * When a transform is applied to a file, the 'transform' event fires on the bundle stream with the transform stream tr and the file that the transform is being applied to.
 * @param {string} event
 * @param {function(string, string, ?): ?|function(?): ?|function(!NodeJS.ReadableStream): ?|function(): ?|function(!NodeJS.ReadWriteStream, string): ?|!Function} listener
 * @return {BrowserifyObject}
 */
browserify.BrowserifyObject.prototype.on = function(event, listener) {};
