/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/paho-mqtt/index.d.ts:
/** @const */
var Paho = {};
/** @const */
Paho.MQTT = {};

/** @typedef {number} */
Paho.MQTT.Qos;
/**
 * @record
 * @struct
 */
Paho.MQTT.MQTTError = function() {};
 /** @type {number} */
Paho.MQTT.MQTTError.prototype.errorCode;
 /** @type {string} */
Paho.MQTT.MQTTError.prototype.errorMessage;
/**
 * @record
 * @struct
 */
Paho.MQTT.WithInvocationContext = function() {};
 /** @type {?} */
Paho.MQTT.WithInvocationContext.prototype.invocationContext;
/**
 * @extends {Paho.MQTT.MQTTError}
 * @extends {Paho.MQTT.WithInvocationContext}
 * @record
 * @struct
 */
Paho.MQTT.ErrorWithInvocationContext = function() {};
/**
 * @extends {Paho.MQTT.WithInvocationContext}
 * @record
 * @struct
 */
Paho.MQTT.OnSubscribeSuccessParams = function() {};
 /** @type {number} */
Paho.MQTT.OnSubscribeSuccessParams.prototype.grantedQos;

/** @typedef {function(!Paho.MQTT.WithInvocationContext): void} */
Paho.MQTT.OnSuccessCallback;

/** @typedef {function(!Paho.MQTT.OnSubscribeSuccessParams): void} */
Paho.MQTT.OnSubscribeSuccessCallback;

/** @typedef {function(!Paho.MQTT.ErrorWithInvocationContext): void} */
Paho.MQTT.OnFailureCallback;

/** @typedef {function(!Paho.MQTT.MQTTError): void} */
Paho.MQTT.OnConnectionLostHandler;

/** @typedef {function(!Paho.MQTT.Message): void} */
Paho.MQTT.OnMessageHandler;
/**
 * @record
 * @struct
 */
Paho.MQTT.ConnectionOptions = function() {};
 /** @type {number} */
Paho.MQTT.ConnectionOptions.prototype.timeout;
 /** @type {string} */
Paho.MQTT.ConnectionOptions.prototype.userName;
 /** @type {string} */
Paho.MQTT.ConnectionOptions.prototype.password;
 /** @type {!Paho.MQTT.Message} */
Paho.MQTT.ConnectionOptions.prototype.willMessage;
 /** @type {number} */
Paho.MQTT.ConnectionOptions.prototype.keepAliveInterval;
 /** @type {boolean} */
Paho.MQTT.ConnectionOptions.prototype.cleanSession;
 /** @type {boolean} */
Paho.MQTT.ConnectionOptions.prototype.useSSL;
 /** @type {?} */
Paho.MQTT.ConnectionOptions.prototype.invocationContext;
 /** @type {function(!Paho.MQTT.WithInvocationContext): void} */
Paho.MQTT.ConnectionOptions.prototype.onSuccess;
 /** @type {number} */
Paho.MQTT.ConnectionOptions.prototype.mqttVersion;
 /** @type {function(!Paho.MQTT.ErrorWithInvocationContext): void} */
Paho.MQTT.ConnectionOptions.prototype.onFailure;
 /** @type {!Array<string>} */
Paho.MQTT.ConnectionOptions.prototype.hosts;
 /** @type {!Array<number>} */
Paho.MQTT.ConnectionOptions.prototype.ports;
/**
 * @record
 * @struct
 */
Paho.MQTT.SubscribeOptions = function() {};
 /** @type {number} */
Paho.MQTT.SubscribeOptions.prototype.qos;
 /** @type {?} */
Paho.MQTT.SubscribeOptions.prototype.invocationContext;
 /** @type {function(!Paho.MQTT.OnSubscribeSuccessParams): void} */
Paho.MQTT.SubscribeOptions.prototype.onSuccess;
 /** @type {function(!Paho.MQTT.ErrorWithInvocationContext): void} */
Paho.MQTT.SubscribeOptions.prototype.onFailure;
 /** @type {number} */
Paho.MQTT.SubscribeOptions.prototype.timeout;
/**
 * @record
 * @struct
 */
Paho.MQTT.UnsubscribeOptions = function() {};
 /** @type {?} */
Paho.MQTT.UnsubscribeOptions.prototype.invocationContext;
 /** @type {function(!Paho.MQTT.WithInvocationContext): void} */
Paho.MQTT.UnsubscribeOptions.prototype.onSuccess;
 /** @type {function(!Paho.MQTT.ErrorWithInvocationContext): void} */
Paho.MQTT.UnsubscribeOptions.prototype.onFailure;
 /** @type {number} */
Paho.MQTT.UnsubscribeOptions.prototype.timeout;
/**
 * @record
 * @struct
 */
Paho.MQTT.TraceElement = function() {};
 /** @type {string} */
Paho.MQTT.TraceElement.prototype.severity;
 /** @type {string} */
Paho.MQTT.TraceElement.prototype.message;

/** @typedef {function(!Paho.MQTT.TraceElement): void} */
Paho.MQTT.TraceFunction;

/**
 * @constructor
 * @struct
 * @param {string} host_or_hostUri - the address of the messaging server as a DNS name or dotted decimal IP address. / - the address of the messaging server as a fully qualified WebSocket URI
 * @param {number|string} port_or_clientId - the port number to connect to / - the Messaging client identifier, between 1 and 23 characters in length.
 * @param {string=} path_or_clientId - the path on the host to connect to - only used if host is not a URI. Default: '/mqtt'. / - the Messaging client identifier, between 1 and 23 characters in length.
 * @param {string=} clientId - the Messaging client identifier, between 1 and 23 characters in length.
 */
Paho.MQTT.Client = function(host_or_hostUri, port_or_clientId, path_or_clientId, clientId) {};
 /** @type {string} */
Paho.MQTT.Client.prototype.clientId;
 /** @type {string} */
Paho.MQTT.Client.prototype.host;
 /** @type {string} */
Paho.MQTT.Client.prototype.path;
 /** @type {number} */
Paho.MQTT.Client.prototype.port;
 /** @type {function(!Paho.MQTT.TraceElement): void} */
Paho.MQTT.Client.prototype.trace;
 /** @type {function(!Paho.MQTT.MQTTError): void} */
Paho.MQTT.Client.prototype.onConnectionLost;
 /** @type {function(!Paho.MQTT.Message): void} */
Paho.MQTT.Client.prototype.onMessageDelivered;
 /** @type {function(!Paho.MQTT.Message): void} */
Paho.MQTT.Client.prototype.onMessageArrived;

/**
 * Connect this Messaging client to its server.
 * @throws {InvalidState} if the client is not in disconnected state. The client must have received
 *      connectionLost or disconnected before calling connect for a second or subsequent time.
 * @param {!Paho.MQTT.ConnectionOptions=} connectionOptions
 * @return {void}
 */
Paho.MQTT.Client.prototype.connect = function(connectionOptions) {};

/**
 * Normal disconnect of this Messaging client from its server.
 * 
 * @throws {InvalidState} if the client is already disconnected.
 * @return {void}
 */
Paho.MQTT.Client.prototype.disconnect = function() {};

/**
 * @return {boolean} True if the client is currently connected
 */
Paho.MQTT.Client.prototype.isConnected = function() {};

/**
 * Get the contents of the trace log.
 * 
 *  \@return {Object[]} tracebuffer containing the time ordered trace records.
 * @return {!Array<?>}
 */
Paho.MQTT.Client.prototype.getTraceLog = function() {};

/**
 * Start tracing.
 * @return {void}
 */
Paho.MQTT.Client.prototype.startTrace = function() {};

/**
 * Stop tracing.
 * @return {void}
 */
Paho.MQTT.Client.prototype.stopTrace = function() {};

/**
 * Send a message to the consumers of the destination in the Message.
 * 
 * @throws {InvalidState} if the client is not connected.
 * Send a message to the consumers of the destination in the Message.
 * 
 *        <dl>
 *            <dt>0 Best effort (default).
 *            <dt>1 At least once.
 *            <dt>2 Exactly once.
 *        </dl>
 * current and future subscriptions. If false the server only delivers the message to current subscribers,
 * this is the default for new Messages. A received message has the retained boolean set to true if the
 * message was published with the retained boolean set to true and the subscrption was made after the
 * message has been published.
 * @throws {InvalidState} if the client is not connected.
 * @param {!Paho.MQTT.Message|string} message_or_topic
 * @param {(string|!ArrayBuffer)=} payload
 * @param {number=} qos
 * @param {boolean=} retained
 * @return {void}
 */
Paho.MQTT.Client.prototype.send = function(message_or_topic, payload, qos, retained) {};

/**
 * Subscribe for messages, request receipt of a copy of messages sent to the destinations described by the
 * filter.
 * 
 * @throws {InvalidState} if the client is not in connected state.
 * @param {string} filter A filter describing the destinations to receive messages from.
 * @param {!Paho.MQTT.SubscribeOptions=} subcribeOptions Used to control the subscription
 * @return {void}
 */
Paho.MQTT.Client.prototype.subscribe = function(filter, subcribeOptions) {};

/**
 * Unsubscribe for messages, stop receiving messages sent to destinations described by the filter.
 * 
 * @throws {InvalidState} if the client is not in connected state.
 * @param {string} filter - describing the destinations to receive messages from.
 * @param {!Paho.MQTT.UnsubscribeOptions=} unsubcribeOptions
 * @return {void}
 */
Paho.MQTT.Client.prototype.unsubscribe = function(filter, unsubcribeOptions) {};

/**
 * @constructor
 * @struct
 * @param {(string|!ArrayBuffer)} payload
 */
Paho.MQTT.Message = function(payload) {};
 /** @type {string} */
Paho.MQTT.Message.prototype.destinationName;
 /** @type {boolean} */
Paho.MQTT.Message.prototype.duplicate;
 /** @type {!ArrayBuffer} */
Paho.MQTT.Message.prototype.payloadBytes;
 /** @type {string} */
Paho.MQTT.Message.prototype.payloadString;
 /** @type {number} */
Paho.MQTT.Message.prototype.qos;
 /** @type {boolean} */
Paho.MQTT.Message.prototype.retained;
