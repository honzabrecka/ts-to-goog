/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/oracledb/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */
/** @const */
var oracledb = {};

/** @typedef {(T|!oracledb.IPromise<T>)} */
oracledb.TRet;

/** @typedef {function(T): (R|!oracledb.IPromise<R>)} */
oracledb.TFunc;
/**
 * @record
 * @struct
 */
oracledb.IPromise = function() {};

/**
 * @template R
 * @param {function(?): (R|!oracledb.IPromise<R>)} onReject
 * @return {!oracledb.IPromise<R>}
 */
oracledb.IPromise.prototype.catch = function(onReject) {};

/**
 * @template R
 * @param {function(T): (R|!oracledb.IPromise<R>)=} onResolve
 * @param {function(?): (R|!oracledb.IPromise<R>)=} onReject
 * @return {!oracledb.IPromise<R>}
 */
oracledb.IPromise.prototype.then = function(onResolve, onReject) {};
/**
 * @record
 * @struct
 */
oracledb.ILob = function() {};
 /** @type {number} */
oracledb.ILob.prototype.chunkSize;
 /** @type {number} */
oracledb.ILob.prototype.length;
 /** @type {number} */
oracledb.ILob.prototype.pieceSize;
 /** @type {number} */
oracledb.ILob.prototype.offset;
 /** @type {string} */
oracledb.ILob.prototype.type;

/**
 * Release method on ILob class.
 * \@remarks The cleanup() called by Release() only frees OCI error handle and Lob
 *          locator.  These calls acquire mutex on OCI environment handle very briefly.
 * @return {void}
 */
oracledb.ILob.prototype.release = function() {};

/**
 * Read method on ILob class.
 * \@remarks CLobs send strings while BLobs send Buffer object.
 * @param {function(?, (string|?)): void} callback
 * @return {void}
 */
oracledb.ILob.prototype.read = function(callback) {};

/**
 * Read method on ILob class.
 * \@remarks CLobs send strings while BLobs send Buffer object.
 * @param {?} data
 * @param {function(?): void} callback
 * @return {void}
 */
oracledb.ILob.prototype.write = function(data, callback) {};
/**
 * @record
 * @struct
 */
oracledb.Lob = function() {};
 /** @type {!oracledb.ILob} */
oracledb.Lob.prototype.iLob;
 /** @type {number} */
oracledb.Lob.prototype.chunkSize;
 /** @type {number} */
oracledb.Lob.prototype.length;
 /** @type {number} */
oracledb.Lob.prototype.pieceSize;
 /** @type {number} */
oracledb.Lob.prototype.type;

/**
 * Do not call this... used internally by node-oracledb
 * @param {!oracledb.ILob} iLob
 * @param {!internal.DuplexOptions=} opts
 * @return {?}
 */
oracledb.Lob.prototype.constructor = function(iLob, opts) {};

/**
 * Closes the current LOB.
 * @param {function(?): void=} callback
 * @return {void} void
 */
oracledb.Lob.prototype.close = function(callback) {};
/**
 * @record
 * @struct
 */
oracledb.IConnectionAttributes = function() {};
 /** @type {string} */
oracledb.IConnectionAttributes.prototype.user;
 /** @type {string} */
oracledb.IConnectionAttributes.prototype.password;
 /** @type {string} */
oracledb.IConnectionAttributes.prototype.connectString;
 /** @type {number} */
oracledb.IConnectionAttributes.prototype.stmtCacheSize;
 /** @type {boolean} */
oracledb.IConnectionAttributes.prototype.externalAuth;
 /** @type {string} */
oracledb.IConnectionAttributes.prototype.poolAlias;
/**
 * @extends {oracledb.IConnectionAttributes}
 * @record
 * @struct
 */
oracledb.IPoolAttributes = function() {};
 /** @type {number} */
oracledb.IPoolAttributes.prototype.poolMax;
 /** @type {number} */
oracledb.IPoolAttributes.prototype.poolMin;
 /** @type {number} */
oracledb.IPoolAttributes.prototype.poolIncrement;
 /** @type {number} */
oracledb.IPoolAttributes.prototype.poolTimeout;
/**
 * @record
 * @struct
 */
oracledb.IExecuteOptions = function() {};
 /** @type {boolean} */
oracledb.IExecuteOptions.prototype.autoCommit;
 /** @type {boolean} */
oracledb.IExecuteOptions.prototype.extendedMetaData;
 /** @type {!Object} */
oracledb.IExecuteOptions.prototype.fetchInfo;
 /** @type {number} */
oracledb.IExecuteOptions.prototype.maxRows;
 /** @type {number} */
oracledb.IExecuteOptions.prototype.outFormat;
 /** @type {number} */
oracledb.IExecuteOptions.prototype.prefetchRows;
 /** @type {boolean} */
oracledb.IExecuteOptions.prototype.resultSet;
/**
 * @record
 * @struct
 */
oracledb.IExecuteReturn = function() {};
 /** @type {!Array<!oracledb.IMetaData>} */
oracledb.IExecuteReturn.prototype.metaData;
 /** @type {(!Object|!Array<?>)} */
oracledb.IExecuteReturn.prototype.outBinds;
 /** @type {!oracledb.IResultSet} */
oracledb.IExecuteReturn.prototype.resultSet;
 /** @type {(!Array<?>|!Array<!Array<?>>)} */
oracledb.IExecuteReturn.prototype.rows;
 /** @type {number} */
oracledb.IExecuteReturn.prototype.rowsAffected;
/**
 * @record
 * @struct
 */
oracledb.IMetaData = function() {};
 /** @type {string} */
oracledb.IMetaData.prototype.name;
 /** @type {number} */
oracledb.IMetaData.prototype.fetchType;
 /** @type {number} */
oracledb.IMetaData.prototype.dbType;
 /** @type {number} */
oracledb.IMetaData.prototype.byteSize;
 /** @type {number} */
oracledb.IMetaData.prototype.precision;
 /** @type {number} */
oracledb.IMetaData.prototype.scale;
 /** @type {boolean} */
oracledb.IMetaData.prototype.nullable;
/**
 * @record
 * @struct
 */
oracledb.IResultSet = function() {};
 /** @type {!Array<!oracledb.IMetaData>} */
oracledb.IResultSet.prototype.metaData;

/**
 * Closes a ResultSet. Applications should always call this at the end of fetch or when no more rows are needed.
 * \@remarks Applications should always call this at the end of fetch or when no more rows are needed.
 * Closes a ResultSet. Applications should always call this at the end of fetch or when no more rows are needed.
 * \@remarks Applications should always call this at the end of fetch or when no more rows are needed.
 * @param {function(?): void=} callback
 * @return {void|!oracledb.IPromise<void>} void / A void Promise on finish or when some error occurs.
 */
oracledb.IResultSet.prototype.close = function(callback) {};

/**
 * This call fetches one row of the result set as an object or an array of column values, depending on the value of outFormat.
 * At the end of fetching, the ResultSet should be freed by calling close().
 * This call fetches one row of the result set as an object or an array of column values, depending on the value of outFormat.
 * At the end of fetching, the ResultSet should be freed by calling close().
 * @param {function(?, (!Object|!Array<?>)): void=} callback
 * @return {void|!oracledb.IPromise<(!Object|!Array<?>)>} void / Promise when the row is available or when some error occurs.
 */
oracledb.IResultSet.prototype.getRow = function(callback) {};

/**
 * This synchronous method converts a ResultSet into a stream.
 * It can be used to make ResultSets from top-level queries or from REF CURSOR bind variables streamable. To make top-level queries streamable, the alternative connection.queryStream() method may be easier to use.
 * @return {!internal.Readable} synchronous stream of result set.
 */
oracledb.IResultSet.prototype.toQueryStream = function() {};
/**
 * @record
 * @struct
 */
oracledb.IConnection = function() {};
 /** @type {string} */
oracledb.IConnection.prototype.action;
 /** @type {string} */
oracledb.IConnection.prototype.clientId;
 /** @type {string} */
oracledb.IConnection.prototype.module;
 /** @type {number} */
oracledb.IConnection.prototype.oracleServerVersion;
 /** @type {number} */
oracledb.IConnection.prototype.stmtCacheSize;

/**
 * This call stops the currently running operation on the connection.
 * If there is no operation in progress or the operation has completed by the time the break is issued, the break() is effectively a no-op.
 * If the running asynchronous operation is interrupted, its callback will return an error.
 * This call stops the currently running operation on the connection.
 * If there is no operation in progress or the operation has completed by the time the break is issued, the break() is effectively a no-op.
 * If the running asynchronous operation is interrupted, its callback will return an error.
 * @param {function(?): void=} callback
 * @return {void|!oracledb.IPromise<void>} 	A void promise when break is done.
 */
oracledb.IConnection.prototype.break = function(callback) {};

/**
 * Releases a connection. If the connection was obtained from the pool, the connection is returned to the pool and is available for reuse.
 * Note: calling close() when connections are no longer required is strongly encouraged. Releasing helps avoid resource leakage and can improve system efficiency.
 * When a connection is released, any ongoing transaction on the connection is rolled back.
 * After releasing a connection to a pool, there is no guarantee a subsequent getConnection() call gets back the same database connection. The application must redo any ALTER SESSION statements on the new connection object, as required.
 * Releases a connection. If the connection was obtained from the pool, the connection is returned to the pool and is available for reuse.
 * Note: calling close() when connections are no longer required is strongly encouraged. Releasing helps avoid resource leakage and can improve system efficiency.
 * When a connection is released, any ongoing transaction on the connection is rolled back.
 * After releasing a connection to a pool, there is no guarantee a subsequent getConnection() call gets back the same database connection. The application must redo any ALTER SESSION statements on the new connection object, as required.
 * @param {function(?): void=} callback
 * @return {void|!oracledb.IPromise<void>} 	A void Promise on close done.
 */
oracledb.IConnection.prototype.close = function(callback) {};

/**
 * Send a commit requisition to the database.
 * Send a commit requisition to the database.
 * @param {function(?): void=} callback
 * @return {void|!oracledb.IPromise<void>} 	A void Promise on commit done.
 */
oracledb.IConnection.prototype.commit = function(callback) {};

/**
 * This call executes a SQL or PL/SQL statement. See SQL Execution for examples.
 * The statement to be executed may contain IN binds, OUT or IN OUT bind values or variables, which are bound using either an object or an array.
 * A callback function returns a result object, containing any fetched rows, the values of any OUT and IN OUT bind variables, and the number of rows affected by the execution of DML statements.
 * This call executes a SQL or PL/SQL statement. See SQL Execution for examples.
 * The statement to be executed may contain IN binds, OUT or IN OUT bind values or variables, which are bound using either an object or an array.
 * A callback function returns a result object, containing any fetched rows, the values of any OUT and IN OUT bind variables, and the number of rows affected by the execution of DML statements.
 * This call executes a SQL or PL/SQL statement. See SQL Execution for examples.
 * The statement to be executed may contain IN binds, OUT or IN OUT bind values or variables, which are bound using either an object or an array.
 * A callback function returns a result object, containing any fetched rows, the values of any OUT and IN OUT bind variables, and the number of rows affected by the execution of DML statements.
 * This call executes a SQL or PL/SQL statement. See SQL Execution for examples.
 * The statement to be executed may contain IN binds, OUT or IN OUT bind values or variables, which are bound using either an object or an array.
 * A callback function returns a result object, containing any fetched rows, the values of any OUT and IN OUT bind variables, and the number of rows affected by the execution of DML statements.
 * This call executes a SQL or PL/SQL statement. See SQL Execution for examples.
 * The statement to be executed may contain IN binds, OUT or IN OUT bind values or variables, which are bound using either an object or an array.
 * @param {string} sql
 * @param {(!Object|!Array<?>)|!oracledb.IExecuteOptions|function(?, !oracledb.IExecuteReturn): void=} bindParams_or_options_or_callback
 * @param {!oracledb.IExecuteOptions|function(?, !oracledb.IExecuteReturn): void=} options_or_callback
 * @param {function(?, !oracledb.IExecuteReturn): void=} callback
 * @return {void|!oracledb.IPromise<!oracledb.IExecuteReturn>} 	A Promise of a result object, containing any fetched rows, the values of any OUT and IN OUT bind variables, and the number of rows affected by the execution of DML statements.
 */
oracledb.IConnection.prototype.execute = function(sql, bindParams_or_options_or_callback, options_or_callback, callback) {};

/**
 * This function provides query streaming support. The parameters are the same as execute() except a callback is not used. Instead this function returns a stream used to fetch data.
 * Each row is returned as a data event. Query metadata is available via a metadata event. The end event indicates the end of the query results.
 * Query results must be fetched to completion to avoid resource leaks.
 * The connection must remain open until the stream is completely read.
 * For tuning purposes the oracledb.maxRows property can be used to size an internal buffer used by queryStream(). Note it does not limit the number of rows returned by the stream. The oracledb.prefetchRows value will also affect performance.
 * @param {string} sql
 * @param {(!Object|!Array<?>)=} bindParams
 * @param {!oracledb.IExecuteOptions=} options
 * @return {!internal.Readable} Readable Stream for queries.
 */
oracledb.IConnection.prototype.queryStream = function(sql, bindParams, options) {};

/**
 * An alias for Connection.close().
 * An alias for Connection.close().
 * @param {function(?): void=} callback
 * @return {void|!oracledb.IPromise<void>} 	A void Promise on close done.
 */
oracledb.IConnection.prototype.release = function(callback) {};

/**
 * Send a rollback requisition to database.
 * Send a rollback requisition to database.
 * @param {function(?): void=} callback
 * @return {void|!oracledb.IPromise<void>} 	A void Promise on rollback done.
 */
oracledb.IConnection.prototype.rollback = function(callback) {};
/**
 * @record
 * @struct
 */
oracledb.IConnectionPool = function() {};
 /** @type {number} */
oracledb.IConnectionPool.prototype.connectionsInUse;
 /** @type {number} */
oracledb.IConnectionPool.prototype.connectionsOpen;
 /** @type {string} */
oracledb.IConnectionPool.prototype.poolAlias;
 /** @type {number} */
oracledb.IConnectionPool.prototype.poolIncrement;
 /** @type {number} */
oracledb.IConnectionPool.prototype.poolMax;
 /** @type {number} */
oracledb.IConnectionPool.prototype.poolMin;
 /** @type {number} */
oracledb.IConnectionPool.prototype.poolTimeout;
 /** @type {number} */
oracledb.IConnectionPool.prototype.queueRequests;
 /** @type {number} */
oracledb.IConnectionPool.prototype.queueTimeout;
 /** @type {number} */
oracledb.IConnectionPool.prototype.stmtCacheSize;

/**
 * Finalizes the connection pool.
 * Finalizes the connection pool.
 * @param {function(?): void=} callback
 * @return {void|!oracledb.IPromise<void>} void / Promise to when the close finishes.
 */
oracledb.IConnectionPool.prototype.close = function(callback) {};

/**
 * This method obtains a connection from the connection pool.
 * If a previously opened connection is available in the pool, that connection is returned. If all connections in the pool are in use, a new connection is created and returned to the caller, as long as the number of connections does not exceed the specified maximum for the pool. If the pool is at its maximum limit, the getConnection() call results in an error, such as ORA-24418: Cannot open further sessions.
 * @see {\@link https://jsao.io/2015/03/making-a-wrapper-module-for-the-node-js-driver-for-oracle-database/}
 * @see {\@link https://github.com/OraOpenSource/orawrap}
 * This method obtains a connection from the connection pool.
 * If a previously opened connection is available in the pool, that connection is returned. If all connections in the pool are in use, a new connection is created and returned to the caller, as long as the number of connections does not exceed the specified maximum for the pool. If the pool is at its maximum limit, the getConnection() call results in an error, such as ORA-24418: Cannot open further sessions.
 * @see {\@link https://jsao.io/2015/03/making-a-wrapper-module-for-the-node-js-driver-for-oracle-database/}
 * @see {\@link https://github.com/OraOpenSource/orawrap}
 * @param {function(?, !oracledb.IConnection): void=} callback
 * @return {void|!oracledb.IPromise<!oracledb.IConnection>} void / An IConnection Promise to when the connection is available or when some error occurs.
 */
oracledb.IConnectionPool.prototype.getConnection = function(callback) {};

/**
 * An alias for IConnectionPool.close().
 * An alias for IConnectionPool.close().
 * @param {function(?): void=} callback
 * @return {void|!oracledb.IPromise<void>} void / Promise to when the close finishes.
 */
oracledb.IConnectionPool.prototype.terminate = function(callback) {};
 /** @type {number} */
oracledb.DEFAULT;
 /** @type {number} */
oracledb.DB_TYPE_VARCHAR;
 /** @type {number} */
oracledb.DB_TYPE_NUMBER;
 /** @type {number} */
oracledb.DB_TYPE_DATE;
 /** @type {number} */
oracledb.DB_TYPE_RAW;
 /** @type {number} */
oracledb.DB_TYPE_CHAR;
 /** @type {number} */
oracledb.DB_TYPE_BINARY_FLOAT;
 /** @type {number} */
oracledb.DB_TYPE_BINARY_DOUBLE;
 /** @type {number} */
oracledb.DB_TYPE_ROWID;
 /** @type {number} */
oracledb.DB_TYPE_CLOB;
 /** @type {number} */
oracledb.DB_TYPE_BLOB;
 /** @type {number} */
oracledb.DB_TYPE_TIMESTAMP;
 /** @type {number} */
oracledb.DB_TYPE_TIMESTAMP_TZ;
 /** @type {number} */
oracledb.DB_TYPE_TIMESTAMP_LTZ;
 /** @type {number} */
oracledb.STRING;
 /** @type {number} */
oracledb.NUMBER;
 /** @type {number} */
oracledb.DATE;
 /** @type {number} */
oracledb.CURSOR;
 /** @type {number} */
oracledb.BUFFER;
 /** @type {number} */
oracledb.CLOB;
 /** @type {number} */
oracledb.BLOB;
 /** @type {number} */
oracledb.BIND_IN;
 /** @type {number} */
oracledb.BIND_INOUT;
 /** @type {number} */
oracledb.BIND_OUT;
 /** @type {number} */
oracledb.ARRAY;
 /** @type {number} */
oracledb.OBJECT;

/**
 * Do not use this method - used internally by node-oracledb.
 * @param {!oracledb.ILob} iLob
 * @return {?}
 */
oracledb.newLob = function(iLob) {};
 /** @type {boolean} */
oracledb.autoCommit;
 /** @type {string} */
oracledb.connectionClass;
 /** @type {boolean} */
oracledb.extendedMetaData;
 /** @type {boolean} */
oracledb.externalAuth;
 /** @type {!Array<number>} */
oracledb.fetchAsString;
 /** @type {number} */
oracledb.lobPrefetchSize;
 /** @type {number} */
oracledb.maxRows;
 /** @type {number} */
oracledb.oracleClientVersion;
 /** @type {number} */
oracledb.outFormat;
 /** @type {number} */
oracledb.poolIncrement;
 /** @type {number} */
oracledb.poolMax;
 /** @type {number} */
oracledb.poolMin;
 /** @type {number} */
oracledb.poolTimeout;
 /** @type {number} */
oracledb.prefetchRows;
 /** @type {?} */
oracledb.Oracledb;
 /** @type {?} */
oracledb.Connection;
 /** @type {?} */
oracledb.Lob;
 /** @type {?} */
oracledb.ResultSet;
 /** @type {?} */
oracledb.Promise;
 /** @type {boolean} */
oracledb.queueRequests;
 /** @type {number} */
oracledb.queueTimeout;
 /** @type {number} */
oracledb.stmtCacheSize;
 /** @type {number} */
oracledb.version;

/**
 * Creates a database managed connection pool.
 * Creates a database managed connection pool.
 * @param {!oracledb.IPoolAttributes} poolAttributes
 * @param {function(?, !oracledb.IConnectionPool): void=} callback
 * @return {void|!oracledb.IPromise<!oracledb.IConnectionPool>} void / Promise {(connection:IConnectionPool)=>any} Promise with the connection pool.
 */
oracledb.createPool = function(poolAttributes, callback) {};

/**
 * Retrieves a connection pool from cache. If it does not exists, an error will be thrown.
 * @param {string=} poolAlias
 * @return {!oracledb.IConnectionPool} The connection pool or throws an error if it was not found.
 */
oracledb.getPool = function(poolAlias) {};

/**
 * Creates a connection with the database - the pool alias will be "default".
 * Creates a connection with the database.
 * Creates a connection with the database.
 * Creates a connection with the database. The pool name will be "default".
 * Creates a connection with the database.
 * Creates a connection with the database.
 * @param {function(?, !oracledb.IConnection): void|string|!oracledb.IConnectionAttributes=} callback_or_poolAlias_or_connectionAttributes
 * @param {function(?, !oracledb.IConnection): void=} callback
 * @return {void|!oracledb.IPromise<!oracledb.IConnection>} void
 */
oracledb.getConnection = function(callback_or_poolAlias_or_connectionAttributes, callback) {};

/* TODO: ExportAssignment in  */
