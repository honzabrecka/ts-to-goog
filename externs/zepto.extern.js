/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/zepto/index.d.ts:
/**
 * @record
 * @struct
 */
function ZeptoStatic() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
 /** @type {?} */
ZeptoStatic.prototype.fn;
 /** @type {!ZeptoAjaxSettings} */
ZeptoStatic.prototype.ajaxSettings;
 /** @type {!ZeptoEffects} */
ZeptoStatic.prototype.fx;
 /** @type {{version: string, phone: boolean, tablet: boolean, ios: boolean, android: boolean, webos: boolean, blackberry: boolean, bb10: boolean, rimtabletos: boolean, iphone: boolean, ipad: boolean, touchpad: boolean, kindle: boolean}} */
ZeptoStatic.prototype.os;
 /** @type {{version: string, chrome: boolean, firefox: boolean, silk: boolean, playbook: boolean}} */
ZeptoStatic.prototype.browser;

/**
 * Turn a dasherized string into “camel case”. Doesn’t affect already camel-cased strings.
 * @param {string} str
 * @return {string} 
 * 
 */
ZeptoStatic.prototype.camelCase = function(str) {};

/**
 * Check if the parent node contains the given DOM node. Returns false if both are the same node.
 * @param {!HTMLElement} parent
 * @param {!HTMLElement} node
 * @return {boolean} 
 * 
 */
ZeptoStatic.prototype.contains = function(parent, node) {};

/**
 * Iterate over array elements or object key-value pairs. Returning false from the iterator function stops the iteration.
 * @see ZeptoStatic.each
 * 
 * @param {!Array<?>|?} collection
 * @param {function(number, ?): boolean|function(string, ?): boolean} fn 
 * 
 * @return {void}
 */
ZeptoStatic.prototype.each = function(collection, fn) {};

/**
 * Extend target object with properties from each of the source objects, overriding the properties on target.
 * By default, copying is shallow. An optional true for the first argument triggers deep (recursive) copying.
 * @see ZeptoStatic.extend
 * @param {?|boolean} target_or_deep 
 * 
 * @param {...?} sources_or_target
 * @return {?} 
 * 
 */
ZeptoStatic.prototype.extend = function(target_or_deep, sources_or_target) {};

/**
 * Get a new array containing only the items for which the callback function returned true.
 * @param {!Array<?>} items
 * @param {function(?): boolean} fn
 * @return {!Array<?>} 
 * 
 */
ZeptoStatic.prototype.grep = function(items, fn) {};

/**
 * Get the position of element inside an array, or -1 if not found.
 * @param {?} element
 * @param {!Array<?>} array
 * @param {number=} fromIndex
 * @return {number} 
 * 
 */
ZeptoStatic.prototype.inArray = function(element, array, fromIndex) {};

/**
 * True if the object is an array.
 * @param {?} object
 * @return {boolean} 
 * 
 */
ZeptoStatic.prototype.isArray = function(object) {};

/**
 * True if the object is a function.
 * @param {?} object
 * @return {boolean} 
 * 
 */
ZeptoStatic.prototype.isFunction = function(object) {};

/**
 * True if the object is a “plain” JavaScript object, which is only true for object literals and objects created with new Object.
 * @param {?} object
 * @return {boolean} 
 * 
 */
ZeptoStatic.prototype.isPlainObject = function(object) {};

/**
 * True if the object is a window object. This is useful for iframes where each one has its own window, and where these objects fail the regular obj === window check.
 * @param {?} object
 * @return {boolean} 
 * 
 */
ZeptoStatic.prototype.isWindow = function(object) {};

/**
 * Iterate through elements of collection and return all results of running the iterator function, with null and undefined values filtered out.
 * @param {!Array<?>} collection
 * @param {function(?, number): ?} fn
 * @return {!Array<?>} 
 * 
 */
ZeptoStatic.prototype.map = function(collection, fn) {};

/**
 * Alias for the native JSON.parse method.
 * \@retrun 
 * 
 * @param {string} str
 * @return {?}
 */
ZeptoStatic.prototype.parseJSON = function(str) {};

/**
 * Remove whitespace from beginning and end of a string; just like String.prototype.trim().
 * @param {string} str
 * @return {string} 
 * 
 */
ZeptoStatic.prototype.trim = function(str) {};

/**
 * Get string type of an object. Possible types are: null undefined boolean number string function array date regexp object error.
 * For other objects it will simply report “object”. To find out if an object is a plain JavaScript object, use isPlainObject.
 * @param {?} object
 * @return {string} 
 * 
 */
ZeptoStatic.prototype.type = function(object) {};

/**
 * Create and initialize a DOM event of the specified type. If a properties object is given, use it to extend the new event object. The event is configured to bubble by default; this can be turned off by setting the bubbles property to false.
 * An event initialized with this function can be triggered with trigger.
 * @param {string} type
 * @param {?} properties
 * @return {!Event} 
 * 
 */
ZeptoStatic.prototype.Event = function(type, properties) {};

/**
 * Get a function that ensures that the value of this in the original function refers to the context object. In the second form, the original function is read from the specific property of the context object.
 * 
 * @param {!Function} fn
 * @param {?} context
 * @return {!Function}
 */
ZeptoStatic.prototype.proxy = function(fn, context) {};

/**
 * Perform an Ajax request. It can be to a local resource, or cross-domain via HTTP access control support in browsers or JSONP.
 * Options:
 * 	type (default: “GET”): HTTP request method (“GET”, “POST”, or other)
 * 	url (default: current URL): URL to which the request is made
 * 	data (default: none): data for the request; for GET requests it is appended to query string of the URL. Non-string objects will get serialized with $.param
 * 	processData (default: true): whether to automatically serialize data for non-GET requests to string
 * 	contentType (default: “application/x-www-form-urlencoded”): the Content-Type of the data being posted to the server (this can also be set via headers). Pass false to skip setting the default value.
 * 	dataType (default: none): response type to expect from the server (“json”, “jsonp”, “xml”, “html”, or “text”)
 * 	timeout (default: 0): request timeout in milliseconds, 0 for no timeout
 * 	headers: object of additional HTTP headers for the Ajax request
 * 	async (default: true): set to false to issue a synchronous (blocking) request
 * 	global (default: true): trigger global Ajax events on this request
 * 	context (default: window): context to execute callbacks in
 * 	traditional (default: false): activate traditional (shallow) serialization of data parameters with $.param
 *  If the URL contains =? or dataType is “jsonp”, the request is performed by injecting a <script> tag instead of using XMLHttpRequest (see JSONP). This has the limitation of contentType, dataType, headers, and async not being supported.
 * @param {!ZeptoAjaxSettings} options
 * @return {!XMLHttpRequest} 
 * 
 */
ZeptoStatic.prototype.ajax = function(options) {};

/**
 * Perform a JSONP request to fetch data from another domain.
 * This method has no advantages over $.ajax and should not be used.
 * @deprecated use $.ajax instead.
 * 
 * @param {!ZeptoAjaxSettings} options Ajax settings to use with JSONP call.
 * @return {!XMLHttpRequest}
 */
ZeptoStatic.prototype.ajaxJSONP = function(options) {};

/**
 * Perform an Ajax GET request. This is a shortcut for the $.ajax method.
 * @see ZeptoStatic.get
 * @param {string} url URL to send the HTTP GET request to.
 * @param {function(?, string, !XMLHttpRequest): void|?} fn_or_data Callback function when the HTTP GET request is completed. / See ZeptoAjaxSettings.data
 * 
 * @param {function(?, string, !XMLHttpRequest): void=} fn
 * @return {!XMLHttpRequest} The XMLHttpRequest object.
 * 
 */
ZeptoStatic.prototype.get = function(url, fn_or_data, fn) {};

/**
 * Get JSON data via Ajax GET request. This is a shortcut for the $.ajax method.
 * @see ZeptoStatic.getJSON
 * @param {string} url URL to send the HTTP GET request to.
 * @param {function(?, string, !XMLHttpRequest): void|?} fn_or_data Callback function when the HTTP GET request is completed. / See ZeptoAjaxSettings.data
 * 
 * @param {function(?, string, !XMLHttpRequest): void=} fn
 * @return {!XMLHttpRequest} The XMLHttpRequest object.
 * 
 */
ZeptoStatic.prototype.getJSON = function(url, fn_or_data, fn) {};

/**
 * Serialize an object to a URL-encoded string representation for use in Ajax request query strings and post data. If shallow is set, nested objects are not serialized and nested array values won’t use square brackets on their keys.
 * Also accepts an array in serializeArray format, where each item has “name” and “value” properties.
 * @param {?} object Serialize this object to URL-encoded string representation.
 * @param {boolean=} shallow Only serialize the first level of `object`.
 * @return {string} Seralized URL-encoded string representation of `object`.
 * 
 */
ZeptoStatic.prototype.param = function(object, shallow) {};

/**
 * Perform an Ajax POST request. This is a shortcut for the $.ajax method.
 * @see ZeptoStatic.post
 * @param {string} url URL to send the HTTP POST request to.
 * @param {function(?, string, !XMLHttpRequest): void|?} fn_or_data Callback function when the HTTP POST request is completed. / See ZeptoAjaxSettings.data
 * 
 * @param {string|function(?, string, !XMLHttpRequest): void=} dataType_or_fn
 * @param {string=} dataType
 * @return {!XMLHttpRequest} The XMLHttpRequest object.
 * 
 */
ZeptoStatic.prototype.post = function(url, fn_or_data, dataType_or_fn, dataType) {};
/**
 * @record
 * @struct
 */
function ZeptoEffects() {}
 /** @type {boolean} */
ZeptoEffects.prototype.off;
 /** @type {!ZeptoEffectsSpeeds} */
ZeptoEffects.prototype.speeds;
/**
 * @record
 * @struct
 */
function ZeptoEffectsSpeeds() {}
 /** @type {number} */
ZeptoEffectsSpeeds.prototype._default;
 /** @type {number} */
ZeptoEffectsSpeeds.prototype.fast;
 /** @type {number} */
ZeptoEffectsSpeeds.prototype.slow;
/**
 * @record
 * @struct
 */
function ZeptoCollection() {}
 /** @type {number} */
ZeptoCollection.prototype.length;

/**
 * Modify the current collection by adding the results of performing the CSS selector on the whole document, or, if context is given, just inside context elements.
 * @param {string} selector
 * @param {?=} context
 * @return {!ZeptoCollection} Self object.
 * 
 */
ZeptoCollection.prototype.add = function(selector, context) {};

/**
 * Add class name to each of the elements in the collection. Multiple class names can be given in a space-separated string.
 * @param {string} name
 * @return {!ZeptoCollection} Self object.
 * 
 */
ZeptoCollection.prototype.addClass = function(name) {};

/**
 * Add content to the DOM after each elements in the collection. The content can be an HTML string, a DOM node or an array of nodes.
 * @see ZeptoCollection.after
 * 
 * @see ZeptoCollection.after
 * 
 * @param {string|!HTMLElement|!Array<!HTMLElement>|!ZeptoCollection} content
 * @return {!ZeptoCollection} Self object.
 * 
 */
ZeptoCollection.prototype.after = function(content) {};

/**
 * Append content to the DOM inside each individual element in the collection. The content can be an HTML string, a DOM node or an array of nodes.
 * @see ZeptoCollection.append
 * 
 * @see ZeptoCollection.append
 * 
 * @see ZeptoCollection.append
 * 
 * @param {string|!HTMLElement|!Array<!HTMLElement>|!ZeptoCollection} content
 * @return {!ZeptoCollection} Self object.
 * 
 */
ZeptoCollection.prototype.append = function(content) {};

/**
 * Append elements from the current collection to the target element. This is like append, but with reversed operands.
 * @see ZeptoCollection.appendTo
 * 
 * @see ZeptoCollection.appendTo
 * 
 * @see ZeptoCollection.appendTo
 * 
 * @param {string|!HTMLElement|!Array<!HTMLElement>|!ZeptoCollection} target
 * @return {!ZeptoCollection} Self object.
 * 
 */
ZeptoCollection.prototype.appendTo = function(target) {};

/**
 * Read or set DOM attributes. When no value is given, reads specified attribute from the first element in the collection. When value is given, sets the attribute to that value on each element in the collection. When value is null, the attribute is removed (like with removeAttr). Multiple attributes can be set by passing an object with name-value pairs.
 * To read DOM properties such as checked or selected, use prop.
 * @see ZeptoCollection.attr
 * @see ZeptoCollection.attr
 * @see ZeptoCollection.attr
 * @param {string|?} name_or_object 
 * 
 * @param {?|function(number, ?): void=} value_or_fn 
 * 
 * @return {string|!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.attr = function(name_or_object, value_or_fn) {};

/**
 * Add content to the DOM before each element in the collection. The content can be an HTML string, a DOM node or an array of nodes.
 * @see ZeptoCollection.before
 * 
 * @see ZeptoCollection.before
 * 
 * @see ZeptoCollection.before
 * 
 * @param {string|!HTMLElement|!Array<!HTMLElement>|!ZeptoCollection} content
 * @return {!ZeptoCollection} Self object.
 * 
 */
ZeptoCollection.prototype.before = function(content) {};

/**
 * Get immediate children of each element in the current collection. If selector is given, filter the results to only include ones matching the CSS selector.
 * @param {string=} selector
 * @return {!ZeptoCollection} Children elements.
 * 
 */
ZeptoCollection.prototype.children = function(selector) {};

/**
 * Duplicate all elements in the collection via deep clone.
 * (!) This method doesn't have an option for copying data and event handlers over to the new elements, as it has in jQuery.
 * @return {!ZeptoCollection} Clone of the self object.
 * 
 */
ZeptoCollection.prototype.clone = function() {};

/**
 * Traverse upwards from the current element to find the first element that matches the selector. If context node is given, consider only elements that are its descendants. This method is similar to parents(selector), but it only returns the first ancestor matched.
 * If a Zepto collection or element is given, the resulting element will have to match one of the given elements instead of a selector.
 * @param {string} selector
 * @param {?=} context
 * @return {!ZeptoCollection} Closest element from the selector and context.
 * 
 */
ZeptoCollection.prototype.closest = function(selector, context) {};

/**
 * Modify the collection by adding elements to it. If any of the arguments is an array, its elements are merged into the current collection.
 * (!) This is a Zepto-provided method that is not part of the jQuery API.
 * @param {...?} nodes
 * @return {!ZeptoCollection} Self object.
 * 
 */
ZeptoCollection.prototype.concat = function(nodes) {};

/**
 * Get the children of each element in the collection, including text and comment nodes.
 * @return {!ZeptoCollection} Children including text and comment nodes.
 * 
 */
ZeptoCollection.prototype.contents = function() {};

/**
 * Read or set CSS properties on DOM elements. When no value is given, returns the CSS property from the first element in the collection. When a value is given, sets the property to that value on each element of the collection. Multiple properties can be set by passing an object to the method.
 * When a value for a property is blank (empty string, null, or undefined), that property is removed. When a unitless number value is given, “px” is appended to it for properties that require units.
 * @see ZeptoCollection.css
 * @see ZeptoCollection.css
 * @param {string|?} property_or_properties 
 * 
 * @param {?=} value 
 * 
 * @return {?|!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.css = function(property_or_properties, value) {};

/**
 * Read or write data-* DOM attributes. Behaves like attr, but prepends data- to the attribute name.
 * When reading attribute values, the following conversions apply:
 * 	“true”, “false”, and “null” are converted to corresponding types;
 * 	number values are converted to actual numeric types;
 * 	JSON values are parsed, if it’s valid JSON;
 * 	everything else is returned as string.
 * (!)  Zepto's basic implementation of `data()` only stores strings. To store arbitrary objects, include the optional "data" module in your custom build of Zepto.
 * @see ZeptoCollection.data
 * @param {string} name
 * @param {?=} value 
 * 
 * @return {?|!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.data = function(name, value) {};

/**
 * Iterate through every element of the collection. Inside the iterator function, this keyword refers to the current item (also passed as the second argument to the function). If the iterator function returns false, iteration stops.
 * @param {function(number, ?): boolean} fn
 * @return {!ZeptoCollection} Self object.
 * 
 */
ZeptoCollection.prototype.each = function(fn) {};

/**
 * Clear DOM contents of each element in the collection.
 * @return {!ZeptoCollection} Self object.
 * 
 */
ZeptoCollection.prototype.empty = function() {};

/**
 * Get the item at position specified by index from the current collection.
 * @param {number} index
 * @return {!ZeptoCollection} Item specified by index in this collection.
 * 
 */
ZeptoCollection.prototype.eq = function(index) {};

/**
 * Filter the collection to contain only items that match the CSS selector. If a function is given, return only elements for which the function returns a truthy value. Inside the function, the this keyword refers to the current element.
 * For the opposite, see not.
 * @see ZeptoCollection.filter
 * @param {string|function(number): boolean} selector_or_fn 
 * 
 * @return {!ZeptoCollection} Filtered collection.
 * 
 */
ZeptoCollection.prototype.filter = function(selector_or_fn) {};

/**
 * Find elements that match CSS selector executed in scope of nodes in the current collection.
 * If a Zepto collection or element is given, filter those elements down to only ones that are descendants of element in the current collection.
 * @see ZeptoCollection.find
 * @see ZeptoCollection.find
 * @param {string|!ZeptoCollection|!Element} selector_or_collection_or_element 
 * 
 * @return {!ZeptoCollection} Found items.
 * 
 */
ZeptoCollection.prototype.find = function(selector_or_collection_or_element) {};

/**
 * Get the first element of the current collection.
 * @return {!ZeptoCollection} First element in the current collection.
 * 
 */
ZeptoCollection.prototype.first = function() {};

/**
 * Iterate through every element of the collection. Similar to each, but the arguments for the iterator functions are different, and returning false from the iterator won’t stop the iteration.
 * (!) This is a Zepto-provided method that is not part of the jQuery API.
 * @param {function(?, number, !Array<?>): void} fn
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.forEach = function(fn) {};

/**
 * Get all elements or a single element from the current collection. When no index is given, returns all elements in an ordinary array. When index is specified, return only the element at that position. This is different than eq in the way that the returned node is not wrapped in a Zepto collection.
 * @see ZeptoCollection.get
 * @param {number=} index 
 * 
 * @return {!Array<!HTMLElement>|!HTMLElement} 
 * 
 */
ZeptoCollection.prototype.get = function(index) {};

/**
 * Filter the current collection to include only elements that have any number of descendants that match a selector, or that contain a specific DOM node.
 * @see ZeptoCollection.has
 * @param {string|!HTMLElement} selector_or_node 
 * 
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.has = function(selector_or_node) {};

/**
 * Check if any elements in the collection have the specified class.
 * @param {string} name
 * @return {boolean} 
 * 
 */
ZeptoCollection.prototype.hasClass = function(name) {};

/**
 * Get the height of the first element in the collection; or set the height of all elements in the collection.
 * @see ZeptoCollection.height
 * @see ZeptoCollection.height
 * @param {number|function(number, number): void=} value_or_fn 
 * 
 * @return {number|!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.height = function(value_or_fn) {};

/**
 * Hide elements in this collection by setting their display CSS property to none.
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.hide = function() {};

/**
 * Get or set HTML contents of elements in the collection. When no content given, returns innerHTML of the first element. When content is given, use it to replace contents of each element. Content can be any of the types described in append.
 * @see ZeptoCollection.html
 * @see ZeptoCollection.html
 * @see ZeptoCollection.html
 * @see ZeptoCollection.html
 * @param {string|!HTMLElement|!Array<!HTMLElement>|function(number, string): void=} content_or_fn 
 * 
 * @return {string|!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.html = function(content_or_fn) {};

/**
 * Get the position of an element. When no element is given, returns position of the current element among its siblings. When an element is given, returns its position in the current collection. Returns -1 if not found.
 * @see ZeptoCollection.index
 * @see ZeptoCollection.index
 * @param {string|!HTMLElement|?=} element 
 * 
 * @return {number} 
 * 
 */
ZeptoCollection.prototype.index = function(element) {};

/**
 * Get the position of an element in the current collection. If fromIndex number is given, search only from that position onwards. Returns the 0-based position when found and -1 if not found. Use of index is recommended over this method.
 * (!) This is a Zepto-provided method that is not part of the jQuery API.
 * @see ZeptoCollection.index
 * @see ZeptoCollection.indexOf
 * @see ZeptoCollection.indexOf
 * @param {string|!HTMLElement|?} element 
 * 
 * @param {number=} fromIndex
 * @return {number} 
 * 
 */
ZeptoCollection.prototype.indexOf = function(element, fromIndex) {};

/**
 * Insert elements from the current collection after the target element in the DOM. This is like after, but with reversed operands.
 * @see ZeptoCollection.insertAfter
 * @param {string|!HTMLElement} target 
 * 
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.insertAfter = function(target) {};

/**
 * Insert elements from the current collection before each of the target elements in the DOM. This is like before, but with reversed operands.
 * @see ZeptoCollection.insertBefore
 * @param {string|!HTMLElement} target 
 * 
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.insertBefore = function(target) {};

/**
 * Check if the first element of the current collection matches the CSS selector. For basic support of jQuery’s non-standard pseudo-selectors such as :visible, include the optional “selector” module.
 * (!) jQuery CSS extensions are not supported. The optional "selector" module only provides limited support for few of the most used ones.
 * @param {string=} selector
 * @return {boolean} 
 * 
 */
ZeptoCollection.prototype.is = function(selector) {};

/**
 * Get the last element of the current collection.
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.last = function() {};

/**
 * Iterate through all elements and collect the return values of the iterator function. Inside the iterator function, this keyword refers to the current item (also passed as the second argument to the function).
 * Returns a collection of results of iterator function, with null and undefined values filtered out.
 * @param {function(number, ?): ?} fn
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.map = function(fn) {};

/**
 * Get the next sibling—optinally filtered by selector—of each element in the collection.
 * @param {string=} selector
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.next = function(selector) {};

/**
 * Filter the current collection to get a new collection of elements that don’t match the CSS selector. If another collection is given instead of selector, return only elements not present in it. If a function is given, return only elements for which the function returns a falsy value. Inside the function, the this keyword refers to the current element.
 * For the opposite, see filter.
 * @see ZeptoCollection.not
 * @see ZeptoCollection.not
 * @param {string|!ZeptoCollection|function(number): boolean} selector_or_collection_or_fn 
 * 
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.not = function(selector_or_collection_or_fn) {};

/**
 * Get position of the element in the document. Returns an object with properties: top, left, width and height.
 * When given an object with properties left and top, use those values to position each element in the collection relative to the document.
 * @see ZeptoCollection.offset
 * @see ZeptoCollection.offset
 * @param {!ZeptoCoordinates|function(number, number): void=} coordinates_or_fn 
 * 
 * @return {!ZeptoCoordinates|!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.offset = function(coordinates_or_fn) {};

/**
 * Find the first ancestor element that is positioned, meaning its CSS position value is “relative”, “absolute” or “fixed”.
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.offsetParent = function() {};

/**
 * Get immediate parents of each element in the collection. If CSS selector is given, filter results to include only ones matching the selector.
 * @param {string=} selector
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.parent = function(selector) {};

/**
 * Get all ancestors of each element in the collection. If CSS selector is given, filter results to include only ones matching the selector.
 * To get only immediate parents, use parent. To only get the first ancestor that matches the selector, use closest.
 * @param {string=} selector
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.parents = function(selector) {};

/**
 * Get values from a named property of each element in the collection, with null and undefined values filtered out.
 * (!) This is a Zepto-provided method that is not part of the jQuery API.
 * @param {string} property
 * @return {!Array<string>} 
 * 
 */
ZeptoCollection.prototype.pluck = function(property) {};

/**
 * Get the position of the first element in the collection, relative to the offsetParent. This information is useful when absolutely positioning an element to appear aligned with another.
 * Returns an object with properties: top, left.
 * @return {!ZeptoPosition} 
 * 
 */
ZeptoCollection.prototype.position = function() {};

/**
 * Prepend content to the DOM inside each element in the collection. The content can be an HTML string, a DOM node or an array of nodes.
 * @see ZeptoCollection.prepend
 * @see ZeptoCollection.prepend
 * @see ZeptoCollection.prepend
 * @param {string|!HTMLElement|!Array<!HTMLElement>|!ZeptoCollection} content 
 * 
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.prepend = function(content) {};

/**
 * Prepend elements of the current collection inside each of the target elements. This is like prepend, only with reversed operands.
 * @see ZeptoCollection.prependTo
 * @see ZeptoCollection.prependTo
 * @see ZeptoCollection.prependTo
 * @param {string|!HTMLElement|!Array<!HTMLElement>|!ZeptoCollection} content 
 * 
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.prependTo = function(content) {};

/**
 * Get the previous sibling—optionally filtered by selector—of each element in the collection.
 * @param {string=} selector
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.prev = function(selector) {};

/**
 * Read or set properties of DOM elements. This should be preferred over attr in case of reading values of properties that change with user interaction over time, such as checked and selected.
 * @see ZeptoCollection.Prop
 * @see ZeptoCollection.Prop
 * @param {string} name
 * @param {?|function(number, ?): void=} value_or_fn 
 * 
 * @return {?|!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.prop = function(name, value_or_fn) {};

/**
 * Add elements to the end of the current collection.
 * (!) This is a Zepto-provided method that is not part of the jQuery API.
 * @param {...?} elements
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.push = function(elements) {};

/**
 * Attach an event handler for the “DOMContentLoaded” event that fires when the DOM on the page is ready. It’s recommended to use the $() function instead of this method.
 * @param {function(!ZeptoStatic): void} fn
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.ready = function(fn) {};

/**
 * Identical to Array.reduce that iterates over current collection.
 * (!) This is a Zepto-provided method that is not part of the jQuery API.
 * @param {function(?, ?, number, !Array<?>, ?): ?} fn
 * @return {?} 
 * 
 */
ZeptoCollection.prototype.reduce = function(fn) {};

/**
 * Remove elements in the current collection from their parent nodes, effectively detaching them from the DOM.
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.remove = function() {};

/**
 * Remove the specified attribute from all elements in the collection.
 * @param {string} name
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.removeAttr = function(name) {};

/**
 * Remove the specified class name from all elements in the collection. When the class name isn’t given, remove all class names. Multiple class names can be given in a space-separated string.
 * @see ZeptoCollection.removeClass
 * @param {string|function(number, string): void=} name_or_fn 
 * 
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.removeClass = function(name_or_fn) {};

/**
 * Replace each element in the collection—both its contents and the element itself—with the new content. Content can be of any type described in before.
 * @see ZeptoCollection.replacewith
 * @see ZeptoCollection.replacewith
 * @param {string|!HTMLElement|!Array<!HTMLElement>} content 
 * 
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.replaceWith = function(content) {};

/**
 * Gets the value of how many pixels were scrolled so far on window or scrollable element on the page.
 * @return {number} 
 * 
 */
ZeptoCollection.prototype.scrollTop = function() {};

/**
 * Restore the default value for the “display” property of each element in the array, effectively showing them if they were hidden with hide.
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.show = function() {};

/**
 * Get all sibling nodes of each element in the collection. If CSS selector is specified, filter the results to contain only elements that match the selector.
 * @param {string=} selector
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.siblings = function(selector) {};

/**
 * Get the number of elements in this collection.
 * @return {number} 
 * 
 */
ZeptoCollection.prototype.size = function() {};

/**
 * Extract the subset of this array, starting at start index. If end is specified, extract up to but not including end index.
 * @param {number=} start
 * @param {number=} end
 * @return {!Array<!ZeptoCollection>} 
 * 
 */
ZeptoCollection.prototype.slice = function(start, end) {};

/**
 * Get or set the text content of elements in the collection. When no content is given, returns the text content of the first element in the collection. When content is given, uses it to replace the text contents of each element in the collection. This is similar to html, with the exception it can’t be used for getting or setting HTML.
 * @see ZeptoCollection.text
 * @param {string=} content
 * @return {string|!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.text = function(content) {};

/**
 * Toggle between showing and hiding each of the elements, based on whether the first element is visible or not. If setting is present, this method behaves like show if setting is truthy or hide otherwise.
 * @param {boolean=} setting
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.toggle = function(setting) {};

/**
 * Toggle given class names (space-separated) in each element in the collection. The class name is removed if present on an element; otherwise it’s added. If setting is present, this method behaves like addClass if setting is truthy or removeClass otherwise.
 * @see ZeptoCollection.toggleClass
 * @param {string|function(number, string): void} names_or_fn 
 * 
 * @param {boolean=} setting
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.toggleClass = function(names_or_fn, setting) {};

/**
 * Remove immediate parent nodes of each element in the collection and put their children in their place. Basically, this method removes one level of ancestry while keeping current elements in the DOM.
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.unwrap = function() {};

/**
 * Get or set the value of form controls. When no value is given, return the value of the first element. For <select multiple>, an array of values is returend. When a value is given, set all elements to this value.
 * @see ZeptoCollection.val
 * @see ZeptoCollection.val
 * @param {?|function(number, ?): void=} value_or_fn 
 * 
 * @return {string|!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.val = function(value_or_fn) {};

/**
 * Get the width of the first element in the collection; or set the width of all elements in the collection.
 * @see ZeptoCollection.width
 * @see ZeptoCollection.width
 * @param {number|function(number, number): void=} value_or_fn 
 * 
 * @return {number|!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.width = function(value_or_fn) {};

/**
 * Wrap each element of the collection separately in a DOM structure. Structure can be a single element or several nested elements, and can be passed in as a HTML string or DOM node, or as a function that is called for each element and returns one of the first two types.
 * Keep in mind that wrapping works best when operating on nodes that are part of the DOM. When calling wrap() on a new element and then inserting the result in the document, the element will lose the wrapping.
 * @see ZeptoCollection.wrap
 * @see ZeptoCollection.wrap
 * @param {string|!HTMLElement|function(number): string} structure_or_fn 
 * 
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.wrap = function(structure_or_fn) {};

/**
 * Wrap all elements in a single structure. Structure can be a single element or several nested elements, and can be passed in as a HTML string or DOM node.
 * @see ZeptoCollection.wrapAll
 * @param {string|!HTMLElement} structure 
 * 
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.wrapAll = function(structure) {};

/**
 * Wrap the contents of each element separately in a structure. Structure can be a single element or several nested elements, and can be passed in as a HTML string or DOM node, or as a function that is called for each element and returns one of the first two types.
 * @see ZeptoCollection.wrapInner
 * @see ZeptoCollection.wrapInner
 * @param {string|!HTMLElement|function(number): string} structure_or_fn 
 * 
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.wrapInner = function(structure_or_fn) {};

/**
 * Attach an event handler to elements.
 * @deprecated use ZeptoCollection.on instead.
 * @param {string} type
 * @param {function(!Event): void} fn
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.bind = function(type, fn) {};

/**
 * Attach an event handler that is only triggered when the event originated from a node that matches a selector.
 * \@depcreated use ZeptoCollection.on instead.
 * @param {string} selector
 * @param {string} type
 * @param {function(!Event): void} fn
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.delegate = function(selector, type, fn) {};

/**
 * Detach event handler added by live.
 * @deprecated use ZeptoCollection.off instead.
 * @see ZeptoCollection.die
 * @param {string|?} type_or_types 
 * 
 * @param {function(!Event): void=} fn
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.die = function(type_or_types, fn) {};

/**
 * Like delegate where the selector is taken from the current collection.
 * \@deprepcated use ZeptoCollection.on instead.
 * @param {string} type
 * @param {function(!Event): void} fn
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.live = function(type, fn) {};

/**
 * Detach event handlers added with on. To detach a specific event handler, the same function must be passed that was used for on(). Otherwise, just calling this method with an event type with detach all handlers of that type. When called without arguments, it detaches all event handlers registered on current elements.
 * @see ZeptoCollection.off
 * 
 * @see ZeptoCollection.off
 * 
 * @see ZeptoCollection.off
 * 
 * @see ZeptoCollection.off
 * @param {string|!ZeptoEventHandlers=} type_or_events 
 * 
 * @param {string|function(!Event): boolean=} selector_or_fn
 * @param {function(!Event): boolean=} fn
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.off = function(type_or_events, selector_or_fn, fn) {};

/**
 * Add event handlers to the elements in collection. Multiple event types can be passed in a space-separated string, or as an object where event types are keys and handlers are values. If a CSS selector is given, the handler function will only be called when an event originates from an element that matches the selector.
 * Event handlers are executed in the context of the element to which the handler is attached, or the matching element in case a selector is provided. When an event handler returns false, preventDefault() is called for the current event, preventing the default browser action such as following links.
 * @see ZeptoCollection.on
 * 
 * @see ZeptoCollection.on
 * @param {string|!ZeptoEventHandlers} type_or_events 
 * 
 * @param {string|function(!Event): boolean=} selector_or_fn
 * @param {function(!Event): boolean=} fn
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.on = function(type_or_events, selector_or_fn, fn) {};

/**
 * Adds an event handler that removes itself the first time it runs, ensuring that the handler only fires once.
 * @see ZeptoCollection.one
 * @param {string|!ZeptoEventHandlers} type_or_events 
 * 
 * @param {function(!Event): void=} fn
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.one = function(type_or_events, fn) {};

/**
 * Trigger the specified event on elements of the collection. Event can either be a string type, or a full event object obtained with $.Event. If a data array is given, it is passed as additional arguments to event handlers.
 * (!) Zepto only supports triggering events on DOM elements.
 * @param {string} event
 * @param {!Array<?>=} data
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.trigger = function(event, data) {};

/**
 * Like trigger, but triggers only event handlers on current elements and doesn’t bubble.
 * @param {string} event
 * @param {!Array<?>=} data
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.triggerHandler = function(event, data) {};

/**
 * Detach event handler added with bind.
 * @deprecated use ZeptoCollection.off instead.
 * @param {string} type
 * @param {function(!Event): boolean} fn
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.unbind = function(type, fn) {};

/**
 * Detach event handler added with delegate.
 * @deprecated use ZeptoCollection.off instead.
 * @param {string} selector
 * @param {string} type
 * @param {function(!Event): boolean} fn
 * @return {!ZeptoCollection} 
 * 
 */
ZeptoCollection.prototype.undelegate = function(selector, type, fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.focusin = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.focusout = function(fn) {};

/**
 * Set the html contents of the current collection to the result of a GET Ajax call to the given URL. Optionally, a CSS selector can be specified in the URL, like so, to use only the HTML content matching the selector for updating the collection:
 * $('#some_element').load('/foo.html #bar')
 * If no CSS selector is given, the complete response text is used instead.
 * Note that any JavaScript blocks found are only executed in case no selector is given.
 * \@example 
 * 	$('#some_element').load('/foo.html #bar')
 * 
 * @param {function(!Event): ?|string=} fn_or_url URL to send the HTTP GET request to.
 * @param {function(?, string, !XMLHttpRequest): void=} fn Callback function when the HTTP GET request is completed.
 * @return {!ZeptoCollection} Self object.
 */
ZeptoCollection.prototype.load = function(fn_or_url, fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.resize = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.scroll = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.unload = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.click = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.dblclick = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.mousedown = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.mouseup = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.mousemove = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.mouseover = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.mouseout = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.mouseenter = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.mouseleave = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.change = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.select = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.keydown = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.keypress = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.keyup = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.error = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.focus = function(fn) {};

/**
 * @param {function(!Event): ?=} fn
 * @return {!ZeptoCollection}
 */
ZeptoCollection.prototype.blur = function(fn) {};

/**
 * Serialize form values to an URL-encoded string for use in Ajax post requests.
 * @return {string} Seralized form values in URL-encoded string.
 * 
 */
ZeptoCollection.prototype.serialize = function() {};

/**
 * Serialize form into an array of objects with name and value properties. Disabled form controls, buttons, and unchecked radio buttons/checkboxes are skipped. The result doesn’t include data from file inputs.
 * @return {!Array<?>} Array with name value pairs from the Form.
 * 
 */
ZeptoCollection.prototype.serializeArray = function() {};

/**
 * Trigger or attach a handler for the submit event. When no function given, trigger the “submit” event on the current form and have it perform its submit action unless preventDefault() was called for the event.
 * When a function is given, this simply attaches it as a handler for the “submit” event on current elements.
 * @see ZeptoCollection.submit
 * @param {function(?): void=} fn Handler for the 'submit' event on current elements.
 * @return {!ZeptoCollection} Self object.
 * 
 */
ZeptoCollection.prototype.submit = function(fn) {};

/**
 * Smoothly transition CSS properties of elements in the current collection.
 * \@note If the duration is 0 or $.fx.off is true (default in a browser that doesn’t support CSS transitions), animations will not be executed; instead the target values will take effect instantly. Similarly, when the target CSS properties match the current state of the element, there will be no animation and the complete function won’t be called.
 * 	If the first argument is a string instead of object, it is taken as a CSS keyframe animation name.
 * \@note Zepto exclusively uses CSS transitions for effects and animation. jQuery easings are not supported. jQuery's syntax for relative changes ("=+10px") is not supported. See the spec for a list of animatable properties (http://www.w3.org/TR/css3-transitions/#animatable-properties-). Browser support may vary, so be sure to test in all browsers you want to support.
 * 
 * @see ZeptoCollection.animate
 * @param {?} properties object that holds CSS values to animate to; or CSS keyframe animation name.
 * 	Zepto also supports the following CSS transform porperties:
 * 		translate(X|Y|Z|3d)
 * 		rotate(X|Y|Z|3d)
 * 		scale(X|Y|Z)
 * 		matrix(3d)
 * 		perspective
 * 		skew(X|Y)
 * @param {number|!ZeptoAnimateSettings=} duration_or_options (default 400): duration in milliseconds, or a string:
 * 		fast (200 ms)
 * 		slow (600 ms)
 * 		any custom property of $.fx.speeds / Animation options.
 * 
 * @param {string=} easing (default linear): specifies the type of animation easing to use, one of:
 * 		ease
 * 		linear
 * 		ease-in
 * 		ease-out
 * 		ease-in-out
 * 		cubic-bezier(x1, y1, x2, y2)
 * @param {function(): void=} complete Callback function when the animation has completed.
 * @return {!ZeptoCollection} Self object.
 */
ZeptoCollection.prototype.animate = function(properties, duration_or_options, easing, complete) {};
/**
 * @record
 * @struct
 */
function ZeptoAjaxSettings() {}
 /** @type {string} */
ZeptoAjaxSettings.prototype.type;
 /** @type {string} */
ZeptoAjaxSettings.prototype.url;
 /** @type {?} */
ZeptoAjaxSettings.prototype.data;
 /** @type {boolean} */
ZeptoAjaxSettings.prototype.processData;
 /** @type {string} */
ZeptoAjaxSettings.prototype.contentType;
 /** @type {string} */
ZeptoAjaxSettings.prototype.mimeType;
 /** @type {string} */
ZeptoAjaxSettings.prototype.dataType;
 /** @type {string} */
ZeptoAjaxSettings.prototype.jsonp;
 /** @type {?} */
ZeptoAjaxSettings.prototype.jsonpCallback;
 /** @type {number} */
ZeptoAjaxSettings.prototype.timeout;
 /** @type {!Object<string,string>} */
ZeptoAjaxSettings.prototype.headers;
 /** @type {boolean} */
ZeptoAjaxSettings.prototype.async;
 /** @type {boolean} */
ZeptoAjaxSettings.prototype.global;
 /** @type {?} */
ZeptoAjaxSettings.prototype.context;
 /** @type {boolean} */
ZeptoAjaxSettings.prototype.traditional;
 /** @type {boolean} */
ZeptoAjaxSettings.prototype.cache;
 /** @type {!Object<string,?>} */
ZeptoAjaxSettings.prototype.xhrFields;
 /** @type {string} */
ZeptoAjaxSettings.prototype.username;
 /** @type {string} */
ZeptoAjaxSettings.prototype.password;
 /** @type {function(!XMLHttpRequest, !ZeptoAjaxSettings): boolean} */
ZeptoAjaxSettings.prototype.beforeSend;
 /** @type {function(?, string, !XMLHttpRequest): void} */
ZeptoAjaxSettings.prototype.success;
 /** @type {function(!XMLHttpRequest, string, !Error): void} */
ZeptoAjaxSettings.prototype.error;
 /** @type {function(!XMLHttpRequest, string): void} */
ZeptoAjaxSettings.prototype.complete;
/**
 * @record
 * @struct
 */
function ZeptoAjaxStartEvent() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ZeptoAjaxBeforeSendEvent() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ZeptoAjaxSendEvent() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ZeptoAjaxSuccessEvent() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ZeptoAjaxErrorEvent() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ZeptoAjaxCompleteEvent() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ZeptoAjaxStopEvent() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ZeptoAnimateSettings() {}
 /** @type {number} */
ZeptoAnimateSettings.prototype.duration;
 /** @type {string} */
ZeptoAnimateSettings.prototype.easing;
 /** @type {function(): void} */
ZeptoAnimateSettings.prototype.complete;
/**
 * @record
 * @struct
 */
function ZeptoPosition() {}
 /** @type {number} */
ZeptoPosition.prototype.top;
 /** @type {number} */
ZeptoPosition.prototype.left;
/**
 * @extends {ZeptoPosition}
 * @record
 * @struct
 */
function ZeptoCoordinates() {}
 /** @type {number} */
ZeptoCoordinates.prototype.width;
 /** @type {number} */
ZeptoCoordinates.prototype.height;
/**
 * @record
 * @struct
 */
function ZeptoEventHandlers() {}

/* TODO: IndexSignature:  */
 /** @type {function(function(!ZeptoStatic): void): void} */
var Zepto;
 /** @type {!ZeptoStatic} */
var $;
