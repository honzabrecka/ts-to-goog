/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/blessed/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */
/** @const */
var Blessed = {};
/**
 * @constructor
 * @struct
 */
Blessed.BlessedProgram = function() {};
 /** @type {function(): void} */
Blessed.BlessedProgram.prototype.hideCursor;
 /** @type {?} */
Blessed.BlessedProgram.prototype.move;
 /** @type {?} */
Blessed.BlessedProgram.prototype.showCursor;
/** @const */
Blessed.Widgets = {};
/** @const */
Blessed.Widgets.Types = {};

/** @typedef {(string|number)} */
Blessed.Widgets.Types.TTopLeft;

/** @typedef {(string|number)} */
Blessed.Widgets.Types.TPosition;

/** @typedef {string} */
Blessed.Widgets.Types.TMouseAction;

/** @typedef {{type: string, bg: string, fg: string, ch: string, bold: boolean, underline: boolean, blink: boolean, inverse: boolean, invisible: boolean, transparent: boolean, border: (string|{type: string, ch: string, bg: number, fg: number, bold: string, underline: string}), hover: boolean, focus: boolean, label: string, track: {bg: string, fg: string}, scrollbar: {bg: string, fg: string}}} */
Blessed.Widgets.Types.TStyle;

/** @typedef {{type: string, ch: string, bg: number, fg: number, bold: string, underline: string}} */
Blessed.Widgets.Types.TBorder;

/** @typedef {{artificial: boolean, shape: boolean, blink: boolean, color: string}} */
Blessed.Widgets.Types.TCursor;

/** @typedef {string} */
Blessed.Widgets.Types.TAlign;

/** @typedef {{key: string, callback: function(): void}} */
Blessed.Widgets.Types.ListbarCommand;

/** @typedef {{width: number, height: number, bmp: ?, cellmap: ?}} */
Blessed.Widgets.Types.TImage;

/** @typedef {{artificial: boolean, shape: boolean, blink: boolean, color: string}} */
Blessed.Widgets.Types.Cursor;
/** @const */
Blessed.Widgets.Events = {};
/**
 * @record
 * @struct
 */
Blessed.Widgets.Events.IMouseEventArg = function() {};
 /** @type {number} */
Blessed.Widgets.Events.IMouseEventArg.prototype.x;
 /** @type {number} */
Blessed.Widgets.Events.IMouseEventArg.prototype.y;
 /** @type {string} */
Blessed.Widgets.Events.IMouseEventArg.prototype.action;
/**
 * @record
 * @struct
 */
Blessed.Widgets.Events.IKeyEventArg = function() {};
 /** @type {string} */
Blessed.Widgets.Events.IKeyEventArg.prototype.full;
 /** @type {string} */
Blessed.Widgets.Events.IKeyEventArg.prototype.name;
 /** @type {boolean} */
Blessed.Widgets.Events.IKeyEventArg.prototype.shift;
 /** @type {boolean} */
Blessed.Widgets.Events.IKeyEventArg.prototype.ctrl;
 /** @type {boolean} */
Blessed.Widgets.Events.IKeyEventArg.prototype.meta;
 /** @type {string} */
Blessed.Widgets.Events.IKeyEventArg.prototype.sequence;
/**
 * @record
 * @struct
 */
Blessed.Widgets.NodeChildProcessExecOptions = function() {};
 /** @type {string} */
Blessed.Widgets.NodeChildProcessExecOptions.prototype.cwd;
 /** @type {?} */
Blessed.Widgets.NodeChildProcessExecOptions.prototype.stdio;
 /** @type {?} */
Blessed.Widgets.NodeChildProcessExecOptions.prototype.customFds;
 /** @type {?} */
Blessed.Widgets.NodeChildProcessExecOptions.prototype.env;
 /** @type {string} */
Blessed.Widgets.NodeChildProcessExecOptions.prototype.encoding;
 /** @type {number} */
Blessed.Widgets.NodeChildProcessExecOptions.prototype.timeout;
 /** @type {number} */
Blessed.Widgets.NodeChildProcessExecOptions.prototype.maxBuffer;
 /** @type {string} */
Blessed.Widgets.NodeChildProcessExecOptions.prototype.killSignal;
/**
 * @record
 * @struct
 */
Blessed.Widgets.IDestroyable = function() {};

/**
 * @return {void}
 */
Blessed.Widgets.IDestroyable.prototype.destroy = function() {};
/**
 * @record
 * @struct
 */
Blessed.Widgets.IOptions = function() {};
/**
 * @record
 * @struct
 */
Blessed.Widgets.IHasOptions = function() {};
 /** @type {T} */
Blessed.Widgets.IHasOptions.prototype.options;
/**
 * @extends {Blessed.Widgets.IOptions}
 * @record
 * @struct
 */
Blessed.Widgets.TputsOptions = function() {};
 /** @type {string} */
Blessed.Widgets.TputsOptions.prototype.terminal;
 /** @type {boolean} */
Blessed.Widgets.TputsOptions.prototype.extended;
 /** @type {boolean} */
Blessed.Widgets.TputsOptions.prototype.debug;
 /** @type {string} */
Blessed.Widgets.TputsOptions.prototype.termcap;
 /** @type {string} */
Blessed.Widgets.TputsOptions.prototype.terminfoFile;
 /** @type {string} */
Blessed.Widgets.TputsOptions.prototype.terminfoPrefix;
 /** @type {string} */
Blessed.Widgets.TputsOptions.prototype.termcapFile;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.TputsOptions} opts
 */
Blessed.Widgets.Tput = function(opts) {};
 /** @type {!Blessed.Widgets.TputsOptions} */
Blessed.Widgets.Tput.prototype.options;
 /** @type {boolean} */
Blessed.Widgets.Tput.prototype.debug;
 /** @type {boolean} */
Blessed.Widgets.Tput.prototype.padding;
 /** @type {boolean} */
Blessed.Widgets.Tput.prototype.extended;
 /** @type {boolean} */
Blessed.Widgets.Tput.prototype.printf;
 /** @type {string} */
Blessed.Widgets.Tput.prototype.termcap;
 /** @type {string} */
Blessed.Widgets.Tput.prototype.terminfoPrefix;
 /** @type {string} */
Blessed.Widgets.Tput.prototype.terminfoFile;
 /** @type {string} */
Blessed.Widgets.Tput.prototype.termcapFile;
 /** @type {!Error} */
Blessed.Widgets.Tput.prototype.error;
 /** @type {string} */
Blessed.Widgets.Tput.prototype.terminal;

/**
 * @return {void}
 */
Blessed.Widgets.Tput.prototype.setup = function() {};

/**
 * @param {?} is
 * @return {boolean}
 */
Blessed.Widgets.Tput.prototype.term = function(is) {};

/**
 * @param {string} term
 * @return {string}
 */
Blessed.Widgets.Tput.prototype.readTerminfo = function(term) {};

/**
 * @param {?} data
 * @param {string} file
 * @return {{header: {dataSize: number, headerSize: number, magicNumber: boolean, namesSize: number, boolCount: number, numCount: number, strCount: number, strTableSize: number, extended: {dataSize: number, headerSize: number, boolCount: number, numCount: number, strCount: number, strTableSize: number, lastStrTableOffset: number}}, name: string, names: !Array<string>, desc: string, bools: !Object, numbers: !Object, strings: !Object}}
 */
Blessed.Widgets.Tput.prototype.parseTerminfo = function(data, file) {};

/**
 * @return {void}
 */
Blessed.Widgets.IDestroyable.prototype.destroy = function() {};
/**
 * @extends {Blessed.Widgets.IOptions}
 * @record
 * @struct
 */
Blessed.Widgets.INodeOptions = function() {};
 /** @type {string} */
Blessed.Widgets.INodeOptions.prototype.name;
 /** @type {!Blessed.Widgets.Screen} */
Blessed.Widgets.INodeOptions.prototype.screen;
 /** @type {!Blessed.Widgets.Node} */
Blessed.Widgets.INodeOptions.prototype.parent;
 /** @type {!Array<!Blessed.Widgets.Node>} */
Blessed.Widgets.INodeOptions.prototype.children;
 /** @type {boolean} */
Blessed.Widgets.INodeOptions.prototype.focusable;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.INodeOptions} options
 */
Blessed.Widgets.Node = function(options) {};
 /** @type {boolean} */
Blessed.Widgets.Node.prototype.focusable;
 /** @type {!Blessed.Widgets.INodeOptions} */
Blessed.Widgets.Node.prototype.options;
 /** @type {!Object<string,?>} */
Blessed.Widgets.Node.prototype.data;
 /** @type {!Object<string,?>} */
Blessed.Widgets.Node.prototype._;
 /** @type {!Object<string,?>} */
Blessed.Widgets.Node.prototype.$;
 /** @type {string} */
Blessed.Widgets.Node.prototype.type;
 /** @type {number} */
Blessed.Widgets.Node.prototype.index;
 /** @type {!Blessed.Widgets.Screen} */
Blessed.Widgets.Node.prototype.screen;
 /** @type {!Blessed.Widgets.Node} */
Blessed.Widgets.Node.prototype.parent;
 /** @type {!Array<!Blessed.Widgets.Node>} */
Blessed.Widgets.Node.prototype.children;

/**
 * Prepend a node to this node's children.
 * @param {!Blessed.Widgets.Node} node
 * @return {void}
 */
Blessed.Widgets.Node.prototype.prepend = function(node) {};

/**
 * Append a node to this node's children.
 * @param {!Blessed.Widgets.Node} node
 * @return {void}
 */
Blessed.Widgets.Node.prototype.append = function(node) {};

/**
 * Remove child node from node.
 * @param {!Blessed.Widgets.Node} node
 * @return {void}
 */
Blessed.Widgets.Node.prototype.remove = function(node) {};

/**
 * Insert a node to this node's children at index i.
 * @param {!Blessed.Widgets.Node} node
 * @param {number} index
 * @return {void}
 */
Blessed.Widgets.Node.prototype.insert = function(node, index) {};

/**
 * Insert a node to this node's children before the reference node.
 * @param {!Blessed.Widgets.Node} node
 * @param {!Blessed.Widgets.Node} refNode
 * @return {void}
 */
Blessed.Widgets.Node.prototype.insertBefore = function(node, refNode) {};

/**
 * Insert a node from node after the reference node.
 * @param {!Blessed.Widgets.Node} node
 * @param {!Blessed.Widgets.Node} refNode
 * @return {void}
 */
Blessed.Widgets.Node.prototype.insertAfter = function(node, refNode) {};

/**
 * Remove node from its parent.
 * @return {void}
 */
Blessed.Widgets.Node.prototype.detach = function() {};

/**
 * Remove node from its parent.
 * @return {void}
 */
Blessed.Widgets.Node.prototype.free = function() {};

/**
 * Remove node from its parent.
 * @param {!Function} iter
 * @param {?} s
 * @return {void}
 */
Blessed.Widgets.Node.prototype.forDescendants = function(iter, s) {};

/**
 * Remove node from its parent.
 * @param {!Function} iter
 * @param {?} s
 * @return {void}
 */
Blessed.Widgets.Node.prototype.forAncestors = function(iter, s) {};

/**
 * Remove node from its parent.
 * @param {?} s
 * @return {void}
 */
Blessed.Widgets.Node.prototype.collectDescendants = function(s) {};

/**
 * Remove node from its parent.
 * @param {?} s
 * @return {void}
 */
Blessed.Widgets.Node.prototype.collectAncestors = function(s) {};

/**
 * Remove node from its parent.
 * Emit event for element, and recursively emit same event for all descendants.
 * @param {string=} type
 * @param {...?} args
 * @return {void}
 */
Blessed.Widgets.Node.prototype.emitDescendants = function(type, args) {};

/**
 * Remove node from its parent.
 * @return {void}
 */
Blessed.Widgets.Node.prototype.emitAncestors = function() {};

/**
 * Remove node from its parent.
 * @param {!Blessed.Widgets.Node} target
 * @return {void}
 */
Blessed.Widgets.Node.prototype.hasDescendant = function(target) {};

/**
 * Remove node from its parent.
 * @param {!Blessed.Widgets.Node} target
 * @return {boolean}
 */
Blessed.Widgets.Node.prototype.hasAncestor = function(target) {};

/**
 * Remove node from its parent.
 * @return {void}
 */
Blessed.Widgets.Node.prototype.destroy = function() {};

/**
 * Get user property with a potential default value.
 * @template T
 * @param {string} name
 * @param {T} def
 * @return {T}
 */
Blessed.Widgets.Node.prototype.get = function(name, def) {};

/**
 * Set user property to value.
 * @template T
 * @param {string} name
 * @param {T} value
 * @return {void}
 */
Blessed.Widgets.Node.prototype.set = function(name, value) {};

/**
 * Received when node is added to a parent.
 * Received when node is removed from it's current parent.
 * Received when node gains a new parent.
 * Received when node is attached to the screen directly or somewhere in its ancestry.
 * Received when node is detached from the screen directly or somewhere in its ancestry.
 * @param {string} event
 * @param {!Function|function(!Blessed.Widgets.Node): void} listener_or_callback
 * @return {Node}
 */
Blessed.Widgets.Node.prototype.on = function(event, listener_or_callback) {};
/**
 * @extends {Blessed.Widgets.Node}
 * @constructor
 * @struct
 */
Blessed.Widgets.NodeWithEvents = function() {};

/**
 * Bind a keypress listener for a specific key.
 * @param {(string|!Array<string>)} name
 * @param {!Function} listener
 * @return {void}
 */
Blessed.Widgets.NodeWithEvents.prototype.key = function(name, listener) {};

/**
 * Bind a keypress listener for a specific key once.
 * @param {string} name
 * @param {!Function} listener
 * @return {void}
 */
Blessed.Widgets.NodeWithEvents.prototype.onceKey = function(name, listener) {};

/**
 * Remove a keypress listener for a specific key.
 * @param {string} name
 * @param {!Function} listener
 * @return {void}
 */
Blessed.Widgets.NodeWithEvents.prototype.unkey = function(name, listener) {};

/**
 * @param {string} name
 * @param {!Function} listener
 * @return {void}
 */
Blessed.Widgets.NodeWithEvents.prototype.removeKey = function(name, listener) {};

/**
 * Received on screen resize.
 * Received on mouse events.
 * Received on key events.
 * Global events received for all elements.
 * Received when the terminal window focuses/blurs. Requires a terminal supporting the
 * focus protocol and focus needs to be passed to program.enableMouse().
 * Received when the terminal window focuses/blurs. Requires a terminal supporting the
 * focus protocol and focus needs to be passed to program.enableMouse().
 * Received before render.
 * Received on render.
 * Received when blessed notices something untoward (output is not a tty, terminfo not found, etc).
 * Received when the screen is destroyed (only useful when using multiple screens).
 * Received when the element is moved.
 * Element was clicked (slightly smarter than mouseup).
 * Received when element is shown.
 * Received when element becomes hidden.
 * @param {string} event
 * @param {!Function|function(): void|function(!Blessed.Widgets.Events.IMouseEventArg): void|function(string, !Blessed.Widgets.Events.IKeyEventArg): void|function(!Blessed.Widgets.Screen): void|function(string): void} listener_or_callback
 * @return {NodeWithEvents}
 */
Blessed.Widgets.NodeWithEvents.prototype.on = function(event, listener_or_callback) {};
/**
 * @extends {Blessed.Widgets.INodeOptions}
 * @record
 * @struct
 */
Blessed.Widgets.IScreenOptions = function() {};
 /** @type {!Blessed.BlessedProgram} */
Blessed.Widgets.IScreenOptions.prototype.program;
 /** @type {boolean} */
Blessed.Widgets.IScreenOptions.prototype.smartCSR;
 /** @type {boolean} */
Blessed.Widgets.IScreenOptions.prototype.fastCSR;
 /** @type {boolean} */
Blessed.Widgets.IScreenOptions.prototype.useBCE;
 /** @type {number} */
Blessed.Widgets.IScreenOptions.prototype.resizeTimeout;
 /** @type {number} */
Blessed.Widgets.IScreenOptions.prototype.tabSize;
 /** @type {boolean} */
Blessed.Widgets.IScreenOptions.prototype.autoPadding;
 /** @type {{artificial: boolean, shape: boolean, blink: boolean, color: string}} */
Blessed.Widgets.IScreenOptions.prototype.cursor;
 /** @type {function(!Array<?>): void} */
Blessed.Widgets.IScreenOptions.prototype.log;
 /** @type {string} */
Blessed.Widgets.IScreenOptions.prototype.dump;
 /** @type {function(!Array<string>): void} */
Blessed.Widgets.IScreenOptions.prototype.debug;
 /** @type {boolean} */
Blessed.Widgets.IScreenOptions.prototype.ignoreLocked;
 /** @type {boolean} */
Blessed.Widgets.IScreenOptions.prototype.dockBorders;
 /** @type {boolean} */
Blessed.Widgets.IScreenOptions.prototype.ignoreDockContrast;
 /** @type {boolean} */
Blessed.Widgets.IScreenOptions.prototype.fullUnicode;
 /** @type {boolean} */
Blessed.Widgets.IScreenOptions.prototype.sendFocus;
 /** @type {boolean} */
Blessed.Widgets.IScreenOptions.prototype.warnings;
 /** @type {boolean} */
Blessed.Widgets.IScreenOptions.prototype.forceUnicode;
 /** @type {!internal.Writable} */
Blessed.Widgets.IScreenOptions.prototype.input;
 /** @type {!internal.Readable} */
Blessed.Widgets.IScreenOptions.prototype.output;
 /** @type {!Blessed.Widgets.Tput} */
Blessed.Widgets.IScreenOptions.prototype.tput;
 /** @type {!Blessed.Widgets.BlessedElement} */
Blessed.Widgets.IScreenOptions.prototype.focused;
 /** @type {(string|number)} */
Blessed.Widgets.IScreenOptions.prototype.width;
 /** @type {(string|number)} */
Blessed.Widgets.IScreenOptions.prototype.height;
 /** @type {number} */
Blessed.Widgets.IScreenOptions.prototype.cols;
 /** @type {number} */
Blessed.Widgets.IScreenOptions.prototype.rows;
 /** @type {(string|number)} */
Blessed.Widgets.IScreenOptions.prototype.top;
 /** @type {(string|number)} */
Blessed.Widgets.IScreenOptions.prototype.left;
 /** @type {(string|number)} */
Blessed.Widgets.IScreenOptions.prototype.right;
 /** @type {(string|number)} */
Blessed.Widgets.IScreenOptions.prototype.bottom;
 /** @type {(string|number)} */
Blessed.Widgets.IScreenOptions.prototype.atop;
 /** @type {(string|number)} */
Blessed.Widgets.IScreenOptions.prototype.aleft;
 /** @type {(string|number)} */
Blessed.Widgets.IScreenOptions.prototype.aright;
 /** @type {(string|number)} */
Blessed.Widgets.IScreenOptions.prototype.abottom;
 /** @type {?} */
Blessed.Widgets.IScreenOptions.prototype.grabKeys;
 /** @type {boolean} */
Blessed.Widgets.IScreenOptions.prototype.lockKeys;
 /** @type {?} */
Blessed.Widgets.IScreenOptions.prototype.hover;
 /** @type {string} */
Blessed.Widgets.IScreenOptions.prototype.terminal;
 /** @type {string} */
Blessed.Widgets.IScreenOptions.prototype.title;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.IScreenOptions} opts
 */
Blessed.Widgets.Screen = function(opts) {};
 /** @type {?} */
Blessed.Widgets.Screen.prototype.cleanSides;
 /** @type {!Blessed.Widgets.IScreenOptions} */
Blessed.Widgets.Screen.prototype.options;
 /** @type {!Blessed.BlessedProgram} */
Blessed.Widgets.Screen.prototype.program;
 /** @type {boolean} */
Blessed.Widgets.Screen.prototype.smartCSR;
 /** @type {boolean} */
Blessed.Widgets.Screen.prototype.fastCSR;
 /** @type {boolean} */
Blessed.Widgets.Screen.prototype.useBCE;
 /** @type {number} */
Blessed.Widgets.Screen.prototype.resizeTimeout;
 /** @type {number} */
Blessed.Widgets.Screen.prototype.tabSize;
 /** @type {boolean} */
Blessed.Widgets.Screen.prototype.autoPadding;
 /** @type {{artificial: boolean, shape: boolean, blink: boolean, color: string}} */
Blessed.Widgets.Screen.prototype.cursor;
 /** @type {string} */
Blessed.Widgets.Screen.prototype.dump;
 /** @type {boolean} */
Blessed.Widgets.Screen.prototype.ignoreLocked;
 /** @type {boolean} */
Blessed.Widgets.Screen.prototype.dockBorders;
 /** @type {boolean} */
Blessed.Widgets.Screen.prototype.ignoreDockContrast;
 /** @type {boolean} */
Blessed.Widgets.Screen.prototype.fullUnicode;
 /** @type {boolean} */
Blessed.Widgets.Screen.prototype.sendFocus;
 /** @type {boolean} */
Blessed.Widgets.Screen.prototype.warnings;
 /** @type {boolean} */
Blessed.Widgets.Screen.prototype.forceUnicode;
 /** @type {!internal.Writable} */
Blessed.Widgets.Screen.prototype.input;
 /** @type {!internal.Readable} */
Blessed.Widgets.Screen.prototype.output;
 /** @type {!Blessed.Widgets.Tput} */
Blessed.Widgets.Screen.prototype.tput;
 /** @type {!Blessed.Widgets.BlessedElement} */
Blessed.Widgets.Screen.prototype.focused;
 /** @type {(string|number)} */
Blessed.Widgets.Screen.prototype.width;
 /** @type {(string|number)} */
Blessed.Widgets.Screen.prototype.height;
 /** @type {number} */
Blessed.Widgets.Screen.prototype.cols;
 /** @type {number} */
Blessed.Widgets.Screen.prototype.rows;
 /** @type {(string|number)} */
Blessed.Widgets.Screen.prototype.top;
 /** @type {(string|number)} */
Blessed.Widgets.Screen.prototype.left;
 /** @type {(string|number)} */
Blessed.Widgets.Screen.prototype.right;
 /** @type {(string|number)} */
Blessed.Widgets.Screen.prototype.bottom;
 /** @type {(string|number)} */
Blessed.Widgets.Screen.prototype.atop;
 /** @type {(string|number)} */
Blessed.Widgets.Screen.prototype.aleft;
 /** @type {(string|number)} */
Blessed.Widgets.Screen.prototype.aright;
 /** @type {(string|number)} */
Blessed.Widgets.Screen.prototype.abottom;
 /** @type {?} */
Blessed.Widgets.Screen.prototype.grabKeys;
 /** @type {boolean} */
Blessed.Widgets.Screen.prototype.lockKeys;
 /** @type {?} */
Blessed.Widgets.Screen.prototype.hover;
 /** @type {string} */
Blessed.Widgets.Screen.prototype.terminal;
 /** @type {string} */
Blessed.Widgets.Screen.prototype.title;

/**
 * Write string to the log file if one was created.
 * @param {...?} msg
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.log = function(msg) {};

/**
 * Same as the log method, but only gets called if the debug option was set.
 * @param {...string} msg
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.debug = function(msg) {};

/**
 * Allocate a new pending screen buffer and a new output screen buffer.
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.alloc = function() {};

/**
 * Reallocate the screen buffers and clear the screen.
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.realloc = function() {};

/**
 * Draw the screen based on the contents of the screen buffer.
 * @param {number} start
 * @param {number} end
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.draw = function(start, end) {};

/**
 * Render all child elements, writing all data to the screen buffer and drawing the screen.
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.render = function() {};

/**
 * Clear any region on the screen.
 * @param {number} x1
 * @param {number} x2
 * @param {number} y1
 * @param {number} y2
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.clearRegion = function(x1, x2, y1, y2) {};

/**
 * Fill any region with a character of a certain attribute.
 * @param {string} attr
 * @param {string} ch
 * @param {number} x1
 * @param {number} x2
 * @param {number} y1
 * @param {number} y2
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.fillRegion = function(attr, ch, x1, x2, y1, y2) {};

/**
 * Focus element by offset of focusable elements.
 * @param {number} offset
 * @return {?}
 */
Blessed.Widgets.Screen.prototype.focusOffset = function(offset) {};

/**
 * Focus previous element in the index.
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.focusPrevious = function() {};

/**
 * Focus next element in the index.
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.focusNext = function() {};

/**
 * Push element on the focus stack (equivalent to screen.focused = el).
 * @param {!Blessed.Widgets.BlessedElement} element
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.focusPush = function(element) {};

/**
 * Pop element off the focus stack.
 * @return {!Blessed.Widgets.BlessedElement}
 */
Blessed.Widgets.Screen.prototype.focusPop = function() {};

/**
 * Save the focused element.
 * @return {!Blessed.Widgets.BlessedElement}
 */
Blessed.Widgets.Screen.prototype.saveFocus = function() {};

/**
 * Restore the saved focused element.
 * @return {!Blessed.Widgets.BlessedElement}
 */
Blessed.Widgets.Screen.prototype.restoreFocus = function() {};

/**
 * "Rewind" focus to the last visible and attached element.
 * @return {!Blessed.Widgets.BlessedElement}
 */
Blessed.Widgets.Screen.prototype.rewindFocus = function() {};

/**
 * Spawn a process in the foreground, return to blessed app after exit.
 * @param {string} file
 * @param {!Array<string>} args
 * @param {!Blessed.Widgets.NodeChildProcessExecOptions} options
 * @return {!ChildProcess}
 */
Blessed.Widgets.Screen.prototype.spawn = function(file, args, options) {};

/**
 * Spawn a process in the foreground, return to blessed app after exit. Executes callback on error or exit.
 * @param {string} file
 * @param {!Array<string>} args
 * @param {!Blessed.Widgets.NodeChildProcessExecOptions} options
 * @param {!Function} callback
 * @return {!ChildProcess}
 */
Blessed.Widgets.Screen.prototype.exec = function(file, args, options, callback) {};

/**
 * Read data from text editor.
 * @param {?|function(!NodeJS.ErrnoException, ?): void} options_or_callback
 * @param {function(!NodeJS.ErrnoException, ?): void=} callback
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.readEditor = function(options_or_callback, callback) {};

/**
 * Set effects based on two events and attributes.
 * @param {!Blessed.Widgets.BlessedElement} el
 * @param {!Blessed.Widgets.BlessedElement} fel
 * @param {?} over
 * @param {?} out
 * @param {?} effects
 * @param {?} temp
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.setEffects = function(el, fel, over, out, effects, temp) {};

/**
 * Insert a line into the screen (using csr: this bypasses the output buffer).
 * @param {number} n
 * @param {number} y
 * @param {number} top
 * @param {number} bottom
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.insertLine = function(n, y, top, bottom) {};

/**
 * Delete a line from the screen (using csr: this bypasses the output buffer).
 * @param {number} n
 * @param {number} y
 * @param {number} top
 * @param {number} bottom
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.deleteLine = function(n, y, top, bottom) {};

/**
 * Insert a line at the bottom of the screen.
 * @param {number} top
 * @param {number} bottom
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.insertBottom = function(top, bottom) {};

/**
 * Insert a line at the top of the screen.
 * @param {number} top
 * @param {number} bottom
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.insertTop = function(top, bottom) {};

/**
 * Delete a line at the bottom of the screen.
 * @param {number} top
 * @param {number} bottom
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.deleteBottom = function(top, bottom) {};

/**
 * Delete a line at the top of the screen.
 * @param {number} top
 * @param {number} bottom
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.deleteTop = function(top, bottom) {};

/**
 * Enable mouse events for the screen and optionally an element (automatically called when a form of
 * on('mouse') is bound).
 * @param {!Blessed.Widgets.BlessedElement=} el
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.enableMouse = function(el) {};

/**
 * Enable keypress events for the screen and optionally an element (automatically called when a form of
 * on('keypress') is bound).
 * @param {!Blessed.Widgets.BlessedElement=} el
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.enableKeys = function(el) {};

/**
 * Enable key and mouse events. Calls bot enableMouse and enableKeys.
 * @param {!Blessed.Widgets.BlessedElement=} el
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.enableInput = function(el) {};

/**
 * Attempt to copy text to clipboard using iTerm2's proprietary sequence. Returns true if successful.
 * @param {string} text
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.copyToClipboard = function(text) {};

/**
 * Attempt to change cursor shape. Will not work in all terminals (see artificial cursors for a solution
 * to this). Returns true if successful.
 * @param {boolean} shape
 * @param {boolean} blink
 * @return {?}
 */
Blessed.Widgets.Screen.prototype.cursorShape = function(shape, blink) {};

/**
 * Attempt to change cursor color. Returns true if successful.
 * @param {string} color
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.cursorColor = function(color) {};

/**
 * Attempt to reset cursor. Returns true if successful.
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.cursorReset = function() {};

/**
 * Take an SGR screenshot of the screen within the region. Returns a string containing only
 * characters and SGR codes. Can be displayed by simply echoing it in a terminal.
 * @param {number=} xi
 * @param {number=} xl
 * @param {number=} yi
 * @param {number=} yl
 * @return {string|void}
 */
Blessed.Widgets.Screen.prototype.screenshot = function(xi, xl, yi, yl) {};

/**
 * Destroy the screen object and remove it from the global list. Also remove all global events relevant
 * to the screen object. If all screen objects are destroyed, the node process is essentially reset
 * to its initial state.
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.destroy = function() {};

/**
 * Reset the terminal to term. Reloads terminfo.
 * @param {string} term
 * @return {void}
 */
Blessed.Widgets.Screen.prototype.setTerminal = function(term) {};
/**
 * @record
 * @struct
 */
Blessed.Widgets.Padding = function() {};
 /** @type {number} */
Blessed.Widgets.Padding.prototype.left;
 /** @type {number} */
Blessed.Widgets.Padding.prototype.right;
 /** @type {number} */
Blessed.Widgets.Padding.prototype.top;
 /** @type {number} */
Blessed.Widgets.Padding.prototype.bottom;
/**
 * @constructor
 * @struct
 */
Blessed.Widgets.PositionCoords = function() {};
 /** @type {number} */
Blessed.Widgets.PositionCoords.prototype.xi;
 /** @type {number} */
Blessed.Widgets.PositionCoords.prototype.xl;
 /** @type {number} */
Blessed.Widgets.PositionCoords.prototype.yi;
 /** @type {number} */
Blessed.Widgets.PositionCoords.prototype.yl;
/**
 * @record
 * @struct
 */
Blessed.Widgets.Position = function() {};
 /** @type {(string|number)} */
Blessed.Widgets.Position.prototype.left;
 /** @type {(string|number)} */
Blessed.Widgets.Position.prototype.right;
 /** @type {(string|number)} */
Blessed.Widgets.Position.prototype.top;
 /** @type {(string|number)} */
Blessed.Widgets.Position.prototype.bottom;
/**
 * @record
 * @struct
 */
Blessed.Widgets.Border = function() {};
 /** @type {string} */
Blessed.Widgets.Border.prototype.type;
 /** @type {string} */
Blessed.Widgets.Border.prototype.ch;
 /** @type {number} */
Blessed.Widgets.Border.prototype.bg;
 /** @type {number} */
Blessed.Widgets.Border.prototype.fg;
 /** @type {string} */
Blessed.Widgets.Border.prototype.bold;
 /** @type {string} */
Blessed.Widgets.Border.prototype.underline;
/**
 * @extends {Blessed.Widgets.INodeOptions}
 * @record
 * @struct
 */
Blessed.Widgets.ElementOptions = function() {};
 /** @type {boolean} */
Blessed.Widgets.ElementOptions.prototype.tags;
 /** @type {string} */
Blessed.Widgets.ElementOptions.prototype.fg;
 /** @type {string} */
Blessed.Widgets.ElementOptions.prototype.bg;
 /** @type {string} */
Blessed.Widgets.ElementOptions.prototype.bold;
 /** @type {string} */
Blessed.Widgets.ElementOptions.prototype.underline;
 /** @type {?} */
Blessed.Widgets.ElementOptions.prototype.style;
 /** @type {(string|!Blessed.Widgets.Border)} */
Blessed.Widgets.ElementOptions.prototype.border;
 /** @type {string} */
Blessed.Widgets.ElementOptions.prototype.content;
 /** @type {boolean} */
Blessed.Widgets.ElementOptions.prototype.clickable;
 /** @type {boolean} */
Blessed.Widgets.ElementOptions.prototype.input;
 /** @type {boolean} */
Blessed.Widgets.ElementOptions.prototype.keyable;
 /** @type {!Blessed.Widgets.BlessedElement} */
Blessed.Widgets.ElementOptions.prototype.focused;
 /** @type {boolean} */
Blessed.Widgets.ElementOptions.prototype.hidden;
 /** @type {string} */
Blessed.Widgets.ElementOptions.prototype.label;
 /** @type {string} */
Blessed.Widgets.ElementOptions.prototype.hoverText;
 /** @type {string} */
Blessed.Widgets.ElementOptions.prototype.align;
 /** @type {string} */
Blessed.Widgets.ElementOptions.prototype.valign;
 /** @type {boolean} */
Blessed.Widgets.ElementOptions.prototype.shrink;
 /** @type {(number|!Blessed.Widgets.Padding)} */
Blessed.Widgets.ElementOptions.prototype.padding;
 /** @type {(string|number)} */
Blessed.Widgets.ElementOptions.prototype.top;
 /** @type {(string|number)} */
Blessed.Widgets.ElementOptions.prototype.left;
 /** @type {(string|number)} */
Blessed.Widgets.ElementOptions.prototype.right;
 /** @type {(string|number)} */
Blessed.Widgets.ElementOptions.prototype.bottom;
 /** @type {(string|number)} */
Blessed.Widgets.ElementOptions.prototype.width;
 /** @type {(string|number)} */
Blessed.Widgets.ElementOptions.prototype.height;
 /** @type {!Blessed.Widgets.Position} */
Blessed.Widgets.ElementOptions.prototype.position;
 /** @type {boolean} */
Blessed.Widgets.ElementOptions.prototype.scrollable;
 /** @type {string} */
Blessed.Widgets.ElementOptions.prototype.ch;
 /** @type {boolean} */
Blessed.Widgets.ElementOptions.prototype.draggable;
 /** @type {boolean} */
Blessed.Widgets.ElementOptions.prototype.shadow;
/**
 * @record
 * @struct
 */
Blessed.Widgets.Coords = function() {};
 /** @type {number} */
Blessed.Widgets.Coords.prototype.xl;
 /** @type {number} */
Blessed.Widgets.Coords.prototype.xi;
 /** @type {number} */
Blessed.Widgets.Coords.prototype.yl;
 /** @type {number} */
Blessed.Widgets.Coords.prototype.yi;
 /** @type {number} */
Blessed.Widgets.Coords.prototype.base;
 /** @type {{x: number, y: number}} */
Blessed.Widgets.Coords.prototype._contentEnd;
 /** @type {(string|number)} */
Blessed.Widgets.Coords.prototype.notop;
 /** @type {(string|number)} */
Blessed.Widgets.Coords.prototype.noleft;
 /** @type {(string|number)} */
Blessed.Widgets.Coords.prototype.noright;
 /** @type {(string|number)} */
Blessed.Widgets.Coords.prototype.nobot;
/**
 * @record
 * @struct
 */
Blessed.Widgets.LabelOptions = function() {};
 /** @type {string} */
Blessed.Widgets.LabelOptions.prototype.text;
 /** @type {string} */
Blessed.Widgets.LabelOptions.prototype.side;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.ElementOptions} opts
 */
Blessed.Widgets.BlessedElement = function(opts) {};
 /** @type {!Blessed.Widgets.ElementOptions} */
Blessed.Widgets.BlessedElement.prototype.options;
 /** @type {string} */
Blessed.Widgets.BlessedElement.prototype.name;
 /** @type {!Blessed.Widgets.Border} */
Blessed.Widgets.BlessedElement.prototype.border;
 /** @type {?} */
Blessed.Widgets.BlessedElement.prototype.style;
 /** @type {!Blessed.Widgets.Position} */
Blessed.Widgets.BlessedElement.prototype.position;
 /** @type {string} */
Blessed.Widgets.BlessedElement.prototype.content;
 /** @type {boolean} */
Blessed.Widgets.BlessedElement.prototype.hidden;
 /** @type {boolean} */
Blessed.Widgets.BlessedElement.prototype.visible;
 /** @type {boolean} */
Blessed.Widgets.BlessedElement.prototype.detached;
 /** @type {number} */
Blessed.Widgets.BlessedElement.prototype.bg;
 /** @type {number} */
Blessed.Widgets.BlessedElement.prototype.fg;
 /** @type {string} */
Blessed.Widgets.BlessedElement.prototype.bold;
 /** @type {string} */
Blessed.Widgets.BlessedElement.prototype.underline;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.width;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.height;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.top;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.left;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.right;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.bottom;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.atop;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.aleft;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.aright;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.abottom;
 /** @type {boolean} */
Blessed.Widgets.BlessedElement.prototype.draggable;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.itop;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.ileft;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.iheight;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.iwidth;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.rtop;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.rleft;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.rright;
 /** @type {(string|number)} */
Blessed.Widgets.BlessedElement.prototype.rbottom;
 /** @type {!Blessed.Widgets.PositionCoords} */
Blessed.Widgets.BlessedElement.prototype.lpos;

/**
 * Write content and children to the screen buffer.
 * @return {!Blessed.Widgets.Coords}
 */
Blessed.Widgets.BlessedElement.prototype.render = function() {};

/**
 * Hide element.
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.hide = function() {};

/**
 * Show element.
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.show = function() {};

/**
 * Toggle hidden/shown.
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.toggle = function() {};

/**
 * Focus element.
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.focus = function() {};

/**
 * Same asel.on('screen', ...) except this will automatically keep track of which listeners
 * are bound to the screen object. For use with removeScreenEvent(), free(), and destroy().
 * @param {string} type
 * @param {!Function} handler
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.onScreenEvent = function(type, handler) {};

/**
 * Same asel.removeListener('screen', ...) except this will automatically keep track of which
 * listeners are bound to the screen object. For use with onScreenEvent(), free(), and destroy().
 * @param {string} type
 * @param {!Function} handler
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.removeScreenEvent = function(type, handler) {};

/**
 * Free up the element. Automatically unbind all events that may have been bound to the screen
 * object. This prevents memory leaks. For use with onScreenEvent(), removeScreenEvent(),
 * and destroy().
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.free = function() {};

/**
 * Same as the detach() method, except this will automatically call free() and unbind any screen
 * events to prevent memory leaks. for use with onScreenEvent(), removeScreenEvent(), and free().
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.destroy = function() {};

/**
 * Set the z-index of the element (changes rendering order).
 * @param {number} z
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.setIndex = function(z) {};

/**
 * Put the element in front of its siblings.
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.setFront = function() {};

/**
 * Put the element in back of its siblings.
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.setBack = function() {};

/**
 * text/options - Set the label text for the top-left corner. Example options: {text:'foo',side:'left'}
 * @param {(string|!Blessed.Widgets.LabelOptions)} arg
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.setLabel = function(arg) {};

/**
 * Remove the label completely.
 * @return {?}
 */
Blessed.Widgets.BlessedElement.prototype.removeLabel = function() {};

/**
 * text/options - Set a hover text box to follow the cursor. Similar to the "title" DOM attribute
 * in the browser. Example options: {text:'foo'}
 * @param {(string|!Blessed.Widgets.LabelOptions)} arg
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.setHover = function(arg) {};

/**
 * Remove the hover label completely.
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.removeHover = function() {};

/**
 * Enable mouse events for the element (automatically called when a form of on('mouse') is bound).
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.enableMouse = function() {};

/**
 * Enable keypress events for the element (automatically called when a form of on('keypress') is bound).
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.enableKeys = function() {};

/**
 * Enable key and mouse events. Calls bot enableMouse and enableKeys.
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.enableInput = function() {};

/**
 * Enable dragging of the element.
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.enableDrag = function() {};

/**
 * Disable dragging of the element.
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.disableDrag = function() {};

/**
 * Take an SGR screenshot of the screen within the region. Returns a string containing only
 * characters and SGR codes. Can be displayed by simply echoing it in a terminal.
 * @param {number=} xi
 * @param {number=} xl
 * @param {number=} yi
 * @param {number=} yl
 * @return {string|void}
 */
Blessed.Widgets.BlessedElement.prototype.screenshot = function(xi, xl, yi, yl) {};

/**
 * Set the content. Note: When text is input, it will be stripped of all non-SGR
 * escape codes, tabs will be replaced with 8 spaces, and tags will be replaced
 * with SGR codes (if enabled).
 * @param {string} text
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.setContent = function(text) {};

/**
 * Return content, slightly different from el.content. Assume the above formatting.
 * @return {string}
 */
Blessed.Widgets.BlessedElement.prototype.getContent = function() {};

/**
 * Similar to setContent, but ignore tags and remove escape codes.
 * @param {string} text
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.setText = function(text) {};

/**
 * Similar to getContent, but return content with tags and escape codes removed.
 * @return {string}
 */
Blessed.Widgets.BlessedElement.prototype.getText = function() {};

/**
 * Insert a line into the box's content.
 * @param {number} i
 * @param {(string|!Array<string>)} lines
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.insertLine = function(i, lines) {};

/**
 * Delete a line from the box's content.
 * @param {number} i
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.deleteLine = function(i) {};

/**
 * Get a line from the box's content.
 * @param {number} i
 * @return {string}
 */
Blessed.Widgets.BlessedElement.prototype.getLine = function(i) {};

/**
 * Get a line from the box's content from the visible top.
 * @param {number} i
 * @return {string}
 */
Blessed.Widgets.BlessedElement.prototype.getBaseLine = function(i) {};

/**
 * Set a line in the box's content.
 * @param {number} i
 * @param {(string|!Array<string>)} line
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.setLine = function(i, line) {};

/**
 * Set a line in the box's content from the visible top.
 * @param {number} i
 * @param {(string|!Array<string>)} line
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.setBaseLine = function(i, line) {};

/**
 * Clear a line from the box's content.
 * @param {number} i
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.clearLine = function(i) {};

/**
 * Clear a line from the box's content from the visible top.
 * @param {number} i
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.clearBaseLine = function(i) {};

/**
 * Insert a line at the top of the box.
 * @param {(string|!Array<string>)} lines
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.insertTop = function(lines) {};

/**
 * Insert a line at the bottom of the box.
 * @param {(string|!Array<string>)} lines
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.insertBottom = function(lines) {};

/**
 * Delete a line at the top of the box.
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.deleteTop = function() {};

/**
 * Delete a line at the bottom of the box.
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.deleteBottom = function() {};

/**
 * Unshift a line onto the top of the content.
 * @param {(string|!Array<string>)} lines
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.unshiftLine = function(lines) {};

/**
 * Shift a line off the top of the content.
 * @param {number} i
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.shiftLine = function(i) {};

/**
 * Push a line onto the bottom of the content.
 * @param {(string|!Array<string>)} lines
 * @return {void}
 */
Blessed.Widgets.BlessedElement.prototype.pushLine = function(lines) {};

/**
 * Pop a line off the bottom of the content.
 * @param {number} i
 * @return {string}
 */
Blessed.Widgets.BlessedElement.prototype.popLine = function(i) {};

/**
 * An array containing the content lines.
 * @return {!Array<string>}
 */
Blessed.Widgets.BlessedElement.prototype.getLines = function() {};

/**
 * An array containing the lines as they are displayed on the screen.
 * @return {!Array<string>}
 */
Blessed.Widgets.BlessedElement.prototype.getScreenLines = function() {};

/**
 * Get a string's displayed width, taking into account double-width, surrogate pairs,
 * combining characters, tags, and SGR escape codes.
 * @param {string} text
 * @return {string}
 */
Blessed.Widgets.BlessedElement.prototype.strWidth = function(text) {};
/**
 * @extends {Blessed.Widgets.ElementOptions}
 * @record
 * @struct
 */
Blessed.Widgets.ScrollableBoxOptions = function() {};
 /** @type {number} */
Blessed.Widgets.ScrollableBoxOptions.prototype.baseLimit;
 /** @type {boolean} */
Blessed.Widgets.ScrollableBoxOptions.prototype.alwaysScroll;
 /** @type {{style: ?, track: ?, ch: string}} */
Blessed.Widgets.ScrollableBoxOptions.prototype.scrollbar;
/**
 * @extends {Blessed.Widgets.ScrollableBoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.ScrollableTextOptions = function() {};
 /** @type {(boolean|function(): void)} */
Blessed.Widgets.ScrollableTextOptions.prototype.mouse;
 /** @type {(string|boolean|!Array<string>)} */
Blessed.Widgets.ScrollableTextOptions.prototype.keys;
 /** @type {boolean} */
Blessed.Widgets.ScrollableTextOptions.prototype.vi;
/**
 * @extends {Blessed.Widgets.ScrollableTextOptions}
 * @record
 * @struct
 */
Blessed.Widgets.BoxOptions = function() {};
 /** @type {?} */
Blessed.Widgets.BoxOptions.prototype.bindings;
/**
 * @extends {Blessed.Widgets.BlessedElement}
 * @constructor
 * @struct
 */
Blessed.Widgets.ScrollableBoxElement = function() {};
 /** @type {number} */
Blessed.Widgets.ScrollableBoxElement.prototype.childBase;
 /** @type {number} */
Blessed.Widgets.ScrollableBoxElement.prototype.childOffset;

/**
 * Scroll the content by a relative offset.
 * @param {number} offset
 * @param {boolean=} always
 * @return {void}
 */
Blessed.Widgets.ScrollableBoxElement.prototype.scroll = function(offset, always) {};

/**
 * Scroll the content to an absolute index.
 * @param {number} index
 * @return {void}
 */
Blessed.Widgets.ScrollableBoxElement.prototype.scrollTo = function(index) {};

/**
 * Same as scrollTo.
 * @param {number} index
 * @return {void}
 */
Blessed.Widgets.ScrollableBoxElement.prototype.setScroll = function(index) {};

/**
 * Set the current scroll index in percentage (0-100).
 * @param {number} perc
 * @return {void}
 */
Blessed.Widgets.ScrollableBoxElement.prototype.setScrollPerc = function(perc) {};

/**
 * Get the current scroll index in lines.
 * @return {number}
 */
Blessed.Widgets.ScrollableBoxElement.prototype.getScroll = function() {};

/**
 * Get the actual height of the scrolling area.
 * @return {number}
 */
Blessed.Widgets.ScrollableBoxElement.prototype.getScrollHeight = function() {};

/**
 * Get the current scroll index in percentage.
 * @return {number}
 */
Blessed.Widgets.ScrollableBoxElement.prototype.getScrollPerc = function() {};

/**
 * Reset the scroll index to its initial state.
 * @return {void}
 */
Blessed.Widgets.ScrollableBoxElement.prototype.resetScroll = function() {};

/**
 * Received when the element is scrolled.
 * @param {string} event
 * @param {!Function|function(): void} listener_or_callback
 * @return {ScrollableBoxElement}
 */
Blessed.Widgets.ScrollableBoxElement.prototype.on = function(event, listener_or_callback) {};
/**
 * @extends {Blessed.Widgets.ScrollableBoxElement}
 * @constructor
 * @struct
 */
Blessed.Widgets.ScrollableTextElement = function() {};

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.BoxOptions} opts
 */
Blessed.Widgets.BoxElement = function(opts) {};
 /** @type {!Blessed.Widgets.BoxOptions} */
Blessed.Widgets.BoxElement.prototype.options;
/**
 * @extends {Blessed.Widgets.ElementOptions}
 * @record
 * @struct
 */
Blessed.Widgets.TextOptions = function() {};
 /** @type {boolean} */
Blessed.Widgets.TextOptions.prototype.fill;
 /** @type {string} */
Blessed.Widgets.TextOptions.prototype.align;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.TextOptions} opts
 */
Blessed.Widgets.TextElement = function(opts) {};
 /** @type {!Blessed.Widgets.TextOptions} */
Blessed.Widgets.TextElement.prototype.options;
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.LineOptions = function() {};
 /** @type {string} */
Blessed.Widgets.LineOptions.prototype.orientation;
 /** @type {string} */
Blessed.Widgets.LineOptions.prototype.type;
 /** @type {string} */
Blessed.Widgets.LineOptions.prototype.bg;
 /** @type {string} */
Blessed.Widgets.LineOptions.prototype.fg;
 /** @type {string} */
Blessed.Widgets.LineOptions.prototype.ch;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.LineOptions} opts
 */
Blessed.Widgets.LineElement = function(opts) {};
 /** @type {!Blessed.Widgets.LineOptions} */
Blessed.Widgets.LineElement.prototype.options;
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.BigTextOptions = function() {};
 /** @type {string} */
Blessed.Widgets.BigTextOptions.prototype.font;
 /** @type {string} */
Blessed.Widgets.BigTextOptions.prototype.fontBold;
 /** @type {string} */
Blessed.Widgets.BigTextOptions.prototype.fch;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.BigTextOptions} opts
 */
Blessed.Widgets.BigTextElement = function(opts) {};
 /** @type {!Blessed.Widgets.BigTextOptions} */
Blessed.Widgets.BigTextElement.prototype.options;
/**
 * @record
 * @struct
 */
Blessed.Widgets.ListElementStyle = function() {};
 /** @type {?} */
Blessed.Widgets.ListElementStyle.prototype.selected;
 /** @type {?} */
Blessed.Widgets.ListElementStyle.prototype.item;
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.ListOptions = function() {};
 /** @type {TStyle} */
Blessed.Widgets.ListOptions.prototype.style;
 /** @type {!Array<string>} */
Blessed.Widgets.ListOptions.prototype.items;
 /** @type {function(): void} */
Blessed.Widgets.ListOptions.prototype.search;
 /** @type {boolean} */
Blessed.Widgets.ListOptions.prototype.interactive;
 /** @type {boolean} */
Blessed.Widgets.ListOptions.prototype.invertSelected;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.ListOptions<!Blessed.Widgets.ListElementStyle>} opts
 */
Blessed.Widgets.ListElement = function(opts) {};
 /** @type {!Blessed.Widgets.ListOptions<!Blessed.Widgets.ListElementStyle>} */
Blessed.Widgets.ListElement.prototype.options;

/**
 * Add an item based on a string.
 * @param {string} text
 * @return {void}
 */
Blessed.Widgets.ListElement.prototype.add = function(text) {};

/**
 * Add an item based on a string.
 * @param {string} text
 * @return {void}
 */
Blessed.Widgets.ListElement.prototype.addItem = function(text) {};

/**
 * Removes an item from the list. Child can be an element, index, or string.
 * @param {!Blessed.Widgets.BlessedElement} child
 * @return {!Blessed.Widgets.BlessedElement}
 */
Blessed.Widgets.ListElement.prototype.removeItem = function(child) {};

/**
 * Push an item onto the list.
 * 
 * @param {!Blessed.Widgets.BlessedElement} child
 * @return {number}
 */
Blessed.Widgets.ListElement.prototype.pushItem = function(child) {};

/**
 * Pop an item off the list.
 * 
 * @return {!Blessed.Widgets.BlessedElement}
 */
Blessed.Widgets.ListElement.prototype.popItem = function() {};

/**
 * Unshift an item onto the list.
 * @param {!Blessed.Widgets.BlessedElement} child
 * @return {number}
 */
Blessed.Widgets.ListElement.prototype.unshiftItem = function(child) {};

/**
 * Shift an item off the list.
 * 
 * @return {!Blessed.Widgets.BlessedElement}
 */
Blessed.Widgets.ListElement.prototype.shiftItem = function() {};

/**
 * Inserts an item to the list. Child can be an element, index, or string.
 * @param {number} i
 * @param {!Blessed.Widgets.BlessedElement} child
 * @return {void}
 */
Blessed.Widgets.ListElement.prototype.insertItem = function(i, child) {};

/**
 * Returns the item element. Child can be an element, index, or string.
 * @param {!Blessed.Widgets.BlessedElement} child
 * @return {!Blessed.Widgets.BlessedElement}
 */
Blessed.Widgets.ListElement.prototype.getItem = function(child) {};

/**
 * Set item to content.
 * @param {!Blessed.Widgets.BlessedElement} child
 * @param {(string|!Blessed.Widgets.BlessedElement)} content
 * @return {void}
 */
Blessed.Widgets.ListElement.prototype.setItem = function(child, content) {};

/**
 * Remove and insert items to the list.
 * 
 * @param {number} i
 * @param {number} n
 * @param {...!Blessed.Widgets.BlessedElement} items
 * @return {void}
 */
Blessed.Widgets.ListElement.prototype.spliceItem = function(i, n, items) {};

/**
 * Clears all items from the list.
 * 
 * @return {void}
 */
Blessed.Widgets.ListElement.prototype.clearItems = function() {};

/**
 * Sets the list items to multiple strings.
 * @param {!Array<!Blessed.Widgets.BlessedElement>} items
 * @return {void}
 */
Blessed.Widgets.ListElement.prototype.setItems = function(items) {};

/**
 * Returns the item index from the list. Child can be an element, index, or string.
 * @param {!Blessed.Widgets.BlessedElement} child
 * @return {number}
 */
Blessed.Widgets.ListElement.prototype.getItemIndex = function(child) {};

/**
 * Select an index of an item.
 * 
 * @param {number} index
 * @return {void}
 */
Blessed.Widgets.ListElement.prototype.select = function(index) {};

/**
 * Select item based on current offset.
 * 
 * @param {number} offset
 * @return {void}
 */
Blessed.Widgets.ListElement.prototype.move = function(offset) {};

/**
 * Select item above selected.
 * 
 * @param {number} amount
 * @return {void}
 */
Blessed.Widgets.ListElement.prototype.up = function(amount) {};

/**
 * Select item below selected.
 * @param {number} amount
 * @return {void}
 */
Blessed.Widgets.ListElement.prototype.down = function(amount) {};

/**
 * Show/focus list and pick an item. The callback is executed with the result.
 * @param {function(): void} callback
 * @return {void}
 */
Blessed.Widgets.ListElement.prototype.pick = function(callback) {};

/**
 * Find an item based on its text content.
 * @param {(string|!RegExp|function(): void)} arg
 * @return {void}
 */
Blessed.Widgets.ListElement.prototype.fuzzyFind = function(arg) {};

/**
 * Received when an item is selected.
 * List was canceled (when esc is pressed with the keys option).
 * Either a select or a cancel event was received.
 * @param {string} event
 * @param {!Function|function(!Blessed.Widgets.BoxElement, number): void|function(): void|function(!Blessed.Widgets.BlessedElement, number): void} listener_or_callback
 * @return {ListElement}
 */
Blessed.Widgets.ListElement.prototype.on = function(event, listener_or_callback) {};
/**
 * @extends {Blessed.Widgets.ListOptions}
 * @record
 * @struct
 */
Blessed.Widgets.FileManagerOptions = function() {};
 /** @type {string} */
Blessed.Widgets.FileManagerOptions.prototype.cwd;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.FileManagerOptions} opts
 */
Blessed.Widgets.FileManagerElement = function(opts) {};
 /** @type {!Blessed.Widgets.FileManagerOptions} */
Blessed.Widgets.FileManagerElement.prototype.options;
 /** @type {string} */
Blessed.Widgets.FileManagerElement.prototype.cwd;

/**
 * Refresh the file list (perform a readdir on cwd and update the list items).
 * @param {string|function(): void=} cwd_or_callback
 * @param {function(): void=} callback
 * @return {void}
 */
Blessed.Widgets.FileManagerElement.prototype.refresh = function(cwd_or_callback, callback) {};

/**
 * Pick a single file and return the path in the callback.
 * @param {string|function(): void} cwd_or_callback
 * @param {function(): void=} callback
 * @return {void}
 */
Blessed.Widgets.FileManagerElement.prototype.pick = function(cwd_or_callback, callback) {};

/**
 * Reset back to original cwd.
 * @param {string|function(): void=} cwd_or_callback
 * @param {function(): void=} callback
 * @return {void}
 */
Blessed.Widgets.FileManagerElement.prototype.reset = function(cwd_or_callback, callback) {};

/**
 * Received when an item is selected.
 * Received when an item is selected.
 * @param {string} event
 * @param {!Function|function(string, string): void|function(string): void|function(?, string): void|function(): void} listener_or_callback
 * @return {FileManagerElement}
 */
Blessed.Widgets.FileManagerElement.prototype.on = function(event, listener_or_callback) {};
/**
 * @extends {Blessed.Widgets.ListElementStyle}
 * @record
 * @struct
 */
Blessed.Widgets.StyleListTable = function() {};
 /** @type {?} */
Blessed.Widgets.StyleListTable.prototype.header;
 /** @type {?} */
Blessed.Widgets.StyleListTable.prototype.cell;
/**
 * @extends {Blessed.Widgets.ListOptions}
 * @record
 * @struct
 */
Blessed.Widgets.ListTableOptions = function() {};
 /** @type {!Array<string>} */
Blessed.Widgets.ListTableOptions.prototype.rows;
 /** @type {!Array<!Array<string>>} */
Blessed.Widgets.ListTableOptions.prototype.data;
 /** @type {number} */
Blessed.Widgets.ListTableOptions.prototype.pad;
 /** @type {boolean} */
Blessed.Widgets.ListTableOptions.prototype.noCellBorders;
 /** @type {!Blessed.Widgets.StyleListTable} */
Blessed.Widgets.ListTableOptions.prototype.style;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.ListTableOptions} opts
 */
Blessed.Widgets.ListTableElement = function(opts) {};
 /** @type {!Blessed.Widgets.ListTableOptions} */
Blessed.Widgets.ListTableElement.prototype.options;

/**
 * Set rows in table. Array of arrays of strings.
 * \@example: 
 * 
 * table.setData([
 * [ 'Animals',  'Foods'  ],
 * [ 'Elephant', 'Apple'  ],
 * [ 'Bird',     'Orange' ]
 * ]);
 * @param {!Array<!Array<string>>} rows
 * @return {void}
 */
Blessed.Widgets.ListTableElement.prototype.setRows = function(rows) {};

/**
 * Set rows in table. Array of arrays of strings.
 * \@example: 
 * 
 * table.setData([
 * [ 'Animals',  'Foods'  ],
 * [ 'Elephant', 'Apple'  ],
 * [ 'Bird',     'Orange' ]
 * ]);
 * @param {!Array<!Array<string>>} rows
 * @return {void}
 */
Blessed.Widgets.ListTableElement.prototype.setData = function(rows) {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.ListbarOptions = function() {};
 /** @type {!Blessed.Widgets.ListElementStyle} */
Blessed.Widgets.ListbarOptions.prototype.style;
 /** @type {!Array<{key: string, callback: function(): void}>} */
Blessed.Widgets.ListbarOptions.prototype.commands;
 /** @type {!Array<{key: string, callback: function(): void}>} */
Blessed.Widgets.ListbarOptions.prototype.items;
 /** @type {boolean} */
Blessed.Widgets.ListbarOptions.prototype.autoCommandKeys;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.ListbarOptions} opts
 */
Blessed.Widgets.ListbarElement = function(opts) {};
 /** @type {!Blessed.Widgets.ListbarOptions} */
Blessed.Widgets.ListbarElement.prototype.options;

/**
 * Set commands (see commands option above).
 * @param {!Array<{key: string, callback: function(): void}>} commands
 * @return {void}
 */
Blessed.Widgets.ListbarElement.prototype.setItems = function(commands) {};

/**
 * Append an item to the bar.
 * @param {{key: string, callback: function(): void}} item
 * @param {function(): void} callback
 * @return {void}
 */
Blessed.Widgets.ListbarElement.prototype.add = function(item, callback) {};

/**
 * Append an item to the bar.
 * @param {{key: string, callback: function(): void}} item
 * @param {function(): void} callback
 * @return {void}
 */
Blessed.Widgets.ListbarElement.prototype.addItem = function(item, callback) {};

/**
 * Append an item to the bar.
 * @param {{key: string, callback: function(): void}} item
 * @param {function(): void} callback
 * @return {void}
 */
Blessed.Widgets.ListbarElement.prototype.appendItem = function(item, callback) {};

/**
 * Select an item on the bar.
 * @param {number} offset
 * @return {void}
 */
Blessed.Widgets.ListbarElement.prototype.select = function(offset) {};

/**
 * Remove item from the bar.
 * @param {!Blessed.Widgets.BlessedElement} child
 * @return {void}
 */
Blessed.Widgets.ListbarElement.prototype.removeItem = function(child) {};

/**
 * Move relatively across the bar.
 * @param {number} offset
 * @return {void}
 */
Blessed.Widgets.ListbarElement.prototype.move = function(offset) {};

/**
 * Move left relatively across the bar.
 * @param {number} offset
 * @return {void}
 */
Blessed.Widgets.ListbarElement.prototype.moveLeft = function(offset) {};

/**
 * Move right relatively across the bar.
 * @param {number} offset
 * @return {void}
 */
Blessed.Widgets.ListbarElement.prototype.moveRight = function(offset) {};

/**
 * Select button and execute its callback.
 * @param {number} index
 * @return {void}
 */
Blessed.Widgets.ListbarElement.prototype.selectTab = function(index) {};

/**
 * @param {string} event
 * @param {!Function|function(): void} listener_or_callback
 * @return {ListbarElement}
 */
Blessed.Widgets.ListbarElement.prototype.on = function(event, listener_or_callback) {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.FormOptions = function() {};
 /** @type {?} */
Blessed.Widgets.FormOptions.prototype.keys;
 /** @type {boolean} */
Blessed.Widgets.FormOptions.prototype.vi;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.FormOptions} opts
 */
Blessed.Widgets.FormElement = function(opts) {};
 /** @type {!Blessed.Widgets.FormOptions} */
Blessed.Widgets.FormElement.prototype.options;
 /** @type {TFormData} */
Blessed.Widgets.FormElement.prototype.submission;

/**
 * Focus next form element.
 * @return {void}
 */
Blessed.Widgets.FormElement.prototype.focusNext = function() {};

/**
 * Focus previous form element.
 * @return {void}
 */
Blessed.Widgets.FormElement.prototype.focusPrevious = function() {};

/**
 * Submit the form.
 * @return {void}
 */
Blessed.Widgets.FormElement.prototype.submit = function() {};

/**
 * Discard the form.
 * @return {void}
 */
Blessed.Widgets.FormElement.prototype.cancel = function() {};

/**
 * Clear the form.
 * @return {void}
 */
Blessed.Widgets.FormElement.prototype.reset = function() {};

/**
 * Form is submitted. Receives a data object.
 * Form is discarded.
 * Form is cleared.
 * @param {string} event
 * @param {!Function|function(TFormData): void|function(): void} listener_or_callback
 * @return {FormElement}
 */
Blessed.Widgets.FormElement.prototype.on = function(event, listener_or_callback) {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.InputOptions = function() {};

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.InputOptions} opts
 */
Blessed.Widgets.InputElement = function(opts) {};
/**
 * @extends {Blessed.Widgets.InputOptions}
 * @record
 * @struct
 */
Blessed.Widgets.TextareaOptions = function() {};
 /** @type {boolean} */
Blessed.Widgets.TextareaOptions.prototype.inputOnFocus;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.TextareaOptions} opts
 */
Blessed.Widgets.TextareaElement = function(opts) {};
 /** @type {!Blessed.Widgets.TextareaOptions} */
Blessed.Widgets.TextareaElement.prototype.options;
 /** @type {string} */
Blessed.Widgets.TextareaElement.prototype.value;

/**
 * Submit the textarea (emits submit).
 * @return {void}
 */
Blessed.Widgets.TextareaElement.prototype.submit = function() {};

/**
 * Cancel the textarea (emits cancel).
 * @return {void}
 */
Blessed.Widgets.TextareaElement.prototype.cancel = function() {};

/**
 * Grab key events and start reading text from the keyboard. Takes a callback which receives
 * the final value.
 * @param {function(?, string): void=} callback
 * @return {void}
 */
Blessed.Widgets.TextareaElement.prototype.readInput = function(callback) {};

/**
 * Grab key events and start reading text from the keyboard. Takes a callback which receives
 * the final value.
 * @param {function(?, string): void} callback
 * @return {void}
 */
Blessed.Widgets.TextareaElement.prototype.input = function(callback) {};

/**
 * Grab key events and start reading text from the keyboard. Takes a callback which receives
 * the final value.
 * @param {function(?, string): void} callback
 * @return {void}
 */
Blessed.Widgets.TextareaElement.prototype.setInput = function(callback) {};

/**
 * Open text editor in $EDITOR, read the output from the resulting file. Takes a callback which
 * receives the final value.
 * @param {function(?, string): void} callback
 * @return {void}
 */
Blessed.Widgets.TextareaElement.prototype.readEditor = function(callback) {};

/**
 * Open text editor in $EDITOR, read the output from the resulting file. Takes a callback which
 * receives the final value.
 * @param {function(?, string): void} callback
 * @return {void}
 */
Blessed.Widgets.TextareaElement.prototype.editor = function(callback) {};

/**
 * Open text editor in $EDITOR, read the output from the resulting file. Takes a callback which
 * receives the final value.
 * @param {function(?, string): void} callback
 * @return {void}
 */
Blessed.Widgets.TextareaElement.prototype.setEditor = function(callback) {};

/**
 * The same as this.value, for now.
 * @return {string}
 */
Blessed.Widgets.TextareaElement.prototype.getValue = function() {};

/**
 * Clear input.
 * @return {void}
 */
Blessed.Widgets.TextareaElement.prototype.clearValue = function() {};

/**
 * Set value.
 * @param {string} text
 * @return {void}
 */
Blessed.Widgets.TextareaElement.prototype.setValue = function(text) {};

/**
 * Value is submitted (enter).
 * Value is discared (escape).
 * Either submit or cancel.
 * @param {string} event
 * @param {!Function|function(?): void} listener_or_callback
 * @return {TextareaElement}
 */
Blessed.Widgets.TextareaElement.prototype.on = function(event, listener_or_callback) {};
/**
 * @extends {Blessed.Widgets.TextareaOptions}
 * @record
 * @struct
 */
Blessed.Widgets.TextboxOptions = function() {};
 /** @type {boolean} */
Blessed.Widgets.TextboxOptions.prototype.secret;
 /** @type {boolean} */
Blessed.Widgets.TextboxOptions.prototype.censor;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.TextboxOptions} opts
 */
Blessed.Widgets.TextboxElement = function(opts) {};
 /** @type {!Blessed.Widgets.TextboxOptions} */
Blessed.Widgets.TextboxElement.prototype.options;
 /** @type {boolean} */
Blessed.Widgets.TextboxElement.prototype.secret;
 /** @type {boolean} */
Blessed.Widgets.TextboxElement.prototype.censor;
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.ButtonOptions = function() {};

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.ButtonOptions} opts
 */
Blessed.Widgets.ButtonElement = function(opts) {};
 /** @type {!Blessed.Widgets.ButtonOptions} */
Blessed.Widgets.ButtonElement.prototype.options;

/**
 * Press button. Emits press.
 * @return {void}
 */
Blessed.Widgets.ButtonElement.prototype.press = function() {};

/**
 * @param {string} event
 * @param {!Function|function(): void} listener_or_callback
 * @return {ButtonElement}
 */
Blessed.Widgets.ButtonElement.prototype.on = function(event, listener_or_callback) {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.CheckboxOptions = function() {};
 /** @type {boolean} */
Blessed.Widgets.CheckboxOptions.prototype.checked;
 /** @type {boolean} */
Blessed.Widgets.CheckboxOptions.prototype.mouse;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.CheckboxOptions=} options
 */
Blessed.Widgets.CheckboxElement = function(options) {};
 /** @type {!Blessed.Widgets.CheckboxOptions} */
Blessed.Widgets.CheckboxElement.prototype.options;
 /** @type {string} */
Blessed.Widgets.CheckboxElement.prototype.text;
 /** @type {boolean} */
Blessed.Widgets.CheckboxElement.prototype.checked;
 /** @type {boolean} */
Blessed.Widgets.CheckboxElement.prototype.value;

/**
 * check the element.
 * 
 * @return {void}
 */
Blessed.Widgets.CheckboxElement.prototype.check = function() {};

/**
 * uncheck the element.
 * 
 * @return {void}
 */
Blessed.Widgets.CheckboxElement.prototype.uncheck = function() {};

/**
 * toggle checked state.
 * 
 * @return {void}
 */
Blessed.Widgets.CheckboxElement.prototype.toggle = function() {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.RadioSetOptions = function() {};

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.RadioSetOptions} opts
 */
Blessed.Widgets.RadioSetElement = function(opts) {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.RadioButtonOptions = function() {};

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.RadioButtonOptions} opts
 */
Blessed.Widgets.RadioButtonElement = function(opts) {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.PromptOptions = function() {};

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.PromptOptions} opts
 */
Blessed.Widgets.PromptElement = function(opts) {};
 /** @type {!Blessed.Widgets.PromptOptions} */
Blessed.Widgets.PromptElement.prototype.options;

/**
 * Show the prompt and wait for the result of the textbox. Set text and initial value.
 * @param {string} text
 * @param {string} value
 * @param {function(?, string): void} callback
 * @return {void}
 */
Blessed.Widgets.PromptElement.prototype.input = function(text, value, callback) {};

/**
 * @param {string} text
 * @param {string} value
 * @param {function(?, string): void} callback
 * @return {void}
 */
Blessed.Widgets.PromptElement.prototype.setInput = function(text, value, callback) {};

/**
 * @param {string} text
 * @param {string} value
 * @param {function(?, string): void} callback
 * @return {void}
 */
Blessed.Widgets.PromptElement.prototype.readInput = function(text, value, callback) {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.QuestionOptions = function() {};

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.QuestionOptions} opts
 */
Blessed.Widgets.QuestionElement = function(opts) {};
 /** @type {!Blessed.Widgets.QuestionOptions} */
Blessed.Widgets.QuestionElement.prototype.options;

/**
 * Ask a question. callback will yield the result.
 * @param {string} question
 * @param {function(?, string): void} callback
 * @return {void}
 */
Blessed.Widgets.QuestionElement.prototype.ask = function(question, callback) {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.MessageOptions = function() {};

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.MessageOptions} opts
 */
Blessed.Widgets.MessageElement = function(opts) {};
 /** @type {!Blessed.Widgets.MessageOptions} */
Blessed.Widgets.MessageElement.prototype.options;

/**
 * Display a message for a time (default is 3 seconds). Set time to 0 for a perpetual message that is dismissed on keypress.
 * @param {string} text
 * @param {number|function(?): void} time_or_callback
 * @param {function(?): void=} callback
 * @return {void}
 */
Blessed.Widgets.MessageElement.prototype.log = function(text, time_or_callback, callback) {};

/**
 * @param {string} text
 * @param {number|function(?): void} time_or_callback
 * @param {function(?): void=} callback
 * @return {void}
 */
Blessed.Widgets.MessageElement.prototype.display = function(text, time_or_callback, callback) {};

/**
 * Display an error in the same way.
 * @param {string} text
 * @param {number|function(): void} time_or_callback
 * @param {function(): void=} callback
 * @return {void}
 */
Blessed.Widgets.MessageElement.prototype.error = function(text, time_or_callback, callback) {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.LoadingOptions = function() {};

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.LoadingOptions} opts
 */
Blessed.Widgets.LoadingElement = function(opts) {};
 /** @type {!Blessed.Widgets.LoadingOptions} */
Blessed.Widgets.LoadingElement.prototype.options;

/**
 * Display the loading box with a message. Will lock keys until stop is called.
 * @param {string} text
 * @return {void}
 */
Blessed.Widgets.LoadingElement.prototype.load = function(text) {};

/**
 * Hide loading box. Unlock keys.
 * @return {void}
 */
Blessed.Widgets.LoadingElement.prototype.stop = function() {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.ProgressBarOptions = function() {};
 /** @type {string} */
Blessed.Widgets.ProgressBarOptions.prototype.orientation;
 /** @type {string} */
Blessed.Widgets.ProgressBarOptions.prototype.pch;
 /** @type {number} */
Blessed.Widgets.ProgressBarOptions.prototype.filled;
 /** @type {number} */
Blessed.Widgets.ProgressBarOptions.prototype.value;
 /** @type {boolean} */
Blessed.Widgets.ProgressBarOptions.prototype.keys;
 /** @type {boolean} */
Blessed.Widgets.ProgressBarOptions.prototype.mouse;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.ProgressBarOptions=} options
 */
Blessed.Widgets.ProgressBarElement = function(options) {};
 /** @type {!Blessed.Widgets.ProgressBarOptions} */
Blessed.Widgets.ProgressBarElement.prototype.options;

/**
 * progress the bar by a fill amount.
 * 
 * @param {number} amount
 * @return {void}
 */
Blessed.Widgets.ProgressBarElement.prototype.progress = function(amount) {};

/**
 * set progress to specific amount.
 * 
 * @param {number} amount
 * @return {void}
 */
Blessed.Widgets.ProgressBarElement.prototype.setProgress = function(amount) {};

/**
 * reset the bar.
 * 
 * @return {void}
 */
Blessed.Widgets.ProgressBarElement.prototype.reset = function() {};

/**
 * Bar was reset.
 * Bar has completely filled.
 * @param {string} event
 * @param {!Function|function(): void} listener_or_callback
 * @return {ProgressBarElement}
 */
Blessed.Widgets.ProgressBarElement.prototype.on = function(event, listener_or_callback) {};
/**
 * @extends {Blessed.Widgets.ScrollableTextOptions}
 * @record
 * @struct
 */
Blessed.Widgets.LogOptions = function() {};
 /** @type {number} */
Blessed.Widgets.LogOptions.prototype.scrollback;
 /** @type {boolean} */
Blessed.Widgets.LogOptions.prototype.scrollOnInput;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.LogOptions=} options
 */
Blessed.Widgets.Log = function(options) {};
 /** @type {!Blessed.Widgets.LogOptions} */
Blessed.Widgets.Log.prototype.options;
 /** @type {number} */
Blessed.Widgets.Log.prototype.scrollback;
 /** @type {boolean} */
Blessed.Widgets.Log.prototype.scrollOnInput;

/**
 * add a log line.
 * 
 * @param {string} text
 * @return {void}
 */
Blessed.Widgets.Log.prototype.log = function(text) {};

/**
 * add a log line.
 * 
 * @param {string} text
 * @return {void}
 */
Blessed.Widgets.Log.prototype.add = function(text) {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.TableOptions = function() {};
 /** @type {!Array<!Array<string>>} */
Blessed.Widgets.TableOptions.prototype.rows;
 /** @type {!Array<!Array<string>>} */
Blessed.Widgets.TableOptions.prototype.data;
 /** @type {number} */
Blessed.Widgets.TableOptions.prototype.pad;
 /** @type {boolean} */
Blessed.Widgets.TableOptions.prototype.noCellBorders;
 /** @type {boolean} */
Blessed.Widgets.TableOptions.prototype.fillCellBorders;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.TableOptions} opts
 */
Blessed.Widgets.TableElement = function(opts) {};
 /** @type {!Blessed.Widgets.TableOptions} */
Blessed.Widgets.TableElement.prototype.options;

/**
 * set rows in table. array of arrays of strings.
 * 
 * @param {!Array<!Array<string>>} rows
 * @return {void}
 */
Blessed.Widgets.TableElement.prototype.setData = function(rows) {};

/**
 * set rows in table. array of arrays of strings.
 * 
 * @param {!Array<!Array<string>>} rows
 * @return {void}
 */
Blessed.Widgets.TableElement.prototype.setRows = function(rows) {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.TerminalOptions = function() {};
 /** @type {function(?): void} */
Blessed.Widgets.TerminalOptions.prototype.handler;
 /** @type {string} */
Blessed.Widgets.TerminalOptions.prototype.shell;
 /** @type {?} */
Blessed.Widgets.TerminalOptions.prototype.args;
 /** @type {string} */
Blessed.Widgets.TerminalOptions.prototype.cursor;
 /** @type {string} */
Blessed.Widgets.TerminalOptions.prototype.terminal;
 /** @type {?} */
Blessed.Widgets.TerminalOptions.prototype.env;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.TerminalOptions} opts
 */
Blessed.Widgets.TerminalElement = function(opts) {};
 /** @type {!Blessed.Widgets.TerminalOptions} */
Blessed.Widgets.TerminalElement.prototype.options;
 /** @type {?} */
Blessed.Widgets.TerminalElement.prototype.term;
 /** @type {?} */
Blessed.Widgets.TerminalElement.prototype.pty;

/**
 * write data to the terminal.
 * 
 * @param {string} data
 * @return {void}
 */
Blessed.Widgets.TerminalElement.prototype.write = function(data) {};

/**
 * nearly identical to `element.screenshot`, however, the specified region includes the terminal's _entire_ scrollback, rather than just what is visible on the screen.
 * 
 * @param {number=} xi
 * @param {number=} xl
 * @param {number=} yi
 * @param {number=} yl
 * @return {string}
 */
Blessed.Widgets.TerminalElement.prototype.screenshot = function(xi, xl, yi, yl) {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.ImageOptions = function() {};
 /** @type {string} */
Blessed.Widgets.ImageOptions.prototype.file;
 /** @type {string} */
Blessed.Widgets.ImageOptions.prototype.type;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.ImageOptions=} options
 */
Blessed.Widgets.ImageElement = function(options) {};
 /** @type {!Blessed.Widgets.ImageOptions} */
Blessed.Widgets.ImageElement.prototype.options;
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.ANSIImageOptions = function() {};
 /** @type {string} */
Blessed.Widgets.ANSIImageOptions.prototype.file;
 /** @type {number} */
Blessed.Widgets.ANSIImageOptions.prototype.scale;
 /** @type {(string|number)} */
Blessed.Widgets.ANSIImageOptions.prototype.width;
 /** @type {(string|number)} */
Blessed.Widgets.ANSIImageOptions.prototype.height;
 /** @type {string} */
Blessed.Widgets.ANSIImageOptions.prototype.ascii;
 /** @type {boolean} */
Blessed.Widgets.ANSIImageOptions.prototype.animate;
 /** @type {number} */
Blessed.Widgets.ANSIImageOptions.prototype.speed;
 /** @type {string} */
Blessed.Widgets.ANSIImageOptions.prototype.optimization;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.ANSIImageOptions=} options
 */
Blessed.Widgets.ANSIImageElement = function(options) {};
 /** @type {!Blessed.Widgets.ANSIImageOptions} */
Blessed.Widgets.ANSIImageElement.prototype.options;
 /** @type {{width: number, height: number, bmp: ?, cellmap: ?}} */
Blessed.Widgets.ANSIImageElement.prototype.img;

/**
 * set the image in the box to a new path.
 * 
 * @param {string} img
 * @param {function(): void} callback
 * @return {void}
 */
Blessed.Widgets.ANSIImageElement.prototype.setImage = function(img, callback) {};

/**
 * clear the current image.
 * 
 * @param {function(): void} callback
 * @return {void}
 */
Blessed.Widgets.ANSIImageElement.prototype.clearImage = function(callback) {};

/**
 * Play animation if it has been paused or stopped.
 * @return {void}
 */
Blessed.Widgets.ANSIImageElement.prototype.play = function() {};

/**
 * Pause animation.
 * @return {void}
 */
Blessed.Widgets.ANSIImageElement.prototype.pause = function() {};

/**
 * Stop animation.
 * @return {void}
 */
Blessed.Widgets.ANSIImageElement.prototype.stop = function() {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.OverlayImageOptions = function() {};
 /** @type {string} */
Blessed.Widgets.OverlayImageOptions.prototype.file;
 /** @type {boolean} */
Blessed.Widgets.OverlayImageOptions.prototype.ansi;
 /** @type {string} */
Blessed.Widgets.OverlayImageOptions.prototype.w3m;
 /** @type {string} */
Blessed.Widgets.OverlayImageOptions.prototype.search;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.OverlayImageOptions=} options
 */
Blessed.Widgets.OverlayImageElement = function(options) {};
 /** @type {!Blessed.Widgets.OverlayImageOptions} */
Blessed.Widgets.OverlayImageElement.prototype.options;

/**
 * set the image in the box to a new path.
 * 
 * @param {string} img
 * @param {function(): void} callback
 * @return {void}
 */
Blessed.Widgets.OverlayImageElement.prototype.setImage = function(img, callback) {};

/**
 * clear the current image.
 * 
 * @param {function(): void} callback
 * @return {void}
 */
Blessed.Widgets.OverlayImageElement.prototype.clearImage = function(callback) {};

/**
 * get the size of an image file in pixels.
 * 
 * @param {string} img
 * @param {function(): void} callback
 * @return {void}
 */
Blessed.Widgets.OverlayImageElement.prototype.imageSize = function(img, callback) {};

/**
 * get the size of the terminal in pixels.
 * 
 * @param {function(): void} callback
 * @return {void}
 */
Blessed.Widgets.OverlayImageElement.prototype.termSize = function(callback) {};

/**
 * get the pixel to cell ratio for the terminal.
 * 
 * @param {function(): void} callback
 * @return {void}
 */
Blessed.Widgets.OverlayImageElement.prototype.getPixelRatio = function(callback) {};
/**
 * @extends {Blessed.Widgets.BoxOptions}
 * @record
 * @struct
 */
Blessed.Widgets.VideoOptions = function() {};
 /** @type {string} */
Blessed.Widgets.VideoOptions.prototype.file;
 /** @type {number} */
Blessed.Widgets.VideoOptions.prototype.start;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.VideoOptions=} options
 */
Blessed.Widgets.VideoElement = function(options) {};
 /** @type {!Blessed.Widgets.VideoOptions} */
Blessed.Widgets.VideoElement.prototype.options;
 /** @type {?} */
Blessed.Widgets.VideoElement.prototype.tty;
/**
 * @extends {Blessed.Widgets.ElementOptions}
 * @record
 * @struct
 */
Blessed.Widgets.LayoutOptions = function() {};
 /** @type {function(): void} */
Blessed.Widgets.LayoutOptions.prototype.renderer;
 /** @type {string} */
Blessed.Widgets.LayoutOptions.prototype.layout;

/**
 * @constructor
 * @struct
 * @param {!Blessed.Widgets.LayoutOptions=} options
 */
Blessed.Widgets.LayoutElement = function(options) {};
 /** @type {!Blessed.Widgets.LayoutOptions} */
Blessed.Widgets.LayoutElement.prototype.options;

/**
 * A callback which is called right before the children are iterated over to be rendered. Should return an
 * iterator callback which is called on each child element: iterator(el, i).
 * @param {!Blessed.Widgets.PositionCoords} coords
 * @return {void}
 */
Blessed.Widgets.LayoutElement.prototype.renderer = function(coords) {};

/**
 * Check to see if a previous child element has been rendered and is visible on screen. This is only useful
 * for checking child elements that have already been attempted to be rendered! see the example below.
 * @param {!Blessed.Widgets.BlessedElement} el
 * @return {boolean}
 */
Blessed.Widgets.LayoutElement.prototype.isRendered = function(el) {};

/**
 * Get the last rendered and visible child element based on an index. This is useful for basing the position
 * of the current child element on the position of the last child element.
 * @param {number} i
 * @return {!Element}
 */
Blessed.Widgets.LayoutElement.prototype.getLast = function(i) {};

/**
 * Get the last rendered and visible child element coords based on an index. This is useful for basing the position
 * of the current child element on the position of the last child element. See the example below.
 * @param {number} i
 * @return {!Blessed.Widgets.PositionCoords}
 */
Blessed.Widgets.LayoutElement.prototype.getLastCoords = function(i) {};
/**
 * @constructor
 * @struct
 */
Blessed.Widgets.Program = function() {};

/**
 * Wrap the given text in terminal formatting codes corresponding to the given attribute
 * name. The `attr` string can be of the form `red fg` or `52 bg` where `52` is a 0-255
 * integer color number.
 * @param {string} text
 * @param {string} attr
 * @return {string}
 */
Blessed.Widgets.Program.prototype.text = function(text, attr) {};
/** @const */
Blessed.widget = {};
/**
 * @extends {Blessed.Widgets.BlessedElement}
 * @constructor
 * @struct
 */
Blessed.widget.Element = function() {};
/**
 * @extends {Blessed.Widgets.Node}
 * @constructor
 * @struct
 */
Blessed.widget.Node = function() {};
/**
 * @extends {Blessed.Widgets.Screen}
 * @constructor
 * @struct
 */
Blessed.widget.Screen = function() {};
/**
 * @extends {Blessed.Widgets.BoxElement}
 * @constructor
 * @struct
 */
Blessed.widget.Box = function() {};
/**
 * @extends {Blessed.Widgets.ScrollableBoxElement}
 * @constructor
 * @struct
 */
Blessed.widget.ScrollableBox = function() {};
/**
 * @extends {Blessed.Widgets.ScrollableTextElement}
 * @constructor
 * @struct
 */
Blessed.widget.ScrollableText = function() {};
/**
 * @extends {Blessed.Widgets.BoxElement}
 * @constructor
 * @struct
 */
Blessed.widget.Text = function() {};
/**
 * @extends {Blessed.Widgets.LineElement}
 * @constructor
 * @struct
 */
Blessed.widget.Line = function() {};
/**
 * @extends {Blessed.Widgets.BigTextElement}
 * @constructor
 * @struct
 */
Blessed.widget.BigText = function() {};
/**
 * @extends {Blessed.Widgets.ListElement}
 * @constructor
 * @struct
 */
Blessed.widget.List = function() {};
/**
 * @extends {Blessed.Widgets.FileManagerElement}
 * @constructor
 * @struct
 */
Blessed.widget.FileManager = function() {};
/**
 * @extends {Blessed.Widgets.ListTableElement}
 * @constructor
 * @struct
 */
Blessed.widget.ListTable = function() {};
/**
 * @extends {Blessed.Widgets.ListbarElement}
 * @constructor
 * @struct
 */
Blessed.widget.ListBar = function() {};
/**
 * @extends {Blessed.Widgets.FormElement}
 * @constructor
 * @struct
 */
Blessed.widget.Form = function() {};
/**
 * @extends {Blessed.Widgets.TextareaElement}
 * @constructor
 * @struct
 */
Blessed.widget.Textarea = function() {};
/**
 * @extends {Blessed.Widgets.ButtonElement}
 * @constructor
 * @struct
 */
Blessed.widget.Button = function() {};
/**
 * @extends {Blessed.Widgets.CheckboxElement}
 * @constructor
 * @struct
 */
Blessed.widget.Checkbox = function() {};
/**
 * @extends {Blessed.Widgets.RadioSetElement}
 * @constructor
 * @struct
 */
Blessed.widget.RadioSet = function() {};
/**
 * @extends {Blessed.Widgets.RadioButtonElement}
 * @constructor
 * @struct
 */
Blessed.widget.RadioButton = function() {};
/**
 * @extends {Blessed.Widgets.PromptElement}
 * @constructor
 * @struct
 */
Blessed.widget.Prompt = function() {};
/**
 * @extends {Blessed.Widgets.QuestionElement}
 * @constructor
 * @struct
 */
Blessed.widget.question = function() {};
/**
 * @extends {Blessed.Widgets.MessageElement}
 * @constructor
 * @struct
 */
Blessed.widget.Message = function() {};
/**
 * @extends {Blessed.Widgets.LoadingElement}
 * @constructor
 * @struct
 */
Blessed.widget.Loading = function() {};
/**
 * @extends {Blessed.Widgets.ProgressBarElement}
 * @constructor
 * @struct
 */
Blessed.widget.ProgressBar = function() {};
/**
 * @extends {Blessed.Widgets.TerminalElement}
 * @constructor
 * @struct
 */
Blessed.widget.Terminal = function() {};

/**
 * @param {!Blessed.Widgets.IScreenOptions=} options
 * @return {!Blessed.Widgets.Screen}
 */
Blessed.screen = function(options) {};

/**
 * @param {!Blessed.Widgets.BoxOptions=} options
 * @return {!Blessed.Widgets.BoxElement}
 */
Blessed.box = function(options) {};

/**
 * @param {!Blessed.Widgets.TextOptions=} options
 * @return {!Blessed.Widgets.TextElement}
 */
Blessed.text = function(options) {};

/**
 * @param {!Blessed.Widgets.LineOptions=} options
 * @return {!Blessed.Widgets.LineElement}
 */
Blessed.line = function(options) {};

/**
 * @param {!Blessed.Widgets.BoxOptions=} options
 * @return {!Blessed.Widgets.BoxElement}
 */
Blessed.scrollablebox = function(options) {};

/**
 * @param {!Blessed.Widgets.BoxOptions=} options
 * @return {!Blessed.Widgets.BoxElement}
 */
Blessed.scrollabletext = function(options) {};

/**
 * @param {!Blessed.Widgets.BigTextOptions=} options
 * @return {!Blessed.Widgets.BigTextElement}
 */
Blessed.bigtext = function(options) {};

/**
 * @param {!Blessed.Widgets.ListOptions<!Blessed.Widgets.ListElementStyle>=} options
 * @return {!Blessed.Widgets.ListElement}
 */
Blessed.list = function(options) {};

/**
 * @param {!Blessed.Widgets.FileManagerOptions=} options
 * @return {!Blessed.Widgets.FileManagerElement}
 */
Blessed.filemanager = function(options) {};

/**
 * @param {!Blessed.Widgets.ListTableOptions=} options
 * @return {!Blessed.Widgets.ListTableElement}
 */
Blessed.listtable = function(options) {};

/**
 * @param {!Blessed.Widgets.ListbarOptions=} options
 * @return {!Blessed.Widgets.ListbarElement}
 */
Blessed.listbar = function(options) {};

/**
 * @template TFormData
 * @param {!Blessed.Widgets.FormOptions=} options
 * @return {!Blessed.Widgets.FormElement<TFormData>}
 */
Blessed.form = function(options) {};

/**
 * @param {!Blessed.Widgets.InputOptions=} options
 * @return {!Blessed.Widgets.InputElement}
 */
Blessed.input = function(options) {};

/**
 * @param {!Blessed.Widgets.TextareaOptions=} options
 * @return {!Blessed.Widgets.TextareaElement}
 */
Blessed.textarea = function(options) {};

/**
 * @param {!Blessed.Widgets.TextboxOptions=} options
 * @return {!Blessed.Widgets.TextboxElement}
 */
Blessed.textbox = function(options) {};

/**
 * @param {!Blessed.Widgets.ButtonOptions=} options
 * @return {!Blessed.Widgets.ButtonElement}
 */
Blessed.button = function(options) {};

/**
 * @param {!Blessed.Widgets.CheckboxOptions=} options
 * @return {!Blessed.Widgets.CheckboxElement}
 */
Blessed.checkbox = function(options) {};

/**
 * @param {!Blessed.Widgets.RadioSetOptions=} options
 * @return {!Blessed.Widgets.RadioSetElement}
 */
Blessed.radioset = function(options) {};

/**
 * @param {!Blessed.Widgets.RadioButtonOptions=} options
 * @return {!Blessed.Widgets.RadioButtonElement}
 */
Blessed.radiobutton = function(options) {};

/**
 * @param {!Blessed.Widgets.TableOptions=} options
 * @return {!Blessed.Widgets.TableElement}
 */
Blessed.table = function(options) {};

/**
 * @param {!Blessed.Widgets.PromptOptions=} options
 * @return {!Blessed.Widgets.PromptElement}
 */
Blessed.prompt = function(options) {};

/**
 * @param {!Blessed.Widgets.QuestionOptions=} options
 * @return {!Blessed.Widgets.QuestionElement}
 */
Blessed.question = function(options) {};

/**
 * @param {!Blessed.Widgets.MessageOptions=} options
 * @return {!Blessed.Widgets.MessageElement}
 */
Blessed.message = function(options) {};

/**
 * @param {!Blessed.Widgets.LoadingOptions=} options
 * @return {!Blessed.Widgets.LoadingElement}
 */
Blessed.loading = function(options) {};

/**
 * @param {!Blessed.Widgets.ProgressBarOptions=} options
 * @return {!Blessed.Widgets.ProgressBarElement}
 */
Blessed.progressbar = function(options) {};

/**
 * @param {!Blessed.Widgets.TerminalOptions=} options
 * @return {!Blessed.Widgets.TerminalElement}
 */
Blessed.terminal = function(options) {};

/**
 * @param {!Blessed.Widgets.LayoutOptions=} options
 * @return {!Blessed.Widgets.LayoutElement}
 */
Blessed.layout = function(options) {};

/**
 * @param {?} item
 * @return {?}
 */
Blessed.escape = function(item) {};
 /** @type {{match: function(string): string}} */
Blessed.colors;

/* TODO: ExportAssignment in  */
