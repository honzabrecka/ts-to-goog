/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/simple-mock/index.d.ts:
/** @const */
var Simple = {};

/** @typedef {function(!Array<?>): T} */
Simple.Fn;
/**
 * @record
 * @struct
 */
Simple.Static = function() {};
 /** @type {function(new: (!PromiseLike<T>), function(function((T|!PromiseLike<T>)): void, function(?): void): void): ?} */
Simple.Static.prototype.Promise;

/**
 * Restores all current mocks.
 * @return {void}
 */
Simple.Static.prototype.restore = function() {};

/**
 * Wraps fn in a spy and sets this on the obj, restorable with all mocks.
 * Sets the value on this object. E.g. mock(config, 'title', 'test') is the same as config.title = 'test', but restorable with all mocks.
 * If obj has already has this function, it is wrapped in a spy. The resulting spy can be turned into a stub by further configuration. Restores with all mocks.
 * Wraps fn in a spy.
 * Returns a stub function that is also a spy.
 * @template T
 * @param {?|function(!Array<?>): T=} obj_or_fn
 * @param {string=} key
 * @param {function(!Array<?>): T|T=} fn_or_mockValue
 * @return {!Simple.Stub<T>|T|!Simple.Stub<?>|!Simple.Spy<T>}
 */
Simple.Static.prototype.mock = function(obj_or_fn, key, fn_or_mockValue) {};

/**
 * Wraps fn in a spy.
 * @template T
 * @param {function(!Array<?>): T} fn
 * @return {!Simple.Spy<T>}
 */
Simple.Static.prototype.spy = function(fn) {};

/**
 * Returns a stub function that is also a spy.
 * @template T
 * @return {!Simple.Stub<?>|!Simple.Stub<T>}
 */
Simple.Static.prototype.stub = function() {};
/**
 * @record
 * @struct
 */
Simple.Calls = function() {};
 /** @type {!Array<?>} */
Simple.Calls.prototype.args;
 /** @type {?} */
Simple.Calls.prototype.arg;
 /** @type {?} */
Simple.Calls.prototype.context;
 /** @type {T} */
Simple.Calls.prototype.returned;
 /** @type {!Error} */
Simple.Calls.prototype.threw;
 /** @type {number} */
Simple.Calls.prototype.k;
/**
 * @record
 * @struct
 */
Simple.Spy = function() {};

/* TODO: CallSignature: Simple */
 /** @type {boolean} */
Simple.Spy.prototype.called;
 /** @type {number} */
Simple.Spy.prototype.callCount;
 /** @type {!Array<!Simple.Calls<T>>} */
Simple.Spy.prototype.calls;
 /** @type {!Simple.Calls<T>} */
Simple.Spy.prototype.firstCall;
 /** @type {!Simple.Calls<T>} */
Simple.Spy.prototype.lastCall;

/**
 * Resets all counts and properties to the original state.
 * @return {void}
 */
Simple.Spy.prototype.reset = function() {};
/**
 * @record
 * @struct
 */
Simple.Action = function() {};
 /** @type {!ArrayLike<?>} */
Simple.Action.prototype.cbArgs;
 /** @type {T} */
Simple.Action.prototype.returnValue;
 /** @type {!Error} */
Simple.Action.prototype.throwError;
/**
 * @extends {Simple.Spy}
 * @record
 * @struct
 */
Simple.Stub = function() {};
 /** @type {!Array<!Simple.Action<T>>} */
Simple.Stub.prototype.actions;
 /** @type {boolean} */
Simple.Stub.prototype.loop;

/**
 * Configures this stub to call this function, returning its return value.
 * Subsequent calls of this on the same stub (chainable) will queue up different behaviours for each subsequent call of the stub.
 * @template R
 * @param {function(!Array<?>): R} fn
 * @return {!Simple.Stub<R>}
 */
Simple.Stub.prototype.callFn = function(fn) {};

/**
 * Configures this stub to call the original, unstubbed function, returning its return value.
 * Subsequent calls of this on the same stub (chainable) will queue up different behaviours for each subsequent call of the stub.
 * @return {!Simple.Stub}
 */
Simple.Stub.prototype.callOriginal = function() {};

/**
 * Configures this stub to return with this value.
 * Subsequent calls of this on the same stub (chainable) will queue up different behaviours for each subsequent call of the stub.
 * @template R
 * @param {R} val
 * @return {!Simple.Stub<R>}
 */
Simple.Stub.prototype.returnWith = function(val) {};

/**
 * Configures this stub to throw this error.
 * Subsequent calls of this on the same stub (chainable) will queue up different behaviours for each subsequent call of the stub.
 * @param {!Error} err
 * @return {!Simple.Stub}
 */
Simple.Stub.prototype.throwWith = function(err) {};

/**
 * Configures this stub to call back with the arguments passed. It will use either the last argument as callback, or the argument at cbArgumentIndex.
 * Subsequent calls of this on the same stub (chainable) will queue up different behaviours for each subsequent call of the stub.
 * @param {...?} args
 * @return {!Simple.Stub}
 */
Simple.Stub.prototype.callback = function(args) {};

/**
 * Configures this stub to call back with the arguments passed. It will use either the last argument as callback, or the argument at cbArgumentIndex.
 * Subsequent calls of this on the same stub (chainable) will queue up different behaviours for each subsequent call of the stub.
 * @param {...?} args
 * @return {!Simple.Stub}
 */
Simple.Stub.prototype.callbackWith = function(args) {};

/**
 * Configures this stub to call back with the arguments passed. It will use either the last argument as callback, or the argument at cbArgumentIndex.
 * Subsequent calls of this on the same stub (chainable) will queue up different behaviours for each subsequent call of the stub.
 * @param {number} cbArgumentIndex
 * @param {...?} args
 * @return {!Simple.Stub}
 */
Simple.Stub.prototype.callbackAtIndex = function(cbArgumentIndex, args) {};

/**
 * Configures this stub to call back with the arguments passed. It will use either the last argument as callback, or the argument at cbArgumentIndex.
 * Subsequent calls of this on the same stub (chainable) will queue up different behaviours for each subsequent call of the stub.
 * @param {number} cbArgumentIndex
 * @param {...?} args
 * @return {!Simple.Stub}
 */
Simple.Stub.prototype.callbackArgWith = function(cbArgumentIndex, args) {};

/**
 * Configures the last configured function or callback to be called in this context, i.e. this will be obj.
 * @param {?} obj
 * @return {!Simple.Stub}
 */
Simple.Stub.prototype.inThisContext = function(obj) {};

/**
 * Configures the stub to return a Promise (where available] resolving to this value. Same as stub.returnWith(Promise.resolve(val)).
 * You can use a custom Promise-conforming library, i.e. simple.Promise = require('bluebird') or simple.Promise = $q.
 * @template V
 * @param {V} val
 * @return {!Simple.Stub<!PromiseLike<V>>}
 */
Simple.Stub.prototype.resolveWith = function(val) {};

/**
 * Configures the stub to return a Promise (where available) rejecting with this error. Same as stub.returnWith(Promise.reject(val)).
 * You can use a custom Promise-conforming library, i.e. simple.Promise = require('bluebird') or simple.Promise = $q.
 * @template V
 * @param {V} val
 * @return {!Simple.Stub<!PromiseLike<V>>}
 */
Simple.Stub.prototype.rejectWith = function(val) {};
 /** @type {!Simple.Static} */
var Simple;

/* TODO: ExportAssignment in  */
