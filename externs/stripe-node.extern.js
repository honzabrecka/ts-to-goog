/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/stripe-node/index.d.ts:
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "stripe"
/** @const */
tsickle_declare_module.stripe = {};
 /** @type {!StripeNode.StripeExport} */
tsickle_declare_module.stripe.out;

/* TODO: ExportAssignment in tsickle_declare_module.stripe */
/** @const */
var StripeNode = {};
/**
 * @extends {StripeNode.StripeStatic}
 * @record
 * @struct
 */
StripeNode.StripeExport = function() {};

/* TODO: ConstructSignature: StripeNode */

/* TODO: CallSignature: StripeNode */
/**
 * @record
 * @struct
 */
StripeNode.StripeStatic = function() {};
 /** @type {string} */
StripeNode.StripeStatic.prototype.DEFAULT_HOST;
 /** @type {string} */
StripeNode.StripeStatic.prototype.DEFAULT_PORT;
 /** @type {string} */
StripeNode.StripeStatic.prototype.DEFAULT_BASE_PATH;
 /** @type {string} */
StripeNode.StripeStatic.prototype.DEFAULT_API_VERSION;
 /** @type {number} */
StripeNode.StripeStatic.prototype.DEFAULT_TIMEOUT;
 /** @type {string} */
StripeNode.StripeStatic.prototype.PACKAGE_VERSION;
 /** @type {{bindings_version: string, lang: string, lang_version: string, platform: string, publisher: string, uname: string}} */
StripeNode.StripeStatic.prototype.USER_AGENT;
 /** @type {string} */
StripeNode.StripeStatic.prototype.USER_AGENT_SERIALIZED;
 /** @type {?} */
StripeNode.StripeStatic.prototype.resources;
 /** @type {?} */
StripeNode.StripeStatic.prototype.StripeResource;

/** @typedef {!StripeNode.bankAccounts.IBankAccount} */
StripeNode.IBankAccount;

/** @typedef {!StripeNode.cards.ICard} */
StripeNode.ICard;
/**
 * @extends {StripeNode.StripeStatic}
 * @record
 * @struct
 */
StripeNode.Stripe = function() {};
 /** @type {!StripeNode.resources.Accounts} */
StripeNode.Stripe.prototype.accounts;
 /** @type {!StripeNode.resources.Balance} */
StripeNode.Stripe.prototype.balance;
 /** @type {!StripeNode.resources.Charges} */
StripeNode.Stripe.prototype.charges;
 /** @type {!StripeNode.resources.Coupons} */
StripeNode.Stripe.prototype.coupons;
 /** @type {!StripeNode.resources.Customers} */
StripeNode.Stripe.prototype.customers;
 /** @type {!StripeNode.resources.Disputes} */
StripeNode.Stripe.prototype.disputes;
 /** @type {!StripeNode.resources.Events} */
StripeNode.Stripe.prototype.events;
 /** @type {!StripeNode.resources.Invoices} */
StripeNode.Stripe.prototype.invoices;
 /** @type {!StripeNode.resources.InvoiceItems} */
StripeNode.Stripe.prototype.invoiceItems;
 /** @type {!StripeNode.resources.Plans} */
StripeNode.Stripe.prototype.plans;
 /** @type {!StripeNode.resources.RecipientCards} */
StripeNode.Stripe.prototype.recipientCards;
 /** @type {!StripeNode.resources.Recipients} */
StripeNode.Stripe.prototype.recipients;
 /** @type {!StripeNode.resources.Subscriptions} */
StripeNode.Stripe.prototype.subscriptions;
 /** @type {!StripeNode.resources.Tokens} */
StripeNode.Stripe.prototype.tokens;
 /** @type {!StripeNode.resources.Transfers} */
StripeNode.Stripe.prototype.transfers;
 /** @type {!StripeNode.resources.ApplicationFees} */
StripeNode.Stripe.prototype.applicationFees;
 /** @type {!StripeNode.resources.FileUploads} */
StripeNode.Stripe.prototype.fileUploads;
 /** @type {!StripeNode.resources.BitcoinReceivers} */
StripeNode.Stripe.prototype.bitcoinReceivers;
 /** @type {!StripeNode.resources.Refunds} */
StripeNode.Stripe.prototype.refunds;
 /** @type {!StripeNode.resources.CountrySpecs} */
StripeNode.Stripe.prototype.countrySpecs;
 /** @type {!StripeNode.resources.Orders} */
StripeNode.Stripe.prototype.orders;
 /** @type {!StripeNode.resources.Products} */
StripeNode.Stripe.prototype.products;
 /** @type {!StripeNode.resources.SKUs} */
StripeNode.Stripe.prototype.skus;

/**
 * @param {string} host
 * @param {(string|number)=} port
 * @param {string=} protocol
 * @return {void}
 */
StripeNode.Stripe.prototype.setHost = function(host, port, protocol) {};

/**
 * @param {string} protocol
 * @return {void}
 */
StripeNode.Stripe.prototype.setProtocol = function(protocol) {};

/**
 * @param {(string|number)} port
 * @return {void}
 */
StripeNode.Stripe.prototype.setPort = function(port) {};

/**
 * @param {string=} version
 * @return {void}
 */
StripeNode.Stripe.prototype.setApiVersion = function(version) {};

/**
 * @param {string=} key
 * @return {void}
 */
StripeNode.Stripe.prototype.setApiKey = function(key) {};

/**
 * @param {number=} timeout
 * @return {void}
 */
StripeNode.Stripe.prototype.setTimeout = function(timeout) {};

/**
 * @param {string} agent
 * @return {void}
 */
StripeNode.Stripe.prototype.setHttpAgent = function(agent) {};

/**
 * @param {string} c
 * @return {?}
 */
StripeNode.Stripe.prototype.getConstant = function(c) {};

/**
 * @param {function(string): void} response
 * @return {void}
 */
StripeNode.Stripe.prototype.getClientUserAgent = function(response) {};
/** @const */
StripeNode.accounts = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @extends {StripeNode.accounts.IAccountShared}
 * @record
 * @struct
 */
StripeNode.accounts.IAccount = function() {};
 /** @type {string} */
StripeNode.accounts.IAccount.prototype.object;
 /** @type {boolean} */
StripeNode.accounts.IAccount.prototype.charges_enabled;
 /** @type {string} */
StripeNode.accounts.IAccount.prototype.country;
 /** @type {boolean} */
StripeNode.accounts.IAccount.prototype.details_submitted;
 /** @type {string} */
StripeNode.accounts.IAccount.prototype.display_name;
 /** @type {boolean} */
StripeNode.accounts.IAccount.prototype.transfers_enabled;
 /** @type {{disabled_reason: string, due_by: number, fields_needed: !Array<string>}} */
StripeNode.accounts.IAccount.prototype.verification;
/**
 * @extends {StripeNode.accounts.IAccountUpdateOptions}
 * @record
 * @struct
 */
StripeNode.accounts.IAccountCreationOptions = function() {};
 /** @type {string} */
StripeNode.accounts.IAccountCreationOptions.prototype.country;
 /** @type {string} */
StripeNode.accounts.IAccountCreationOptions.prototype.email;
 /** @type {boolean} */
StripeNode.accounts.IAccountCreationOptions.prototype.managed;
/**
 * @record
 * @struct
 */
StripeNode.accounts.IAccountShared = function() {};
 /** @type {string} */
StripeNode.accounts.IAccountShared.prototype.business_logo;
 /** @type {string} */
StripeNode.accounts.IAccountShared.prototype.business_name;
 /** @type {string} */
StripeNode.accounts.IAccountShared.prototype.business_primary_color;
 /** @type {string} */
StripeNode.accounts.IAccountShared.prototype.business_url;
 /** @type {boolean} */
StripeNode.accounts.IAccountShared.prototype.debit_negative_balances;
 /** @type {{avs_failure: boolean, cvc_failure: boolean}} */
StripeNode.accounts.IAccountShared.prototype.decline_charge_on;
 /** @type {string} */
StripeNode.accounts.IAccountShared.prototype.default_currency;
 /** @type {string} */
StripeNode.accounts.IAccountShared.prototype.email;
 /** @type {!Object} */
StripeNode.accounts.IAccountShared.prototype.legal_entity;
 /** @type {!StripeNode.IMetadata} */
StripeNode.accounts.IAccountShared.prototype.metadata;
 /** @type {string} */
StripeNode.accounts.IAccountShared.prototype.product_description;
 /** @type {string} */
StripeNode.accounts.IAccountShared.prototype.statement_descriptor;
 /** @type {string} */
StripeNode.accounts.IAccountShared.prototype.support_email;
 /** @type {string} */
StripeNode.accounts.IAccountShared.prototype.support_phone;
 /** @type {string} */
StripeNode.accounts.IAccountShared.prototype.support_url;
 /** @type {{date: number, ip: string, user_agent: string}} */
StripeNode.accounts.IAccountShared.prototype.tos_acceptance;
 /** @type {{delay_days: (string|number), interval: string, monthly_anchor: number, weekly_anchor: string}} */
StripeNode.accounts.IAccountShared.prototype.transfer_schedule;
/**
 * @extends {StripeNode.IDataOptions}
 * @extends {StripeNode.accounts.IAccountShared}
 * @record
 * @struct
 */
StripeNode.accounts.IAccountUpdateOptions = function() {};
 /** @type {{object: string, account_number: string, country: string, currency: string, account_holder_name: string, account_holder_type: string, routing_number: string}} */
StripeNode.accounts.IAccountUpdateOptions.prototype.external_account;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.accounts.IExternalAccountCreationOptions = function() {};
 /** @type {string} */
StripeNode.accounts.IExternalAccountCreationOptions.prototype.external_account;
 /** @type {boolean} */
StripeNode.accounts.IExternalAccountCreationOptions.prototype.default_for_currency;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.accounts.IExternalAccountUpdateOptions = function() {};
 /** @type {boolean} */
StripeNode.accounts.IExternalAccountUpdateOptions.prototype.default_for_currency;
/**
 * @extends {StripeNode.IListOptions}
 * @record
 * @struct
 */
StripeNode.accounts.IBankAccountListOptions = function() {};
 /** @type {string} */
StripeNode.accounts.IBankAccountListOptions.prototype.object;
/**
 * @extends {StripeNode.IListOptions}
 * @record
 * @struct
 */
StripeNode.accounts.ICardListOptions = function() {};
 /** @type {string} */
StripeNode.accounts.ICardListOptions.prototype.object;
/**
 * @record
 * @struct
 */
StripeNode.accounts.IRejectReason = function() {};
 /** @type {string} */
StripeNode.accounts.IRejectReason.prototype.reason;
/** @const */
StripeNode.applicationFees = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.applicationFees.IApplicationFee = function() {};
 /** @type {string} */
StripeNode.applicationFees.IApplicationFee.prototype.object;
 /** @type {(string|!StripeNode.accounts.IAccount)} */
StripeNode.applicationFees.IApplicationFee.prototype.account;
 /** @type {number} */
StripeNode.applicationFees.IApplicationFee.prototype.amount;
 /** @type {number} */
StripeNode.applicationFees.IApplicationFee.prototype.amount_refunded;
 /** @type {string} */
StripeNode.applicationFees.IApplicationFee.prototype.application;
 /** @type {(string|!StripeNode.balance.IBalanceTransaction)} */
StripeNode.applicationFees.IApplicationFee.prototype.balance_transaction;
 /** @type {(string|!StripeNode.charges.ICharge)} */
StripeNode.applicationFees.IApplicationFee.prototype.charge;
 /** @type {number} */
StripeNode.applicationFees.IApplicationFee.prototype.created;
 /** @type {string} */
StripeNode.applicationFees.IApplicationFee.prototype.currency;
 /** @type {boolean} */
StripeNode.applicationFees.IApplicationFee.prototype.livemode;
 /** @type {string} */
StripeNode.applicationFees.IApplicationFee.prototype.originating_transaction;
 /** @type {boolean} */
StripeNode.applicationFees.IApplicationFee.prototype.refunded;
 /** @type {!StripeNode.applicationFees.IApplicationFeeRefunds} */
StripeNode.applicationFees.IApplicationFee.prototype.refunds;
/**
 * @extends {StripeNode.IListOptionsCreated}
 * @record
 * @struct
 */
StripeNode.applicationFees.IApplicationFeeListOptions = function() {};
 /** @type {string} */
StripeNode.applicationFees.IApplicationFeeListOptions.prototype.charge;
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.applicationFees.IApplicationFeeRefund = function() {};
 /** @type {string} */
StripeNode.applicationFees.IApplicationFeeRefund.prototype.object;
 /** @type {number} */
StripeNode.applicationFees.IApplicationFeeRefund.prototype.amount;
 /** @type {(string|!StripeNode.balance.IBalanceTransaction)} */
StripeNode.applicationFees.IApplicationFeeRefund.prototype.balance_transaction;
 /** @type {number} */
StripeNode.applicationFees.IApplicationFeeRefund.prototype.created;
 /** @type {string} */
StripeNode.applicationFees.IApplicationFeeRefund.prototype.currency;
 /** @type {(string|!StripeNode.applicationFees.IApplicationFee)} */
StripeNode.applicationFees.IApplicationFeeRefund.prototype.fee;
 /** @type {!StripeNode.IMetadata} */
StripeNode.applicationFees.IApplicationFeeRefund.prototype.metadata;
/**
 * @extends {StripeNode.IList}
 * @record
 * @struct
 */
StripeNode.applicationFees.IApplicationFeeRefunds = function() {};
/**
 * @extends {StripeNode.IDataOptions}
 * @record
 * @struct
 */
StripeNode.applicationFees.IApplicationFeeRefundCreationOptions = function() {};
 /** @type {number} */
StripeNode.applicationFees.IApplicationFeeRefundCreationOptions.prototype.amount;
 /** @type {!StripeNode.IMetadata} */
StripeNode.applicationFees.IApplicationFeeRefundCreationOptions.prototype.metadata;
/** @const */
StripeNode.balance = {};
/**
 * @extends {StripeNode.IObject}
 * @record
 * @struct
 */
StripeNode.balance.IBalance = function() {};
 /** @type {string} */
StripeNode.balance.IBalance.prototype.object;
 /** @type {!Array<!StripeNode.balance.ISourceType>} */
StripeNode.balance.IBalance.prototype.available;
 /** @type {boolean} */
StripeNode.balance.IBalance.prototype.livemode;
 /** @type {!Array<!StripeNode.balance.ISourceType>} */
StripeNode.balance.IBalance.prototype.pending;
/**
 * @record
 * @struct
 */
StripeNode.balance.ISourceType = function() {};
 /** @type {string} */
StripeNode.balance.ISourceType.prototype.currency;
 /** @type {number} */
StripeNode.balance.ISourceType.prototype.amount;
 /** @type {{card: number, bitcoin_receiver: number, customer_bank_account: number, alipay_account: number}} */
StripeNode.balance.ISourceType.prototype.source_types;
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.balance.IBalanceTransaction = function() {};
 /** @type {string} */
StripeNode.balance.IBalanceTransaction.prototype.object;
 /** @type {number} */
StripeNode.balance.IBalanceTransaction.prototype.amount;
 /** @type {number} */
StripeNode.balance.IBalanceTransaction.prototype.available_on;
 /** @type {number} */
StripeNode.balance.IBalanceTransaction.prototype.created;
 /** @type {string} */
StripeNode.balance.IBalanceTransaction.prototype.currency;
 /** @type {string} */
StripeNode.balance.IBalanceTransaction.prototype.description;
 /** @type {number} */
StripeNode.balance.IBalanceTransaction.prototype.fee;
 /** @type {!Array<{amount: number, application: string, currency: string, description: string, type: string}>} */
StripeNode.balance.IBalanceTransaction.prototype.fee_details;
 /** @type {number} */
StripeNode.balance.IBalanceTransaction.prototype.net;
 /** @type {(string|!StripeNode.IResourceObject)} */
StripeNode.balance.IBalanceTransaction.prototype.source;
 /** @type {!StripeNode.IList<!StripeNode.transfers.ITransfer>} */
StripeNode.balance.IBalanceTransaction.prototype.source_transfers;
 /** @type {string} */
StripeNode.balance.IBalanceTransaction.prototype.status;
 /** @type {string} */
StripeNode.balance.IBalanceTransaction.prototype.type;
/**
 * @extends {StripeNode.IListOptions}
 * @record
 * @struct
 */
StripeNode.balance.IBalanceListOptions = function() {};
 /** @type {(string|{gt: string, gte: string, lt: string, lte: string})} */
StripeNode.balance.IBalanceListOptions.prototype.available_on;
 /** @type {string} */
StripeNode.balance.IBalanceListOptions.prototype.currency;
 /** @type {string} */
StripeNode.balance.IBalanceListOptions.prototype.source;
 /** @type {string} */
StripeNode.balance.IBalanceListOptions.prototype.transfer;
 /** @type {string} */
StripeNode.balance.IBalanceListOptions.prototype.type;
/** @const */
StripeNode.charges = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.charges.ICharge = function() {};
 /** @type {string} */
StripeNode.charges.ICharge.prototype.object;
 /** @type {number} */
StripeNode.charges.ICharge.prototype.amount;
 /** @type {number} */
StripeNode.charges.ICharge.prototype.amount_refunded;
 /** @type {string} */
StripeNode.charges.ICharge.prototype.application_fee;
 /** @type {(string|!StripeNode.balance.IBalanceTransaction)} */
StripeNode.charges.ICharge.prototype.balance_transaction;
 /** @type {boolean} */
StripeNode.charges.ICharge.prototype.captured;
 /** @type {number} */
StripeNode.charges.ICharge.prototype.created;
 /** @type {string} */
StripeNode.charges.ICharge.prototype.currency;
 /** @type {(string|!StripeNode.customers.ICustomer)} */
StripeNode.charges.ICharge.prototype.customer;
 /** @type {string} */
StripeNode.charges.ICharge.prototype.description;
 /** @type {!StripeNode.disputes.IDispute} */
StripeNode.charges.ICharge.prototype.dispute;
 /** @type {string} */
StripeNode.charges.ICharge.prototype.failure_code;
 /** @type {string} */
StripeNode.charges.ICharge.prototype.failure_message;
 /** @type {{user_report: string, stripe_report: string}} */
StripeNode.charges.ICharge.prototype.fraud_details;
 /** @type {(string|!StripeNode.invoices.IInvoice)} */
StripeNode.charges.ICharge.prototype.invoice;
 /** @type {boolean} */
StripeNode.charges.ICharge.prototype.livemode;
 /** @type {!StripeNode.IMetadata} */
StripeNode.charges.ICharge.prototype.metadata;
 /** @type {(string|!StripeNode.orders.IOrder)} */
StripeNode.charges.ICharge.prototype.order;
 /** @type {boolean} */
StripeNode.charges.ICharge.prototype.paid;
 /** @type {string} */
StripeNode.charges.ICharge.prototype.receipt_email;
 /** @type {string} */
StripeNode.charges.ICharge.prototype.receipt_number;
 /** @type {boolean} */
StripeNode.charges.ICharge.prototype.refunded;
 /** @type {!StripeNode.charges.IChargeRefunds} */
StripeNode.charges.ICharge.prototype.refunds;
 /** @type {!StripeNode.IShippingInformation} */
StripeNode.charges.ICharge.prototype.shipping;
 /** @type {(!StripeNode.cards.ICard|!StripeNode.bitcoinReceivers.IBitcoinReceiver)} */
StripeNode.charges.ICharge.prototype.source;
 /** @type {(string|!StripeNode.transfers.ITransfer)} */
StripeNode.charges.ICharge.prototype.source_transfer;
 /** @type {string} */
StripeNode.charges.ICharge.prototype.statement_descriptor;
 /** @type {string} */
StripeNode.charges.ICharge.prototype.status;
 /** @type {(string|!StripeNode.transfers.ITransfer)} */
StripeNode.charges.ICharge.prototype.transfer;
/**
 * @extends {StripeNode.IDataOptions}
 * @record
 * @struct
 */
StripeNode.charges.IChargeCreationOptions = function() {};
 /** @type {number} */
StripeNode.charges.IChargeCreationOptions.prototype.amount;
 /** @type {string} */
StripeNode.charges.IChargeCreationOptions.prototype.currency;
 /** @type {number} */
StripeNode.charges.IChargeCreationOptions.prototype.application_fee;
 /** @type {boolean} */
StripeNode.charges.IChargeCreationOptions.prototype.capture;
 /** @type {string} */
StripeNode.charges.IChargeCreationOptions.prototype.description;
 /** @type {string} */
StripeNode.charges.IChargeCreationOptions.prototype.destination;
 /** @type {!StripeNode.IMetadata} */
StripeNode.charges.IChargeCreationOptions.prototype.metadata;
 /** @type {string} */
StripeNode.charges.IChargeCreationOptions.prototype.receipt_email;
 /** @type {!StripeNode.IShippingInformation} */
StripeNode.charges.IChargeCreationOptions.prototype.shipping;
 /** @type {string} */
StripeNode.charges.IChargeCreationOptions.prototype.customer;
 /** @type {(string|!StripeNode.cards.ISourceCreationOptions)} */
StripeNode.charges.IChargeCreationOptions.prototype.source;
 /** @type {string} */
StripeNode.charges.IChargeCreationOptions.prototype.statement_descriptor;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.charges.IChargeUpdateOptions = function() {};
 /** @type {string} */
StripeNode.charges.IChargeUpdateOptions.prototype.description;
 /** @type {{user_report: string}} */
StripeNode.charges.IChargeUpdateOptions.prototype.fraud_details;
 /** @type {string} */
StripeNode.charges.IChargeUpdateOptions.prototype.receipt_email;
 /** @type {!StripeNode.IShippingInformation} */
StripeNode.charges.IChargeUpdateOptions.prototype.shipping;
/**
 * @extends {StripeNode.IListOptionsCreated}
 * @record
 * @struct
 */
StripeNode.charges.IChargeListOptions = function() {};
 /** @type {string} */
StripeNode.charges.IChargeListOptions.prototype.customer;
 /** @type {{object: string}} */
StripeNode.charges.IChargeListOptions.prototype.source;
/**
 * @extends {StripeNode.IList}
 * @record
 * @struct
 */
StripeNode.charges.IChargeRefunds = function() {};
/** @const */
StripeNode.coupons = {};
/**
 * @extends {StripeNode.IObject}
 * @record
 * @struct
 */
StripeNode.coupons.IDiscount = function() {};
 /** @type {string} */
StripeNode.coupons.IDiscount.prototype.object;
 /** @type {!StripeNode.coupons.ICoupon} */
StripeNode.coupons.IDiscount.prototype.coupon;
 /** @type {string} */
StripeNode.coupons.IDiscount.prototype.customer;
 /** @type {number} */
StripeNode.coupons.IDiscount.prototype.end;
 /** @type {number} */
StripeNode.coupons.IDiscount.prototype.start;
 /** @type {string} */
StripeNode.coupons.IDiscount.prototype.subscription;
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.coupons.ICoupon = function() {};
 /** @type {string} */
StripeNode.coupons.ICoupon.prototype.object;
 /** @type {number} */
StripeNode.coupons.ICoupon.prototype.amount_off;
 /** @type {number} */
StripeNode.coupons.ICoupon.prototype.created;
 /** @type {string} */
StripeNode.coupons.ICoupon.prototype.currency;
 /** @type {string} */
StripeNode.coupons.ICoupon.prototype.duration;
 /** @type {number} */
StripeNode.coupons.ICoupon.prototype.duration_in_months;
 /** @type {boolean} */
StripeNode.coupons.ICoupon.prototype.livemode;
 /** @type {number} */
StripeNode.coupons.ICoupon.prototype.max_redemptions;
 /** @type {!StripeNode.IMetadata} */
StripeNode.coupons.ICoupon.prototype.metadata;
 /** @type {number} */
StripeNode.coupons.ICoupon.prototype.percent_off;
 /** @type {number} */
StripeNode.coupons.ICoupon.prototype.redeem_by;
 /** @type {number} */
StripeNode.coupons.ICoupon.prototype.times_redeemed;
 /** @type {boolean} */
StripeNode.coupons.ICoupon.prototype.valid;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.coupons.ICouponCreationOptions = function() {};
 /** @type {string} */
StripeNode.coupons.ICouponCreationOptions.prototype.id;
 /** @type {string} */
StripeNode.coupons.ICouponCreationOptions.prototype.duration;
 /** @type {number} */
StripeNode.coupons.ICouponCreationOptions.prototype.amount_off;
 /** @type {string} */
StripeNode.coupons.ICouponCreationOptions.prototype.currency;
 /** @type {number} */
StripeNode.coupons.ICouponCreationOptions.prototype.duration_in_months;
 /** @type {number} */
StripeNode.coupons.ICouponCreationOptions.prototype.max_redemptions;
 /** @type {number} */
StripeNode.coupons.ICouponCreationOptions.prototype.percent_off;
 /** @type {number} */
StripeNode.coupons.ICouponCreationOptions.prototype.redeem_by;
/** @const */
StripeNode.customers = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.customers.ICustomer = function() {};
 /** @type {string} */
StripeNode.customers.ICustomer.prototype.object;
 /** @type {number} */
StripeNode.customers.ICustomer.prototype.account_balance;
 /** @type {number} */
StripeNode.customers.ICustomer.prototype.created;
 /** @type {string} */
StripeNode.customers.ICustomer.prototype.currency;
 /** @type {(string|!StripeNode.cards.ICard|!StripeNode.bitcoinReceivers.IBitcoinReceiver)} */
StripeNode.customers.ICustomer.prototype.default_source;
 /** @type {boolean} */
StripeNode.customers.ICustomer.prototype.delinquent;
 /** @type {string} */
StripeNode.customers.ICustomer.prototype.description;
 /** @type {!StripeNode.coupons.IDiscount} */
StripeNode.customers.ICustomer.prototype.discount;
 /** @type {string} */
StripeNode.customers.ICustomer.prototype.email;
 /** @type {boolean} */
StripeNode.customers.ICustomer.prototype.livemode;
 /** @type {!StripeNode.IMetadata} */
StripeNode.customers.ICustomer.prototype.metadata;
 /** @type {!StripeNode.IShippingInformation} */
StripeNode.customers.ICustomer.prototype.shipping;
 /** @type {!StripeNode.IList<(!StripeNode.cards.ICard|!StripeNode.bitcoinReceivers.IBitcoinReceiver)>} */
StripeNode.customers.ICustomer.prototype.sources;
 /** @type {!StripeNode.resources.CustomerCards} */
StripeNode.customers.ICustomer.prototype.cards;
 /** @type {!StripeNode.customers.ICustomerSubscriptions} */
StripeNode.customers.ICustomer.prototype.subscriptions;
/**
 * @extends {StripeNode.IList}
 * @record
 * @struct
 */
StripeNode.customers.ICustomerSubscriptions = function() {};
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.customers.ICustomerCreationOptions = function() {};
 /** @type {number} */
StripeNode.customers.ICustomerCreationOptions.prototype.account_balance;
 /** @type {string} */
StripeNode.customers.ICustomerCreationOptions.prototype.coupon;
 /** @type {string} */
StripeNode.customers.ICustomerCreationOptions.prototype.description;
 /** @type {string} */
StripeNode.customers.ICustomerCreationOptions.prototype.email;
 /** @type {string} */
StripeNode.customers.ICustomerCreationOptions.prototype.plan;
 /** @type {number} */
StripeNode.customers.ICustomerCreationOptions.prototype.quantity;
 /** @type {!StripeNode.IShippingInformation} */
StripeNode.customers.ICustomerCreationOptions.prototype.shipping;
 /** @type {(string|!StripeNode.cards.ISourceCreationOptionsExtended)} */
StripeNode.customers.ICustomerCreationOptions.prototype.source;
 /** @type {number} */
StripeNode.customers.ICustomerCreationOptions.prototype.tax_percent;
 /** @type {number} */
StripeNode.customers.ICustomerCreationOptions.prototype.trial_end;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.customers.ICustomerUpdateOptions = function() {};
 /** @type {number} */
StripeNode.customers.ICustomerUpdateOptions.prototype.account_balance;
 /** @type {string} */
StripeNode.customers.ICustomerUpdateOptions.prototype.coupon;
 /** @type {string} */
StripeNode.customers.ICustomerUpdateOptions.prototype.default_source;
 /** @type {string} */
StripeNode.customers.ICustomerUpdateOptions.prototype.description;
 /** @type {string} */
StripeNode.customers.ICustomerUpdateOptions.prototype.email;
 /** @type {!StripeNode.IShippingInformation} */
StripeNode.customers.ICustomerUpdateOptions.prototype.shipping;
 /** @type {(string|!StripeNode.cards.ISourceCreationOptionsExtended)} */
StripeNode.customers.ICustomerUpdateOptions.prototype.source;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.customers.ICustomerSourceCreationOptions = function() {};
 /** @type {(string|!StripeNode.cards.ISourceCreationOptions)} */
StripeNode.customers.ICustomerSourceCreationOptions.prototype.source;
/**
 * @extends {StripeNode.customers.ICustomerSourceCreationOptions}
 * @record
 * @struct
 */
StripeNode.customers.ICustomerCardSourceCreationOptions = function() {};
 /** @type {!StripeNode.cards.ISourceCreationOptions} */
StripeNode.customers.ICustomerCardSourceCreationOptions.prototype.source;
/**
 * @extends {StripeNode.IListOptions}
 * @record
 * @struct
 */
StripeNode.customers.IBankAccountSourceListOptions = function() {};
 /** @type {string} */
StripeNode.customers.IBankAccountSourceListOptions.prototype.object;
/**
 * @extends {StripeNode.IListOptions}
 * @record
 * @struct
 */
StripeNode.customers.ICardSourceListOptions = function() {};
 /** @type {string} */
StripeNode.customers.ICardSourceListOptions.prototype.object;
/** @const */
StripeNode.disputes = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.disputes.IDispute = function() {};
 /** @type {string} */
StripeNode.disputes.IDispute.prototype.object;
 /** @type {number} */
StripeNode.disputes.IDispute.prototype.amount;
 /** @type {!Array<!StripeNode.balance.IBalanceTransaction>} */
StripeNode.disputes.IDispute.prototype.balance_transactions;
 /** @type {(string|!StripeNode.charges.ICharge)} */
StripeNode.disputes.IDispute.prototype.charge;
 /** @type {number} */
StripeNode.disputes.IDispute.prototype.created;
 /** @type {string} */
StripeNode.disputes.IDispute.prototype.currency;
 /** @type {!StripeNode.disputes.IDisputeEvidence} */
StripeNode.disputes.IDispute.prototype.evidence;
 /** @type {{due_by: number, has_evidence: boolean, past_due: boolean, submission_count: number}} */
StripeNode.disputes.IDispute.prototype.evidence_details;
 /** @type {boolean} */
StripeNode.disputes.IDispute.prototype.is_charge_refundable;
 /** @type {boolean} */
StripeNode.disputes.IDispute.prototype.livemode;
 /** @type {!StripeNode.IMetadata} */
StripeNode.disputes.IDispute.prototype.metadata;
 /** @type {string} */
StripeNode.disputes.IDispute.prototype.reason;
 /** @type {string} */
StripeNode.disputes.IDispute.prototype.status;
/**
 * @record
 * @struct
 */
StripeNode.disputes.IDisputeEvidence = function() {};
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.access_activity_log;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.billing_address;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.cancellation_policy;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.cancellation_policy_disclosure;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.cancellation_rebuttal;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.customer_communication;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.customer_email_address;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.customer_name;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.customer_purchase_ip;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.customer_signature;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.duplicate_charge_documentation;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.duplicate_charge_explanation;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.duplicate_charge_id;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.product_description;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.receipt;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.refund_policy;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.refund_policy_disclosure;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.refund_refusal_explanation;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.service_date;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.service_documentation;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.shipping_address;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.shipping_carrier;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.shipping_date;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.shipping_documentation;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.shipping_tracking_number;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.uncategorized_file;
 /** @type {string} */
StripeNode.disputes.IDisputeEvidence.prototype.uncategorized_text;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.disputes.IDisputeUpdateOptions = function() {};
 /** @type {!StripeNode.disputes.IDisputeEvidence} */
StripeNode.disputes.IDisputeUpdateOptions.prototype.evidence;
/** @const */
StripeNode.events = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.events.IEvent = function() {};
 /** @type {string} */
StripeNode.events.IEvent.prototype.object;
 /** @type {string} */
StripeNode.events.IEvent.prototype.api_version;
 /** @type {number} */
StripeNode.events.IEvent.prototype.created;
 /** @type {{object: !StripeNode.IObject, previous_attributes: !Object}} */
StripeNode.events.IEvent.prototype.data;
 /** @type {boolean} */
StripeNode.events.IEvent.prototype.livemode;
 /** @type {number} */
StripeNode.events.IEvent.prototype.pending_webhooks;
 /** @type {string} */
StripeNode.events.IEvent.prototype.request;
 /** @type {string} */
StripeNode.events.IEvent.prototype.type;
/**
 * @extends {StripeNode.IListOptionsCreated}
 * @record
 * @struct
 */
StripeNode.events.IEventListOptions = function() {};
 /** @type {string} */
StripeNode.events.IEventListOptions.prototype.type;
/** @const */
StripeNode.fileUploads = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.fileUploads.IFileUpdate = function() {};
 /** @type {string} */
StripeNode.fileUploads.IFileUpdate.prototype.object;
 /** @type {number} */
StripeNode.fileUploads.IFileUpdate.prototype.created;
 /** @type {string} */
StripeNode.fileUploads.IFileUpdate.prototype.purpose;
 /** @type {number} */
StripeNode.fileUploads.IFileUpdate.prototype.size;
 /** @type {string} */
StripeNode.fileUploads.IFileUpdate.prototype.type;
 /** @type {string} */
StripeNode.fileUploads.IFileUpdate.prototype.url;
/**
 * @extends {StripeNode.IDataOptions}
 * @record
 * @struct
 */
StripeNode.fileUploads.IFileUploadCreationOptions = function() {};
 /** @type {string} */
StripeNode.fileUploads.IFileUploadCreationOptions.prototype.purpose;
 /** @type {{data: (string|?), name: string, type: string}} */
StripeNode.fileUploads.IFileUploadCreationOptions.prototype.file;
/**
 * @extends {StripeNode.IListOptionsCreated}
 * @record
 * @struct
 */
StripeNode.fileUploads.IFileUploadListOptions = function() {};
 /** @type {string} */
StripeNode.fileUploads.IFileUploadListOptions.prototype.purpose;

/** @typedef {string} */
StripeNode.fileUploads.IPurpose;
/** @const */
StripeNode.invoices = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.invoices.IInvoice = function() {};
 /** @type {string} */
StripeNode.invoices.IInvoice.prototype.object;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.amount_due;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.application_fee;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.attempt_count;
 /** @type {boolean} */
StripeNode.invoices.IInvoice.prototype.attempted;
 /** @type {(string|!StripeNode.charges.ICharge)} */
StripeNode.invoices.IInvoice.prototype.charge;
 /** @type {boolean} */
StripeNode.invoices.IInvoice.prototype.closed;
 /** @type {string} */
StripeNode.invoices.IInvoice.prototype.currency;
 /** @type {string} */
StripeNode.invoices.IInvoice.prototype.customer;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.date;
 /** @type {string} */
StripeNode.invoices.IInvoice.prototype.description;
 /** @type {!StripeNode.coupons.IDiscount} */
StripeNode.invoices.IInvoice.prototype.discount;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.ending_balance;
 /** @type {boolean} */
StripeNode.invoices.IInvoice.prototype.forgiven;
 /** @type {!StripeNode.IList<!StripeNode.invoices.IInvoiceLineItem>} */
StripeNode.invoices.IInvoice.prototype.lines;
 /** @type {boolean} */
StripeNode.invoices.IInvoice.prototype.livemode;
 /** @type {!StripeNode.IMetadata} */
StripeNode.invoices.IInvoice.prototype.metadata;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.next_payment_attempt;
 /** @type {boolean} */
StripeNode.invoices.IInvoice.prototype.paid;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.period_end;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.period_start;
 /** @type {string} */
StripeNode.invoices.IInvoice.prototype.receipt_number;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.starting_balance;
 /** @type {string} */
StripeNode.invoices.IInvoice.prototype.statement_descriptor;
 /** @type {string} */
StripeNode.invoices.IInvoice.prototype.subscription;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.subscription_proration_date;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.subtotal;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.tax;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.tax_percent;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.total;
 /** @type {number} */
StripeNode.invoices.IInvoice.prototype.webhooks_delivered_at;
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.invoices.IInvoiceLineItem = function() {};
 /** @type {string} */
StripeNode.invoices.IInvoiceLineItem.prototype.id;
 /** @type {string} */
StripeNode.invoices.IInvoiceLineItem.prototype.object;
 /** @type {number} */
StripeNode.invoices.IInvoiceLineItem.prototype.amount;
 /** @type {string} */
StripeNode.invoices.IInvoiceLineItem.prototype.currency;
 /** @type {string} */
StripeNode.invoices.IInvoiceLineItem.prototype.description;
 /** @type {boolean} */
StripeNode.invoices.IInvoiceLineItem.prototype.discountable;
 /** @type {boolean} */
StripeNode.invoices.IInvoiceLineItem.prototype.livemode;
 /** @type {!StripeNode.IMetadata} */
StripeNode.invoices.IInvoiceLineItem.prototype.metadata;
 /** @type {!StripeNode.invoices.IPeriod} */
StripeNode.invoices.IInvoiceLineItem.prototype.period;
 /** @type {!StripeNode.plans.IPlan} */
StripeNode.invoices.IInvoiceLineItem.prototype.plan;
 /** @type {boolean} */
StripeNode.invoices.IInvoiceLineItem.prototype.proration;
 /** @type {number} */
StripeNode.invoices.IInvoiceLineItem.prototype.quantity;
 /** @type {string} */
StripeNode.invoices.IInvoiceLineItem.prototype.subscription;
 /** @type {string} */
StripeNode.invoices.IInvoiceLineItem.prototype.type;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.invoices.IInvoiceCreationOptions = function() {};
 /** @type {string} */
StripeNode.invoices.IInvoiceCreationOptions.prototype.customer;
 /** @type {number} */
StripeNode.invoices.IInvoiceCreationOptions.prototype.application_fee;
 /** @type {string} */
StripeNode.invoices.IInvoiceCreationOptions.prototype.description;
 /** @type {string} */
StripeNode.invoices.IInvoiceCreationOptions.prototype.statement_descriptor;
 /** @type {string} */
StripeNode.invoices.IInvoiceCreationOptions.prototype.subscription;
 /** @type {number} */
StripeNode.invoices.IInvoiceCreationOptions.prototype.tax_percent;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.invoices.IInvoiceUpdateOptions = function() {};
 /** @type {number} */
StripeNode.invoices.IInvoiceUpdateOptions.prototype.application_fee;
 /** @type {boolean} */
StripeNode.invoices.IInvoiceUpdateOptions.prototype.closed;
 /** @type {string} */
StripeNode.invoices.IInvoiceUpdateOptions.prototype.description;
 /** @type {boolean} */
StripeNode.invoices.IInvoiceUpdateOptions.prototype.forgiven;
 /** @type {string} */
StripeNode.invoices.IInvoiceUpdateOptions.prototype.statement_descriptor;
 /** @type {number} */
StripeNode.invoices.IInvoiceUpdateOptions.prototype.tax_percent;
/**
 * @extends {StripeNode.IListOptions}
 * @record
 * @struct
 */
StripeNode.invoices.IInvoiceListOptions = function() {};
 /** @type {string} */
StripeNode.invoices.IInvoiceListOptions.prototype.customer;
 /** @type {(string|{gt: string, gte: string, lt: string, lte: string})} */
StripeNode.invoices.IInvoiceListOptions.prototype.date;
/**
 * @extends {StripeNode.IListOptions}
 * @record
 * @struct
 */
StripeNode.invoices.IInvoiceLineItemRetrievalOptions = function() {};
 /** @type {string} */
StripeNode.invoices.IInvoiceLineItemRetrievalOptions.prototype.coupon;
 /** @type {string} */
StripeNode.invoices.IInvoiceLineItemRetrievalOptions.prototype.customer;
 /** @type {string} */
StripeNode.invoices.IInvoiceLineItemRetrievalOptions.prototype.subscription;
 /** @type {string} */
StripeNode.invoices.IInvoiceLineItemRetrievalOptions.prototype.subscription_plan;
 /** @type {boolean} */
StripeNode.invoices.IInvoiceLineItemRetrievalOptions.prototype.subscription_prorate;
 /** @type {number} */
StripeNode.invoices.IInvoiceLineItemRetrievalOptions.prototype.subscription_proration_date;
 /** @type {number} */
StripeNode.invoices.IInvoiceLineItemRetrievalOptions.prototype.subscription_quantity;
 /** @type {number} */
StripeNode.invoices.IInvoiceLineItemRetrievalOptions.prototype.subscription_trial_end;
/**
 * @extends {StripeNode.IDataOptions}
 * @record
 * @struct
 */
StripeNode.invoices.IInvoiceUpcomingOptions = function() {};
 /** @type {string} */
StripeNode.invoices.IInvoiceUpcomingOptions.prototype.coupon;
 /** @type {string} */
StripeNode.invoices.IInvoiceUpcomingOptions.prototype.subscription;
 /** @type {string} */
StripeNode.invoices.IInvoiceUpcomingOptions.prototype.subscription_plan;
 /** @type {boolean} */
StripeNode.invoices.IInvoiceUpcomingOptions.prototype.subscription_prorate;
 /** @type {number} */
StripeNode.invoices.IInvoiceUpcomingOptions.prototype.subscription_proration_date;
 /** @type {number} */
StripeNode.invoices.IInvoiceUpcomingOptions.prototype.subscription_quantity;
 /** @type {number} */
StripeNode.invoices.IInvoiceUpcomingOptions.prototype.subscription_trial_end;
/**
 * @record
 * @struct
 */
StripeNode.invoices.IPeriod = function() {};
 /** @type {number} */
StripeNode.invoices.IPeriod.prototype.start;
 /** @type {number} */
StripeNode.invoices.IPeriod.prototype.end;
/** @const */
StripeNode.invoiceItems = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.invoiceItems.InvoiceItem = function() {};
 /** @type {string} */
StripeNode.invoiceItems.InvoiceItem.prototype.object;
 /** @type {number} */
StripeNode.invoiceItems.InvoiceItem.prototype.amount;
 /** @type {string} */
StripeNode.invoiceItems.InvoiceItem.prototype.currency;
 /** @type {string} */
StripeNode.invoiceItems.InvoiceItem.prototype.customer;
 /** @type {number} */
StripeNode.invoiceItems.InvoiceItem.prototype.date;
 /** @type {string} */
StripeNode.invoiceItems.InvoiceItem.prototype.description;
 /** @type {boolean} */
StripeNode.invoiceItems.InvoiceItem.prototype.discountable;
 /** @type {string} */
StripeNode.invoiceItems.InvoiceItem.prototype.invoice;
 /** @type {boolean} */
StripeNode.invoiceItems.InvoiceItem.prototype.livemode;
 /** @type {!StripeNode.IMetadata} */
StripeNode.invoiceItems.InvoiceItem.prototype.metadata;
 /** @type {!StripeNode.invoices.IPeriod} */
StripeNode.invoiceItems.InvoiceItem.prototype.period;
 /** @type {!StripeNode.plans.IPlan} */
StripeNode.invoiceItems.InvoiceItem.prototype.plan;
 /** @type {boolean} */
StripeNode.invoiceItems.InvoiceItem.prototype.proration;
 /** @type {number} */
StripeNode.invoiceItems.InvoiceItem.prototype.quantity;
 /** @type {string} */
StripeNode.invoiceItems.InvoiceItem.prototype.subscription;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.invoiceItems.InvoiceItemCreationOptions = function() {};
 /** @type {number} */
StripeNode.invoiceItems.InvoiceItemCreationOptions.prototype.amount;
 /** @type {string} */
StripeNode.invoiceItems.InvoiceItemCreationOptions.prototype.currency;
 /** @type {string} */
StripeNode.invoiceItems.InvoiceItemCreationOptions.prototype.customer;
 /** @type {string} */
StripeNode.invoiceItems.InvoiceItemCreationOptions.prototype.description;
 /** @type {boolean} */
StripeNode.invoiceItems.InvoiceItemCreationOptions.prototype.discountable;
 /** @type {string} */
StripeNode.invoiceItems.InvoiceItemCreationOptions.prototype.invoice;
 /** @type {string} */
StripeNode.invoiceItems.InvoiceItemCreationOptions.prototype.subscription;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.invoiceItems.InvoiceItemUpdateOptions = function() {};
 /** @type {number} */
StripeNode.invoiceItems.InvoiceItemUpdateOptions.prototype.amount;
 /** @type {string} */
StripeNode.invoiceItems.InvoiceItemUpdateOptions.prototype.description;
 /** @type {boolean} */
StripeNode.invoiceItems.InvoiceItemUpdateOptions.prototype.discountable;
/**
 * @extends {StripeNode.IListOptionsCreated}
 * @record
 * @struct
 */
StripeNode.invoiceItems.InvoiceItemListOptions = function() {};
 /** @type {string} */
StripeNode.invoiceItems.InvoiceItemListOptions.prototype.customer;
/** @const */
StripeNode.orders = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.orders.IOrder = function() {};
 /** @type {string} */
StripeNode.orders.IOrder.prototype.object;
 /** @type {number} */
StripeNode.orders.IOrder.prototype.amount;
 /** @type {string} */
StripeNode.orders.IOrder.prototype.application;
 /** @type {number} */
StripeNode.orders.IOrder.prototype.application_fee;
 /** @type {(string|!StripeNode.charges.ICharge)} */
StripeNode.orders.IOrder.prototype.charge;
 /** @type {number} */
StripeNode.orders.IOrder.prototype.created;
 /** @type {string} */
StripeNode.orders.IOrder.prototype.currency;
 /** @type {(string|!StripeNode.customers.ICustomer)} */
StripeNode.orders.IOrder.prototype.customer;
 /** @type {string} */
StripeNode.orders.IOrder.prototype.email;
 /** @type {string} */
StripeNode.orders.IOrder.prototype.external_coupon_code;
 /** @type {!Array<!StripeNode.orders.IOrderItem>} */
StripeNode.orders.IOrder.prototype.items;
 /** @type {boolean} */
StripeNode.orders.IOrder.prototype.livemode;
 /** @type {!StripeNode.IMetadata} */
StripeNode.orders.IOrder.prototype.metadata;
 /** @type {string} */
StripeNode.orders.IOrder.prototype.selected_shipping_method;
 /** @type {!StripeNode.IShippingInformation} */
StripeNode.orders.IOrder.prototype.shipping;
 /** @type {!Array<!StripeNode.orders.IShippingMethod>} */
StripeNode.orders.IOrder.prototype.shipping_methods;
 /** @type {string} */
StripeNode.orders.IOrder.prototype.status;
 /** @type {{canceled: number, fulfiled: number, paid: number, returned: number}} */
StripeNode.orders.IOrder.prototype.status_transactions;
 /** @type {number} */
StripeNode.orders.IOrder.prototype.updated;
/**
 * @extends {StripeNode.IObject}
 * @record
 * @struct
 */
StripeNode.orders.IOrderItem = function() {};
 /** @type {string} */
StripeNode.orders.IOrderItem.prototype.object;
 /** @type {number} */
StripeNode.orders.IOrderItem.prototype.amount;
 /** @type {string} */
StripeNode.orders.IOrderItem.prototype.currency;
 /** @type {string} */
StripeNode.orders.IOrderItem.prototype.description;
 /** @type {(string|!StripeNode.skus.ISku)} */
StripeNode.orders.IOrderItem.prototype.parent;
 /** @type {number} */
StripeNode.orders.IOrderItem.prototype.quantity;
 /** @type {string} */
StripeNode.orders.IOrderItem.prototype.type;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.orders.IOrderCreationOptions = function() {};
 /** @type {string} */
StripeNode.orders.IOrderCreationOptions.prototype.currency;
 /** @type {string} */
StripeNode.orders.IOrderCreationOptions.prototype.coupon;
 /** @type {string} */
StripeNode.orders.IOrderCreationOptions.prototype.customer;
 /** @type {string} */
StripeNode.orders.IOrderCreationOptions.prototype.email;
 /** @type {!Array<!StripeNode.orders.IOrderItemCreationHash>} */
StripeNode.orders.IOrderCreationOptions.prototype.items;
 /** @type {!StripeNode.IShippingInformation} */
StripeNode.orders.IOrderCreationOptions.prototype.shipping;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.orders.IOrderUpdateOptions = function() {};
 /** @type {string} */
StripeNode.orders.IOrderUpdateOptions.prototype.coupon;
 /** @type {string} */
StripeNode.orders.IOrderUpdateOptions.prototype.selected_shipping_method;
 /** @type {string} */
StripeNode.orders.IOrderUpdateOptions.prototype.status;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.orders.IOrderPayOptions = function() {};
 /** @type {string} */
StripeNode.orders.IOrderPayOptions.prototype.customer;
 /** @type {(string|!StripeNode.cards.ISourceCreationOptions)} */
StripeNode.orders.IOrderPayOptions.prototype.source;
 /** @type {number} */
StripeNode.orders.IOrderPayOptions.prototype.application_fee;
 /** @type {string} */
StripeNode.orders.IOrderPayOptions.prototype.email;
/**
 * @extends {StripeNode.IListOptionsCreated}
 * @record
 * @struct
 */
StripeNode.orders.IOrderListOptions = function() {};
 /** @type {string} */
StripeNode.orders.IOrderListOptions.prototype.customer;
 /** @type {!Array<string>} */
StripeNode.orders.IOrderListOptions.prototype.ids;
 /** @type {string} */
StripeNode.orders.IOrderListOptions.prototype.status;
 /** @type {{canceled: (string|{gt: string, gte: string, lt: string, lte: string}), fulfilled: (string|?), paid: (string|?), returned: (string|?)}} */
StripeNode.orders.IOrderListOptions.prototype.status_transitions;
/**
 * @record
 * @struct
 */
StripeNode.orders.IOrderItemCreationHash = function() {};
 /** @type {number} */
StripeNode.orders.IOrderItemCreationHash.prototype.amount;
 /** @type {string} */
StripeNode.orders.IOrderItemCreationHash.prototype.currency;
 /** @type {string} */
StripeNode.orders.IOrderItemCreationHash.prototype.description;
 /** @type {string} */
StripeNode.orders.IOrderItemCreationHash.prototype.parent;
 /** @type {number} */
StripeNode.orders.IOrderItemCreationHash.prototype.quantity;
 /** @type {string} */
StripeNode.orders.IOrderItemCreationHash.prototype.type;
/**
 * @record
 * @struct
 */
StripeNode.orders.IShippingMethod = function() {};
 /** @type {string} */
StripeNode.orders.IShippingMethod.prototype.id;
 /** @type {number} */
StripeNode.orders.IShippingMethod.prototype.amount;
 /** @type {string} */
StripeNode.orders.IShippingMethod.prototype.currency;
 /** @type {{date: string, earliest: string, latest: string, type: string}} */
StripeNode.orders.IShippingMethod.prototype.delivery_estimate;
 /** @type {string} */
StripeNode.orders.IShippingMethod.prototype.description;

/** @typedef {string} */
StripeNode.orders.OrderStatus;
/** @const */
StripeNode.plans = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.plans.IPlan = function() {};
 /** @type {string} */
StripeNode.plans.IPlan.prototype.object;
 /** @type {number} */
StripeNode.plans.IPlan.prototype.amount;
 /** @type {number} */
StripeNode.plans.IPlan.prototype.created;
 /** @type {string} */
StripeNode.plans.IPlan.prototype.currency;
 /** @type {string} */
StripeNode.plans.IPlan.prototype.interval;
 /** @type {number} */
StripeNode.plans.IPlan.prototype.interval_count;
 /** @type {boolean} */
StripeNode.plans.IPlan.prototype.livemode;
 /** @type {!StripeNode.IMetadata} */
StripeNode.plans.IPlan.prototype.metadata;
 /** @type {string} */
StripeNode.plans.IPlan.prototype.name;
 /** @type {string} */
StripeNode.plans.IPlan.prototype.statement_descriptor;
 /** @type {number} */
StripeNode.plans.IPlan.prototype.trial_period_days;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.plans.IPlanCreationOptions = function() {};
 /** @type {string} */
StripeNode.plans.IPlanCreationOptions.prototype.id;
 /** @type {number} */
StripeNode.plans.IPlanCreationOptions.prototype.amount;
 /** @type {string} */
StripeNode.plans.IPlanCreationOptions.prototype.currency;
 /** @type {string} */
StripeNode.plans.IPlanCreationOptions.prototype.interval;
 /** @type {string} */
StripeNode.plans.IPlanCreationOptions.prototype.name;
 /** @type {number} */
StripeNode.plans.IPlanCreationOptions.prototype.interval_count;
 /** @type {string} */
StripeNode.plans.IPlanCreationOptions.prototype.statement_descriptor;
 /** @type {number} */
StripeNode.plans.IPlanCreationOptions.prototype.trial_period_days;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.plans.IPlanUpdateOptions = function() {};
 /** @type {string} */
StripeNode.plans.IPlanUpdateOptions.prototype.name;
 /** @type {string} */
StripeNode.plans.IPlanUpdateOptions.prototype.statement_descriptor;

/** @typedef {string} */
StripeNode.plans.IntervalUnit;
/** @const */
StripeNode.products = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.products.IProduct = function() {};
 /** @type {string} */
StripeNode.products.IProduct.prototype.object;
 /** @type {boolean} */
StripeNode.products.IProduct.prototype.active;
 /** @type {!Array<string>} */
StripeNode.products.IProduct.prototype.attributes;
 /** @type {string} */
StripeNode.products.IProduct.prototype.caption;
 /** @type {number} */
StripeNode.products.IProduct.prototype.created;
 /** @type {!Array<string>} */
StripeNode.products.IProduct.prototype.deactivated_on;
 /** @type {string} */
StripeNode.products.IProduct.prototype.description;
 /** @type {!Array<string>} */
StripeNode.products.IProduct.prototype.images;
 /** @type {boolean} */
StripeNode.products.IProduct.prototype.livemode;
 /** @type {!StripeNode.IMetadata} */
StripeNode.products.IProduct.prototype.metadata;
 /** @type {string} */
StripeNode.products.IProduct.prototype.name;
 /** @type {!StripeNode.products.IPackageDimensions} */
StripeNode.products.IProduct.prototype.package_dimensions;
 /** @type {boolean} */
StripeNode.products.IProduct.prototype.shippable;
 /** @type {!StripeNode.IList<!StripeNode.skus.ISku>} */
StripeNode.products.IProduct.prototype.skus;
 /** @type {number} */
StripeNode.products.IProduct.prototype.updated;
 /** @type {string} */
StripeNode.products.IProduct.prototype.url;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.products.IProductCreationOptions = function() {};
 /** @type {string} */
StripeNode.products.IProductCreationOptions.prototype.id;
 /** @type {string} */
StripeNode.products.IProductCreationOptions.prototype.name;
 /** @type {boolean} */
StripeNode.products.IProductCreationOptions.prototype.active;
 /** @type {!Array<string>} */
StripeNode.products.IProductCreationOptions.prototype.attribute;
 /** @type {string} */
StripeNode.products.IProductCreationOptions.prototype.caption;
 /** @type {!Array<string>} */
StripeNode.products.IProductCreationOptions.prototype.deactivate_on;
 /** @type {string} */
StripeNode.products.IProductCreationOptions.prototype.description;
 /** @type {!Array<string>} */
StripeNode.products.IProductCreationOptions.prototype.images;
 /** @type {!StripeNode.products.IPackageDimensions} */
StripeNode.products.IProductCreationOptions.prototype.package_dimensions;
 /** @type {boolean} */
StripeNode.products.IProductCreationOptions.prototype.shippable;
 /** @type {string} */
StripeNode.products.IProductCreationOptions.prototype.url;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.products.IProductUpdateOptions = function() {};
 /** @type {boolean} */
StripeNode.products.IProductUpdateOptions.prototype.active;
 /** @type {string} */
StripeNode.products.IProductUpdateOptions.prototype.caption;
 /** @type {!Array<string>} */
StripeNode.products.IProductUpdateOptions.prototype.deactivate_on;
 /** @type {string} */
StripeNode.products.IProductUpdateOptions.prototype.description;
 /** @type {!Array<string>} */
StripeNode.products.IProductUpdateOptions.prototype.images;
 /** @type {string} */
StripeNode.products.IProductUpdateOptions.prototype.name;
 /** @type {!StripeNode.products.IPackageDimensions} */
StripeNode.products.IProductUpdateOptions.prototype.package_dimensions;
 /** @type {boolean} */
StripeNode.products.IProductUpdateOptions.prototype.shippable;
 /** @type {string} */
StripeNode.products.IProductUpdateOptions.prototype.url;
/**
 * @extends {StripeNode.IListOptions}
 * @record
 * @struct
 */
StripeNode.products.IProductListOptions = function() {};
 /** @type {boolean} */
StripeNode.products.IProductListOptions.prototype.active;
 /** @type {!Array<string>} */
StripeNode.products.IProductListOptions.prototype.ids;
 /** @type {boolean} */
StripeNode.products.IProductListOptions.prototype.shippable;
 /** @type {string} */
StripeNode.products.IProductListOptions.prototype.url;
/**
 * @record
 * @struct
 */
StripeNode.products.IPackageDimensions = function() {};
 /** @type {number} */
StripeNode.products.IPackageDimensions.prototype.height;
 /** @type {number} */
StripeNode.products.IPackageDimensions.prototype.length;
 /** @type {number} */
StripeNode.products.IPackageDimensions.prototype.weight;
 /** @type {number} */
StripeNode.products.IPackageDimensions.prototype.width;
/** @const */
StripeNode.recipientCards = {};
/** @const */
StripeNode.recipients = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.recipients.IRecipient = function() {};
/** @const */
StripeNode.skus = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.skus.ISku = function() {};
 /** @type {string} */
StripeNode.skus.ISku.prototype.object;
 /** @type {boolean} */
StripeNode.skus.ISku.prototype.active;
 /** @type {!StripeNode.skus.ISkuAttributes} */
StripeNode.skus.ISku.prototype.attributes;
 /** @type {number} */
StripeNode.skus.ISku.prototype.created;
 /** @type {string} */
StripeNode.skus.ISku.prototype.currency;
 /** @type {string} */
StripeNode.skus.ISku.prototype.image;
 /** @type {!StripeNode.skus.IInventory} */
StripeNode.skus.ISku.prototype.inventory;
 /** @type {boolean} */
StripeNode.skus.ISku.prototype.livemode;
 /** @type {!StripeNode.IMetadata} */
StripeNode.skus.ISku.prototype.metadata;
 /** @type {!StripeNode.products.IPackageDimensions} */
StripeNode.skus.ISku.prototype.package_dimensions;
 /** @type {number} */
StripeNode.skus.ISku.prototype.price;
 /** @type {(string|!StripeNode.products.IProduct)} */
StripeNode.skus.ISku.prototype.product;
 /** @type {number} */
StripeNode.skus.ISku.prototype.updated;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.skus.ISkuCreationOptions = function() {};
 /** @type {string} */
StripeNode.skus.ISkuCreationOptions.prototype.id;
 /** @type {string} */
StripeNode.skus.ISkuCreationOptions.prototype.currency;
 /** @type {!StripeNode.skus.IInventory} */
StripeNode.skus.ISkuCreationOptions.prototype.inventory;
 /** @type {number} */
StripeNode.skus.ISkuCreationOptions.prototype.price;
 /** @type {string} */
StripeNode.skus.ISkuCreationOptions.prototype.product;
 /** @type {boolean} */
StripeNode.skus.ISkuCreationOptions.prototype.active;
 /** @type {!StripeNode.skus.ISkuAttributes} */
StripeNode.skus.ISkuCreationOptions.prototype.attributes;
 /** @type {string} */
StripeNode.skus.ISkuCreationOptions.prototype.image;
 /** @type {!StripeNode.products.IPackageDimensions} */
StripeNode.skus.ISkuCreationOptions.prototype.package_dimensions;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.skus.ISkuUpdateOptions = function() {};
 /** @type {boolean} */
StripeNode.skus.ISkuUpdateOptions.prototype.active;
 /** @type {string} */
StripeNode.skus.ISkuUpdateOptions.prototype.currency;
 /** @type {string} */
StripeNode.skus.ISkuUpdateOptions.prototype.image;
 /** @type {!StripeNode.skus.IInventory} */
StripeNode.skus.ISkuUpdateOptions.prototype.inventory;
 /** @type {!StripeNode.products.IPackageDimensions} */
StripeNode.skus.ISkuUpdateOptions.prototype.package_dimensions;
 /** @type {number} */
StripeNode.skus.ISkuUpdateOptions.prototype.price;
 /** @type {string} */
StripeNode.skus.ISkuUpdateOptions.prototype.product;
/**
 * @extends {StripeNode.IListOptions}
 * @record
 * @struct
 */
StripeNode.skus.ISkuListOptions = function() {};
 /** @type {boolean} */
StripeNode.skus.ISkuListOptions.prototype.active;
 /** @type {!StripeNode.skus.ISkuAttributes} */
StripeNode.skus.ISkuListOptions.prototype.attributes;
 /** @type {!Array<string>} */
StripeNode.skus.ISkuListOptions.prototype.ids;
 /** @type {boolean} */
StripeNode.skus.ISkuListOptions.prototype.in_stock;
 /** @type {string} */
StripeNode.skus.ISkuListOptions.prototype.product;
/**
 * @record
 * @struct
 */
StripeNode.skus.IInventory = function() {};
 /** @type {number} */
StripeNode.skus.IInventory.prototype.quantity;
 /** @type {string} */
StripeNode.skus.IInventory.prototype.type;
 /** @type {string} */
StripeNode.skus.IInventory.prototype.value;
/**
 * @record
 * @struct
 */
StripeNode.skus.ISkuAttributes = function() {};
/** @const */
StripeNode.tokens = {};
/**
 * @extends {StripeNode.tokens.ICardToken}
 * @extends {StripeNode.tokens.IBankAccountToken}
 * @record
 * @struct
 */
StripeNode.tokens.IToken = function() {};
/**
 * @extends {StripeNode.tokens.ITokenBase}
 * @record
 * @struct
 */
StripeNode.tokens.ICardToken = function() {};
 /** @type {!StripeNode.cards.ICardHash} */
StripeNode.tokens.ICardToken.prototype.card;
/**
 * @extends {StripeNode.tokens.ITokenBase}
 * @record
 * @struct
 */
StripeNode.tokens.IBankAccountToken = function() {};
 /** @type {!StripeNode.bankAccounts.IBankAccountHash} */
StripeNode.tokens.IBankAccountToken.prototype.bank_account;
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.tokens.ITokenBase = function() {};
 /** @type {string} */
StripeNode.tokens.ITokenBase.prototype.object;
 /** @type {string} */
StripeNode.tokens.ITokenBase.prototype.client_ip;
 /** @type {number} */
StripeNode.tokens.ITokenBase.prototype.created;
 /** @type {boolean} */
StripeNode.tokens.ITokenBase.prototype.livemode;
 /** @type {string} */
StripeNode.tokens.ITokenBase.prototype.type;
 /** @type {boolean} */
StripeNode.tokens.ITokenBase.prototype.used;
/**
 * @extends {StripeNode.IDataOptions}
 * @record
 * @struct
 */
StripeNode.tokens.ITokenCreationOptionsBase = function() {};
 /** @type {string} */
StripeNode.tokens.ITokenCreationOptionsBase.prototype.customer;
/**
 * @extends {StripeNode.tokens.ITokenCreationOptionsBase}
 * @record
 * @struct
 */
StripeNode.tokens.ICardTokenCreationOptions = function() {};
 /** @type {(string|!StripeNode.cards.ISourceCreationOptions)} */
StripeNode.tokens.ICardTokenCreationOptions.prototype.card;
/**
 * @extends {StripeNode.tokens.ITokenCreationOptionsBase}
 * @record
 * @struct
 */
StripeNode.tokens.IBankAccountTokenCreationOptions = function() {};
 /** @type {!StripeNode.bankAccounts.ISourceCreationOptions} */
StripeNode.tokens.IBankAccountTokenCreationOptions.prototype.bank_account;
/**
 * @extends {StripeNode.IDataOptions}
 * @record
 * @struct
 */
StripeNode.tokens.IPiiTokenCreationOptions = function() {};
 /** @type {{personal_id_number: string}} */
StripeNode.tokens.IPiiTokenCreationOptions.prototype.pii;
/** @const */
StripeNode.transfers = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.transfers.ITransfer = function() {};
 /** @type {string} */
StripeNode.transfers.ITransfer.prototype.object;
 /** @type {number} */
StripeNode.transfers.ITransfer.prototype.amount;
 /** @type {number} */
StripeNode.transfers.ITransfer.prototype.amount_reversed;
 /** @type {string} */
StripeNode.transfers.ITransfer.prototype.application_fee;
 /** @type {(string|!StripeNode.balance.IBalanceTransaction)} */
StripeNode.transfers.ITransfer.prototype.balance_transaction;
 /** @type {number} */
StripeNode.transfers.ITransfer.prototype.created;
 /** @type {string} */
StripeNode.transfers.ITransfer.prototype.currency;
 /** @type {number} */
StripeNode.transfers.ITransfer.prototype.date;
 /** @type {string} */
StripeNode.transfers.ITransfer.prototype.description;
 /** @type {(string|!StripeNode.bankAccounts.IBankAccount|!StripeNode.cards.ICardHash|!StripeNode.accounts.IAccount)} */
StripeNode.transfers.ITransfer.prototype.destination;
 /** @type {string} */
StripeNode.transfers.ITransfer.prototype.destination_payment;
 /** @type {string} */
StripeNode.transfers.ITransfer.prototype.failure_code;
 /** @type {string} */
StripeNode.transfers.ITransfer.prototype.failure_message;
 /** @type {boolean} */
StripeNode.transfers.ITransfer.prototype.livemode;
 /** @type {!StripeNode.IMetadata} */
StripeNode.transfers.ITransfer.prototype.metadata;
 /** @type {!StripeNode.transfers.ITransferReversals} */
StripeNode.transfers.ITransfer.prototype.reversals;
 /** @type {boolean} */
StripeNode.transfers.ITransfer.prototype.reversed;
 /** @type {(string|!StripeNode.charges.ICharge)} */
StripeNode.transfers.ITransfer.prototype.source_transaction;
 /** @type {string} */
StripeNode.transfers.ITransfer.prototype.source_type;
 /** @type {string} */
StripeNode.transfers.ITransfer.prototype.statement_descriptor;
 /** @type {string} */
StripeNode.transfers.ITransfer.prototype.status;
 /** @type {string} */
StripeNode.transfers.ITransfer.prototype.type;
/**
 * @extends {StripeNode.IList}
 * @record
 * @struct
 */
StripeNode.transfers.ITransferReversals = function() {};
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.transfers.ITransferCreationOptions = function() {};
 /** @type {number} */
StripeNode.transfers.ITransferCreationOptions.prototype.amount;
 /** @type {string} */
StripeNode.transfers.ITransferCreationOptions.prototype.currency;
 /** @type {string} */
StripeNode.transfers.ITransferCreationOptions.prototype.destination;
 /** @type {string} */
StripeNode.transfers.ITransferCreationOptions.prototype.description;
 /** @type {string} */
StripeNode.transfers.ITransferCreationOptions.prototype.source_transaction;
 /** @type {string} */
StripeNode.transfers.ITransferCreationOptions.prototype.statement_descriptor;
 /** @type {string} */
StripeNode.transfers.ITransferCreationOptions.prototype.source_type;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.transfers.ITransferUpdateOptions = function() {};
 /** @type {string} */
StripeNode.transfers.ITransferUpdateOptions.prototype.description;
/**
 * @extends {StripeNode.IListOptionsCreated}
 * @record
 * @struct
 */
StripeNode.transfers.ITransferListOptions = function() {};
 /** @type {(string|{gt: string, gte: string, lt: string, lte: string})} */
StripeNode.transfers.ITransferListOptions.prototype.date;
 /** @type {string} */
StripeNode.transfers.ITransferListOptions.prototype.destination;
 /** @type {string} */
StripeNode.transfers.ITransferListOptions.prototype.recipient;
 /** @type {string} */
StripeNode.transfers.ITransferListOptions.prototype.status;

/** @typedef {string} */
StripeNode.transfers.SourceTypes;

/** @typedef {string} */
StripeNode.transfers.Statuses;
/** @const */
StripeNode.transferReversals = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.transferReversals.IReversal = function() {};
 /** @type {string} */
StripeNode.transferReversals.IReversal.prototype.object;
 /** @type {number} */
StripeNode.transferReversals.IReversal.prototype.amount;
 /** @type {(string|!StripeNode.balance.IBalanceTransaction)} */
StripeNode.transferReversals.IReversal.prototype.balance_transaction;
 /** @type {number} */
StripeNode.transferReversals.IReversal.prototype.created;
 /** @type {string} */
StripeNode.transferReversals.IReversal.prototype.currency;
 /** @type {!StripeNode.IMetadata} */
StripeNode.transferReversals.IReversal.prototype.metadata;
 /** @type {(string|!StripeNode.transfers.ITransfer)} */
StripeNode.transferReversals.IReversal.prototype.transfer;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.transferReversals.IReversalCreationOptions = function() {};
 /** @type {number} */
StripeNode.transferReversals.IReversalCreationOptions.prototype.amount;
 /** @type {string} */
StripeNode.transferReversals.IReversalCreationOptions.prototype.description;
 /** @type {boolean} */
StripeNode.transferReversals.IReversalCreationOptions.prototype.refund_application_fee;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.transferReversals.IReversalUpdateOptions = function() {};
 /** @type {string} */
StripeNode.transferReversals.IReversalUpdateOptions.prototype.description;
/** @const */
StripeNode.bankAccounts = {};
/**
 * @extends {StripeNode.bankAccounts.IBankAccountHash}
 * @record
 * @struct
 */
StripeNode.bankAccounts.IBankAccount = function() {};
 /** @type {string} */
StripeNode.bankAccounts.IBankAccount.prototype.account;
 /** @type {boolean} */
StripeNode.bankAccounts.IBankAccount.prototype.default_for_currency;
 /** @type {!StripeNode.IMetadata} */
StripeNode.bankAccounts.IBankAccount.prototype.metadata;
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.bankAccounts.IBankAccountHash = function() {};
 /** @type {string} */
StripeNode.bankAccounts.IBankAccountHash.prototype.object;
 /** @type {string} */
StripeNode.bankAccounts.IBankAccountHash.prototype.account_holder_name;
 /** @type {string} */
StripeNode.bankAccounts.IBankAccountHash.prototype.account_holder_type;
 /** @type {string} */
StripeNode.bankAccounts.IBankAccountHash.prototype.bank_name;
 /** @type {string} */
StripeNode.bankAccounts.IBankAccountHash.prototype.country;
 /** @type {string} */
StripeNode.bankAccounts.IBankAccountHash.prototype.currency;
 /** @type {string} */
StripeNode.bankAccounts.IBankAccountHash.prototype.fingerprint;
 /** @type {string} */
StripeNode.bankAccounts.IBankAccountHash.prototype.last4;
 /** @type {string} */
StripeNode.bankAccounts.IBankAccountHash.prototype.routing_number;
 /** @type {string} */
StripeNode.bankAccounts.IBankAccountHash.prototype.status;
/**
 * @record
 * @struct
 */
StripeNode.bankAccounts.ISourceCreationOptions = function() {};
 /** @type {string} */
StripeNode.bankAccounts.ISourceCreationOptions.prototype.account_number;
 /** @type {string} */
StripeNode.bankAccounts.ISourceCreationOptions.prototype.country;
 /** @type {string} */
StripeNode.bankAccounts.ISourceCreationOptions.prototype.currency;
 /** @type {string} */
StripeNode.bankAccounts.ISourceCreationOptions.prototype.routing_number;
 /** @type {string} */
StripeNode.bankAccounts.ISourceCreationOptions.prototype.account_holder_name;
 /** @type {string} */
StripeNode.bankAccounts.ISourceCreationOptions.prototype.account_holder_type;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.bankAccounts.IBankAccountUpdateOptions = function() {};
 /** @type {string} */
StripeNode.bankAccounts.IBankAccountUpdateOptions.prototype.account_holder_name;
 /** @type {string} */
StripeNode.bankAccounts.IBankAccountUpdateOptions.prototype.account_holder_type;
/** @const */
StripeNode.bitcoinReceivers = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.bitcoinReceivers.IBitcoinReceiver = function() {};
 /** @type {string} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.object;
 /** @type {boolean} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.active;
 /** @type {number} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.amount;
 /** @type {number} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.amount_received;
 /** @type {number} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.bitcoin_amount;
 /** @type {number} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.bitcoin_amount_received;
 /** @type {number} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.bitcoin_uri;
 /** @type {number} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.created;
 /** @type {string} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.currency;
 /** @type {string} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.customer;
 /** @type {string} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.description;
 /** @type {string} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.email;
 /** @type {boolean} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.filled;
 /** @type {string} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.inbound_address;
 /** @type {boolean} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.livemode;
 /** @type {!StripeNode.IMetadata} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.metadata;
 /** @type {string} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.payment;
 /** @type {string} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.refund_address;
 /** @type {!StripeNode.IList<!StripeNode.bitcoinReceivers.IBitcoinTransaction>} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.transactions;
 /** @type {boolean} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.uncaptured_funds;
 /** @type {boolean} */
StripeNode.bitcoinReceivers.IBitcoinReceiver.prototype.used_for_payment;
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.bitcoinReceivers.IBitcoinTransaction = function() {};
 /** @type {string} */
StripeNode.bitcoinReceivers.IBitcoinTransaction.prototype.object;
 /** @type {number} */
StripeNode.bitcoinReceivers.IBitcoinTransaction.prototype.amount;
 /** @type {number} */
StripeNode.bitcoinReceivers.IBitcoinTransaction.prototype.bitcoin_amount;
 /** @type {number} */
StripeNode.bitcoinReceivers.IBitcoinTransaction.prototype.created;
 /** @type {string} */
StripeNode.bitcoinReceivers.IBitcoinTransaction.prototype.currency;
 /** @type {string} */
StripeNode.bitcoinReceivers.IBitcoinTransaction.prototype.receiver;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.bitcoinReceivers.IBitcoinReceiverCreationOptions = function() {};
 /** @type {number} */
StripeNode.bitcoinReceivers.IBitcoinReceiverCreationOptions.prototype.amount;
 /** @type {string} */
StripeNode.bitcoinReceivers.IBitcoinReceiverCreationOptions.prototype.currency;
 /** @type {string} */
StripeNode.bitcoinReceivers.IBitcoinReceiverCreationOptions.prototype.email;
 /** @type {string} */
StripeNode.bitcoinReceivers.IBitcoinReceiverCreationOptions.prototype.description;
 /** @type {boolean} */
StripeNode.bitcoinReceivers.IBitcoinReceiverCreationOptions.prototype.refund_mispayments;
/**
 * @extends {StripeNode.IListOptions}
 * @record
 * @struct
 */
StripeNode.bitcoinReceivers.IBitcoinReceiverListOptions = function() {};
 /** @type {boolean} */
StripeNode.bitcoinReceivers.IBitcoinReceiverListOptions.prototype.active;
 /** @type {boolean} */
StripeNode.bitcoinReceivers.IBitcoinReceiverListOptions.prototype.filled;
 /** @type {boolean} */
StripeNode.bitcoinReceivers.IBitcoinReceiverListOptions.prototype.uncaptured_funds;
/** @const */
StripeNode.cards = {};
/**
 * @extends {StripeNode.cards.ICardHash}
 * @record
 * @struct
 */
StripeNode.cards.ICard = function() {};
 /** @type {(string|!StripeNode.accounts.IAccount)} */
StripeNode.cards.ICard.prototype.account;
 /** @type {string} */
StripeNode.cards.ICard.prototype.currency;
 /** @type {!StripeNode.customers.ICustomer} */
StripeNode.cards.ICard.prototype.customer;
 /** @type {boolean} */
StripeNode.cards.ICard.prototype.default_for_currency;
 /** @type {(string|!StripeNode.recipients.IRecipient)} */
StripeNode.cards.ICard.prototype.recipient;
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.cards.ICardHash = function() {};
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.id;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.object;
 /** @type {number} */
StripeNode.cards.ICardHash.prototype.number;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.brand;
 /** @type {number} */
StripeNode.cards.ICardHash.prototype.exp_month;
 /** @type {number} */
StripeNode.cards.ICardHash.prototype.exp_year;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.funding;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.last4;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.address_city;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.address_country;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.address_line1;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.address_line1_check;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.address_line2;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.address_state;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.address_zip;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.address_zip_check;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.country;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.cvc_check;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.dynamic_last4;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.name;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.fingerprint;
 /** @type {!StripeNode.IMetadata} */
StripeNode.cards.ICardHash.prototype.metadata;
 /** @type {string} */
StripeNode.cards.ICardHash.prototype.tokenization_method;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.cards.ICardUpdateOptions = function() {};
 /** @type {string} */
StripeNode.cards.ICardUpdateOptions.prototype.address_city;
 /** @type {string} */
StripeNode.cards.ICardUpdateOptions.prototype.address_country;
 /** @type {string} */
StripeNode.cards.ICardUpdateOptions.prototype.address_line1;
 /** @type {string} */
StripeNode.cards.ICardUpdateOptions.prototype.address_line2;
 /** @type {string} */
StripeNode.cards.ICardUpdateOptions.prototype.address_state;
 /** @type {string} */
StripeNode.cards.ICardUpdateOptions.prototype.address_zip;
 /** @type {boolean} */
StripeNode.cards.ICardUpdateOptions.prototype.default_for_currency;
 /** @type {number} */
StripeNode.cards.ICardUpdateOptions.prototype.exp_month;
 /** @type {number} */
StripeNode.cards.ICardUpdateOptions.prototype.exp_year;
 /** @type {string} */
StripeNode.cards.ICardUpdateOptions.prototype.name;
/**
 * @record
 * @struct
 */
StripeNode.cards.ISourceCreationOptions = function() {};
 /** @type {string} */
StripeNode.cards.ISourceCreationOptions.prototype.object;
 /** @type {number} */
StripeNode.cards.ISourceCreationOptions.prototype.exp_month;
 /** @type {number} */
StripeNode.cards.ISourceCreationOptions.prototype.exp_year;
 /** @type {number} */
StripeNode.cards.ISourceCreationOptions.prototype.number;
 /** @type {string} */
StripeNode.cards.ISourceCreationOptions.prototype.cvc;
 /** @type {string} */
StripeNode.cards.ISourceCreationOptions.prototype.name;
 /** @type {string} */
StripeNode.cards.ISourceCreationOptions.prototype.address_city;
 /** @type {string} */
StripeNode.cards.ISourceCreationOptions.prototype.address_country;
 /** @type {string} */
StripeNode.cards.ISourceCreationOptions.prototype.address_line1;
 /** @type {string} */
StripeNode.cards.ISourceCreationOptions.prototype.address_line2;
 /** @type {string} */
StripeNode.cards.ISourceCreationOptions.prototype.address_state;
 /** @type {string} */
StripeNode.cards.ISourceCreationOptions.prototype.address_zip;
 /** @type {!StripeNode.IMetadata} */
StripeNode.cards.ISourceCreationOptions.prototype.metadata;
/**
 * @extends {StripeNode.cards.ISourceCreationOptions}
 * @record
 * @struct
 */
StripeNode.cards.ISourceCreationOptionsExtended = function() {};
 /** @type {string} */
StripeNode.cards.ISourceCreationOptionsExtended.prototype.currency;
 /** @type {boolean} */
StripeNode.cards.ISourceCreationOptionsExtended.prototype.default_for_currency;
/** @const */
StripeNode.subscriptions = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.subscriptions.ISubscription = function() {};
 /** @type {string} */
StripeNode.subscriptions.ISubscription.prototype.object;
 /** @type {number} */
StripeNode.subscriptions.ISubscription.prototype.application_fee_percent;
 /** @type {boolean} */
StripeNode.subscriptions.ISubscription.prototype.cancel_at_period_end;
 /** @type {number} */
StripeNode.subscriptions.ISubscription.prototype.canceled_at;
 /** @type {number} */
StripeNode.subscriptions.ISubscription.prototype.created;
 /** @type {number} */
StripeNode.subscriptions.ISubscription.prototype.current_period_end;
 /** @type {number} */
StripeNode.subscriptions.ISubscription.prototype.current_period_start;
 /** @type {string} */
StripeNode.subscriptions.ISubscription.prototype.customer;
 /** @type {!StripeNode.coupons.IDiscount} */
StripeNode.subscriptions.ISubscription.prototype.discount;
 /** @type {number} */
StripeNode.subscriptions.ISubscription.prototype.ended_at;
 /** @type {!StripeNode.IMetadata} */
StripeNode.subscriptions.ISubscription.prototype.metadata;
 /** @type {!StripeNode.plans.IPlan} */
StripeNode.subscriptions.ISubscription.prototype.plan;
 /** @type {number} */
StripeNode.subscriptions.ISubscription.prototype.quantity;
 /** @type {number} */
StripeNode.subscriptions.ISubscription.prototype.start;
 /** @type {string} */
StripeNode.subscriptions.ISubscription.prototype.status;
 /** @type {number} */
StripeNode.subscriptions.ISubscription.prototype.tax_percent;
 /** @type {number} */
StripeNode.subscriptions.ISubscription.prototype.trial_end;
 /** @type {number} */
StripeNode.subscriptions.ISubscription.prototype.trial_start;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.subscriptions.ISubscriptionCustCreationOptions = function() {};
 /** @type {string} */
StripeNode.subscriptions.ISubscriptionCustCreationOptions.prototype.plan;
 /** @type {number} */
StripeNode.subscriptions.ISubscriptionCustCreationOptions.prototype.application_fee_percent;
 /** @type {string} */
StripeNode.subscriptions.ISubscriptionCustCreationOptions.prototype.coupon;
 /** @type {(string|!StripeNode.cards.ISourceCreationOptions)} */
StripeNode.subscriptions.ISubscriptionCustCreationOptions.prototype.source;
 /** @type {number} */
StripeNode.subscriptions.ISubscriptionCustCreationOptions.prototype.quantity;
 /** @type {number} */
StripeNode.subscriptions.ISubscriptionCustCreationOptions.prototype.tax_percent;
 /** @type {number} */
StripeNode.subscriptions.ISubscriptionCustCreationOptions.prototype.trial_end;
/**
 * @extends {StripeNode.subscriptions.ISubscriptionCustCreationOptions}
 * @record
 * @struct
 */
StripeNode.subscriptions.ISubscriptionCreationOptions = function() {};
 /** @type {string} */
StripeNode.subscriptions.ISubscriptionCreationOptions.prototype.customer;
/**
 * @extends {StripeNode.IDataOptionsWithMetadata}
 * @record
 * @struct
 */
StripeNode.subscriptions.ISubscriptionUpdateOptions = function() {};
 /** @type {number} */
StripeNode.subscriptions.ISubscriptionUpdateOptions.prototype.application_fee_percent;
 /** @type {string} */
StripeNode.subscriptions.ISubscriptionUpdateOptions.prototype.coupon;
 /** @type {string} */
StripeNode.subscriptions.ISubscriptionUpdateOptions.prototype.plan;
 /** @type {boolean} */
StripeNode.subscriptions.ISubscriptionUpdateOptions.prototype.prorate;
 /** @type {number} */
StripeNode.subscriptions.ISubscriptionUpdateOptions.prototype.proration_date;
 /** @type {number} */
StripeNode.subscriptions.ISubscriptionUpdateOptions.prototype.quantity;
 /** @type {(string|!StripeNode.cards.ISourceCreationOptions)} */
StripeNode.subscriptions.ISubscriptionUpdateOptions.prototype.source;
 /** @type {number} */
StripeNode.subscriptions.ISubscriptionUpdateOptions.prototype.tax_percent;
 /** @type {number} */
StripeNode.subscriptions.ISubscriptionUpdateOptions.prototype.trial_end;
/**
 * @extends {StripeNode.IDataOptions}
 * @record
 * @struct
 */
StripeNode.subscriptions.ISubscriptionCancellationOptions = function() {};
 /** @type {boolean} */
StripeNode.subscriptions.ISubscriptionCancellationOptions.prototype.at_period_end;
/**
 * @extends {StripeNode.IListOptionsCreated}
 * @record
 * @struct
 */
StripeNode.subscriptions.ISubscriptionListOptions = function() {};
 /** @type {string} */
StripeNode.subscriptions.ISubscriptionListOptions.prototype.customer;
 /** @type {string} */
StripeNode.subscriptions.ISubscriptionListOptions.prototype.plan;
/** @const */
StripeNode.refunds = {};
/**
 * @record
 * @struct
 */
StripeNode.refunds.IRefund = function() {};
 /** @type {string} */
StripeNode.refunds.IRefund.prototype.id;
 /** @type {string} */
StripeNode.refunds.IRefund.prototype.object;
 /** @type {number} */
StripeNode.refunds.IRefund.prototype.amount;
 /** @type {string} */
StripeNode.refunds.IRefund.prototype.balance_transaction;
 /** @type {(string|!StripeNode.charges.ICharge)} */
StripeNode.refunds.IRefund.prototype.charge;
 /** @type {number} */
StripeNode.refunds.IRefund.prototype.created;
 /** @type {string} */
StripeNode.refunds.IRefund.prototype.currency;
 /** @type {string} */
StripeNode.refunds.IRefund.prototype.description;
 /** @type {!StripeNode.IMetadata} */
StripeNode.refunds.IRefund.prototype.metadata;
 /** @type {string} */
StripeNode.refunds.IRefund.prototype.reason;
 /** @type {string} */
StripeNode.refunds.IRefund.prototype.receipt_number;
/**
 * @extends {StripeNode.IDataOptions}
 * @record
 * @struct
 */
StripeNode.refunds.IRefundCreationOptions = function() {};
 /** @type {number} */
StripeNode.refunds.IRefundCreationOptions.prototype.amount;
 /** @type {!StripeNode.IMetadata} */
StripeNode.refunds.IRefundCreationOptions.prototype.metadata;
 /** @type {string} */
StripeNode.refunds.IRefundCreationOptions.prototype.reason;
 /** @type {boolean} */
StripeNode.refunds.IRefundCreationOptions.prototype.refund_application_fee;
 /** @type {boolean} */
StripeNode.refunds.IRefundCreationOptions.prototype.reverse_transfer;
/**
 * @extends {StripeNode.refunds.IRefundCreationOptions}
 * @record
 * @struct
 */
StripeNode.refunds.IRefundCreationOptionsWithCharge = function() {};
 /** @type {string} */
StripeNode.refunds.IRefundCreationOptionsWithCharge.prototype.charge;
/**
 * @extends {StripeNode.IListOptions}
 * @record
 * @struct
 */
StripeNode.refunds.IRefundListOptions = function() {};
 /** @type {string} */
StripeNode.refunds.IRefundListOptions.prototype.charge;
/** @const */
StripeNode.sources = {};

/** @typedef {(string|!StripeNode.cards.ISourceCreationOptions)} */
StripeNode.sources.ISourceCreationOptions;

/** @typedef {(string|!StripeNode.cards.ISourceCreationOptionsExtended)} */
StripeNode.sources.ISourceCreationOptionsExtended;
/** @const */
StripeNode.countrySpecs = {};
/**
 * @extends {StripeNode.IResourceObject}
 * @record
 * @struct
 */
StripeNode.countrySpecs.ICountrySpec = function() {};
 /** @type {string} */
StripeNode.countrySpecs.ICountrySpec.prototype.object;
 /** @type {string} */
StripeNode.countrySpecs.ICountrySpec.prototype.default_currency;
 /** @type {!Object} */
StripeNode.countrySpecs.ICountrySpec.prototype.supported_bank_account_currencies;
 /** @type {!Array<string>} */
StripeNode.countrySpecs.ICountrySpec.prototype.supported_payment_currencies;
 /** @type {!Array<string>} */
StripeNode.countrySpecs.ICountrySpec.prototype.supported_payment_methods;
 /** @type {{individual: {minimum: !Array<string>, additional: !Array<string>}, company: {minimum: !Array<string>, additional: !Array<string>}}} */
StripeNode.countrySpecs.ICountrySpec.prototype.verification_fields;

/**
 * @constructor
 * @struct
 * @param {!StripeNode.Stripe} stripe
 * @param {?} urlData
 */
StripeNode.StripeResource = function(stripe, urlData) {};
/** @const */
StripeNode.resources = {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.Accounts = function() {};

/**
 * With Connect, you can create Stripe accounts for your users. To do this, you'll first need to register your platform.
 * @param {!StripeNode.accounts.IAccountCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.accounts.IAccount>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.accounts.IAccount>=} response
 * @return {!Promise<!StripeNode.accounts.IAccount>}
 */
StripeNode.resources.Accounts.prototype.create = function(data, options_or_response, response) {};

/**
 * Retrieves the details of the account.
 * @param {string|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.accounts.IAccount>=} id_or_options_or_response
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.accounts.IAccount>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.accounts.IAccount>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.accounts.IAccount>=} response
 * @return {!Promise<!StripeNode.accounts.IAccount>}
 */
StripeNode.resources.Accounts.prototype.retrieve = function(id_or_options_or_response, data_or_options_or_response, options_or_response, response) {};

/**
 * Updates an account by setting the values of the parameters passed. Any parameters not provided will be left unchanged.
 * 
 * You may only update accounts that you manage. To update your own account, you can currently only do so via the dashboard.
 * For more information on updating managed accounts, see our guide.
 * @param {string} id
 * @param {!StripeNode.accounts.IAccountUpdateOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.accounts.IAccount>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.accounts.IAccount>=} response
 * @return {!Promise<!StripeNode.accounts.IAccount>}
 */
StripeNode.resources.Accounts.prototype.update = function(id, data, options_or_response, response) {};

/**
 * With Connect, you may delete Stripe accounts you manage.
 * 
 * Managed accounts created using test-mode keys can be deleted at any time. Managed accounts created using live-mode keys may only be
 * deleted once all balances are zero.
 * 
 * If you are looking to close your own account, use the data tab in your account settings instead.
 * @param {string|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} id_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} response
 * @return {!Promise<!StripeNode.IDeleteConfirmation>}
 */
StripeNode.resources.Accounts.prototype.del = function(id_or_options_or_response, options_or_response, response) {};

/**
 * With Connect, you may flag managed accounts as suspicious.
 * 
 * Managed accounts created using test-mode keys can be rejected at any time. Managed accounts created using live-mode keys may only be
 * rejected once all balances are zero.
 * @param {string} id
 * @param {!StripeNode.accounts.IRejectReason} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.accounts.IAccount>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.accounts.IAccount>=} response
 * @return {!Promise<!StripeNode.accounts.IAccount>}
 */
StripeNode.resources.Accounts.prototype.reject = function(id, data, options_or_response, response) {};

/**
 * Returns a list of accounts connected to your platform via Connect. If youre not a platform, the list will be empty.
 * @param {!StripeNode.IListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.accounts.IAccount>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.accounts.IAccount>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.accounts.IAccount>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.accounts.IAccount>>}
 */
StripeNode.resources.Accounts.prototype.list = function(data_or_options_or_response, options_or_response, response) {};

/**
 * When you create a new bank account or credit card, you must specify a managed account to create it on.
 * 
 * If the bank account's owner has no other external account in the bank account's currency, the new bank account will become the
 * default for that currency. However, if the owner already has a bank account for that currency, the new account will only become
 * the default if the default_for_currency parameter is set to true.
 * 
 * If the account has no default destination card, then the new card will become the default. However, if the owner already has a
 * default then it will not change. To change the default, you should set default_for_currency to true when creating a card for a
 * managed account.
 * @param {string} accId
 * @param {!StripeNode.accounts.IExternalAccountCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<(!StripeNode.bankAccounts.IBankAccount|!StripeNode.cards.ICard)>=} options_or_response
 * @param {!StripeNode.IResponseFn<(!StripeNode.bankAccounts.IBankAccount|!StripeNode.cards.ICard)>=} response
 * @return {!Promise<(!StripeNode.bankAccounts.IBankAccount|!StripeNode.cards.ICard)>}
 */
StripeNode.resources.Accounts.prototype.createExternalAccount = function(accId, data, options_or_response, response) {};

/**
 * By default, you can see the 10 most recent bank accounts stored on a managed account directly on the object, but you can also
 * retrieve details about a specific bank account stored on the Stripe account.
 * @param {string} accId
 * @param {string} bankAccId
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.bankAccounts.IBankAccount>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.bankAccounts.IBankAccount>=} response
 * @return {!Promise<!StripeNode.bankAccounts.IBankAccount>}
 */
StripeNode.resources.Accounts.prototype.retrieveExternalAccount = function(accId, bankAccId, options_or_response, response) {};

/**
 * You can always see the 10 most recent cards directly on a managed account; this method lets you retrieve details about a specific
 * card stored on the account.
 * @param {string} accId
 * @param {string} cardId
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} response
 * @return {!Promise<!StripeNode.cards.ICard>}
 */
StripeNode.resources.Accounts.prototype.retrieveCard = function(accId, cardId, options_or_response, response) {};

/**
 * Updates the metadata of a bank account belonging to a managed account, and optionally sets it as the default for its currency.
 * Other bank account details are not editable by design.
 * If you need to update only some card details, like the billing address or expiration date, you can do so without having to re-enter the
 * full card details. Stripe also works directly with card networks so that your customers can continue using your service without
 * interruption.
 * 
 * When you update a card, Stripe will automatically validate the card.
 * @param {string} accId
 * @param {string} bankAccId_or_cardId
 * @param {!StripeNode.accounts.IExternalAccountUpdateOptions|!StripeNode.cards.ICardUpdateOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.bankAccounts.IBankAccount>|!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.bankAccounts.IBankAccount>|!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} response
 * @return {!Promise<!StripeNode.bankAccounts.IBankAccount>|!Promise<!StripeNode.cards.ICard>}
 */
StripeNode.resources.Accounts.prototype.updateExternalAccount = function(accId, bankAccId_or_cardId, data, options_or_response, response) {};

/**
 * You can delete destination bank accounts and cards from a managed account. If a bank account is the default external account for its currency
 * or card's default_for_currency property is true, it can only be deleted if it is the only external account for that currency, and the
 * currency is not the Stripe account's default currency. Otherwise, you must set another external account to be the default for the currency
 * before deleting it.
 * @param {string} accId
 * @param {string} id
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<(!StripeNode.bankAccounts.IBankAccount|!StripeNode.cards.ICard)>=} options_or_response
 * @param {!StripeNode.IResponseFn<(!StripeNode.bankAccounts.IBankAccount|!StripeNode.cards.ICard)>=} response
 * @return {!Promise<(!StripeNode.bankAccounts.IBankAccount|!StripeNode.cards.ICard)>}
 */
StripeNode.resources.Accounts.prototype.deleteExternalAccount = function(accId, id, options_or_response, response) {};

/**
 * You can see a list of the bank accounts belonging to a managed account. Note that the 10 most recent external accounts are always
 * available by default on the corresponding Stripe object. If you need more than those 10, you can use this API method and the limit
 * and starting_after parameters to page through additional bank accounts.
 * You can see a list of the cards belonging to a managed account. Note that the 10 most recent external accounts are available on the
 * account object. If you need more than those 10, you can use this API method and the limit and starting_after parameters to page
 * through additional cards.
 * @param {string} accId
 * @param {!StripeNode.accounts.IBankAccountListOptions|!StripeNode.accounts.ICardListOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.bankAccounts.IBankAccount>>|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.cards.ICard>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.bankAccounts.IBankAccount>>|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.cards.ICard>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.bankAccounts.IBankAccount>>|!Promise<!StripeNode.IList<!StripeNode.cards.ICard>>}
 */
StripeNode.resources.Accounts.prototype.listExternalAccounts = function(accId, data, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.ApplicationFees = function() {};

/**
 * Retrieves the details of an application fee that your account has collected. The same information is returned when refunding the
 * application fee.
 * @param {string} id
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFee>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFee>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFee>=} response
 * @return {!Promise<!StripeNode.applicationFees.IApplicationFee>}
 */
StripeNode.resources.ApplicationFees.prototype.retrieve = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * Returns a list of application fees youve previously collected. The application fees are returned in sorted order, with the most
 * recent fees appearing first.
 * @param {!StripeNode.applicationFees.IApplicationFeeListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.applicationFees.IApplicationFee>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.applicationFees.IApplicationFee>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.applicationFees.IApplicationFee>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.applicationFees.IApplicationFee>>}
 */
StripeNode.resources.ApplicationFees.prototype.list = function(data_or_options_or_response, options_or_response, response) {};

/**
 * Refunds an application fee that has previously been collected but not yet refunded. Funds will be refunded to the Stripe account that
 * the fee was originally collected from.
 * 
 * You can optionally refund only part of an application fee. You can do so as many times as you wish until the entire fee has been refunded.
 * 
 * Once entirely refunded, an application fee can't be refunded again. This method will throw an error when called on an already-refunded
 * application fee, or when trying to refund more money than is left on an application fee.
 * @param {string} feeId
 * @param {!StripeNode.applicationFees.IApplicationFeeRefundCreationOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} response
 * @return {!Promise<!StripeNode.applicationFees.IApplicationFeeRefund>}
 */
StripeNode.resources.ApplicationFees.prototype.refund = function(feeId, data_or_options_or_response, options_or_response, response) {};

/**
 * Refunds an application fee that has previously been collected but not yet refunded. Funds will be refunded to the Stripe account that
 * the fee was originally collected from.
 * 
 * You can optionally refund only part of an application fee. You can do so as many times as you wish until the entire fee has been refunded.
 * 
 * Once entirely refunded, an application fee can't be refunded again. This method will throw an error when called on an already-refunded
 * application fee, or when trying to refund more money than is left on an application fee.
 * @param {string} feeId
 * @param {!StripeNode.applicationFees.IApplicationFeeRefundCreationOptions|!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>|(string|!StripeNode.IHeaderOptions)=} data_or_response_or_options
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} response
 * @return {!Promise<!StripeNode.applicationFees.IApplicationFeeRefund>}
 */
StripeNode.resources.ApplicationFees.prototype.createRefund = function(feeId, data_or_response_or_options, options_or_response, response) {};

/**
 * By default, you can see the 10 most recent refunds stored directly on the application fee object, but you can also retrieve details
 * about a specific refund stored on the application fee.
 * @param {string} feeId
 * @param {string} refundId
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} response
 * @return {!Promise<!StripeNode.applicationFees.IApplicationFeeRefund>}
 */
StripeNode.resources.ApplicationFees.prototype.retreiveRefund = function(feeId, refundId, options_or_response, response) {};

/**
 * Updates the specified application fee refund by setting the values of the parameters passed. Any parameters not provided will be left
 * unchanged.
 * 
 * This request only accepts metadata as an argument.
 * @param {string} feeId
 * @param {string} refundId
 * @param {{metadata: !StripeNode.IMetadata}} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} response
 * @return {!Promise<!StripeNode.applicationFees.IApplicationFeeRefund>}
 */
StripeNode.resources.ApplicationFees.prototype.updateRefund = function(feeId, refundId, data, options_or_response, response) {};

/**
 * You can see a list of the refunds belonging to a specific application fee. Note that the 10 most recent refunds are always available
 * by default on the application fee object. If you need more than those 10, you can use this API method and the limit and starting_after
 * parameters to page through additional refunds.
 * @param {string} feeId
 * @param {!StripeNode.IListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.applicationFees.IApplicationFeeRefund>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.applicationFees.IApplicationFeeRefund>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.applicationFees.IApplicationFeeRefund>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.applicationFees.IApplicationFeeRefund>>}
 */
StripeNode.resources.ApplicationFees.prototype.listRefunds = function(feeId, data_or_options_or_response, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.ApplicationFeeRefunds = function() {};

/**
 * Refunds an application fee that has previously been collected but not yet refunded. Funds will be refunded to the Stripe account that
 * the fee was originally collected from.
 * 
 * You can optionally refund only part of an application fee. You can do so as many times as you wish until the entire fee has been refunded.
 * 
 * Once entirely refunded, an application fee can't be refunded again. This method will throw an error when called on an already-refunded
 * application fee, or when trying to refund more money than is left on an application fee.
 * @param {!StripeNode.applicationFees.IApplicationFeeRefundCreationOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} response
 * @return {!Promise<!StripeNode.applicationFees.IApplicationFeeRefund>}
 */
StripeNode.resources.ApplicationFeeRefunds.prototype.create = function(data_or_options_or_response, options_or_response, response) {};

/**
 * By default, you can see the 10 most recent refunds stored directly on the application fee object, but you can also retrieve details
 * about a specific refund stored on the application fee.
 * @param {string} refundId
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} response
 * @return {!Promise<!StripeNode.applicationFees.IApplicationFeeRefund>}
 */
StripeNode.resources.ApplicationFeeRefunds.prototype.retrieve = function(refundId, data_or_options_or_response, options_or_response, response) {};

/**
 * Updates the specified application fee refund by setting the values of the parameters passed. Any parameters not provided will be left
 * unchanged.
 * 
 * This request only accepts metadata as an argument.
 * @param {string} refundId
 * @param {{metadata: !StripeNode.IMetadata}} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.applicationFees.IApplicationFeeRefund>=} response
 * @return {!Promise<!StripeNode.applicationFees.IApplicationFeeRefund>}
 */
StripeNode.resources.ApplicationFeeRefunds.prototype.update = function(refundId, data, options_or_response, response) {};

/**
 * You can see a list of the refunds belonging to a specific application fee. Note that the 10 most recent refunds are always available
 * by default on the application fee object. If you need more than those 10, you can use this API method and the limit and starting_after
 * parameters to page through additional refunds.
 * @param {!StripeNode.IListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.applicationFees.IApplicationFeeRefund>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.applicationFees.IApplicationFeeRefund>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.applicationFees.IApplicationFeeRefund>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.applicationFees.IApplicationFeeRefund>>}
 */
StripeNode.resources.ApplicationFeeRefunds.prototype.list = function(data_or_options_or_response, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.Balance = function() {};

/**
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.balance.IBalance>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.balance.IBalance>=} response
 * @return {!Promise<!StripeNode.balance.IBalance>}
 */
StripeNode.resources.Balance.prototype.retrieve = function(options_or_response, response) {};

/**
 * @param {string} id
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.balance.IBalanceTransaction>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.balance.IBalanceTransaction>=} response
 * @return {!Promise<!StripeNode.balance.IBalanceTransaction>}
 */
StripeNode.resources.Balance.prototype.retrieveTransaction = function(id, options_or_response, response) {};

/**
 * @param {!StripeNode.balance.IBalanceListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.balance.IBalanceTransaction>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.balance.IBalanceTransaction>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.balance.IBalanceTransaction>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.balance.IBalanceTransaction>>}
 */
StripeNode.resources.Balance.prototype.listTransactions = function(data_or_options_or_response, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.BitcoinReceivers = function() {};

/**
 * Creates a Bitcoin receiver object that can be used to accept bitcoin payments from your customer. The receiver exposes a Bitcoin address
 * and is created with a bitcoin to USD exchange rate that is valid for 10 minutes.
 * @param {!StripeNode.bitcoinReceivers.IBitcoinReceiverCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.bitcoinReceivers.IBitcoinReceiver>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.bitcoinReceivers.IBitcoinReceiver>=} response
 * @return {!Promise<!StripeNode.bitcoinReceivers.IBitcoinReceiver>}
 */
StripeNode.resources.BitcoinReceivers.prototype.create = function(data, options_or_response, response) {};

/**
 * Retrieves the Bitcoin receiver with the given ID.
 * @param {string} id
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.bitcoinReceivers.IBitcoinReceiver>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.bitcoinReceivers.IBitcoinReceiver>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.bitcoinReceivers.IBitcoinReceiver>=} response
 * @return {!Promise<!StripeNode.bitcoinReceivers.IBitcoinReceiver>}
 */
StripeNode.resources.BitcoinReceivers.prototype.retrieve = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * Returns a list of your receivers. Receivers are returned sorted by creation date, with the most recently created receivers appearing first.
 * @param {!StripeNode.bitcoinReceivers.IBitcoinReceiverListOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.bitcoinReceivers.IBitcoinReceiver>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.bitcoinReceivers.IBitcoinReceiver>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.bitcoinReceivers.IBitcoinReceiver>>}
 */
StripeNode.resources.BitcoinReceivers.prototype.list = function(data, options_or_response, response) {};

/**
 * @return {void}
 */
StripeNode.resources.BitcoinReceivers.prototype.setMetadata = function() {};

/**
 * @return {void}
 */
StripeNode.resources.BitcoinReceivers.prototype.getMetadata = function() {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.Charges = function() {};

/**
 * To charge a credit card, you create a charge object. If your API key is in test mode, the supplied card won't actually be charged, though
 * everything else will occur as if in live mode. (Stripe assumes that the charge would have completed successfully).
 * 
 * @param {!StripeNode.charges.IChargeCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.charges.ICharge>=} options_or_response Options for creating a charge.
 * @param {!StripeNode.IResponseFn<!StripeNode.charges.ICharge>=} response A callback to receive the response and newly created charge, or errors if they exist.
 * @return {!Promise<!StripeNode.charges.ICharge>} Returns a charge object if the charge succeeded. Throws an error if something goes wrong. A common source of error is an invalid or
 * expired card, or a valid card with insufficient available balance. If the cvc parameter is provided, Stripe will attempt to check the CVC's
 * correctness, and the check's result will be returned. Similarly, If address_line1 or address_zip are provided, Stripe will similarly try to
 * check the validity of those parameters. Some banks do not support checking one or more of these parameters, in which case Stripe will return
 * an 'unavailable' result. Also note that, depending on the bank, charges can succeed even when passed incorrect CVC and address information.
 * 
 */
StripeNode.resources.Charges.prototype.create = function(data, options_or_response, response) {};

/**
 * Retrieves the details of a charge that has previously been created. Supply the unique charge ID that was returned
 * from your previous request, and Stripe will return the corresponding charge information. The same information is
 * returned when creating or refunding the charge.
 * 
 * @param {string} id The identifier of the charge to be retrieved
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.charges.ICharge>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.charges.ICharge>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.charges.ICharge>=} response A callback that takes in a potential error and a charge object.
 * @return {!Promise<!StripeNode.charges.ICharge>}
 */
StripeNode.resources.Charges.prototype.retrieve = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * Updates the specified charge by setting the values of the parameters passed. Any parameters not provided will be left unchanged.
 * This request accepts only the description, metadata, receipt_emailand fraud_details as arguments.
 * 
 * @param {string} id The identifier of the charge to be updated
 * @param {!StripeNode.charges.IChargeUpdateOptions} data An object containing the updated properties.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.charges.ICharge>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.charges.ICharge>=} response
 * @return {!Promise<!StripeNode.charges.ICharge>}
 */
StripeNode.resources.Charges.prototype.update = function(id, data, options_or_response, response) {};

/**
 * Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first
 * you created a charge with the capture option set to false. Uncaptured payments expire exactly seven days after they are
 * created. If they are not captured by that point in time, they will be marked as refunded and will no longer be capturable.
 * @param {string} id
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.charges.ICharge>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.charges.ICharge>=} response
 * @return {!Promise<!StripeNode.charges.ICharge>}
 */
StripeNode.resources.Charges.prototype.capture = function(id, options_or_response, response) {};

/**
 * Returns a list of charges you've previously created. The charges are returned in sorted order, with the most recent charges
 * appearing first.
 * 
 * @param {!StripeNode.charges.IChargeListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.charges.ICharge>>=} data_or_options_or_response Filtering options for the returned items.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.charges.ICharge>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.charges.ICharge>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.charges.ICharge>>} An object with a data property that contains an array of up to limit charges, starting after charge starting_after.
 * Each entry in the array is a separate charge object. If no more charges are available, the resulting array will be empty.
 * If you provide a non-existent customer ID, this call throws an error. You can optionally request that the response include
 * the total count of all charges that match your filters. To do so, specify include[]=total_count in your request.
 * 
 */
StripeNode.resources.Charges.prototype.list = function(data_or_options_or_response, options_or_response, response) {};

/**
 * When you create a new refund, you must specify a charge to create it on.
 * Creating a new refund will refund a charge that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged. The fees you were originally charged are also refunded.
 * You can optionally refund only part of a charge. You can do so as many times as you wish until the entire charge has been refunded.
 * Once entirely refunded, a charge can't be refunded again. This method will throw an error when called on an already-refunded charge, or when trying to refund more money than is left on a charge.
 * @param {string} chargeId
 * @param {!StripeNode.refunds.IRefundCreationOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} response
 * @return {!Promise<!StripeNode.refunds.IRefund>}
 */
StripeNode.resources.Charges.prototype.refund = function(chargeId, data_or_options_or_response, options_or_response, response) {};

/**
 * When you create a new refund, you must specify a charge to create it on. Creating a new refund will refund a charge that has previously
 * been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged. The fees you were
 * originally charged are also refunded. You can optionally refund only part of a charge. You can do so as many times as you wish until
 * the entire charge has been refunded. Once entirely refunded, a charge can't be refunded again. This method will throw an error when
 * called on an already-refunded charge, or when trying to refund more money than is left on a charge.
 * 
 * @deprecated According to source code (https://github.com/stripe/stripe-node/blob/master/lib/resources/Charges.js#L43)
 * @param {string} id The identifier of the charge to be refunded.
 * @param {!StripeNode.refunds.IRefundCreationOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} data_or_options_or_response Options for specifying reasons and refund amount
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} response The refund.
 * 
 * @return {!Promise<!StripeNode.refunds.IRefund>} Returns the refund object if the refund succeeded. Throws an error if the charge has already been refunded or an invalid
 * charge identifier was provided.
 * 
 */
StripeNode.resources.Charges.prototype.createRefund = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * By default, you can see the 10 most recent refunds stored directly on the charge object, but you can also retrieve details about a specific
 * refund stored on the charge.
 * 
 * @param {string} chargeId The ID of the charge refunded
 * @param {string} refundId The ID of the refund to retrieve
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} response
 * @return {!Promise<!StripeNode.refunds.IRefund>}
 */
StripeNode.resources.Charges.prototype.retrieveRefund = function(chargeId, refundId, options_or_response, response) {};

/**
 * Updates the specified refund by setting the values of the parameters passed. Any parameters not provided will be left unchanged.
 * This request only accepts metadata as an argument.
 * 
 * @param {string} chargeId The ID of the charge refunded
 * @param {string} refundId The ID of the refund to update
 * @param {!StripeNode.IDataOptionsWithMetadata} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} response
 * @return {!Promise<!StripeNode.refunds.IRefund>}
 */
StripeNode.resources.Charges.prototype.updateRefund = function(chargeId, refundId, data, options_or_response, response) {};

/**
 * You can see a list of the refunds belonging to a specific charge. Note that the 10 most recent refunds are always available by default on
 * the charge object. If you need more than those 10, you can use this API method and the limit and starting_after parameters to page through
 * additional refunds.
 * 
 * @param {string} chargeId The ID of the charge refunded
 * @param {!StripeNode.IListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.refunds.IRefund>>=} data_or_options_or_response Used to filter the refunds returned
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.refunds.IRefund>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.refunds.IRefund>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.refunds.IRefund>>} A object with a data property that contains an array of up to limit refunds, starting after refund starting_after.
 * Each entry in the array is a separate refund object. If no more refunds are available, the resulting array will be empty. If you provide
 * a non-existent customer ID or charge ID, this call throws an error. You can optionally request that the response include the total count
 * of all refunds that match your filters. To do so, specify include[]=total_count in your request.
 * 
 */
StripeNode.resources.Charges.prototype.listRefunds = function(chargeId, data_or_options_or_response, options_or_response, response) {};

/**
 * @param {string} chargeId
 * @param {!StripeNode.IResponseFn<!StripeNode.charges.ICharge>=} response
 * @return {!Promise<!StripeNode.charges.ICharge>}
 */
StripeNode.resources.Charges.prototype.markAsSafe = function(chargeId, response) {};

/**
 * @param {string} chargeId
 * @param {!StripeNode.IResponseFn<!StripeNode.charges.ICharge>=} response
 * @return {!Promise<!StripeNode.charges.ICharge>}
 */
StripeNode.resources.Charges.prototype.markAsFraudulent = function(chargeId, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.ChargeRefunds = function() {};

/**
 * When you create a new refund, you must specify a charge to create it on.
 * 
 * Creating a new refund will refund a charge that has previously been created but not yet refunded.
 * Funds will be refunded to the credit or debit card that was originally charged.
 * The fees you were originally charged are also refunded.
 * 
 * You can optionally refund only part of a charge.
 * You can do so as many times as you wish until the entire charge has been refunded.
 * 
 * Once entirely refunded, a charge can't be refunded again.
 * This method will throw an error when called on an already-refunded charge, or when trying to refund more money than is left on a charge.
 * @param {!StripeNode.refunds.IRefundCreationOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} response
 * @return {!Promise<!StripeNode.refunds.IRefund>}
 */
StripeNode.resources.ChargeRefunds.prototype.create = function(data_or_options_or_response, options_or_response, response) {};

/**
 * Retrieves the details of an existing refund.
 * @param {string} id
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} response
 * @return {!Promise<!StripeNode.refunds.IRefund>}
 */
StripeNode.resources.ChargeRefunds.prototype.retrieve = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * Updates the specified refund by setting the values of the parameters passed.
 * Any parameters not provided will be left unchanged.
 * 
 * This request only accepts metadata as an argument.
 * @param {string} id
 * @param {!StripeNode.IDataOptionsWithMetadata} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} response
 * @return {!Promise<!StripeNode.refunds.IRefund>}
 */
StripeNode.resources.ChargeRefunds.prototype.update = function(id, data, options_or_response, response) {};

/**
 * Returns a list of all refunds youve previously created. The refunds are returned in sorted order,
 * with the most recent refunds appearing first.
 * For convenience, the 10 most recent refunds are always available by default on the charge object.
 * @param {!StripeNode.refunds.IRefundListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.refunds.IRefund>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.refunds.IRefund>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.refunds.IRefund>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.refunds.IRefund>>}
 */
StripeNode.resources.ChargeRefunds.prototype.list = function(data_or_options_or_response, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.Coupons = function() {};

/**
 * You can create coupons easily via the coupon management page of the Stripe dashboard. Coupon creation is also accessible via the API if
 * you need to create coupons on the fly. A coupon has either a percent_off or an amount_off and currency. If you set an amount_off, that
 * amount will be subtracted from any invoice's subtotal. For example, an invoice with a subtotal of $10 will have a final total of $0 if
 * a coupon with an amount_off of 2000 is applied to it and an invoice with a subtotal of $30 will have a final total of $10 if a coupon
 * with an amount_off of 2000 is applied to it.
 * 
 * @param {!StripeNode.coupons.ICouponCreationOptions} data Options for creating the coupon.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.coupons.ICoupon>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.coupons.ICoupon>=} response
 * @return {!Promise<!StripeNode.coupons.ICoupon>} Returns the coupon object.
 * 
 */
StripeNode.resources.Coupons.prototype.create = function(data, options_or_response, response) {};

/**
 * Retrieves the coupon with the given ID.
 * 
 * @param {string} id The ID of the desired coupon
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.coupons.ICoupon>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.coupons.ICoupon>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.coupons.ICoupon>=} response
 * @return {!Promise<!StripeNode.coupons.ICoupon>} Returns a coupon if a valid coupon ID was provided. Throws an error otherwise.
 * 
 */
StripeNode.resources.Coupons.prototype.retrieve = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * Updates the metadata of a coupon. Other coupon details (currency, duration, amount_off) are, by design, not editable.
 * 
 * @param {string} id The ID of the coupon to be updated
 * @param {!StripeNode.IDataOptionsWithMetadata} data Metadata to update
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.coupons.ICoupon>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.coupons.ICoupon>=} response
 * @return {!Promise<!StripeNode.coupons.ICoupon>} The newly updated coupon object if the call succeeded. Otherwise, this call throws an error, such as if the coupon has
 * been deleted.
 * 
 */
StripeNode.resources.Coupons.prototype.update = function(id, data, options_or_response, response) {};

/**
 * You can delete coupons via the coupon management page of the Stripe dashboard. However, deleting a coupon does not affect any
 * customers who have already applied the coupon; it means that new customers can't redeem the coupon. You can also delete coupons
 * via the API.
 * 
 * @param {string} id The ID of the coupon to be deleted.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} response
 * @return {!Promise<!StripeNode.IDeleteConfirmation>} An object with the deleted coupon's ID and a deleted flag upon success. Otherwise, this call throws an error, such as
 * if the coupon has already been deleted.
 * 
 */
StripeNode.resources.Coupons.prototype.del = function(id, options_or_response, response) {};

/**
 * Returns a list of your coupons.
 * 
 * @param {!StripeNode.IListOptionsCreated|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.coupons.ICoupon>>=} data_or_options_or_response Filtering options for the list.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.coupons.ICoupon>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.coupons.ICoupon>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.coupons.ICoupon>>} A object with a data property that contains an array of up to limit coupons, starting after coupon starting_after. Each
 * entry in the array is a separate coupon object. If no more coupons are available, the resulting array will be empty. This request
 * should never throw an error. You can optionally request that the response include the total count of all coupons. To do so, specify
 * include[]=total_count in your request.
 * 
 */
StripeNode.resources.Coupons.prototype.list = function(data_or_options_or_response, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.CustomerCards = function() {};

/**
 * When you create a new credit card, you must specify a customer or recipient to create it on. If the card's owner has no default card,
 * then the new card will become the default. However, if the owner already has a default then it will not change. To change the default,
 * you should either update the customer to have a new default_source or update the recipient to have a new default_card.
 * 
 * @param {{card: (string|!StripeNode.cards.ISourceCreationOptionsExtended)}} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} response
 * @return {!Promise<!StripeNode.cards.ICard>} Returns the card object.
 */
StripeNode.resources.CustomerCards.prototype.create = function(data, options_or_response, response) {};

/**
 * You can see a list of the cards belonging to a customer or recipient. Note that the 10 most recent
 * cards are always available by default on the customer or recipient object. If you need more than
 * those 10, you can use this API method and the limit and starting_after parameters to page through
 * additional cards.
 * 
 * @param {!StripeNode.IListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.cards.ICard>>=} data_or_options_or_response Filtering options
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.cards.ICard>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.cards.ICard>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.cards.ICard>>} Returns a list of the cards stored on the customer or recipient. You can optionally request
 * that the response include the total count of all cards for the customer or recipient. To do so,
 * specify include[]=total_count in your request.
 */
StripeNode.resources.CustomerCards.prototype.list = function(data_or_options_or_response, options_or_response, response) {};

/**
 * If you need to update only some card details, like the billing address or expiration date, you can do so without having to re-enter the
 * full card details. Stripe also works directly with card networks so that your customers can continue using your service without
 * interruption. When you update a card, Stripe will automatically validate the card.
 * 
 * @param {string} cardId The ID of the card to be retrieved.
 * @param {!StripeNode.cards.ICardUpdateOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} response
 * @return {!Promise<!StripeNode.cards.ICard>} Returns the card object.
 * 
 */
StripeNode.resources.CustomerCards.prototype.update = function(cardId, data, options_or_response, response) {};

/**
 * By default, you can see the 10 most recent cards stored on a customer or recipient directly on the customer or recipient object, but
 * you can also retrieve details about a specific card stored on the customer or recipient.
 * 
 * @param {string} cardId The ID of the card to be retrieved.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} response
 * @return {!Promise<!StripeNode.cards.ICard>} Returns the card object.
 * 
 */
StripeNode.resources.CustomerCards.prototype.retrieve = function(cardId, options_or_response, response) {};

/**
 * You can delete cards from a customer or recipient. If you delete a card that is currently the
 * default source on a customer, then the most recently added source will become the new default.
 * If you delete a card that is the last remaining source on the customer then the default_source
 * attribute will become null. Similarly, if you delete the default card on a recipient, then the
 * most recently added card will become the new default. If you delete the last remaining card on
 * a recipient, then the default_card attribute will become null. Note that for cards belonging to
 * customers, you may want to prevent customers on paid subscriptions from deleting all cards on
 * file so that there is at least one default card for the next invoice payment attempt.
 * 
 * @param {string} cardId The ID of the card to be retrieved.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} response
 * @return {!Promise<!StripeNode.IDeleteConfirmation>} Returns the deleted card object.
 * 
 */
StripeNode.resources.CustomerCards.prototype.del = function(cardId, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.Customers = function() {};

/* TODO: SemicolonClassElement: StripeNode.resources */

/* TODO: SemicolonClassElement: StripeNode.resources */

/* TODO: SemicolonClassElement: StripeNode.resources */

/* TODO: SemicolonClassElement: StripeNode.resources */

/**
 * Creates a new customer object.
 * 
 * @param {!StripeNode.customers.ICustomerCreationOptions} data The options for the new customer
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.customers.ICustomer>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.customers.ICustomer>=} response
 * @return {!Promise<!StripeNode.customers.ICustomer>} Returns a customer object if the call succeeded. The returned object will have information about subscriptions, discount,
 * and payment sources, if that information has been provided. If a non-free plan is specified and a source is not provided (unless
 * the plan has a trial period), the call will throw an error. If a non-existent plan or a non-existent or expired coupon is provided,
 * the call will throw an error. If a source has been attached to the customer, the returned customer object will have a default_source
 * attribute, which is an ID that can be expanded into the full source details when retrieving the customer.
 * 
 */
StripeNode.resources.Customers.prototype.create = function(data, options_or_response, response) {};

/**
 * Returns a list of your customers. The customers are returned sorted by creation date, with the most recently created customers
 * appearing first.
 * 
 * @param {!StripeNode.IListOptionsCreated|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.customers.ICustomer>>=} data_or_options_or_response Allows you to filter the customers you want.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.customers.ICustomer>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.customers.ICustomer>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.customers.ICustomer>>} A object with a data property that contains an array of up to limit customers, starting after customer starting_after.
 * Each entry in the array is a separate customer object. If no more customers are available, the resulting array will be empty.
 * This request should never throw an error. You can optionally request that the response include the total count of all customers
 * that match your filters. To do so, specify include[]=total_count in your request.
 * 
 */
StripeNode.resources.Customers.prototype.list = function(data_or_options_or_response, options_or_response, response) {};

/**
 * Updates the specified customer by setting the values of the parameters passed. Any parameters not provided will be left unchanged.
 * For example, if you pass the card parameter, that becomes the customer's active card to be used for all charges in the future.
 * When you update a customer to a new valid card: for each of the customer's current subscriptions, if the subscription is in the
 * past_due state, then the latest unpaid, unclosed invoice for the subscription will be retried (note that this retry will not count
 * as an automatic retry, and will not affect the next regularly scheduled payment for the invoice). (Note also that no invoices
 * pertaining to subscriptions in the unpaid state, or invoices pertaining to canceled subscriptions, will be retried as a result
 * of updating the customer's card.) This request accepts mostly the same arguments as the customer creation call.
 * 
 * @param {string} id The identifier of the customer to be retrieved.
 * @param {!StripeNode.customers.ICustomerUpdateOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.customers.ICustomer>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.customers.ICustomer>=} response
 * @return {!Promise<!StripeNode.customers.ICustomer>} Returns the customer object if the update succeeded. Throws an error if update parameters are invalid (e.g. specifying
 * an invalid coupon or an invalid card).
 * 
 */
StripeNode.resources.Customers.prototype.update = function(id, data, options_or_response, response) {};

/**
 * Retrieves the details of an existing customer. You need only supply the unique customer identifier that was returned upon customer
 * creation.
 * 
 * @param {string} id The identifier of the customer to be retrieved.
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.customers.ICustomer>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.customers.ICustomer>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.customers.ICustomer>=} response
 * @return {!Promise<!StripeNode.customers.ICustomer>} Returns a customer object if a valid identifier was provided. When requesting the ID of a customer that has been deleted,
 * a subset of the customer's information will be returned, including a "deleted" property, which will be true.
 * 
 */
StripeNode.resources.Customers.prototype.retrieve = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * Permanently deletes a customer. It cannot be undone. Also immediately cancels any active subscriptions on the customer.
 * 
 * @param {string} id The identifier of the customer to be deleted.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} response
 * @return {!Promise<!StripeNode.IDeleteConfirmation>} Returns an object with a deleted parameter on success. If the customer ID does not exist, this call throws an error. Unlike
 * other objects, deleted customers can still be retrieved through the API, in order to be able to track the history of customers while
 * still removing their credit card details and preventing any further operations to be performed (such as adding a new subscription).
 * 
 */
StripeNode.resources.Customers.prototype.del = function(id, options_or_response, response) {};

/**
 * When you create a new credit card, you must specify a customer or recipient to create it on. If the card's owner has no default card,
 * then the new card will become the default. However, if the owner already has a default then it will not change. To change the default,
 * you should either update the customer to have a new default_source or update the recipient to have a new default_card.
 * 
 * @deprecated
 * @param {string} customerId The customer ID to which to add the card.
 * 
 * @param {{card: (string|!StripeNode.cards.ISourceCreationOptionsExtended)}} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} response
 * @return {!Promise<!StripeNode.cards.ICard>} Returns the card object.
 * 
 */
StripeNode.resources.Customers.prototype.createCard = function(customerId, data, options_or_response, response) {};

/**
 * By default, you can see the 10 most recent cards stored on a customer or recipient directly on the customer or recipient object, but
 * you can also retrieve details about a specific card stored on the customer or recipient.
 * 
 * @param {string} customerId The ID of the customer whose card needs to be retrieved.
 * @param {string} cardId The ID of the card to be retrieved.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} response
 * @return {!Promise<!StripeNode.cards.ICard>} Returns the card object.
 * 
 */
StripeNode.resources.Customers.prototype.retrieveCard = function(customerId, cardId, options_or_response, response) {};

/**
 * If you need to update only some card details, like the billing address or expiration date, you can do so without having to re-enter the
 * full card details. Stripe also works directly with card networks so that your customers can continue using your service without
 * interruption. When you update a card, Stripe will automatically validate the card.
 * 
 * @param {string} customerId The ID of the customer whose card needs to be retrieved.
 * @param {string} cardId The ID of the card to be retrieved.
 * @param {!StripeNode.cards.ICardUpdateOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} response
 * @return {!Promise<!StripeNode.cards.ICard>} Returns the card object.
 * 
 */
StripeNode.resources.Customers.prototype.updateCard = function(customerId, cardId, data, options_or_response, response) {};

/**
 * You can delete cards from a customer or recipient. If you delete a card that is currently the
 * default source on a customer, then the most recently added source will become the new default.
 * If you delete a card that is the last remaining source on the customer then the default_source
 * attribute will become null. Similarly, if you delete the default card on a recipient, then the
 * most recently added card will become the new default. If you delete the last remaining card on
 * a recipient, then the default_card attribute will become null. Note that for cards belonging to
 * customers, you may want to prevent customers on paid subscriptions from deleting all cards on
 * file so that there is at least one default card for the next invoice payment attempt.
 * 
 * @param {string} customerId The ID of the customer whose card needs to be retrieved.
 * @param {string} cardId The ID of the card to be retrieved.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} response
 * @return {!Promise<!StripeNode.IDeleteConfirmation>} Returns the deleted card object.
 * 
 */
StripeNode.resources.Customers.prototype.deleteCard = function(customerId, cardId, options_or_response, response) {};

/**
 * You can see a list of the cards belonging to a customer or recipient. Note that the 10 most recent
 * cards are always available by default on the customer or recipient object. If you need more than
 * those 10, you can use this API method and the limit and starting_after parameters to page through
 * additional cards.
 * 
 * @param {string} customerId The ID of the customer whose cards will be retrieved
 * @param {!StripeNode.IListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.cards.ICard>>=} data_or_options_or_response Filtering options
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.cards.ICard>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.cards.ICard>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.cards.ICard>>} Returns a list of the cards stored on the customer or recipient. You can optionally request
 * that the response include the total count of all cards for the customer or recipient. To do so,
 * specify include[]=total_count in your request.
 * 
 */
StripeNode.resources.Customers.prototype.listCards = function(customerId, data_or_options_or_response, options_or_response, response) {};

/**
 * When adding a card to a customer, the parameter name is source. When
 * adding to an account, the parameter name is external_account. The
 * value can either be a token, like the ones returned by our Stripe.js, or a
 * dictionary containing a user's credit card details.
 * Stripe will automatically validate the card.
 * 
 * When adding a card to a customer, the parameter name is source. When
 * adding to an account, the parameter name is external_account. The
 * value can either be a token, like the ones returned by our Stripe.js, or a
 * dictionary containing a users credit card details.
 * Stripe will automatically validate the card.
 * 
 * @param {string} customerId The customer ID to which to add the card.
 * @param {!StripeNode.customers.ICustomerCardSourceCreationOptions|!StripeNode.customers.ICustomerSourceCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.cards.ICard>|!StripeNode.IResponseFn<(!StripeNode.bankAccounts.IBankAccount|!StripeNode.cards.ICard)>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.cards.ICard>|!StripeNode.IResponseFn<(!StripeNode.bankAccounts.IBankAccount|!StripeNode.cards.ICard)>=} response
 * @return {!Promise<!StripeNode.cards.ICard>|!Promise<(!StripeNode.bankAccounts.IBankAccount|!StripeNode.cards.ICard)>} Returns the card object.
 *  / Returns the card or bank account object.
 * 
 */
StripeNode.resources.Customers.prototype.createSource = function(customerId, data, options_or_response, response) {};

/**
 * You can see a list of the cards belonging to a customer or recipient. Note that the 10 most recent
 * cards are always available by default on the customer or recipient object. If you need more than
 * those 10, you can use this API method and the limit and starting_after parameters to page through
 * additional cards.
 * 
 * You can see a list of the bank accounts belonging to a customer or recipient. Note that the 10 most recent
 * bank accounts are always available by default on the customer or recipient object. If you need more than
 * those 10, you can use this API method and the limit and starting_after parameters to page through
 * additional cards.
 * 
 * @param {string} customerId The ID of the customer whose cards will be retrieved
 * @param {!StripeNode.customers.ICardSourceListOptions|!StripeNode.customers.IBankAccountSourceListOptions} data Filtering options
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.cards.ICard>>|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.bankAccounts.IBankAccount>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.cards.ICard>>|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.bankAccounts.IBankAccount>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.cards.ICard>>|!Promise<!StripeNode.IList<!StripeNode.bankAccounts.IBankAccount>>} Returns a list of the cards stored on the customer or recipient. You can optionally request
 * that the response include the total count of all cards for the customer or recipient. To do so,
 * specify include[]=total_count in your request.
 *  / Returns a list of the bank accounts stored on the customer or recipient. You can optionally request
 * that the response include the total count of all bank accounts for the customer or recipient. To do so,
 * specify include[]=total_count in your request.
 * 
 */
StripeNode.resources.Customers.prototype.listSource = function(customerId, data, options_or_response, response) {};

/**
 * By default, you can see the 10 most recent cards/bank accounts stored on a customer or recipient directly on the customer or recipient object, but
 * you can also retrieve details about a specific card/bank account stored on the customer or recipient.
 * 
 * @param {string} customerId The ID of the customer whose card needs to be retrieved.
 * @param {string} sourceId The ID of the source to be retrieved.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<(!StripeNode.bankAccounts.IBankAccount|!StripeNode.cards.ICard)>=} options_or_response
 * @param {!StripeNode.IResponseFn<(!StripeNode.bankAccounts.IBankAccount|!StripeNode.cards.ICard)>=} response
 * @return {!Promise<(!StripeNode.bankAccounts.IBankAccount|!StripeNode.cards.ICard)>} Returns the card/bank account object.
 * 
 */
StripeNode.resources.Customers.prototype.retrieveSource = function(customerId, sourceId, options_or_response, response) {};

/**
 * If you need to update only some card details, like the billing address or expiration date, you can do so without having to re-enter the
 * full card details. Stripe also works directly with card networks so that your customers can continue using your service without
 * interruption. When you update a card, Stripe will automatically validate the card.
 * 
 * Updates the metadata, account_holder_name, and account_holder_type of a bank account belonging to a Customer. Other bank account details
 * are not editable by design.
 * 
 * @param {string} customerId The ID of the customer whose card needs to be retrieved.
 * @param {string} sourceId The ID of the card to be retrieved. / The ID of the bank account to be updated.
 * @param {!StripeNode.cards.ICardUpdateOptions|!StripeNode.bankAccounts.IBankAccountUpdateOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.cards.ICard>|!StripeNode.IResponseFn<!StripeNode.bankAccounts.IBankAccount>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.cards.ICard>=} response
 * @return {!Promise<!StripeNode.cards.ICard>|!Promise<!StripeNode.bankAccounts.IBankAccount>} Returns the card object.
 *  / Returns the bank account object.
 * 
 */
StripeNode.resources.Customers.prototype.updateSource = function(customerId, sourceId, data, options_or_response, response) {};

/**
 * You can delete cards or bank accounts from a customer or recipient. If you delete a card or bank account that is currently the
 * default source on a customer, then the most recently added source will become the new default.
 * If you delete a card or bank account that is the last remaining source on the customer then the default_source
 * attribute will become null. Similarly, if you delete the default card or bank account on a recipient, then the
 * most recently added source will become the new default. If you delete the last remaining source on
 * a recipient, then the default_card attribute will become null. Note that for sources belonging to
 * customers, you may want to prevent customers on paid subscriptions from deleting all sources on
 * file so that there is at least one default source for the next invoice payment attempt.
 * 
 * @param {string} customerId The ID of the customer whose source needs to be deleted.
 * @param {string} sourceId The ID of the source to be deleted.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} response
 * @return {!Promise<!StripeNode.IDeleteConfirmation>} Returns a confirmation object.
 * 
 */
StripeNode.resources.Customers.prototype.deleteSource = function(customerId, sourceId, options_or_response, response) {};

/**
 * @param {string} customerId
 * @param {string} sourceId
 * @param {(string|!StripeNode.IHeaderOptions)=} options
 * @return {!Promise<!Object>}
 */
StripeNode.resources.Customers.prototype.verifySource = function(customerId, sourceId, options) {};

/**
 * Creates a new subscription on an existing customer.
 * 
 * @param {string} customerId The customer to which the add the subscription.
 * @param {!StripeNode.subscriptions.ISubscriptionCustCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} options_or_response The options for the new subscription
 * @param {!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} response
 * @return {!Promise<!StripeNode.subscriptions.ISubscription>} The newly created subscription object if the call succeeded. If the customer has no card or the
 * attempted charge fails, this call throws an error (unless the specified plan is free or has a trial
 * period).
 * 
 */
StripeNode.resources.Customers.prototype.createSubscription = function(customerId, data, options_or_response, response) {};

/**
 * By default, you can see the 10 most recent active subscriptions stored on a customer directly on the customer
 * object, but you can also retrieve details about a specific active subscription for a customer.
 * 
 * @param {string} customerId The customer ID for the subscription
 * @param {string} subscriptionId The ID of the subscription to retrieve
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} response
 * @return {!Promise<!StripeNode.subscriptions.ISubscription>} Returns the subscription object.
 * 
 */
StripeNode.resources.Customers.prototype.retrieveSubscription = function(customerId, subscriptionId, options_or_response, response) {};

/**
 * Updates an existing subscription on a customer to match the specified parameters. When changing plans or quantities,
 * we will optionally prorate the price we charge next month to make up for any price changes.
 * 
 * By default, we prorate subscription changes. For example, if a customer signs up on May 1 for a $10 plan, she'll be billed
 * $10 immediately. If she then switches to a $20 plan on May 15, on June 1 she'll be billed $25 ($20 for a renewal of her
 * subscription and a $5 prorating adjustment for the previous month). Similarly, a downgrade will generate a credit to be
 * applied to the next invoice. We also prorate when you make quantity changes. Switching plans does not change the billing
 * date or generate an immediate charge unless you're switching between different intervals (e.g. monthly to yearly), in which
 * case we apply a credit for the time unused on the old plan and charge for the new plan starting right away, resetting the
 * billing date. (Note that if we charge for the new plan, and that payment fails, the plan change will not go into effect). If
 * you'd like to charge for an upgrade immediately, just pass prorate as true as usual, and then invoice the customer as soon
 * as you make the subscription change. That'll collect the proration adjustments into a new invoice, and Stripe will automatically
 * attempt to pay the invoice. If you don't want to prorate at all, set the prorate option to false and the customer would be billed
 * $10 on May 1 and $20 on June 1. Similarly, if you set prorate to false when switching between different billing intervals
 * (monthly to yearly, for example), we won't generate any credits for the old subscription's unused time, although we will still
 * reset the billing date and bill immediately for the new subscription.
 * 
 * @param {string} customerId The ID of the customer whose subscription needs to be updated.
 * @param {string} subscriptionId The ID of the subscription to update.
 * @param {!StripeNode.subscriptions.ISubscriptionUpdateOptions} data The fields to update
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} response
 * @return {!Promise<!StripeNode.subscriptions.ISubscription>} The newly updated subscription object if the call succeeded. If a charge is required for the update, and
 * the charge fails, this call raises throws an error, and the subscription update does not go into effect.
 * 
 */
StripeNode.resources.Customers.prototype.updateSubscription = function(customerId, subscriptionId, data, options_or_response, response) {};

/**
 * Cancels a customer's subscription. If you set the at_period_end parameter to true, the subscription will remain active until
 * the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated
 * immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending
 * invoice items that you've created will still be charged for at the end of the period unless manually deleted. If you've set
 * the subscription to cancel at period end, any pending prorations will also be left in place and collected at the end of the
 * period, but if the subscription is set to cancel immediately, pending prorations will be removed. By default, all unpaid
 * invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment
 * retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription
 * cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices
 * before allowing the customer to cancel the subscription at all.
 * 
 * @param {string} customerId The ID of the customer whose subscription needs to be cancelled.
 * @param {string} subscriptionId The ID of the subscription to cancel.
 * @param {!StripeNode.subscriptions.ISubscriptionCancellationOptions|!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} data_or_response Specify when to cancel the subscription
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} response
 * @return {!Promise<!StripeNode.subscriptions.ISubscription>} The canceled subscription object. Its subscription status will be set to "canceled" unless you've set at_period_end
 * to true when canceling, in which case the status will remain "active" but the cancel_at_period_end attribute will change to true.
 * 
 */
StripeNode.resources.Customers.prototype.cancelSubscription = function(customerId, subscriptionId, data_or_response, options_or_response, response) {};

/**
 * You can see a list of the customer's active subscriptions. Note that the 10 most recent active subscriptions are always available
 * by default on the customer object. If you need more than those 10, you can use the limit and starting_after parameters to page
 * through additional subscriptions.
 * 
 * @param {string} customerId The ID of the customer whose subscriptions will be retrieved
 * @param {!StripeNode.IListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.subscriptions.ISubscription>>=} data_or_options_or_response Filtering options
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.subscriptions.ISubscription>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.subscriptions.ISubscription>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.subscriptions.ISubscription>>} Returns a list of the customer's active subscriptions. You can optionally request that the response include the total
 * count of all subscriptions for the customer. To do so, specify include[]=total_count in your request.
 * 
 */
StripeNode.resources.Customers.prototype.listSubscriptions = function(customerId, data_or_options_or_response, options_or_response, response) {};

/**
 * Removes the currently applied discount on a customer.
 * 
 * @param {string} customerId The ID of the customer.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} response
 * @return {!Promise<!StripeNode.IDeleteConfirmation>} An object with a deleted flag set to true upon success. This call throws an error otherwise, such as if no
 * discount exists on this customer.
 * 
 */
StripeNode.resources.Customers.prototype.deleteDiscount = function(customerId, options_or_response, response) {};

/**
 * Removes the currently applied discount on a subscription.
 * 
 * @param {string} customerId The ID of the customer.
 * @param {string} subscriptionId The ID of the subscription.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} response
 * @return {!Promise<!StripeNode.IDeleteConfirmation>} An object with a deleted flag set to true upon success. This call throws an error otherwise, such as if no
 * discount exists on this subscription.
 * 
 */
StripeNode.resources.Customers.prototype.deleteSubscriptionDiscount = function(customerId, subscriptionId, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.SubscriptionsBase = function() {};

/* TODO: SemicolonClassElement: StripeNode.resources */

/* TODO: SemicolonClassElement: StripeNode.resources */

/**
 * By default, you can see the 10 most recent active subscriptions stored on a customer directly on the customer
 * object, but you can also retrieve details about a specific active subscription for a customer.
 * 
 * @param {string} subscriptionId The ID of the subscription to retrieve
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} response
 * @return {!Promise<!StripeNode.subscriptions.ISubscription>} Returns the subscription object.
 * 
 */
StripeNode.resources.SubscriptionsBase.prototype.retrieve = function(subscriptionId, options_or_response, response) {};

/**
 * Updates an existing subscription on a customer to match the specified parameters. When changing plans or quantities,
 * we will optionally prorate the price we charge next month to make up for any price changes.
 * 
 * By default, we prorate subscription changes. For example, if a customer signs up on May 1 for a $10 plan, she'll be billed
 * $10 immediately. If she then switches to a $20 plan on May 15, on June 1 she'll be billed $25 ($20 for a renewal of her
 * subscription and a $5 prorating adjustment for the previous month). Similarly, a downgrade will generate a credit to be
 * applied to the next invoice. We also prorate when you make quantity changes. Switching plans does not change the billing
 * date or generate an immediate charge unless you're switching between different intervals (e.g. monthly to yearly), in which
 * case we apply a credit for the time unused on the old plan and charge for the new plan starting right away, resetting the
 * billing date. (Note that if we charge for the new plan, and that payment fails, the plan change will not go into effect). If
 * you'd like to charge for an upgrade immediately, just pass prorate as true as usual, and then invoice the customer as soon
 * as you make the subscription change. That'll collect the proration adjustments into a new invoice, and Stripe will automatically
 * attempt to pay the invoice. If you don't want to prorate at all, set the prorate option to false and the customer would be billed
 * $10 on May 1 and $20 on June 1. Similarly, if you set prorate to false when switching between different billing intervals
 * (monthly to yearly, for example), we won't generate any credits for the old subscription's unused time, although we will still
 * reset the billing date and bill immediately for the new subscription.
 * 
 * @param {string} subscriptionId The ID of the subscription to update.
 * @param {!StripeNode.subscriptions.ISubscriptionUpdateOptions} data The fields to update
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} response
 * @return {!Promise<!StripeNode.subscriptions.ISubscription>} The newly updated subscription object if the call succeeded. If a charge is required for the update, and
 * the charge fails, this call raises throws an error, and the subscription update does not go into effect.
 * 
 */
StripeNode.resources.SubscriptionsBase.prototype.update = function(subscriptionId, data, options_or_response, response) {};

/**
 * Cancels a customer's subscription. If you set the at_period_end parameter to true, the subscription will remain active until
 * the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated
 * immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending
 * invoice items that you've created will still be charged for at the end of the period unless manually deleted. If you've set
 * the subscription to cancel at period end, any pending prorations will also be left in place and collected at the end of the
 * period, but if the subscription is set to cancel immediately, pending prorations will be removed. By default, all unpaid
 * invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment
 * retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription
 * cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices
 * before allowing the customer to cancel the subscription at all.
 * 
 * @param {string} subscriptionId The ID of the subscription to cancel.
 * @param {!StripeNode.subscriptions.ISubscriptionCancellationOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} data_or_options_or_response Specify when to cancel the subscription
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} response
 * @return {!Promise<!StripeNode.subscriptions.ISubscription>} The canceled subscription object. Its subscription status will be set to "canceled" unless you've set at_period_end
 * to true when canceling, in which case the status will remain "active" but the cancel_at_period_end attribute will change to true.
 * 
 */
StripeNode.resources.SubscriptionsBase.prototype.del = function(subscriptionId, data_or_options_or_response, options_or_response, response) {};

/**
 * You can see a list of the customer's active subscriptions. Note that the 10 most recent active subscriptions are always available
 * by default on the customer object. If you need more than those 10, you can use the limit and starting_after parameters to page
 * through additional subscriptions.
 * 
 * @param {!StripeNode.subscriptions.ISubscriptionListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.subscriptions.ISubscription>>=} data_or_options_or_response Filtering options
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.subscriptions.ISubscription>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.subscriptions.ISubscription>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.subscriptions.ISubscription>>} Returns a list of the customer's active subscriptions. You can optionally request that the response include the total
 * count of all subscriptions for the customer. To do so, specify include[]=total_count in your request.
 * 
 */
StripeNode.resources.SubscriptionsBase.prototype.list = function(data_or_options_or_response, options_or_response, response) {};

/**
 * Removes the currently applied discount on a subscription.
 * 
 * @param {string} subscriptionId The ID of the subscription.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} response
 * @return {!Promise<!StripeNode.IDeleteConfirmation>} An object with a deleted flag set to true upon success. This call throws an error otherwise, such as if no
 * discount exists on this subscription.
 * 
 */
StripeNode.resources.SubscriptionsBase.prototype.deleteDiscount = function(subscriptionId, options_or_response, response) {};
/**
 * @extends {StripeNode.resources.SubscriptionsBase}
 * @constructor
 * @struct
 */
StripeNode.resources.Subscriptions = function() {};

/**
 * Creates a new subscription on an existing customer.
 * 
 * @param {!StripeNode.subscriptions.ISubscriptionCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} options_or_response The options for the new subscription
 * @param {!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} response
 * @return {!Promise<!StripeNode.subscriptions.ISubscription>} The newly created subscription object if the call succeeded. If the customer has no card or the
 * attempted charge fails, this call throws an error (unless the specified plan is free or has a trial
 * period).
 * 
 */
StripeNode.resources.Subscriptions.prototype.create = function(data, options_or_response, response) {};
/**
 * @extends {StripeNode.resources.SubscriptionsBase}
 * @constructor
 * @struct
 */
StripeNode.resources.CustomerSubscriptions = function() {};

/**
 * Creates a new subscription on an existing customer.
 * 
 * @param {!StripeNode.subscriptions.ISubscriptionCustCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} options_or_response The options for the new subscription
 * @param {!StripeNode.IResponseFn<!StripeNode.subscriptions.ISubscription>=} response
 * @return {!Promise<!StripeNode.subscriptions.ISubscription>} The newly created subscription object if the call succeeded. If the customer has no card or the
 * attempted charge fails, this call throws an error (unless the specified plan is free or has a trial
 * period).
 * 
 */
StripeNode.resources.CustomerSubscriptions.prototype.create = function(data, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.Disputes = function() {};

/**
 * Retrieves the dispute with the given ID.
 * @param {string} disputeId
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.disputes.IDispute>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.disputes.IDispute>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.disputes.IDispute>=} response
 * @return {!Promise<!StripeNode.disputes.IDispute>}
 */
StripeNode.resources.Disputes.prototype.retrieve = function(disputeId, data_or_options_or_response, options_or_response, response) {};

/**
 * When you get a dispute, contacting your customer is always the best first step. If that doesn't work, you can submit evidence in
 * order to help us resolve the dispute in your favor. You can do this in your dashboard, but if you prefer, you can use the API to
 * submit evidence programmatically. Depending on your dispute type, different evidence fields will give you a better chance of winning
 * your dispute. You may want to consult our guide to dispute types to help you figure out which evidence fields to provide:
 * https://stripe.com/help/dispute-types
 * 
 * @param {string} disputeId
 * @param {!StripeNode.disputes.IDisputeUpdateOptions} data The fields to update
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.disputes.IDispute>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.disputes.IDispute>=} response
 * @return {!Promise<!StripeNode.disputes.IDispute>}
 */
StripeNode.resources.Disputes.prototype.update = function(disputeId, data, options_or_response, response) {};

/**
 * Closing the dispute for a charge indicates that you do not have any evidence to submit and are
 * essentially dismissing the dispute, acknowledging it as lost
 * 
 * The status of the dispute will change from needs_response to lost.
 * 
 * *Closing a dispute is irreversible!*
 * @param {string} disputeId
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.disputes.IDispute>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.disputes.IDispute>=} response
 * @return {!Promise<!StripeNode.disputes.IDispute>}
 */
StripeNode.resources.Disputes.prototype.close = function(disputeId, options_or_response, response) {};

/**
 * Returns a list of your disputes.
 * @param {!StripeNode.IListOptionsCreated|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.disputes.IDispute>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.disputes.IDispute>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.disputes.IDispute>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.disputes.IDispute>>}
 */
StripeNode.resources.Disputes.prototype.list = function(data_or_options_or_response, options_or_response, response) {};

/**
 * @return {void}
 */
StripeNode.resources.Disputes.prototype.setMetadata = function() {};

/**
 * @return {void}
 */
StripeNode.resources.Disputes.prototype.getMetadata = function() {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.Events = function() {};

/**
 * Retrieves the details of an event. Supply the unique identifier of the event, which you might have
 * received in a webhook.
 * @param {string} id
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.events.IEvent>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.events.IEvent>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.events.IEvent>=} response
 * @return {!Promise<!StripeNode.events.IEvent>}
 */
StripeNode.resources.Events.prototype.retrieve = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * List events, going back up to 30 days.
 * @param {!StripeNode.events.IEventListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.events.IEvent>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.events.IEvent>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.events.IEvent>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.events.IEvent>>}
 */
StripeNode.resources.Events.prototype.list = function(data_or_options_or_response, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.FileUploads = function() {};

/**
 * To upload a file to Stripe, youll need to send a request of type multipart/form-data.
 * The request should contain the file you would like to upload, as well as the parameters for creating a file.
 * 
 * All of Stripes officially supported API libraries should have support for sending multipart/form-data.
 * @param {!StripeNode.fileUploads.IFileUploadCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.fileUploads.IFileUpdate>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.fileUploads.IFileUpdate>=} response
 * @return {!Promise<!StripeNode.fileUploads.IFileUpdate>}
 */
StripeNode.resources.FileUploads.prototype.create = function(data, options_or_response, response) {};

/**
 * Retrieves the details of an existing file object.
 * Supply the unique file upload ID from a file creation request, and Stripe will return the corresponding transfer information.
 * @param {string} id
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.fileUploads.IFileUpdate>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.fileUploads.IFileUpdate>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.fileUploads.IFileUpdate>=} response
 * @return {!Promise<!StripeNode.fileUploads.IFileUpdate>}
 */
StripeNode.resources.FileUploads.prototype.retrieve = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * Returns a list of the files that you have uploaded to Stripe.
 * The file uploads are returned sorted by creation date, with the most recently created file uploads appearing first.
 * @param {!StripeNode.fileUploads.IFileUploadListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.fileUploads.IFileUpdate>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.fileUploads.IFileUpdate>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.fileUploads.IFileUpdate>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.fileUploads.IFileUpdate>>}
 */
StripeNode.resources.FileUploads.prototype.list = function(data_or_options_or_response, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.Invoices = function() {};

/**
 * If you need to invoice your customer outside the regular billing cycle, you can create an invoice that
 * pulls in all pending invoice items, including prorations. The customer's billing cycle and regular subscription
 * won't be affected. Once you create the invoice, it'll be picked up and paid automatically, though you can
 * choose to pay it right away: https://stripe.com/docs/api#pay_invoice
 * 
 * @param {!StripeNode.invoices.IInvoiceCreationOptions} data Options used to create the invoice.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.invoices.IInvoice>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.invoices.IInvoice>=} response
 * @return {!Promise<!StripeNode.invoices.IInvoice>} Returns the invoice object if there are pending invoice items to invoice. Throws an error if there
 * are no pending invoice items or if the customer ID provided is invalid.
 * 
 */
StripeNode.resources.Invoices.prototype.create = function(data, options_or_response, response) {};

/**
 * Retrieves the invoice with the given ID. The invoice object contains a
 * lines hash that contains information about the subscriptions and invoice items that have been applied to the
 * invoice, as well as any prorations that Stripe has automatically calculated. Each line on the invoice has an
 * amount attribute that represents the amount actually contributed to the invoice's total. For invoice items and
 * prorations, the amount attribute is the same as for the invoice item or proration respectively. For
 * subscriptions, the amount may be different from the plan's regular price depending on whether the invoice
 * covers a trial period or the invoice period differs from the plan's usual interval. The invoice object has
 * both a subtotal and a total. The subtotal represents the total before any discounts, while the total is the final
 * amount to be charged to the customer after all coupons have been applied. The invoice also has a
 * next_payment_attempt attribute that tells you the next time (as a Unix timestamp) payment for the invoice will be
 * automatically attempted. For invoices that have been closed or that have reached the maximum number of retries
 * (specified in your retry settings), the next_payment_attempt will be null.
 * 
 * @param {string} id The ID of the desired invoice.
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.invoices.IInvoice>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.invoices.IInvoice>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.invoices.IInvoice>=} response
 * @return {!Promise<!StripeNode.invoices.IInvoice>} Returns an invoice object if a valid invoice ID was provided. Throws an error otherwise.
 * 
 */
StripeNode.resources.Invoices.prototype.retrieve = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * When retrieving an invoice, you'll get a lines property containing the total count of line items and the first
 * handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.
 * 
 * @param {string} id The id of the invoice containing the lines to be retrieved
 * @param {!StripeNode.invoices.IInvoiceLineItemRetrievalOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.invoices.IInvoiceLineItem>>=} data_or_options_or_response Filtering options
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.invoices.IInvoiceLineItem>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.invoices.IInvoiceLineItem>>=} response
 * @return {!Promise<!StripeNode.invoices.IInvoiceLineItem>} Returns a list of line_item objects.
 * 
 */
StripeNode.resources.Invoices.prototype.retrieveLines = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * At any time, you can preview the upcoming invoice for a customer. This will show you all the charges that are pending,
 * including subscription renewal charges, invoice item charges, etc. It will also show you any discount that is applicable
 * to the customer. Note that when you are viewing an upcoming invoice, you are simply viewing a preview -- the invoice has
 * not yet been created. As such, the upcoming invoice will not show up in invoice listing calls, and you cannot use the API
 * to pay or edit the invoice. If you want to change the amount that your customer will be billed, you can add, remove, or
 * update pending invoice items, or update the customer's discount.
 * 
 * @param {string} id The identifier of the customer whose upcoming invoice you'd like to retrieve.
 * @param {!StripeNode.invoices.IInvoiceUpcomingOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.invoices.IInvoice>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.invoices.IInvoice>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.invoices.IInvoice>=} response
 * @return {!Promise<!StripeNode.invoices.IInvoice>} Returns an invoice if a valid customer ID was provided. Throws an error otherwise.
 * 
 */
StripeNode.resources.Invoices.prototype.retrieveUpcoming = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * Until an invoice is paid, it is marked as open (closed=false). If you'd like to stop Stripe from automatically attempting
 * payment on an invoice or would simply like to close the invoice out as no longer owed by the customer, you can update the
 * closed parameter.
 * 
 * @param {string} id The ID of the invoice to update
 * @param {!StripeNode.invoices.IInvoiceUpdateOptions} data Fields to update
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.invoices.IInvoice>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.invoices.IInvoice>=} response
 * @return {!Promise<!StripeNode.invoices.IInvoice>} Returns the invoice object.
 * 
 */
StripeNode.resources.Invoices.prototype.update = function(id, data, options_or_response, response) {};

/**
 * Stripe automatically creates and then attempts to pay invoices for customers on subscriptions. We'll also retry unpaid
 * invoices according to your retry settings. However, if you'd like to attempt to collect payment on an invoice out of the
 * normal retry schedule or for some other reason, you can do so.
 * 
 * @param {string} id The ID of the invoice to pay.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.invoices.IInvoice>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.invoices.IInvoice>=} response
 * @return {!Promise<!StripeNode.invoices.IInvoice>} Returns the invoice object.
 * 
 */
StripeNode.resources.Invoices.prototype.pay = function(id, options_or_response, response) {};

/**
 * You can list all invoices, or list the invoices for a specific customer. The invoices are returned
 * sorted by creation date, with the most recently created invoices appearing first.
 * 
 * @param {!StripeNode.invoices.IInvoiceListOptions|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.invoices.IInvoice>>=} data_or_response Filtering options
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.invoices.IInvoice>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.invoices.IInvoice>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.invoices.IInvoice>>} A object with a data property that contains an array of invoice objects. Throws an error if the
 * customer ID is invalid.
 * 
 */
StripeNode.resources.Invoices.prototype.list = function(data_or_response, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.InvoiceItems = function() {};

/**
 * Adds an arbitrary charge or credit to the customers upcoming invoice.
 * @param {!StripeNode.invoiceItems.InvoiceItemCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.invoiceItems.InvoiceItem>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.invoiceItems.InvoiceItem>=} response
 * @return {!Promise<!StripeNode.invoiceItems.InvoiceItem>}
 */
StripeNode.resources.InvoiceItems.prototype.create = function(data, options_or_response, response) {};

/**
 * Retrieves the invoice item with the given ID.
 * @param {string} invoiceItemId
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.invoiceItems.InvoiceItem>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.invoiceItems.InvoiceItem>=} response
 * @return {!Promise<!StripeNode.invoiceItems.InvoiceItem>}
 */
StripeNode.resources.InvoiceItems.prototype.retrieve = function(invoiceItemId, options_or_response, response) {};

/**
 * Updates the amount or description of an invoice item on an upcoming invoice. Updating an invoice item is only possible before the
 * invoice it's attached to is closed.
 * @param {string} invoiceItemId
 * @param {!StripeNode.invoiceItems.InvoiceItemUpdateOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.invoiceItems.InvoiceItem>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.invoiceItems.InvoiceItem>=} response
 * @return {!Promise<!StripeNode.invoiceItems.InvoiceItem>}
 */
StripeNode.resources.InvoiceItems.prototype.update = function(invoiceItemId, data, options_or_response, response) {};

/**
 * Returns a list of your invoice items. Invoice items are returned sorted by creation date, with the most recently created invoice
 * items appearing first.
 * @param {!StripeNode.invoiceItems.InvoiceItemListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.invoiceItems.InvoiceItem>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.invoiceItems.InvoiceItem>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.invoiceItems.InvoiceItem>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.invoiceItems.InvoiceItem>>}
 */
StripeNode.resources.InvoiceItems.prototype.list = function(data_or_options_or_response, options_or_response, response) {};

/**
 * Removes an invoice item from the upcoming invoice. Removing an invoice item is only possible before the invoice it's attached
 * to is closed.
 * @param {string} invoiceItemId
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} response
 * @return {!Promise<!StripeNode.IDeleteConfirmation>}
 */
StripeNode.resources.InvoiceItems.prototype.del = function(invoiceItemId, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.Plans = function() {};

/**
 * You can create plans easily via the plan management page of the Stripe dashboard. Plan creation is also
 * accessible via the API if you need to create plans on the fly.
 * 
 * @param {!StripeNode.plans.IPlanCreationOptions} data Creation options for the new plan.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.plans.IPlan>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.plans.IPlan>=} response
 * @return {!Promise<!StripeNode.plans.IPlan>} The newly created plan
 * 
 */
StripeNode.resources.Plans.prototype.create = function(data, options_or_response, response) {};

/**
 * Retrieves the plan with the given ID.
 * 
 * @param {string} planName The identifier of the desired plan.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.plans.IPlan>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.plans.IPlan>=} response
 * @return {!Promise<!StripeNode.plans.IPlan>} Returns a plan if a valid plan ID was provided. Throws an error otherwise.
 * 
 */
StripeNode.resources.Plans.prototype.retrieve = function(planName, options_or_response, response) {};

/**
 * Updates the name of a plan. Other plan details (price, interval, etc.) are, by design, not editable.
 * 
 * @param {string} planName The identifier of the plan to update
 * @param {!StripeNode.plans.IPlanUpdateOptions} data The fields to update
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.plans.IPlan>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.plans.IPlan>=} response
 * @return {!Promise<!StripeNode.plans.IPlan>} The updated plan object is returned upon success. Otherwise, this call throws an error.
 * 
 */
StripeNode.resources.Plans.prototype.update = function(planName, data, options_or_response, response) {};

/**
 * You can delete plans via the plan management page of the Stripe dashboard. However, deleting a plan does not affect
 * any current subscribers to the plan; it merely means that new subscribers can't be added to that plan. You can also
 * delete plans via the API.
 * 
 * @param {string} planName The identifier of the plan to be deleted.
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} response
 * @return {!Promise<!StripeNode.IDeleteConfirmation>} An object with the deleted plan's ID and a deleted flag upon success. Otherwise, this call throws an error, such as if the plan has already been deleted.
 * 
 */
StripeNode.resources.Plans.prototype.del = function(planName, options_or_response, response) {};

/**
 * Returns a list of your plans.
 * 
 * @param {!StripeNode.IListOptionsCreated|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.plans.IPlan>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.plans.IPlan>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.plans.IPlan>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.plans.IPlan>>} An object with a data property that contains an array of up to limit plans, starting after plan starting_after.
 * Each entry in the array is a separate plan object. If no more plans are available, the resulting array will be empty. This
 * request should never throw an error. You can optionally request that the response include the total count of all plans. To
 * do so, specify include[]=total_count in your request.
 */
StripeNode.resources.Plans.prototype.list = function(data_or_options_or_response, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.RecipientCards = function() {};

/**
 * @deprecated
 * @return {void}
 */
StripeNode.resources.RecipientCards.prototype.create = function() {};

/**
 * @deprecated
 * @return {void}
 */
StripeNode.resources.RecipientCards.prototype.list = function() {};

/**
 * @deprecated
 * @param {string} id
 * @return {void}
 */
StripeNode.resources.RecipientCards.prototype.update = function(id) {};

/**
 * @deprecated
 * @param {string} id
 * @return {void}
 */
StripeNode.resources.RecipientCards.prototype.retrieve = function(id) {};

/**
 * @deprecated
 * @param {string} id
 * @return {void}
 */
StripeNode.resources.RecipientCards.prototype.del = function(id) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.Recipients = function() {};

/**
 * @deprecated
 * @return {void}
 */
StripeNode.resources.Recipients.prototype.create = function() {};

/**
 * @deprecated
 * @return {void}
 */
StripeNode.resources.Recipients.prototype.list = function() {};

/**
 * @deprecated
 * @param {string} id
 * @return {void}
 */
StripeNode.resources.Recipients.prototype.update = function(id) {};

/**
 * @deprecated
 * @param {string} id
 * @return {void}
 */
StripeNode.resources.Recipients.prototype.retrieve = function(id) {};

/**
 * @deprecated
 * @param {string} id
 * @return {void}
 */
StripeNode.resources.Recipients.prototype.del = function(id) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.Refunds = function() {};

/**
 * When you create a new refund, you must specify a charge to create it on.
 * 
 * Creating a new refund will refund a charge that has previously been created but not yet refunded.
 * Funds will be refunded to the credit or debit card that was originally charged.
 * The fees you were originally charged are also refunded.
 * 
 * You can optionally refund only part of a charge.
 * You can do so as many times as you wish until the entire charge has been refunded.
 * 
 * Once entirely refunded, a charge can't be refunded again.
 * This method will throw an error when called on an already-refunded charge, or when trying to refund more money than is left on a charge.
 * @param {!StripeNode.refunds.IRefundCreationOptionsWithCharge} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} response
 * @return {!Promise<!StripeNode.refunds.IRefund>}
 */
StripeNode.resources.Refunds.prototype.create = function(data, options_or_response, response) {};

/**
 * Retrieves the details of an existing refund.
 * @param {string} id
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} response
 * @return {!Promise<!StripeNode.refunds.IRefund>}
 */
StripeNode.resources.Refunds.prototype.retrieve = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * Updates the specified refund by setting the values of the parameters passed.
 * Any parameters not provided will be left unchanged.
 * 
 * This request only accepts metadata as an argument.
 * @param {string} id
 * @param {!StripeNode.IDataOptionsWithMetadata} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.refunds.IRefund>=} response
 * @return {!Promise<!StripeNode.refunds.IRefund>}
 */
StripeNode.resources.Refunds.prototype.update = function(id, data, options_or_response, response) {};

/**
 * Returns a list of all refunds youve previously created. The refunds are returned in sorted order,
 * with the most recent refunds appearing first.
 * For convenience, the 10 most recent refunds are always available by default on the charge object.
 * @param {!StripeNode.refunds.IRefundListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.refunds.IRefund>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.refunds.IRefund>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.refunds.IRefund>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.refunds.IRefund>>}
 */
StripeNode.resources.Refunds.prototype.list = function(data_or_options_or_response, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.Tokens = function() {};

/**
 * Creates a single use token that wraps the details of a credit card. This token can be used
 * in place of a credit card object with any API method. These tokens can only be used once:
 * by creating a new charge object, or attaching them to a customer.
 * Creates a single use token that wraps the details of a bank account. This token can be used
 * in place of a bank account object with any API method. These tokens can only be used once:
 * by attaching them to a recipient or managed account.
 * Creates a single use token that wraps the details of personally identifiable information (PII).
 * This token can be used in place of a personal_id_number in the Account Update API method.
 * These tokens can only be used once.
 * @param {!StripeNode.tokens.ICardTokenCreationOptions|!StripeNode.tokens.IBankAccountTokenCreationOptions|!StripeNode.tokens.IPiiTokenCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.tokens.ICardToken>|!StripeNode.IResponseFn<!StripeNode.tokens.IBankAccountToken>|!StripeNode.IResponseFn<!StripeNode.tokens.IToken>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.tokens.ICardToken>|!StripeNode.IResponseFn<!StripeNode.tokens.IBankAccountToken>|!StripeNode.IResponseFn<!StripeNode.tokens.IToken>=} response
 * @return {!Promise<!StripeNode.tokens.ICardToken>|!Promise<!StripeNode.tokens.IBankAccountToken>|!Promise<!StripeNode.tokens.IToken>}
 */
StripeNode.resources.Tokens.prototype.create = function(data, options_or_response, response) {};

/**
 * Retrieves the token with the given ID.
 * @param {string} tokenId
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.tokens.IToken>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.tokens.IToken>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.tokens.IToken>=} response
 * @return {!Promise<!StripeNode.tokens.IToken>}
 */
StripeNode.resources.Tokens.prototype.retrieve = function(tokenId, data_or_options_or_response, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.Transfers = function() {};

/**
 * To send funds from your Stripe account to a third-party recipient or to your own bank account, you create a new transfer
 * object. Your Stripe balance must be able to cover the transfer amount, or you'll receive an "Insufficient Funds" error.
 * 
 * If your API key is in test mode, money won't actually be sent, though everything else will occur as if in live mode.
 * 
 * If you are creating a manual transfer or a special case transfer on a Stripe account that uses multiple payment source
 * types, you'll need to specify the source type balance that the transfer should draw from. The balance object details
 * available and pending amounts by source type.
 * @param {!StripeNode.transfers.ITransferCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transfers.ITransfer>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.transfers.ITransfer>=} response
 * @return {!Promise<!StripeNode.transfers.ITransfer>}
 */
StripeNode.resources.Transfers.prototype.create = function(data, options_or_response, response) {};

/**
 * Retrieves the details of an existing transfer. Supply the unique transfer ID from either a transfer creation request or
 * the transfer list, and Stripe will return the corresponding transfer information.
 * @param {string} id
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transfers.ITransfer>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transfers.ITransfer>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.transfers.ITransfer>=} response
 * @return {!Promise<!StripeNode.transfers.ITransfer>}
 */
StripeNode.resources.Transfers.prototype.retrieve = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * Updates the specified transfer by setting the values of the parameters passed. Any parameters not provided will be left
 * unchanged.
 * 
 * This request accepts only the description and metadata as arguments.
 * @param {string} id
 * @param {!StripeNode.transfers.ITransferUpdateOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transfers.ITransfer>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.transfers.ITransfer>=} response
 * @return {!Promise<!StripeNode.transfers.ITransfer>}
 */
StripeNode.resources.Transfers.prototype.update = function(id, data, options_or_response, response) {};

/**
 * Returns a list of existing transfers sent to third-party bank accounts or that Stripe has sent you. The transfers are
 * returned in sorted order, with the most recently created transfers appearing first.
 * @param {!StripeNode.transfers.ITransferListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.transfers.ITransfer>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.transfers.ITransfer>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.transfers.ITransfer>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.transfers.ITransfer>>}
 */
StripeNode.resources.Transfers.prototype.list = function(data_or_options_or_response, options_or_response, response) {};

/**
 * @param {string} id
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transfers.ITransfer>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.transfers.ITransfer>=} response
 * @return {!Promise<!StripeNode.transfers.ITransfer>}
 */
StripeNode.resources.Transfers.prototype.cancel = function(id, options_or_response, response) {};

/**
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.charges.ICharge>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.charges.ICharge>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.charges.ICharge>>}
 */
StripeNode.resources.Transfers.prototype.listTransactions = function(options_or_response, response) {};

/**
 * When you create a new reversal, you must specify a transfer to create it on.
 * 
 * Creating a new reversal on a transfer that has previously been created but not paid out will return the funds to your available balance
 * and refund the fees you were originally charged on the transfer. You may not reverse automatic Stripe transfers.
 * 
 * When reversing transfers to Stripe accounts, you can optionally reverse part of the transfer. You can do so as many times as you wish
 * until the entire transfer has been reversed.
 * 
 * Once entirely reversed, a transfer can't be reversed again. This method will return an error when called on an already-reversed transfer,
 * or when trying to reverse more money than is left on a transfer.
 * @param {string} id
 * @param {!StripeNode.transferReversals.IReversalCreationOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} response
 * @return {!Promise<!StripeNode.transferReversals.IReversal>}
 */
StripeNode.resources.Transfers.prototype.reverse = function(id, data_or_options_or_response, options_or_response, response) {};

/**
 * When you create a new reversal, you must specify a transfer to create it on.
 * 
 * Creating a new reversal on a transfer that has previously been created but not paid out will return the funds to your available balance
 * and refund the fees you were originally charged on the transfer. You may not reverse automatic Stripe transfers.
 * 
 * When reversing transfers to Stripe accounts, you can optionally reverse part of the transfer. You can do so as many times as you wish
 * until the entire transfer has been reversed.
 * 
 * Once entirely reversed, a transfer can't be reversed again. This method will return an error when called on an already-reversed transfer,
 * or when trying to reverse more money than is left on a transfer.
 * @param {string} transferId
 * @param {!StripeNode.transferReversals.IReversalCreationOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} response
 * @return {!Promise<!StripeNode.transferReversals.IReversal>}
 */
StripeNode.resources.Transfers.prototype.createReverse = function(transferId, data_or_options_or_response, options_or_response, response) {};

/**
 * By default, you can see the 10 most recent reversals stored directly on the transfer object, but you can also retrieve details about a
 * specific reversal stored on the transfer.
 * @param {string} transferId
 * @param {string} reversalId
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} response
 * @return {!Promise<!StripeNode.transferReversals.IReversal>}
 */
StripeNode.resources.Transfers.prototype.retrieveReversal = function(transferId, reversalId, options_or_response, response) {};

/**
 * Updates the specified reversal by setting the values of the parameters passed. Any parameters not provided will be left unchanged.
 * 
 * This request only accepts metadata and description as arguments.
 * @param {string} transferId
 * @param {string} reversalId
 * @param {!StripeNode.transferReversals.IReversalUpdateOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} response
 * @return {!Promise<!StripeNode.transferReversals.IReversal>}
 */
StripeNode.resources.Transfers.prototype.updateReversal = function(transferId, reversalId, data, options_or_response, response) {};

/**
 * You can see a list of the reversals belonging to a specific transfer. Note that the 10 most recent reversals are always available by
 * default on the transfer object. If you need more than those 10, you can use this API method and the limit and starting_after
 * parameters to page through additional reversals.
 * @param {string} transferId
 * @param {!StripeNode.IListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.transferReversals.IReversal>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.transferReversals.IReversal>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.transferReversals.IReversal>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.transferReversals.IReversal>>}
 */
StripeNode.resources.Transfers.prototype.listReversals = function(transferId, data_or_options_or_response, options_or_response, response) {};

/**
 * @return {void}
 */
StripeNode.resources.Transfers.prototype.setMetadata = function() {};

/**
 * @return {void}
 */
StripeNode.resources.Transfers.prototype.getMetadata = function() {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.TransferReversals = function() {};

/**
 * When you create a new reversal, you must specify a transfer to create it on.
 * 
 * Creating a new reversal on a transfer that has previously been created but not paid out will return the funds to your available balance
 * and refund the fees you were originally charged on the transfer. You may not reverse automatic Stripe transfers.
 * 
 * When reversing transfers to Stripe accounts, you can optionally reverse part of the transfer. You can do so as many times as you wish
 * until the entire transfer has been reversed.
 * 
 * Once entirely reversed, a transfer can't be reversed again. This method will return an error when called on an already-reversed transfer,
 * or when trying to reverse more money than is left on a transfer.
 * @param {!StripeNode.transferReversals.IReversalCreationOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} response
 * @return {!Promise<!StripeNode.transferReversals.IReversal>}
 */
StripeNode.resources.TransferReversals.prototype.create = function(data_or_options_or_response, options_or_response, response) {};

/**
 * By default, you can see the 10 most recent reversals stored directly on the transfer object, but you can also retrieve details about a
 * specific reversal stored on the transfer.
 * @param {string} reversalId
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} response
 * @return {!Promise<!StripeNode.transferReversals.IReversal>}
 */
StripeNode.resources.TransferReversals.prototype.retrieve = function(reversalId, data_or_options_or_response, options_or_response, response) {};

/**
 * Updates the specified reversal by setting the values of the parameters passed. Any parameters not provided will be left unchanged.
 * 
 * This request only accepts metadata and description as arguments.
 * @param {string} reversalId
 * @param {!StripeNode.transferReversals.IReversalUpdateOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.transferReversals.IReversal>=} response
 * @return {!Promise<!StripeNode.transferReversals.IReversal>}
 */
StripeNode.resources.TransferReversals.prototype.update = function(reversalId, data, options_or_response, response) {};

/**
 * You can see a list of the reversals belonging to a specific transfer. Note that the 10 most recent reversals are always available by
 * default on the transfer object. If you need more than those 10, you can use this API method and the limit and starting_after
 * parameters to page through additional reversals.
 * @param {!StripeNode.IListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.transferReversals.IReversal>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.transferReversals.IReversal>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.transferReversals.IReversal>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.transferReversals.IReversal>>}
 */
StripeNode.resources.TransferReversals.prototype.list = function(data_or_options_or_response, options_or_response, response) {};
/**
 * @extends {StripeNode.StripeResource}
 * @constructor
 * @struct
 */
StripeNode.resources.CountrySpecs = function() {};

/**
 * Lists all Country Spec objects available in the API.
 * @param {!StripeNode.IListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.countrySpecs.ICountrySpec>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.countrySpecs.ICountrySpec>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.countrySpecs.ICountrySpec>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.countrySpecs.ICountrySpec>>}
 */
StripeNode.resources.CountrySpecs.prototype.list = function(data_or_options_or_response, options_or_response, response) {};

/**
 * Returns a Country Spec for a given Country code.
 * 
 * @param {string} id
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.countrySpecs.ICountrySpec>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.countrySpecs.ICountrySpec>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.countrySpecs.ICountrySpec>=} response
 * @return {!Promise<!StripeNode.countrySpecs.ICountrySpec>}
 */
StripeNode.resources.CountrySpecs.prototype.retrieve = function(id, data_or_options_or_response, options_or_response, response) {};
/**
 * @constructor
 * @struct
 */
StripeNode.resources.Orders = function() {};

/**
 * Creates a new order object.
 * @param {!StripeNode.orders.IOrderCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.orders.IOrder>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.orders.IOrder>=} response
 * @return {!Promise<!StripeNode.orders.IOrder>}
 */
StripeNode.resources.Orders.prototype.create = function(data, options_or_response, response) {};

/**
 * Retrieves the details of an existing order. Supply the unique order ID from either an order creation request or the order list,
 * and Stripe will return the corresponding order information.
 * @param {string} orderId
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.orders.IOrder>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.orders.IOrder>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.orders.IOrder>=} response
 * @return {!Promise<!StripeNode.orders.IOrder>}
 */
StripeNode.resources.Orders.prototype.retrieve = function(orderId, data_or_options_or_response, options_or_response, response) {};

/**
 * Updates the specific order by setting the values of the parameters passed. Any parameters not provided will be left unchanged.
 * This request accepts only the metadata, and status as arguments.
 * @param {string} orderId
 * @param {!StripeNode.orders.IOrderUpdateOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.orders.IOrder>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.orders.IOrder>=} response
 * @return {!Promise<!StripeNode.orders.IOrder>}
 */
StripeNode.resources.Orders.prototype.update = function(orderId, data, options_or_response, response) {};

/**
 * Pay an order by providing a source to create a payment.
 * @param {string} orderId
 * @param {!StripeNode.orders.IOrderPayOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.orders.IOrder>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.orders.IOrder>=} response
 * @return {!Promise<!StripeNode.orders.IOrder>}
 */
StripeNode.resources.Orders.prototype.pay = function(orderId, data, options_or_response, response) {};

/**
 * Returns a list of your orders. The orders are returned sorted by creation date, with the most recently created orders appearing first.
 * @param {!StripeNode.orders.IOrderListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.orders.IOrder>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.orders.IOrder>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.orders.IOrder>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.orders.IOrder>>}
 */
StripeNode.resources.Orders.prototype.list = function(data_or_options_or_response, options_or_response, response) {};
/**
 * @constructor
 * @struct
 */
StripeNode.resources.Products = function() {};

/**
 * Creates a new product object.
 * @param {!StripeNode.products.IProductCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.products.IProduct>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.products.IProduct>=} response
 * @return {!Promise<!StripeNode.products.IProduct>}
 */
StripeNode.resources.Products.prototype.create = function(data, options_or_response, response) {};

/**
 * Retrieves the details of an existing product. Supply the unique product ID from either a product creation request or the product
 * list, and Stripe will return the corresponding product information.
 * @param {string} productId
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.products.IProduct>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.products.IProduct>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.products.IProduct>=} response
 * @return {!Promise<!StripeNode.products.IProduct>}
 */
StripeNode.resources.Products.prototype.retrieve = function(productId, data_or_options_or_response, options_or_response, response) {};

/**
 * Updates the specific product by setting the values of the parameters passed. Any parameters not provided will be left unchanged.
 * 
 * Note that a product's attributes are not editable. Instead, you would need to deactivate the existing product and create a new one
 * with the new attribute values.
 * @param {string} productId
 * @param {!StripeNode.products.IProductUpdateOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.products.IProduct>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.products.IProduct>=} response
 * @return {!Promise<!StripeNode.products.IProduct>}
 */
StripeNode.resources.Products.prototype.update = function(productId, data, options_or_response, response) {};

/**
 * Returns a list of your products. The products are returned sorted by creation date, with the most recently created products appearing first.
 * @param {!StripeNode.products.IProductListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.products.IProduct>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.products.IProduct>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.products.IProduct>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.products.IProduct>>}
 */
StripeNode.resources.Products.prototype.list = function(data_or_options_or_response, options_or_response, response) {};

/**
 * Delete a product. Deleting a product is only possible if it has no SKUs associated with it.
 * @param {string} productId
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} response
 * @return {!Promise<!StripeNode.IDeleteConfirmation>}
 */
StripeNode.resources.Products.prototype.del = function(productId, options_or_response, response) {};
/**
 * @constructor
 * @struct
 */
StripeNode.resources.SKUs = function() {};

/**
 * Creates a new SKU associated with a product.
 * @param {!StripeNode.skus.ISkuCreationOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.skus.ISku>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.skus.ISku>=} response
 * @return {!Promise<!StripeNode.skus.ISku>}
 */
StripeNode.resources.SKUs.prototype.create = function(data, options_or_response, response) {};

/**
 * Retrieves the details of an existing SKU. Supply the unique SKU identifier from either a SKU creation request or from the
 * product, and Stripe will return the corresponding SKU information.
 * @param {string} skuId
 * @param {!StripeNode.IDataOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.skus.ISku>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.skus.ISku>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.skus.ISku>=} response
 * @return {!Promise<!StripeNode.skus.ISku>}
 */
StripeNode.resources.SKUs.prototype.retrieve = function(skuId, data_or_options_or_response, options_or_response, response) {};

/**
 * Updates the specific SKU by setting the values of the parameters passed. Any parameters not provided will be left unchanged.
 * 
 * Note that a SKU's attributes are not editable. Instead, you would need to deactivate the existing SKU and create a new one with
 * the new attribute values.
 * @param {string} skuId
 * @param {!StripeNode.skus.ISkuUpdateOptions} data
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.skus.ISku>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.skus.ISku>=} response
 * @return {!Promise<!StripeNode.skus.ISku>}
 */
StripeNode.resources.SKUs.prototype.update = function(skuId, data, options_or_response, response) {};

/**
 * Returns a list of your SKUs. The SKUs are returned sorted by creation date, with the most recently created SKUs appearing first.
 * @param {!StripeNode.skus.ISkuListOptions|(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.skus.ISku>>=} data_or_options_or_response
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.skus.ISku>>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IList<!StripeNode.skus.ISku>>=} response
 * @return {!Promise<!StripeNode.IList<!StripeNode.skus.ISku>>}
 */
StripeNode.resources.SKUs.prototype.list = function(data_or_options_or_response, options_or_response, response) {};

/**
 * Delete a SKU. Deleting a SKU is only possible until it has been used in an order.
 * @param {string} skuId
 * @param {(string|!StripeNode.IHeaderOptions)|!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} options_or_response
 * @param {!StripeNode.IResponseFn<!StripeNode.IDeleteConfirmation>=} response
 * @return {!Promise<!StripeNode.IDeleteConfirmation>}
 */
StripeNode.resources.SKUs.prototype.del = function(skuId, options_or_response, response) {};
/**
 * @record
 * @struct
 */
StripeNode.IObject = function() {};
 /** @type {string} */
StripeNode.IObject.prototype.object;
/**
 * @extends {StripeNode.IObject}
 * @record
 * @struct
 */
StripeNode.IResourceObject = function() {};
 /** @type {string} */
StripeNode.IResourceObject.prototype.id;
/**
 * @record
 * @struct
 */
StripeNode.IResponseFn = function() {};

/* TODO: CallSignature: StripeNode */
/**
 * @record
 * @struct
 */
StripeNode.IDeleteConfirmation = function() {};
 /** @type {string} */
StripeNode.IDeleteConfirmation.prototype.id;
 /** @type {boolean} */
StripeNode.IDeleteConfirmation.prototype.deleted;

/** @typedef {(string|{gt: string, gte: string, lt: string, lte: string})} */
StripeNode.IDateFilter;
/**
 * @record
 * @struct
 */
StripeNode.IMetadata = function() {};
/**
 * @record
 * @struct
 */
StripeNode.IShippingInformation = function() {};
 /** @type {{line1: string, line2: string, city: string, state: string, postal_code: string, country: string}} */
StripeNode.IShippingInformation.prototype.address;
 /** @type {string} */
StripeNode.IShippingInformation.prototype.name;
 /** @type {string} */
StripeNode.IShippingInformation.prototype.carrier;
 /** @type {string} */
StripeNode.IShippingInformation.prototype.phone;
 /** @type {string} */
StripeNode.IShippingInformation.prototype.tracking_number;
/**
 * @record
 * @struct
 */
StripeNode.IList = function() {};
 /** @type {string} */
StripeNode.IList.prototype.object;
 /** @type {!Array<T>} */
StripeNode.IList.prototype.data;
 /** @type {boolean} */
StripeNode.IList.prototype.has_more;
 /** @type {string} */
StripeNode.IList.prototype.url;
 /** @type {number} */
StripeNode.IList.prototype.total_count;
/**
 * @extends {StripeNode.IDataOptions}
 * @record
 * @struct
 */
StripeNode.IListOptions = function() {};
 /** @type {string} */
StripeNode.IListOptions.prototype.ending_before;
 /** @type {number} */
StripeNode.IListOptions.prototype.limit;
 /** @type {string} */
StripeNode.IListOptions.prototype.starting_after;
/**
 * @extends {StripeNode.IListOptions}
 * @record
 * @struct
 */
StripeNode.IListOptionsCreated = function() {};
 /** @type {(string|{gt: string, gte: string, lt: string, lte: string})} */
StripeNode.IListOptionsCreated.prototype.created;
/**
 * @record
 * @struct
 */
StripeNode.IDataOptions = function() {};
 /** @type {!Array<string>} */
StripeNode.IDataOptions.prototype.expand;
 /** @type {!Array<string>} */
StripeNode.IDataOptions.prototype.include;
/**
 * @extends {StripeNode.IDataOptions}
 * @record
 * @struct
 */
StripeNode.IDataOptionsWithMetadata = function() {};
 /** @type {!StripeNode.IMetadata} */
StripeNode.IDataOptionsWithMetadata.prototype.metadata;
/**
 * @record
 * @struct
 */
StripeNode.IHeaderOptions = function() {};
 /** @type {string} */
StripeNode.IHeaderOptions.prototype.idempotency_key;
 /** @type {string} */
StripeNode.IHeaderOptions.prototype.stripe_account;
 /** @type {string} */
StripeNode.IHeaderOptions.prototype.api_key;

/** @typedef {(string|!StripeNode.IHeaderOptions)} */
StripeNode.HeaderOptions;
/**
 * @record
 * @struct
 */
StripeNode.IStripeError = function() {};
 /** @type {string} */
StripeNode.IStripeError.prototype.type;
 /** @type {string} */
StripeNode.IStripeError.prototype.message;
 /** @type {string} */
StripeNode.IStripeError.prototype.code;
 /** @type {string} */
StripeNode.IStripeError.prototype.param;
