/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/bigint/index.d.ts:
/** @const */
var BigInt = {};
/**
 * @record
 * @struct
 */
BigInt.BigInt = function() {};
/**
 * @record
 * @struct
 */
BigInt.IRandom = function() {};

/* TODO: CallSignature: BigInt */

/**
 * Sets a random number generator.
 * 
 * @param {!BigInt.IRandom} random
 * @return {void}
 */
BigInt.setRandom = function(random) {};

/**
 * return (x+y) for bigInts x and y.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @return {!BigInt.BigInt}
 */
BigInt.add = function(x, y) {};

/**
 * return (x+n) where x is a bigInt and n is an integer.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {number} n
 * @return {!BigInt.BigInt}
 */
BigInt.addInt = function(x, n) {};

/**
 * return a string form of bigInt x in a given base, with 2 <= base <= 95.
 * 
 * 
 * return a string form of bigInt x in a given base, with 2 <= base <= 95.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {number|string} base
 * @return {string}
 */
BigInt.bigInt2str = function(x, base) {};

/**
 * return how many bits long the bigInt x is, not counting leading zeros.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @return {number}
 */
BigInt.bitSize = function(x) {};

/**
 * return a copy of bigInt x.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @return {!BigInt.BigInt}
 */
BigInt.dup = function(x) {};

/**
 * is the bigInt x equal to the bigint y?
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @return {boolean}
 */
BigInt.equals = function(x, y) {};

/**
 * is bigint x equal to integer y?
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {number} y
 * @return {boolean}
 */
BigInt.equalsInt = function(x, y) {};

/**
 * return a copy of x with at least n elements, adding leading zeros if needed.
 * 
 * 
 * @param {!BigInt.BigInt} value
 * @param {number} n
 * @return {!BigInt.BigInt}
 */
BigInt.expand = function(value, n) {};

/**
 * return array of all primes less than integer n.
 * 
 * 
 * @param {number} n
 * @return {!Array<number>}
 */
BigInt.findPrimes = function(n) {};

/**
 * return greatest common divisor of bigInts x and y (each with same number of elements).
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @return {!BigInt.BigInt}
 */
BigInt.GCD = function(x, y) {};

/**
 * is x>y?  (x and y are nonnegative bigInts)
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @return {boolean}
 */
BigInt.greater = function(x, y) {};

/**
 * is (x <<(shift*bpe)) > y?
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @param {number} shift
 * @return {boolean}
 */
BigInt.greaterShift = function(x, y, shift) {};

/**
 * return a bigInt equal to integer t, with at least n bits and m array elements.
 * 
 * 
 * @param {number} t
 * @param {number=} n
 * @param {number=} m
 * @return {!BigInt.BigInt}
 */
BigInt.int2bigInt = function(t, n, m) {};

/**
 * return (x**(-1) mod n) for bigInts x and n. If no inverse exists, it returns null.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} n
 * @return {!BigInt.BigInt}
 */
BigInt.inverseMod = function(x, n) {};

/**
 * return x**(-1) mod n, for integers x and n.
 * Return 0 if there is no inverse.
 * 
 * 
 * @param {number} x
 * @param {number} n
 * @return {!BigInt.BigInt}
 */
BigInt.inverseModInt = function(x, n) {};

/**
 * is the bigInt x equal to zero?
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @return {boolean}
 */
BigInt.isZero = function(x) {};

/**
 * does one round of Miller-Rabin base integer b say that bigInt x is possibly prime?
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} b
 * @return {boolean}
 */
BigInt.millerRabin = function(x, b) {};

/**
 * does one round of Miller-Rabin base integer b say that bigInt x is possibly prime?
 * 
 * 
 * @param {number} x
 * @param {number} b
 * @return {boolean}
 */
BigInt.millerRabinInt = function(x, b) {};

/**
 * return a new bigInt equal to (x mod n) for bigInts x and n.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} n
 * @return {!BigInt.BigInt}
 */
BigInt.mod = function(x, n) {};

/**
 * return x mod n for bigInt x and integer n.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {number} n
 * @return {number}
 */
BigInt.modInt = function(x, n) {};

/**
 * return x*y for bigInts x and y. This is faster when y<x.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @return {!BigInt.BigInt}
 */
BigInt.mult = function(x, y) {};

/**
 * return (x*y mod n) for bigInts x,y,n. For greater speed, let y<x.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @param {!BigInt.BigInt} n
 * @return {!BigInt.BigInt}
 */
BigInt.multMod = function(x, y, n) {};

/**
 * is bigInt x negative?
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @return {boolean}
 */
BigInt.negative = function(x) {};

/**
 * return (x**y mod n) where x,y,n are bigInts and ** is exponentiation.
 *  0**0=1. Faster for odd n.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @param {!BigInt.BigInt} n
 * @return {!BigInt.BigInt}
 */
BigInt.powMod = function(x, y, n) {};

/**
 * return an n-bit random BigInt (n>=1).
 *  If s=1, then the most significant of those n bits is set to 1.
 * 
 * 
 * @param {number} n
 * @param {number} s
 * @return {!BigInt.BigInt}
 */
BigInt.randBigInt = function(n, s) {};

/**
 * return a new, random, k-bit, true prime bigInt using Maurer's algorithm.
 * 
 * 
 * @param {number} k
 * @return {!BigInt.BigInt}
 */
BigInt.randTruePrime = function(k) {};

/**
 * return a new, random, k-bit, probable prime bigInt.
 *  Probability it's composite less than 2^- 80.
 * 
 * 
 * @param {number} k
 * @return {!BigInt.BigInt}
 */
BigInt.randProbPrime = function(k) {};

/**
 * return a bigInt for number represented in string s in base b with at least n bits and m array
 * elements.
 * 
 * 
 * return a bigInt for number represented in string s in base b with at least n bits and m array
 * elements.
 * 
 * 
 * @param {string} s
 * @param {number|string} b
 * @param {number=} n
 * @param {number=} m
 * @return {!BigInt.BigInt}
 */
BigInt.str2bigInt = function(s, b, n, m) {};

/**
 * return (x-y) for bigInts x and y.
 *  Negative answers will be 2s complement.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @return {!BigInt.BigInt}
 */
BigInt.sub = function(x, y) {};

/**
 * return a copy of x with exactly k leading zero elements.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {number} k
 * @return {!BigInt.BigInt}
 */
BigInt.trim = function(x, k) {};

/**
 * do x=x+n where x is a bigInt and n is an integer.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {number} n
 * @return {void}
 */
BigInt.addInt_ = function(x, n) {};

/**
 * do x=x+y for bigInts x and y.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @return {void}
 */
BigInt.add_ = function(x, y) {};

/**
 * do x=y on bigInts x and y.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @return {void}
 */
BigInt.copy_ = function(x, y) {};

/**
 * do x=n on bigInt x and integer n.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {number} n
 * @return {void}
 */
BigInt.copyInt_ = function(x, n) {};

/**
 * set x to the greatest common divisor of bigInts x and y, (y is destroyed).
 *  This never overflows its array.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @return {void}
 */
BigInt.GCD_ = function(x, y) {};

/**
 * do x=x**(-1) mod n, for bigInts x and n. Returns 1 (0) if inverse does (doesn't) exist.
 * 
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} n
 * @return {boolean}
 */
BigInt.inverseMod_ = function(x, n) {};

/**
 * do x=x mod n for bigInts x and n. (This never overflows its array).
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} n
 * @return {void}
 */
BigInt.mod_ = function(x, n) {};

/**
 * do x=x*y for bigInts x and y.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @return {void}
 */
BigInt.mult_ = function(x, y) {};

/**
 * do x=x*y mod n for bigInts x,y,n.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @param {!BigInt.BigInt} n
 * @return {void}
 */
BigInt.multMod_ = function(x, y, n) {};

/**
 * do x=x**y mod n, where x,y,n are bigInts (n is odd) and ** is exponentiation.
 *  0**0=1.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @param {!BigInt.BigInt} n
 * @return {void}
 */
BigInt.powMod_ = function(x, y, n) {};

/**
 * do b = an n-bit random BigInt.
 *  if s=1, then nth bit (most significant bit) is set to 1. n>=1.
 * 
 * 
 * @param {!BigInt.BigInt} b
 * @param {number} n
 * @param {number} s
 * @return {void}
 */
BigInt.randBigInt_ = function(b, n, s) {};

/**
 * do ans = a random k-bit true random prime (not just probable prime) with 1 in the msb.
 * 
 * 
 * @param {!BigInt.BigInt} ans
 * @param {number} k
 * @return {void}
 */
BigInt.randTruePrime_ = function(ans, k) {};

/**
 * do x=x-y for bigInts x and y. Negative answers will be 2s complement.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @return {void}
 */
BigInt.sub_ = function(x, y) {};

/**
 * do x=x+(y<<(ys*bpe))
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @param {number} ys
 * @return {void}
 */
BigInt.addShift_ = function(x, y, ys) {};

/**
 * do carries and borrows so each element of the bigInt x fits in bpe bits.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @return {void}
 */
BigInt.carry_ = function(x) {};

/**
 * divide x by y giving quotient q and remainder r.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @param {!BigInt.BigInt} q
 * @param {!BigInt.BigInt} r
 * @return {void}
 */
BigInt.divide_ = function(x, y, q, r) {};

/**
 * do x=floor(x/n) for bigInt x and integer n, and return the remainder.
 *  This never overflows its array.
 * 
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {number} n
 * @return {number}
 */
BigInt.divInt_ = function(x, n) {};

/**
 * sets a,b,d to positive bigInts such that d = GCD_(x,y) = a*x-b*y.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @param {!BigInt.BigInt} d
 * @param {!BigInt.BigInt} a
 * @param {!BigInt.BigInt} b
 * @return {void}
 */
BigInt.eGCD_ = function(x, y, d, a, b) {};

/**
 * do x=floor(|x|/2)*sgn(x) for bigInt x in 2's complement.
 *  This never overflows its array.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @return {void}
 */
BigInt.halve_ = function(x) {};

/**
 * left shift bigInt x by n bits.  n<bpe.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {number} n
 * @return {void}
 */
BigInt.leftShift_ = function(x, n) {};

/**
 * do x=a*x+b*y for bigInts x and y and integers a and b.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @param {number} a
 * @param {number} b
 * @return {void}
 */
BigInt.linComb_ = function(x, y, a, b) {};

/**
 * do x=x+b*(y<<(ys*bpe)) for bigInts x and y, and integers b and ys.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @param {number} b
 * @param {number} ys
 * @return {void}
 */
BigInt.linCombShift_ = function(x, y, b, ys) {};

/**
 * Montgomery multiplication (see comments where the function is defined)
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @param {!BigInt.BigInt} n
 * @param {number} np
 * @return {void}
 */
BigInt.mont_ = function(x, y, n, np) {};

/**
 * do x=x*n where x is a bigInt and n is an integer.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {number} n
 * @return {void}
 */
BigInt.multInt_ = function(x, n) {};

/**
 * right shift bigInt x by n bits.  0 <= n < bpe.
 *  This never overflows its array.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {number} n
 * @return {void}
 */
BigInt.rightShift_ = function(x, n) {};

/**
 * do x=x*x mod n for bigInts x,n.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} n
 * @return {void}
 */
BigInt.squareMod_ = function(x, n) {};

/**
 * do x=x-(y<<(ys*bpe)). Negative answers will be 2s complement.
 * 
 * 
 * @param {!BigInt.BigInt} x
 * @param {!BigInt.BigInt} y
 * @param {number} ys
 * @return {void}
 */
BigInt.subShift_ = function(x, y, ys) {};
