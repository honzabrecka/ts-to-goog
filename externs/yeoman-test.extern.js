/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/yeoman-test/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */
/**
 * @record
 * @struct
 */
function Dictionary() {}

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function Constructor() {}

/* TODO: ConstructSignature:  */

/** @typedef {(string|!Array<?>)} */
var Dependency;

/**
 * Create a function that will clean up the test directory,
 * cd into it, and create a dummy gruntfile inside. Intended for use
 * as a callback for the mocha `before` hook.
 * 
 * @param {string} dir
 * @return {?}
 */
function setUpTestDirectory(dir) {}

/**
 * 
 * Generates a new Gruntfile.js in the current working directory based on
 * options hash passed in.
 * 
 * @param {?} options
 * @param {?} done
 * @return {void}
 */
function gruntfile(options, done) {}

/**
 * Clean-up the test directory and cd into it.
 * Call given callback after entering the test directory.
 * \@example 
 * testDirectory(path.join(__dirname, './temp'), function () {
 *   fs.writeFileSync('testfile', 'Roses are red.');
 * });
 * @param {string} dir
 * @param {?} cb
 * @return {void}
 */
function testDirectory(dir, cb) {}

/**
 * Answer prompt questions for the passed-in generator
 *   generators prompt names and values are the answers to
 *   the prompt questions
 * \@example 
 * mockPrompt(angular, {'bootstrap': 'Y', 'compassBoostrap': 'Y'});
 * @param {!Base} generator
 * @param {?} answers
 * @return {void}
 */
function mockPrompt(generator, answers) {}

/**
 * Restore defaults prompts on a generator.
 * @param {!Base} generator
 * @return {void}
 */
function restorePrompt(generator) {}

/**
 * Provide mocked values to the config
 * @param {!Base} generator
 * @param {?} localConfig
 * @return {void}
 */
function mockLocalConfig(generator, localConfig) {}

/**
 * Create a simple, dummy generator
 * @return {!Base}
 */
function createDummyGenerator() {}

/**
 * Create a generator, using the given dependencies and controller arguments
 * Dependecies can be path (autodiscovery) or an array [<generator>, <name>]
 * 
 *   if String, will be split on spaces to create an Array
 * \@example 
 *  var deps = ['../../app',
 *              '../../common',
 *              '../../controller',
 *              '../../main',
 *              [createDummyGenerator(), 'testacular:app']
 *            ];
 * var angular = createGenerator('angular:app', deps);
 * @param {string} name
 * @param {!Array<(string|!Array<?>)>} dependencies
 * @param {(string|!Array<string>)=} args
 * @param {?=} options
 * @return {!Base}
 */
function createGenerator(name, dependencies, args, options) {}

/**
 * Register a list of dependent generators into the provided env.
 * Dependecies can be path (autodiscovery) or an array [<generator>, <name>]
 * 
 * @param {?} env
 * @param {!Array<(string|!Array<?>)>} dependencies
 * @return {void}
 */
function registerDependencies(env, dependencies) {}

/**
 * Run the provided Generator
 * @param {(string|?)} GeneratorOrNamespace
 * @param {?=} settings
 * @return {?}
 */
function run(GeneratorOrNamespace, settings) {}
/**
 * @record
 * @struct
 */
function RunContextSettings() {}
 /** @type {boolean} */
RunContextSettings.prototype.tmpdir;
/**
 * @record
 * @struct
 */
function RunContextConstructor() {}

/* TODO: ConstructSignature:  */
/**
 * @record
 * @struct
 */
function RunContext() {}
 /** @type {function(function(string): (TResult1|!PromiseLike<TResult1>), function(?): (TResult2|!PromiseLike<TResult2>)): !Promise<(TResult1|TResult2)>} */
RunContext.prototype.then;
 /** @type {function(function(?): (TResult|!PromiseLike<TResult>)): !Promise<(string|TResult)>} */
RunContext.prototype.catch;

/**
 * Hold the execution until the returned callback is triggered
 * @return {?}
 */
RunContext.prototype.async = function() {};

/**
 * Return a promise representing the generator run process
 * @return {!Promise<string>}
 */
RunContext.prototype.toPromise = function() {};

/**
 * Clean the provided directory, then change directory into it
 *                            file path for predictable results
 * @param {string} dirPath
 * @param {?} cb
 * @return {?}
 */
RunContext.prototype.inDir = function(dirPath, cb) {};

/**
 * Change directory without deleting directory content.
 *                            file path for predictable results
 * @param {string} dirPath
 * @return {?}
 */
RunContext.prototype.cd = function(dirPath) {};

/**
 * Cleanup a temporary directy and change the CWD into it
 * 
 * This method is called automatically when creating a RunContext. Only use it if you need
 * to use the callback.
 * 
 * @param {?} cb
 * @return {?}
 */
RunContext.prototype.inTmpDir = function(cb) {};

/**
 * Clean the directory used for tests inside inDir/inTmpDir
 * @return {void}
 */
RunContext.prototype.cleanTestDirectory = function() {};

/**
 * Provide arguments to the run context
 * @param {(string|!Array<string>)} args
 * @return {?}
 */
RunContext.prototype.withArguments = function(args) {};

/**
 * Provide options to the run context
 * @param {?} options
 * @return {?}
 */
RunContext.prototype.withOptions = function(options) {};

/**
 * Mock the prompt with dummy answers
 * @param {?} answers
 * @return {?}
 */
RunContext.prototype.withPrompts = function(answers) {};

/**
 * Provide dependent generators
 * \@example 
 * var angular = new RunContext('../../app');
 * angular.withGenerators([
 *   '../../common',
 *   '../../controller',
 *   '../../main',
 *   [helpers.createDummyGenerator(), 'testacular:app']
 * ]);
 * angular.on('end', function () {
 *   // assert something
 * });
 * @param {!Array<(string|!Array<?>)>} dependencies
 * @return {?}
 */
RunContext.prototype.withGenerators = function(dependencies) {};

/**
 * Mock the local configuration with the provided config
 * @param {?} localConfig
 * @return {?}
 */
RunContext.prototype.withLocalConfig = function(localConfig) {};

/* TODO: ExportDeclaration in  */
