/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/ramda/index.d.ts:
 /** @type {!R.Static} */
var R;

/** @typedef {(string|number|boolean)} */
R.Ord;

/** @typedef {!Array<(string|number)>} */
R.Path;
/**
 * @record
 * @struct
 */
R.Functor = function() {};

/**
 * @template U
 * @param {function(T): U} fn
 * @return {!R.Functor<U>}
 */
R.Functor.prototype.map = function(fn) {};
/**
 * @record
 * @struct
 */
R.KeyValuePair = function() {};

/* TODO: PropertySignature: R.0 */

/* TODO: PropertySignature: R.1 */
/**
 * @record
 * @struct
 */
R.ArrayLike = function() {};
 /** @type {number} */
R.ArrayLike.prototype.nodeType;

/** @typedef {function(): ?} */
R.Arity0Fn;

/** @typedef {function(?): ?} */
R.Arity1Fn;

/** @typedef {function(?, ?): ?} */
R.Arity2Fn;
/**
 * @record
 * @struct
 */
R.ObjFunc = function() {};

/* TODO: IndexSignature: R */
/**
 * @record
 * @struct
 */
R.ObjFunc2 = function() {};

/* TODO: IndexSignature: R */

/** @typedef {function(!Array<?>): boolean} */
R.Pred;

/** @typedef {function(?, string): boolean} */
R.ObjPred;
/**
 * @record
 * @struct
 */
R.Dictionary = function() {};

/* TODO: IndexSignature: R */
/**
 * @record
 * @struct
 */
R.CharList = function() {};

/**
 * @param {string} x
 * @return {void}
 */
R.CharList.prototype.push = function(x) {};
/**
 * @record
 * @struct
 */
R.Lens = function() {};

/* TODO: CallSignature: R */

/**
 * @template T, U
 * @param {string} str
 * @param {T} obj
 * @return {U}
 */
R.Lens.prototype.set = function(str, obj) {};

/** @typedef {(function(T): T|?)} */
R.Evolver;
/**
 * @record
 * @struct
 */
R.CurriedTypeGuard2 = function() {};

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */
/**
 * @record
 * @struct
 */
R.CurriedTypeGuard3 = function() {};

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */
/**
 * @record
 * @struct
 */
R.CurriedTypeGuard4 = function() {};

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */
/**
 * @record
 * @struct
 */
R.CurriedTypeGuard5 = function() {};

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */
/**
 * @record
 * @struct
 */
R.CurriedTypeGuard6 = function() {};

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */
/**
 * @record
 * @struct
 */
R.CurriedFunction2 = function() {};

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */
/**
 * @record
 * @struct
 */
R.CurriedFunction3 = function() {};

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */
/**
 * @record
 * @struct
 */
R.CurriedFunction4 = function() {};

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */
/**
 * @record
 * @struct
 */
R.CurriedFunction5 = function() {};

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */
/**
 * @record
 * @struct
 */
R.CurriedFunction6 = function() {};

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */

/* TODO: CallSignature: R */
/**
 * @record
 * @struct
 */
R.Reduced = function() {};

/* TODO: IndexSignature: R */

/* TODO: IndexSignature: R */
/**
 * @record
 * @struct
 */
R.Static = function() {};

/**
 * Adds two numbers (or strings). Equivalent to a + b but curried.
 * @param {number|string} a
 * @param {number|string=} b
 * @return {number|string|function(number): number|function(string): string}
 */
R.Static.prototype.add = function(a, b) {};

/**
 * Creates a new list iteration function from an existing one by adding two new parameters to its callback
 * function: the current index, and the entire list.
 * @template T, U
 * @param {function(function(T): U, !Array<T>): !Array<U>|function(function(T): void, !Array<T>): !Array<T>|function(function(U, T): U, U, !Array<T>): U} fn
 * @return {!R.CurriedFunction2<function(T, number, !Array<T>): U, !Array<T>, !Array<U>>|!R.CurriedFunction2<function(T, number, !Array<T>): void, !Array<T>, !Array<T>>|!R.CurriedFunction3<function(U, T, number, !Array<T>): U, U, !Array<T>, U>}
 */
R.Static.prototype.addIndex = function(fn) {};

/**
 * Applies a function to the value at the given index of an array, returning a new copy of the array with the
 * element at the given index replaced with the result of the function application.
 * @template T
 * @param {function(T): T} fn
 * @param {number} index
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.adjust = function(fn, index, list) {};

/**
 * Returns true if all elements of the list match the predicate, false if there are any that don't.
 * @template T
 * @param {function(T): boolean} fn
 * @param {!Array<T>=} list
 * @return {boolean|function(!Array<T>): boolean}
 */
R.Static.prototype.all = function(fn, list) {};

/**
 * Given a list of predicates, returns a new predicate that will be true exactly when all of them are.
 * @param {!Array<function(!Array<?>): boolean>} preds
 * @return {function(!Array<?>): boolean}
 */
R.Static.prototype.allPass = function(preds) {};

/**
 * Returns a function that always returns the given value.
 * @template T
 * @param {T} val
 * @return {function(): T}
 */
R.Static.prototype.always = function(val) {};

/**
 * A function that returns the first argument if it's falsy otherwise the second argument. Note that this is
 * NOT short-circuited, meaning that if expressions are passed they are both evaluated.
 * @template T
 * @param {T} fn1
 * @param {?=} val2
 * @return {boolean|function(?): boolean}
 */
R.Static.prototype.and = function(fn1, val2) {};

/**
 * Returns true if at least one of elements of the list match the predicate, false otherwise.
 * @template T
 * @param {function(T): boolean} fn
 * @param {!Array<T>=} list
 * @return {boolean|function(!Array<T>): boolean}
 */
R.Static.prototype.any = function(fn, list) {};

/**
 * Given a list of predicates returns a new predicate that will be true exactly when any one of them is.
 * @param {!Array<function(!Array<?>): boolean>} preds
 * @return {function(!Array<?>): boolean}
 */
R.Static.prototype.anyPass = function(preds) {};

/**
 * ap applies a list of functions to a list of values.
 * @template T, U
 * @param {!Array<function(T): U>} fns
 * @param {!Array<T>=} vs
 * @return {!Array<U>|function(!Array<T>): !Array<U>}
 */
R.Static.prototype.ap = function(fns, vs) {};

/**
 * Returns a new list, composed of n-tuples of consecutive elements If n is greater than the length of the list,
 * an empty list is returned.
 * @template T
 * @param {number} n
 * @param {!Array<T>=} list
 * @return {!Array<!Array<T>>|function(!Array<T>): !Array<!Array<T>>}
 */
R.Static.prototype.aperture = function(n, list) {};

/**
 * Returns a new list containing the contents of the given list, followed by the given element.
 * @template T, U
 * @param {U} el
 * @param {!Array<T>=} list
 * @return {!Array<?>|function(!Array<T>): !Array<?>}
 */
R.Static.prototype.append = function(el, list) {};

/**
 * Applies function fn to the argument list args. This is useful for creating a fixed-arity function from
 * a variadic function. fn should be a bound function if context is significant.
 * @template T, U, TResult
 * @param {function(T, !Array<T>): TResult} fn
 * @param {!Array<U>=} args
 * @return {TResult|function(!Array<U>): TResult}
 */
R.Static.prototype.apply = function(fn, args) {};

/**
 * Given a spec object recursively mapping properties to functions, creates a function producing an object
 * of the same structure, by mapping each property to the result of calling its associated function with
 * the supplied arguments.
 * @template T
 * @param {?} obj
 * @return {function(!Array<?>): T}
 */
R.Static.prototype.applySpec = function(obj) {};

/**
 * Makes an ascending comparator function out of a function that returns a value that can be compared with < and >.
 * @template T
 * @param {function(T): ?} fn
 * @param {T=} a
 * @param {T=} b
 * @return {number|function(T, T): number}
 */
R.Static.prototype.ascend = function(fn, a, b) {};

/**
 * Makes a shallow clone of an object, setting or overriding the specified property with the given value.
 * @template T, U, K
 * @param {K} prop
 * @param {T=} val
 * @param {U=} obj
 * @return {?|function(T, U): ?|function(U): ?}
 */
R.Static.prototype.assoc = function(prop, val, obj) {};

/**
 * Makes a shallow clone of an object, setting or overriding the nodes required to create the given path, and
 * placing the specific value at the tail end of that path.
 * @template T, U
 * @param {!Array<(string|number)>} path
 * @param {T=} val
 * @param {U=} obj
 * @return {U|function(U): U|!R.CurriedFunction2<T, U, U>}
 */
R.Static.prototype.assocPath = function(path, val, obj) {};

/**
 * Wraps a function of any arity (including nullary) in a function that accepts exactly 2
 * parameters. Any extraneous parameters will not be passed to the supplied function.
 * @param {function(!Array<?>): ?} fn
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.binary = function(fn) {};

/**
 * Creates a function that is bound to a context. Note: R.bind does not provide the additional argument-binding
 * capabilities of Function.prototype.bind.
 * @template T
 * @param {T} thisObj
 * @param {function(!Array<?>): ?} fn
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.bind = function(thisObj, fn) {};

/**
 * A function wrapping calls to the two functions in an && operation, returning the result of the first function
 * if it is false-y and the result of the second function otherwise. Note that this is short-circuited, meaning
 * that the second function will not be invoked if the first returns a false-y value.
 * @param {function(!Array<?>): boolean} pred1
 * @param {function(!Array<?>): boolean=} pred2
 * @return {function(!Array<?>): boolean|function(function(!Array<?>): boolean): ?}
 */
R.Static.prototype.both = function(pred1, pred2) {};

/**
 * Returns the result of calling its first argument with the remaining arguments. This is occasionally useful
 * as a converging function for R.converge: the left branch can produce a function while the right branch
 * produces a value to be passed to that function as an argument.
 * @param {function(!Array<?>): function(!Array<?>): ?} fn
 * @param {...?} args
 * @return {?}
 */
R.Static.prototype.call = function(fn, args) {};

/**
 * `chain` maps a function over a list and concatenates the results.
 * This implementation is compatible with the Fantasy-land Chain spec
 * @template T, U
 * @param {function(T): !Array<U>} fn
 * @param {!Array<T>=} list
 * @return {!Array<U>|function(!Array<T>): !Array<U>}
 */
R.Static.prototype.chain = function(fn, list) {};

/**
 * Restricts a number to be within a range.
 * Also works for other ordered types such as Strings and Date
 * @template T
 * @param {T} min
 * @param {T=} max
 * @param {T=} value
 * @return {T|function(T): T|function(T, T): T|function(T): function(T): T}
 */
R.Static.prototype.clamp = function(min, max, value) {};

/**
 * Creates a deep copy of the value which may contain (nested) Arrays and Objects, Numbers, Strings, Booleans and Dates.
 * @template T
 * @param {T|!Array<T>} value
 * @return {T|!Array<T>}
 */
R.Static.prototype.clone = function(value) {};

/**
 * @template T
 * @param {function(T, T): boolean} pred
 * @return {function(T, T): number}
 */
R.Static.prototype.comparator = function(pred) {};

/**
 * Takes a function f and returns a function g such that:
 * - applying g to zero or more arguments will give true if applying the same arguments to f gives
 *   a logical false value; and
 * - applying g to zero or more arguments will give false if applying the same arguments to f gives
 *   a logical true value.
 * @param {function(!Array<?>): boolean} pred
 * @return {function(!Array<?>): boolean}
 */
R.Static.prototype.complement = function(pred) {};

/**
 * Performs right-to-left function composition. The rightmost function may have any arity; the remaining
 * functions must be unary.
 * @template V0, T1, V1, V2, T2, T3, T4, T5, T6
 * @param {function(V0): T1|function(V0, V1): T1|function(V0, V1, V2): T1|function(T1): T2|function(T2): T3|function(T3): T4|function(T4): T5|function(T5): T6} fn0_or_fn1_or_fn2_or_fn3_or_fn4_or_fn5
 * @param {function(V0): T1|function(V0, V1): T1|function(V0, V1, V2): T1|function(T1): T2|function(T2): T3|function(T3): T4|function(T4): T5=} fn0_or_fn1_or_fn2_or_fn3_or_fn4
 * @param {function(V0): T1|function(V0, V1): T1|function(V0, V1, V2): T1|function(T1): T2|function(T2): T3|function(T3): T4=} fn0_or_fn1_or_fn2_or_fn3
 * @param {function(V0): T1|function(V0, V1): T1|function(V0, V1, V2): T1|function(T1): T2|function(T2): T3=} fn0_or_fn1_or_fn2
 * @param {function(V0): T1|function(V0, V1): T1|function(V0, V1, V2): T1|function(T1): T2=} fn0_or_fn1
 * @param {function(V0): T1|function(V0, V1): T1|function(V0, V1, V2): T1=} fn0
 * @return {function(V0): T1|function(V0, V1): T1|function(V0, V1, V2): T1|function(V0): T2|function(V0, V1): T2|function(V0, V1, V2): T2|function(V0): T3|function(V0, V1): T3|function(V0, V1, V2): T3|function(V0): T4|function(V0, V1): T4|function(V0, V1, V2): T4|function(V0): T5|function(V0, V1): T5|function(V0, V1, V2): T5|function(V0): T6|function(V0, V1): T6|function(V0, V1, V2): T6}
 */
R.Static.prototype.compose = function(fn0_or_fn1_or_fn2_or_fn3_or_fn4_or_fn5, fn0_or_fn1_or_fn2_or_fn3_or_fn4, fn0_or_fn1_or_fn2_or_fn3, fn0_or_fn1_or_fn2, fn0_or_fn1, fn0) {};

/**
 * Returns a new list consisting of the elements of the first list followed by the elements
 * of the second.
 * @template T
 * @param {!Array<T>|string} list1
 * @param {!Array<T>|string=} list2
 * @return {!Array<T>|function(!Array<T>): !Array<T>|string|function(string): string}
 */
R.Static.prototype.concat = function(list1, list2) {};

/**
 * Returns a function, fn, which encapsulates if/else-if/else logic. R.cond takes a list of [predicate, transform] pairs.
 * All of the arguments to fn are applied to each of the predicates in turn until one returns a "truthy" value, at which
 * point fn returns the result of applying its arguments to the corresponding transformer. If none of the predicates
 * matches, fn returns undefined.
 * @param {!Array<!Array<?>>} fns
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.cond = function(fns) {};

/**
 * Wraps a constructor function inside a curried function that can be called with the same arguments and returns the same type.
 * @param {function(!Array<?>): ?} fn
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.construct = function(fn) {};

/**
 * Wraps a constructor function inside a curried function that can be called with the same arguments and returns the same type.
 * The arity of the function returned is specified to allow using variadic constructor functions.
 * @param {number} n
 * @param {function(!Array<?>): ?} fn
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.constructN = function(n, fn) {};

/**
 * Returns `true` if the specified item is somewhere in the list, `false` otherwise.
 * Equivalent to `indexOf(a)(list) > -1`. Uses strict (`===`) equality checking.
 * @template T
 * @param {string|T} a
 * @param {string|!Array<T>=} list
 * @return {boolean|function(string): boolean|function(!Array<T>): boolean}
 */
R.Static.prototype.contains = function(a, list) {};

/**
 * Accepts a converging function and a list of branching functions and returns a new
 * function. When invoked, this new function is applied to some arguments, each branching
 * function is applied to those same arguments. The results of each branching function
 * are passed as arguments to the converging function to produce the return value.
 * @param {function(!Array<?>): ?} after
 * @param {!Array<function(!Array<?>): ?>} fns
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.converge = function(after, fns) {};

/**
 * Counts the elements of a list according to how many match each value
 * of a key generated by the supplied function. Returns an object
 * mapping the keys produced by `fn` to the number of occurrences in
 * the list. Note that all keys are coerced to strings because of how
 * JavaScript objects work.
 * @param {function(?): (string|number)} fn
 * @param {!Array<?>=} list
 * @return {?|function(!Array<?>): ?}
 */
R.Static.prototype.countBy = function(fn, list) {};

/**
 * Returns a curried equivalent of the provided function. The curried function has two unusual capabilities.
 * First, its arguments needn't be provided one at a time.
 * @template T1, T2, TResult, T3, T4, T5, T6
 * @param {function(T1, T2): boolean|function(T1, T2, T3): boolean|function(T1, T2, T3, T4): boolean|function(T1, T2, T3, T4, T5): boolean|function(T1, T2, T3, T4, T5, T6): boolean|function(T1, T2): TResult|function(T1, T2, T3): TResult|function(T1, T2, T3, T4): TResult|function(T1, T2, T3, T4, T5): TResult|function(T1, T2, T3, T4, T5, T6): TResult|function(!Array<?>): ?} fn
 * @return {!R.CurriedTypeGuard2<T1, T2, TResult>|!R.CurriedTypeGuard3<T1, T2, T3, TResult>|!R.CurriedTypeGuard4<T1, T2, T3, T4, TResult>|!R.CurriedTypeGuard5<T1, T2, T3, T4, T5, TResult>|!R.CurriedTypeGuard6<T1, T2, T3, T4, T5, T6, TResult>|!R.CurriedFunction2<T1, T2, TResult>|!R.CurriedFunction3<T1, T2, T3, TResult>|!R.CurriedFunction4<T1, T2, T3, T4, TResult>|!R.CurriedFunction5<T1, T2, T3, T4, T5, TResult>|!R.CurriedFunction6<T1, T2, T3, T4, T5, T6, TResult>|function(!Array<?>): ?}
 */
R.Static.prototype.curry = function(fn) {};

/**
 * Returns a curried equivalent of the provided function, with the specified arity. The curried function has
 * two unusual capabilities. First, its arguments needn't be provided one at a time.
 * @param {number} length
 * @param {function(!Array<?>): ?} fn
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.curryN = function(length, fn) {};

/**
 * Decrements its argument.
 * @param {number} n
 * @return {number}
 */
R.Static.prototype.dec = function(n) {};

/**
 * Returns the second argument if it is not null or undefined. If it is null or undefined, the
 * first (default) argument is returned.
 * @template T, U
 * @param {T} a
 * @param {U=} b
 * @return {(T|U)|function(U): (T|U)}
 */
R.Static.prototype.defaultTo = function(a, b) {};

/**
 * Makes a descending comparator function out of a function that returns a value that can be compared with < and >.
 * @template T
 * @param {function(T): ?} fn
 * @param {T=} a
 * @param {T=} b
 * @return {number|function(T, T): number}
 */
R.Static.prototype.descend = function(fn, a, b) {};

/**
 * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
 * @template T
 * @param {!Array<T>} list1
 * @param {!Array<T>=} list2
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.difference = function(list1, list2) {};

/**
 * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
 * Duplication is determined according to the value returned by applying the supplied predicate to two list
 * elements.
 * @template T
 * @param {function(T, T): boolean} pred
 * @param {!Array<T>} list1
 * @param {!Array<T>} list2
 * @return {!Array<T>}
 */
R.Static.prototype.differenceWith = function(pred, list1, list2) {};

/**
 * @template T
 * @param {string} prop
 * @param {?=} obj
 * @return {T|function(?): U}
 */
R.Static.prototype.dissoc = function(prop, obj) {};

/**
 * Makes a shallow clone of an object, omitting the property at the given path.
 * @template T
 * @param {!Array<(string|number)>} path
 * @param {?=} obj
 * @return {T|function(?): T}
 */
R.Static.prototype.dissocPath = function(path, obj) {};

/**
 * Divides two numbers. Equivalent to a / b.
 * @param {number} a
 * @param {number=} b
 * @return {number|function(number): number}
 */
R.Static.prototype.divide = function(a, b) {};

/**
 * Returns a new list containing all but the first n elements of the given list.
 * @template T
 * @param {number} n
 * @param {!Array<T>|string=} xs
 * @return {!Array<T>|string|?}
 */
R.Static.prototype.drop = function(n, xs) {};

/**
 * Returns a list containing all but the last n elements of the given list.
 * @template T
 * @param {number} n
 * @param {!Array<T>|string=} xs
 * @return {!Array<T>|string|?}
 */
R.Static.prototype.dropLast = function(n, xs) {};

/**
 * Returns a new list containing all but last then elements of a given list, passing each value from the
 * right to the supplied predicate function, skipping elements while the predicate function returns true.
 * @template T
 * @param {function(T): boolean} fn
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.dropLastWhile = function(fn, list) {};

/**
 * Returns a new list containing the last n elements of a given list, passing each value to the supplied
 * predicate function, skipping elements while the predicate function returns true.
 * @template T
 * @param {function(T): boolean} fn
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.dropWhile = function(fn, list) {};

/**
 * A function wrapping calls to the two functions in an || operation, returning the result of the first
 * function if it is truth-y and the result of the second function otherwise. Note that this is
 * short-circuited, meaning that the second function will not be invoked if the first returns a truth-y value.
 * @param {function(!Array<?>): boolean} pred1
 * @param {function(!Array<?>): boolean=} pred2
 * @return {function(!Array<?>): boolean|function(function(!Array<?>): boolean): ?}
 */
R.Static.prototype.either = function(pred1, pred2) {};

/**
 * Returns the empty value of its argument's type. Ramda defines the empty value of Array ([]), Object ({}),
 * String (''), and Arguments. Other types are supported if they define <Type>.empty and/or <Type>.prototype.empty.
 * Dispatches to the empty method of the first argument, if present.
 * @template T
 * @param {T} x
 * @return {T}
 */
R.Static.prototype.empty = function(x) {};

/**
 * Takes a function and two values in its domain and returns true if the values map to the same value in the
 * codomain; false otherwise.
 * @template T
 * @param {function(T): T} fn
 * @param {T=} a
 * @param {T=} b
 * @return {boolean|function(T): boolean|function(T, T): boolean|function(T): function(T): boolean}
 */
R.Static.prototype.eqBy = function(fn, a, b) {};

/**
 * Reports whether two functions have the same value for the specified property.
 * @template T, U
 * @param {string} prop
 * @param {T=} obj1
 * @param {U=} obj2
 * @return {boolean|function(T, U): boolean|function(U): boolean}
 */
R.Static.prototype.eqProps = function(prop, obj1, obj2) {};

/**
 * Returns true if its arguments are equivalent, false otherwise. Dispatches to an equals method if present.
 * Handles cyclical data structures.
 * @template T
 * @param {T} a
 * @param {T=} b
 * @return {boolean|function(T): boolean}
 */
R.Static.prototype.equals = function(a, b) {};

/**
 * Creates a new object by evolving a shallow copy of object, according to the transformation functions.
 * @template V
 * @param {(function(V): V|?)} transformations
 * @param {V=} obj
 * @return {V|function(W): W}
 */
R.Static.prototype.evolve = function(transformations, obj) {};

/**
 * @return {boolean}
 */
R.Static.prototype.F = function() {};

/**
 * Returns a new list containing only those items that match a given predicate function. The predicate function is passed one argument: (value).
 * @template T
 * @param {function(T): boolean} fn
 * @param {!Array<T>=} list
 * @return {function(!Array<T>): !Array<T>|!Array<T>}
 */
R.Static.prototype.filter = function(fn, list) {};

/**
 * Returns the first element of the list which matches the predicate, or `undefined` if no
 * element matches.
 * @template T
 * @param {function(T): boolean} fn
 * @param {!Array<T>=} list
 * @return {T|function(!Array<T>): T}
 */
R.Static.prototype.find = function(fn, list) {};

/**
 * Returns the index of the first element of the list which matches the predicate, or `-1`
 * if no element matches.
 * @template T
 * @param {function(T): boolean} fn
 * @param {!Array<T>=} list
 * @return {number|function(!Array<T>): number}
 */
R.Static.prototype.findIndex = function(fn, list) {};

/**
 * Returns the last element of the list which matches the predicate, or `undefined` if no
 * element matches.
 * @template T
 * @param {function(T): boolean} fn
 * @param {!Array<T>=} list
 * @return {T|function(!Array<T>): T}
 */
R.Static.prototype.findLast = function(fn, list) {};

/**
 * Returns the index of the last element of the list which matches the predicate, or
 * `-1` if no element matches.
 * @template T
 * @param {function(T): boolean} fn
 * @param {!Array<T>=} list
 * @return {number|function(!Array<T>): number}
 */
R.Static.prototype.findLastIndex = function(fn, list) {};

/**
 * Returns a new list by pulling every item out of it (and all its sub-arrays) and putting
 * them in a new array, depth-first.
 * @template T
 * @param {(!Array<T>|!Array<!Array<T>>)} x
 * @return {!Array<T>}
 */
R.Static.prototype.flatten = function(x) {};

/**
 * Returns a new function much like the supplied one, except that the first two arguments'
 * order is reversed.
 * @template T, U, TResult
 * @param {function(T, U): TResult|function(T, U, !Array<?>): TResult} fn
 * @return {function(U, T): TResult|function(U, T, !Array<?>): TResult}
 */
R.Static.prototype.flip = function(fn) {};

/**
 * Iterate over an input list, calling a provided function fn for each element in the list.
 * @template T
 * @param {function(T): void} fn
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.forEach = function(fn, list) {};

/**
 * Iterate over an input object, calling a provided function fn for each key and value in the object.
 * @template T
 * @param {function(?, ?, T): void} fn
 * @param {T=} obj
 * @return {T|function(T): T}
 */
R.Static.prototype.forEachObjIndexed = function(fn, obj) {};

/**
 * Creates a new object out of a list key-value pairs.
 * @template V
 * @param {!Array<!R.KeyValuePair<string, V>>|!Array<!R.KeyValuePair<number, V>>} pairs
 * @return {!Object<string,V>|!Object<number,V>}
 */
R.Static.prototype.fromPairs = function(pairs) {};

/**
 * Splits a list into sublists stored in an object, based on the result of
 * calling a String-returning function
 * on each element, and grouping the results according to values returned.
 * @template T
 * @param {function(T): string} fn
 * @param {!Array<T>=} list
 * @return {!Object<string,!Array<T>>|function(!Array<T>): !Object<string,!Array<T>>}
 */
R.Static.prototype.groupBy = function(fn, list) {};

/**
 * Takes a list and returns a list of lists where each sublist's elements are all "equal" according to the provided equality function
 * @template T
 * @param {function(T, T): boolean} fn
 * @param {!Array<T>|string} list
 * @return {!Array<!Array<T>>|!Array<string>}
 */
R.Static.prototype.groupWith = function(fn, list) {};

/**
 * Returns true if the first parameter is greater than the second.
 * @param {number} a
 * @param {number=} b
 * @return {boolean|function(number): boolean}
 */
R.Static.prototype.gt = function(a, b) {};

/**
 * Returns true if the first parameter is greater than or equal to the second.
 * @param {number} a
 * @param {number=} b
 * @return {boolean|function(number): boolean}
 */
R.Static.prototype.gte = function(a, b) {};

/**
 * Returns whether or not an object has an own property with the specified name.
 * @template T
 * @param {string} s
 * @param {T=} obj
 * @return {boolean|function(T): boolean}
 */
R.Static.prototype.has = function(s, obj) {};

/**
 * Returns whether or not an object or its prototype chain has a property with the specified name
 * @template T
 * @param {string} s
 * @param {T=} obj
 * @return {boolean|function(T): boolean}
 */
R.Static.prototype.hasIn = function(s, obj) {};

/**
 * Returns the first element in a list.
 * In some libraries this function is named `first`.
 * @template T
 * @param {!Array<T>|string} list
 * @return {T|string}
 */
R.Static.prototype.head = function(list) {};

/**
 * Returns true if its arguments are identical, false otherwise. Values are identical if they reference the
 * same memory. NaN is identical to NaN; 0 and -0 are not identical.
 * @template T
 * @param {T} a
 * @param {T=} b
 * @return {boolean|function(T): boolean}
 */
R.Static.prototype.identical = function(a, b) {};

/**
 * A function that does nothing but return the parameter supplied to it. Good as a default
 * or placeholder function.
 * @template T
 * @param {T} a
 * @return {T}
 */
R.Static.prototype.identity = function(a) {};

/**
 * Creates a function that will process either the onTrue or the onFalse function depending upon the result
 * of the condition predicate.
 * @param {function(!Array<?>): boolean} fn
 * @param {function(?): ?} onTrue
 * @param {function(?): ?} onFalse
 * @return {function(?): ?}
 */
R.Static.prototype.ifElse = function(fn, onTrue, onFalse) {};

/**
 * Increments its argument.
 * @param {number} n
 * @return {number}
 */
R.Static.prototype.inc = function(n) {};

/**
 * Given a function that generates a key, turns a list of objects into an object indexing the objects
 * by the given key.
 * @template T, U
 * @param {function(T): string} fn
 * @param {!Array<T>=} list
 * @return {U|function(!Array<T>): U}
 */
R.Static.prototype.indexBy = function(fn, list) {};

/**
 * Returns the position of the first occurrence of an item in an array
 * (by strict equality),
 * or -1 if the item is not included in the array.
 * @template T
 * @param {T} target
 * @param {!Array<T>=} list
 * @return {number|function(!Array<T>): number}
 */
R.Static.prototype.indexOf = function(target, list) {};

/**
 * Returns all but the last element of a list or string.
 * @template T
 * @param {!Array<T>|string} list
 * @return {!Array<T>|string}
 */
R.Static.prototype.init = function(list) {};

/**
 * Inserts the supplied element into the list, at index index. Note that
 * this is not destructive: it returns a copy of the list with the changes.
 * @template T
 * @param {number} index
 * @param {T=} elt
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>|function(T, !Array<T>): !Array<T>}
 */
R.Static.prototype.insert = function(index, elt, list) {};

/**
 * Inserts the sub-list into the list, at index `index`.  _Note  that this
 * is not destructive_: it returns a copy of the list with the changes.
 * @template T
 * @param {number} index
 * @param {!Array<T>=} elts
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>|function(!Array<T>, !Array<T>): !Array<T>}
 */
R.Static.prototype.insertAll = function(index, elts, list) {};

/**
 * Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.
 * @template T
 * @param {!Array<T>} list1
 * @param {!Array<T>} list2
 * @return {!Array<T>}
 */
R.Static.prototype.intersection = function(list1, list2) {};

/**
 * Combines two lists into a set (i.e. no duplicates) composed of those
 * elements common to both lists.  Duplication is determined according
 * to the value returned by applying the supplied predicate to two list
 * elements.
 * @template T
 * @param {function(T, T): boolean} pred
 * @param {!Array<T>} list1
 * @param {!Array<T>} list2
 * @return {!Array<T>}
 */
R.Static.prototype.intersectionWith = function(pred, list1, list2) {};

/**
 * Creates a new list with the separator interposed between elements.
 * @template T
 * @param {T} separator
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.intersperse = function(separator, list) {};

/**
 * Transforms the items of the list with the transducer and appends the transformed items to the accumulator
 * using an appropriate iterator function based on the accumulator type.
 * @template T
 * @param {?} acc
 * @param {function(!Array<?>): ?=} xf
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>|function(function(!Array<?>): ?, !Array<T>): !Array<T>}
 */
R.Static.prototype.into = function(acc, xf, list) {};

/**
 * Same as R.invertObj, however this accounts for objects with duplicate values by putting the values into an array.
 * @template T
 * @param {T} obj
 * @return {!Object<string,!Array<string>>}
 */
R.Static.prototype.invert = function(obj) {};

/**
 * Returns a new object with the keys of the given object as values, and the values of the given object as keys.
 * @param {?} obj
 * @return {!Object<string,string>}
 */
R.Static.prototype.invertObj = function(obj) {};

/**
 * Turns a named method of an object (or object prototype) into a function that can be
 * called directly. Passing the optional `len` parameter restricts the returned function to
 * the initial `len` parameters of the method.
 * 
 * The returned function is curried and accepts `len + 1` parameters (or `method.length + 1`
 * when `len` is not specified), and the final parameter is the target object.
 * @param {string} name
 * @param {?=} obj
 * @param {number=} len
 * @return {function(!Array<?>): ?|function(?, number): function(!Array<?>): ?}
 */
R.Static.prototype.invoker = function(name, obj, len) {};

/**
 * See if an object (`val`) is an instance of the supplied constructor.
 * This function will check up the inheritance chain, if any.
 * @param {?} ctor
 * @param {?=} val
 * @return {boolean|function(?): boolean}
 */
R.Static.prototype.is = function(ctor, val) {};

/**
 * Tests whether or not an object is similar to an array.
 * @param {?} val
 * @return {boolean}
 */
R.Static.prototype.isArrayLike = function(val) {};

/**
 * Reports whether the list has zero elements.
 * @param {?} value
 * @return {boolean}
 */
R.Static.prototype.isEmpty = function(value) {};

/**
 * Returns true if the input value is NaN.
 * @param {?} x
 * @return {boolean}
 */
R.Static.prototype.isNaN = function(x) {};

/**
 * Checks if the input value is null or undefined.
 * @param {?} value
 * @return {boolean}
 */
R.Static.prototype.isNil = function(value) {};

/**
 * Returns a string made by inserting the `separator` between each
 * element and concatenating all the elements into a single string.
 * @param {string} x
 * @param {!Array<?>=} xs
 * @return {string|function(!Array<?>): string}
 */
R.Static.prototype.join = function(x, xs) {};

/**
 * Applies a list of functions to a list of values.
 * @template T, U
 * @param {!Array<function(!Array<T>): U>} fns
 * @return {function(!Array<T>): !Array<U>}
 */
R.Static.prototype.juxt = function(fns) {};

/**
 * Returns a list containing the names of all the enumerable own
 * properties of the supplied object.
 * @template T
 * @param {T} x
 * @return {!Array<string>}
 */
R.Static.prototype.keys = function(x) {};

/**
 * Returns a list containing the names of all the
 * properties of the supplied object, including prototype properties.
 * @template T
 * @param {T} obj
 * @return {!Array<string>}
 */
R.Static.prototype.keysIn = function(obj) {};

/**
 * Returns the last element from a list.
 * @template T
 * @param {!Array<T>|string} list
 * @return {T|string}
 */
R.Static.prototype.last = function(list) {};

/**
 * Returns the position of the last occurrence of an item (by strict equality) in
 * an array, or -1 if the item is not included in the array.
 * @template T
 * @param {T} target
 * @param {!Array<T>} list
 * @return {number}
 */
R.Static.prototype.lastIndexOf = function(target, list) {};

/**
 * Returns the number of elements in the array by returning list.length.
 * @param {!Array<?>} list
 * @return {number}
 */
R.Static.prototype.length = function(list) {};

/**
 * Returns a lens for the given getter and setter functions. The getter
 * "gets" the value of the focus; the setter "sets" the value of the focus.
 * The setter should not mutate the data structure.
 * @template T, U, V
 * @param {function(T): U} getter
 * @param {function(U, T): V} setter
 * @return {!R.Lens}
 */
R.Static.prototype.lens = function(getter, setter) {};

/**
 * Creates a lens that will focus on index n of the source array.
 * @param {number} n
 * @return {!R.Lens}
 */
R.Static.prototype.lensIndex = function(n) {};

/**
 * Returns a lens whose focus is the specified path.
 * See also view, set, over.
 * @param {!Array<(string|number)>} path
 * @return {!R.Lens}
 */
R.Static.prototype.lensPath = function(path) {};

/**
 * lensProp creates a lens that will focus on property k of the source object.
 * @param {string} str
 * @return {?}
 */
R.Static.prototype.lensProp = function(str) {};

/**
 * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other object that satisfies
 * the FantasyLand Apply spec.
 * @param {function(!Array<?>): ?} fn
 * @param {...?} args
 * @return {?}
 */
R.Static.prototype.lift = function(fn, args) {};

/**
 * "lifts" a function to be the specified arity, so that it may "map over" that many lists, Functions or other
 * objects that satisfy the FantasyLand Apply spec.
 * @param {number} n
 * @param {function(!Array<?>): ?} fn
 * @param {...?} args
 * @return {?}
 */
R.Static.prototype.liftN = function(n, fn, args) {};

/**
 * Returns true if the first parameter is less than the second.
 * @param {number} a
 * @param {number=} b
 * @return {boolean|function(number): boolean}
 */
R.Static.prototype.lt = function(a, b) {};

/**
 * Returns true if the first parameter is less than or equal to the second.
 * @param {number} a
 * @param {number=} b
 * @return {boolean|function(number): boolean}
 */
R.Static.prototype.lte = function(a, b) {};

/**
 * Returns a new list, constructed by applying the supplied function to every element of the supplied list.
 * @template T, U
 * @param {function(T): U|function(?): ?} fn
 * @param {!Array<T>|!R.Functor<T>|T=} list_or_obj
 * @return {!Array<U>|!R.Functor<U>|function(!Array<T>): !Array<U>|U|function(T): U}
 */
R.Static.prototype.map = function(fn, list_or_obj) {};

/**
 * The mapAccum function behaves like a combination of map and reduce.
 * @template T, U, TResult
 * @param {function(U, T): !Array<?>} fn
 * @param {U=} acc
 * @param {!Array<T>=} list
 * @return {!Array<?>|function(U, !Array<T>): !Array<?>|function(!Array<T>): !Array<?>}
 */
R.Static.prototype.mapAccum = function(fn, acc, list) {};

/**
 * The mapAccumRight function behaves like a combination of map and reduce.
 * @template T, U, TResult
 * @param {function(U, T): !Array<?>} fn
 * @param {U=} acc
 * @param {!Array<T>=} list
 * @return {!Array<?>|function(U, !Array<T>): !Array<?>|function(!Array<T>): !Array<?>}
 */
R.Static.prototype.mapAccumRight = function(fn, acc, list) {};

/**
 * Like mapObj, but but passes additional arguments to the predicate function.
 * @template T, TResult
 * @param {function(T, string, ?): TResult} fn
 * @param {?=} obj
 * @return {!Object<string,TResult>|function(?): !Object<string,TResult>}
 */
R.Static.prototype.mapObjIndexed = function(fn, obj) {};

/**
 * Tests a regular expression agains a String
 * @param {!RegExp} regexp
 * @param {string=} str
 * @return {!Array<?>|function(string): !Array<?>}
 */
R.Static.prototype.match = function(regexp, str) {};

/**
 * mathMod behaves like the modulo operator should mathematically, unlike the `%`
 * operator (and by extension, R.modulo). So while "-17 % 5" is -2,
 * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
 * when the modulus is zero or negative.
 * @param {number} a
 * @param {number=} b
 * @return {number|function(number): number}
 */
R.Static.prototype.mathMod = function(a, b) {};

/**
 * Returns the larger of its two arguments.
 * @param {(string|number|boolean)} a
 * @param {(string|number|boolean)=} b
 * @return {(string|number|boolean)|function((string|number|boolean)): (string|number|boolean)}
 */
R.Static.prototype.max = function(a, b) {};

/**
 * Takes a function and two values, and returns whichever value produces
 * the larger result when passed to the provided function.
 * @template T
 * @param {function(T): (string|number|boolean)} keyFn
 * @param {T=} a
 * @param {T=} b
 * @return {T|function(T): T|!R.CurriedFunction2<T, T, T>}
 */
R.Static.prototype.maxBy = function(keyFn, a, b) {};

/**
 * Returns the mean of the given list of numbers.
 * @param {!Array<number>} list
 * @return {number}
 */
R.Static.prototype.mean = function(list) {};

/**
 * Returns the median of the given list of numbers.
 * @param {!Array<number>} list
 * @return {number}
 */
R.Static.prototype.median = function(list) {};

/**
 * Creates a new function that, when invoked, caches the result of calling fn for a given argument set and
 * returns the result. Subsequent calls to the memoized fn with the same argument set will not result in an
 * additional call to fn; instead, the cached result for that set of arguments will be returned.
 * @param {function(!Array<?>): ?} fn
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.memoize = function(fn) {};

/**
 * Create a new object with the own properties of a
 * merged with the own properties of object b.
 * This function will *not* mutate passed-in objects.
 * @template T1, T2
 * @param {T1} a
 * @param {T2=} b
 * @return {?|function(T2): ?}
 */
R.Static.prototype.merge = function(a, b) {};

/**
 * Merges a list of objects together into one object.
 * @template T
 * @param {!Array<?>} list
 * @return {T}
 */
R.Static.prototype.mergeAll = function(list) {};

/**
 * Creates a new object with the own properties of the first object merged with the own properties of the second object.
 * If a key exists in both objects:
 * and both values are objects, the two values will be recursively merged
 * otherwise the value from the first object will be used.
 * @template T1, T2
 * @param {T1} a
 * @param {T2=} b
 * @return {?|function(T2): ?}
 */
R.Static.prototype.mergeDeepLeft = function(a, b) {};

/**
 * Creates a new object with the own properties of the first object merged with the own properties of the second object.
 * If a key exists in both objects:
 * and both values are objects, the two values will be recursively merged
 * otherwise the value from the second object will be used.
 * @template A, B
 * @param {A} a
 * @param {B=} b
 * @return {?|function(B): ?}
 */
R.Static.prototype.mergeDeepRight = function(a, b) {};

/**
 * Creates a new object with the own properties of the two provided objects. If a key exists in both objects:
 * and both associated values are also objects then the values will be recursively merged.
 * otherwise the provided function is applied to associated values using the resulting value as the new value
 * associated with the key. If a key only exists in one object, the value will be associated with the key of the resulting object.
 * @template T1, T2
 * @param {function(T3, T4): ?} fn
 * @param {T1=} a
 * @param {T2=} b
 * @return {?|function(T2): ?|function(T1, T2): ?}
 */
R.Static.prototype.mergeDeepWith = function(fn, a, b) {};

/**
 * Creates a new object with the own properties of the two provided objects. If a key exists in both objects:
 * and both associated values are also objects then the values will be recursively merged.
 * otherwise the provided function is applied to the key and associated values using the resulting value as
 * the new value associated with the key. If a key only exists in one object, the value will be associated with
 * the key of the resulting object.
 * @template T1, T2
 * @param {function(string, T3, T4): ?} fn
 * @param {T1=} a
 * @param {T2=} b
 * @return {?|function(T2): ?|function(T1, T2): ?}
 */
R.Static.prototype.mergeDeepWithKey = function(fn, a, b) {};

/**
 * Creates a new object with the own properties of the two provided objects. If a key exists in both objects,
 * the provided function is applied to the values associated with the key in each object, with the result being used as
 * the value associated with the key in the returned object. The key will be excluded from the returned object if the
 * resulting value is undefined.
 * @template U, V
 * @param {function(?, ?): ?} fn
 * @param {U=} a
 * @param {V=} b
 * @return {?|function(V): ?|function(U, V): ?}
 */
R.Static.prototype.mergeWith = function(fn, a, b) {};

/**
 * Creates a new object with the own properties of the two provided objects. If a key exists in both objects,
 * the provided function is applied to the key and the values associated with the key in each object, with the
 * result being used as the value associated with the key in the returned object. The key will be excluded from
 * the returned object if the resulting value is undefined.
 * @template U, V
 * @param {function(string, ?, ?): ?} fn
 * @param {U=} a
 * @param {V=} b
 * @return {?|function(V): ?|function(U, V): ?}
 */
R.Static.prototype.mergeWithKey = function(fn, a, b) {};

/**
 * Returns the smaller of its two arguments.
 * @param {(string|number|boolean)} a
 * @param {(string|number|boolean)=} b
 * @return {(string|number|boolean)|function((string|number|boolean)): (string|number|boolean)}
 */
R.Static.prototype.min = function(a, b) {};

/**
 * Takes a function and two values, and returns whichever value produces
 * the smaller result when passed to the provided function.
 * @template T
 * @param {function(T): (string|number|boolean)} keyFn
 * @param {T=} a
 * @param {T=} b
 * @return {T|function(T): T|!R.CurriedFunction2<T, T, T>}
 */
R.Static.prototype.minBy = function(keyFn, a, b) {};

/**
 * Divides the second parameter by the first and returns the remainder.
 * The flipped version (`moduloBy`) may be more useful curried.
 * Note that this functions preserves the JavaScript-style behavior for
 * modulo. For mathematical modulo see `mathMod`
 * @param {number} a
 * @param {number=} b
 * @return {number|function(number): number}
 */
R.Static.prototype.modulo = function(a, b) {};

/**
 * Multiplies two numbers. Equivalent to a * b but curried.
 * @param {number} a
 * @param {number=} b
 * @return {number|function(number): number}
 */
R.Static.prototype.multiply = function(a, b) {};

/**
 * Wraps a function of any arity (including nullary) in a function that accepts exactly n parameters.
 * Any extraneous parameters will not be passed to the supplied function.
 * @param {number} n
 * @param {function(!Array<?>): ?} fn
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.nAry = function(n, fn) {};

/**
 * Negates its argument.
 * @param {number} n
 * @return {number}
 */
R.Static.prototype.negate = function(n) {};

/**
 * Returns true if no elements of the list match the predicate, false otherwise.
 * @template T
 * @param {function(T): boolean} fn
 * @param {!Array<T>=} list
 * @return {boolean|function(!Array<T>): boolean}
 */
R.Static.prototype.none = function(fn, list) {};

/**
 * A function wrapping a call to the given function in a `!` operation.  It will return `true` when the
 * underlying function would return a false-y value, and `false` when it would return a truth-y one.
 * @param {?} value
 * @return {boolean}
 */
R.Static.prototype.not = function(value) {};

/**
 * Returns the nth element in a list.
 * @template T
 * @param {number} n
 * @param {!Array<T>=} list
 * @return {T|function(!Array<T>): T}
 */
R.Static.prototype.nth = function(n, list) {};

/**
 * Returns a function which returns its nth argument.
 * @param {number} n
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.nthArg = function(n) {};

/**
 * Creates an object containing a single key:value pair.
 * @template T, K
 * @param {K} key
 * @param {T=} value
 * @return {?|function(T): ?}
 */
R.Static.prototype.objOf = function(key, value) {};

/**
 * Returns a singleton array containing the value provided.
 * @template T
 * @param {T} x
 * @return {!Array<T>}
 */
R.Static.prototype.of = function(x) {};

/**
 * Returns a partial copy of an object omitting the keys specified.
 * @template T
 * @param {!Array<string>} names
 * @param {T=} obj
 * @return {T|function(T): T}
 */
R.Static.prototype.omit = function(names, obj) {};

/**
 * Accepts a function fn and returns a function that guards invocation of fn such that fn can only ever be
 * called once, no matter how many times the returned function is invoked. The first value calculated is
 * returned in subsequent invocations.
 * @param {function(!Array<?>): ?} fn
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.once = function(fn) {};

/**
 * A function that returns the first truthy of two arguments otherwise the last argument. Note that this is
 * NOT short-circuited, meaning that if expressions are passed they are both evaluated.
 * Dispatches to the or method of the first argument if applicable.
 * @template T, U
 * @param {T} a_or_fn1
 * @param {U=} b_or_val2
 * @return {(T|U)|function(U): (T|U)}
 */
R.Static.prototype.or = function(a_or_fn1, b_or_val2) {};

/**
 * Returns the result of "setting" the portion of the given data structure
 * focused by the given lens to the given value.
 * @template T
 * @param {!R.Lens} lens
 * @param {function(?): ?=} fn
 * @param {T|!Array<T>=} value
 * @return {T|!Array<T>|function(T): T|function(!Array<T>): !Array<T>|function(function(?): ?, T): T|function(function(?): ?, !Array<T>): !Array<T>}
 */
R.Static.prototype.over = function(lens, fn, value) {};

/**
 * Takes two arguments, fst and snd, and returns [fst, snd].
 * @template F, S
 * @param {F} fst
 * @param {S} snd
 * @return {!Array<?>}
 */
R.Static.prototype.pair = function(fst, snd) {};

/**
 * Accepts as its arguments a function and any number of values and returns a function that,
 * when invoked, calls the original function with all of the values prepended to the
 * original function's arguments list. In some libraries this function is named `applyLeft`.
 * @param {function(!Array<?>): ?} fn
 * @param {...?} args
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.partial = function(fn, args) {};

/**
 * Accepts as its arguments a function and any number of values and returns a function that,
 * when invoked, calls the original function with all of the values appended to the original
 * function's arguments list.
 * @param {function(!Array<?>): ?} fn
 * @param {...?} args
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.partialRight = function(fn, args) {};

/**
 * Takes a predicate and a list and returns the pair of lists of elements
 * which do and do not satisfy the predicate, respectively.
 * @template T
 * @param {function(string): boolean|function(T): boolean} fn
 * @param {!Array<string>|!Array<T>=} list
 * @return {!Array<!Array<string>>|!Array<!Array<T>>|function(!Array<T>): !Array<!Array<T>>|function(!Array<string>): !Array<!Array<string>>}
 */
R.Static.prototype.partition = function(fn, list) {};

/**
 * Retrieve the value at a given path.
 * @template T
 * @param {!Array<(string|number)>} path
 * @param {?=} obj
 * @return {T|function(?): T}
 */
R.Static.prototype.path = function(path, obj) {};

/**
 * Determines whether a nested path on an object has a specific value,
 * in `R.equals` terms. Most likely used to filter a list.
 * @param {!Array<(string|number)>} path
 * @param {?=} val
 * @param {?=} obj
 * @return {boolean|function(?): boolean|!R.CurriedFunction2<?, ?, boolean>}
 */
R.Static.prototype.pathEq = function(path, val, obj) {};

/**
 * If the given, non-null object has a value at the given path, returns the value at that path.
 * Otherwise returns the provided default value.
 * @template T
 * @param {T} d
 * @param {!Array<(string|number)>=} p
 * @param {?=} obj
 * @return {?|function(?): ?|!R.CurriedFunction2<!Array<(string|number)>, ?, ?>}
 */
R.Static.prototype.pathOr = function(d, p, obj) {};

/**
 * Returns true if the specified object property at given path satisfies the given predicate; false otherwise.
 * @template T, U
 * @param {function(T): boolean} pred
 * @param {!Array<(string|number)>=} path
 * @param {U=} obj
 * @return {boolean|function(U): boolean|!R.CurriedFunction2<!Array<(string|number)>, U, boolean>}
 */
R.Static.prototype.pathSatisfies = function(pred, path, obj) {};

/**
 * Returns a partial copy of an object containing only the keys specified.  If the key does not exist, the
 * property is ignored.
 * @template T, K
 * @param {!Array<(string|K)>|!Array<string>} names
 * @param {T=} obj
 * @return {?|function(T): U}
 */
R.Static.prototype.pick = function(names, obj) {};

/**
 * Similar to `pick` except that this one includes a `key: undefined` pair for properties that don't exist.
 * @template T, U
 * @param {!Array<string>} names
 * @param {T=} obj
 * @return {U|function(T): U}
 */
R.Static.prototype.pickAll = function(names, obj) {};

/**
 * Returns a partial copy of an object containing only the keys that satisfy the supplied predicate.
 * @template T, U
 * @param {function(?, string): boolean} pred
 * @param {T=} obj
 * @return {U|function(T): U}
 */
R.Static.prototype.pickBy = function(pred, obj) {};

/**
 * Creates a new function that runs each of the functions supplied as parameters in turn,
 * passing the return value of each function invocation to the next function invocation,
 * beginning with whatever arguments were passed to the initial invocation.
 * @template V0, T1, V1, V2, T2, T3, T4, T5, T6, T7, T8, T9, T10
 * @param {function(V0): T1|function(V0, V1): T1|function(V0, V1, V2): T1} fn0
 * @param {function(T1): T2=} fn1
 * @param {function(T2): T3=} fn2
 * @param {function(T3): T4=} fn3
 * @param {function(T4): T5=} fn4
 * @param {function(T5): T6=} fn5
 * @param {function(T6): T7=} fn_or_fn6
 * @param {function(T7): T8=} fn_or_fn7
 * @param {function(T8): T9=} fn8
 * @param {function(T9): T10=} fn9
 * @return {function(V0): T1|function(V0, V1): T1|function(V0, V1, V2): T1|function(V0): T2|function(V0, V1): T2|function(V0, V1, V2): T2|function(V0): T3|function(V0, V1): T3|function(V0, V1, V2): T3|function(V0): T4|function(V0, V1): T4|function(V0, V1, V2): T4|function(V0): T5|function(V0, V1): T5|function(V0, V1, V2): T5|function(V0): T6|function(V0, V1): T6|function(V0, V1, V2): T6|function(V0): T7|function(V0, V1): T7|function(V0, V1, V2): T7|function(V0): T8|function(V0, V1): T8|function(V0, V1, V2): T8|function(V0): T9|function(V0, V1): T9|function(V0, V1, V2): T9|function(V0): T10|function(V0, V1): T10|function(V0, V1, V2): T10}
 */
R.Static.prototype.pipe = function(fn0, fn1, fn2, fn3, fn4, fn5, fn_or_fn6, fn_or_fn7, fn8, fn9) {};

/**
 * Returns a new list by plucking the same named property off all objects in the list supplied.
 * @template T
 * @param {(string|number)} p
 * @param {!Array<?>=} list
 * @return {!Array<T>|function(!Array<?>): !Array<T>}
 */
R.Static.prototype.pluck = function(p, list) {};

/**
 * Returns a new list with the given element at the front, followed by the contents of the
 * list.
 * @template T
 * @param {T} el
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.prepend = function(el, list) {};

/**
 * Multiplies together all the elements of a list.
 * @param {!Array<number>} list
 * @return {number}
 */
R.Static.prototype.product = function(list) {};

/**
 * Reasonable analog to SQL `select` statement.
 * @template T, U
 * @param {!Array<string>} props
 * @param {!Array<T>} objs
 * @return {!Array<U>}
 */
R.Static.prototype.project = function(props, objs) {};

/**
 * Returns a function that when supplied an object returns the indicated property of that object, if it exists.
 * Note: TS1.9 # replace any by dictionary
 * @template T
 * @param {string} p
 * @param {?=} obj
 * @return {T|function(?): T}
 */
R.Static.prototype.prop = function(p, obj) {};

/**
 * @template T
 * @param {string} name
 * @param {T=} val
 * @param {?=} obj
 * @return {boolean|function(?): boolean|function(T, ?): boolean}
 */
R.Static.prototype.propEq = function(name, val, obj) {};

/**
 * Returns true if the specified object property is of the given type; false otherwise.
 * @param {?} type
 * @param {string=} name
 * @param {?=} obj
 * @return {boolean|function(?): boolean|?}
 */
R.Static.prototype.propIs = function(type, name, obj) {};

/**
 * If the given, non-null object has an own property with the specified name, returns the value of that property.
 * Otherwise returns the provided default value.
 * @template T, U, V
 * @param {T} val
 * @param {string=} p
 * @param {U=} obj
 * @return {V|function(U): V|function(string, U): V}
 */
R.Static.prototype.propOr = function(val, p, obj) {};

/**
 * Returns the value at the specified property.
 * The only difference from `prop` is the parameter order.
 * Note: TS1.9 # replace any by dictionary
 * @template T
 * @param {!Array<string>} ps
 * @param {?=} obj
 * @return {!Array<T>|function(?): !Array<T>}
 */
R.Static.prototype.props = function(ps, obj) {};

/**
 * Returns true if the specified object property satisfies the given predicate; false otherwise.
 * @template T, U
 * @param {function(T): boolean} pred
 * @param {string=} name
 * @param {U=} obj
 * @return {boolean|function(U): boolean|!R.CurriedFunction2<string, U, boolean>}
 */
R.Static.prototype.propSatisfies = function(pred, name, obj) {};

/**
 * Returns a list of numbers from `from` (inclusive) to `to`
 * (exclusive). In mathematical terms, `range(a, b)` is equivalent to
 * the half-open interval `[a, b)`.
 * @param {number} from
 * @param {number=} to
 * @return {!Array<number>|function(number): !Array<number>}
 */
R.Static.prototype.range = function(from, to) {};

/**
 * Returns a single item by iterating through the list, successively calling the iterator
 * function and passing it an accumulator value and the current value from the array, and
 * then passing the result to the next call.
 * @template T, TResult
 * @param {function(TResult, T): (TResult|!R.Reduced)|function(TResult, T): (!R.Reduced|TResult)} fn
 * @param {TResult=} acc
 * @param {!Array<T>=} list
 * @return {TResult|function(TResult, !Array<T>): TResult|function(!Array<T>): TResult}
 */
R.Static.prototype.reduce = function(fn, acc, list) {};

/**
 * Groups the elements of the list according to the result of calling the String-returning function keyFn on each
 * element and reduces the elements of each group to a single value via the reducer function valueFn.
 * @template T, TResult
 * @param {function(TResult, T): TResult} valueFn
 * @param {TResult=} acc
 * @param {function(T): string=} keyFn
 * @param {!Array<T>=} list
 * @return {!Object<string,TResult>|function(!Array<T>): !Object<string,TResult>|!R.CurriedFunction2<function(T): string, !Array<T>, !Object<string,TResult>>|!R.CurriedFunction3<TResult, function(T): string, !Array<T>, !Object<string,TResult>>}
 */
R.Static.prototype.reduceBy = function(valueFn, acc, keyFn, list) {};

/**
 * Returns a value wrapped to indicate that it is the final value of the reduce and
 * transduce functions. The returned value should be considered a black box: the internal
 * structure is not guaranteed to be stable.
 * @template T
 * @param {T} elem
 * @return {!R.Reduced}
 */
R.Static.prototype.reduced = function(elem) {};

/**
 * Returns a single item by iterating through the list, successively calling the iterator
 * function and passing it an accumulator value and the current value from the array, and
 * then passing the result to the next call.
 * @template T, TResult
 * @param {function(TResult, T): TResult} fn
 * @param {TResult=} acc
 * @param {!Array<T>=} list
 * @return {TResult|function(TResult, !Array<T>): TResult|function(!Array<T>): TResult}
 */
R.Static.prototype.reduceRight = function(fn, acc, list) {};

/**
 * Similar to `filter`, except that it keeps only values for which the given predicate
 * function returns falsy.
 * @template T
 * @param {function(T): boolean} fn
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.reject = function(fn, list) {};

/**
 * Removes the sub-list of `list` starting at index `start` and containing `count` elements.
 * @template T
 * @param {number} start
 * @param {number=} count
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(number, !Array<T>): !Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.remove = function(start, count, list) {};

/**
 * Returns a fixed list of size n containing a specified identical value.
 * @template T
 * @param {T} a
 * @param {number=} n
 * @return {!Array<T>|function(number): !Array<T>}
 */
R.Static.prototype.repeat = function(a, n) {};

/**
 * Replace a substring or regex match in a string with a replacement.
 * @param {(string|!RegExp)} pattern
 * @param {string=} replacement
 * @param {string=} str
 * @return {string|function(string): string|function(string): function(string): string}
 */
R.Static.prototype.replace = function(pattern, replacement, str) {};

/**
 * Returns a new list with the same elements as the original list, just in the reverse order.
 * @template T
 * @param {!Array<T>} list
 * @return {!Array<T>}
 */
R.Static.prototype.reverse = function(list) {};

/**
 * Scan is similar to reduce, but returns a list of successively reduced values from the left.
 * @template T, TResult
 * @param {function(TResult, T): ?} fn
 * @param {TResult=} acc
 * @param {!Array<T>=} list
 * @return {!Array<TResult>|function(!Array<T>): !Array<TResult>|function(TResult, !Array<T>): !Array<TResult>}
 */
R.Static.prototype.scan = function(fn, acc, list) {};

/**
 * Returns the result of "setting" the portion of the given data structure focused by the given lens to the
 * given value.
 * @template T, U
 * @param {!R.Lens} lens
 * @param {U=} a
 * @param {T=} obj
 * @return {T|function(T): T|function(U, T): T}
 */
R.Static.prototype.set = function(lens, a, obj) {};

/**
 * Returns the elements from `xs` starting at `a` and ending at `b - 1`.
 * @template T
 * @param {number} a
 * @param {number=} b
 * @param {string|!Array<T>=} list
 * @return {string|!Array<T>|function((string|!Array<T>)): (string|!Array<T>)|function(number, (string|!Array<T>)): (string|!Array<T>)}
 */
R.Static.prototype.slice = function(a, b, list) {};

/**
 * Returns a copy of the list, sorted according to the comparator function, which should accept two values at a
 * time and return a negative number if the first value is smaller, a positive number if it's larger, and zero
 * if they are equal.
 * @template T
 * @param {function(T, T): number} fn
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.sort = function(fn, list) {};

/**
 * Sorts the list according to a key generated by the supplied function.
 * @template T
 * @param {function(?): (string|number|boolean)} fn
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.sortBy = function(fn, list) {};

/**
 * Sorts a list according to a list of comparators.
 * @template T
 * @param {!Array<function(T, T): number>} fns
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.sortWith = function(fns, list) {};

/**
 * Splits a string into an array of strings based on the given
 * separator.
 * @param {(string|!RegExp)} sep
 * @param {string=} str
 * @return {function(string): !Array<string>|!Array<string>}
 */
R.Static.prototype.split = function(sep, str) {};

/**
 * Splits a given list or string at a given index.
 * @template T
 * @param {number} index
 * @param {T|!Array<T>=} list
 * @return {!Array<T>|function(T): !Array<T>|!Array<!Array<T>>|function(!Array<T>): !Array<!Array<T>>}
 */
R.Static.prototype.splitAt = function(index, list) {};

/**
 * Splits a collection into slices of the specified length.
 * @template T
 * @param {number} a
 * @param {!Array<T>=} list
 * @return {!Array<!Array<T>>|function(!Array<T>): !Array<!Array<T>>}
 */
R.Static.prototype.splitEvery = function(a, list) {};

/**
 * Takes a list and a predicate and returns a pair of lists with the following properties:
 * - the result of concatenating the two output lists is equivalent to the input list;
 * - none of the elements of the first output list satisfies the predicate; and
 * - if the second output list is non-empty, its first element satisfies the predicate.
 * @template T, U
 * @param {function(T): boolean} pred
 * @param {!Array<U>=} list
 * @return {!Array<!Array<U>>|function(!Array<U>): !Array<!Array<U>>}
 */
R.Static.prototype.splitWhen = function(pred, list) {};

/**
 * Checks if a list starts with the provided values
 * @param {?} a
 * @param {?=} list
 * @return {boolean|function(?): boolean}
 */
R.Static.prototype.startsWith = function(a, list) {};

/**
 * Subtracts two numbers. Equivalent to `a - b` but curried.
 * @param {number} a
 * @param {number=} b
 * @return {number|function(number): number}
 */
R.Static.prototype.subtract = function(a, b) {};

/**
 * Adds together all the elements of a list.
 * @param {!Array<number>} list
 * @return {number}
 */
R.Static.prototype.sum = function(list) {};

/**
 * Finds the set (i.e. no duplicates) of all elements contained in the first or second list, but not both.
 * @template T
 * @param {!Array<T>} list1_or_list
 * @param {!Array<T>=} list2
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.symmetricDifference = function(list1_or_list, list2) {};

/**
 * Finds the set (i.e. no duplicates) of all elements contained in the first or second list, but not both.
 * Duplication is determined according to the value returned by applying the supplied predicate to two list elements.
 * @template T
 * @param {function(T, T): boolean} pred
 * @param {!Array<T>=} list1
 * @param {!Array<T>=} list2
 * @return {!Array<T>|!R.CurriedFunction2<!Array<T>, !Array<T>, !Array<T>>}
 */
R.Static.prototype.symmetricDifferenceWith = function(pred, list1, list2) {};

/**
 * A function that always returns true. Any passed in parameters are ignored.
 * @return {boolean}
 */
R.Static.prototype.T = function() {};

/**
 * Returns all but the first element of a list or string.
 * @template T
 * @param {!Array<T>|string} list
 * @return {!Array<T>|string}
 */
R.Static.prototype.tail = function(list) {};

/**
 * Returns a new list containing the first `n` elements of the given list.  If
 * `n > * list.length`, returns a list of `list.length` elements.
 * @template T
 * @param {number} n
 * @param {!Array<T>|string=} xs
 * @return {!Array<T>|string|?}
 */
R.Static.prototype.take = function(n, xs) {};

/**
 * Returns a new list containing the last n elements of the given list. If n > list.length,
 * returns a list of list.length elements.
 * @template T
 * @param {number} n
 * @param {!Array<T>|string=} xs
 * @return {!Array<T>|string|?}
 */
R.Static.prototype.takeLast = function(n, xs) {};

/**
 * Returns a new list containing the last n elements of a given list, passing each value
 * to the supplied predicate function, and terminating when the predicate function returns
 * false. Excludes the element that caused the predicate function to fail. The predicate
 * function is passed one argument: (value).
 * @template T
 * @param {function(T): boolean} pred
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.takeLastWhile = function(pred, list) {};

/**
 * Returns a new list containing the first `n` elements of a given list, passing each value
 * to the supplied predicate function, and terminating when the predicate function returns
 * `false`.
 * @template T
 * @param {function(T): boolean} fn
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.takeWhile = function(fn, list) {};

/**
 * The function to call with x. The return value of fn will be thrown away.
 * @template T
 * @param {function(T): ?} fn
 * @param {T=} value
 * @return {T|function(T): T}
 */
R.Static.prototype.tap = function(fn, value) {};

/**
 * Determines whether a given string matches a given regular expression.
 * @param {!RegExp} regexp
 * @param {string=} str
 * @return {boolean|function(string): boolean}
 */
R.Static.prototype.test = function(regexp, str) {};

/**
 * Calls an input function `n` times, returning an array containing the results of those
 * function calls.
 * @template T
 * @param {function(number): T} fn
 * @param {number=} n
 * @return {!Array<T>|function(number): !Array<T>}
 */
R.Static.prototype.times = function(fn, n) {};

/**
 * The lower case version of a string.
 * @param {string} str
 * @return {string}
 */
R.Static.prototype.toLower = function(str) {};

/**
 * Converts an object into an array of key, value arrays.
 * Only the object's own properties are used.
 * Note that the order of the output array is not guaranteed to be
 * consistent across different JS platforms.
 * @template F, S
 * @param {?} obj
 * @return {!Array<!Array<?>>}
 */
R.Static.prototype.toPairs = function(obj) {};

/**
 * Converts an object into an array of key, value arrays.
 * The object's own properties and prototype properties are used.
 * Note that the order of the output array is not guaranteed to be
 * consistent across different JS platforms.
 * @template F, S
 * @param {?} obj
 * @return {!Array<!Array<?>>}
 */
R.Static.prototype.toPairsIn = function(obj) {};

/**
 * Returns the string representation of the given value. eval'ing the output should
 * result in a value equivalent to the input value. Many of the built-in toString
 * methods do not satisfy this requirement.
 * 
 * If the given value is an [object Object] with a toString method other than
 * Object.prototype.toString, this method is invoked with no arguments to produce the
 * return value. This means user-defined constructor functions can provide a suitable
 * toString method.
 * @template T
 * @param {T} val
 * @return {string}
 */
R.Static.prototype.toString = function(val) {};

/**
 * The upper case version of a string.
 * @param {string} str
 * @return {string}
 */
R.Static.prototype.toUpper = function(str) {};

/**
 * Initializes a transducer using supplied iterator function. Returns a single item by iterating through the
 * list, successively calling the transformed iterator function and passing it an accumulator value and the
 * current value from the array, and then passing the result to the next call.
 * @template T, U
 * @param {function(!Array<T>): !Array<T>} xf
 * @param {function(!Array<U>, U): !Array<U>=} fn
 * @param {!Array<T>=} acc
 * @param {!Array<T>=} list
 * @return {U|function(function(!Array<U>, U): !Array<U>, !Array<T>, !Array<T>): U|function(!Array<T>, !Array<T>): U|function(!Array<T>): U}
 */
R.Static.prototype.transduce = function(xf, fn, acc, list) {};

/**
 * Transposes the rows and columns of a 2D list. When passed a list of n lists of length x, returns a list of x lists of length n.
 * @template T
 * @param {!Array<!Array<T>>} list
 * @return {!Array<!Array<T>>}
 */
R.Static.prototype.transpose = function(list) {};

/**
 * Maps an Applicative-returning function over a Traversable, then uses
 * sequence to transform the resulting Traversable of Applicative into
 * an Applicative of Traversable.
 * @template T, U, A
 * @param {function(!Array<U>): A} of
 * @param {function(T): U=} fn
 * @param {!Array<T>=} list
 * @return {A|function(!Array<T>): A|function(function(T): U, !Array<T>): A}
 */
R.Static.prototype.traverse = function(of, fn, list) {};

/**
 * Removes (strips) whitespace from both ends of the string.
 * @param {string} str
 * @return {string}
 */
R.Static.prototype.trim = function(str) {};

/**
 * tryCatch takes two functions, a tryer and a catcher. The returned function evaluates the tryer; if it does
 * not throw, it simply returns the result. If the tryer does throw, the returned function evaluates the catcher
 * function and returns its result. Note that for effective composition with this function, both the tryer and
 * catcher functions must return the same type of results.
 * @template T
 * @param {function(!Array<?>): T} tryer
 * @param {function(!Array<?>): T} catcher
 * @return {function(!Array<?>): T}
 */
R.Static.prototype.tryCatch = function(tryer, catcher) {};

/**
 * Gives a single-word string description of the (native) type of a value, returning such answers as 'Object',
 * 'Number', 'Array', or 'Null'. Does not attempt to distinguish user Object types any further, reporting them
 * all as 'Object'.
 * @param {?} val
 * @return {string}
 */
R.Static.prototype.type = function(val) {};

/**
 * Takes a function fn, which takes a single array argument, and returns a function which:
 * - takes any number of positional arguments;
 * - passes these arguments to fn as an array; and
 * - returns the result.
 * In other words, R.unapply derives a variadic function from a function which takes an array.
 * R.unapply is the inverse of R.apply.
 * @template T
 * @param {function(!Array<?>): T} fn
 * @return {function(!Array<?>): T}
 */
R.Static.prototype.unapply = function(fn) {};

/**
 * Wraps a function of any arity (including nullary) in a function that accepts exactly 1 parameter.
 * Any extraneous parameters will not be passed to the supplied function.
 * @template T
 * @param {function(T, !Array<?>): ?} fn
 * @return {function(T): ?}
 */
R.Static.prototype.unary = function(fn) {};

/**
 * Returns a function of arity n from a (manually) curried function.
 * @template T
 * @param {number} len
 * @param {function(?): ?} fn
 * @return {function(!Array<?>): T}
 */
R.Static.prototype.uncurryN = function(len, fn) {};

/**
 * Builds a list from a seed value. Accepts an iterator function, which returns either false
 * to stop iteration or an array of length 2 containing the value to add to the resulting
 * list and the seed to be used in the next call to the iterator function.
 * @template T, TResult
 * @param {function(T): (boolean|!Array<?>)} fn
 * @param {T=} seed
 * @return {!Array<TResult>|function(T): !Array<TResult>}
 */
R.Static.prototype.unfold = function(fn, seed) {};

/**
 * Combines two lists into a set (i.e. no duplicates) composed of the
 * elements of each list.
 * @template T
 * @param {!Array<T>} as
 * @param {!Array<T>=} bs
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.union = function(as, bs) {};

/**
 * Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.  Duplication is
 * determined according to the value returned by applying the supplied predicate to two list elements.
 * @template T
 * @param {function(T, T): boolean} pred
 * @param {!Array<T>=} list1
 * @param {!Array<T>=} list2
 * @return {!Array<T>|!R.CurriedFunction2<!Array<T>, !Array<T>, !Array<T>>}
 */
R.Static.prototype.unionWith = function(pred, list1, list2) {};

/**
 * Returns a new list containing only one copy of each element in the original list.
 * @template T
 * @param {!Array<T>} list
 * @return {!Array<T>}
 */
R.Static.prototype.uniq = function(list) {};

/**
 * Returns a new list containing only one copy of each element in the original list,
 * based upon the value returned by applying the supplied function to each list element.
 * Prefers the first item if the supplied function produces the same value on two items.
 * R.equals is used for comparison.
 * @template T, U
 * @param {function(T): U} fn
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.uniqBy = function(fn, list) {};

/**
 * Returns a new list containing only one copy of each element in the original list, based upon the value
 * returned by applying the supplied predicate to two list elements.
 * @template T, U
 * @param {function(T, T): boolean} pred
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.uniqWith = function(pred, list) {};

/**
 * Tests the final argument by passing it to the given predicate function. If the predicate is not satisfied,
 * the function will return the result of calling the whenFalseFn function with the same argument. If the
 * predicate is satisfied, the argument is returned as is.
 * @template T, U
 * @param {function(T): boolean} pred
 * @param {function(T): U} whenFalseFn
 * @param {T=} obj
 * @return {U|function(T): U}
 */
R.Static.prototype.unless = function(pred, whenFalseFn, obj) {};

/**
 * Returns a new list by pulling every item at the first level of nesting out, and putting
 * them in a new array.
 * @template T
 * @param {(!Array<T>|!Array<!Array<T>>)} x
 * @return {!Array<T>}
 */
R.Static.prototype.unnest = function(x) {};

/**
 * Takes a predicate, a transformation function, and an initial value, and returns a value of the same type as
 * the initial value. It does so by applying the transformation until the predicate is satisfied, at which point
 * it returns the satisfactory value.
 * @template T, U
 * @param {function(T): boolean} pred
 * @param {function(T): U} fn
 * @param {U=} init
 * @return {U|function(U): U}
 */
R.Static.prototype.until = function(pred, fn, init) {};

/**
 * Returns a new copy of the array with the element at the provided index replaced with the given value.
 * @template T
 * @param {number} index
 * @param {T} value
 * @param {!Array<T>=} list
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.update = function(index, value, list) {};

/**
 * Accepts a function fn and a list of transformer functions and returns a new curried function.
 * When the new function is invoked, it calls the function fn with parameters consisting of the
 * result of calling each supplied handler on successive arguments to the new function.
 * 
 * If more arguments are passed to the returned function than transformer functions, those arguments
 * are passed directly to fn as additional parameters. If you expect additional arguments that don't
 * need to be transformed, although you can ignore them, it's best to pass an identity function so
 * that the new function reports the correct arity.
 * @param {function(!Array<?>): ?} fn
 * @param {!Array<function(!Array<?>): ?>} transformers
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.useWith = function(fn, transformers) {};

/**
 * Returns a list of all the enumerable own properties of the supplied object.
 * Note that the order of the output array is not guaranteed across
 * different JS platforms.
 * @template T
 * @param {?} obj
 * @return {!Array<T>}
 */
R.Static.prototype.values = function(obj) {};

/**
 * Returns a list of all the properties, including prototype properties, of the supplied
 * object. Note that the order of the output array is not guaranteed to be consistent across different JS platforms.
 * @template T
 * @param {?} obj
 * @return {!Array<T>}
 */
R.Static.prototype.valuesIn = function(obj) {};

/**
 * Returns a "view" of the given data structure, determined by the given lens. The lens's focus determines which
 * portion of the data structure is visible.
 * @template T, U
 * @param {!R.Lens} lens
 * @param {T=} obj
 * @return {function(T): U|U}
 */
R.Static.prototype.view = function(lens, obj) {};

/**
 * Tests the final argument by passing it to the given predicate function. If the predicate is satisfied, the function
 * will return the result of calling the whenTrueFn function with the same argument. If the predicate is not satisfied,
 * the argument is returned as is.
 * @template T, U
 * @param {function(T): boolean} pred
 * @param {function(T): U} whenTrueFn
 * @param {T=} obj
 * @return {U|function(T): U}
 */
R.Static.prototype.when = function(pred, whenTrueFn, obj) {};

/**
 * Takes a spec object and a test object and returns true if the test satisfies the spec.
 * Any property on the spec that is not a function is interpreted as an equality
 * relation.
 * 
 * If the spec has a property mapped to a function, then `where` evaluates the function, passing in
 * the test object's value for the property in question, as well as the whole test object.
 * 
 * `where` is well suited to declarativley expressing constraints for other functions, e.g.,
 * `filter`, `find`, `pickWith`, etc.
 * @template T, U, ObjFunc2
 * @param {T|ObjFunc2} spec
 * @param {U=} testObj
 * @return {boolean|function(U): boolean}
 */
R.Static.prototype.where = function(spec, testObj) {};

/**
 * Takes a spec object and a test object; returns true if the test satisfies the spec,
 * false otherwise. An object satisfies the spec if, for each of the spec's own properties,
 * accessing that property of the object gives the same value (in R.eq terms) as accessing
 * that property of the spec.
 * @template T, U
 * @param {T} spec
 * @param {U=} obj
 * @return {boolean|function(U): boolean}
 */
R.Static.prototype.whereEq = function(spec, obj) {};

/**
 * Returns a new list without values in the first argument. R.equals is used to determine equality.
 * Acts as a transducer if a transformer is given in list position.
 * @template T
 * @param {!Array<T>} list1
 * @param {!Array<T>=} list2
 * @return {!Array<T>|function(!Array<T>): !Array<T>}
 */
R.Static.prototype.without = function(list1, list2) {};

/**
 * Wrap a function inside another to allow you to make adjustments to the parameters, or do other processing
 * either before the internal function is called or with its results.
 * @param {function(!Array<?>): ?} fn
 * @param {function(!Array<?>): ?} wrapper
 * @return {function(!Array<?>): ?}
 */
R.Static.prototype.wrap = function(fn, wrapper) {};

/**
 * Creates a new list out of the two supplied by creating each possible pair from the lists.
 * @template K, V
 * @param {!Array<K>} as
 * @param {!Array<V>=} bs
 * @return {!Array<!R.KeyValuePair<K, V>>|function(!Array<V>): !Array<!R.KeyValuePair<K, V>>}
 */
R.Static.prototype.xprod = function(as, bs) {};

/**
 * Creates a new list out of the two supplied by pairing up equally-positioned items from
 * both lists. Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
 * @template K, V
 * @param {!Array<K>} list1
 * @param {!Array<V>=} list2
 * @return {!Array<!R.KeyValuePair<K, V>>|function(!Array<V>): !Array<!R.KeyValuePair<K, V>>}
 */
R.Static.prototype.zip = function(list1, list2) {};

/**
 * @template T
 * @param {!Array<string>} keys
 * @param {!Array<T>=} values
 * @return {!Object<string,T>|function(!Array<T>): !Object<string,T>}
 */
R.Static.prototype.zipObj = function(keys, values) {};

/**
 * Creates a new list out of the two supplied by applying the function to each
 * equally-positioned pair in the lists.
 * @template T, U, TResult
 * @param {function(T, U): TResult} fn
 * @param {!Array<T>=} list1
 * @param {!Array<U>=} list2
 * @return {!Array<TResult>|function(!Array<U>): !Array<TResult>|function(!Array<T>, !Array<U>): !Array<TResult>}
 */
R.Static.prototype.zipWith = function(fn, list1, list2) {};

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
