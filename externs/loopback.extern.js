/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/loopback/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/**
 * @return {!l.LoopBackApplication}
 */
function l() {}
/**
 * @extends {Application}
 * @record
 * @struct
 */
l.LoopBackApplication = function() {};

/**
 * @return {void}
 */
l.LoopBackApplication.prototype.start = function() {};

/**
 * Register a connector
 * When a new data-source is being added via `app.dataSource`, the connector
 * name is looked up in the registered connectors first
 * Connectors are required to be explicitly registered only for applications
 * using browserify, because browserify does not support dynamic require,
 * which is used by LoopBack to automatically load the connector module
 *    by `require('loopback-connector-{name}')`
 * @param {string} name
 * @param {?} connector
 * @return {void}
 */
l.LoopBackApplication.prototype.connector = function(name, connector) {};

/**
 * Define a DataSource
 * @param {string} name
 * @param {?} config
 * @return {void}
 */
l.LoopBackApplication.prototype.dataSource = function(name, config) {};

/**
 *  Enable app wide authentication
 * @return {void}
 */
l.LoopBackApplication.prototype.enableAuth = function() {};

/**
 * Attach a model to the app. The `Model` will be available on the
 * `app.models` object
 * Example - Attach an existing mode
 * ```js
 * var User = loopback.User;
 * app.model(User)
 * ```
 * Example - Attach an existing model, alter some aspects of the model:
 * ```js
 * var User = loopback.User;
 * app.model(User, { dataSource: 'db' })
 * ``
 * \@options {any} config The model's configuration
 * \@property {string|any} dataSource The `DataSource` to which to attach the model
 * \@property {boolean} [public] Whether the model should be exposed via REST API
 * \@property {any} [relations] Relations to add/update
 * \@en
 * @param {?} Model
 * @param {{dataSource: ?, public: boolean, relations: ?}} config
 * @return {?}
 */
l.LoopBackApplication.prototype.model = function(Model, config) {};

/**
 * Get the models exported by the app. Returns only models defined using `app.model()
 * There are two ways to access models
 * 1.  Call `app.models()` to get a list of all models
 * ```js
 * var models = app.models()
 * models.forEach(function(Model) {
 *  console.log(Model.modelName); // color
 * });
 * ```
 * 2. Use `app.model` to access a model by name.
 * `app.models` has properties for all defined models
 * The following example illustrates accessing the `Product` and `CustomerReceipt` models
 * using the `models` object
 * ```js
 * var loopback = require('loopback');
 *  var app = loopback();
 *  app.boot({
 *   dataSources: {
 *     db: {connector: 'memory'}
 *   }
 * })
 * app.model('product', {dataSource: 'db'});
 * app.model('customer-receipt', {dataSource: 'db'})
 * // available based on the given name
 * var Product = app.models.Product
 * // also available as camelCase
 * var product = app.models.product
 * // multi-word models are avaiable as pascal cased
 * var CustomerReceipt = app.models.CustomerReceipt
 * // also available as camelCase
 * var customerReceipt = app.models.customerReceipt;
 * ``
 *  \@returns {Array} Array of model classes
 * @return {!Array<?>}
 */
l.LoopBackApplication.prototype.models = function() {};

/**
 * Get all remote objects.
 * @return {?}
 */
l.LoopBackApplication.prototype.remoteObjects = function() {};

/**
 * Lazily load a set of [remote objects](apidocs.strongloop.com/strong-remoting/#remoteObjectsoptions).
 * 
 * *NOTE:** Calling `app.remotes()` more than once returns only a single set of remote objects.
 * @return {?}
 */
l.LoopBackApplication.prototype.remotes = function() {};

/**
 * Register a middleware using a factory function and a JSON config
 * **Example*
 * ```js
 * app.middlewareFromConfig(compression, {
 *   enabled: true,
 *   phase: 'initial',
 *   params: {
 *     threshold: 128
 *   }
 * });
 * ``
 *   Typically a result of `require()` call, e.g. `require('compression')`.
 * \@options {any} config The configuration.
 * \@property {string} phase The phase to register the middleware in.
 * \@property {boolean} [enabled] Whether the middleware is enabled.
 *   Default: `true`.
 * \@property {Array|*} [params] The arguments to pass to the factory
 *   function. Either an Array of arguments,
 *   or the value of the first argument when the factory expects
 *   a single argument only.
 * \@property {Array|string|RegExp} [paths] Optional list of paths limiting
 *   the scope of the middleware
 * \@header app.middlewareFromConfig(factory, config
 * @param {function(): void} factory
 * @param {{phase: string, enabled: boolean, params: ?, paths: (string|!RegExp|!Array<?>)}} config
 * @return {?}
 */
l.LoopBackApplication.prototype.middlewareFromConfig = function(factory, config) {};

/**
 * Register (new) middleware phases.
 * 
 * If all names are new, then the phases are added just before "routes" phase.
 * Otherwise the provided list of names is merged with the existing phases
 * in such way that the order of phases is preserved
 * 
 * **Examples*
 * ```js
 * // built-in phases:
 * // initial, session, auth, parse, routes, files, fina
 * 
 * app.defineMiddlewarePhases('custom');
 * // new list of phases
 * // initial, session, auth, parse, custom, routes, files, fina
 * app.defineMiddlewarePhases([
 * 'initial', 'postinit', 'preauth', 'routes', 'subapps'
 * ]);
 * // new list of phases
 * // initial, postinit, preauth, session, auth, parse, custom,
 * // routes, subapps, files, final
 * ``
 * names to add
 * \@header app.defineMiddlewarePhases(nameOrArray
 * @param {(string|!Array<string>)} nameOrArray
 * @return {?}
 */
l.LoopBackApplication.prototype.defineMiddlewarePhases = function(nameOrArray) {};

/**
 * Register a middleware handler to be executed in a given phase.
 *   the scope of the middleware.
 *   string paths are interpreted as expressjs path patterns,
 *   regular expressions are used as-is.
 *   `function(req, res, next)` or
 *   `function(err, req, res, next)`
 * \@header app.middleware(name, handler
 * @param {string} name
 * @param {(string|!RegExp|!Array<?>)=} paths
 * @param {?=} handler
 * @return {?}
 */
l.LoopBackApplication.prototype.middleware = function(name, paths, handler) {};
/**
 * @constructor
 * @struct
 */
l.loopback = function() {};
 /** @type {string} */
l.loopback.prototype.version;
 /** @type {string} */
l.loopback.prototype.mime;
 /** @type {boolean} */
l.loopback.prototype.isBrowser;
 /** @type {boolean} */
l.loopback.prototype.isServer;
 /** @type {!l.Registry} */
l.loopback.prototype.registry;
 /** @type {string} */
l.loopback.prototype.faviconFile;

/**
 * Alter an existing Model class.
 * \@options {any} config Additional configuration to apply
 * \@property {any} dataSource Attach the model to a dataSource.
 * \@property {any} [relations] Model relations to add/update
 * \@header loopback.configureModel(ModelCtor, config
 * @param {!l.Model} ModelCtor
 * @param {{dataSource: ?, relations: ?}} config
 * @return {void}
 */
l.loopback.configureModel = function(ModelCtor, config) {};

/**
 * Create a data source with passing the provided options to the connector
 * \@options {any} options Data Source options
 * \@property {any} connector LoopBack connector.
 * \@property {*} [*] Other&nbsp;connector properties.
 * See the relevant connector documentation
 * @param {string} name
 * @param {{connector: ?, properties: ?}} options
 * @return {void}
 */
l.loopback.createDataSource = function(name, options) {};

/**
 * Create a named vanilla JavaScript class constructor with an attached
 * set of properties and options
 * This function comes with two variants:
 *  * `loopback.createModel(name, properties, options)`
 *  * `loopback.createModel(config)
 * In the second variant, the parameters `name`, `properties` and `options`
 * are provided in the config object. Any additional config entries are
 * interpreted as `options`, i.e. the following two configs are identical
 * 
 * ```js
 * { name: 'Customer', base: 'User' }
 * { name: 'Customer', options: { base: 'User' } }
 * ``
 * **Example*
 * Create an `Author` model using the three-parameter variant
 * ```js
 * loopback.createModel(
 *   'Author',
 *   {
 *     firstName: 'string',
 *     lastName: 'string'
 *   },
 *   {
 *     relations: {
 *       books: {
 *         model: 'Book',
 *         type: 'hasAndBelongsToMany'
 *       }
 *     }
 *   }
 * );
 * ``
 * Create the same model using a config object
 * ```js
 * loopback.createModel({
 *   name: 'Author',
 *   properties: {
 *     firstName: 'string',
 *     lastName: 'string'
 *   },
 *   relations: {
 *     books: {
 *       model: 'Book',
 *       type: 'hasAndBelongsToMany'
 *     }
 *   }
 * });
 * ``
 * \@header loopback.createMode
 * @param {string} name
 * @param {?} properties
 * @param {?} options
 * @return {void}
 */
l.loopback.createModel = function(name, properties, options) {};

/**
 * Look up a model class by name from all models created by
 * `loopback.createModel()`
 * \@header loopback.findModel(modelName
 * @param {string} modelName
 * @return {!l.Model}
 */
l.loopback.findModel = function(modelName) {};

/**
 * Look up a model class by name from all models created by
 * `loopback.createModel()`. Throw an error when no such model exists
 * \@header loopback.getModel(modelName
 * @param {string} modelName
 * @return {!l.Model}
 */
l.loopback.getModel = function(modelName) {};

/**
 * Look up a model class by the base model class.
 * The method can be used by LoopBack
 * to find configured models in models.json over the base model.
 * \@header loopback.getModelByType(modelType
 * @param {!l.Model} modelType
 * @return {!l.Model}
 */
l.loopback.getModelByType = function(modelType) {};

/**
 * Get an in-memory data source. Use one if it already exists
 * If not provided, the `'default'` is used
 * @param {string=} name
 * @return {void}
 */
l.loopback.memory = function(name) {};

/**
 * Add a remote method to a model.
 * @param {function(): void} fn
 * @param {?} options
 * @return {void}
 */
l.loopback.remoteMethod = function(fn, options) {};

/**
 * Create a template helper
 *     var render = loopback.template('foo.ejs');
 *     var html = render({foo: 'bar'})
 * @param {string} path
 * @return {void}
 */
l.loopback.template = function(path) {};
/**
 * @constructor
 * @struct
 */
l.Registry = function() {};

/**
 * @param {!Array<?>} acls
 * @param {?} acl
 * @return {void}
 */
l.Registry.addACL = function(acls, acl) {};

/**
 * Alter an existing Model class.
 * \@options {any} config Additional configuration to apply
 * \@property {any} dataSource Attach the model to a dataSource.
 * \@property {any} [relations] Model relations to add/update
 * \@header loopback.configureModel(ModelCtor, config
 * @param {!l.Model} ModelCtor
 * @param {{dataSource: ?, relations: ?}} config
 * @return {void}
 */
l.Registry.prototype.configureModel = function(ModelCtor, config) {};

/**
 * Create a data source with passing the provided options to the connector
 * \@options {any} options Data Source options
 * \@property {any} connector LoopBack connector.
 * \@property {*} [*] Other&nbsp;connector properties.
 *   See the relevant connector documentation
 * @param {string} name
 * @param {{connector: ?, properties: ?}} options
 * @return {void}
 */
l.Registry.prototype.createDataSource = function(name, options) {};

/**
 * Create a named vanilla JavaScript class constructor with an attached
 * set of properties and options
 * This function comes with two variants:
 *  * `loopback.createModel(name, properties, options)`
 *  * `loopback.createModel(config)
 * In the second variant, the parameters `name`, `properties` and `options`
 * are provided in the config object. Any additional config entries are
 * interpreted as `options`, i.e. the following two configs are identical
 * ```js
 * { name: 'Customer', base: 'User' }
 * { name: 'Customer', options: { base: 'User' } }
 * ``
 * **Example*
 * Create an `Author` model using the three-parameter variant
 * ```js
 * loopback.createModel(
 *   'Author',
 *   {
 *     firstName: 'string',
 *     lastName: 'string'
 *   },
 *   {
 *     relations: {
 *       books: {
 *         model: 'Book',
 *         type: 'hasAndBelongsToMany'
 *       }
 *     }
 *   }
 * );
 * ``
 * Create the same model using a config object
 * ```js
 * loopback.createModel({
 *   name: 'Author',
 *   properties: {
 *     firstName: 'string',
 *     lastName: 'string'
 *   },
 *   relations: {
 *     books: {
 *       model: 'Book',
 *       type: 'hasAndBelongsToMany'
 *     }
 *   }
 * });
 * ``
 * \@header loopback.createMode
 * @param {string} name
 * @param {?} properties
 * @param {?} options
 * @return {void}
 */
l.Registry.prototype.createModel = function(name, properties, options) {};

/**
 * Look up a model class by name from all models created by
 * `loopback.createModel()`
 * \@header loopback.findModel(modelName
 * @param {string} modelOrName
 * @return {!l.Model}
 */
l.Registry.prototype.findModel = function(modelOrName) {};

/**
 * Look up a model class by name from all models created by
 * `loopback.createModel()`. **Throw an error when no such model exists.*
 * \@header loopback.getModel(modelName
 * @param {string} modelOrName
 * @return {!l.Model}
 */
l.Registry.prototype.getModel = function(modelOrName) {};

/**
 * Look up a model class by the base model class.
 * The method can be used by LoopBack
 * to find configured models in models.json over the base model.
 * \@header loopback.getModelByType(modelType
 * @param {!l.Model} modelType
 * @return {!l.Model}
 */
l.Registry.prototype.getModelByType = function(modelType) {};

/**
 * Get an in-memory data source. Use one if it already exists
 * If not provided, the `'default'` is used
 * @param {string=} name
 * @return {void}
 */
l.Registry.prototype.memory = function(name) {};

/**
 * @constructor
 * @struct
 * context The context object
 * @param {!l.Context} context
 */
l.AccessContext = function(context) {};

/**
 * Add a principal to the context
 * @param {string} principalType
 * @param {?} principalId
 * @param {string=} principalName
 * @return {boolean}
 */
l.AccessContext.prototype.addPrincipal = function(principalType, principalId, principalName) {};

/**
 * Get the user id
 * @return {?}
 */
l.AccessContext.prototype.getUserId = function() {};

/**
 * Get the application id
 * @return {?}
 */
l.AccessContext.prototype.getAppId = function() {};

/**
 * Check if the access context has authenticated principals
 * @return {boolean}
 */
l.AccessContext.prototype.isAuthenticated = function() {};
/**
 * @record
 * @struct
 */
l.Context = function() {};
 /** @type {!Array<!l.Principal>} */
l.Context.prototype.principals;
 /** @type {string} */
l.Context.prototype.modelName;
 /** @type {string} */
l.Context.prototype.modelId;
 /** @type {string} */
l.Context.prototype.property;
 /** @type {string} */
l.Context.prototype.method;
 /** @type {string} */
l.Context.prototype.accesType;
 /** @type {!l.AccessToken} */
l.Context.prototype.accessToken;

/**
 * The model class
 * @return {void}
 */
l.Context.prototype.model = function() {};

/**
 * @constructor
 * @struct
 * @param {string} model
 * @param {string} property
 * @param {string} accessType
 * @param {string} permission
 */
l.AccessRequest = function(model, property, accessType, permission) {};

/**
 * Does the given `ACL` apply to this `AccessRequest`
 * @param {!l.ACL} acl
 * @return {void}
 */
l.AccessRequest.prototype.exactlyMatches = function(acl) {};

/**
 * Is the request for access allowed
 * @return {boolean}
 */
l.AccessRequest.prototype.isAllowed = function() {};

/**
 * Does the request contain any wildcards
 * @return {boolean}
 */
l.AccessRequest.prototype.isWildcard = function() {};

/**
 * @constructor
 * @struct
 * @param {string} type
 * @param {?} id
 * @param {string} name
 */
l.Principal = function(type, id, name) {};

/**
 * Compare if two principals are equal
 * Returns true if argument principal is equal to this principal.
 * @param {?} p
 * @return {void}
 */
l.Principal.prototype.equals = function(p) {};

/**
 * @constructor
 * @struct
 * @param {?} data
 */
l.Model = function(data) {};
 /** @type {string} */
l.Model.modelName;
 /** @type {?} */
l.Model.dataSource;
 /** @type {?} */
l.Model.sharedMethod;
 /** @type {!l.Settings} */
l.Model.prototype.settings;

/**
 * Check if the given access token can invoke the specified method
 * \@callback {() => void} callback The callback function.
 * @param {!l.AccessToken} token
 * @param {?} modelId
 * @param {?} sharedMethod
 * @param {?} ctx
 * @param {function((string|!Error), boolean): void} callback
 * @return {void}
 */
l.Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {};

/**
 * Disable remote invocation for the method with the given name
 * `false` if the method defined on the prototype (eg.
 * `MyModel.prototype.myMethod`)
 * @param {string} name
 * @param {boolean} isStatic
 * @return {void}
 */
l.Model.disableRemoteMethod = function(name, isStatic) {};

/**
 * Disable remote invocation for the method with the given name.
 * The name of the method (include "prototype." if the method is defined on the prototype).
 * @param {string} name
 * @return {void}
 */
l.Model.disableRemoteMethodByName = function(name) {};

/**
 * Get the `Application` object to which the Model is attached
 * \@callback {() => void} callback Callback function called with `(err, app)` arguments.
 * \@end
 * @param {function(!Error, !l.Application): void} callback
 * @return {void}
 */
l.Model.getApp = function(callback) {};

/**
 * Enabled deeply-nested queries of related models via REST API
 * \@options {any} [options] It is optional. See below.
 * \@callback {() => void} filterCallback The Optional filter function.
 * @param {string} relationName
 * @param {string} pathName
 * @param {string} filterMethod
 * @param {string} paramName
 * @param {string} getterName
 * @param {boolean} hooks
 * @param {!Object=} options
 * @param {function(?, ?): void=} filterCallback
 * @return {void}
 */
l.Model.nestRemoting = function(relationName, pathName, filterMethod, paramName, getterName, hooks, options, filterCallback) {};

/**
 * Enable remote invocation for the specified method.
 * See [Remote methods](docs.strongloop.com/display/LB/Remote+methods) for more information
 * Static method example:
 * ```js
 * Model.myMethod();
 * Model.remoteMethod('myMethod');
 * ``
 * See [Remote methods - Options](docs.strongloop.com/display/LB/Remote+methods#Remotemethods-Options)
 * @param {string} name
 * @param {?} options
 * @return {void}
 */
l.Model.prototype.remoteMethod = function(name, options) {};

/**
 * The `loopback.Model.extend()` method calls this when you create a model that extends another model.
 * Add any setup or configuration code you want executed when the model is created.
 * See  [Setting up a custom model](docs.strongloop.com/display/LB/Extending+built-in+models#Extendingbuilt-inmodels-Settingupacustommodel)
 * @return {void}
 */
l.Model.setup = function() {};

/**
 * loopback 3.x Remote hooks
 * http://loopback.io/doc/en/lb3/Remote-hooks.html
 * @param {string} method
 * @param {function(!l.Context, (!l.Model|!e.NextFunction), !e.NextFunction): void} callback
 * @return {void}
 */
l.Model.prototype.beforeRemote = function(method, callback) {};

/**
 * @param {string} method
 * @param {function(!l.Context, (!l.Model|!e.NextFunction), !e.NextFunction): void} callback
 * @return {void}
 */
l.Model.prototype.afterRemote = function(method, callback) {};

/**
 * @param {string} method
 * @param {!e.NextFunction} callback
 * @return {void}
 */
l.Model.prototype.afterRemoteError = function(method, callback) {};

/**
 * @constructor
 * @struct
 * @param {string} name
 * @param {function(): void} constructor
 */
l.SharedClass = function(name, constructor) {};
 /** @type {function(): void} */
l.SharedClass.prototype.ctor;
 /** @type {?} */
l.SharedClass.prototype.http;

/**
 * Normalize HTTP path.
 * @return {void}
 */
l.SharedClass.normalizeHttpPath = function() {};

/**
 * Define a shared method with the given name.
 * @param {string} name
 * @param {?} options
 * @return {void}
 */
l.SharedClass.prototype.defineMethod = function(name, options) {};

/**
 * Disable a sharedMethod with the given name or function object.
 * @param {string} fn
 * @param {boolean} isStatic
 * @return {void}
 */
l.SharedClass.prototype.disableMethod = function(fn, isStatic) {};

/**
 * Disable a sharedMethod with the given static or prototype method name.
 * @param {string} methodName
 * @return {void}
 */
l.SharedClass.prototype.disableMethodByName = function(methodName) {};

/**
 * Find a sharedMethod with the given name or function object.
 * @param {function(): (string|void)} fn
 * @param {boolean} isStatic
 * @return {?}
 */
l.SharedClass.prototype.find = function(fn, isStatic) {};

/**
 * Find a sharedMethod with the given static or prototype method name.
 * @param {string} methodName
 * @return {?}
 */
l.SharedClass.prototype.findMethodByName = function(methodName) {};

/**
 * Get a key for the given method.
 * @param {string} fn
 * @param {boolean} isStatic
 * @return {void}
 */
l.SharedClass.prototype.getKeyFromMethodNameAndTarget = function(fn, isStatic) {};

/**
 * Get all shared methods belonging to this shared class.
 * @param {{includeDisabled: boolean}} options
 * @return {!Array<?>}
 */
l.SharedClass.prototype.methods = function(options) {};

/**
 * Define a shared method resolver for dynamically defining methods.
 * ```
 * // below is a simple example
 * sharedClass.resolve(function(define) {
 *    define('myMethod', {
 *          accepts: {arg: 'str', type: 'string'},
 *          returns: {arg: 'str', type: 'string'}
 *          errors: [ { code: 404, message: 'Not Found', responseModel: 'Error' } ]
 *    }, myMethod);
 * });
 * function myMethod(str, cb) {
 * cb(null, str);
 * }
 * ```
 * 
 * @param {function(): void} resolver
 * @return {void}
 */
l.SharedClass.prototype.resolve = function(resolver) {};
/**
 * @record
 * @struct
 */
l.Settings = function() {};
 /** @type {{path: string}} */
l.Settings.prototype.http;
 /** @type {!Array<!l.ACL>} */
l.Settings.prototype.acls;
/**
 * @extends {l.Model}
 * @constructor
 * @struct
 */
l.PersistedModel = function() {};

/**
 * Apply an update list
 * **Note: this is not atomic*
 * @param {!Array<?>} updates
 * @param {?} options
 * @param {function(): void} callback
 * @return {void}
 */
l.PersistedModel.bulkUpdate = function(updates, options, callback) {};

/**
 * Get the changes to a model since the specified checkpoint. Provide a filter object
 * to reduce the number of results returned.
 * \@callback {() => void} callback Callback function called with `(err, changes)` arguments.  Required.
 * @param {number} since
 * @param {?} filter
 * @param {function(!Error, !Array<?>): void} callback
 * @return {void}
 */
l.PersistedModel.changes = function(since, filter, callback) {};

/**
 * Create a checkpoint
 * @param {function(): void} callback
 * @return {void}
 */
l.PersistedModel.checkpoint = function(callback) {};

/**
 * Return the number of records that match the optional "where" filter.
 * ```
 * { key: val, key2: {gt: 'val2'}, ...}
 * ```
 * <br/>See
 * [Where filter](docs.strongloop.com/display/LB/Where+filter#Wherefilter-Whereclauseforothermethods).
 * \@callback {() => void} callback Callback function called with `(err, count)` arguments.  Required.
 * @param {?=} where
 * @param {function(!Error, number): void=} callback
 * @return {void}
 */
l.PersistedModel.count = function(where, callback) {};

/**
 * Create new instance of Model, and save to database
 * \@callback {() => void} callback Callback function called with `cb(err, obj)` signature.
 * @param {?=} data
 * @param {function(!Error, ?): void=} callback
 * @return {void}
 */
l.PersistedModel.create = function(data, callback) {};

/**
 * Create a change stream. See here for more info http://loopback.io/doc/en/lb2/Realtime-server-sent-events.html
 * @param {{where: ?}} options
 * @param {function(!Error, ?): void} callback
 * @return {void}
 */
l.PersistedModel.createChangeStream = function(options, callback) {};

/**
 * Create an update list (for `Model.bulkUpdate()`) from a delta list
 * (result of `Change.diff()`)
 * @param {!Array<?>} deltas
 * @param {function(): void} callback
 * @return {void}
 */
l.PersistedModel.createUpdates = function(deltas, callback) {};

/**
 * Get the current checkpoint ID
 * \@callback {() => void} callback Callback function called with `(err, currentCheckpointId)` arguments.  Required.
 * @param {function(!Error, number): void} callback
 * @return {void}
 */
l.PersistedModel.currentCheckpoint = function(callback) {};

/**
 * Destroy all model instances that match the optional `where` specification
 * ```
 * {key: val, key2: {gt: 'val2'}, ...}
 * ```
 * <br/>See
 * [Where filter](docs.strongloop.com/display/LB/Where+filter#Wherefilter-Whereclauseforothermethods)
 * 
 * \@callback {() => void} callback Optional callback function called with `(err, info)` arguments.
 * @param {?=} where
 * @param {function(!Error, ?, number): void=} callback
 * @return {void}
 */
l.PersistedModel.destroyAll = function(where, callback) {};

/**
 * Destroy model instance with the specified ID.
 * \@callback {() => void} callback Callback function called with `(err)` arguments.  Required.
 * @param {?} id
 * @param {function(!Error): void} callback
 * @return {void}
 */
l.PersistedModel.destroyById = function(id, callback) {};

/**
 * Get a set of deltas and conflicts since the given checkpoint
 * See [Change.diff()](#change-diff) for details
 * \@callback {() => void} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {number} since
 * @param {!Array<?>} remoteChanges
 * @param {function(!Error, ?): void} callback
 * @return {void}
 */
l.PersistedModel.diff = function(since, remoteChanges, callback) {};

/**
 * Enable the tracking of changes made to the model. Usually for replication.
 * @return {void}
 */
l.PersistedModel.enableChangeTracking = function() {};

/**
 * Check whether a model instance exists in database
 * \@callback {() => void} callback Callback function called with `(err, exists)` arguments.  Required.
 * @param {?} id
 * @param {function(!Error, boolean): void} callback
 * @return {void}
 */
l.PersistedModel.exists = function(id, callback) {};

/**
 * Find all model instances that match `filter` specification.
 * See [Querying models](docs.strongloop.com/display/LB/Querying+models)
 * \@options {any} [filter] Optional Filter JSON object; see below.
 * \@property {string|any|Array} fields Identify fields to include in return result.
 * <br/>See [Fields filter](docs.strongloop.com/display/LB/Fields+filter).
 * \@property {string|any|Array} include  See PersistedModel.include documentation.
 * <br/>See [Include filter](docs.strongloop.com/display/LB/Include+filter).
 * \@property {number} limit Maximum number of instances to return.
 * <br/>See [Limit filter](docs.strongloop.com/display/LB/Limit+filter).
 * \@property {string} order Sort order: either "ASC" for ascending or "DESC" for descending.
 * <br/>See [Order filter](docs.strongloop.com/display/LB/Order+filter).
 * \@property {number} skip number of results to skip.
 * <br/>See [Skip filter](docs.strongloop.com/display/LB/Skip+filter).
 * \@property {any} where Where clause, like
 * ```
 * { where: { key: val, key2: {gt: 'val2'}, ...} }
 * ```
 * <br/>See
 * [Where filter](docs.strongloop.com/display/LB/Where+filter#Wherefilter-Whereclauseforqueries)
 * \@callback {() => void} callback Callback function called with `(err, returned-instances)` arguments.    Required.
 * @param {{fields: ?, include: ?, limit: number, order: string, skip: number, where: ?}=} filter
 * @param {function(!Error, !Array<?>): void=} callback
 * @return {void}
 */
l.PersistedModel.find = function(filter, callback) {};

/**
 * Find object by ID with an optional filter for include/fields
 * \@options {any} [filter] Optional Filter JSON object; see below.
 * \@property {string|any|Array} fields Identify fields to include in return result.
 * <br/>See [Fields filter](docs.strongloop.com/display/LB/Fields+filter).
 * \@property {string|any|Array} include  See PersistedModel.include documentation.
 * <br/>See [Include filter](docs.strongloop.com/display/LB/Include+filter).
 * \@callback {() => void} callback Callback function called with `(err, instance)` arguments.  Required.
 * @param {?} id
 * @param {{fields: ?, include: ?}=} filter
 * @param {function(!Error, ?): void=} callback
 * @return {void}
 */
l.PersistedModel.findById = function(id, filter, callback) {};

/**
 * Find one model instance that matches `filter` specification.
 * Same as `find`, but limited to one result;
 * Returns object, not collection
 * \@options {any} [filter] Optional Filter JSON object; see below.
 * \@property {string|any|Array} fields Identify fields to include in return result.
 * <br/>See [Fields filter](docs.strongloop.com/display/LB/Fields+filter).
 * \@property {string|any|Array} include  See PersistedModel.include documentation.
 * <br/>See [Include filter](docs.strongloop.com/display/LB/Include+filter).
 * \@property {string} order Sort order: either "ASC" for ascending or "DESC" for descending.
 * <br/>See [Order filter](docs.strongloop.com/display/LB/Order+filter).
 * \@property {number} skip number of results to skip.
 * <br/>See [Skip filter](docs.strongloop.com/display/LB/Skip+filter).
 * \@property {any} where Where clause, like
 * ```
 * {where: { key: val, key2: {gt: 'val2'}, ...} }
 * ```
 * <br/>See
 * [Where filter](docs.strongloop.com/display/LB/Where+filter#Wherefilter-Whereclauseforqueries)
 * \@callback {() => void} callback Callback function called with `(err, returned-instance)` arguments.  Required.
 * @param {{fields: ?, include: ?, order: string, skip: number, where: ?}=} filter
 * @param {function(!Error, ?): void=} callback
 * @return {void}
 */
l.PersistedModel.findOne = function(filter, callback) {};

/**
 * Finds one record matching the optional filter object. If not found, creates
 * the object using the data provided as second argument. In this sense it is
 * the same as `find`, but limited to one object. Returns an object, not
 * collection. If you don't provide the filter object argument, it tries to
 * locate an existing object that matches the `data` argument
 * 
 * \@options {any} [filter] Optional Filter object; see below.
 * \@property {string|any|Array} fields Identify fields to include in return result.
 * <br/>See [Fields filter](docs.strongloop.com/display/LB/Fields+filter).
 * \@property {string|any|Array} include  See PersistedModel.include documentation.
 * <br/>See [Include filter](docs.strongloop.com/display/LB/Include+filter).
 * \@property {number} limit Maximum number of instances to return.
 * <br/>See [Limit filter](docs.strongloop.com/display/LB/Limit+filter).
 * \@property {string} order Sort order: either "ASC" for ascending or "DESC" for descending.
 * <br/>See [Order filter](docs.strongloop.com/display/LB/Order+filter).
 * \@property {number} skip number of results to skip.
 * <br/>See [Skip filter](docs.strongloop.com/display/LB/Skip+filter).
 * \@property {any} where Where clause, like
 * ```
 * {where: {key: val, key2: {gt: val2}, ...}}
 * ```
 * <br/>See
 * [Where filter](docs.strongloop.com/display/LB/Where+filter#Wherefilter-Whereclauseforqueries).
 * \@callback {() => void} callback Callback function called with `cb(err, instance, created)` arguments.  Required.
 * @param {?} data
 * @param {{fields: ?, include: ?, limit: number, order: string, skip: number, where: ?}=} filter
 * @param {function(!Error, ?, boolean): void=} callback
 * @return {void}
 */
l.PersistedModel.findOrCreate = function(data, filter, callback) {};

/**
 * Get the `Change` model.
 * Throws an error if the change model is not correctly setup.
 * @return {void}
 */
l.PersistedModel.getChangeModel = function() {};

/**
 * Get the `id` property name of the constructor
 * @return {string}
 */
l.PersistedModel.getIdName = function() {};

/**
 * Get the source identifier for this model or dataSource
 * \@callback {() => void} callback Callback function called with `(err, id)` arguments.
 * @param {function(!Error, string): void} callback
 * @return {void}
 */
l.PersistedModel.getSourceId = function(callback) {};

/**
 * Handle a change error. Override this method in a subclassing model to customize
 * change error handling
 * @param {!Error} err
 * @return {void}
 */
l.PersistedModel.handleChangeError = function(err) {};

/**
 * Specify that a change to the model with the given ID has occurred
 * \@callback {() => void} callback
 * @param {?} id
 * @param {function(!Error): void} callback
 * @return {void}
 */
l.PersistedModel.rectifyChange = function(id, callback) {};

/**
 * Replace attributes for a model instance whose id is the first input
 * argument and persist it into the datasource.
 * Performs validation before replacing
 * \@options {any} [options] Options for replace
 * \@property {boolean} validate Perform validation before saving.  Default is true.
 * \@callback {() => void} callback Callback function called with `(err, instance)` arguments.
 * @param {?} id
 * @param {?} data
 * @param {{validate: boolean}=} options
 * @param {function(!Error, ?): void=} callback
 * @return {void}
 */
l.PersistedModel.replaceById = function(id, data, options, callback) {};

/**
 * Replace or insert a model instance; replace existing record if one is found,
 * such that parameter `data.id` matches `id` of model instance; otherwise,
 * insert a new record.
 * \@options {any} [options] Options for replaceOrCreate
 * \@property {boolean} validate Perform validation before saving.  Default is true.
 * \@callback {() => void} callback Callback function called with `cb(err, obj)` signature.
 * @param {?} data
 * @param {{validate: boolean}=} options
 * @param {function(!Error, ?): void=} callback
 * @return {void}
 */
l.PersistedModel.replaceOrCreate = function(data, options, callback) {};

/**
 * Replicate changes since the given checkpoint to the given target model
 * \@callback {() => void} [callback] Callback function called with `(err, conflicts)` arguments.
 * argument for the next replication
 * @param {number=} since
 * @param {!l.Model=} targetModel
 * @param {?=} options
 * @param {?=} optionsFilter
 * @param {function(!Error, !Array<!l.Conflict>, ?): void=} callback
 * @return {void}
 */
l.PersistedModel.replicate = function(since, targetModel, options, optionsFilter, callback) {};

/**
 * Update multiple instances that match the where clause.
 * 
 * Example:
 * 
 * ```js
 * Employee.updateAll({managerId: 'x001'}, {managerId: 'x002'}, function(err, info) {
 *     ...
 * });
 * ```
 * 
 * ```
 * { key: val, key2: {gt: 'val2'}, ...}
 * ```
 * <br/>see
 * [Where filter](docs.strongloop.com/display/LB/Where+filter#Wherefilter-Whereclauseforothermethods).
 * 
 * \@callback {() => void} callback Callback function called with `(err, info)` arguments.  Required.
 * 
 * @param {?=} where
 * @param {?=} data
 * @param {function(!Error, ?, number): void=} callback
 * @return {void}
 */
l.PersistedModel.updateAll = function(where, data, callback) {};

/**
 * Update or insert a model instance
 * \@callback {() => void} callback Callback function called with `cb(err, obj)` signature.
 * @param {?} data
 * @param {function(!Error, ?): void} callback
 * @return {void}
 */
l.PersistedModel.upsert = function(data, callback) {};

/**
 * Update or insert a model instance based on the search criteria.
 * If there is a single instance retrieved, update the retrieved model.
 * Creates a new model if no model instances were found.
 * Returns an error if multiple instances are found.
 * * \@param {any} [where]  `where` filter, like
 * ```
 * { key: val, key2: {gt: 'val2'}, ...}
 * ```
 * <br/>see
 * [Where filter](docs.strongloop.com/display/LB/Where+filter#Wherefilter-Whereclauseforothermethods).
 * \@callback {() => void} callback Callback function called with `cb(err, obj)` signature.
 * @param {?} data
 * @param {function(!Error, ?): void} callback
 * @return {void}
 */
l.PersistedModel.upsertWithWhere = function(data, callback) {};

/**
 * Deletes the model from persistence.
 * Triggers `destroy` hook (async) before and after destroying object.
 * @param {function(): void} callback
 * @return {void}
 */
l.PersistedModel.prototype.destroy = function(callback) {};

/**
 * Get the `id` value for the `PersistedModel`
 * @return {?}
 */
l.PersistedModel.prototype.getId = function() {};

/**
 * Get the `id` property name of the constructor
 * @return {string}
 */
l.PersistedModel.prototype.getIdName = function() {};

/**
 * Determine if the data model is new.
 * @return {boolean}
 */
l.PersistedModel.prototype.isNewRecord = function() {};

/**
 * Reload object from persistence.  Requires `id` member of `object` to be able to call `find`.
 * \@callback {() => void} callback Callback function called with `(err, instance)` arguments.  Required.
 * @param {function(!Error, ?): void} callback
 * @return {void}
 */
l.PersistedModel.prototype.reload = function(callback) {};

/**
 * Replace attributes for a model instance and persist it into the datasource.
 * Performs validation before replacing
 * \@options {any} [options] Options for replace
 * \@property {boolean} validate Perform validation before saving.  Default is true.
 * \@callback {() => void} callback Callback function called with `(err, instance)` arguments.
 * @param {?} data
 * @param {{validate: boolean}=} options
 * @param {function(!Error, ?): void=} callback
 * @return {void}
 */
l.PersistedModel.prototype.replaceAttributes = function(data, options, callback) {};

/**
 * Save model instance. If the instance doesn't have an ID, then calls [create](#persistedmodelcreatedata-cb) instead.
 * Triggers: validate, save, update, or create.
 * \@options {any} [options] See below.
 * \@property {boolean} validate Perform validation before saving.  Default is true.
 * \@property {boolean} throws If true, throw a validation error; WARNING: This can crash Node.
 * If false, report the error via callback.  Default is false.
 * \@callback {() => void} callback Optional callback function called with `(err, obj)` arguments.
 * @param {{validate: boolean, throws: boolean}=} options
 * @param {function(!Error, ?): void=} callback
 * @return {void}
 */
l.PersistedModel.prototype.save = function(options, callback) {};

/**
 * Set the correct `id` property for the `PersistedModel`. Uses the `setId` method if the model is attached to
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs
 * @param {?} val
 * @return {void}
 */
l.PersistedModel.prototype.setId = function(val) {};

/**
 * Update a single attribute.
 * Equivalent to `updateAttributes({name: 'value'}, cb)
 * \@callback {() => void} callback Callback function called with `(err, instance)` arguments.  Required.
 * @param {string} name
 * @param {?} value
 * @param {function(!Error, ?): void} callback
 * @return {void}
 */
l.PersistedModel.prototype.updateAttribute = function(name, value, callback) {};

/**
 * Update set of attributes.  Performs validation before updating
 * Triggers: `validation`, `save` and `update` hooks
 * \@callback {() => void} callback Callback function called with `(err, instance)` arguments.  Required.
 * @param {?} data
 * @param {function(!Error, ?): void} callback
 * @return {void}
 */
l.PersistedModel.prototype.updateAttributes = function(data, callback) {};

/**
 * Serve the LoopBack favicon.
 * \@header loopback.favicon(
 * @return {void}
 */
l.favicon = function() {};

/**
 * Expose models over REST
 * For example:
 * ```js
 * app.use(loopback.rest());
 * ```
 * For more information, see [Exposing models over a REST API](docs.strongloop.com/display/DOC/Exposing+models+over+a+REST+API).
 * \@header loopback.rest(
 * @return {void}
 */
l.rest = function() {};

/**
 * Serve static assets of a LoopBack application
 * be served.
 *   [express documentation](expressjs.com/4x/api.html#express.static)
 *   for the full list of available options.
 * \@header loopback.static(root, [options])
 * @param {string} root
 * @param {?} options
 * @return {void}
 */
l.static = function(root, options) {};

/**
 * Return HTTP response with basic application status information:
 * date the application was started and uptime, in JSON format. For example:
 * ```
 * {
 *    "started": "2014-06-05T00:26:49.750Z",
 *    "uptime": 9.394
 * }
 * ```
 * @return {void}
 */
l.status = function() {};

/**
 * Rewrite the url to replace current user literal with the logged in user id
 * @return {void}
 */
l.rewriteUserLiteral = function() {};

/**
 * Check for an access token in cookies, headers, and query string parameters.
 * This function always checks for the following
 * - `access_token` (params only)
 * - `X-Access-Token` (headers only)
 * - `authorization` (headers and cookies
 * 
 * It checks for these values in cookies, headers, and query string parameters _in addition_ to the items
 * specified in the options parameter
 * **NOTE:** This function only checks for [signed cookies](expressjs.com/api.html#req.signedCookies)
 * The following example illustrates how to check for an `accessToken` in a custom cookie, query string parameter
 * and header called `foo-auth`
 * ```js
 * app.use(loopback.token({
 *   cookies: ['foo-auth'],
 *   headers: ['foo-auth', 'X-Foo-Auth'],
 *   params: ['foo-auth', 'foo_auth']
 * }));
 * ```
 * 
 * \@options {any} [options] Each option Array is used to add additional keys to find an `accessToken` for a `request`.
 * \@property {Array} [cookies] Array of cookie names.
 * \@property {Array} [headers] Array of header names.
 * \@property {Array} [params] Array of param names.
 * \@property {boolean} [searchDefaultTokenKeys] Use the default search locations for Token in request
 * \@property {boolean} [enableDoublecheck] Execute middleware although an instance mounted earlier in the chain didn't find a token
 * \@property {boolean} [overwriteExistingToken] only has effect in combination with `enableDoublecheck`. If truthy, will allow to overwrite an existing accessToken.
 * \@property {() => void|string} [model] AccessToken model name or class to use.
 * \@property {string} [currentUserLiteral] string literal for the current user.
 * \@header loopback.token([options])
 * @param {{cookies: !Array<?>, headers: !Array<?>, params: !Array<?>, searchDefaultTokenKeys: boolean, enableDoublecheck: boolean, overwriteExistingToken: boolean, model: function(): (string|void), currentUserLiteral: string}=} options
 * @return {void}
 */
l.token = function(options) {};

/**
 * Convert any request not handled so far to a 404 error
 * to be handled by error-handling middleware.
 * \@header loopback.urlNotFound(
 * @return {void}
 */
l.urlNotFound = function() {};
/**
 * @extends {l.PersistedModel}
 * @constructor
 * @struct
 */
l.AccessToken = function() {};
 /** @type {string} */
l.AccessToken.prototype.id;
 /** @type {number} */
l.AccessToken.prototype.ttl;
 /** @type {!Date} */
l.AccessToken.prototype.created;
 /** @type {{http: {path: string}, acls: !Array<!l.ACL>, accessTokenIdLength: number}} */
l.AccessToken.prototype.settings;

/**
 * Create a cryptographically random access token id
 * \@callback {() => void} callback
 * @param {function(!Error, string): void} callback
 * @return {void}
 */
l.AccessToken.createAccessTokenId = function(callback) {};

/**
 * Find a token for the given `any`
 * \@callback {() => void} callback
 * @param {?} req
 * @param {?=} options
 * @param {function(!Error, !l.AccessToken): void=} callback
 * @return {void}
 */
l.AccessToken.findForRequest = function(req, options, callback) {};

/**
 * Validate the token.
 * 
 * \@callback {() => void} callback
 * @param {function(!Error, boolean): void} callback
 * @return {void}
 */
l.AccessToken.prototype.validate = function(callback) {};
/**
 * @extends {l.PersistedModel}
 * @constructor
 * @struct
 */
l.ACL = function() {};
 /** @type {string} */
l.ACL.prototype.model;
 /** @type {string} */
l.ACL.prototype.property;
 /** @type {string} */
l.ACL.prototype.accesType;
 /** @type {string} */
l.ACL.prototype.permission;
 /** @type {string} */
l.ACL.prototype.principalType;
 /** @type {string} */
l.ACL.prototype.principalId;
 /** @type {{http: {path: string}, acls: !Array<!l.ACL>, defaultPermission: string}} */
l.ACL.prototype.settings;

/**
 * Check if the request has the permission to access.
 * \@options {any} context See below.
 * \@property {any[]} principals An Array of principals.
 * \@property {string|Model} model The model name or model class.
 * \@property {*} id The model instance ID.
 * \@property {string} property The property/method/relation name.
 * \@property {string} accessType The access type:
 *   READ, REPLICATE, WRITE, or EXECUTE.
 * @param {{principals: !Array<?>, model: (string|!l.Model), id: ?, property: string, accessType: string}} context
 * @param {function(): void} callback
 * @return {void}
 */
l.ACL.checkAccessForContext = function(context, callback) {};

/**
 * Check if the given access token can invoke the method
 * \@callback {() => void} callback Callback function
 * @param {!l.AccessToken} token
 * @param {string} model
 * @param {?} modelId
 * @param {string} method
 * @param {function((string|!Error), boolean): void} callback
 * @return {void}
 */
l.ACL.checkAccessForToken = function(token, model, modelId, method, callback) {};

/**
 * Check if the given principal is allowed to access the model/property
 * \@callback {() => void} callback Callback function.
 * @param {string} principalType
 * @param {string} principalId
 * @param {string} model
 * @param {string} property
 * @param {string} accessType
 * @param {function((string|!Error), !l.AccessRequest): void} callback
 * @return {void}
 */
l.ACL.checkPermission = function(principalType, principalId, model, property, accessType, callback) {};

/**
 * Calculate the matching score for the given rule and request
 * @param {!l.ACL} rule
 * @param {!l.AccessRequest} req
 * @return {number}
 */
l.ACL.getMatchingScore = function(rule, req) {};

/**
 * Check if the given principal is mapped to the role
 * @param {string} principalType
 * @param {?} principalId
 * @param {?} role
 * @param {function(): void} cb
 * @return {void}
 */
l.ACL.isMappedToRole = function(principalType, principalId, role, cb) {};

/**
 * Resolve a principal by type/id
 * @param {string} type
 * @param {(string|number)} id
 * @param {function(): void} cb
 * @return {void}
 */
l.ACL.resolvePrincipal = function(type, id, cb) {};

/**
 * Get matching score for the given `AccessRequest`.
 * @param {!l.AccessRequest} req
 * @return {number}
 */
l.ACL.prototype.score = function(req) {};
/**
 * @extends {l.PersistedModel}
 * @constructor
 * @struct
 */
l.Application = function() {};
 /** @type {string} */
l.Application.prototype.id;
 /** @type {string} */
l.Application.prototype.name;
 /** @type {string} */
l.Application.prototype.description;
 /** @type {string} */
l.Application.prototype.icon;
 /** @type {string} */
l.Application.prototype.owner;
 /** @type {string} */
l.Application.prototype.email;
 /** @type {string} */
l.Application.prototype.emailVerified;
 /** @type {string} */
l.Application.prototype.url;
 /** @type {!Array<string>} */
l.Application.prototype.callBackUrl;
 /** @type {string} */
l.Application.prototype.status;
 /** @type {!Date} */
l.Application.prototype.created;
 /** @type {!Date} */
l.Application.prototype.modified;
 /** @type {{apns: {production: boolean, cerData: string, keyData: string, pushOptions: {gateway: string, port: number}, feedBackOptions: {gateway: string, port: number, batchFeedback: boolean, interval: number}}, gcm: {serverApiKey: string}}} */
l.Application.prototype.pushSetings;
 /** @type {boolean} */
l.Application.prototype.authenticationEnabled;
 /** @type {boolean} */
l.Application.prototype.anonymousAllowed;
 /** @type {!Array<string>} */
l.Application.prototype.authenticationSchemes;

/**
 * Authenticate the application id and key
 * \@callback {() => void} callback
 * - clientKey
 * - javaScriptKey
 * - restApiKey
 * - windowsKey
 * - masterKe
 * @param {?} appId
 * @param {string} key
 * @param {function(!Error, string): void} callback
 * @return {void}
 */
l.Application.authenticate = function(appId, key, callback) {};

/**
 * Register a new application
 * @param {string} owner
 * @param {string} name
 * @param {?} options
 * @param {function(): void} callback
 * @return {void}
 */
l.Application.register = function(owner, name, options, callback) {};

/**
 * Reset keys for the application instance
 * \@callback {() => void} callback
 * @param {function(!Error): void} callback
 * @return {void}
 */
l.Application.resetKeys = function(callback) {};

/**
 * Reset keys for a given application by the appId
 * \@callback {() => void} callback
 * @param {?} appId
 * @param {function(!Error): void} callback
 * @return {void}
 */
l.Application.prototype.resetKeys = function(appId, callback) {};
/**
 * @extends {l.PersistedModel}
 * @constructor
 * @struct
 */
l.Change = function() {};
 /** @type {string} */
l.Change.prototype.id;
 /** @type {string} */
l.Change.prototype.rev;
 /** @type {string} */
l.Change.prototype.prev;
 /** @type {number} */
l.Change.prototype.checkpoint;
 /** @type {string} */
l.Change.prototype.modelName;
 /** @type {string} */
l.Change.prototype.modelId;
 /** @type {{http: {path: string}, acls: !Array<!l.ACL>, hashAlgorithm: string, ignoreErrors: boolean}} */
l.Change.prototype.settings;

/**
 * Are both changes deletes?
 * @param {!l.Change} a
 * @param {!l.Change} b
 * @return {void}
 */
l.Change.bothDeleted = function(a, b) {};

/**
 * Find or create a change for the given model
 * \@callback {() => void} callback
 * \@end
 * @param {string} modelName
 * @param {string} modelId
 * @param {function(!Error, !l.Change): void} callback
 * @return {void}
 */
l.Change.findOrCreateChange = function(modelName, modelId, callback) {};

/**
 * Get the checkpoint model.
 * @return {void}
 */
l.Change.getCheckpointModel = function() {};

/**
 * Create a hash of the given `string` with the `options.hashAlgorithm`.
 * **Default: `sha1`*
 * @param {string} str
 * @return {void}
 */
l.Change.hash = function(str) {};

/**
 * Get an identifier for a given model
 * @param {string} modelName
 * @param {string} modelId
 * @return {void}
 */
l.Change.idForModel = function(modelName, modelId) {};

/**
 * Correct all change list entries.
 * @param {function(): void} cb
 * @return {void}
 */
l.Change.rectifyAll = function(cb) {};

/**
 * Track the recent change of the given modelIds
 * \@callback {() => void} callback
 * @param {string} modelName
 * @param {!Array<?>} modelIds
 * @param {function(!Error, !Array<?>): void} callback
 * @return {void}
 */
l.Change.rectifyModelChanges = function(modelName, modelIds, callback) {};

/**
 * Get the revision string for the given object
 * @param {?} inst
 * @return {void}
 */
l.Change.revisionForInst = function(inst) {};

/**
 * Does this change conflict with the given change.
 * @param {!l.Change} change
 * @return {void}
 */
l.Change.prototype.conflictsWith = function(change) {};

/**
 * Get a change's current revision based on current data.
 * \@callback {() => void} callback
 * @param {function(!Error, string): void} callback
 * @return {void}
 */
l.Change.prototype.currentRevision = function(callback) {};

/**
 * Compare two changes.
 * @param {!l.Change} change
 * @return {void}
 */
l.Change.prototype.equals = function(change) {};

/**
 * Get the `Model` class for `change.modelName`.
 * @return {void}
 */
l.Change.prototype.getModelCtor = function() {};

/**
 * Determine if the change is based on the given change.
 * @param {!l.Change} change
 * @return {void}
 */
l.Change.prototype.isBasedOn = function(change) {};

/**
 * Update (or create) the change with the current revision
 * \@callback {() => void} callback
 * @param {function(!Error, !l.Change): void} callback
 * @return {void}
 */
l.Change.prototype.rectify = function(callback) {};

/**
 * Get a change's type. Returns one of
 * - `Change.UPDATE`
 * - `Change.CREATE`
 * - `Change.DELETE`
 * - `Change.UNKNOWN
 * @return {void}
 */
l.Change.prototype.type = function() {};

/**
 * @constructor
 * @struct
 * @param {?} modelId
 * @param {!l.PersistedModel} SourceModel
 * @param {!l.PersistedModel} TargetModel
 */
l.Conflict = function(modelId, SourceModel, TargetModel) {};
 /** @type {?} */
l.Conflict.prototype.source;
 /** @type {?} */
l.Conflict.prototype.target;

/**
 * Get the conflicting changes
 * \@callback {() => void} callback
 * @param {function(!Error, !l.Change, !l.Change): void} callback
 * @return {void}
 */
l.Conflict.prototype.changes = function(callback) {};

/**
 * Fetch the conflicting models
 * \@callback {() => void} callback
 * @param {function(!Error, !l.PersistedModel, !l.PersistedModel): void} callback
 * @return {void}
 */
l.Conflict.prototype.models = function(callback) {};

/**
 * Resolve the conflict
 * Set the source change's previous revision to the current revision of the
 * (conflicting) target change. Since the changes are no longer conflicting
 * and appear as if the source change was based on the target, they will be
 * replicated normally as part of the next replicate() call
 * This is effectively resolving the conflict using the source version
 * \@callback {() => void} callback
 * @param {function(!Error): void} callback
 * @return {void}
 */
l.Conflict.prototype.resolve = function(callback) {};

/**
 * Resolve the conflict using the supplied instance data
 * instance. Use `null` value to delete the source instance instead.
 * \@callback {() => void} callback
 * @param {?} data
 * @param {function(!Error): void} callback
 * @return {void}
 */
l.Conflict.prototype.resolveManually = function(data, callback) {};

/**
 * Resolve the conflict using the instance data in the source model
 * \@callback {() => void} callback
 * @param {function(!Error): void} callback
 * @return {void}
 */
l.Conflict.prototype.resolveUsingSource = function(callback) {};

/**
 * Resolve the conflict using the instance data in the target model
 * \@callback {() => void} callback
 * @param {function(!Error): void} callback
 * @return {void}
 */
l.Conflict.prototype.resolveUsingTarget = function(callback) {};

/**
 * Return a new Conflict instance with swapped Source and Target models
 * This is useful when resolving a conflict in one-way
 * replication, where the source data must not be changed
 * 
 * ```js
 * conflict.swapParties().resolveUsingTarget(cb);
 * ```
 * @return {!l.Conflict}
 */
l.Conflict.prototype.swapParties = function() {};

/**
 * Determine the conflict type
 * Possible results ar
 * 
 * - `Change.UPDATE`: Source and target models were updated
 * - `Change.DELETE`: Source and or target model was deleted.
 * - `Change.UNKNOWN`: the conflict type is uknown or due to an erro
 * 
 * \@callback {() => void} callback
 * @param {function(!Error, string): void} callback
 * @return {void}
 */
l.Conflict.prototype.type = function(callback) {};
/**
 * @extends {l.Model}
 * @constructor
 * @struct
 */
l.Email = function() {};
 /** @type {string} */
l.Email.prototype.to;
 /** @type {string} */
l.Email.prototype.from;
 /** @type {string} */
l.Email.prototype.subject;
 /** @type {string} */
l.Email.prototype.text;
 /** @type {string} */
l.Email.prototype.html;

/**
 * Send an email with the given `options`
 * Example Options
 * ```js
 * {
 *   from: "Fred Foo <foo\@blurdybloop.com>", // sender address
 *   to: "bar\@blurdybloop.com, baz\@blurdybloop.com", // list of receivers
 *   subject: "Hello", // Subject line
 *   text: "Hello world", // plaintext body
 *   html: "<b>Hello world</b>" // html body
 * }
 * ``
 * See github.com/andris9/Nodemailer for other supported options
 * 
 * \@options {any} options See below
 * \@prop {string} from Senders's email address
 * \@prop {string} to List of one or more recipient email addresses (comma-delimited)
 * \@prop {string} subject Subject line
 * \@prop {string} text Body text
 * \@prop {string} html Body HTML (optional)
 * @param {function(): void} callback
 * @param {{from: string, to: string, subject: string, text: string, html: string}} options
 * @return {void}
 */
l.Email.send = function(callback, options) {};

/**
 * A shortcut for Email.send(this).
 * @return {void}
 */
l.Email.prototype.send = function() {};
/**
 * @constructor
 * @struct
 */
l.KeyValueModel = function() {};

/**
 * Set the TTL (time to live) in ms (milliseconds) for a given key.
 * TTL is the remaining time before a key-value pair is discarded from the database.
 * 
 * Callback (Optional) Optional callback.
 * When the callback function is not provided, a promise is returned instead (see below).
 * 
 * Promise
 * this method supports both callback-based and promise-based invocation.
 * Call this method with no callback argument to get back a promise instead.
 * @param {string} key
 * @param {number} ttl
 * @param {?} options
 * @param {function(): void} callback
 * @return {!PromiseLike<?>}
 */
l.KeyValueModel.expire = function(key, ttl, options, callback) {};

/**
 * Return the value associated with a given key.
 * 
 * Callback (Optional)
 * Optional callback. When the callback function is not provided, a promise is returned instead (see below).
 * 
 * Promise
 * This method supports both callback-based and promise-based invocation.
 * Call this method with no callback argument to get back a promise instead.
 * 
 * @param {string} key
 * @param {?=} option
 * @param {function(!Error, ?): void=} callback
 * @return {!PromiseLike<?>}
 */
l.KeyValueModel.get = function(key, option, callback) {};

/**
 * Asynchronously iterate all keys in the database. Similar to .keys()
 * but instead allows for iteration over large data sets without having
 * to load everything into memory at once.
 * Callback example:
 * ```
 * // Given a model named `Color` with two keys `red` and `blue`
 *    var iterator = Color.iterateKeys();
 *    t.next(function(err, key) {
 *    // key contains `red`
 *          it.next(function(err, key) {
 *          // key contains `blue`
 *          });
 *    });
 * ```
 * 
 * Promise example:
 * ```
 * // Given a model named `Color` with two keys `red` and `blue`
 * var iterator = Color.iterateKeys();
 * Promise.resolve().then(function() {
 *   return it.next();
 * })
 * .then(function(key) {
 *  // key contains `red`
 *   return it.next();
 * });
 * .then(function(key) {
 *   // key contains `blue`
 * });
 * ```
 * 
 *  All connectors are required to support * and ?.
 * They may also support additional special characters that are specific to the backing database.
 * @param {{match: string, options: ?}} filter
 * @return {?}
 */
l.KeyValueModel.iterateKeys = function(filter) {};

/**
 * Return all keys in the database.
 * WARNING: This method is not suitable for large data sets as all key-values pairs
 * are loaded into memory at once. For large data sets, use iterateKeys() instead.
 * 
 * This method supports both callback-based and promise-based invocation.
 * Call this method with no callback argument to get back a promise instead
 * 
 * WARNING: this promise implementation will not resolve according to the callback function.
 * 
 * All connectors are required to support * and ?, but may also support additional special
 * characters specific to the database.
 * @param {{match: string, options: ?}} filter
 * @param {function(): void} callback
 * @return {!PromiseLike<?>}
 */
l.KeyValueModel.keys = function(filter, callback) {};

/**
 * Persist a value and associate it with the given key.
 * 
 * Callback (Optional)
 * Optional callback. When the callback function is not provided, a promise is returned instead (see below).
 * 
 * Promise
 * This method supports both callback-based and promise-based invocation.
 * Call this method with no callback argument to get back a promise instead.
 * 
 * @param {string} key
 * @param {?} value
 * @param {?=} options
 * @param {function(!Error): void=} callback
 * @return {!PromiseLike<?>}
 */
l.KeyValueModel.set = function(key, value, options, callback) {};

/**
 * Return the TTL (time to live) for a given key.
 * TTL is the remaining time before a key-value pair is discarded from the database.
 * 
 * Callback (Optional)
 * Optional callback. When the callback function is not provided,
 * a promise is returned instead (see below).
 * 
 * @param {string} key
 * @param {?=} options
 * @param {function(!Error): void=} cb
 * @return {!PromiseLike<?>}
 */
l.KeyValueModel.ttl = function(key, options, cb) {};
/**
 * @constructor
 * @struct
 */
l.Role = function() {};

/**
 * List roles for a given principal.
 * \@callback {() => void} callback Callback function.
 * @param {?} context
 * @param {function(!Error, !Array<string>): void} callback
 * @return {void}
 */
l.Role.getRoles = function(context, callback) {};

/**
 * Check if the user ID is authenticated
 * @param {?} context
 * @param {function(!Error, boolean): void} callback
 * @return {void}
 */
l.Role.isAuthenticated = function(context, callback) {};

/**
 * Check if a given principal is in the specified role.
 * \@callback {() => void} callback Callback function.
 * @param {string} role
 * @param {?} context
 * @param {function(!Error, boolean): void} callback
 * @return {void}
 */
l.Role.isInRole = function(role, context, callback) {};

/**
 * Check if a given user ID is the owner the model instance.
 * @param {function(): void} modelClass
 * @param {?} modelId
 * @param {?} userId
 * @param {function(): void} callback
 * @return {void}
 */
l.Role.isOwner = function(modelClass, modelId, userId, callback) {};

/**
 * Add custom handler for roles.
 * if a principal is in the specified role.
 * Should provide a callback or return a promise.
 * @param {string} role
 * @param {function(): void} resolver
 * @return {void}
 */
l.Role.registerResolver = function(role, resolver) {};
/**
 * @extends {l.PersistedModel}
 * @constructor
 * @struct
 */
l.RoleMapping = function() {};
 /** @type {string} */
l.RoleMapping.prototype.id;
 /** @type {string} */
l.RoleMapping.prototype.name;
 /** @type {string} */
l.RoleMapping.prototype.description;

/**
 * Get the application principal
 * \@callback {() => void} callback
 * @param {function(!Error, !l.Application): void} callback
 * @return {void}
 */
l.RoleMapping.prototype.application = function(callback) {};

/**
 * Get the child role principal
 * \@callback {() => void} callback
 * @param {function(!Error, !l.User): void} callback
 * @return {void}
 */
l.RoleMapping.prototype.childRole = function(callback) {};

/**
 * Get the user principal
 * \@callback {() => void} callback
 * @param {function(!Error, !l.User): void} callback
 * @return {void}
 */
l.RoleMapping.prototype.user = function(callback) {};
/**
 * @constructor
 * @struct
 */
l.Scope = function() {};

/**
 * Check if the given scope is allowed to access the model/property
 * \@callback {() => void} callback
 * @param {string} scope
 * @param {string} model
 * @param {string} property
 * @param {string} accessType
 * @param {function((string|!Error), !l.AccessRequest): void} callback
 * @return {void}
 */
l.Scope.checkPermission = function(scope, model, property, accessType, callback) {};
/**
 * @extends {l.PersistedModel}
 * @constructor
 * @struct
 */
l.User = function() {};
 /** @type {string} */
l.User.prototype.username;
 /** @type {string} */
l.User.prototype.password;
 /** @type {string} */
l.User.prototype.email;
 /** @type {boolean} */
l.User.prototype.emailVerified;
 /** @type {string} */
l.User.prototype.verificationToken;
 /** @type {string} */
l.User.prototype.realm;
 /** @type {!Date} */
l.User.prototype.created;
 /** @type {!Date} */
l.User.prototype.lastUpdate;
 /** @type {string} */
l.User.prototype.status;
 /** @type {{http: {path: string}, acls: !Array<!l.ACL>, emailVerificationRequired: boolean, ttl: number, maxTTL: number, realmRequired: boolean, realmDelimiter: string, resetPasswordTokenTTL: number, saltWorkFactor: number, caseSensitiveEmail: boolean}} */
l.User.prototype.settings;

/**
 * Confirm the user's identity
 * \@callback {() => void} callback
 * @param {?} userId
 * @param {string} token
 * @param {string} redirect
 * @param {function(!Error): void} callback
 * @return {void}
 */
l.User.confirm = function(userId, token, redirect, callback) {};

/**
 * A default verification token generator which accepts the user the token is
 * being generated for and a callback function to indicate completion.
 * This one uses the crypto library and 64 random bytes (converted to hex)
 * for the token. When used in combination with the user.verify() method this
 * function will be called with the `user` object as it's context (`this`)
 * @param {?} user
 * @param {function(): void} cb
 * @return {void}
 */
l.User.generateVerificationToken = function(user, cb) {};

/**
 * Login a user by with the given `credentials`
 * 
 * ```js
 *    User.login({username: 'foo', password: 'bar'}, function (err, token) {
 *          console.log(token.id);
 *    });
 * ```
 * 
 * the user info
 * \@callback {() => void} callback Callback function
 * @param {?} credentials
 * @param {(string|!Array<string>)=} include
 * @param {function(!Error, !l.AccessToken): void=} callback
 * @return {void}
 */
l.User.login = function(credentials, include, callback) {};

/**
 * Logout a user with the given accessToken id
 * 
 * ```js
 *    User.logout('asd0a9f8dsj9s0s3223mk', function (err) {
 *     console.log(err || 'Logged out');
 *   });
 * ```
 * 
 * \@callback {() => void} callback
 * @param {string} accessTokenID
 * @param {function(!Error): void} callback
 * @return {void}
 */
l.User.logout = function(accessTokenID, callback) {};

/**
 * Normalize the credentials
 * @param {?} credentials
 * @param {boolean} realmRequired
 * @param {string} realmDelimiter
 * @return {?}
 */
l.User.normalizeCredentials = function(credentials, realmRequired, realmDelimiter) {};

/**
 * Create a short lived acess token for temporary login. Allows users
 * to change passwords if forgotten
 * \@options {any} options
 * \@prop {string} email The user's email address
 * \@callback {() => void} callback
 * @param {!Object} options
 * @param {function(!Error): void} callback
 * @return {void}
 */
l.User.resetPassword = function(options, callback) {};

/**
 * Create access token for the logged in user. This method can be overridden to
 * customize how access tokens are generate
 * \@callback {() => void} cb The callback function
 * @param {number} ttl
 * @param {?=} options
 * @param {function((string|!Error), !l.AccessToken): void=} cb
 * @return {void}
 */
l.User.prototype.createAccessToken = function(ttl, options, cb) {};

/**
 * Compare the given `password` with the users hashed password
 * \@callback {() => void} callback Callback function
 * @param {string} password
 * @param {function(!Error, boolean): void} callback
 * @return {void}
 */
l.User.prototype.hasPassword = function(password, callback) {};

/**
 * Verify a user's identity by sending them a confirmation email
 *  ```js
 *   var options = {
 *     type: 'email',
 *     to: user.email,
 *     template: 'verify.ejs',
 *     redirect: '/',
 *     tokenGenerator: function (user, cb) { cb("random-token"); }
 *   };
 * 
 *   user.verify(options, next);
 * ```
 * 
 * \@options {any} options
 * \@property {string} type Must be 'email'.
 * \@property {string} to Email address to which verification email is sent.
 * \@property {string} from Sender email addresss, for example
 *   `'noreply\@myapp.com'`.
 * \@property {string} subject Subject line text.
 * \@property {string} text Text of email.
 * \@property {string} template Name of template that displays verification
 *  page, for example, `'verify.ejs'.
 * \@property {string} redirect Page to which user will be redirected after
 *  they verify their email, for example `'/'` for root URI.
 * \@property {() => void} generateVerificationToken A function to be used to
 *  generate the verification token. It must accept the user object and a
 *  callback function. This function should NOT add the token to the user
 *  object, instead simply execute the callback with the token! User saving
 *  and email sending will be handled in the `verify()` method
 * @param {{type: string, to: string, from: string, subject: string, text: string, template: string, redirect: string, generateVerificationToken: function(): void}} options
 * @return {void}
 */
l.User.prototype.verify = function(options) {};

/* TODO: ExportAssignment in  */
