/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/extjs/index.d.ts:
/** @const */
var Ext = {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IPositionable}
 * @extends {Ext.util.IObservable}
 * @extends {Ext.util.IAnimate}
 * @extends {Ext.util.IElementContainer}
 * @extends {Ext.util.IRenderable}
 * @extends {Ext.state.IStateful}
 * @record
 * @struct
 */
Ext.IAbstractComponent = function() {};
 /** @type {?} */
Ext.IAbstractComponent.prototype.autoEl;
 /** @type {?} */
Ext.IAbstractComponent.prototype.autoLoad;
 /** @type {?} */
Ext.IAbstractComponent.prototype.autoRender;
 /** @type {boolean} */
Ext.IAbstractComponent.prototype.autoShow;
 /** @type {string} */
Ext.IAbstractComponent.prototype.baseCls;
 /** @type {?} */
Ext.IAbstractComponent.prototype.border;
 /** @type {!Array<?>} */
Ext.IAbstractComponent.prototype.childEls;
 /** @type {string} */
Ext.IAbstractComponent.prototype.cls;
 /** @type {string} */
Ext.IAbstractComponent.prototype.componentCls;
 /** @type {?} */
Ext.IAbstractComponent.prototype.componentLayout;
 /** @type {string} */
Ext.IAbstractComponent.prototype.contentEl;
 /** @type {?} */
Ext.IAbstractComponent.prototype.data;
 /** @type {boolean} */
Ext.IAbstractComponent.prototype.disabled;
 /** @type {string} */
Ext.IAbstractComponent.prototype.disabledCls;
 /** @type {boolean} */
Ext.IAbstractComponent.prototype.draggable;
 /** @type {boolean} */
Ext.IAbstractComponent.prototype.floating;
 /** @type {boolean} */
Ext.IAbstractComponent.prototype.frame;
 /** @type {number} */
Ext.IAbstractComponent.prototype.height;
 /** @type {boolean} */
Ext.IAbstractComponent.prototype.hidden;
 /** @type {string} */
Ext.IAbstractComponent.prototype.hideMode;
 /** @type {?} */
Ext.IAbstractComponent.prototype.html;
 /** @type {string} */
Ext.IAbstractComponent.prototype.id;
 /** @type {string} */
Ext.IAbstractComponent.prototype.itemId;
 /** @type {?} */
Ext.IAbstractComponent.prototype.loader;
 /** @type {?} */
Ext.IAbstractComponent.prototype.margin;
 /** @type {number} */
Ext.IAbstractComponent.prototype.maxHeight;
 /** @type {number} */
Ext.IAbstractComponent.prototype.maxWidth;
 /** @type {number} */
Ext.IAbstractComponent.prototype.minHeight;
 /** @type {number} */
Ext.IAbstractComponent.prototype.minWidth;
 /** @type {string} */
Ext.IAbstractComponent.prototype.overCls;
 /** @type {?} */
Ext.IAbstractComponent.prototype.padding;
 /** @type {?} */
Ext.IAbstractComponent.prototype.plugins;
 /** @type {?} */
Ext.IAbstractComponent.prototype.renderData;
 /** @type {?} */
Ext.IAbstractComponent.prototype.renderSelectors;
 /** @type {?} */
Ext.IAbstractComponent.prototype.renderTo;
 /** @type {?} */
Ext.IAbstractComponent.prototype.renderTpl;
 /** @type {boolean} */
Ext.IAbstractComponent.prototype.rtl;
 /** @type {?} */
Ext.IAbstractComponent.prototype.shrinkWrap;
 /** @type {?} */
Ext.IAbstractComponent.prototype.style;
 /** @type {?} */
Ext.IAbstractComponent.prototype.tpl;
 /** @type {string} */
Ext.IAbstractComponent.prototype.tplWriteMode;
 /** @type {string} */
Ext.IAbstractComponent.prototype.ui;
 /** @type {number} */
Ext.IAbstractComponent.prototype.width;
 /** @type {!Ext.enums.IWidget} */
Ext.IAbstractComponent.prototype.xtype;
 /** @type {boolean} */
Ext.IAbstractComponent.prototype._isLayoutRoot;
 /** @type {string} */
Ext.IAbstractComponent.prototype.contentPaddingProperty;
 /** @type {?} */
Ext.IAbstractComponent.prototype.frameSize;
 /** @type {boolean} */
Ext.IAbstractComponent.prototype.isComponent;
 /** @type {boolean} */
Ext.IAbstractComponent.prototype.maskOnDisable;
 /** @type {!Ext.IContainer} */
Ext.IAbstractComponent.prototype.ownerCt;
 /** @type {boolean} */
Ext.IAbstractComponent.prototype.rendered;
 /** @type {?} */
Ext.IAbstractComponent.prototype.animate;

/**
 * [Method] Adds each argument passed to this method to the childEls array
 * @return {void}
 */
Ext.IAbstractComponent.prototype.addChildEls = function() {};

/**
 * [Method] Adds a CSS class to the top level element representing this component
 * @param {?=} cls String/String[] The CSS class name to add.
 * @return {!Ext.IComponent} Ext.Component Returns the Component to allow method chaining.
 */
Ext.IAbstractComponent.prototype.addClass = function(cls) {};

/**
 * [Method] Adds a CSS class to the top level element representing this component
 * @param {?=} cls String/String[] The CSS class name to add.
 * @return {!Ext.IComponent} Ext.Component Returns the Component to allow method chaining.
 */
Ext.IAbstractComponent.prototype.addCls = function(cls) {};

/**
 * [Method] Adds a cls to the uiCls array which will also call addUIClsToElement and adds to all elements of this component
 * @param {?=} classes String/String[] A string or an array of strings to add to the uiCls.
 * @param {?=} skip Object (Boolean) skip true to skip adding it to the class and do it later (via the return).
 * @return {void}
 */
Ext.IAbstractComponent.prototype.addClsWithUI = function(classes, skip) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.IAbstractComponent.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} element Object
 * @param {?=} listeners Object
 * @param {?=} scope Object
 * @param {?=} options Object
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.IAbstractComponent.prototype.addListener = function(element, listeners, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.IAbstractComponent.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Save a property to the given state object if it is not its default or configured value
 * @param {?=} state Object The state object.
 * @param {string=} propName String The name of the property on this object to save.
 * @param {string=} value String The value of the state property (defaults to this[propName]).
 * @return {boolean} Boolean The state object or a new object if state was null and the property was saved.
 */
Ext.IAbstractComponent.prototype.addPropertyToState = function(state, propName, value) {};

/**
 * [Method] Add events that will trigger the state to be saved
 * @param {?=} events String/String[] The event name or an array of event names.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.addStateEvents = function(events) {};

/**
 * [Method] Method which adds a specified UI  uiCls to the components element
 * @param {string=} ui String The UI to remove from the element.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.addUIClsToElement = function(ui) {};

/**
 * [Method] Called by the layout system after the Component has been laid out
 * @param {number=} width Number The width that was set
 * @param {number=} height Number The height that was set
 * @param {?=} oldWidth Number/undefined The old width, or undefined if this was the initial layout.
 * @param {?=} oldHeight Number/undefined The old height, or undefined if this was the initial layout.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.afterComponentLayout = function(width, height, oldWidth, oldHeight) {};

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.IAbstractComponent.prototype.afterRender = function() {};

/**
 * [Method] Template method called after a Component has been positioned
 * @param {number=} x Number
 * @param {number=} y Number
 * @return {void}
 */
Ext.IAbstractComponent.prototype.afterSetPosition = function(x, y) {};

/**
 * [Method] Aligns the element with another element relative to the specified anchor points
 * @param {?=} element Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or id of the element to align to.
 * @param {string=} position String The position to align to
 * @param {!Array<number>=} offsets Number[] Offset the positioning by [x, y]
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.IAbstractComponent.prototype.alignTo = function(element, position, offsets, animate) {};

/**
 * [Method] Anchors an element to another element and realigns it when the window is resized
 * @param {?=} element Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or id of the element to align to.
 * @param {string=} position String The position to align to
 * @param {!Array<number>=} offsets Number[] Offset the positioning by [x, y]
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @param {?=} monitorScroll Boolean/Number True to monitor body scroll and reposition. If this parameter is a number, it is used as the buffer delay in milliseconds.
 * @param {?=} callback Function The function to call after the animation finishes
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.IAbstractComponent.prototype.anchorTo = function(element, position, offsets, animate, monitorScroll, callback) {};

/**
 * [Method] Applies the state to the object
 * @param {?=} state Object The state
 * @return {void}
 */
Ext.IAbstractComponent.prototype.applyState = function(state) {};

/**
 * [Method] Template method to do any pre blur processing
 * @param {!Ext.IEventObject=} e Ext.EventObject The event object
 * @return {void}
 */
Ext.IAbstractComponent.prototype.beforeBlur = function(e) {};

/**
 * [Method] Occurs before componentLayout is run
 * @param {number=} adjWidth Number The box-adjusted width that was set.
 * @param {number=} adjHeight Number The box-adjusted height that was set.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.beforeComponentLayout = function(adjWidth, adjHeight) {};

/**
 * [Method] Invoked before the Component is destroyed
 * @return {void}
 */
Ext.IAbstractComponent.prototype.beforeDestroy = function() {};

/**
 * [Method] Template method to do any pre focus processing
 * @param {!Ext.IEventObject=} e Ext.EventObject The event object
 * @return {void}
 */
Ext.IAbstractComponent.prototype.beforeFocus = function(e) {};

/**
 * [Method] Occurs before componentLayout is run
 * @return {void}
 */
Ext.IAbstractComponent.prototype.beforeLayout = function() {};

/**
 * [Method] Calculates the new x y position to move this Positionable into a constrain region
 * @param {?=} constrainTo String/HTMLElement/Ext.Element/Ext.util.Region The Element or Region into which this Component is to be constrained. Defaults to the element into which this Positionable was rendered, or this Component's {\@link Ext.Component.constrainTo.
 * @param {!Array<number>=} proposedPosition Number[] A proposed [X, Y] position to test for validity and to coerce into constraints instead of using this Positionable's current position.
 * @param {boolean=} local Boolean The proposedPosition is local (relative to floatParent if a floating Component)
 * @param {!Array<number>=} proposedSize Number[] A proposed [width, height] size to use when calculating constraints instead of using this Positionable's current size.
 * @return {!Array<number>} Number[] If the element needs to be translated, the new [X, Y] position within constraints if possible, giving priority to keeping the top and left edge in the constrain region. Otherwise, false.
 */
Ext.IAbstractComponent.prototype.calculateConstrainedPosition = function(constrainTo, proposedPosition, local, proposedSize) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.IAbstractComponent.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.IAbstractComponent.prototype.clearManagedListeners = function() {};

/**
 * [Method] Destroys the Component
 * @return {void}
 */
Ext.IAbstractComponent.prototype.destroy = function() {};

/**
 * [Method] Disable the component
 * @param {boolean=} silent Boolean Passing true will suppress the disable event from being fired.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.disable = function(silent) {};

/**
 * [Method] Handles autoRender
 * @return {void}
 */
Ext.IAbstractComponent.prototype.doAutoRender = function() {};

/**
 * [Method] This method needs to be called whenever you change something on this component that requires the Component s layout t
 * @return {!Ext.container.IContainer} Ext.container.Container this
 */
Ext.IAbstractComponent.prototype.doComponentLayout = function() {};

/**
 * [Method] Enable the component
 * @param {boolean=} silent Boolean Passing true will suppress the enable event from being fired.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.enable = function(silent) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Ensures that this component is attached to document body
 * @param {boolean=} runLayout Boolean True to run the component's layout.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.ensureAttachedToBody = function(runLayout) {};

/**
 * [Method] Retrieves plugin from this component s collection by its ptype
 * @param {string=} ptype String The Plugin's ptype as specified by the class's alias configuration.
 * @return {!Ext.IAbstractPlugin} Ext.AbstractPlugin plugin instance.
 */
Ext.IAbstractComponent.prototype.findPlugin = function(ptype) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.IAbstractComponent.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.IAbstractComponent.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Forces this component to redo its componentLayout
 * @return {void}
 */
Ext.IAbstractComponent.prototype.forceComponentLayout = function() {};

/**
 * [Method] Returns the current animation if this object has any effects actively running or queued else returns false
 * @return {?} Ext.fx.Anim/Boolean Anim if element has active effects, else false
 */
Ext.IAbstractComponent.prototype.getActiveAnimation = function() {};

/**
 * [Method] Gets the x y coordinates to align this element with another element
 * @param {?=} element Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or id of the element to align to.
 * @param {string=} position String The position to align to
 * @param {!Array<number>=} offsets Number[] Offset the positioning by [x, y]
 * @return {!Array<number>} Number[] [x, y]
 */
Ext.IAbstractComponent.prototype.getAlignToXY = function(element, position, offsets) {};

/**
 * [Method] Gets the x y coordinates specified by the anchor position on the element
 * @param {string=} anchor String The specified anchor position. See alignTo for details on supported anchor positions.
 * @param {boolean=} local Boolean True to get the local (element top/left-relative) anchor position instead of page coordinates
 * @param {?=} size Object An object containing the size to use for calculating anchor position {width: (target width), height: (target height)} (defaults to the element's current size)
 * @return {!Array<number>} Number[] [x, y] An array containing the element's x and y coordinates
 */
Ext.IAbstractComponent.prototype.getAnchorXY = function(anchor, local, size) {};

/**
 * [Method] Return an object defining the area of this Element which can be passed to setBox to set another Element s size locati
 * @param {boolean=} contentBox Boolean If true a box for the content of the element is returned.
 * @param {boolean=} local Boolean If true the element's left and top relative to its offsetParent are returned instead of page x/y.
 * @return {?} Object box An object in the format: {  x: &lt;Element's X position&gt;,  y: &lt;Element's Y position&gt;,  left: &lt;Element's X position (an alias for x)&gt;,  top: &lt;Element's Y position (an alias for y)&gt;,  width: &lt;Element's width&gt;,  height: &lt;Element's height&gt;,  bottom: &lt;Element's lower bound&gt;,  right: &lt;Element's rightmost bound&gt; }  The returned object may also be addressed as an Array where index 0 contains the X position and index 1 contains the Y position. The result may also be used for setXY
 */
Ext.IAbstractComponent.prototype.getBox = function(contentBox, local) {};

/**
 * [Method] Provides the link for Observable s fireEvent method to bubble up the ownership hierarchy
 * @return {!Ext.container.IContainer} Ext.container.Container the Container which owns this Component.
 */
Ext.IAbstractComponent.prototype.getBubbleTarget = function() {};

/**
 * [Method] Returns the X Y vector by which this Positionable s element must be translated to make a best attempt to constrain
 * @param {?=} constrainTo Ext.util.Positionable/HTMLElement/String/Ext.util.Region The Positionable, HTMLElement, element id, or Region into which the element is to be constrained.
 * @param {!Array<number>=} proposedPosition Number[] A proposed [X, Y] position to test for validity and to produce a vector for instead of using the element's current position
 * @param {!Array<number>=} proposedSize Number[] A proposed [width, height] size to constrain instead of using the element's current size
 * @return {?} Number[]/Boolean If the element needs to be translated, an [X, Y] vector by which this element must be translated. Otherwise, false.
 */
Ext.IAbstractComponent.prototype.getConstrainVector = function(constrainTo, proposedPosition, proposedSize) {};

/**
 * [Method] Retrieves the top level element representing this component
 * @return {!Ext.dom.IElement} Ext.dom.Element
 */
Ext.IAbstractComponent.prototype.getEl = function() {};

/**
 * [Method] Gets the current height of the component s underlying element
 * @return {number} Number
 */
Ext.IAbstractComponent.prototype.getHeight = function() {};

/**
 * [Method] Retrieves the id of this component
 * @return {string} String
 */
Ext.IAbstractComponent.prototype.getId = function() {};

/**
 * [Method] This function takes the position argument passed to onRender and returns a DOM element that you can use in the insert
 * @param {?=} position String/Number/Ext.dom.Element/HTMLElement Index, element id or element you want to put this component before.
 * @return {!HTMLElement} HTMLElement DOM element that you can use in the insertBefore
 */
Ext.IAbstractComponent.prototype.getInsertPosition = function(position) {};

/**
 * [Method] Returns the value of itemId assigned to this component or when that is not set returns the value of id
 * @return {string} String
 */
Ext.IAbstractComponent.prototype.getItemId = function() {};

/**
 * [Method] Gets the Ext ComponentLoader for this Component
 * @return {!Ext.IComponentLoader} Ext.ComponentLoader The loader instance, null if it doesn't exist.
 */
Ext.IAbstractComponent.prototype.getLoader = function() {};

/**
 * [Method] Overridden in Ext rtl AbstractComponent
 * @return {number} Number The local x coordinate
 */
Ext.IAbstractComponent.prototype.getLocalX = function() {};

/**
 * [Method] Overridden in Ext rtl AbstractComponent
 * @return {!Array<number>} Number[] The local XY position of the element
 */
Ext.IAbstractComponent.prototype.getLocalXY = function() {};

/**
 * [Method] Returns the y coordinate of this element reletive to its offsetParent
 * @return {number} Number The local y coordinate
 */
Ext.IAbstractComponent.prototype.getLocalY = function() {};

/**
 * [Method] Returns the offsets of this element from the passed element
 * @param {?=} offsetsTo Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or element id to get get the offsets from.
 * @return {!Array<number>} Number[] The XY page offsets (e.g. [100, -200])
 */
Ext.IAbstractComponent.prototype.getOffsetsTo = function(offsetsTo) {};

/**
 * [Method] Retrieves a plugin from this component s collection by its pluginId
 * @param {string=} pluginId String
 * @return {!Ext.IAbstractPlugin} Ext.AbstractPlugin plugin instance.
 */
Ext.IAbstractComponent.prototype.getPlugin = function(pluginId) {};

/**
 * [Method] Returns a region object that defines the area of this element
 * @return {!Ext.util.IRegion} Ext.util.Region A Region containing "top, left, bottom, right" properties.
 */
Ext.IAbstractComponent.prototype.getRegion = function() {};

/**
 * [Method] Gets the current size of the component s underlying element
 * @return {?} Object An object containing the element's size {width: (element width), height: (element height)}
 */
Ext.IAbstractComponent.prototype.getSize = function() {};

/**
 * [Method] Returns an object that describes how this component s width and height are managed
 * @param {?=} ownerCtSizeModel Object
 * @return {?} Object The size model for this component.
 */
Ext.IAbstractComponent.prototype.getSizeModel = function(ownerCtSizeModel) {};

/**
 * [Method] The supplied default state gathering method for the AbstractComponent class
 * @return {?} Object
 */
Ext.IAbstractComponent.prototype.getState = function() {};

/**
 * [Method] Returns the content region of this element
 * @return {!Ext.util.IRegion} Ext.util.Region A Region containing "top, left, bottom, right" member data.
 */
Ext.IAbstractComponent.prototype.getViewRegion = function() {};

/**
 * [Method] Gets the current width of the component s underlying element
 * @return {number} Number
 */
Ext.IAbstractComponent.prototype.getWidth = function() {};

/**
 * [Method] Gets the current X position of the DOM element based on page coordinates
 * @return {number} Number The X position of the element
 */
Ext.IAbstractComponent.prototype.getX = function() {};

/**
 * [Method] Returns this Component s xtype hierarchy as a slash delimited string
 * @return {string} String The xtype hierarchy string
 */
Ext.IAbstractComponent.prototype.getXTypes = function() {};

/**
 * [Method] Gets the current position of the DOM element based on page coordinates
 * @return {!Array<number>} Number[] The XY position of the element
 */
Ext.IAbstractComponent.prototype.getXY = function() {};

/**
 * [Method] Gets the current Y position of the DOM element based on page coordinates
 * @return {number} Number The Y position of the element
 */
Ext.IAbstractComponent.prototype.getY = function() {};

/**
 * [Method] Returns the current animation if this object has any effects actively running or queued else returns false
 * @return {?} Ext.fx.Anim/Boolean Anim if element has active effects, else false
 */
Ext.IAbstractComponent.prototype.hasActiveFx = function() {};

/**
 * [Method] Checks if the specified CSS class exists on this element s DOM node
 * @param {string=} className String The CSS class to check for.
 * @return {boolean} Boolean true if the class exists, else false.
 */
Ext.IAbstractComponent.prototype.hasCls = function(className) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.IAbstractComponent.prototype.hasListener = function(eventName) {};

/**
 * [Method] Checks if there is currently a specified uiCls
 * @param {string=} cls String The cls to check.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.hasUICls = function(cls) {};

/**
 * [Method] Initialize any events on this component
 * @return {void}
 */
Ext.IAbstractComponent.prototype.initEvents = function() {};

/**
 * [Method] Initialized the renderData to be used when rendering the renderTpl
 * @return {?} Object Object with keys and values that are going to be applied to the renderTpl
 */
Ext.IAbstractComponent.prototype.initRenderData = function() {};

/**
 * [Method] Tests whether this Component matches the selector string
 * @param {string=} selector String The selector string to test against.
 * @return {boolean} Boolean true if this Component matches the selector.
 */
Ext.IAbstractComponent.prototype.is = function(selector) {};

/**
 * [Method] Determines whether this component is the descendant of a particular container
 * @param {!Ext.IContainer=} container Ext.Container
 * @return {boolean} Boolean true if the component is the descendant of a particular container, otherwise false.
 */
Ext.IAbstractComponent.prototype.isDescendantOf = function(container) {};

/**
 * [Method] Method to determine whether this Component is currently disabled
 * @return {boolean} Boolean the disabled state of this Component.
 */
Ext.IAbstractComponent.prototype.isDisabled = function() {};

/**
 * [Method] Method to determine whether this Component is draggable
 * @return {boolean} Boolean the draggable state of this component.
 */
Ext.IAbstractComponent.prototype.isDraggable = function() {};

/**
 * [Method] Method to determine whether this Component is droppable
 * @return {boolean} Boolean the droppable state of this component.
 */
Ext.IAbstractComponent.prototype.isDroppable = function() {};

/**
 * [Method] Method to determine whether this Component is floating
 * @return {boolean} Boolean the floating state of this component.
 */
Ext.IAbstractComponent.prototype.isFloating = function() {};

/**
 * [Method] Method to determine whether this Component is currently set to hidden
 * @return {boolean} Boolean the hidden state of this Component.
 */
Ext.IAbstractComponent.prototype.isHidden = function() {};

/**
 * [Method] Determines whether this Component is the root of a layout
 * @return {void}
 */
Ext.IAbstractComponent.prototype.isLayoutRoot = function() {};

/**
 * [Method] Returns true if layout is suspended for this component
 * @return {boolean} Boolean true layout of this component is suspended.
 */
Ext.IAbstractComponent.prototype.isLayoutSuspended = function() {};

/**
 * [Method] Returns true if this component is visible
 * @param {boolean=} deep Boolean Pass true to interrogate the visibility status of all parent Containers to determine whether this Component is truly visible to the user. Generally, to determine whether a Component is hidden, the no argument form is needed. For example when creating dynamically laid out UIs in a hidden Container before showing them.
 * @return {boolean} Boolean true if this component is visible, false otherwise.
 */
Ext.IAbstractComponent.prototype.isVisible = function(deep) {};

/**
 * [Method] Tests whether or not this Component is of a specific xtype
 * @param {string=} xtype String The xtype to check for this Component
 * @param {boolean=} shallow Boolean true to check whether this Component is directly of the specified xtype, false to check whether this Component is descended from the xtype.
 * @return {boolean} Boolean true if this component descends from the specified xtype, false otherwise.
 */
Ext.IAbstractComponent.prototype.isXType = function(xtype, shallow) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.IAbstractComponent.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Move the element relative to its current position
 * @param {string=} direction String Possible values are:  "l" (or "left") "r" (or "right") "t" (or "top", or "up") "b" (or "bottom", or "down")
 * @param {number=} distance Number How far to move the element in pixels
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {void}
 */
Ext.IAbstractComponent.prototype.move = function(direction, distance, animate) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Returns the next node in the Component tree in tree traversal order
 * @param {string=} selector String A ComponentQuery selector to filter the following nodes.
 * @return {!Ext.IComponent} Ext.Component The next node (or the next node which matches the selector). Returns null if there is no matching node.
 */
Ext.IAbstractComponent.prototype.nextNode = function(selector) {};

/**
 * [Method] Returns the next sibling of this Component
 * @param {string=} selector String A ComponentQuery selector to filter the following items.
 * @return {!Ext.IComponent} Ext.Component The next sibling (or the next sibling which matches the selector). Returns null if there is no matching sibling.
 */
Ext.IAbstractComponent.prototype.nextSibling = function(selector) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.IAbstractComponent.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Method to manage awareness of when components are added to their respective Container firing an added event
 * @param {!Ext.container.IContainer=} container Ext.container.Container Container which holds the component.
 * @param {number=} pos Number Position at which the component was added.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.onAdded = function(container, pos) {};

/**
 * [Method] Allows addition of behavior to the disable operation
 * @return {void}
 */
Ext.IAbstractComponent.prototype.onDisable = function() {};

/**
 * [Method] Allows addition of behavior to the enable operation
 * @return {void}
 */
Ext.IAbstractComponent.prototype.onEnable = function() {};

/**
 * [Method] Called after the component is moved this method is empty by default but can be implemented by any subclass that need
 * @param {number=} x Number The new x position.
 * @param {number=} y Number The new y position.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.onPosition = function(x, y) {};

/**
 * [Method] Method to manage awareness of when components are removed from their respective Container firing a removed event
 * @param {boolean=} destroying Boolean Will be passed as true if the Container performing the remove operation will delete this Component upon remove.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.onRemoved = function(destroying) {};

/**
 * [Method] Template method called when this Component s DOM structure is created
 * @param {!Ext.core.IElement=} parentNode Ext.core.Element The parent Element in which this Component's encapsulating element is contained.
 * @param {number=} containerIdx Number The index within the parent Container's child collection of this Component.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.onRender = function(parentNode, containerIdx) {};

/**
 * [Method] Allows addition of behavior to the resize operation
 * @param {?=} width Object
 * @param {?=} height Object
 * @param {?=} oldWidth Object
 * @param {?=} oldHeight Object
 * @return {void}
 */
Ext.IAbstractComponent.prototype.onResize = function(width, height, oldWidth, oldHeight) {};

/**
 * [Method] Template method to do any post blur processing
 * @param {!Ext.IEventObject=} e Ext.EventObject The event object
 * @return {void}
 */
Ext.IAbstractComponent.prototype.postBlur = function(e) {};

/**
 * [Method] Returns the previous node in the Component tree in tree traversal order
 * @param {string=} selector String A ComponentQuery selector to filter the preceding nodes.
 * @return {!Ext.IComponent} Ext.Component The previous node (or the previous node which matches the selector). Returns null if there is no matching node.
 */
Ext.IAbstractComponent.prototype.previousNode = function(selector) {};

/**
 * [Method] Returns the previous sibling of this Component
 * @param {string=} selector String A ComponentQuery selector to filter the preceding items.
 * @return {!Ext.IComponent} Ext.Component The previous sibling (or the previous sibling which matches the selector). Returns null if there is no matching sibling.
 */
Ext.IAbstractComponent.prototype.previousSibling = function(selector) {};

/**
 * [Method] Called by Component doAutoRender Register a Container configured floating true with this Component s ZIndexManager
 * @param {?=} cmp Object
 * @return {void}
 */
Ext.IAbstractComponent.prototype.registerFloatingItem = function(cmp) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.IAbstractComponent.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Remove any anchor to this element
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.IAbstractComponent.prototype.removeAnchor = function() {};

/**
 * [Method] Removes items in the childEls array based on the return value of a supplied test function
 * @param {?=} testFn Function The test function.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.removeChildEls = function(testFn) {};

/**
 * [Method] Removes a CSS class from the top level element representing this component
 * @param {?=} cls String/String[] The CSS class name to remove.
 * @return {!Ext.IComponent} Ext.Component Returns the Component to allow method chaining.
 */
Ext.IAbstractComponent.prototype.removeCls = function(cls) {};

/**
 * [Method] Removes a cls to the uiCls array which will also call removeUIClsFromElement and removes it from all elements of thi
 * @param {?=} cls String/String[] A string or an array of strings to remove to the uiCls.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.removeClsWithUI = function(cls) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Method which removes a specified UI  uiCls from the components element
 * @param {string=} ui String The UI to add to the element.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.removeUIClsFromElement = function(ui) {};

/**
 * [Method] Renders the Component into the passed HTML element
 * @param {?=} container Ext.Element/HTMLElement/String The element this Component should be rendered into. If it is being created from existing markup, this should be omitted.
 * @param {?=} position String/Number The element ID or DOM node index within the container before which this component will be inserted (defaults to appending to the end of the container)
 * @return {void}
 */
Ext.IAbstractComponent.prototype.render = function(container, position) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.IAbstractComponent.prototype.resumeEvents = function() {};

/**
 * [Method] Conditionally saves a single property from this object to the given state object
 * @param {string=} propName String The name of the property to save.
 * @param {?=} state Object The state object in to which to save the property.
 * @param {string=} stateName String The name to use for the property in state.
 * @return {boolean} Boolean True if the property was saved, false if not.
 */
Ext.IAbstractComponent.prototype.savePropToState = function(propName, state, stateName) {};

/**
 * [Method] Gathers additional named properties of the instance and adds their current values to the passed state object
 * @param {?=} propNames String/String[] The name (or array of names) of the property to save.
 * @param {?=} state Object The state object in to which to save the property values.
 * @return {?} Object state
 */
Ext.IAbstractComponent.prototype.savePropsToState = function(propNames, state) {};

/**
 * [Method] Saves the state of the object to the persistence store
 * @return {void}
 */
Ext.IAbstractComponent.prototype.saveState = function() {};

/**
 * [Method] Ensures that all effects queued after sequenceFx is called on this object are run in sequence
 * @return {?} Object this
 */
Ext.IAbstractComponent.prototype.sequenceFx = function() {};

/**
 * [Method]
 * @param {?=} border String/Number The border, see border. If a falsey value is passed the border will be removed.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.setBorder = function(border) {};

/**
 * [Method] Sets the element s box
 * @param {?=} box Object The box to fill {x, y, width, height}
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.IAbstractComponent.prototype.setBox = function(box, animate) {};

/**
 * [Method] Enable or disable the component
 * @param {boolean=} disabled Boolean true to disable.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.setDisabled = function(disabled) {};

/**
 * [Method] Sets the dock position of this component in its parent panel
 * @param {?=} dock Object The dock position.
 * @param {boolean=} layoutParent Boolean true to re-layout parent.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IAbstractComponent.prototype.setDocked = function(dock, layoutParent) {};

/**
 * [Method] Sets the height of the component
 * @param {number=} height Number The new height to set. This may be one of:  A Number specifying the new height in the Element's Ext.Element.defaultUnits (by default, pixels). A String used to set the CSS height style. undefined to leave the height unchanged.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IAbstractComponent.prototype.setHeight = function(height) {};

/**
 * [Method] Overridden in Ext rtl AbstractComponent
 * @param {?=} x Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.IAbstractComponent.prototype.setLocalX = function(x) {};

/**
 * [Method] Overridden in Ext rtl AbstractComponent
 * @param {?=} x Object
 * @param {?=} y Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.IAbstractComponent.prototype.setLocalXY = function(x, y) {};

/**
 * [Method] Sets the local y coordinate of this element using CSS style
 * @param {?=} y Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.IAbstractComponent.prototype.setLocalY = function(y) {};

/**
 * [Method] Sets the margin on the target element
 * @param {?=} margin Number/String The margin to set. See the margin config.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.setMargin = function(margin) {};

/**
 * [Method] Sets the element s position and size to the specified region
 * @param {!Ext.util.IRegion=} region Ext.util.Region The region to fill
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.IAbstractComponent.prototype.setRegion = function(region, animate) {};

/**
 * [Method] Sets the width and height of this Component
 * @param {?=} width Number/String/Object The new width to set. This may be one of:  A Number specifying the new width in the Element's Ext.Element.defaultUnits (by default, pixels). A String used to set the CSS width style. A size object in the format {width: widthValue, height: heightValue}. undefined to leave the width unchanged.
 * @param {?=} height Number/String The new height to set (not required if a size object is passed as the first arg). This may be one of:  A Number specifying the new height in the Element's Ext.Element.defaultUnits (by default, pixels). A String used to set the CSS height style. Animation may not be used. undefined to leave the height unchanged.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IAbstractComponent.prototype.setSize = function(width, height) {};

/**
 * [Method] Sets the UI for the component
 * @param {string=} ui String The new UI for the component.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.setUI = function(ui) {};

/**
 * [Method] Convenience function to hide or show this component by Boolean
 * @param {boolean=} visible Boolean true to show, false to hide.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IAbstractComponent.prototype.setVisible = function(visible) {};

/**
 * [Method] Sets the width of the component
 * @param {number=} width Number The new width to setThis may be one of:  A Number specifying the new width in the Element's Ext.Element.defaultUnits (by default, pixels). A String used to set the CSS width style.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IAbstractComponent.prototype.setWidth = function(width) {};

/**
 * [Method] Sets the X position of the DOM element based on page coordinates
 * @param {?=} x Object
 * @param {?=} animate Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.IAbstractComponent.prototype.setX = function(x, animate) {};

/**
 * [Method] Sets the position of the DOM element in page coordinates
 * @param {?=} xy Object
 * @param {?=} animate Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.IAbstractComponent.prototype.setXY = function(xy, animate) {};

/**
 * [Method] Sets the Y position of the DOM element based on page coordinates
 * @param {?=} y Object
 * @param {?=} animate Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.IAbstractComponent.prototype.setY = function(y, animate) {};

/**
 * [Method] Stops any running effects and clears this object s internal effects queue if it contains any additional effects that
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.IAbstractComponent.prototype.stopAnimation = function() {};

/**
 * [Method] Stops any running effects and clears this object s internal effects queue if it contains any additional effects that
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.IAbstractComponent.prototype.stopFx = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Ensures that all effects queued after syncFx is called on this object are run concurrently
 * @return {?} Object this
 */
Ext.IAbstractComponent.prototype.syncFx = function() {};

/**
 * [Method] Translates the passed page coordinates into left top css values for the element
 * @param {?=} x Number/Array The page x or an array containing [x, y]
 * @param {number=} y Number The page y, required if x is not an array
 * @return {?} Object An object with left and top properties. e.g. {left: (value), top: (value)}
 */
Ext.IAbstractComponent.prototype.translatePoints = function(x, y) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.un = function(eventName, fn, scope) {};

/**
 * [Method] Navigates up the ownership hierarchy searching for an ancestor Container which matches any passed simple selector or
 * @param {?=} selector String/Ext.Component The simple selector component or actual component to test. If not passed the immediate owner/activater is returned.
 * @param {?=} limit String/Number/Ext.Component This may be a selector upon which to stop the upward scan, or a limit of teh number of steps, or Component reference to stop on.
 * @return {!Ext.container.IContainer} Ext.container.Container The matching ancestor Container (or undefined if no match was found).
 */
Ext.IAbstractComponent.prototype.up = function(selector, limit) {};

/**
 * [Method] Update the content area of a component
 * @param {?=} htmlOrData String/Object If this component has been configured with a template via the tpl config then it will use this argument as data to populate the template. If this component was not configured with a template, the components content area will be updated via Ext.Element update.
 * @param {boolean=} loadScripts Boolean Only legitimate when using the html configuration.
 * @param {?=} callback Function Only legitimate when using the html configuration. Callback to execute when scripts have finished loading.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.update = function(htmlOrData, loadScripts, callback) {};

/**
 * [Method] Updates this component s layout
 * @param {?=} options Object An object with layout options.
 * @return {void}
 */
Ext.IAbstractComponent.prototype.updateLayout = function(options) {};
/**
 * @constructor
 * @struct
 */
Ext.AbstractComponent = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.AbstractComponent.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.AbstractComponent.addStatics = function(members) {};

/**
 * [Method] Cancels layout of a component
 * @param {!Ext.IComponent=} comp Ext.Component
 * @return {void}
 */
Ext.AbstractComponent.cancelLayout = function(comp) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.AbstractComponent.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.AbstractComponent.createAlias = function(alias, origin) {};

/**
 * [Method] Performs all pending layouts that were scheduled while suspendLayouts was in effect
 * @return {void}
 */
Ext.AbstractComponent.flushLayouts = function() {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.AbstractComponent.getName = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.AbstractComponent.implement = function() {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.AbstractComponent.override = function(members) {};

/**
 * [Method] Resumes layout activity in the whole framework
 * @param {boolean=} flush Boolean true to perform all the pending layouts. This can also be achieved by calling flushLayouts directly.
 * @return {void}
 */
Ext.AbstractComponent.resumeLayouts = function(flush) {};

/**
 * [Method] Stops layouts from happening in the whole framework
 * @return {void}
 */
Ext.AbstractComponent.suspendLayouts = function() {};

/**
 * [Method] Updates layout of a component
 * @param {!Ext.IComponent=} comp Ext.Component The component to update.
 * @param {boolean=} defer Boolean true to just queue the layout if this component.
 * @return {void}
 */
Ext.AbstractComponent.updateLayout = function(comp, defer) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IAbstractManager = function() {};
 /** @type {!Ext.util.IHashMap} */
Ext.IAbstractManager.prototype.all;

/**
 * [Method] Creates and returns an instance of whatever this manager manages based on the supplied type and config object
 * @param {?=} config Object The config object
 * @param {string=} defaultType String If no type is discovered in the config object, we fall back to this type
 * @return {?} Object The instance of whatever this manager is managing
 */
Ext.IAbstractManager.prototype.create = function(config, defaultType) {};

/**
 * [Method] Executes the specified function once for each item in the collection
 * @param {?=} fn Function The function to execute.
 * @param {?=} scope Object The scope to execute in. Defaults to this.
 * @return {void}
 */
Ext.IAbstractManager.prototype.each = function(fn, scope) {};

/**
 * [Method] Returns an item by id
 * @param {string=} id String The id of the item
 * @return {?} Object The item, undefined if not found.
 */
Ext.IAbstractManager.prototype.get = function(id) {};

/**
 * [Method] Gets the number of items in the collection
 * @return {number} Number The number of items in the collection.
 */
Ext.IAbstractManager.prototype.getCount = function() {};

/**
 * [Method] Checks if an item type is registered
 * @param {string=} type String The mnemonic string by which the class may be looked up
 * @return {boolean} Boolean Whether the type is registered.
 */
Ext.IAbstractManager.prototype.isRegistered = function(type) {};

/**
 * [Method] Registers a function that will be called when an item with the specified id is added to the manager
 * @param {string=} id String The item id
 * @param {?=} fn Function The callback function. Called with a single parameter, the item.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed. Defaults to the item.
 * @return {void}
 */
Ext.IAbstractManager.prototype.onAvailable = function(id, fn, scope) {};

/**
 * [Method] Registers an item to be managed
 * @param {?=} item Object The item to register
 * @return {void}
 */
Ext.IAbstractManager.prototype.register = function(item) {};

/**
 * [Method] Registers a new item constructor keyed by a type key
 * @param {string=} type String The mnemonic string by which the class may be looked up.
 * @param {?=} cls Function The new instance class.
 * @return {void}
 */
Ext.IAbstractManager.prototype.registerType = function(type, cls) {};

/**
 * [Method] Unregisters an item by removing it from this manager
 * @param {?=} item Object The item to unregister
 * @return {void}
 */
Ext.IAbstractManager.prototype.unregister = function(item) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IAbstractPlugin = function() {};
 /** @type {string} */
Ext.IAbstractPlugin.prototype.pluginId;
 /** @type {boolean} */
Ext.IAbstractPlugin.prototype.isPlugin;

/**
 * [Method] Creates clone of the plugin
 * @param {?=} overrideCfg Object Additional config for the derived plugin.
 * @return {void}
 */
Ext.IAbstractPlugin.prototype.clonePlugin = function(overrideCfg) {};

/**
 * [Method] The destroy method is invoked by the owning Component at the time the Component is being destroyed
 * @return {void}
 */
Ext.IAbstractPlugin.prototype.destroy = function() {};

/**
 * [Method] The base implementation just sets the plugin s disabled flag to true Plugin subclasses which need more complex proce
 * @return {void}
 */
Ext.IAbstractPlugin.prototype.disable = function() {};

/**
 * [Method] The base implementation just sets the plugin s disabled flag to false Plugin subclasses which need more complex proc
 * @return {void}
 */
Ext.IAbstractPlugin.prototype.enable = function() {};

/**
 * [Method] Returns the component to which this plugin is attached
 * @return {!Ext.IComponent} Ext.Component Owner component.
 */
Ext.IAbstractPlugin.prototype.getCmp = function() {};

/**
 * [Method] The init method is invoked after initComponent method has been run for the client Component
 * @param {!Ext.IComponent=} client Ext.Component The client Component which owns this plugin.
 * @return {void}
 */
Ext.IAbstractPlugin.prototype.init = function(client) {};

/**
 * [Method] Sets the component to which this plugin is attached
 * @param {!Ext.IComponent=} cmp Ext.Component Owner component.
 * @return {void}
 */
Ext.IAbstractPlugin.prototype.setCmp = function(cmp) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IAction = function() {};
 /** @type {boolean} */
Ext.IAction.prototype.disabled;
 /** @type {?} */
Ext.IAction.prototype.handler;
 /** @type {boolean} */
Ext.IAction.prototype.hidden;
 /** @type {string} */
Ext.IAction.prototype.iconCls;
 /** @type {string} */
Ext.IAction.prototype.itemId;
 /** @type {?} */
Ext.IAction.prototype.scope;
 /** @type {string} */
Ext.IAction.prototype.text;

/**
 * [Method] Disables all components configured by this Action
 * @return {void}
 */
Ext.IAction.prototype.disable = function() {};

/**
 * [Method] Executes the specified function once for each Component currently tied to this Action
 * @param {?=} fn Function The function to execute for each component
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the Component.
 * @return {void}
 */
Ext.IAction.prototype.each = function(fn, scope) {};

/**
 * [Method] Enables all components configured by this Action
 * @return {void}
 */
Ext.IAction.prototype.enable = function() {};

/**
 * [Method] Executes this Action manually using the handler function specified in the original config object or the handler funct
 * @param {...?} args Object... Variable number of arguments passed to the handler function
 * @return {void}
 */
Ext.IAction.prototype.execute = function(args) {};

/**
 * [Method] Gets the icon CSS class currently used by all components configured by this Action
 * @return {void}
 */
Ext.IAction.prototype.getIconCls = function() {};

/**
 * [Method] Gets the text currently displayed by all components configured by this Action
 * @return {void}
 */
Ext.IAction.prototype.getText = function() {};

/**
 * [Method] Hides all components configured by this Action
 * @return {void}
 */
Ext.IAction.prototype.hide = function() {};

/**
 * [Method] Returns true if the components using this Action are currently disabled else returns false
 * @return {void}
 */
Ext.IAction.prototype.isDisabled = function() {};

/**
 * [Method] Returns true if the components configured by this Action are currently hidden else returns false
 * @return {void}
 */
Ext.IAction.prototype.isHidden = function() {};

/**
 * [Method] Sets the disabled state of all components configured by this Action
 * @param {boolean=} disabled Boolean True to disable the component, false to enable it
 * @return {void}
 */
Ext.IAction.prototype.setDisabled = function(disabled) {};

/**
 * [Method] Sets the function that will be called by each Component using this action when its primary event is triggered
 * @param {?=} fn Function The function that will be invoked by the action's components. The function will be called with no arguments.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the Component firing the event.
 * @return {void}
 */
Ext.IAction.prototype.setHandler = function(fn, scope) {};

/**
 * [Method] Sets the hidden state of all components configured by this Action
 * @param {boolean=} hidden Boolean True to hide the component, false to show it.
 * @return {void}
 */
Ext.IAction.prototype.setHidden = function(hidden) {};

/**
 * [Method] Sets the icon CSS class for all components configured by this Action
 * @param {string=} cls String The CSS class supplying the icon image
 * @return {void}
 */
Ext.IAction.prototype.setIconCls = function(cls) {};

/**
 * [Method] Sets the text to be displayed by all components configured by this Action
 * @param {string=} text String The text to display
 * @return {void}
 */
Ext.IAction.prototype.setText = function(text) {};

/**
 * [Method] Shows all components configured by this Action
 * @return {void}
 */
Ext.IAction.prototype.show = function() {};
/**
 * @extends {Ext.data.IConnection}
 * @record
 * @struct
 */
Ext.IAjax = function() {};
/**
 * @constructor
 * @struct
 */
Ext.Ajax = function() {};
 /** @type {boolean} */
Ext.Ajax.autoAbort;
 /** @type {?} */
Ext.Ajax.defaultHeaders;
 /** @type {boolean} */
Ext.Ajax.disableCaching;
 /** @type {?} */
Ext.Ajax.extraParams;
 /** @type {?} */
Ext.Ajax.hasListeners;
 /** @type {boolean} */
Ext.Ajax.isObservable;
 /** @type {string} */
Ext.Ajax.method;
 /** @type {!Ext.IClass} */
Ext.Ajax.self;
 /** @type {number} */
Ext.Ajax.timeout;
 /** @type {string} */
Ext.Ajax.url;

/**
 * [Method] Aborts an active request
 * @param {?=} request Object Defaults to the last request
 * @return {void}
 */
Ext.Ajax.abort = function(request) {};

/**
 * [Method] Aborts all active requests
 * @return {void}
 */
Ext.Ajax.abortAll = function() {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.Ajax.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.Ajax.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.Ajax.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.Ajax.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.Ajax.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.Ajax.callSuper = function(args) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.Ajax.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.Ajax.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.Ajax.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.Ajax.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.Ajax.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.Ajax.getInitialConfig = function(name) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.Ajax.hasListener = function(eventName) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.Ajax.initConfig = function(config) {};

/**
 * [Method] Determines whether this object has a request outstanding
 * @param {?=} request Object Defaults to the last transaction
 * @return {boolean} Boolean True if there is an outstanding request.
 */
Ext.Ajax.isLoading = function(request) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.Ajax.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.Ajax.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.Ajax.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Checks if the response status was successful
 * @param {number=} status Number The status code
 * @return {?} Object An object containing success/status state
 */
Ext.Ajax.parseStatus = function(status) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.Ajax.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.Ajax.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.Ajax.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Sends an HTTP request to a remote server
 * @param {?=} options Object An object which may contain the following properties: (The options object may also contain any other property which might be needed to perform postprocessing in a callback because it is passed to callback functions.)
 * @return {?} Object The request object. This may be used to cancel the request.
 */
Ext.Ajax.request = function(options) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.Ajax.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.Ajax.resumeEvents = function() {};

/**
 * [Method] Sets various options such as the url params for the request
 * @param {?=} options Object The initial options
 * @param {?=} scope Object The scope to execute in
 * @return {?} Object The params for the request
 */
Ext.Ajax.setOptions = function(options, scope) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.Ajax.statics = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.Ajax.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.Ajax.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.Ajax.un = function(eventName, fn, scope) {};

/**
 * [Method] Uploads a form using a hidden iframe
 * @param {?=} form String/HTMLElement/Ext.Element The form to upload
 * @param {string=} url String The url to post to
 * @param {string=} params String Any extra parameters to pass
 * @param {?=} options Object The initial options
 * @return {void}
 */
Ext.Ajax.upload = function(form, url, params, options) {};
/** @const */
Ext.app = {};
/**
 * @extends {Ext.app.IController}
 * @record
 * @struct
 */
Ext.app.IApplication = function() {};
 /** @type {string} */
Ext.app.IApplication.prototype.appFolder;
 /** @type {string} */
Ext.app.IApplication.prototype.appProperty;
 /** @type {boolean} */
Ext.app.IApplication.prototype.autoCreateViewport;
 /** @type {?} */
Ext.app.IApplication.prototype.controllers;
 /** @type {boolean} */
Ext.app.IApplication.prototype.enableQuickTips;
 /** @type {string} */
Ext.app.IApplication.prototype.name;
 /** @type {?} */
Ext.app.IApplication.prototype.namespaces;
 /** @type {?} */
Ext.app.IApplication.prototype.paths;
 /** @type {?} */
Ext.app.IApplication.prototype.scope;

/**
 * [Method] Returns the base Ext app Application for this controller
 * @return {!Ext.app.IApplication} Ext.app.Application the application
 */
Ext.app.IApplication.prototype.getApplication = function() {};

/**
 * [Method] Returns instance of a Controller with the given id
 * @param {?=} name Object
 * @return {!Ext.app.IController} Ext.app.Controller controller instance or undefined.
 */
Ext.app.IApplication.prototype.getController = function(name) {};

/**
 * [Method] Called automatically when the page has completely loaded
 * @param {string=} profile String The detected application profile
 * @return {boolean} Boolean By default, the Application will dispatch to the configured startup controller and action immediately after running the launch function. Return false to prevent this behavior.
 */
Ext.app.IApplication.prototype.launch = function(profile) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.app.IController = function() {};
 /** @type {string} */
Ext.app.IController.prototype.id;
 /** @type {?} */
Ext.app.IController.prototype.models;
 /** @type {!Array<?>} */
Ext.app.IController.prototype.refs;
 /** @type {?} */
Ext.app.IController.prototype.stores;
 /** @type {?} */
Ext.app.IController.prototype.views;
 /** @type {!Ext.app.IApplication} */
Ext.app.IController.prototype.application;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.app.IController.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.app.IController.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.app.IController.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Registers one or more references
 * @param {?=} refs Object/Object[]
 * @return {void}
 */
Ext.app.IController.prototype.addRef = function(refs) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.app.IController.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.app.IController.prototype.clearManagedListeners = function() {};

/**
 * [Method] Adds listeners to components selected via Ext ComponentQuery
 * @param {?=} selectors String/Object If a String, the second argument is used as the listeners, otherwise an object of selectors -> listeners is assumed
 * @param {?=} listeners Object Config for listeners.
 * @return {void}
 */
Ext.app.IController.prototype.control = function(selectors, listeners) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.app.IController.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.app.IController.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.app.IController.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the base Ext app Application for this controller
 * @return {!Ext.app.IApplication} Ext.app.Application the application
 */
Ext.app.IController.prototype.getApplication = function() {};

/**
 * [Method] Returns instance of a Controller with the given id
 * @param {string=} id String
 * @return {!Ext.app.IController} Ext.app.Controller controller instance or undefined.
 */
Ext.app.IController.prototype.getController = function(id) {};

/**
 * [Method] Returns a Model class with the given name
 * @param {string=} name String
 * @return {!Ext.data.IModel} Ext.data.Model a model class.
 */
Ext.app.IController.prototype.getModel = function(name) {};

/**
 * [Method] Returns instance of a Store with the given name
 * @param {string=} name String
 * @return {!Ext.data.IStore} Ext.data.Store a store instance.
 */
Ext.app.IController.prototype.getStore = function(name) {};

/**
 * [Method] Returns a View class with the given name
 * @param {string=} name String
 * @return {!Ext.IBase} Ext.Base a view class.
 */
Ext.app.IController.prototype.getView = function(name) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.app.IController.prototype.hasListener = function(eventName) {};

/**
 * [Method] Returns true if a reference is registered
 * @param {?=} ref Object
 * @return {boolean} Boolean
 */
Ext.app.IController.prototype.hasRef = function(ref) {};

/**
 * [Method] A template method that is called when your application boots
 * @param {!Ext.app.IApplication=} application Ext.app.Application
 * @return {void}
 */
Ext.app.IController.prototype.init = function(application) {};

/**
 * [Method] Adds listeners to different event sources also called event domains
 * @param {?=} to Object Config object containing domains, selectors and listeners.
 * @return {void}
 */
Ext.app.IController.prototype.listen = function(to) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.app.IController.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.app.IController.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.app.IController.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] A template method like init but called after the viewport is created
 * @param {!Ext.app.IApplication=} application Ext.app.Application
 * @return {void}
 */
Ext.app.IController.prototype.onLaunch = function(application) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.app.IController.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.app.IController.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.app.IController.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.app.IController.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.app.IController.prototype.resumeEvents = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.app.IController.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.app.IController.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.app.IController.prototype.un = function(eventName, fn, scope) {};
/** @const */
Ext.app.domain = {};
/**
 * @extends {Ext.app.IEventDomain}
 * @record
 * @struct
 */
Ext.app.domain.IComponent = function() {};
/**
 * @constructor
 * @struct
 */
Ext.app.domain.Component = function() {};
 /** @type {!Ext.IClass} */
Ext.app.domain.Component.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.app.domain.Component.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.app.domain.Component.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.app.domain.Component.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.app.domain.Component.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.app.domain.Component.initConfig = function(config) {};

/**
 * [Method] This method matches the firer of the event the target to the given selector
 * @param {?=} target Object
 * @param {?=} selector Object
 * @return {boolean} Boolean true if the target matches the selector.
 */
Ext.app.domain.Component.match = function(target, selector) {};

/**
 * [Method] This method is called by the derived class to monitor fireEvent calls
 * @param {!Ext.IClass=} observable Ext.Class The Observable to monitor for events.
 * @return {void}
 */
Ext.app.domain.Component.monitor = function(observable) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.app.domain.Component.statics = function() {};
/**
 * @extends {Ext.app.IEventDomain}
 * @record
 * @struct
 */
Ext.app.domain.IController = function() {};
/**
 * @constructor
 * @struct
 */
Ext.app.domain.Controller = function() {};
 /** @type {string} */
Ext.app.domain.Controller.idProperty;
 /** @type {!Ext.IClass} */
Ext.app.domain.Controller.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.app.domain.Controller.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.app.domain.Controller.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.app.domain.Controller.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.app.domain.Controller.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.app.domain.Controller.initConfig = function(config) {};

/**
 * [Method] This method matches the firer of the event the target to the given selector
 * @param {?=} target Object The firer of the event.
 * @param {string=} selector String The selector to which to match the target.
 * @return {boolean} Boolean true if the target matches the selector.
 */
Ext.app.domain.Controller.match = function(target, selector) {};

/**
 * [Method] This method is called by the derived class to monitor fireEvent calls
 * @param {!Ext.IClass=} observable Ext.Class The Observable to monitor for events.
 * @return {void}
 */
Ext.app.domain.Controller.monitor = function(observable) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.app.domain.Controller.statics = function() {};
/**
 * @extends {Ext.app.IEventDomain}
 * @record
 * @struct
 */
Ext.app.domain.IDirect = function() {};
/**
 * @constructor
 * @struct
 */
Ext.app.domain.Direct = function() {};
 /** @type {string} */
Ext.app.domain.Direct.idProperty;
 /** @type {!Ext.IClass} */
Ext.app.domain.Direct.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.app.domain.Direct.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.app.domain.Direct.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.app.domain.Direct.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.app.domain.Direct.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.app.domain.Direct.initConfig = function(config) {};

/**
 * [Method] This method matches the firer of the event the target to the given selector
 * @param {?=} target Object The firer of the event.
 * @param {string=} selector String The selector to which to match the target.
 * @return {boolean} Boolean true if the target matches the selector.
 */
Ext.app.domain.Direct.match = function(target, selector) {};

/**
 * [Method] This method is called by the derived class to monitor fireEvent calls
 * @param {!Ext.IClass=} observable Ext.Class The Observable to monitor for events.
 * @return {void}
 */
Ext.app.domain.Direct.monitor = function(observable) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.app.domain.Direct.statics = function() {};
/**
 * @extends {Ext.app.IEventDomain}
 * @record
 * @struct
 */
Ext.app.domain.IGlobal = function() {};
/**
 * @constructor
 * @struct
 */
Ext.app.domain.Global = function() {};
 /** @type {!Ext.IClass} */
Ext.app.domain.Global.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.app.domain.Global.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.app.domain.Global.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.app.domain.Global.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.app.domain.Global.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.app.domain.Global.initConfig = function(config) {};

/**
 * [Method] This method matches the firer of the event the target to the given selector
 * @return {boolean} Boolean true if the target matches the selector.
 */
Ext.app.domain.Global.match = function() {};

/**
 * [Method] This method is called by the derived class to monitor fireEvent calls
 * @param {!Ext.IClass=} observable Ext.Class The Observable to monitor for events.
 * @return {void}
 */
Ext.app.domain.Global.monitor = function(observable) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.app.domain.Global.statics = function() {};
/**
 * @extends {Ext.app.IEventDomain}
 * @record
 * @struct
 */
Ext.app.domain.IStore = function() {};
/**
 * @constructor
 * @struct
 */
Ext.app.domain.Store = function() {};
 /** @type {string} */
Ext.app.domain.Store.idProperty;
 /** @type {!Ext.IClass} */
Ext.app.domain.Store.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.app.domain.Store.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.app.domain.Store.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.app.domain.Store.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.app.domain.Store.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.app.domain.Store.initConfig = function(config) {};

/**
 * [Method] This method matches the firer of the event the target to the given selector
 * @param {?=} target Object The firer of the event.
 * @param {string=} selector String The selector to which to match the target.
 * @return {boolean} Boolean true if the target matches the selector.
 */
Ext.app.domain.Store.match = function(target, selector) {};

/**
 * [Method] This method is called by the derived class to monitor fireEvent calls
 * @param {!Ext.IClass=} observable Ext.Class The Observable to monitor for events.
 * @return {void}
 */
Ext.app.domain.Store.monitor = function(observable) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.app.domain.Store.statics = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.app.IEventBus = function() {};
/**
 * @constructor
 * @struct
 */
Ext.app.EventBus = function() {};
 /** @type {!Ext.IClass} */
Ext.app.EventBus.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.app.EventBus.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.app.EventBus.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.app.EventBus.callSuper = function(args) {};

/**
 * [Method] Adds a set of component event listeners for a controller
 * @param {?=} selectors Object Config object containing selectors and listeners.
 * @param {!Ext.app.IController=} controller Ext.app.Controller The listening controller instance.
 * @return {void}
 */
Ext.app.EventBus.control = function(selectors, controller) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.app.EventBus.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.app.EventBus.initConfig = function(config) {};

/**
 * [Method] Adds a set of event domain listeners for a controller
 * @param {?=} to Object Config object containing domains, selectors and listeners.
 * @param {!Ext.app.IController=} controller Ext.app.Controller The listening controller instance.
 * @return {void}
 */
Ext.app.EventBus.listen = function(to, controller) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.app.EventBus.statics = function() {};

/**
 * [Method] Removes all of a controller s attached listeners
 * @param {string=} controllerId String The id of the controller.
 * @return {void}
 */
Ext.app.EventBus.unlisten = function(controllerId) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.app.IEventDomain = function() {};
 /** @type {string} */
Ext.app.IEventDomain.prototype.idProperty;
 /** @type {?} */
Ext.app.IEventDomain.prototype.instances;

/**
 * [Method] This method matches the firer of the event the target to the given selector
 * @param {?=} target Object The firer of the event.
 * @param {string=} selector String The selector to which to match the target.
 * @return {boolean} Boolean true if the target matches the selector.
 */
Ext.app.IEventDomain.prototype.match = function(target, selector) {};

/**
 * [Method] This method is called by the derived class to monitor fireEvent calls
 * @param {!Ext.IClass=} observable Ext.Class The Observable to monitor for events.
 * @return {void}
 */
Ext.app.IEventDomain.prototype.monitor = function(observable) {};
/**
 * @record
 * @struct
 */
Ext.IArray = function() {};
/**
 * @constructor
 * @struct
 */
Ext.Array = function() {};

/**
 * [Method] Filter through an array and remove empty item as defined in Ext isEmpty See filter
 * @param {!Array<?>=} array Array
 * @return {!Array<?>} Array results
 */
Ext.Array.clean = function(array) {};

/**
 * [Method] Clone a flat array without referencing the previous one
 * @param {!Array<?>=} array Array The array
 * @return {!Array<?>} Array The clone array
 */
Ext.Array.clone = function(array) {};

/**
 * [Method] Checks whether or not the given array contains the specified item
 * @param {!Array<?>=} array Array The array to check
 * @param {?=} item Object The item to look for
 * @return {boolean} Boolean True if the array contains the item, false otherwise
 */
Ext.Array.contains = function(array, item) {};

/**
 * [Method] Perform a set difference A B by subtracting all items in array B from array A
 * @param {!Array<?>=} arrayA Array
 * @param {!Array<?>=} arrayB Array
 * @return {!Array<?>} Array difference
 */
Ext.Array.difference = function(arrayA, arrayB) {};

/**
 * [Method] Iterates an array or an iterable value and invoke the given callback function for each item
 * @param {?=} iterable Array/NodeList/Object The value to be iterated. If this argument is not iterable, the callback function is called once.
 * @param {?=} fn Function The callback function. If it returns false, the iteration stops and this method returns the current index.
 * @param {?=} scope Object The scope (this reference) in which the specified function is executed.
 * @param {boolean=} reverse Boolean Reverse the iteration order (loop from the end to the beginning) Defaults false
 * @return {boolean} Boolean See description for the fn parameter.
 */
Ext.Array.each = function(iterable, fn, scope, reverse) {};

/**
 * [Method] Shallow compares the contents of 2 arrays using strict equality
 * @param {!Array<?>=} array1 Array
 * @param {!Array<?>=} array2 Array
 * @return {boolean} Boolean true if the arrays are equal.
 */
Ext.Array.equals = function(array1, array2) {};

/**
 * [Method] Removes items from an array
 * @param {!Array<?>=} array Array The Array on which to replace.
 * @param {number=} index Number The index in the array at which to operate.
 * @param {number=} removeCount Number The number of items to remove at index.
 * @return {!Array<?>} Array The array passed.
 */
Ext.Array.erase = function(array, index, removeCount) {};

/**
 * [Method] Executes the specified function for each array element until the function returns a falsy value
 * @param {!Array<?>=} array Array
 * @param {?=} fn Function Callback function for each item
 * @param {?=} scope Object Callback function scope
 * @return {boolean} Boolean True if no false value is returned by the callback function.
 */
Ext.Array.every = function(array, fn, scope) {};

/**
 * [Method] Creates a new array with all of the elements of this array for which the provided filtering function returns true
 * @param {!Array<?>=} array Array
 * @param {?=} fn Function Callback function for each item
 * @param {?=} scope Object Callback function scope
 * @return {!Array<?>} Array results
 */
Ext.Array.filter = function(array, fn, scope) {};

/**
 * [Method] Returns the first item in the array which elicits a true return value from the passed selection function
 * @param {!Array<?>=} array Array The array to search
 * @param {?=} fn Function The selection function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the array
 * @return {?} Object The first item in the array which returned true from the selection function, or null if none was found.
 */
Ext.Array.findBy = function(array, fn, scope) {};

/**
 * [Method] Recursively flattens into 1 d Array
 * @param {!Array<?>=} array Array The array to flatten
 * @return {!Array<?>} Array The 1-d array.
 */
Ext.Array.flatten = function(array) {};

/**
 * [Method] Iterates an array and invoke the given callback function for each item
 * @param {!Array<?>=} array Array The array to iterate
 * @param {?=} fn Function The callback function.
 * @param {?=} scope Object The execution scope (this) in which the specified function is executed.
 * @return {void}
 */
Ext.Array.forEach = function(array, fn, scope) {};

/**
 * [Method] Converts a value to an array if it s not already an array returns An empty array if given value is undefined or n
 * @param {?=} value Object The value to convert to an array if it's not already is an array
 * @param {boolean=} newReference Boolean True to clone the given array and return a new reference if necessary, defaults to false
 * @return {!Array<?>} Array array
 */
Ext.Array.from = function(value, newReference) {};

/**
 * [Method] Push an item into the array only if the array doesn t contain it yet
 * @param {!Array<?>=} array Array The array
 * @param {?=} item Object The item to include
 * @return {void}
 */
Ext.Array.include = function(array, item) {};

/**
 * [Method] Get the index of the provided item in the given array a supplement for the missing arrayPrototype indexOf in Interne
 * @param {!Array<?>=} array Array The array to check
 * @param {?=} item Object The item to look for
 * @param {number=} from Number The index at which to begin the search
 * @return {number} Number The index of item in the array (or -1 if it is not found)
 */
Ext.Array.indexOf = function(array, item, from) {};

/**
 * [Method] Inserts items in to an array
 * @param {!Array<?>=} array Array The Array in which to insert.
 * @param {number=} index Number The index in the array at which to operate.
 * @param {!Array<?>=} items Array The array of items to insert at index.
 * @return {!Array<?>} Array The array passed.
 */
Ext.Array.insert = function(array, index, items) {};

/**
 * [Method] Merge multiple arrays into one with unique items that exist in all of the arrays
 * @param {!Array<?>=} array1 Array
 * @param {!Array<?>=} array2 Array
 * @param {!Array<?>=} etc Array
 * @return {!Array<?>} Array intersect
 */
Ext.Array.intersect = function(array1, array2, etc) {};

/**
 * [Method] Creates a new array with the results of calling a provided function on every element in this array
 * @param {!Array<?>=} array Array
 * @param {?=} fn Function Callback function for each item
 * @param {?=} scope Object Callback function scope
 * @return {!Array<?>} Array results
 */
Ext.Array.map = function(array, fn, scope) {};

/**
 * [Method] Returns the maximum value in the Array
 * @param {?=} array Array/NodeList The Array from which to select the maximum value.
 * @param {?=} comparisonFn Function a function to perform the comparision which determines maximization. If omitted the ">" operator will be used. Note: gt = 1; eq = 0; lt = -1
 * @return {?} Object maxValue The maximum value
 */
Ext.Array.max = function(array, comparisonFn) {};

/**
 * [Method] Calculates the mean of all items in the array
 * @param {!Array<?>=} array Array The Array to calculate the mean value of.
 * @return {number} Number The mean.
 */
Ext.Array.mean = function(array) {};

/**
 * [Method] Merge multiple arrays into one with unique items
 * @param {!Array<?>=} array1 Array
 * @param {!Array<?>=} array2 Array
 * @param {!Array<?>=} etc Array
 * @return {!Array<?>} Array merged
 */
Ext.Array.merge = function(array1, array2, etc) {};

/**
 * [Method] Returns the minimum value in the Array
 * @param {?=} array Array/NodeList The Array from which to select the minimum value.
 * @param {?=} comparisonFn Function a function to perform the comparision which determines minimization. If omitted the "&lt;" operator will be used. Note: gt = 1; eq = 0; lt = -1
 * @return {?} Object minValue The minimum value
 */
Ext.Array.min = function(array, comparisonFn) {};

/**
 * [Method] Plucks the value of a property from each item in the Array
 * @param {?=} array Array/NodeList The Array of items to pluck the value from.
 * @param {string=} propertyName String The property name to pluck from each element.
 * @return {!Array<?>} Array The value from each item in the Array.
 */
Ext.Array.pluck = function(array, propertyName) {};

/**
 * [Method] Pushes new items onto the end of an Array
 * @param {!Array<?>} target Array The Array onto which to push new items
 * @param {...?} elements Object... The elements to add to the array. Each parameter may be an Array, in which case all the elements of that Array will be pushed into the end of the destination Array.
 * @return {!Array<?>} Array An array containing all the new items push onto the end.
 */
Ext.Array.push = function(target, elements) {};

/**
 * [Method] Removes the specified item from the array if it exists
 * @param {!Array<?>=} array Array The array
 * @param {?=} item Object The item to remove
 * @return {!Array<?>} Array The passed array itself
 */
Ext.Array.remove = function(array, item) {};

/**
 * [Method] Replaces items in an array
 * @param {!Array<?>=} array Array The Array on which to replace.
 * @param {number=} index Number The index in the array at which to operate.
 * @param {number=} removeCount Number The number of items to remove at index (can be 0).
 * @param {!Array<?>=} insert Array An array of items to insert at index.
 * @return {!Array<?>} Array The array passed.
 */
Ext.Array.replace = function(array, index, removeCount, insert) {};

/**
 * [Method] Returns a shallow copy of a part of an array
 * @param {!Array<?>=} array Array The array (or arguments object).
 * @param {number=} begin Number The index at which to begin. Negative values are offsets from the end of the array.
 * @param {number=} end Number The index at which to end. The copied items do not include end. Negative values are offsets from the end of the array. If end is omitted, all items up to the end of the array are copied.
 * @return {!Array<?>} Array The copied piece of the array.
 */
Ext.Array.slice = function(array, begin, end) {};

/**
 * [Method] Executes the specified function for each array element until the function returns a truthy value
 * @param {!Array<?>=} array Array
 * @param {?=} fn Function Callback function for each item
 * @param {?=} scope Object Callback function scope
 * @return {boolean} Boolean True if the callback function returns a truthy value.
 */
Ext.Array.some = function(array, fn, scope) {};

/**
 * [Method] Sorts the elements of an Array
 * @param {!Array<?>=} array Array The array to sort.
 * @param {?=} sortFn Function The comparison function.
 * @return {!Array<?>} Array The sorted array.
 */
Ext.Array.sort = function(array, sortFn) {};

/**
 * [Method] Replaces items in an array
 * @param {!Array<?>} array Array The Array on which to replace.
 * @param {number} index Number The index in the array at which to operate.
 * @param {number} removeCount Number The number of items to remove at index (can be 0).
 * @param {...?} elements Object... The elements to add to the array. If you don't specify any elements, splice simply removes elements from the array.
 * @return {!Array<?>} Array An array containing the removed items.
 */
Ext.Array.splice = function(array, index, removeCount, elements) {};

/**
 * [Method] Calculates the sum of all items in the given array
 * @param {!Array<?>=} array Array The Array to calculate the sum value of.
 * @return {number} Number The sum.
 */
Ext.Array.sum = function(array) {};

/**
 * [Method] Converts any iterable numeric indices and a length property into a true array
 * @param {?=} iterable Object the iterable object to be turned into a true Array.
 * @param {number=} start Number a zero-based index that specifies the start of extraction. Defaults to 0
 * @param {number=} end Number a 1-based index that specifies the end of extraction. Defaults to the last index of the iterable value
 * @return {!Array<?>} Array array
 */
Ext.Array.toArray = function(iterable, start, end) {};

/**
 * [Method] Creates a map object keyed by the elements of the given array
 * @param {!Array<?>=} array Array The Array to create the map from.
 * @param {?=} getKey String/Function Name of the object property to use as a key or a function to extract the key.
 * @param {?=} scope Object Value of this inside callback.
 * @return {?} Object The resulting map.
 */
Ext.Array.toMap = function(array, getKey, scope) {};

/**
 * [Method] Creates a map object keyed by a property of elements of the given array
 * @param {!Array<?>=} array Array The Array to create the map from.
 * @param {?=} getKey String/Function Name of the object property to use as a key or a function to extract the key.
 * @param {?=} scope Object Value of this inside callback.
 * @return {?} Object The resulting map.
 */
Ext.Array.toValueMap = function(array, getKey, scope) {};

/**
 * [Method] Merge multiple arrays into one with unique items
 * @param {!Array<?>=} array1 Array
 * @param {!Array<?>=} array2 Array
 * @param {!Array<?>=} etc Array
 * @return {!Array<?>} Array merged
 */
Ext.Array.union = function(array1, array2, etc) {};

/**
 * [Method] Returns a new array with unique items
 * @param {!Array<?>=} array Array
 * @return {!Array<?>} Array results
 */
Ext.Array.unique = function(array) {};
/**
 * @extends {Ext.IClass}
 * @record
 * @struct
 */
Ext.IBase = function() {};
 /** @type {!Ext.IClass} */
Ext.IBase.prototype.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.IBase.prototype.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.IBase.prototype.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.IBase.prototype.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.IBase.prototype.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.IBase.prototype.initConfig = function(config) {};
/**
 * @constructor
 * @struct
 */
Ext.Base = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.Base.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.Base.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.Base.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.Base.createAlias = function(alias, origin) {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.Base.getName = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.Base.implement = function() {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.Base.override = function(members) {};
/** @const */
Ext.button = {};
/**
 * @extends {Ext.IComponent}
 * @extends {Ext.IQueryable}
 * @record
 * @struct
 */
Ext.button.IButton = function() {};
 /** @type {boolean} */
Ext.button.IButton.prototype.allowDepress;
 /** @type {string} */
Ext.button.IButton.prototype.arrowAlign;
 /** @type {string} */
Ext.button.IButton.prototype.arrowCls;
 /** @type {string} */
Ext.button.IButton.prototype.baseCls;
 /** @type {?} */
Ext.button.IButton.prototype.baseParams;
 /** @type {string} */
Ext.button.IButton.prototype.clickEvent;
 /** @type {string} */
Ext.button.IButton.prototype.cls;
 /** @type {?} */
Ext.button.IButton.prototype.componentLayout;
 /** @type {boolean} */
Ext.button.IButton.prototype.destroyMenu;
 /** @type {boolean} */
Ext.button.IButton.prototype.disabled;
 /** @type {boolean} */
Ext.button.IButton.prototype.enableToggle;
 /** @type {string} */
Ext.button.IButton.prototype.focusCls;
 /** @type {boolean} */
Ext.button.IButton.prototype.frame;
 /** @type {?} */
Ext.button.IButton.prototype.glyph;
 /** @type {boolean} */
Ext.button.IButton.prototype.handleMouseEvents;
 /** @type {?} */
Ext.button.IButton.prototype.handler;
 /** @type {boolean} */
Ext.button.IButton.prototype.hidden;
 /** @type {string} */
Ext.button.IButton.prototype.href;
 /** @type {string} */
Ext.button.IButton.prototype.hrefTarget;
 /** @type {string} */
Ext.button.IButton.prototype.icon;
 /** @type {string} */
Ext.button.IButton.prototype.iconAlign;
 /** @type {string} */
Ext.button.IButton.prototype.iconCls;
 /** @type {?} */
Ext.button.IButton.prototype.menu;
 /** @type {string} */
Ext.button.IButton.prototype.menuActiveCls;
 /** @type {string} */
Ext.button.IButton.prototype.menuAlign;
 /** @type {number} */
Ext.button.IButton.prototype.minWidth;
 /** @type {string} */
Ext.button.IButton.prototype.overCls;
 /** @type {string} */
Ext.button.IButton.prototype.overflowText;
 /** @type {?} */
Ext.button.IButton.prototype.params;
 /** @type {boolean} */
Ext.button.IButton.prototype.pressed;
 /** @type {string} */
Ext.button.IButton.prototype.pressedCls;
 /** @type {boolean} */
Ext.button.IButton.prototype.preventDefault;
 /** @type {?} */
Ext.button.IButton.prototype.renderTpl;
 /** @type {?} */
Ext.button.IButton.prototype.repeat;
 /** @type {?} */
Ext.button.IButton.prototype.scale;
 /** @type {?} */
Ext.button.IButton.prototype.scope;
 /** @type {boolean} */
Ext.button.IButton.prototype.showEmptyMenu;
 /** @type {?} */
Ext.button.IButton.prototype.shrinkWrap;
 /** @type {number} */
Ext.button.IButton.prototype.tabIndex;
 /** @type {string} */
Ext.button.IButton.prototype.text;
 /** @type {string} */
Ext.button.IButton.prototype.textAlign;
 /** @type {string} */
Ext.button.IButton.prototype.toggleGroup;
 /** @type {?} */
Ext.button.IButton.prototype.toggleHandler;
 /** @type {?} */
Ext.button.IButton.prototype.tooltip;
 /** @type {string} */
Ext.button.IButton.prototype.tooltipType;
 /** @type {boolean} */
Ext.button.IButton.prototype.isAction;
 /** @type {!Ext.ITemplate} */
Ext.button.IButton.prototype.template;

/**
 * [Method] Retrieves the first direct child of this container which matches the passed selector or component
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching child Ext.Component (or null if no match was found).
 */
Ext.button.IButton.prototype.child = function(selector) {};

/**
 * [Method] inherit docs
 * @param {?=} silent Object
 * @return {void}
 */
Ext.button.IButton.prototype.disable = function(silent) {};

/**
 * [Method] Retrieves the first descendant of this container which matches the passed selector
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector or Ext.Component. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching descendant Ext.Component (or null if no match was found).
 */
Ext.button.IButton.prototype.down = function(selector) {};

/**
 * [Method] inherit docs
 * @param {?=} silent Object
 * @return {void}
 */
Ext.button.IButton.prototype.enable = function(silent) {};

/**
 * [Method] This method returns an object which provides substitution parameters for the XTemplate used to create this Button s D
 * @return {?} Object Substitution data for a Template. The default implementation which provides data for the default template returns an Object containing the following properties:
 */
Ext.button.IButton.prototype.getTemplateArgs = function() {};

/**
 * [Method] Gets the text for this Button
 * @return {string} String The button text
 */
Ext.button.IButton.prototype.getText = function() {};

/**
 * [Method] Returns true if the button has a menu and it is visible
 * @return {boolean} Boolean
 */
Ext.button.IButton.prototype.hasVisibleMenu = function() {};

/**
 * [Method] Hides this button s menu if it has one
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.button.IButton.prototype.hideMenu = function() {};

/**
 * [Method] inherit docs
 * @return {void}
 */
Ext.button.IButton.prototype.initComponent = function() {};

/**
 * [Method] See comments in onFocus
 * @return {void}
 */
Ext.button.IButton.prototype.onDisable = function() {};

/**
 * [Method] Retrieves all descendant components which match the passed selector
 * @param {string=} selector String Selector complying to an Ext.ComponentQuery selector. If no selector is specified all items will be returned.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components which matched the selector
 */
Ext.button.IButton.prototype.query = function(selector) {};

/**
 * [Method] Retrieves all descendant components which match the passed function
 * @param {?=} fn Function The matcher function. It will be called with a single argument, the component being tested.
 * @param {?=} scope Object The scope in which to run the function. If not specified, it will default to the active component.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components matched by the passed function
 */
Ext.button.IButton.prototype.queryBy = function(fn, scope) {};

/**
 * [Method] Finds a component at any level under this container matching the id itemId
 * @param {string=} id String The id to find
 * @return {!Ext.IComponent} Ext.Component The matching id, null if not found
 */
Ext.button.IButton.prototype.queryById = function(id) {};

/**
 * [Method] Sets this button s glyph
 * @param {?=} glyph Number/String the numeric charCode or string charCode/font-family. This parameter expects a format consistent with that of glyph
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.button.IButton.prototype.setGlyph = function(glyph) {};

/**
 * [Method] Assigns this Button s click handler
 * @param {?=} handler Function The function to call when the button is clicked
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. Defaults to this Button.
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.button.IButton.prototype.setHandler = function(handler, scope) {};

/**
 * [Method] Sets the href of the embedded anchor element to the passed URL
 * @param {string=} href String The URL to set in the anchor element.
 * @return {void}
 */
Ext.button.IButton.prototype.setHref = function(href) {};

/**
 * [Method] Sets the background image inline style of the button
 * @param {string=} icon String The path to an image to display in the button
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.button.IButton.prototype.setIcon = function(icon) {};

/**
 * [Method] Sets the CSS class that provides a background image to use as the button s icon
 * @param {string=} cls String The CSS class providing the icon image
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.button.IButton.prototype.setIconCls = function(cls) {};

/**
 * [Method] Sets the href of the link dynamically according to the params passed and any baseParams configured
 * @param {?=} params Object Parameters to use in the href URL.
 * @return {void}
 */
Ext.button.IButton.prototype.setParams = function(params) {};

/**
 * [Method] Method to change the scale of the button
 * @param {string=} scale String The scale to change to.
 * @return {void}
 */
Ext.button.IButton.prototype.setScale = function(scale) {};

/**
 * [Method] Sets this Button s text
 * @param {string=} text String The button text
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.button.IButton.prototype.setText = function(text) {};

/**
 * [Method] Sets the text alignment for this button
 * @param {string=} align String The new alignment of the button text. See textAlign.
 * @return {void}
 */
Ext.button.IButton.prototype.setTextAlign = function(align) {};

/**
 * [Method] Sets the tooltip for this Button
 * @param {?=} tooltip String/Object This may be:  String : A string to be used as innerHTML (html tags are accepted) to show in a tooltip Object : A configuration object for Ext.tip.QuickTipManager.register.
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.button.IButton.prototype.setTooltip = function(tooltip) {};

/**
 * [Method] inherit docs
 * @param {?=} ui Object
 * @return {void}
 */
Ext.button.IButton.prototype.setUI = function(ui) {};

/**
 * [Method] Shows this button s menu if it has one
 * @param {?=} fromEvent Object
 * @return {void}
 */
Ext.button.IButton.prototype.showMenu = function(fromEvent) {};

/**
 * [Method] If a state it passed it becomes the pressed state otherwise the current state is toggled
 * @param {boolean=} state Boolean Force a particular state
 * @param {boolean=} suppressEvent Boolean True to stop events being fired when calling this method.
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.button.IButton.prototype.toggle = function(state, suppressEvent) {};
/**
 * @extends {Ext.IComponent}
 * @extends {Ext.IQueryable}
 * @record
 * @struct
 */
Ext.IButton = function() {};
 /** @type {boolean} */
Ext.IButton.prototype.allowDepress;
 /** @type {string} */
Ext.IButton.prototype.arrowAlign;
 /** @type {string} */
Ext.IButton.prototype.arrowCls;
 /** @type {string} */
Ext.IButton.prototype.baseCls;
 /** @type {?} */
Ext.IButton.prototype.baseParams;
 /** @type {string} */
Ext.IButton.prototype.clickEvent;
 /** @type {string} */
Ext.IButton.prototype.cls;
 /** @type {?} */
Ext.IButton.prototype.componentLayout;
 /** @type {boolean} */
Ext.IButton.prototype.destroyMenu;
 /** @type {boolean} */
Ext.IButton.prototype.disabled;
 /** @type {boolean} */
Ext.IButton.prototype.enableToggle;
 /** @type {string} */
Ext.IButton.prototype.focusCls;
 /** @type {boolean} */
Ext.IButton.prototype.frame;
 /** @type {?} */
Ext.IButton.prototype.glyph;
 /** @type {boolean} */
Ext.IButton.prototype.handleMouseEvents;
 /** @type {?} */
Ext.IButton.prototype.handler;
 /** @type {boolean} */
Ext.IButton.prototype.hidden;
 /** @type {string} */
Ext.IButton.prototype.href;
 /** @type {string} */
Ext.IButton.prototype.hrefTarget;
 /** @type {string} */
Ext.IButton.prototype.icon;
 /** @type {string} */
Ext.IButton.prototype.iconAlign;
 /** @type {string} */
Ext.IButton.prototype.iconCls;
 /** @type {?} */
Ext.IButton.prototype.menu;
 /** @type {string} */
Ext.IButton.prototype.menuActiveCls;
 /** @type {string} */
Ext.IButton.prototype.menuAlign;
 /** @type {number} */
Ext.IButton.prototype.minWidth;
 /** @type {string} */
Ext.IButton.prototype.overCls;
 /** @type {string} */
Ext.IButton.prototype.overflowText;
 /** @type {?} */
Ext.IButton.prototype.params;
 /** @type {boolean} */
Ext.IButton.prototype.pressed;
 /** @type {string} */
Ext.IButton.prototype.pressedCls;
 /** @type {boolean} */
Ext.IButton.prototype.preventDefault;
 /** @type {?} */
Ext.IButton.prototype.renderTpl;
 /** @type {?} */
Ext.IButton.prototype.repeat;
 /** @type {?} */
Ext.IButton.prototype.scale;
 /** @type {?} */
Ext.IButton.prototype.scope;
 /** @type {boolean} */
Ext.IButton.prototype.showEmptyMenu;
 /** @type {?} */
Ext.IButton.prototype.shrinkWrap;
 /** @type {number} */
Ext.IButton.prototype.tabIndex;
 /** @type {string} */
Ext.IButton.prototype.text;
 /** @type {string} */
Ext.IButton.prototype.textAlign;
 /** @type {string} */
Ext.IButton.prototype.toggleGroup;
 /** @type {?} */
Ext.IButton.prototype.toggleHandler;
 /** @type {?} */
Ext.IButton.prototype.tooltip;
 /** @type {string} */
Ext.IButton.prototype.tooltipType;
 /** @type {boolean} */
Ext.IButton.prototype.isAction;
 /** @type {!Ext.ITemplate} */
Ext.IButton.prototype.template;

/**
 * [Method] Retrieves the first direct child of this container which matches the passed selector or component
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching child Ext.Component (or null if no match was found).
 */
Ext.IButton.prototype.child = function(selector) {};

/**
 * [Method] inherit docs
 * @param {?=} silent Object
 * @return {void}
 */
Ext.IButton.prototype.disable = function(silent) {};

/**
 * [Method] Retrieves the first descendant of this container which matches the passed selector
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector or Ext.Component. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching descendant Ext.Component (or null if no match was found).
 */
Ext.IButton.prototype.down = function(selector) {};

/**
 * [Method] inherit docs
 * @param {?=} silent Object
 * @return {void}
 */
Ext.IButton.prototype.enable = function(silent) {};

/**
 * [Method] This method returns an object which provides substitution parameters for the XTemplate used to create this Button s D
 * @return {?} Object Substitution data for a Template. The default implementation which provides data for the default template returns an Object containing the following properties:
 */
Ext.IButton.prototype.getTemplateArgs = function() {};

/**
 * [Method] Gets the text for this Button
 * @return {string} String The button text
 */
Ext.IButton.prototype.getText = function() {};

/**
 * [Method] Returns true if the button has a menu and it is visible
 * @return {boolean} Boolean
 */
Ext.IButton.prototype.hasVisibleMenu = function() {};

/**
 * [Method] Hides this button s menu if it has one
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.IButton.prototype.hideMenu = function() {};

/**
 * [Method] inherit docs
 * @return {void}
 */
Ext.IButton.prototype.initComponent = function() {};

/**
 * [Method] See comments in onFocus
 * @return {void}
 */
Ext.IButton.prototype.onDisable = function() {};

/**
 * [Method] Retrieves all descendant components which match the passed selector
 * @param {string=} selector String Selector complying to an Ext.ComponentQuery selector. If no selector is specified all items will be returned.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components which matched the selector
 */
Ext.IButton.prototype.query = function(selector) {};

/**
 * [Method] Retrieves all descendant components which match the passed function
 * @param {?=} fn Function The matcher function. It will be called with a single argument, the component being tested.
 * @param {?=} scope Object The scope in which to run the function. If not specified, it will default to the active component.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components matched by the passed function
 */
Ext.IButton.prototype.queryBy = function(fn, scope) {};

/**
 * [Method] Finds a component at any level under this container matching the id itemId
 * @param {string=} id String The id to find
 * @return {!Ext.IComponent} Ext.Component The matching id, null if not found
 */
Ext.IButton.prototype.queryById = function(id) {};

/**
 * [Method] Sets this button s glyph
 * @param {?=} glyph Number/String the numeric charCode or string charCode/font-family. This parameter expects a format consistent with that of glyph
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.IButton.prototype.setGlyph = function(glyph) {};

/**
 * [Method] Assigns this Button s click handler
 * @param {?=} handler Function The function to call when the button is clicked
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. Defaults to this Button.
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.IButton.prototype.setHandler = function(handler, scope) {};

/**
 * [Method] Sets the href of the embedded anchor element to the passed URL
 * @param {string=} href String The URL to set in the anchor element.
 * @return {void}
 */
Ext.IButton.prototype.setHref = function(href) {};

/**
 * [Method] Sets the background image inline style of the button
 * @param {string=} icon String The path to an image to display in the button
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.IButton.prototype.setIcon = function(icon) {};

/**
 * [Method] Sets the CSS class that provides a background image to use as the button s icon
 * @param {string=} cls String The CSS class providing the icon image
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.IButton.prototype.setIconCls = function(cls) {};

/**
 * [Method] Sets the href of the link dynamically according to the params passed and any baseParams configured
 * @param {?=} params Object Parameters to use in the href URL.
 * @return {void}
 */
Ext.IButton.prototype.setParams = function(params) {};

/**
 * [Method] Method to change the scale of the button
 * @param {string=} scale String The scale to change to.
 * @return {void}
 */
Ext.IButton.prototype.setScale = function(scale) {};

/**
 * [Method] Sets this Button s text
 * @param {string=} text String The button text
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.IButton.prototype.setText = function(text) {};

/**
 * [Method] Sets the text alignment for this button
 * @param {string=} align String The new alignment of the button text. See textAlign.
 * @return {void}
 */
Ext.IButton.prototype.setTextAlign = function(align) {};

/**
 * [Method] Sets the tooltip for this Button
 * @param {?=} tooltip String/Object This may be:  String : A string to be used as innerHTML (html tags are accepted) to show in a tooltip Object : A configuration object for Ext.tip.QuickTipManager.register.
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.IButton.prototype.setTooltip = function(tooltip) {};

/**
 * [Method] inherit docs
 * @param {?=} ui Object
 * @return {void}
 */
Ext.IButton.prototype.setUI = function(ui) {};

/**
 * [Method] Shows this button s menu if it has one
 * @param {?=} fromEvent Object
 * @return {void}
 */
Ext.IButton.prototype.showMenu = function(fromEvent) {};

/**
 * [Method] If a state it passed it becomes the pressed state otherwise the current state is toggled
 * @param {boolean=} state Boolean Force a particular state
 * @param {boolean=} suppressEvent Boolean True to stop events being fired when calling this method.
 * @return {!Ext.button.IButton} Ext.button.Button this
 */
Ext.IButton.prototype.toggle = function(state, suppressEvent) {};
/**
 * @extends {Ext.button.ISplit}
 * @record
 * @struct
 */
Ext.button.ICycle = function() {};
 /** @type {?} */
Ext.button.ICycle.prototype.changeHandler;
 /** @type {?} */
Ext.button.ICycle.prototype.forceGlyph;
 /** @type {string} */
Ext.button.ICycle.prototype.forceIcon;
 /** @type {!Array<?>} */
Ext.button.ICycle.prototype.items;
 /** @type {string} */
Ext.button.ICycle.prototype.prependText;
 /** @type {boolean} */
Ext.button.ICycle.prototype.showText;
 /** @type {!Ext.menu.IMenu} */
Ext.button.ICycle.prototype.menu;

/**
 * [Method] Gets the currently active menu item
 * @return {!Ext.menu.ICheckItem} Ext.menu.CheckItem The active item
 */
Ext.button.ICycle.prototype.getActiveItem = function() {};

/**
 * [Method] Sets the button s active menu item
 * @param {!Ext.menu.ICheckItem=} item Ext.menu.CheckItem The item to activate
 * @param {boolean=} suppressEvent Boolean True to prevent the button's change event from firing.
 * @return {void}
 */
Ext.button.ICycle.prototype.setActiveItem = function(item, suppressEvent) {};

/**
 * [Method] This is normally called internally on button click but can be called externally to advance the button s active item
 * @return {void}
 */
Ext.button.ICycle.prototype.toggleSelected = function() {};
/**
 * @extends {Ext.button.ISplit}
 * @record
 * @struct
 */
Ext.ICycleButton = function() {};
 /** @type {?} */
Ext.ICycleButton.prototype.changeHandler;
 /** @type {?} */
Ext.ICycleButton.prototype.forceGlyph;
 /** @type {string} */
Ext.ICycleButton.prototype.forceIcon;
 /** @type {!Array<?>} */
Ext.ICycleButton.prototype.items;
 /** @type {string} */
Ext.ICycleButton.prototype.prependText;
 /** @type {boolean} */
Ext.ICycleButton.prototype.showText;
 /** @type {!Ext.menu.IMenu} */
Ext.ICycleButton.prototype.menu;

/**
 * [Method] Gets the currently active menu item
 * @return {!Ext.menu.ICheckItem} Ext.menu.CheckItem The active item
 */
Ext.ICycleButton.prototype.getActiveItem = function() {};

/**
 * [Method] Sets the button s active menu item
 * @param {!Ext.menu.ICheckItem=} item Ext.menu.CheckItem The item to activate
 * @param {boolean=} suppressEvent Boolean True to prevent the button's change event from firing.
 * @return {void}
 */
Ext.ICycleButton.prototype.setActiveItem = function(item, suppressEvent) {};

/**
 * [Method] This is normally called internally on button click but can be called externally to advance the button s active item
 * @return {void}
 */
Ext.ICycleButton.prototype.toggleSelected = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.button.IManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.button.Manager = function() {};
 /** @type {!Ext.IClass} */
Ext.button.Manager.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.button.Manager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.button.Manager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.button.Manager.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.button.Manager.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.button.Manager.initConfig = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.button.Manager.statics = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IButtonToggleManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.ButtonToggleManager = function() {};
 /** @type {!Ext.IClass} */
Ext.ButtonToggleManager.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.ButtonToggleManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.ButtonToggleManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.ButtonToggleManager.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.ButtonToggleManager.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.ButtonToggleManager.initConfig = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.ButtonToggleManager.statics = function() {};
/**
 * @extends {Ext.button.IButton}
 * @record
 * @struct
 */
Ext.button.ISplit = function() {};
 /** @type {?} */
Ext.button.ISplit.prototype.arrowHandler;
 /** @type {string} */
Ext.button.ISplit.prototype.arrowTooltip;

/**
 * [Method] Sets this button s arrow click handler
 * @param {?=} handler Function The function to call when the arrow is clicked.
 * @param {?=} scope Object Scope for the function passed above.
 * @return {void}
 */
Ext.button.ISplit.prototype.setArrowHandler = function(handler, scope) {};
/**
 * @extends {Ext.button.IButton}
 * @record
 * @struct
 */
Ext.ISplitButton = function() {};
 /** @type {?} */
Ext.ISplitButton.prototype.arrowHandler;
 /** @type {string} */
Ext.ISplitButton.prototype.arrowTooltip;

/**
 * [Method] Sets this button s arrow click handler
 * @param {?=} handler Function The function to call when the arrow is clicked.
 * @param {?=} scope Object Scope for the function passed above.
 * @return {void}
 */
Ext.ISplitButton.prototype.setArrowHandler = function(handler, scope) {};
/** @const */
Ext.chart = {};
/** @const */
Ext.chart.axis = {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.chart.axis.IAbstract = function() {};
 /** @type {!Array<string>} */
Ext.chart.axis.IAbstract.prototype.fields;
 /** @type {!Ext.chart.ILabel} */
Ext.chart.axis.IAbstract.prototype.label;
/**
 * @extends {Ext.chart.axis.IAbstract}
 * @record
 * @struct
 */
Ext.chart.axis.IAxis = function() {};
 /** @type {boolean} */
Ext.chart.axis.IAxis.prototype.adjustEnd;
 /** @type {number} */
Ext.chart.axis.IAxis.prototype.dashSize;
 /** @type {?} */
Ext.chart.axis.IAxis.prototype.grid;
 /** @type {boolean} */
Ext.chart.axis.IAxis.prototype.hidden;
 /** @type {number} */
Ext.chart.axis.IAxis.prototype.length;
 /** @type {number} */
Ext.chart.axis.IAxis.prototype.majorTickSteps;
 /** @type {number} */
Ext.chart.axis.IAxis.prototype.minorTickSteps;
 /** @type {string} */
Ext.chart.axis.IAxis.prototype.position;
 /** @type {string} */
Ext.chart.axis.IAxis.prototype.title;
 /** @type {number} */
Ext.chart.axis.IAxis.prototype.width;

/**
 * [Method] Renders the axis into the screen and updates its position
 * @param {?=} init Object
 * @return {void}
 */
Ext.chart.axis.IAxis.prototype.drawAxis = function(init) {};

/**
 * [Method] Renders an horizontal and or vertical grid into the Surface
 * @return {void}
 */
Ext.chart.axis.IAxis.prototype.drawGrid = function() {};

/**
 * [Method] Renders the labels in the axes
 * @return {void}
 */
Ext.chart.axis.IAxis.prototype.drawLabel = function() {};

/**
 * [Method] Updates the title of this axis
 * @param {string=} title String
 * @return {void}
 */
Ext.chart.axis.IAxis.prototype.setTitle = function(title) {};
/**
 * @extends {Ext.chart.axis.IAbstract}
 * @record
 * @struct
 */
Ext.chart.IAxis = function() {};
 /** @type {boolean} */
Ext.chart.IAxis.prototype.adjustEnd;
 /** @type {number} */
Ext.chart.IAxis.prototype.dashSize;
 /** @type {?} */
Ext.chart.IAxis.prototype.grid;
 /** @type {boolean} */
Ext.chart.IAxis.prototype.hidden;
 /** @type {number} */
Ext.chart.IAxis.prototype.length;
 /** @type {number} */
Ext.chart.IAxis.prototype.majorTickSteps;
 /** @type {number} */
Ext.chart.IAxis.prototype.minorTickSteps;
 /** @type {string} */
Ext.chart.IAxis.prototype.position;
 /** @type {string} */
Ext.chart.IAxis.prototype.title;
 /** @type {number} */
Ext.chart.IAxis.prototype.width;

/**
 * [Method] Renders the axis into the screen and updates its position
 * @param {?=} init Object
 * @return {void}
 */
Ext.chart.IAxis.prototype.drawAxis = function(init) {};

/**
 * [Method] Renders an horizontal and or vertical grid into the Surface
 * @return {void}
 */
Ext.chart.IAxis.prototype.drawGrid = function() {};

/**
 * [Method] Renders the labels in the axes
 * @return {void}
 */
Ext.chart.IAxis.prototype.drawLabel = function() {};

/**
 * [Method] Updates the title of this axis
 * @param {string=} title String
 * @return {void}
 */
Ext.chart.IAxis.prototype.setTitle = function(title) {};
/**
 * @extends {Ext.chart.axis.IAxis}
 * @record
 * @struct
 */
Ext.chart.axis.ICategory = function() {};
 /** @type {boolean} */
Ext.chart.axis.ICategory.prototype.calculateCategoryCount;
 /** @type {string} */
Ext.chart.axis.ICategory.prototype.categoryNames;
/**
 * @extends {Ext.chart.axis.IAxis}
 * @record
 * @struct
 */
Ext.chart.ICategoryAxis = function() {};
 /** @type {boolean} */
Ext.chart.ICategoryAxis.prototype.calculateCategoryCount;
 /** @type {string} */
Ext.chart.ICategoryAxis.prototype.categoryNames;
/**
 * @extends {Ext.chart.axis.IAbstract}
 * @record
 * @struct
 */
Ext.chart.axis.IGauge = function() {};
 /** @type {number} */
Ext.chart.axis.IGauge.prototype.margin;
 /** @type {number} */
Ext.chart.axis.IGauge.prototype.maximum;
 /** @type {number} */
Ext.chart.axis.IGauge.prototype.minimum;
 /** @type {number} */
Ext.chart.axis.IGauge.prototype.steps;
 /** @type {string} */
Ext.chart.axis.IGauge.prototype.title;

/**
 * [Method] Updates the title of this axis
 * @param {string=} title String
 * @return {void}
 */
Ext.chart.axis.IGauge.prototype.setTitle = function(title) {};
/**
 * @extends {Ext.chart.axis.IAxis}
 * @record
 * @struct
 */
Ext.chart.axis.INumeric = function() {};
 /** @type {boolean} */
Ext.chart.axis.INumeric.prototype.adjustMaximumByMajorUnit;
 /** @type {boolean} */
Ext.chart.axis.INumeric.prototype.adjustMinimumByMajorUnit;
 /** @type {boolean} */
Ext.chart.axis.INumeric.prototype.constrain;
 /** @type {number} */
Ext.chart.axis.INumeric.prototype.decimals;
 /** @type {number} */
Ext.chart.axis.INumeric.prototype.maximum;
 /** @type {number} */
Ext.chart.axis.INumeric.prototype.minimum;
 /** @type {string} */
Ext.chart.axis.INumeric.prototype.position;
/**
 * @extends {Ext.chart.axis.IAxis}
 * @record
 * @struct
 */
Ext.chart.INumericAxis = function() {};
 /** @type {boolean} */
Ext.chart.INumericAxis.prototype.adjustMaximumByMajorUnit;
 /** @type {boolean} */
Ext.chart.INumericAxis.prototype.adjustMinimumByMajorUnit;
 /** @type {boolean} */
Ext.chart.INumericAxis.prototype.constrain;
 /** @type {number} */
Ext.chart.INumericAxis.prototype.decimals;
 /** @type {number} */
Ext.chart.INumericAxis.prototype.maximum;
 /** @type {number} */
Ext.chart.INumericAxis.prototype.minimum;
 /** @type {string} */
Ext.chart.INumericAxis.prototype.position;
/**
 * @extends {Ext.chart.axis.INumeric}
 * @record
 * @struct
 */
Ext.chart.axis.IRadial = function() {};
 /** @type {number} */
Ext.chart.axis.IRadial.prototype.maximum;
 /** @type {string} */
Ext.chart.axis.IRadial.prototype.position;
 /** @type {number} */
Ext.chart.axis.IRadial.prototype.steps;

/**
 * [Method] Renders the labels in the axes
 * @return {void}
 */
Ext.chart.axis.IRadial.prototype.drawLabel = function() {};
/**
 * @extends {Ext.chart.axis.INumeric}
 * @record
 * @struct
 */
Ext.chart.axis.ITime = function() {};
 /** @type {boolean} */
Ext.chart.axis.ITime.prototype.constrain;
 /** @type {?} */
Ext.chart.axis.ITime.prototype.dateFormat;
 /** @type {?} */
Ext.chart.axis.ITime.prototype.fromDate;
 /** @type {!Array<?>} */
Ext.chart.axis.ITime.prototype.step;
 /** @type {?} */
Ext.chart.axis.ITime.prototype.toDate;
/**
 * @extends {Ext.chart.axis.INumeric}
 * @record
 * @struct
 */
Ext.chart.ITimeAxis = function() {};
 /** @type {boolean} */
Ext.chart.ITimeAxis.prototype.constrain;
 /** @type {?} */
Ext.chart.ITimeAxis.prototype.dateFormat;
 /** @type {?} */
Ext.chart.ITimeAxis.prototype.fromDate;
 /** @type {!Array<?>} */
Ext.chart.ITimeAxis.prototype.step;
 /** @type {?} */
Ext.chart.ITimeAxis.prototype.toDate;
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.chart.ICallout = function() {};
/**
 * @extends {Ext.draw.IComponent}
 * @extends {Ext.chart.theme.ITheme}
 * @extends {Ext.chart.IMask}
 * @extends {Ext.chart.INavigation}
 * @extends {Ext.util.IBindable}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.chart.IChart = function() {};
 /** @type {?} */
Ext.chart.IChart.prototype.animate;
 /** @type {!Array<!Ext.chart.axis.IAxis>} */
Ext.chart.IChart.prototype.axes;
 /** @type {?} */
Ext.chart.IChart.prototype.background;
 /** @type {!Array<?>} */
Ext.chart.IChart.prototype.gradients;
 /** @type {number} */
Ext.chart.IChart.prototype.insetPadding;
 /** @type {?} */
Ext.chart.IChart.prototype.legend;
 /** @type {!Array<!Ext.chart.series.ISeries>} */
Ext.chart.IChart.prototype.series;
 /** @type {!Ext.data.IStore} */
Ext.chart.IChart.prototype.store;
 /** @type {string} */
Ext.chart.IChart.prototype.theme;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.chart.IChart.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.chart.IChart.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.chart.IChart.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Binds a store to this instance
 * @param {?=} store Object
 * @param {?=} initial Object
 * @return {void}
 */
Ext.chart.IChart.prototype.bindStore = function(store, initial) {};

/**
 * [Method] Binds listeners for this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to bind to
 * @return {void}
 */
Ext.chart.IChart.prototype.bindStoreListeners = function(store) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.chart.IChart.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.chart.IChart.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.chart.IChart.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.chart.IChart.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.chart.IChart.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Gets the current store instance
 * @return {!Ext.data.IAbstractStore} Ext.data.AbstractStore The store, null if one does not exist.
 */
Ext.chart.IChart.prototype.getStore = function() {};

/**
 * [Method] Gets the listeners to bind to a new store
 * @return {?} Object The listeners to be bound to the store in object literal form. The scope may be omitted, it is assumed to be the current instance.
 */
Ext.chart.IChart.prototype.getStoreListeners = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.chart.IChart.prototype.hasListener = function(eventName) {};

/**
 * [Method] The initComponent template method is an important initialization step for a Component
 * @return {void}
 */
Ext.chart.IChart.prototype.initComponent = function() {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.chart.IChart.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.chart.IChart.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.chart.IChart.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Template method it is called when a new store is bound to the current instance
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store being bound
 * @param {boolean=} initial Boolean True if this store is being bound as initialization of the instance.
 * @return {void}
 */
Ext.chart.IChart.prototype.onBindStore = function(store, initial) {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.chart.IChart.prototype.onShow = function() {};

/**
 * [Method] Template method it is called when an existing store is unbound from the current instance
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store being unbound
 * @param {boolean=} initial Boolean True if this store is being bound as initialization of the instance.
 * @return {void}
 */
Ext.chart.IChart.prototype.onUnbindStore = function(store, initial) {};

/**
 * [Method] Redraws the chart
 * @param {boolean=} resize Boolean flag which changes the default origin points of the chart for animations.
 * @return {void}
 */
Ext.chart.IChart.prototype.redraw = function(resize) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.chart.IChart.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.chart.IChart.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.chart.IChart.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Restores the zoom to the original value
 * @return {void}
 */
Ext.chart.IChart.prototype.restoreZoom = function() {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.chart.IChart.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.chart.IChart.prototype.resumeEvents = function() {};

/**
 * [Method] Saves the chart by either triggering a download or returning a string containing the chart data as SVG
 * @param {?=} config Object The configuration to be passed to the exporter. See the export method for the appropriate exporter for the relevant configuration options
 * @return {?} Object See the return types for the appropriate exporter
 */
Ext.chart.IChart.prototype.save = function(config) {};

/**
 * [Method] Zooms the chart to the specified selection range
 * @param {?=} zoomConfig Object
 * @return {void}
 */
Ext.chart.IChart.prototype.setZoom = function(zoomConfig) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.chart.IChart.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.chart.IChart.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.chart.IChart.prototype.un = function(eventName, fn, scope) {};

/**
 * [Method] Unbinds listeners from this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to unbind from
 * @return {void}
 */
Ext.chart.IChart.prototype.unbindStoreListeners = function(store) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.chart.IHighlight = function() {};
 /** @type {?} */
Ext.chart.IHighlight.prototype.highlight;
 /** @type {?} */
Ext.chart.IHighlight.prototype.highlightCfg;

/**
 * [Method] Highlight the given series item
 * @param {?=} item Object Info about the item; same format as returned by #getItemForPoint.
 * @return {void}
 */
Ext.chart.IHighlight.prototype.highlightItem = function(item) {};

/**
 * [Method] Un highlight any existing highlights
 * @return {void}
 */
Ext.chart.IHighlight.prototype.unHighlightItem = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.chart.ILabel = function() {};
 /** @type {?} */
Ext.chart.ILabel.prototype.label;

/**
 * [Method] Called each time a new label is created
 * @param {!Ext.data.IModel=} storeItem Ext.data.Model The element of the store that is related to the sprite.
 * @param {?=} item Object The item related to the sprite. An item is an object containing the position of the shape used to describe the visualization and also pointing to the actual shape (circle, rectangle, path, etc).
 * @param {number=} i Number The index of the element created (i.e the first created label, second created label, etc).
 * @param {string=} display String The label.display type. May be false if the label is hidden
 * @return {!Ext.draw.ISprite} Ext.draw.Sprite The created sprite that will draw the label.
 */
Ext.chart.ILabel.prototype.onCreateLabel = function(storeItem, item, i, display) {};

/**
 * [Method] Called for updating the position of the label
 * @param {!Ext.draw.ISprite=} label Ext.draw.Sprite The sprite that draws the label.
 * @param {!Ext.data.IModel=} storeItem Ext.data.Model The element of the store that is related to the sprite.
 * @param {?=} item Object The item related to the sprite. An item is an object containing the position of the shape used to describe the visualization and also pointing to the actual shape (circle, rectangle, path, etc).
 * @param {number=} i Number The index of the element to be updated (i.e. whether it is the first, second, third from the labelGroup)
 * @param {string=} display String The label.display type. May be false if the label is hidden
 * @param {boolean=} animate Boolean A boolean value to set or unset animations for the labels.
 * @param {number=} index Number The series index.
 * @return {void}
 */
Ext.chart.ILabel.prototype.onPlaceLabel = function(label, storeItem, item, i, display, animate, index) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.chart.ILegend = function() {};
 /** @type {string} */
Ext.chart.ILegend.prototype.boxFill;
 /** @type {string} */
Ext.chart.ILegend.prototype.boxStroke;
 /** @type {string} */
Ext.chart.ILegend.prototype.boxStrokeWidth;
 /** @type {number} */
Ext.chart.ILegend.prototype.boxZIndex;
 /** @type {number} */
Ext.chart.ILegend.prototype.itemSpacing;
 /** @type {string} */
Ext.chart.ILegend.prototype.labelColor;
 /** @type {string} */
Ext.chart.ILegend.prototype.labelFont;
 /** @type {number} */
Ext.chart.ILegend.prototype.padding;
 /** @type {string} */
Ext.chart.ILegend.prototype.position;
 /** @type {boolean} */
Ext.chart.ILegend.prototype.update;
 /** @type {boolean} */
Ext.chart.ILegend.prototype.visible;
 /** @type {number} */
Ext.chart.ILegend.prototype.x;
 /** @type {number} */
Ext.chart.ILegend.prototype.y;
 /** @type {boolean} */
Ext.chart.ILegend.prototype.isVertical;

/**
 * [Method] toggle
 * @param {boolean=} show Boolean Whether to show or hide the legend.
 * @return {void}
 */
Ext.chart.ILegend.prototype.toggle = function(show) {};
/**
 * @extends {Ext.draw.ICompositeSprite}
 * @record
 * @struct
 */
Ext.chart.ILegendItem = function() {};

/**
 * [Method] Creates all the individual sprites for this legend item
 * @param {?=} config Object
 * @return {void}
 */
Ext.chart.ILegendItem.prototype.createLegend = function(config) {};

/**
 * [Method] Update the positions of all this item s sprites to match the root position of the legend box
 * @param {?=} relativeTo Object If specified, this object's 'x' and 'y' values will be used as the reference point for the relative positioning. Defaults to the Legend.
 * @return {void}
 */
Ext.chart.ILegendItem.prototype.updatePosition = function(relativeTo) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.chart.IMask = function() {};
 /** @type {?} */
Ext.chart.IMask.prototype.mask;
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.chart.IMaskLayer = function() {};

/**
 * [Method] The initComponent template method is an important initialization step for a Component
 * @return {void}
 */
Ext.chart.IMaskLayer.prototype.initComponent = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.chart.INavigation = function() {};

/**
 * [Method] Restores the zoom to the original value
 * @return {void}
 */
Ext.chart.INavigation.prototype.restoreZoom = function() {};

/**
 * [Method] Zooms the chart to the specified selection range
 * @param {?=} zoomConfig Object
 * @return {void}
 */
Ext.chart.INavigation.prototype.setZoom = function(zoomConfig) {};
/** @const */
Ext.chart.series = {};
/**
 * @extends {Ext.chart.series.ICartesian}
 * @record
 * @struct
 */
Ext.chart.series.IArea = function() {};
 /** @type {?} */
Ext.chart.series.IArea.prototype.style;
 /** @type {string} */
Ext.chart.series.IArea.prototype.type;

/**
 * [Method] Draws the series for the current chart
 * @return {void}
 */
Ext.chart.series.IArea.prototype.drawSeries = function() {};

/**
 * [Method] Returns the color of the series to be displayed as color for the series legend item
 * @param {?=} item Object Info about the item; same format as returned by getItemForPoint
 * @return {void}
 */
Ext.chart.series.IArea.prototype.getLegendColor = function(item) {};

/**
 * [Method] Highlight the specified item
 * @param {?=} item Object {Object} Info about the item; same format as returned by getItemForPoint
 * @return {void}
 */
Ext.chart.series.IArea.prototype.highlightItem = function(item) {};

/**
 * [Method] Highlight this entire series
 * @param {?=} item Object Info about the item; same format as returned by getItemForPoint.
 * @return {void}
 */
Ext.chart.series.IArea.prototype.highlightSeries = function(item) {};

/**
 * [Method] Un highlights the specified item
 * @param {?=} item Object Info about the item; same format as returned by getItemForPoint
 * @return {void}
 */
Ext.chart.series.IArea.prototype.unHighlightItem = function(item) {};

/**
 * [Method] UnHighlight this entire series
 * @param {?=} item Object Info about the item; same format as returned by getItemForPoint.
 * @return {void}
 */
Ext.chart.series.IArea.prototype.unHighlightSeries = function(item) {};
/**
 * @extends {Ext.chart.series.ICartesian}
 * @record
 * @struct
 */
Ext.chart.series.IBar = function() {};
 /** @type {boolean} */
Ext.chart.series.IBar.prototype.column;
 /** @type {number} */
Ext.chart.series.IBar.prototype.groupGutter;
 /** @type {number} */
Ext.chart.series.IBar.prototype.gutter;
 /** @type {boolean} */
Ext.chart.series.IBar.prototype.stacked;
 /** @type {?} */
Ext.chart.series.IBar.prototype.style;
 /** @type {string} */
Ext.chart.series.IBar.prototype.type;
 /** @type {?} */
Ext.chart.series.IBar.prototype.xPadding;
 /** @type {?} */
Ext.chart.series.IBar.prototype.yPadding;

/**
 * [Method] Draws the series for the current chart
 * @return {void}
 */
Ext.chart.series.IBar.prototype.drawSeries = function() {};

/**
 * [Method] Returns a string with the color to be used for the series legend item
 * @param {?=} index Object
 * @return {void}
 */
Ext.chart.series.IBar.prototype.getLegendColor = function(index) {};

/**
 * [Method] Highlight the given series item
 * @param {?=} item Object
 * @return {void}
 */
Ext.chart.series.IBar.prototype.highlightItem = function(item) {};

/**
 * [Method] Un highlight any existing highlights
 * @return {void}
 */
Ext.chart.series.IBar.prototype.unHighlightItem = function() {};
/**
 * @extends {Ext.chart.series.ICartesian}
 * @record
 * @struct
 */
Ext.chart.IBarSeries = function() {};
 /** @type {boolean} */
Ext.chart.IBarSeries.prototype.column;
 /** @type {number} */
Ext.chart.IBarSeries.prototype.groupGutter;
 /** @type {number} */
Ext.chart.IBarSeries.prototype.gutter;
 /** @type {boolean} */
Ext.chart.IBarSeries.prototype.stacked;
 /** @type {?} */
Ext.chart.IBarSeries.prototype.style;
 /** @type {string} */
Ext.chart.IBarSeries.prototype.type;
 /** @type {?} */
Ext.chart.IBarSeries.prototype.xPadding;
 /** @type {?} */
Ext.chart.IBarSeries.prototype.yPadding;

/**
 * [Method] Draws the series for the current chart
 * @return {void}
 */
Ext.chart.IBarSeries.prototype.drawSeries = function() {};

/**
 * [Method] Returns a string with the color to be used for the series legend item
 * @param {?=} index Object
 * @return {void}
 */
Ext.chart.IBarSeries.prototype.getLegendColor = function(index) {};

/**
 * [Method] Highlight the given series item
 * @param {?=} item Object
 * @return {void}
 */
Ext.chart.IBarSeries.prototype.highlightItem = function(item) {};

/**
 * [Method] Un highlight any existing highlights
 * @return {void}
 */
Ext.chart.IBarSeries.prototype.unHighlightItem = function() {};
/**
 * @extends {Ext.chart.series.ICartesian}
 * @record
 * @struct
 */
Ext.chart.IBarChart = function() {};
 /** @type {boolean} */
Ext.chart.IBarChart.prototype.column;
 /** @type {number} */
Ext.chart.IBarChart.prototype.groupGutter;
 /** @type {number} */
Ext.chart.IBarChart.prototype.gutter;
 /** @type {boolean} */
Ext.chart.IBarChart.prototype.stacked;
 /** @type {?} */
Ext.chart.IBarChart.prototype.style;
 /** @type {string} */
Ext.chart.IBarChart.prototype.type;
 /** @type {?} */
Ext.chart.IBarChart.prototype.xPadding;
 /** @type {?} */
Ext.chart.IBarChart.prototype.yPadding;

/**
 * [Method] Draws the series for the current chart
 * @return {void}
 */
Ext.chart.IBarChart.prototype.drawSeries = function() {};

/**
 * [Method] Returns a string with the color to be used for the series legend item
 * @param {?=} index Object
 * @return {void}
 */
Ext.chart.IBarChart.prototype.getLegendColor = function(index) {};

/**
 * [Method] Highlight the given series item
 * @param {?=} item Object
 * @return {void}
 */
Ext.chart.IBarChart.prototype.highlightItem = function(item) {};

/**
 * [Method] Un highlight any existing highlights
 * @return {void}
 */
Ext.chart.IBarChart.prototype.unHighlightItem = function() {};
/**
 * @extends {Ext.chart.series.ICartesian}
 * @record
 * @struct
 */
Ext.chart.IStackedBarChart = function() {};
 /** @type {boolean} */
Ext.chart.IStackedBarChart.prototype.column;
 /** @type {number} */
Ext.chart.IStackedBarChart.prototype.groupGutter;
 /** @type {number} */
Ext.chart.IStackedBarChart.prototype.gutter;
 /** @type {boolean} */
Ext.chart.IStackedBarChart.prototype.stacked;
 /** @type {?} */
Ext.chart.IStackedBarChart.prototype.style;
 /** @type {string} */
Ext.chart.IStackedBarChart.prototype.type;
 /** @type {?} */
Ext.chart.IStackedBarChart.prototype.xPadding;
 /** @type {?} */
Ext.chart.IStackedBarChart.prototype.yPadding;

/**
 * [Method] Draws the series for the current chart
 * @return {void}
 */
Ext.chart.IStackedBarChart.prototype.drawSeries = function() {};

/**
 * [Method] Returns a string with the color to be used for the series legend item
 * @param {?=} index Object
 * @return {void}
 */
Ext.chart.IStackedBarChart.prototype.getLegendColor = function(index) {};

/**
 * [Method] Highlight the given series item
 * @param {?=} item Object
 * @return {void}
 */
Ext.chart.IStackedBarChart.prototype.highlightItem = function(item) {};

/**
 * [Method] Un highlight any existing highlights
 * @return {void}
 */
Ext.chart.IStackedBarChart.prototype.unHighlightItem = function() {};
/**
 * @extends {Ext.chart.series.ISeries}
 * @record
 * @struct
 */
Ext.chart.series.ICartesian = function() {};
 /** @type {?} */
Ext.chart.series.ICartesian.prototype.axis;
 /** @type {string} */
Ext.chart.series.ICartesian.prototype.xField;
 /** @type {?} */
Ext.chart.series.ICartesian.prototype.yField;

/**
 * [Method] Iterates over a given record s values for each of this series s yFields executing a given function for each value
 * @param {!Ext.data.IModel=} record Ext.data.Model
 * @param {?=} fn Function
 * @param {?=} scope Object
 * @return {void}
 */
Ext.chart.series.ICartesian.prototype.eachYValue = function(record, fn, scope) {};

/**
 * [Method] Calculate the min and max values for this series s xField
 * @return {!Array<?>} Array [min, max]
 */
Ext.chart.series.ICartesian.prototype.getMinMaxXValues = function() {};

/**
 * [Method] Calculate the min and max values for this series s yField s
 * @return {!Array<?>} Array [min, max]
 */
Ext.chart.series.ICartesian.prototype.getMinMaxYValues = function() {};

/**
 * [Method] Returns an array of functions each of which returns the value of the yField corresponding to function s index in the
 * @return {!Array<?>} Array array of accessor functions
 */
Ext.chart.series.ICartesian.prototype.getYValueAccessors = function() {};

/**
 * [Method] Returns the number of yField values taking into account fields combined via legend drag drop
 * @return {number} Number
 */
Ext.chart.series.ICartesian.prototype.getYValueCount = function() {};
/**
 * @extends {Ext.chart.series.ISeries}
 * @record
 * @struct
 */
Ext.chart.ICartesianSeries = function() {};
 /** @type {?} */
Ext.chart.ICartesianSeries.prototype.axis;
 /** @type {string} */
Ext.chart.ICartesianSeries.prototype.xField;
 /** @type {?} */
Ext.chart.ICartesianSeries.prototype.yField;

/**
 * [Method] Iterates over a given record s values for each of this series s yFields executing a given function for each value
 * @param {!Ext.data.IModel=} record Ext.data.Model
 * @param {?=} fn Function
 * @param {?=} scope Object
 * @return {void}
 */
Ext.chart.ICartesianSeries.prototype.eachYValue = function(record, fn, scope) {};

/**
 * [Method] Calculate the min and max values for this series s xField
 * @return {!Array<?>} Array [min, max]
 */
Ext.chart.ICartesianSeries.prototype.getMinMaxXValues = function() {};

/**
 * [Method] Calculate the min and max values for this series s yField s
 * @return {!Array<?>} Array [min, max]
 */
Ext.chart.ICartesianSeries.prototype.getMinMaxYValues = function() {};

/**
 * [Method] Returns an array of functions each of which returns the value of the yField corresponding to function s index in the
 * @return {!Array<?>} Array array of accessor functions
 */
Ext.chart.ICartesianSeries.prototype.getYValueAccessors = function() {};

/**
 * [Method] Returns the number of yField values taking into account fields combined via legend drag drop
 * @return {number} Number
 */
Ext.chart.ICartesianSeries.prototype.getYValueCount = function() {};
/**
 * @extends {Ext.chart.series.ISeries}
 * @record
 * @struct
 */
Ext.chart.ICartesianChart = function() {};
 /** @type {?} */
Ext.chart.ICartesianChart.prototype.axis;
 /** @type {string} */
Ext.chart.ICartesianChart.prototype.xField;
 /** @type {?} */
Ext.chart.ICartesianChart.prototype.yField;

/**
 * [Method] Iterates over a given record s values for each of this series s yFields executing a given function for each value
 * @param {!Ext.data.IModel=} record Ext.data.Model
 * @param {?=} fn Function
 * @param {?=} scope Object
 * @return {void}
 */
Ext.chart.ICartesianChart.prototype.eachYValue = function(record, fn, scope) {};

/**
 * [Method] Calculate the min and max values for this series s xField
 * @return {!Array<?>} Array [min, max]
 */
Ext.chart.ICartesianChart.prototype.getMinMaxXValues = function() {};

/**
 * [Method] Calculate the min and max values for this series s yField s
 * @return {!Array<?>} Array [min, max]
 */
Ext.chart.ICartesianChart.prototype.getMinMaxYValues = function() {};

/**
 * [Method] Returns an array of functions each of which returns the value of the yField corresponding to function s index in the
 * @return {!Array<?>} Array array of accessor functions
 */
Ext.chart.ICartesianChart.prototype.getYValueAccessors = function() {};

/**
 * [Method] Returns the number of yField values taking into account fields combined via legend drag drop
 * @return {number} Number
 */
Ext.chart.ICartesianChart.prototype.getYValueCount = function() {};
/**
 * @extends {Ext.chart.series.IBar}
 * @record
 * @struct
 */
Ext.chart.series.IColumn = function() {};
 /** @type {string} */
Ext.chart.series.IColumn.prototype.axis;
 /** @type {boolean} */
Ext.chart.series.IColumn.prototype.column;
 /** @type {string} */
Ext.chart.series.IColumn.prototype.type;
 /** @type {?} */
Ext.chart.series.IColumn.prototype.xPadding;
 /** @type {?} */
Ext.chart.series.IColumn.prototype.yPadding;
/**
 * @extends {Ext.chart.series.IBar}
 * @record
 * @struct
 */
Ext.chart.IColumnSeries = function() {};
 /** @type {string} */
Ext.chart.IColumnSeries.prototype.axis;
 /** @type {boolean} */
Ext.chart.IColumnSeries.prototype.column;
 /** @type {string} */
Ext.chart.IColumnSeries.prototype.type;
 /** @type {?} */
Ext.chart.IColumnSeries.prototype.xPadding;
 /** @type {?} */
Ext.chart.IColumnSeries.prototype.yPadding;
/**
 * @extends {Ext.chart.series.IBar}
 * @record
 * @struct
 */
Ext.chart.IColumnChart = function() {};
 /** @type {string} */
Ext.chart.IColumnChart.prototype.axis;
 /** @type {boolean} */
Ext.chart.IColumnChart.prototype.column;
 /** @type {string} */
Ext.chart.IColumnChart.prototype.type;
 /** @type {?} */
Ext.chart.IColumnChart.prototype.xPadding;
 /** @type {?} */
Ext.chart.IColumnChart.prototype.yPadding;
/**
 * @extends {Ext.chart.series.IBar}
 * @record
 * @struct
 */
Ext.chart.IStackedColumnChart = function() {};
 /** @type {string} */
Ext.chart.IStackedColumnChart.prototype.axis;
 /** @type {boolean} */
Ext.chart.IStackedColumnChart.prototype.column;
 /** @type {string} */
Ext.chart.IStackedColumnChart.prototype.type;
 /** @type {?} */
Ext.chart.IStackedColumnChart.prototype.xPadding;
 /** @type {?} */
Ext.chart.IStackedColumnChart.prototype.yPadding;
/**
 * @extends {Ext.chart.series.ISeries}
 * @record
 * @struct
 */
Ext.chart.series.IGauge = function() {};
 /** @type {string} */
Ext.chart.series.IGauge.prototype.angleField;
 /** @type {?} */
Ext.chart.series.IGauge.prototype.donut;
 /** @type {number} */
Ext.chart.series.IGauge.prototype.highlightDuration;
 /** @type {boolean} */
Ext.chart.series.IGauge.prototype.needle;
 /** @type {boolean} */
Ext.chart.series.IGauge.prototype.showInLegend;
 /** @type {?} */
Ext.chart.series.IGauge.prototype.style;
 /** @type {string} */
Ext.chart.series.IGauge.prototype.type;

/**
 * [Method] Draws the series for the current chart
 * @return {void}
 */
Ext.chart.series.IGauge.prototype.drawSeries = function() {};

/**
 * [Method] Returns the color of the series to be displayed as color for the series legend item
 * @param {?=} item Object {Object} Info about the item; same format as returned by getItemForPoint
 * @return {void}
 */
Ext.chart.series.IGauge.prototype.getLegendColor = function(item) {};

/**
 * [Method] Sets the Gauge chart to the current specified value
 * @param {?=} value Object
 * @return {void}
 */
Ext.chart.series.IGauge.prototype.setValue = function(value) {};
/**
 * @extends {Ext.chart.series.ICartesian}
 * @record
 * @struct
 */
Ext.chart.series.ILine = function() {};
 /** @type {boolean} */
Ext.chart.series.ILine.prototype.fill;
 /** @type {?} */
Ext.chart.series.ILine.prototype.markerConfig;
 /** @type {number} */
Ext.chart.series.ILine.prototype.selectionTolerance;
 /** @type {boolean} */
Ext.chart.series.ILine.prototype.showMarkers;
 /** @type {?} */
Ext.chart.series.ILine.prototype.smooth;
 /** @type {?} */
Ext.chart.series.ILine.prototype.style;
 /** @type {string} */
Ext.chart.series.ILine.prototype.type;

/**
 * [Method] Draws the series for the current chart
 * @return {void}
 */
Ext.chart.series.ILine.prototype.drawSeries = function() {};
/**
 * @extends {Ext.chart.series.ICartesian}
 * @record
 * @struct
 */
Ext.chart.ILineSeries = function() {};
 /** @type {boolean} */
Ext.chart.ILineSeries.prototype.fill;
 /** @type {?} */
Ext.chart.ILineSeries.prototype.markerConfig;
 /** @type {number} */
Ext.chart.ILineSeries.prototype.selectionTolerance;
 /** @type {boolean} */
Ext.chart.ILineSeries.prototype.showMarkers;
 /** @type {?} */
Ext.chart.ILineSeries.prototype.smooth;
 /** @type {?} */
Ext.chart.ILineSeries.prototype.style;
 /** @type {string} */
Ext.chart.ILineSeries.prototype.type;

/**
 * [Method] Draws the series for the current chart
 * @return {void}
 */
Ext.chart.ILineSeries.prototype.drawSeries = function() {};
/**
 * @extends {Ext.chart.series.ICartesian}
 * @record
 * @struct
 */
Ext.chart.ILineChart = function() {};
 /** @type {boolean} */
Ext.chart.ILineChart.prototype.fill;
 /** @type {?} */
Ext.chart.ILineChart.prototype.markerConfig;
 /** @type {number} */
Ext.chart.ILineChart.prototype.selectionTolerance;
 /** @type {boolean} */
Ext.chart.ILineChart.prototype.showMarkers;
 /** @type {?} */
Ext.chart.ILineChart.prototype.smooth;
 /** @type {?} */
Ext.chart.ILineChart.prototype.style;
 /** @type {string} */
Ext.chart.ILineChart.prototype.type;

/**
 * [Method] Draws the series for the current chart
 * @return {void}
 */
Ext.chart.ILineChart.prototype.drawSeries = function() {};
/**
 * @extends {Ext.chart.series.ISeries}
 * @record
 * @struct
 */
Ext.chart.series.IPie = function() {};
 /** @type {string} */
Ext.chart.series.IPie.prototype.angleField;
 /** @type {!Array<?>} */
Ext.chart.series.IPie.prototype.colorSet;
 /** @type {?} */
Ext.chart.series.IPie.prototype.donut;
 /** @type {string} */
Ext.chart.series.IPie.prototype.field;
 /** @type {number} */
Ext.chart.series.IPie.prototype.highlightDuration;
 /** @type {string} */
Ext.chart.series.IPie.prototype.lengthField;
 /** @type {boolean} */
Ext.chart.series.IPie.prototype.showInLegend;
 /** @type {?} */
Ext.chart.series.IPie.prototype.style;
 /** @type {string} */
Ext.chart.series.IPie.prototype.type;
 /** @type {string} */
Ext.chart.series.IPie.prototype.xField;

/**
 * [Method] Draws the series for the current chart
 * @return {void}
 */
Ext.chart.series.IPie.prototype.drawSeries = function() {};

/**
 * [Method] Returns the color of the series to be displayed as color for the series legend item
 * @param {?=} item Object {Object} Info about the item; same format as returned by getItemForPoint
 * @return {void}
 */
Ext.chart.series.IPie.prototype.getLegendColor = function(item) {};

/**
 * [Method] Highlight the specified item
 * @param {?=} item Object {Object} Info about the item; same format as returned by getItemForPoint
 * @return {void}
 */
Ext.chart.series.IPie.prototype.highlightItem = function(item) {};

/**
 * [Method] Un highlights the specified item
 * @param {?=} item Object {Object} Info about the item; same format as returned by getItemForPoint
 * @return {void}
 */
Ext.chart.series.IPie.prototype.unHighlightItem = function(item) {};
/**
 * @extends {Ext.chart.series.ISeries}
 * @record
 * @struct
 */
Ext.chart.IPieSeries = function() {};
 /** @type {string} */
Ext.chart.IPieSeries.prototype.angleField;
 /** @type {!Array<?>} */
Ext.chart.IPieSeries.prototype.colorSet;
 /** @type {?} */
Ext.chart.IPieSeries.prototype.donut;
 /** @type {string} */
Ext.chart.IPieSeries.prototype.field;
 /** @type {number} */
Ext.chart.IPieSeries.prototype.highlightDuration;
 /** @type {string} */
Ext.chart.IPieSeries.prototype.lengthField;
 /** @type {boolean} */
Ext.chart.IPieSeries.prototype.showInLegend;
 /** @type {?} */
Ext.chart.IPieSeries.prototype.style;
 /** @type {string} */
Ext.chart.IPieSeries.prototype.type;
 /** @type {string} */
Ext.chart.IPieSeries.prototype.xField;

/**
 * [Method] Draws the series for the current chart
 * @return {void}
 */
Ext.chart.IPieSeries.prototype.drawSeries = function() {};

/**
 * [Method] Returns the color of the series to be displayed as color for the series legend item
 * @param {?=} item Object {Object} Info about the item; same format as returned by getItemForPoint
 * @return {void}
 */
Ext.chart.IPieSeries.prototype.getLegendColor = function(item) {};

/**
 * [Method] Highlight the specified item
 * @param {?=} item Object {Object} Info about the item; same format as returned by getItemForPoint
 * @return {void}
 */
Ext.chart.IPieSeries.prototype.highlightItem = function(item) {};

/**
 * [Method] Un highlights the specified item
 * @param {?=} item Object {Object} Info about the item; same format as returned by getItemForPoint
 * @return {void}
 */
Ext.chart.IPieSeries.prototype.unHighlightItem = function(item) {};
/**
 * @extends {Ext.chart.series.ISeries}
 * @record
 * @struct
 */
Ext.chart.IPieChart = function() {};
 /** @type {string} */
Ext.chart.IPieChart.prototype.angleField;
 /** @type {!Array<?>} */
Ext.chart.IPieChart.prototype.colorSet;
 /** @type {?} */
Ext.chart.IPieChart.prototype.donut;
 /** @type {string} */
Ext.chart.IPieChart.prototype.field;
 /** @type {number} */
Ext.chart.IPieChart.prototype.highlightDuration;
 /** @type {string} */
Ext.chart.IPieChart.prototype.lengthField;
 /** @type {boolean} */
Ext.chart.IPieChart.prototype.showInLegend;
 /** @type {?} */
Ext.chart.IPieChart.prototype.style;
 /** @type {string} */
Ext.chart.IPieChart.prototype.type;
 /** @type {string} */
Ext.chart.IPieChart.prototype.xField;

/**
 * [Method] Draws the series for the current chart
 * @return {void}
 */
Ext.chart.IPieChart.prototype.drawSeries = function() {};

/**
 * [Method] Returns the color of the series to be displayed as color for the series legend item
 * @param {?=} item Object {Object} Info about the item; same format as returned by getItemForPoint
 * @return {void}
 */
Ext.chart.IPieChart.prototype.getLegendColor = function(item) {};

/**
 * [Method] Highlight the specified item
 * @param {?=} item Object {Object} Info about the item; same format as returned by getItemForPoint
 * @return {void}
 */
Ext.chart.IPieChart.prototype.highlightItem = function(item) {};

/**
 * [Method] Un highlights the specified item
 * @param {?=} item Object {Object} Info about the item; same format as returned by getItemForPoint
 * @return {void}
 */
Ext.chart.IPieChart.prototype.unHighlightItem = function(item) {};
/**
 * @extends {Ext.chart.series.ISeries}
 * @record
 * @struct
 */
Ext.chart.series.IRadar = function() {};
 /** @type {?} */
Ext.chart.series.IRadar.prototype.markerConfig;
 /** @type {boolean} */
Ext.chart.series.IRadar.prototype.showInLegend;
 /** @type {boolean} */
Ext.chart.series.IRadar.prototype.showMarkers;
 /** @type {?} */
Ext.chart.series.IRadar.prototype.style;
 /** @type {string} */
Ext.chart.series.IRadar.prototype.type;
 /** @type {string} */
Ext.chart.series.IRadar.prototype.xField;
 /** @type {string} */
Ext.chart.series.IRadar.prototype.yField;

/**
 * [Method] Draws the series for the current chart
 * @return {void}
 */
Ext.chart.series.IRadar.prototype.drawSeries = function() {};
/**
 * @extends {Ext.chart.series.ICartesian}
 * @record
 * @struct
 */
Ext.chart.series.IScatter = function() {};
 /** @type {?} */
Ext.chart.series.IScatter.prototype.markerConfig;
 /** @type {?} */
Ext.chart.series.IScatter.prototype.style;
 /** @type {string} */
Ext.chart.series.IScatter.prototype.type;

/**
 * [Method] Draws the series for the current chart
 * @return {void}
 */
Ext.chart.series.IScatter.prototype.drawSeries = function() {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @extends {Ext.chart.ILabel}
 * @extends {Ext.chart.IHighlight}
 * @extends {Ext.chart.ITip}
 * @extends {Ext.chart.ICallout}
 * @record
 * @struct
 */
Ext.chart.series.ISeries = function() {};
 /** @type {?} */
Ext.chart.series.ISeries.prototype.highlight;
 /** @type {?} */
Ext.chart.series.ISeries.prototype.listeners;
 /** @type {?} */
Ext.chart.series.ISeries.prototype.renderer;
 /** @type {!Array<?>} */
Ext.chart.series.ISeries.prototype.shadowAttributes;
 /** @type {boolean} */
Ext.chart.series.ISeries.prototype.showInLegend;
 /** @type {?} */
Ext.chart.series.ISeries.prototype.tips;
 /** @type {string} */
Ext.chart.series.ISeries.prototype.title;
 /** @type {string} */
Ext.chart.series.ISeries.prototype.type;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.chart.series.ISeries.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.chart.series.ISeries.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.clearManagedListeners = function() {};

/**
 * [Method] Iterate over each of the records for this series
 * @param {?=} fn Function The function to execute for each record.
 * @param {?=} scope Object Scope for the fn.
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.eachRecord = function(fn, scope) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.chart.series.ISeries.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.chart.series.ISeries.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] For a given x y point relative to the Surface find a corresponding item from this series if any
 * @param {number=} x Number
 * @param {number=} y Number
 * @return {?} Object An object describing the item, or null if there is no matching item. The exact contents of this object will vary by series type, but should always contain the following:
 */
Ext.chart.series.ISeries.prototype.getItemForPoint = function(x, y) {};

/**
 * [Method] Returns a string with the color to be used for the series legend item
 * @param {?=} index Object
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.getLegendColor = function(index) {};

/**
 * [Method] Return the number of records being displayed in this series
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.getRecordCount = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.chart.series.ISeries.prototype.hasListener = function(eventName) {};

/**
 * [Method] Hides all the elements in the series
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.hideAll = function() {};

/**
 * [Method] Highlight the given series item
 * @param {?=} item Object Info about the item; same format as returned by #getItemForPoint.
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.highlightItem = function(item) {};

/**
 * [Method] Determines whether the series item at the given index has been excluded i e
 * @param {?=} index Object
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.isExcluded = function(index) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.chart.series.ISeries.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.chart.series.ISeries.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Called each time a new label is created
 * @param {!Ext.data.IModel=} storeItem Ext.data.Model The element of the store that is related to the sprite.
 * @param {?=} item Object The item related to the sprite. An item is an object containing the position of the shape used to describe the visualization and also pointing to the actual shape (circle, rectangle, path, etc).
 * @param {number=} i Number The index of the element created (i.e the first created label, second created label, etc).
 * @param {string=} display String The label.display type. May be false if the label is hidden
 * @return {!Ext.draw.ISprite} Ext.draw.Sprite The created sprite that will draw the label.
 */
Ext.chart.series.ISeries.prototype.onCreateLabel = function(storeItem, item, i, display) {};

/**
 * [Method] Called for updating the position of the label
 * @param {!Ext.draw.ISprite=} label Ext.draw.Sprite The sprite that draws the label.
 * @param {!Ext.data.IModel=} storeItem Ext.data.Model The element of the store that is related to the sprite.
 * @param {?=} item Object The item related to the sprite. An item is an object containing the position of the shape used to describe the visualization and also pointing to the actual shape (circle, rectangle, path, etc).
 * @param {number=} i Number The index of the element to be updated (i.e. whether it is the first, second, third from the labelGroup)
 * @param {string=} display String The label.display type. May be false if the label is hidden
 * @param {boolean=} animate Boolean A boolean value to set or unset animations for the labels.
 * @param {number=} index Number The series index.
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.onPlaceLabel = function(label, storeItem, item, i, display, animate, index) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.chart.series.ISeries.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.resumeEvents = function() {};

/**
 * [Method] Changes the value of the title for the series
 * @param {number=} index Number
 * @param {string=} title String
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.setTitle = function(index, title) {};

/**
 * [Method] Shows all the elements in the series
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.showAll = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.un = function(eventName, fn, scope) {};

/**
 * [Method] Un highlight any existing highlights
 * @return {void}
 */
Ext.chart.series.ISeries.prototype.unHighlightItem = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.chart.IShape = function() {};
/**
 * @constructor
 * @struct
 */
Ext.chart.Shape = function() {};
 /** @type {!Ext.IClass} */
Ext.chart.Shape.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.chart.Shape.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.chart.Shape.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.chart.Shape.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.chart.Shape.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.chart.Shape.initConfig = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.chart.Shape.statics = function() {};
/** @const */
Ext.chart.theme = {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.chart.theme.IBase = function() {};
/**
 * @record
 * @struct
 */
Ext.chart.theme.ITheme = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.chart.ITip = function() {};
/**
 * @extends {Ext.draw.IComponent}
 * @record
 * @struct
 */
Ext.chart.ITipSurface = function() {};
/**
 * @record
 * @struct
 */
Ext.IClass = function() {};
 /** @type {!Array<string>} */
Ext.IClass.prototype.alias;
 /** @type {?} */
Ext.IClass.prototype.alternateClassName;
 /** @type {?} */
Ext.IClass.prototype.config;
 /** @type {string} */
Ext.IClass.prototype.extend;
 /** @type {?} */
Ext.IClass.prototype.inheritableStatics;
 /** @type {?} */
Ext.IClass.prototype.mixins;
 /** @type {!Array<string>} */
Ext.IClass.prototype.requires;
 /** @type {boolean} */
Ext.IClass.prototype.singleton;
 /** @type {?} */
Ext.IClass.prototype.statics;
 /** @type {!Array<string>} */
Ext.IClass.prototype.uses;
/**
 * @record
 * @struct
 */
Ext.IClassManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.ClassManager = function() {};

/**
 * [Method] Adds a batch of class name to alias mappings
 * @param {?=} aliases Object The set of mappings of the form className : [values...]
 * @return {!Ext.IClassManager} Ext.ClassManager this
 */
Ext.ClassManager.addNameAliasMappings = function(aliases) {};

/**
 * [Method]
 * @param {?=} alternates Object The set of mappings of the form className : [values...]
 * @return {!Ext.IClassManager} Ext.ClassManager this
 */
Ext.ClassManager.addNameAlternateMappings = function(alternates) {};

/**
 * [Method] Defines a class
 * @param {?=} className Object
 * @param {?=} data Object
 * @param {?=} createdFn Object
 * @return {void}
 */
Ext.ClassManager.create = function(className, data, createdFn) {};

/**
 * [Method] Retrieve a class by its name
 * @param {string=} name String
 * @return {!Ext.IClass} Ext.Class class
 */
Ext.ClassManager.get = function(name) {};

/**
 * [Method] Get the aliases of a class by the class name
 * @param {string=} name String
 * @return {!Array<?>} Array aliases
 */
Ext.ClassManager.getAliasesByName = function(name) {};

/**
 * [Method] Get a reference to the class by its alias
 * @param {string=} alias String
 * @return {!Ext.IClass} Ext.Class class
 */
Ext.ClassManager.getByAlias = function(alias) {};

/**
 * [Method] Get the class of the provided object returns null if it s not an instance of any class created with Ext define
 * @param {?=} object Object
 * @return {!Ext.IClass} Ext.Class class
 */
Ext.ClassManager.getClass = function(object) {};

/**
 * [Method] Returns the displayName property or className or object
 * @param {?=} object Object
 * @return {string} String
 */
Ext.ClassManager.getDisplayName = function(object) {};

/**
 * [Method] Get the name of the class by its reference or its instance  getName is usually invoked by the shorthand Ext getClass
 * @param {?=} object Ext.Class/Object
 * @return {string} String className
 */
Ext.ClassManager.getName = function(object) {};

/**
 * [Method] Get the name of a class by its alias
 * @param {string=} alias String
 * @return {string} String className
 */
Ext.ClassManager.getNameByAlias = function(alias) {};

/**
 * [Method] Get the name of a class by its alternate name
 * @param {string=} alternate String
 * @return {string} String className
 */
Ext.ClassManager.getNameByAlternate = function(alternate) {};

/**
 * [Method] Converts a string expression to an array of matching class names
 * @param {string=} expression String
 * @return {!Array<string>} String[] classNames
 */
Ext.ClassManager.getNamesByExpression = function(expression) {};

/**
 * [Method] Instantiate a class by its alias
 * @param {string} alias String
 * @param {...?} args Object... Additional arguments after the alias will be passed to the class constructor.
 * @return {?} Object instance
 */
Ext.ClassManager.instantiateByAlias = function(alias, args) {};

/**
 * [Method] Checks if a class has already been created
 * @param {string=} className String
 * @return {boolean} Boolean exist
 */
Ext.ClassManager.isCreated = function(className) {};

/**
 * [Method] Sets a name reference to a class
 * @param {string=} name String
 * @param {?=} value Object
 * @return {!Ext.IClassManager} Ext.ClassManager this
 */
Ext.ClassManager.set = function(name, value) {};

/**
 * [Method] Register the alias for a class
 * @param {?=} cls Ext.Class/String a reference to a class or a className
 * @param {string=} alias String Alias to use when referring to this class
 * @return {!Ext.IClassManager} Ext.ClassManager this
 */
Ext.ClassManager.setAlias = function(cls, alias) {};

/**
 * [Method] Creates a namespace and assign the value to the created object Ext ClassManager setNamespace MyCompany pkg Example
 * @param {string=} name String
 * @param {?=} value Object
 * @return {void}
 */
Ext.ClassManager.setNamespace = function(name, value) {};
/**
 * @extends {Ext.IAbstractComponent}
 * @extends {Ext.util.IFloating}
 * @record
 * @struct
 */
Ext.IComponent = function() {};
 /** @type {boolean} */
Ext.IComponent.prototype.autoScroll;
 /** @type {?} */
Ext.IComponent.prototype.columnWidth;
 /** @type {?} */
Ext.IComponent.prototype.constrainTo;
 /** @type {?} */
Ext.IComponent.prototype.constraintInsets;
 /** @type {string} */
Ext.IComponent.prototype.defaultAlign;
 /** @type {boolean} */
Ext.IComponent.prototype.floating;
 /** @type {boolean} */
Ext.IComponent.prototype.formBind;
 /** @type {string} */
Ext.IComponent.prototype.overflowX;
 /** @type {string} */
Ext.IComponent.prototype.overflowY;
 /** @type {?} */
Ext.IComponent.prototype.region;
 /** @type {?} */
Ext.IComponent.prototype.resizable;
 /** @type {string} */
Ext.IComponent.prototype.resizeHandles;
 /** @type {boolean} */
Ext.IComponent.prototype.toFrontOnShow;
 /** @type {!Ext.IContainer} */
Ext.IComponent.prototype.floatParent;
 /** @type {?} */
Ext.IComponent.prototype.scrollFlags;
 /** @type {!Ext.IZIndexManager} */
Ext.IComponent.prototype.zIndexManager;
 /** @type {!Ext.IContainer} */
Ext.IComponent.prototype.zIndexParent;

/**
 * [Method] Called by the layout system after the Component has been laid out
 * @return {void}
 */
Ext.IComponent.prototype.afterComponentLayout = function() {};

/**
 * [Method] Invoked after the Component has been hidden
 * @param {?=} callback Function
 * @param {?=} scope Object
 * @return {void}
 */
Ext.IComponent.prototype.afterHide = function(callback, scope) {};

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.IComponent.prototype.afterRender = function() {};

/**
 * [Method] Template method called after a Component has been positioned
 * @param {?=} ax Object
 * @param {?=} ay Object
 * @return {void}
 */
Ext.IComponent.prototype.afterSetPosition = function(ax, ay) {};

/**
 * [Method] Invoked after the Component is shown after onShow is called
 * @param {?=} animateTarget String/Ext.Element
 * @param {?=} callback Function
 * @param {?=} scope Object
 * @return {void}
 */
Ext.IComponent.prototype.afterShow = function(animateTarget, callback, scope) {};

/**
 * [Method] Occurs before componentLayout is run
 * @return {void}
 */
Ext.IComponent.prototype.beforeLayout = function() {};

/**
 * [Method] Invoked before the Component is shown
 * @return {void}
 */
Ext.IComponent.prototype.beforeShow = function() {};

/**
 * [Method] Bubbles up the component container heirarchy calling the specified function with each component
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope of the function. Defaults to current node.
 * @param {!Array<?>=} args Array The args to call the function with. Defaults to passing the current component.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IComponent.prototype.bubble = function(fn, scope, args) {};

/**
 * [Method] Cancel any deferred focus on this component
 * @return {void}
 */
Ext.IComponent.prototype.cancelFocus = function() {};

/**
 * [Method] Center this Component in its container
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IComponent.prototype.center = function() {};

/**
 * [Method] Clone the current component using the original config values passed into this instance by default
 * @param {?=} overrides Object A new config containing any properties to override in the cloned version. An id property can be passed on this object, otherwise one will be generated to avoid duplicates.
 * @return {!Ext.IComponent} Ext.Component clone The cloned copy of this component
 */
Ext.IComponent.prototype.cloneConfig = function(overrides) {};

/**
 * [Method] Moves this floating Component into a constrain region
 * @param {?=} constrainTo String/HTMLElement/Ext.Element/Ext.util.Region The Element or Region into which this Component is to be constrained. Defaults to the element into which this floating Component was rendered.
 * @return {void}
 */
Ext.IComponent.prototype.doConstrain = function(constrainTo) {};

/**
 * [Method] Find a container above this component at any level by a custom function
 * @param {?=} fn Function The custom function to call with the arguments (container, this component).
 * @return {!Ext.container.IContainer} Ext.container.Container The first Container for which the custom function returns true
 */
Ext.IComponent.prototype.findParentBy = function(fn) {};

/**
 * [Method] Find a container above this component at any level by xtype or class See also the up method
 * @param {?=} xtype String/Ext.Class The xtype string for a component, or the class of the component directly
 * @return {!Ext.container.IContainer} Ext.container.Container The first Container which matches the given xtype or class
 */
Ext.IComponent.prototype.findParentByType = function(xtype) {};

/**
 * [Method] Try to focus this component
 * @param {boolean=} selectText Boolean If applicable, true to also select the text in this component
 * @param {?=} delay Boolean/Number Delay the focus this number of milliseconds (true for 10 milliseconds).
 * @param {?=} callback Function Only needed if the delay parameter is used. A function to call upon focus.
 * @param {?=} scope Function Only needed if the delay parameter is used. The scope (this reference) in which to execute the callback.
 * @return {!Ext.IComponent} Ext.Component The focused Component. Usually this Component. Some Containers may delegate focus to a descendant Component (Windows can do this through their defaultFocus config option.
 */
Ext.IComponent.prototype.focus = function(selectText, delay, callback, scope) {};

/**
 * [Method] Retrieves the top level element representing this component
 * @return {!Ext.dom.IElement} Ext.dom.Element
 */
Ext.IComponent.prototype.getEl = function() {};

/**
 * [Method] Retrieves the id of this component
 * @return {string} String
 */
Ext.IComponent.prototype.getId = function() {};

/**
 * [Method] Gets the current XY position of the component s underlying element
 * @param {boolean=} local Boolean If true the element's left and top are returned instead of page XY.
 * @return {!Array<number>} Number[] The XY position of the element (e.g., [100, 200])
 */
Ext.IComponent.prototype.getPosition = function(local) {};

/**
 * [Method] Gets the xtype for this component as registered with Ext ComponentManager
 * @return {string} String The xtype
 */
Ext.IComponent.prototype.getXType = function() {};

/**
 * [Method] Hides this Component setting it to invisible using the configured hideMode
 * @param {?=} animateTarget String/Ext.Element/Ext.Component only valid for floating Components such as Windows or ToolTips, or regular Components which have been configured with floating: true.. The target to which the Component should animate while hiding.
 * @param {?=} callback Function A callback function to call after the Component is hidden.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed. Defaults to this Component.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IComponent.prototype.hide = function(animateTarget, callback, scope) {};

/**
 * [Method] The initComponent template method is an important initialization step for a Component
 * @return {void}
 */
Ext.IComponent.prototype.initComponent = function() {};

/**
 * [Method] Method to manage awareness of when components are added to their respective Container firing an added event
 * @return {void}
 */
Ext.IComponent.prototype.onAdded = function() {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.IComponent.prototype.onDestroy = function() {};

/**
 * [Method] Possibly animates down to a target element
 * @param {?=} animateTarget String/Ext.Element/Ext.Component
 * @param {?=} callback Function
 * @param {?=} scope Object
 * @return {void}
 */
Ext.IComponent.prototype.onHide = function(animateTarget, callback, scope) {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @param {?=} animateTarget String/Ext.Element
 * @param {?=} callback Function
 * @param {?=} scope Object
 * @return {void}
 */
Ext.IComponent.prototype.onShow = function(animateTarget, callback, scope) {};

/**
 * [Method] Invoked after the afterShow method is complete
 * @param {?=} callback Function
 * @param {?=} scope Object
 * @return {void}
 */
Ext.IComponent.prototype.onShowComplete = function(callback, scope) {};

/**
 * [Method] Scrolls this Component s target element by the passed delta values optionally animating
 * @param {?=} deltaX Number/Number[]/Object Either the x delta, an Array specifying x and y deltas or an object with "x" and "y" properties.
 * @param {?=} deltaY Number/Boolean/Object Either the y delta, or an animate flag or config object.
 * @param {?=} animate Boolean/Object Animate flag/config object if the delta values were passed separately.
 * @return {void}
 */
Ext.IComponent.prototype.scrollBy = function(deltaX, deltaY, animate) {};

/**
 * [Method] This method is called internally by Ext ZIndexManager to signal that a floating Component has either been moved to th
 * @param {boolean=} active Boolean True to activate the Component, false to deactivate it.
 * @param {!Ext.IComponent=} newActive Ext.Component The newly active Component which is taking over topmost zIndex position.
 * @return {void}
 */
Ext.IComponent.prototype.setActive = function(active, newActive) {};

/**
 * [Method] Sets the overflow on the content element of the component
 * @param {boolean=} scroll Boolean True to allow the Component to auto scroll.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IComponent.prototype.setAutoScroll = function(scroll) {};

/**
 * [Method] This method changes the region config property for this border region
 * @param {string=} region String The new region value ("north", "south", "east" or "west").
 * @return {string} String The previous value of the region property.
 */
Ext.IComponent.prototype.setBorderRegion = function(region) {};

/**
 * [Method] This method allows you to show or hide a LoadMask on top of this component
 * @param {?=} load Boolean/Object/String True to show the default LoadMask, a config object that will be passed to the LoadMask constructor, or a message String to show. False to hide the current LoadMask.
 * @param {boolean=} targetEl Boolean True to mask the targetEl of this Component instead of the this.el. For example, setting this to true on a Panel will cause only the body to be masked.
 * @return {!Ext.ILoadMask} Ext.LoadMask The LoadMask instance that has just been shown.
 */
Ext.IComponent.prototype.setLoading = function(load, targetEl) {};

/**
 * [Method] Sets the overflow x y on the content element of the component
 * @param {string=} overflowX String The overflow-x value.
 * @param {string=} overflowY String The overflow-y value.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IComponent.prototype.setOverflowXY = function(overflowX, overflowY) {};

/**
 * [Method] Sets the page XY position of the component
 * @param {?=} x Number/Number[] The new x position or an array of [x,y].
 * @param {number=} y Number The new y position.
 * @param {?=} animate Boolean/Object True to animate the Component into its new position. You may also pass an animation configuration.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IComponent.prototype.setPagePosition = function(x, y, animate) {};

/**
 * [Method] Sets the left and top of the component
 * @param {?=} x Number/Number[]/Object The new left, an array of [x,y], or animation config object containing x and y properties.
 * @param {number=} y Number The new top.
 * @param {?=} animate Boolean/Object If true, the Component is animated into its new position. You may also pass an animation configuration.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IComponent.prototype.setPosition = function(x, y, animate) {};

/**
 * [Method] Sets the weight config property for this component
 * @param {number=} weight Number The new weight value.
 * @return {number} Number The previous value of the weight property.
 */
Ext.IComponent.prototype.setRegionWeight = function(weight) {};

/**
 * [Method] Shows this Component rendering it first if autoRender or floating are true
 * @param {?=} animateTarget String/Ext.Element only valid for floating Components such as Windows or ToolTips, or regular Components which have been configured with floating: true. The target from which the Component should animate from while opening.
 * @param {?=} callback Function A callback function to call after the Component is displayed. Only necessary if animation was specified.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed. Defaults to this Component.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IComponent.prototype.show = function(animateTarget, callback, scope) {};

/**
 * [Method] Displays component at specific xy position
 * @param {?=} x Number/Number[] The new x position or array of [x,y].
 * @param {number=} y Number The new y position
 * @param {?=} animate Boolean/Object True to animate the Component into its new position. You may also pass an animation configuration.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IComponent.prototype.showAt = function(x, y, animate) {};

/**
 * [Method] Shows this component by the specified Component or Element
 * @param {?=} component Ext.Component/Ext.dom.Element The Ext.Component or Ext.Element to show the component by.
 * @param {string=} position String Alignment position as used by Ext.util.Positionable.getAlignToXY. Defaults to defaultAlign.
 * @param {!Array<number>=} offsets Number[] Alignment offsets as used by Ext.util.Positionable.getAlignToXY.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IComponent.prototype.showBy = function(component, position, offsets) {};

/**
 * [Method] Sends this Component to the back of lower z index than any other visible windows
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IComponent.prototype.toBack = function() {};

/**
 * [Method] Brings this floating Component to the front of any other visible floating Components managed by the same ZIndexManag
 * @param {boolean=} preventFocus Boolean Specify true to prevent the Component from being focused.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IComponent.prototype.toFront = function(preventFocus) {};

/**
 * [Method] Sets the current box measurements of the component s underlying element
 * @param {?=} box Object An object in the format {x, y, width, height}
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.IComponent.prototype.updateBox = function(box) {};
/**
 * @extends {Ext.IElementLoader}
 * @record
 * @struct
 */
Ext.IComponentLoader = function() {};
 /** @type {?} */
Ext.IComponentLoader.prototype.loadMask;
 /** @type {boolean} */
Ext.IComponentLoader.prototype.scripts;
 /** @type {?} */
Ext.IComponentLoader.prototype.target;

/**
 * [Method] Set a Ext Component as the target of this loader
 * @param {?=} target String/Ext.Component The component to be the target of this loader. If a string is passed it will be looked up via its id.
 * @return {void}
 */
Ext.IComponentLoader.prototype.setTarget = function(target) {};
/**
 * @extends {Ext.IAbstractManager}
 * @record
 * @struct
 */
Ext.IComponentManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.ComponentManager = function() {};
 /** @type {!Ext.util.IHashMap} */
Ext.ComponentManager.all;
 /** @type {!Ext.IClass} */
Ext.ComponentManager.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.ComponentManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.ComponentManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.ComponentManager.callSuper = function(args) {};

/**
 * [Method] Creates a new Component from the specified config object using the config object s xtype to determine the class to in
 * @param {?=} config Object A configuration object for the Component you wish to create.
 * @param {string=} defaultType String The xtype to use if the config object does not contain a xtype. (Optional if the config contains a xtype).
 * @return {!Ext.IComponent} Ext.Component The newly instantiated Component.
 */
Ext.ComponentManager.create = function(config, defaultType) {};

/**
 * [Method] Executes the specified function once for each item in the collection
 * @param {?=} fn Function The function to execute.
 * @param {?=} scope Object The scope to execute in. Defaults to this.
 * @return {void}
 */
Ext.ComponentManager.each = function(fn, scope) {};

/**
 * [Method] Returns an item by id
 * @param {string=} id String The id of the item
 * @return {?} Object The item, undefined if not found.
 */
Ext.ComponentManager.get = function(id) {};

/**
 * [Method] Gets the number of items in the collection
 * @return {number} Number The number of items in the collection.
 */
Ext.ComponentManager.getCount = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.ComponentManager.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.ComponentManager.initConfig = function(config) {};

/**
 * [Method] Checks if an item type is registered
 * @param {string=} type String The mnemonic string by which the class may be looked up
 * @return {boolean} Boolean Whether the type is registered.
 */
Ext.ComponentManager.isRegistered = function(type) {};

/**
 * [Method] Registers a function that will be called when an item with the specified id is added to the manager
 * @param {string=} id String The item id
 * @param {?=} fn Function The callback function. Called with a single parameter, the item.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed. Defaults to the item.
 * @return {void}
 */
Ext.ComponentManager.onAvailable = function(id, fn, scope) {};

/**
 * [Method] Registers an item to be managed
 * @param {?=} item Object The item to register
 * @return {void}
 */
Ext.ComponentManager.register = function(item) {};

/**
 * [Method] Registers a new item constructor keyed by a type key
 * @param {?=} type Object
 * @param {?=} cls Object
 * @return {void}
 */
Ext.ComponentManager.registerType = function(type, cls) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.ComponentManager.statics = function() {};

/**
 * [Method] Unregisters an item by removing it from this manager
 * @param {?=} item Object The item to unregister
 * @return {void}
 */
Ext.ComponentManager.unregister = function(item) {};
/**
 * @extends {Ext.IAbstractManager}
 * @record
 * @struct
 */
Ext.IComponentMgr = function() {};
/**
 * @constructor
 * @struct
 */
Ext.ComponentMgr = function() {};
 /** @type {!Ext.util.IHashMap} */
Ext.ComponentMgr.all;
 /** @type {!Ext.IClass} */
Ext.ComponentMgr.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.ComponentMgr.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.ComponentMgr.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.ComponentMgr.callSuper = function(args) {};

/**
 * [Method] Creates a new Component from the specified config object using the config object s xtype to determine the class to in
 * @param {?=} config Object A configuration object for the Component you wish to create.
 * @param {string=} defaultType String The xtype to use if the config object does not contain a xtype. (Optional if the config contains a xtype).
 * @return {!Ext.IComponent} Ext.Component The newly instantiated Component.
 */
Ext.ComponentMgr.create = function(config, defaultType) {};

/**
 * [Method] Executes the specified function once for each item in the collection
 * @param {?=} fn Function The function to execute.
 * @param {?=} scope Object The scope to execute in. Defaults to this.
 * @return {void}
 */
Ext.ComponentMgr.each = function(fn, scope) {};

/**
 * [Method] Returns an item by id
 * @param {string=} id String The id of the item
 * @return {?} Object The item, undefined if not found.
 */
Ext.ComponentMgr.get = function(id) {};

/**
 * [Method] Gets the number of items in the collection
 * @return {number} Number The number of items in the collection.
 */
Ext.ComponentMgr.getCount = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.ComponentMgr.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.ComponentMgr.initConfig = function(config) {};

/**
 * [Method] Checks if an item type is registered
 * @param {string=} type String The mnemonic string by which the class may be looked up
 * @return {boolean} Boolean Whether the type is registered.
 */
Ext.ComponentMgr.isRegistered = function(type) {};

/**
 * [Method] Registers a function that will be called when an item with the specified id is added to the manager
 * @param {string=} id String The item id
 * @param {?=} fn Function The callback function. Called with a single parameter, the item.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed. Defaults to the item.
 * @return {void}
 */
Ext.ComponentMgr.onAvailable = function(id, fn, scope) {};

/**
 * [Method] Registers an item to be managed
 * @param {?=} item Object The item to register
 * @return {void}
 */
Ext.ComponentMgr.register = function(item) {};

/**
 * [Method] Registers a new item constructor keyed by a type key
 * @param {?=} type Object
 * @param {?=} cls Object
 * @return {void}
 */
Ext.ComponentMgr.registerType = function(type, cls) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.ComponentMgr.statics = function() {};

/**
 * [Method] Unregisters an item by removing it from this manager
 * @param {?=} item Object The item to unregister
 * @return {void}
 */
Ext.ComponentMgr.unregister = function(item) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IComponentQuery = function() {};
/**
 * @constructor
 * @struct
 */
Ext.ComponentQuery = function() {};
 /** @type {!Ext.IClass} */
Ext.ComponentQuery.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.ComponentQuery.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.ComponentQuery.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.ComponentQuery.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.ComponentQuery.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.ComponentQuery.initConfig = function(config) {};

/**
 * [Method] Tests whether the passed Component matches the selector string
 * @param {!Ext.IComponent=} component Ext.Component The Component to test
 * @param {string=} selector String The selector string to test against.
 * @return {boolean} Boolean True if the Component matches the selector.
 */
Ext.ComponentQuery.is = function(component, selector) {};

/**
 * [Method] Returns an array of matched Components from within the passed root object
 * @param {string=} selector String The selector string to filter returned Components
 * @param {!Ext.container.IContainer=} root Ext.container.Container The Container within which to perform the query. If omitted, all Components within the document are included in the search. This parameter may also be an array of Components to filter according to the selector.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] The matched Components.
 */
Ext.ComponentQuery.query = function(selector, root) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.ComponentQuery.statics = function() {};
/** @const */
Ext.container = {};
/**
 * @extends {Ext.IComponent}
 * @extends {Ext.IQueryable}
 * @record
 * @struct
 */
Ext.container.IAbstractContainer = function() {};
 /** @type {?} */
Ext.container.IAbstractContainer.prototype.activeItem;
 /** @type {boolean} */
Ext.container.IAbstractContainer.prototype.autoDestroy;
 /** @type {string} */
Ext.container.IAbstractContainer.prototype.baseCls;
 /** @type {!Array<string>} */
Ext.container.IAbstractContainer.prototype.bubbleEvents;
 /** @type {string} */
Ext.container.IAbstractContainer.prototype.defaultType;
 /** @type {?} */
Ext.container.IAbstractContainer.prototype.defaults;
 /** @type {boolean} */
Ext.container.IAbstractContainer.prototype.detachOnRemove;
 /** @type {?} */
Ext.container.IAbstractContainer.prototype.items;
 /** @type {?} */
Ext.container.IAbstractContainer.prototype.layout;
 /** @type {?} */
Ext.container.IAbstractContainer.prototype.renderTpl;
 /** @type {boolean} */
Ext.container.IAbstractContainer.prototype.suspendLayout;

/**
 * [Method] Adds Component s to this Container
 * @param {?=} component Ext.Component[]|Object[]/Ext.Component.../Object... Either one or more Components to add or an Array of Components to add. See items for additional information.
 * @return {?} Ext.Component[]/Ext.Component The Components that were added.
 */
Ext.container.IAbstractContainer.prototype.add = function(component) {};

/**
 * [Method] Called by the layout system after the Component has been laid out
 * @return {void}
 */
Ext.container.IAbstractContainer.prototype.afterComponentLayout = function() {};

/**
 * [Method] Invoked after the Container has laid out and rendered if necessary its child Components
 * @param {!Ext.layout.container.IContainer=} layout Ext.layout.container.Container
 * @return {void}
 */
Ext.container.IAbstractContainer.prototype.afterLayout = function(layout) {};

/**
 * [Method] Cascades down the component container heirarchy from this component passed in the first call  calling the specified
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope of the function (defaults to current component)
 * @param {!Array<?>=} args Array The args to call the function with. The current component always passed as the last argument.
 * @return {!Ext.IContainer} Ext.Container this
 */
Ext.container.IAbstractContainer.prototype.cascade = function(fn, scope, args) {};

/**
 * [Method] Retrieves the first direct child of this container which matches the passed selector or component
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching child Ext.Component (or null if no match was found).
 */
Ext.container.IAbstractContainer.prototype.child = function(selector) {};

/**
 * [Method] Determines whether the passed Component is either an immediate child of this Container or whether it is a descendant
 * @param {!Ext.IComponent=} comp Ext.Component The Component to test.
 * @param {boolean=} deep Boolean Pass true to test for the Component being a descendant at any level.
 * @return {boolean} Boolean true if the passed Component is contained at the specified level.
 */
Ext.container.IAbstractContainer.prototype.contains = function(comp, deep) {};

/**
 * [Method] Inherit docs Disable all immediate children that was previously disabled Override disable because onDisable only gets
 * @return {!Ext.container.IAbstractContainer} Ext.container.AbstractContainer this
 */
Ext.container.IAbstractContainer.prototype.disable = function() {};

/**
 * [Method] Manually force this container s layout to be recalculated
 * @return {!Ext.container.IContainer} Ext.container.Container this
 */
Ext.container.IAbstractContainer.prototype.doLayout = function() {};

/**
 * [Method] Retrieves the first descendant of this container which matches the passed selector
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector or Ext.Component. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching descendant Ext.Component (or null if no match was found).
 */
Ext.container.IAbstractContainer.prototype.down = function(selector) {};

/**
 * [Method] Examines this container s items property and gets a direct child component of this container
 * @param {?=} comp String/Number This parameter may be any of the following:  a String : representing the itemId or id of the child component. a Number : representing the position of the child component within the items property For additional information see Ext.util.MixedCollection.get.
 * @return {!Ext.IComponent} Ext.Component The component (if found).
 */
Ext.container.IAbstractContainer.prototype.getComponent = function(comp) {};

/**
 * [Method] Returns the layout instance currently associated with this Container
 * @return {!Ext.layout.container.IContainer} Ext.layout.container.Container The layout
 */
Ext.container.IAbstractContainer.prototype.getLayout = function() {};

/**
 * [Method] Used by ComponentQuery child and down to retrieve all of the items which can potentially be considered a child of th
 * @param {?=} deep Object
 * @return {void}
 */
Ext.container.IAbstractContainer.prototype.getRefItems = function(deep) {};

/**
 * [Method] Inserts a Component into this Container at a specified index
 * @param {number=} index Number The index at which the Component will be inserted into the Container's items collection
 * @param {?=} component Ext.Component/Object The child Component to insert. Ext uses lazy rendering, and will only render the inserted Component should it become necessary. A Component config object may be passed in order to avoid the overhead of constructing a real Component object if lazy rendering might mean that the inserted Component will not be rendered immediately. To take advantage of this 'lazy instantiation', set the Ext.Component.xtype config property to the registered type of the Component wanted. For a list of all available xtypes, see Ext.enums.Widget.
 * @return {!Ext.IComponent} Ext.Component component The Component (or config object) that was inserted with the Container's default config values applied.
 */
Ext.container.IAbstractContainer.prototype.insert = function(index, component) {};

/**
 * [Method] Determines whether this Container is an ancestor of the passed Component
 * @param {!Ext.IComponent=} possibleDescendant Ext.Component The Component to test for presence within this Container's subtree.
 * @return {void}
 */
Ext.container.IAbstractContainer.prototype.isAncestor = function(possibleDescendant) {};

/**
 * [Method] Moves a Component within the Container
 * @param {?=} fromIdx Number/Ext.Component The index/component to move.
 * @param {number=} toIdx Number The new index for the Component.
 * @return {!Ext.IComponent} Ext.Component component The Component that was moved.
 */
Ext.container.IAbstractContainer.prototype.move = function(fromIdx, toIdx) {};

/**
 * [Method] This method is invoked after a new Component has been added
 * @param {!Ext.IComponent=} component Ext.Component
 * @param {number=} position Number
 * @return {void}
 */
Ext.container.IAbstractContainer.prototype.onAdd = function(component, position) {};

/**
 * [Method] This method is invoked before adding a new child Component
 * @param {!Ext.IComponent=} item Ext.Component
 * @return {void}
 */
Ext.container.IAbstractContainer.prototype.onBeforeAdd = function(item) {};

/**
 * [Method] Called after the component is moved this method is empty by default but can be implemented by any subclass that need
 * @return {void}
 */
Ext.container.IAbstractContainer.prototype.onPosition = function() {};

/**
 * [Method] This method is invoked after a new Component has been removed
 * @param {!Ext.IComponent=} component Ext.Component
 * @param {boolean=} autoDestroy Boolean
 * @return {void}
 */
Ext.container.IAbstractContainer.prototype.onRemove = function(component, autoDestroy) {};

/**
 * [Method] Allows addition of behavior to the resize operation
 * @return {void}
 */
Ext.container.IAbstractContainer.prototype.onResize = function() {};

/**
 * [Method] Retrieves all descendant components which match the passed selector
 * @param {string=} selector String Selector complying to an Ext.ComponentQuery selector. If no selector is specified all items will be returned.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components which matched the selector
 */
Ext.container.IAbstractContainer.prototype.query = function(selector) {};

/**
 * [Method] Retrieves all descendant components which match the passed function
 * @param {?=} fn Function The matcher function. It will be called with a single argument, the component being tested.
 * @param {?=} scope Object The scope in which to run the function. If not specified, it will default to the active component.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components matched by the passed function
 */
Ext.container.IAbstractContainer.prototype.queryBy = function(fn, scope) {};

/**
 * [Method] Finds a component at any level under this container matching the id itemId
 * @param {string=} id String The id to find
 * @return {!Ext.IComponent} Ext.Component The matching id, null if not found
 */
Ext.container.IAbstractContainer.prototype.queryById = function(id) {};

/**
 * [Method] Removes a component from this container
 * @param {?=} component Ext.Component/String The component reference or id to remove.
 * @param {boolean=} autoDestroy Boolean True to automatically invoke the removed Component's Ext.Component.destroy function. Defaults to the value of this Container's autoDestroy config.
 * @return {!Ext.IComponent} Ext.Component component The Component that was removed.
 */
Ext.container.IAbstractContainer.prototype.remove = function(component, autoDestroy) {};

/**
 * [Method] Removes all components from this container
 * @param {boolean=} autoDestroy Boolean True to automatically invoke the removed Component's Ext.Component.destroy function. Defaults to the value of this Container's autoDestroy config.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Array of the removed components
 */
Ext.container.IAbstractContainer.prototype.removeAll = function(autoDestroy) {};
/**
 * @extends {Ext.panel.IPanel}
 * @record
 * @struct
 */
Ext.container.IButtonGroup = function() {};
 /** @type {string} */
Ext.container.IButtonGroup.prototype.baseCls;
 /** @type {number} */
Ext.container.IButtonGroup.prototype.columns;
 /** @type {string} */
Ext.container.IButtonGroup.prototype.defaultButtonUI;
 /** @type {string} */
Ext.container.IButtonGroup.prototype.defaultType;
 /** @type {boolean} */
Ext.container.IButtonGroup.prototype.frame;
 /** @type {?} */
Ext.container.IButtonGroup.prototype.layout;
 /** @type {string} */
Ext.container.IButtonGroup.prototype.titleAlign;

/**
 * [Method] private
 * @param {?=} component Object
 * @return {void}
 */
Ext.container.IButtonGroup.prototype.onBeforeAdd = function(component) {};
/**
 * @extends {Ext.panel.IPanel}
 * @record
 * @struct
 */
Ext.IButtonGroup = function() {};
 /** @type {string} */
Ext.IButtonGroup.prototype.baseCls;
 /** @type {number} */
Ext.IButtonGroup.prototype.columns;
 /** @type {string} */
Ext.IButtonGroup.prototype.defaultButtonUI;
 /** @type {string} */
Ext.IButtonGroup.prototype.defaultType;
 /** @type {boolean} */
Ext.IButtonGroup.prototype.frame;
 /** @type {?} */
Ext.IButtonGroup.prototype.layout;
 /** @type {string} */
Ext.IButtonGroup.prototype.titleAlign;

/**
 * [Method] private
 * @param {?=} component Object
 * @return {void}
 */
Ext.IButtonGroup.prototype.onBeforeAdd = function(component) {};
/**
 * @extends {Ext.container.IAbstractContainer}
 * @record
 * @struct
 */
Ext.container.IContainer = function() {};
 /** @type {?} */
Ext.container.IContainer.prototype.anchorSize;

/**
 * [Method] Return the immediate child Component in which the passed element is located
 * @param {?=} el Ext.Element/HTMLElement/String The element to test (or ID of element).
 * @param {boolean=} deep Boolean If true, returns the deepest descendant Component which contains the passed element.
 * @return {!Ext.IComponent} Ext.Component The child item which contains the passed element.
 */
Ext.container.IContainer.prototype.getChildByElement = function(el, deep) {};
/**
 * @extends {Ext.container.IAbstractContainer}
 * @record
 * @struct
 */
Ext.IContainer = function() {};
 /** @type {?} */
Ext.IContainer.prototype.anchorSize;

/**
 * [Method] Return the immediate child Component in which the passed element is located
 * @param {?=} el Ext.Element/HTMLElement/String The element to test (or ID of element).
 * @param {boolean=} deep Boolean If true, returns the deepest descendant Component which contains the passed element.
 * @return {!Ext.IComponent} Ext.Component The child item which contains the passed element.
 */
Ext.IContainer.prototype.getChildByElement = function(el, deep) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.container.IDockingContainer = function() {};
 /** @type {?} */
Ext.container.IDockingContainer.prototype.defaultDockWeights;

/**
 * [Method] Adds docked item s to the container
 * @param {?=} component Object/Object[] The Component or array of components to add. The components must include a 'dock' parameter on each component to indicate where it should be docked ('top', 'right', 'bottom', 'left').
 * @param {number=} pos Number The index at which the Component will be added
 * @return {!Array<!Ext.IComponent>} Ext.Component[] The added components.
 */
Ext.container.IDockingContainer.prototype.addDocked = function(component, pos) {};

/**
 * [Method] Finds a docked component by id itemId or position
 * @param {?=} comp String/Number The id, itemId or position of the docked component (see getComponent for details)
 * @return {!Ext.IComponent} Ext.Component The docked component (if found)
 */
Ext.container.IDockingContainer.prototype.getDockedComponent = function(comp) {};

/**
 * [Method] Retrieves an array of all currently docked Components
 * @param {string=} selector String A ComponentQuery selector string to filter the returned items.
 * @param {boolean=} beforeBody Boolean An optional flag to limit the set of items to only those before the body (true) or after the body (false). All components are returned by default.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] The array of docked components meeting the specified criteria.
 */
Ext.container.IDockingContainer.prototype.getDockedItems = function(selector, beforeBody) {};

/**
 * [Method] Inserts docked item s to the panel at the indicated position
 * @param {number=} pos Number The index at which the Component will be inserted
 * @param {?=} component Object/Object[] The Component or array of components to add. The components must include a 'dock' paramater on each component to indicate where it should be docked ('top', 'right', 'bottom', 'left').
 * @return {void}
 */
Ext.container.IDockingContainer.prototype.insertDocked = function(pos, component) {};

/**
 * [Method] Invoked after a docked item is added to the Panel
 * @param {!Ext.IComponent=} component Ext.Component
 * @return {void}
 */
Ext.container.IDockingContainer.prototype.onDockedAdd = function(component) {};

/**
 * [Method] Invoked after a docked item is removed from the Panel
 * @param {!Ext.IComponent=} component Ext.Component
 * @return {void}
 */
Ext.container.IDockingContainer.prototype.onDockedRemove = function(component) {};

/**
 * [Method] Removes the docked item from the panel
 * @param {!Ext.IComponent=} item Ext.Component The Component to remove.
 * @param {boolean=} autoDestroy Boolean Destroy the component after removal.
 * @return {void}
 */
Ext.container.IDockingContainer.prototype.removeDocked = function(item, autoDestroy) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.container.IMonitor = function() {};
/**
 * @extends {Ext.container.IContainer}
 * @record
 * @struct
 */
Ext.container.IViewport = function() {};
 /** @type {boolean} */
Ext.container.IViewport.prototype.isViewport;

/**
 * [Method] Template method called when this Component s DOM structure is created
 * @return {void}
 */
Ext.container.IViewport.prototype.onRender = function() {};
/**
 * @extends {Ext.container.IContainer}
 * @record
 * @struct
 */
Ext.IViewport = function() {};
 /** @type {boolean} */
Ext.IViewport.prototype.isViewport;

/**
 * [Method] Template method called when this Component s DOM structure is created
 * @return {void}
 */
Ext.IViewport.prototype.onRender = function() {};
/** @const */
Ext.data = {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @extends {Ext.util.ISortable}
 * @record
 * @struct
 */
Ext.data.IAbstractStore = function() {};
 /** @type {?} */
Ext.data.IAbstractStore.prototype.autoLoad;
 /** @type {boolean} */
Ext.data.IAbstractStore.prototype.autoSync;
 /** @type {string} */
Ext.data.IAbstractStore.prototype.batchUpdateMode;
 /** @type {!Array<?>} */
Ext.data.IAbstractStore.prototype.fields;
 /** @type {boolean} */
Ext.data.IAbstractStore.prototype.filterOnLoad;
 /** @type {?} */
Ext.data.IAbstractStore.prototype.filters;
 /** @type {string} */
Ext.data.IAbstractStore.prototype.model;
 /** @type {?} */
Ext.data.IAbstractStore.prototype.proxy;
 /** @type {boolean} */
Ext.data.IAbstractStore.prototype.remoteFilter;
 /** @type {boolean} */
Ext.data.IAbstractStore.prototype.remoteSort;
 /** @type {boolean} */
Ext.data.IAbstractStore.prototype.sortOnLoad;
 /** @type {boolean} */
Ext.data.IAbstractStore.prototype.statefulFilters;
 /** @type {string} */
Ext.data.IAbstractStore.prototype.storeId;
 /** @type {string} */
Ext.data.IAbstractStore.prototype.defaultProxyType;
 /** @type {boolean} */
Ext.data.IAbstractStore.prototype.isDestroyed;
 /** @type {boolean} */
Ext.data.IAbstractStore.prototype.isStore;
 /** @type {!Array<!Ext.data.IModel>} */
Ext.data.IAbstractStore.prototype.removed;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IAbstractStore.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IAbstractStore.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IAbstractStore.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IAbstractStore.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns a comparator function which compares two items and returns 1 0 or 1 depending on the currently defined set
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.generateComparator = function() {};

/**
 * [Method] Gets the first sorter from the sorters collection excluding any groupers that may be in place
 * @return {!Ext.util.ISorter} Ext.util.Sorter The sorter, null if none exist
 */
Ext.data.IAbstractStore.prototype.getFirstSorter = function() {};

/**
 * [Method] Gets all records added or updated since the last commit
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] The added and updated Model instances
 */
Ext.data.IAbstractStore.prototype.getModifiedRecords = function() {};

/**
 * [Method] Returns all Model instances that are either currently a phantom e g
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] The Model instances
 */
Ext.data.IAbstractStore.prototype.getNewRecords = function() {};

/**
 * [Method] Returns the proxy currently attached to this proxy instance
 * @return {!Ext.data.proxy.IProxy} Ext.data.proxy.Proxy The Proxy instance
 */
Ext.data.IAbstractStore.prototype.getProxy = function() {};

/**
 * [Method] Returns any records that have been removed from the store but not yet destroyed on the proxy
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] The removed Model instances
 */
Ext.data.IAbstractStore.prototype.getRemovedRecords = function() {};

/**
 * [Method] Returns all Model instances that have been updated in the Store but not yet synchronized with the Proxy
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] The updated Model instances
 */
Ext.data.IAbstractStore.prototype.getUpdatedRecords = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.data.IAbstractStore.prototype.hasListener = function(eventName) {};

/**
 * [Method] Performs initialization of this mixin
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.initSortable = function() {};

/**
 * [Method] Returns true if the Store is currently performing a load operation
 * @return {boolean} Boolean True if the Store is currently loading
 */
Ext.data.IAbstractStore.prototype.isLoading = function() {};

/**
 * [Method] Loads the Store using its configured proxy
 * @param {?=} options Object config object. This is passed into the Operation object that is created and then sent to the proxy's Ext.data.proxy.Proxy.read function
 * @return {void} void this
 */
Ext.data.IAbstractStore.prototype.load = function(options) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IAbstractStore.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IAbstractStore.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.data.IAbstractStore.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Reloads the store using the last options passed to the load method
 * @param {?=} options Object A config object which contains options which may override the options passed to the previous load call.
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.reload = function(options) {};

/**
 * [Method] Removes all records from the store
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.removeAll = function() {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes automatically syncing the Store with its Proxy
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.resumeAutoSync = function() {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.resumeEvents = function() {};

/**
 * [Method] Saves all pending changes via the configured proxy
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.save = function() {};

/**
 * [Method] Sets the Store s Proxy by string config object or Proxy instance
 * @param {?=} proxy String/Object/Ext.data.proxy.Proxy The new Proxy, which can be either a type string, a configuration object or an Ext.data.proxy.Proxy instance
 * @return {!Ext.data.proxy.IProxy} Ext.data.proxy.Proxy The attached Proxy object
 */
Ext.data.IAbstractStore.prototype.setProxy = function(proxy) {};

/**
 * [Method] Sorts the data in the Store by one or more of its properties
 * @param {?=} sorters String/Ext.util.Sorter[] Either a string name of one of the fields in this Store's configured Model, or an array of sorter configurations.
 * @param {string=} direction String The overall direction to sort the data by.
 * @return {!Array<!Ext.util.ISorter>} Ext.util.Sorter[]
 */
Ext.data.IAbstractStore.prototype.sort = function(sorters, direction) {};

/**
 * [Method] Suspends automatically syncing the Store with its Proxy
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.suspendAutoSync = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Synchronizes the store with its proxy
 * @param {?=} options Object Object containing one or more properties supported by the sync method (these get passed along to the underlying proxy's batch method):
 * @return {!Ext.data.IStore} Ext.data.Store this
 */
Ext.data.IAbstractStore.prototype.sync = function(options) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IAbstractStore.prototype.un = function(eventName, fn, scope) {};
/**
 * @constructor
 * @struct
 */
Ext.data.AbstractStore = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.data.AbstractStore.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.data.AbstractStore.addStatics = function(members) {};

/**
 * [Method] Creates a store from config object
 * @param {?=} store Object/Ext.data.AbstractStore A config for the store to be created. It may contain a type field which defines the particular type of store to create. Alteratively passing an actual store to this method will just return it, no changes made.
 * @return {!Ext.data.IAbstractStore} Ext.data.AbstractStore The created store.
 */
Ext.data.AbstractStore.create = function(store) {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.data.AbstractStore.createAlias = function(alias, origin) {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.data.AbstractStore.getName = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.data.AbstractStore.implement = function() {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.data.AbstractStore.override = function(members) {};
/**
 * @extends {Ext.data.IStore}
 * @record
 * @struct
 */
Ext.data.IArrayStore = function() {};

/**
 * [Method] Loads an array of data straight into the Store
 * @param {?=} data Object
 * @param {?=} append Object
 * @return {void}
 */
Ext.data.IArrayStore.prototype.loadData = function(data, append) {};
/** @const */
Ext.data.association = {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.association.IAssociation = function() {};
 /** @type {string} */
Ext.data.association.IAssociation.prototype.associatedModel;
 /** @type {string} */
Ext.data.association.IAssociation.prototype.associationKey;
 /** @type {string} */
Ext.data.association.IAssociation.prototype.model;
 /** @type {string} */
Ext.data.association.IAssociation.prototype.ownerModel;
 /** @type {string} */
Ext.data.association.IAssociation.prototype.primaryKey;
 /** @type {!Ext.data.reader.IReader} */
Ext.data.association.IAssociation.prototype.reader;
 /** @type {string} */
Ext.data.association.IAssociation.prototype.associatedName;
 /** @type {string} */
Ext.data.association.IAssociation.prototype.ownerName;

/**
 * [Method] Get a specialized reader for reading associated data
 * @return {!Ext.data.reader.IReader} Ext.data.reader.Reader The reader, null if not supplied
 */
Ext.data.association.IAssociation.prototype.getReader = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.IAssociation = function() {};
 /** @type {string} */
Ext.data.IAssociation.prototype.associatedModel;
 /** @type {string} */
Ext.data.IAssociation.prototype.associationKey;
 /** @type {string} */
Ext.data.IAssociation.prototype.model;
 /** @type {string} */
Ext.data.IAssociation.prototype.ownerModel;
 /** @type {string} */
Ext.data.IAssociation.prototype.primaryKey;
 /** @type {!Ext.data.reader.IReader} */
Ext.data.IAssociation.prototype.reader;
 /** @type {string} */
Ext.data.IAssociation.prototype.associatedName;
 /** @type {string} */
Ext.data.IAssociation.prototype.ownerName;

/**
 * [Method] Get a specialized reader for reading associated data
 * @return {!Ext.data.reader.IReader} Ext.data.reader.Reader The reader, null if not supplied
 */
Ext.data.IAssociation.prototype.getReader = function() {};
/**
 * @extends {Ext.data.association.IAssociation}
 * @record
 * @struct
 */
Ext.data.association.IBelongsTo = function() {};
 /** @type {string} */
Ext.data.association.IBelongsTo.prototype.foreignKey;
 /** @type {string} */
Ext.data.association.IBelongsTo.prototype.getterName;
 /** @type {string} */
Ext.data.association.IBelongsTo.prototype.setterName;
 /** @type {string} */
Ext.data.association.IBelongsTo.prototype.type;
/**
 * @extends {Ext.data.association.IAssociation}
 * @record
 * @struct
 */
Ext.data.IBelongsToAssociation = function() {};
 /** @type {string} */
Ext.data.IBelongsToAssociation.prototype.foreignKey;
 /** @type {string} */
Ext.data.IBelongsToAssociation.prototype.getterName;
 /** @type {string} */
Ext.data.IBelongsToAssociation.prototype.setterName;
 /** @type {string} */
Ext.data.IBelongsToAssociation.prototype.type;
/**
 * @extends {Ext.data.association.IAssociation}
 * @record
 * @struct
 */
Ext.data.association.IHasMany = function() {};
 /** @type {boolean} */
Ext.data.association.IHasMany.prototype.autoLoad;
 /** @type {string} */
Ext.data.association.IHasMany.prototype.filterProperty;
 /** @type {string} */
Ext.data.association.IHasMany.prototype.foreignKey;
 /** @type {string} */
Ext.data.association.IHasMany.prototype.name;
 /** @type {?} */
Ext.data.association.IHasMany.prototype.storeConfig;
 /** @type {string} */
Ext.data.association.IHasMany.prototype.type;
/**
 * @extends {Ext.data.association.IAssociation}
 * @record
 * @struct
 */
Ext.data.IHasManyAssociation = function() {};
 /** @type {boolean} */
Ext.data.IHasManyAssociation.prototype.autoLoad;
 /** @type {string} */
Ext.data.IHasManyAssociation.prototype.filterProperty;
 /** @type {string} */
Ext.data.IHasManyAssociation.prototype.foreignKey;
 /** @type {string} */
Ext.data.IHasManyAssociation.prototype.name;
 /** @type {?} */
Ext.data.IHasManyAssociation.prototype.storeConfig;
 /** @type {string} */
Ext.data.IHasManyAssociation.prototype.type;
/**
 * @extends {Ext.data.association.IAssociation}
 * @record
 * @struct
 */
Ext.data.association.IHasOne = function() {};
 /** @type {string} */
Ext.data.association.IHasOne.prototype.foreignKey;
 /** @type {string} */
Ext.data.association.IHasOne.prototype.getterName;
 /** @type {string} */
Ext.data.association.IHasOne.prototype.setterName;
 /** @type {string} */
Ext.data.association.IHasOne.prototype.type;
/**
 * @extends {Ext.data.association.IAssociation}
 * @record
 * @struct
 */
Ext.data.IHasOneAssociation = function() {};
 /** @type {string} */
Ext.data.IHasOneAssociation.prototype.foreignKey;
 /** @type {string} */
Ext.data.IHasOneAssociation.prototype.getterName;
 /** @type {string} */
Ext.data.IHasOneAssociation.prototype.setterName;
 /** @type {string} */
Ext.data.IHasOneAssociation.prototype.type;
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.data.IBatch = function() {};
 /** @type {boolean} */
Ext.data.IBatch.prototype.autoStart;
 /** @type {boolean} */
Ext.data.IBatch.prototype.pauseOnException;
 /** @type {number} */
Ext.data.IBatch.prototype.current;
 /** @type {!Array<!Ext.data.IOperation>} */
Ext.data.IBatch.prototype.exceptions;
 /** @type {boolean} */
Ext.data.IBatch.prototype.hasException;
 /** @type {boolean} */
Ext.data.IBatch.prototype.isComplete;
 /** @type {boolean} */
Ext.data.IBatch.prototype.isRunning;
 /** @type {!Array<!Ext.data.IOperation>} */
Ext.data.IBatch.prototype.operations;
 /** @type {number} */
Ext.data.IBatch.prototype.total;

/**
 * [Method] Adds a new operation to this batch at the end of the operations array
 * @param {?=} operation Object The Operation object
 * @return {!Ext.data.IBatch} Ext.data.Batch this
 */
Ext.data.IBatch.prototype.add = function(operation) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.data.IBatch.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IBatch.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IBatch.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.data.IBatch.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.data.IBatch.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.data.IBatch.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IBatch.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IBatch.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.data.IBatch.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IBatch.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IBatch.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IBatch.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Pauses execution of the batch but does not cancel the current operation
 * @return {!Ext.data.IBatch} Ext.data.Batch this
 */
Ext.data.IBatch.prototype.pause = function() {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.data.IBatch.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IBatch.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IBatch.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.data.IBatch.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.data.IBatch.prototype.resumeEvents = function() {};

/**
 * [Method] Kicks off execution of the batch continuing from the current operation
 * @return {!Ext.data.IBatch} Ext.data.Batch this
 */
Ext.data.IBatch.prototype.retry = function() {};

/**
 * [Method] Executes an operation by its numeric index in the operations array
 * @param {number=} index Number The operation index to run
 * @return {!Ext.data.IBatch} Ext.data.Batch this
 */
Ext.data.IBatch.prototype.runOperation = function(index) {};

/**
 * [Method] Kicks off execution of the batch continuing from the next operation if the previous operation encountered an excepti
 * @param {?=} index Object
 * @return {!Ext.data.IBatch} Ext.data.Batch this
 */
Ext.data.IBatch.prototype.start = function(index) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.data.IBatch.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.data.IBatch.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IBatch.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.data.IStore}
 * @record
 * @struct
 */
Ext.data.IBufferStore = function() {};
 /** @type {boolean} */
Ext.data.IBufferStore.prototype.filterOnLoad;
 /** @type {boolean} */
Ext.data.IBufferStore.prototype.sortOnLoad;
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.data.IConnection = function() {};
 /** @type {boolean} */
Ext.data.IConnection.prototype.autoAbort;
 /** @type {boolean} */
Ext.data.IConnection.prototype.binary;
 /** @type {boolean} */
Ext.data.IConnection.prototype.cors;
 /** @type {?} */
Ext.data.IConnection.prototype.defaultHeaders;
 /** @type {boolean} */
Ext.data.IConnection.prototype.disableCaching;
 /** @type {string} */
Ext.data.IConnection.prototype.disableCachingParam;
 /** @type {?} */
Ext.data.IConnection.prototype.extraParams;
 /** @type {string} */
Ext.data.IConnection.prototype.method;
 /** @type {number} */
Ext.data.IConnection.prototype.timeout;
 /** @type {boolean} */
Ext.data.IConnection.prototype.withCredentials;

/**
 * [Method] Aborts an active request
 * @param {?=} request Object Defaults to the last request
 * @return {void}
 */
Ext.data.IConnection.prototype.abort = function(request) {};

/**
 * [Method] Aborts all active requests
 * @return {void}
 */
Ext.data.IConnection.prototype.abortAll = function() {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.data.IConnection.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IConnection.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IConnection.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.data.IConnection.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.data.IConnection.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.data.IConnection.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IConnection.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IConnection.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.data.IConnection.prototype.hasListener = function(eventName) {};

/**
 * [Method] Determines whether this object has a request outstanding
 * @param {?=} request Object Defaults to the last transaction
 * @return {boolean} Boolean True if there is an outstanding request.
 */
Ext.data.IConnection.prototype.isLoading = function(request) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IConnection.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IConnection.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IConnection.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Checks if the response status was successful
 * @param {number=} status Number The status code
 * @return {?} Object An object containing success/status state
 */
Ext.data.IConnection.prototype.parseStatus = function(status) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.data.IConnection.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IConnection.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IConnection.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Sends an HTTP request to a remote server
 * @param {?=} options Object An object which may contain the following properties: (The options object may also contain any other property which might be needed to perform postprocessing in a callback because it is passed to callback functions.)
 * @return {?} Object The request object. This may be used to cancel the request.
 */
Ext.data.IConnection.prototype.request = function(options) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.data.IConnection.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.data.IConnection.prototype.resumeEvents = function() {};

/**
 * [Method] Sets various options such as the url params for the request
 * @param {?=} options Object The initial options
 * @param {?=} scope Object The scope to execute in
 * @return {?} Object The params for the request
 */
Ext.data.IConnection.prototype.setOptions = function(options, scope) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.data.IConnection.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.data.IConnection.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IConnection.prototype.un = function(eventName, fn, scope) {};

/**
 * [Method] Uploads a form using a hidden iframe
 * @param {?=} form String/HTMLElement/Ext.Element The form to upload
 * @param {string=} url String The url to post to
 * @param {string=} params String Any extra parameters to pass
 * @param {?=} options Object The initial options
 * @return {void}
 */
Ext.data.IConnection.prototype.upload = function(form, url, params, options) {};
/**
 * @extends {Ext.data.IStore}
 * @record
 * @struct
 */
Ext.data.IDirectStore = function() {};
/**
 * @extends {Ext.util.IMixedCollection}
 * @record
 * @struct
 */
Ext.data.IErrors = function() {};

/**
 * [Method] Returns all of the errors for the given field
 * @param {string=} fieldName String The field to get errors for
 * @return {!Array<?>} Object[] All errors for the given field
 */
Ext.data.IErrors.prototype.getByField = function(fieldName) {};

/**
 * [Method] Returns true if there are no errors in the collection
 * @return {boolean} Boolean
 */
Ext.data.IErrors.prototype.isValid = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.IField = function() {};
 /** @type {?} */
Ext.data.IField.prototype.convert;
 /** @type {string} */
Ext.data.IField.prototype.dateFormat;
 /** @type {string} */
Ext.data.IField.prototype.dateReadFormat;
 /** @type {string} */
Ext.data.IField.prototype.dateWriteFormat;
 /** @type {?} */
Ext.data.IField.prototype.defaultValue;
 /** @type {?} */
Ext.data.IField.prototype.mapping;
 /** @type {string} */
Ext.data.IField.prototype.name;
 /** @type {boolean} */
Ext.data.IField.prototype.persist;
 /** @type {?} */
Ext.data.IField.prototype.serialize;
 /** @type {string} */
Ext.data.IField.prototype.sortDir;
 /** @type {?} */
Ext.data.IField.prototype.sortType;
 /** @type {?} */
Ext.data.IField.prototype.type;
 /** @type {boolean} */
Ext.data.IField.prototype.useNull;
/** @const */
Ext.data.flash = {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.flash.IBinaryXhr = function() {};
 /** @type {number} */
Ext.data.flash.IBinaryXhr.prototype.readyState;
 /** @type {!Array<?>} */
Ext.data.flash.IBinaryXhr.prototype.responseBytes;
 /** @type {number} */
Ext.data.flash.IBinaryXhr.prototype.status;
 /** @type {string} */
Ext.data.flash.IBinaryXhr.prototype.statusText;

/**
 * [Method] Abort this connection
 * @return {void}
 */
Ext.data.flash.IBinaryXhr.prototype.abort = function() {};

/**
 * [Method] As in XMLHttpRequest
 * @return {void}
 */
Ext.data.flash.IBinaryXhr.prototype.getAllResponseHeaders = function() {};

/**
 * [Method] As in XMLHttpRequest
 * @param {?=} header Object
 * @return {void}
 */
Ext.data.flash.IBinaryXhr.prototype.getResponseHeader = function(header) {};

/**
 * [Method] As in XMLHttpRequest
 * @return {void}
 */
Ext.data.flash.IBinaryXhr.prototype.onreadystatechange = function() {};

/**
 * [Method] As in XMLHttpRequest
 * @param {?=} method Object
 * @param {?=} url Object
 * @param {?=} async Object
 * @param {?=} user Object
 * @param {?=} password Object
 * @return {void}
 */
Ext.data.flash.IBinaryXhr.prototype.open = function(method, url, async, user, password) {};

/**
 * [Method] As in XMLHttpRequest
 * @param {?=} mimeType Object
 * @return {void}
 */
Ext.data.flash.IBinaryXhr.prototype.overrideMimeType = function(mimeType) {};

/**
 * [Method] Initiate the request
 * @param {!Array<?>=} body Array an array of byte values to send.
 * @return {void}
 */
Ext.data.flash.IBinaryXhr.prototype.send = function(body) {};

/**
 * [Method] As in XMLHttpRequest
 * @param {?=} header Object
 * @param {?=} value Object
 * @return {void}
 */
Ext.data.flash.IBinaryXhr.prototype.setRequestHeader = function(header, value) {};
/**
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.data.IGroup = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.IIdGenerator = function() {};
 /** @type {string} */
Ext.data.IIdGenerator.prototype.id;
 /** @type {boolean} */
Ext.data.IIdGenerator.prototype.isGenerator;

/**
 * [Method] Generates and returns the next id
 * @return {string} String The next id.
 */
Ext.data.IIdGenerator.prototype.generate = function() {};
/**
 * @constructor
 * @struct
 */
Ext.data.IdGenerator = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.data.IdGenerator.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.data.IdGenerator.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.data.IdGenerator.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.data.IdGenerator.createAlias = function(alias, origin) {};

/**
 * [Method] Returns the IdGenerator given its config description
 * @param {?=} config String/Object If this parameter is an IdGenerator instance, it is simply returned. If this is a string, it is first used as an id for lookup and then, if there is no match, as a type to create a new instance. This parameter can also be a config object that contains a type property (among others) that are used to create and configure the instance.
 * @return {void}
 */
Ext.data.IdGenerator.get = function(config) {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.data.IdGenerator.getName = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.data.IdGenerator.implement = function() {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.data.IdGenerator.override = function(members) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.IJsonP = function() {};
/**
 * @constructor
 * @struct
 */
Ext.data.JsonP = function() {};
 /** @type {string} */
Ext.data.JsonP.callbackKey;
 /** @type {boolean} */
Ext.data.JsonP.disableCaching;
 /** @type {string} */
Ext.data.JsonP.disableCachingParam;
 /** @type {!Ext.IClass} */
Ext.data.JsonP.self;
 /** @type {number} */
Ext.data.JsonP.timeout;

/**
 * [Method] Abort a request
 * @param {?=} request Object/String The request to abort
 * @return {void}
 */
Ext.data.JsonP.abort = function(request) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.data.JsonP.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.data.JsonP.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.data.JsonP.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.data.JsonP.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.data.JsonP.initConfig = function(config) {};

/**
 * [Method] Makes a JSONP request
 * @param {?=} options Object An object which may contain the following properties. Note that options will take priority over any defaults that are specified in the class.  url : String The URL to request. params : Object (Optional)An object containing a series of key value pairs that will be sent along with the request. timeout : Number (Optional) See timeout callbackKey : String (Optional) See callbackKey callbackName : String (Optional) The function name to use for this request. By default this name will be auto-generated: Ext.data.JsonP.callback1, Ext.data.JsonP.callback2, etc. Setting this option to "my_name" will force the function name to be Ext.data.JsonP.my_name. Use this if you want deterministic behavior, but be careful - the callbackName should be different in each JsonP request that you make. disableCaching : Boolean (Optional) See disableCaching disableCachingParam : String (Optional) See disableCachingParam success : Function (Optional) A function to execute if the request succeeds. failure : Function (Optional) A function to execute if the request fails. callback : Function (Optional) A function to execute when the request completes, whether it is a success or failure. scope : Object (Optional)The scope in which to execute the callbacks: The "this" object for the callback function. Defaults to the browser window.
 * @return {?} Object request An object containing the request details.
 */
Ext.data.JsonP.request = function(options) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.data.JsonP.statics = function() {};
/**
 * @extends {Ext.data.IStore}
 * @record
 * @struct
 */
Ext.data.IJsonPStore = function() {};
/**
 * @extends {Ext.data.IStore}
 * @record
 * @struct
 */
Ext.data.IJsonStore = function() {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.data.IModel = function() {};
 /** @type {!Array<?>} */
Ext.data.IModel.prototype.associations;
 /** @type {?} */
Ext.data.IModel.prototype.belongsTo;
 /** @type {string} */
Ext.data.IModel.prototype.clientIdProperty;
 /** @type {string} */
Ext.data.IModel.prototype.defaultProxyType;
 /** @type {?} */
Ext.data.IModel.prototype.fields;
 /** @type {?} */
Ext.data.IModel.prototype.hasMany;
 /** @type {?} */
Ext.data.IModel.prototype.idProperty;
 /** @type {?} */
Ext.data.IModel.prototype.idgen;
 /** @type {string} */
Ext.data.IModel.prototype.persistenceProperty;
 /** @type {?} */
Ext.data.IModel.prototype.proxy;
 /** @type {!Array<?>} */
Ext.data.IModel.prototype.validations;
 /** @type {boolean} */
Ext.data.IModel.prototype.dirty;
 /** @type {boolean} */
Ext.data.IModel.prototype.editing;
 /** @type {boolean} */
Ext.data.IModel.prototype.isModel;
 /** @type {?} */
Ext.data.IModel.prototype.modified;
 /** @type {boolean} */
Ext.data.IModel.prototype.phantom;
 /** @type {?} */
Ext.data.IModel.prototype.raw;
 /** @type {!Ext.data.IStore} */
Ext.data.IModel.prototype.store;
 /** @type {!Array<!Ext.data.IStore>} */
Ext.data.IModel.prototype.stores;
 /** @type {string} */
Ext.data.IModel.prototype.COMMIT;
 /** @type {string} */
Ext.data.IModel.prototype.EDIT;
 /** @type {string} */
Ext.data.IModel.prototype.REJECT;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.data.IModel.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IModel.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IModel.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Begins an edit
 * @return {void}
 */
Ext.data.IModel.prototype.beginEdit = function() {};

/**
 * [Method] Cancels all changes made in the current edit operation
 * @return {void}
 */
Ext.data.IModel.prototype.cancelEdit = function() {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.data.IModel.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.data.IModel.prototype.clearManagedListeners = function() {};

/**
 * [Method] Usually called by the Ext data Store which owns the model instance
 * @param {boolean=} silent Boolean Pass true to skip notification of the owning store of the change.
 * @param {!Array<string>=} modifiedFieldNames String[] Array of field names changed during sync with server if known. Omit or pass null if unknown. An empty array means that it is known that no fields were modified by the server's response. Defaults to false.
 * @return {void}
 */
Ext.data.IModel.prototype.commit = function(silent, modifiedFieldNames) {};

/**
 * [Method] Creates a copy clone of this Model instance
 * @param {string=} id String A new id, defaults to the id of the instance being copied. See id. To generate a phantom instance with a new id use: var rec = record.copy(); // clone the record Ext.data.Model.id(rec); // automatically generate a unique sequential id
 * @return {!Ext.data.IModel} Ext.data.Model
 */
Ext.data.IModel.prototype.copy = function(id) {};

/**
 * [Method] Destroys the model using the configured proxy
 * @param {?=} options Object Options to pass to the proxy. Config object for Ext.data.Operation.
 * @return {!Ext.data.IModel} Ext.data.Model The Model instance
 */
Ext.data.IModel.prototype.destroy = function(options) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.data.IModel.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Ends an edit
 * @param {boolean=} silent Boolean True to not notify the store of the change
 * @param {!Array<string>=} modifiedFieldNames String[] Array of field names changed during edit.
 * @return {void}
 */
Ext.data.IModel.prototype.endEdit = function(silent, modifiedFieldNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IModel.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IModel.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the value of the given field
 * @param {string=} fieldName String The field to fetch the value for
 * @return {?} Object The value
 */
Ext.data.IModel.prototype.get = function(fieldName) {};

/**
 * [Method] Gets all of the data from this Models loaded associations
 * @return {?} Object The nested data set for the Model's loaded associations
 */
Ext.data.IModel.prototype.getAssociatedData = function() {};

/**
 * [Method] Gets a hash of only the fields that have been modified since this Model was created or commited
 * @return {?} Object
 */
Ext.data.IModel.prototype.getChanges = function() {};

/**
 * [Method] Gets all values for each field in this model and returns an object containing the current data
 * @param {boolean=} includeAssociated Boolean True to also include associated data. Defaults to false.
 * @return {?} Object An object hash containing all the values in this model
 */
Ext.data.IModel.prototype.getData = function(includeAssociated) {};

/**
 * [Method] Returns the unique ID allocated to this model instance as defined by idProperty
 * @return {?} Number/String The id
 */
Ext.data.IModel.prototype.getId = function() {};

/**
 * [Method] Returns the configured Proxy for this Model
 * @return {!Ext.data.proxy.IProxy} Ext.data.proxy.Proxy The proxy
 */
Ext.data.IModel.prototype.getProxy = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.data.IModel.prototype.hasListener = function(eventName) {};

/**
 * [Method] Returns true if the passed field name has been modified since the load or last commit
 * @param {string=} fieldName String Ext.data.Field.name
 * @return {boolean} Boolean
 */
Ext.data.IModel.prototype.isModified = function(fieldName) {};

/**
 * [Method] Checks if the model is valid
 * @return {boolean} Boolean True if the model is valid.
 */
Ext.data.IModel.prototype.isValid = function() {};

/**
 * [Method] Tells this model instance that it has been added to a store
 * @param {!Ext.data.IStore=} store Ext.data.Store The store to which this model has been added.
 * @return {void}
 */
Ext.data.IModel.prototype.join = function(store) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IModel.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IModel.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IModel.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Usually called by the Ext data Store to which this model instance has been joined
 * @param {boolean=} silent Boolean True to skip notification of the owning store of the change. Defaults to false.
 * @return {void}
 */
Ext.data.IModel.prototype.reject = function(silent) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.data.IModel.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IModel.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IModel.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.data.IModel.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.data.IModel.prototype.resumeEvents = function() {};

/**
 * [Method] Saves the model instance using the configured proxy
 * @param {?=} options Object Options to pass to the proxy. Config object for Ext.data.Operation.
 * @return {!Ext.data.IModel} Ext.data.Model The Model instance
 */
Ext.data.IModel.prototype.save = function(options) {};

/**
 * [Method] Sets the given field to the given value marks the instance as dirty
 * @param {?=} fieldName String/Object The field to set, or an object containing key/value pairs
 * @param {?=} newValue Object The value to set
 * @return {!Array<string>} String[] The array of modified field names or null if nothing was modified.
 */
Ext.data.IModel.prototype.set = function(fieldName, newValue) {};

/**
 * [Method] Marks this Record as dirty
 * @return {void}
 */
Ext.data.IModel.prototype.setDirty = function() {};

/**
 * [Method] Sets the model instance s id field to the given id
 * @param {?=} id Number/String The new id
 * @return {void}
 */
Ext.data.IModel.prototype.setId = function(id) {};

/**
 * [Method] Sets the Proxy to use for this model
 * @param {?=} proxy String/Object/Ext.data.proxy.Proxy The proxy
 * @return {!Ext.data.proxy.IProxy} Ext.data.proxy.Proxy
 */
Ext.data.IModel.prototype.setProxy = function(proxy) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.data.IModel.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.data.IModel.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IModel.prototype.un = function(eventName, fn, scope) {};

/**
 * [Method] Tells this model instance that it has been removed from the store
 * @param {!Ext.data.IStore=} store Ext.data.Store The store from which this model has been removed.
 * @return {void}
 */
Ext.data.IModel.prototype.unjoin = function(store) {};

/**
 * [Method] Validates the current data against all of its configured validations
 * @return {!Ext.data.IErrors} Ext.data.Errors The errors object
 */
Ext.data.IModel.prototype.validate = function() {};
/**
 * @constructor
 * @struct
 */
Ext.data.Model = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.data.Model.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.data.Model.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.data.Model.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.data.Model.createAlias = function(alias, origin) {};

/**
 * [Method] Returns an Array of Field definitions which define this Model s structure Fields are sorted upon Model class definit
 * @return {!Array<!Ext.data.IField>} Ext.data.Field[] The defined Fields for this Model.
 */
Ext.data.Model.getFields = function() {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.data.Model.getName = function() {};

/**
 * [Method] Returns the configured Proxy for this Model
 * @return {!Ext.data.proxy.IProxy} Ext.data.proxy.Proxy The proxy
 */
Ext.data.Model.getProxy = function() {};

/**
 * [Method] Generates a sequential id
 * @param {!Ext.data.IModel=} rec Ext.data.Model The record being created. The record does not exist, it's a phantom.
 * @return {string} String auto-generated string id, "ext-record-i++";
 */
Ext.data.Model.id = function(rec) {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.data.Model.implement = function() {};

/**
 * [Method] Asynchronously loads a model instance by id
 * @param {?=} id Number/String The id of the model to load
 * @param {?=} config Object config object containing success, failure and callback functions, plus optional scope
 * @return {void}
 */
Ext.data.Model.load = function(id, config) {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.data.Model.override = function(members) {};

/**
 * [Method] Apply a new set of field and or property definitions to the existing model
 * @param {?=} fields Object
 * @param {?=} idProperty Object
 * @param {?=} clientIdProperty Object
 * @return {void}
 */
Ext.data.Model.setFields = function(fields, idProperty, clientIdProperty) {};

/**
 * [Method] Sets the Proxy to use for this model
 * @param {?=} proxy String/Object/Ext.data.proxy.Proxy The proxy
 * @return {!Ext.data.proxy.IProxy} Ext.data.proxy.Proxy
 */
Ext.data.Model.setProxy = function(proxy) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.data.IRecord = function() {};
 /** @type {!Array<?>} */
Ext.data.IRecord.prototype.associations;
 /** @type {?} */
Ext.data.IRecord.prototype.belongsTo;
 /** @type {string} */
Ext.data.IRecord.prototype.clientIdProperty;
 /** @type {string} */
Ext.data.IRecord.prototype.defaultProxyType;
 /** @type {?} */
Ext.data.IRecord.prototype.fields;
 /** @type {?} */
Ext.data.IRecord.prototype.hasMany;
 /** @type {?} */
Ext.data.IRecord.prototype.idProperty;
 /** @type {?} */
Ext.data.IRecord.prototype.idgen;
 /** @type {string} */
Ext.data.IRecord.prototype.persistenceProperty;
 /** @type {?} */
Ext.data.IRecord.prototype.proxy;
 /** @type {!Array<?>} */
Ext.data.IRecord.prototype.validations;
 /** @type {boolean} */
Ext.data.IRecord.prototype.dirty;
 /** @type {boolean} */
Ext.data.IRecord.prototype.editing;
 /** @type {boolean} */
Ext.data.IRecord.prototype.isModel;
 /** @type {?} */
Ext.data.IRecord.prototype.modified;
 /** @type {boolean} */
Ext.data.IRecord.prototype.phantom;
 /** @type {?} */
Ext.data.IRecord.prototype.raw;
 /** @type {!Ext.data.IStore} */
Ext.data.IRecord.prototype.store;
 /** @type {!Array<!Ext.data.IStore>} */
Ext.data.IRecord.prototype.stores;
 /** @type {string} */
Ext.data.IRecord.prototype.COMMIT;
 /** @type {string} */
Ext.data.IRecord.prototype.EDIT;
 /** @type {string} */
Ext.data.IRecord.prototype.REJECT;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.data.IRecord.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IRecord.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IRecord.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Begins an edit
 * @return {void}
 */
Ext.data.IRecord.prototype.beginEdit = function() {};

/**
 * [Method] Cancels all changes made in the current edit operation
 * @return {void}
 */
Ext.data.IRecord.prototype.cancelEdit = function() {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.data.IRecord.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.data.IRecord.prototype.clearManagedListeners = function() {};

/**
 * [Method] Usually called by the Ext data Store which owns the model instance
 * @param {boolean=} silent Boolean Pass true to skip notification of the owning store of the change.
 * @param {!Array<string>=} modifiedFieldNames String[] Array of field names changed during sync with server if known. Omit or pass null if unknown. An empty array means that it is known that no fields were modified by the server's response. Defaults to false.
 * @return {void}
 */
Ext.data.IRecord.prototype.commit = function(silent, modifiedFieldNames) {};

/**
 * [Method] Creates a copy clone of this Model instance
 * @param {string=} id String A new id, defaults to the id of the instance being copied. See id. To generate a phantom instance with a new id use: var rec = record.copy(); // clone the record Ext.data.Model.id(rec); // automatically generate a unique sequential id
 * @return {!Ext.data.IModel} Ext.data.Model
 */
Ext.data.IRecord.prototype.copy = function(id) {};

/**
 * [Method] Destroys the model using the configured proxy
 * @param {?=} options Object Options to pass to the proxy. Config object for Ext.data.Operation.
 * @return {!Ext.data.IModel} Ext.data.Model The Model instance
 */
Ext.data.IRecord.prototype.destroy = function(options) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.data.IRecord.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Ends an edit
 * @param {boolean=} silent Boolean True to not notify the store of the change
 * @param {!Array<string>=} modifiedFieldNames String[] Array of field names changed during edit.
 * @return {void}
 */
Ext.data.IRecord.prototype.endEdit = function(silent, modifiedFieldNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IRecord.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IRecord.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the value of the given field
 * @param {string=} fieldName String The field to fetch the value for
 * @return {?} Object The value
 */
Ext.data.IRecord.prototype.get = function(fieldName) {};

/**
 * [Method] Gets all of the data from this Models loaded associations
 * @return {?} Object The nested data set for the Model's loaded associations
 */
Ext.data.IRecord.prototype.getAssociatedData = function() {};

/**
 * [Method] Gets a hash of only the fields that have been modified since this Model was created or commited
 * @return {?} Object
 */
Ext.data.IRecord.prototype.getChanges = function() {};

/**
 * [Method] Gets all values for each field in this model and returns an object containing the current data
 * @param {boolean=} includeAssociated Boolean True to also include associated data. Defaults to false.
 * @return {?} Object An object hash containing all the values in this model
 */
Ext.data.IRecord.prototype.getData = function(includeAssociated) {};

/**
 * [Method] Returns the unique ID allocated to this model instance as defined by idProperty
 * @return {?} Number/String The id
 */
Ext.data.IRecord.prototype.getId = function() {};

/**
 * [Method] Returns the configured Proxy for this Model
 * @return {!Ext.data.proxy.IProxy} Ext.data.proxy.Proxy The proxy
 */
Ext.data.IRecord.prototype.getProxy = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.data.IRecord.prototype.hasListener = function(eventName) {};

/**
 * [Method] Returns true if the passed field name has been modified since the load or last commit
 * @param {string=} fieldName String Ext.data.Field.name
 * @return {boolean} Boolean
 */
Ext.data.IRecord.prototype.isModified = function(fieldName) {};

/**
 * [Method] Checks if the model is valid
 * @return {boolean} Boolean True if the model is valid.
 */
Ext.data.IRecord.prototype.isValid = function() {};

/**
 * [Method] Tells this model instance that it has been added to a store
 * @param {!Ext.data.IStore=} store Ext.data.Store The store to which this model has been added.
 * @return {void}
 */
Ext.data.IRecord.prototype.join = function(store) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IRecord.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IRecord.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IRecord.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Usually called by the Ext data Store to which this model instance has been joined
 * @param {boolean=} silent Boolean True to skip notification of the owning store of the change. Defaults to false.
 * @return {void}
 */
Ext.data.IRecord.prototype.reject = function(silent) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.data.IRecord.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IRecord.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IRecord.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.data.IRecord.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.data.IRecord.prototype.resumeEvents = function() {};

/**
 * [Method] Saves the model instance using the configured proxy
 * @param {?=} options Object Options to pass to the proxy. Config object for Ext.data.Operation.
 * @return {!Ext.data.IModel} Ext.data.Model The Model instance
 */
Ext.data.IRecord.prototype.save = function(options) {};

/**
 * [Method] Sets the given field to the given value marks the instance as dirty
 * @param {?=} fieldName String/Object The field to set, or an object containing key/value pairs
 * @param {?=} newValue Object The value to set
 * @return {!Array<string>} String[] The array of modified field names or null if nothing was modified.
 */
Ext.data.IRecord.prototype.set = function(fieldName, newValue) {};

/**
 * [Method] Marks this Record as dirty
 * @return {void}
 */
Ext.data.IRecord.prototype.setDirty = function() {};

/**
 * [Method] Sets the model instance s id field to the given id
 * @param {?=} id Number/String The new id
 * @return {void}
 */
Ext.data.IRecord.prototype.setId = function(id) {};

/**
 * [Method] Sets the Proxy to use for this model
 * @param {?=} proxy String/Object/Ext.data.proxy.Proxy The proxy
 * @return {!Ext.data.proxy.IProxy} Ext.data.proxy.Proxy
 */
Ext.data.IRecord.prototype.setProxy = function(proxy) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.data.IRecord.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.data.IRecord.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IRecord.prototype.un = function(eventName, fn, scope) {};

/**
 * [Method] Tells this model instance that it has been removed from the store
 * @param {!Ext.data.IStore=} store Ext.data.Store The store from which this model has been removed.
 * @return {void}
 */
Ext.data.IRecord.prototype.unjoin = function(store) {};

/**
 * [Method] Validates the current data against all of its configured validations
 * @return {!Ext.data.IErrors} Ext.data.Errors The errors object
 */
Ext.data.IRecord.prototype.validate = function() {};
/**
 * @constructor
 * @struct
 */
Ext.data.Record = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.data.Record.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.data.Record.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.data.Record.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.data.Record.createAlias = function(alias, origin) {};

/**
 * [Method] Returns an Array of Field definitions which define this Model s structure Fields are sorted upon Model class definit
 * @return {!Array<!Ext.data.IField>} Ext.data.Field[] The defined Fields for this Model.
 */
Ext.data.Record.getFields = function() {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.data.Record.getName = function() {};

/**
 * [Method] Returns the configured Proxy for this Model
 * @return {!Ext.data.proxy.IProxy} Ext.data.proxy.Proxy The proxy
 */
Ext.data.Record.getProxy = function() {};

/**
 * [Method] Generates a sequential id
 * @param {!Ext.data.IModel=} rec Ext.data.Model The record being created. The record does not exist, it's a phantom.
 * @return {string} String auto-generated string id, "ext-record-i++";
 */
Ext.data.Record.id = function(rec) {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.data.Record.implement = function() {};

/**
 * [Method] Asynchronously loads a model instance by id
 * @param {?=} id Number/String The id of the model to load
 * @param {?=} config Object config object containing success, failure and callback functions, plus optional scope
 * @return {void}
 */
Ext.data.Record.load = function(id, config) {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.data.Record.override = function(members) {};

/**
 * [Method] Apply a new set of field and or property definitions to the existing model
 * @param {?=} fields Object
 * @param {?=} idProperty Object
 * @param {?=} clientIdProperty Object
 * @return {void}
 */
Ext.data.Record.setFields = function(fields, idProperty, clientIdProperty) {};

/**
 * [Method] Sets the Proxy to use for this model
 * @param {?=} proxy String/Object/Ext.data.proxy.Proxy The proxy
 * @return {!Ext.data.proxy.IProxy} Ext.data.proxy.Proxy
 */
Ext.data.Record.setProxy = function(proxy) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.INodeInterface = function() {};
 /** @type {boolean} */
Ext.data.INodeInterface.prototype.allowDrag;
 /** @type {boolean} */
Ext.data.INodeInterface.prototype.allowDrop;
 /** @type {boolean} */
Ext.data.INodeInterface.prototype.checked;
 /** @type {!Array<!Ext.data.INodeInterface>} */
Ext.data.INodeInterface.prototype.children;
 /** @type {string} */
Ext.data.INodeInterface.prototype.cls;
 /** @type {number} */
Ext.data.INodeInterface.prototype.depth;
 /** @type {boolean} */
Ext.data.INodeInterface.prototype.expandable;
 /** @type {boolean} */
Ext.data.INodeInterface.prototype.expanded;
 /** @type {string} */
Ext.data.INodeInterface.prototype.href;
 /** @type {string} */
Ext.data.INodeInterface.prototype.hrefTarget;
 /** @type {string} */
Ext.data.INodeInterface.prototype.icon;
 /** @type {string} */
Ext.data.INodeInterface.prototype.iconCls;
 /** @type {number} */
Ext.data.INodeInterface.prototype.index;
 /** @type {boolean} */
Ext.data.INodeInterface.prototype.isFirst;
 /** @type {boolean} */
Ext.data.INodeInterface.prototype.isLast;
 /** @type {boolean} */
Ext.data.INodeInterface.prototype.leaf;
 /** @type {boolean} */
Ext.data.INodeInterface.prototype.loaded;
 /** @type {boolean} */
Ext.data.INodeInterface.prototype.loading;
 /** @type {string} */
Ext.data.INodeInterface.prototype.parentId;
 /** @type {number} */
Ext.data.INodeInterface.prototype.qshowDelay;
 /** @type {string} */
Ext.data.INodeInterface.prototype.qtip;
 /** @type {string} */
Ext.data.INodeInterface.prototype.qtitle;
 /** @type {boolean} */
Ext.data.INodeInterface.prototype.root;
 /** @type {string} */
Ext.data.INodeInterface.prototype.text;
 /** @type {!Array<!Ext.data.INodeInterface>} */
Ext.data.INodeInterface.prototype.childNodes;
 /** @type {!Ext.data.INodeInterface} */
Ext.data.INodeInterface.prototype.firstChild;
 /** @type {boolean} */
Ext.data.INodeInterface.prototype.isNode;
 /** @type {!Ext.data.INodeInterface} */
Ext.data.INodeInterface.prototype.lastChild;
 /** @type {!Ext.data.INodeInterface} */
Ext.data.INodeInterface.prototype.nextSibling;
 /** @type {!Ext.data.INodeInterface} */
Ext.data.INodeInterface.prototype.parentNode;
 /** @type {!Ext.data.INodeInterface} */
Ext.data.INodeInterface.prototype.previousSibling;

/**
 * [Method] Inserts node s as the last child node of this node
 * @param {?=} node Ext.data.NodeInterface/Ext.data.NodeInterface[]/Object The node or Array of nodes to append
 * @param {boolean=} suppressEvents Boolean True to suppress firering of events.
 * @param {boolean=} commit Boolean
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface The appended node if single append, or null if an array was passed
 */
Ext.data.INodeInterface.prototype.appendChild = function(node, suppressEvents, commit) {};

/**
 * [Method] Bubbles up the tree from this node calling the specified function with each node
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current Node.
 * @param {!Array<?>=} args Array The args to call the function with. Defaults to passing the current Node.
 * @return {void}
 */
Ext.data.INodeInterface.prototype.bubble = function(fn, scope, args) {};

/**
 * [Method] Cascades down the tree from this node calling the specified function with each node
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current Node.
 * @param {!Array<?>=} args Array The args to call the function with. Defaults to passing the current Node.
 * @return {void}
 */
Ext.data.INodeInterface.prototype.cascadeBy = function(fn, scope, args) {};

/**
 * [Method] Collapse this node
 * @param {boolean=} recursive Boolean True to recursively collapse all the children
 * @param {?=} callback Function The function to execute once the collapse completes
 * @param {?=} scope Object The scope to run the callback in
 * @return {void}
 */
Ext.data.INodeInterface.prototype.collapse = function(recursive, callback, scope) {};

/**
 * [Method] Collapse all the children of this node
 * @param {?=} recursive Function True to recursively collapse all the children
 * @param {?=} callback Function The function to execute once all the children are collapsed
 * @param {?=} scope Object The scope to run the callback in
 * @return {void}
 */
Ext.data.INodeInterface.prototype.collapseChildren = function(recursive, callback, scope) {};

/**
 * [Method] Returns true if this node is an ancestor at any point of the passed node
 * @param {!Ext.data.INodeInterface=} node Ext.data.NodeInterface
 * @return {boolean} Boolean
 */
Ext.data.INodeInterface.prototype.contains = function(node) {};

/**
 * [Method] Creates a copy clone of this Node
 * @param {string=} id String A new id, defaults to this Node's id.
 * @param {boolean=} deep Boolean True to recursively copy all child Nodes into the new Node. False to copy without child Nodes.
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface A copy of this Node.
 */
Ext.data.INodeInterface.prototype.copy = function(id, deep) {};

/**
 * [Method] Ensures that the passed object is an instance of a Record with the NodeInterface applied
 * @param {?=} node Object
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface
 */
Ext.data.INodeInterface.prototype.createNode = function(node) {};

/**
 * [Method] Destroys the node
 * @param {?=} silent Object
 * @return {void}
 */
Ext.data.INodeInterface.prototype.destroy = function(silent) {};

/**
 * [Method] Interates the child nodes of this node calling the specified function with each node
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current Node in iteration.
 * @param {!Array<?>=} args Array The args to call the function with. Defaults to passing the current Node.
 * @return {void}
 */
Ext.data.INodeInterface.prototype.eachChild = function(fn, scope, args) {};

/**
 * [Method] Expand this node
 * @param {boolean=} recursive Boolean True to recursively expand all the children
 * @param {?=} callback Function The function to execute once the expand completes
 * @param {?=} scope Object The scope to run the callback in
 * @return {void}
 */
Ext.data.INodeInterface.prototype.expand = function(recursive, callback, scope) {};

/**
 * [Method] Expand all the children of this node
 * @param {boolean=} recursive Boolean True to recursively expand all the children
 * @param {?=} callback Function The function to execute once all the children are expanded
 * @param {?=} scope Object The scope to run the callback in
 * @return {void}
 */
Ext.data.INodeInterface.prototype.expandChildren = function(recursive, callback, scope) {};

/**
 * [Method] Finds the first child that has the attribute with the specified value
 * @param {string=} attribute String The attribute name
 * @param {?=} value Object The value to search for
 * @param {boolean=} deep Boolean True to search through nodes deeper than the immediate children
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface The found child or null if none was found
 */
Ext.data.INodeInterface.prototype.findChild = function(attribute, value, deep) {};

/**
 * [Method] Finds the first child by a custom function
 * @param {?=} fn Function A function which must return true if the passed Node is the required Node.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the Node being tested.
 * @param {boolean=} deep Boolean True to search through nodes deeper than the immediate children
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface The found child or null if none was found
 */
Ext.data.INodeInterface.prototype.findChildBy = function(fn, scope, deep) {};

/**
 * [Method] Returns the child node at the specified index
 * @param {number=} index Number
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface
 */
Ext.data.INodeInterface.prototype.getChildAt = function(index) {};

/**
 * [Method] Returns depth of this node the root node has a depth of 0
 * @return {number} Number
 */
Ext.data.INodeInterface.prototype.getDepth = function() {};

/**
 * [Method] Returns the tree this node is in
 * @return {!Ext.tree.IPanel} Ext.tree.Panel The tree panel which owns this node.
 */
Ext.data.INodeInterface.prototype.getOwnerTree = function() {};

/**
 * [Method] Gets the hierarchical path from the root of the current node
 * @param {string=} field String The field to construct the path from. Defaults to the model idProperty.
 * @param {string=} separator String A separator to use.
 * @return {string} String The node path
 */
Ext.data.INodeInterface.prototype.getPath = function(field, separator) {};

/**
 * [Method] Returns true if this node has one or more child nodes else false
 * @return {boolean} Boolean
 */
Ext.data.INodeInterface.prototype.hasChildNodes = function() {};

/**
 * [Method] Returns the index of a child node
 * @param {!Ext.data.INodeInterface=} node Ext.data.NodeInterface
 * @return {number} Number The index of the node or -1 if it was not found
 */
Ext.data.INodeInterface.prototype.indexOf = function(node) {};

/**
 * [Method] Returns the index of a child node that matches the id
 * @param {string=} id String The id of the node to find
 * @return {number} Number The index of the node or -1 if it was not found
 */
Ext.data.INodeInterface.prototype.indexOfId = function(id) {};

/**
 * [Method] Inserts the first node before the second node in this nodes childNodes collection
 * @param {!Ext.data.INodeInterface=} node Ext.data.NodeInterface The node to insert
 * @param {!Ext.data.INodeInterface=} refNode Ext.data.NodeInterface The node to insert before (if null the node is appended)
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface The inserted node
 */
Ext.data.INodeInterface.prototype.insertBefore = function(node, refNode) {};

/**
 * [Method] Inserts a node into this node
 * @param {number=} index Number The zero-based index to insert the node at
 * @param {!Ext.data.INodeInterface=} node Ext.data.NodeInterface The node to insert
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface The node you just inserted
 */
Ext.data.INodeInterface.prototype.insertChild = function(index, node) {};

/**
 * [Method] Returns true if the passed node is an ancestor at any point of this node
 * @param {!Ext.data.INodeInterface=} node Ext.data.NodeInterface
 * @return {boolean} Boolean
 */
Ext.data.INodeInterface.prototype.isAncestor = function(node) {};

/**
 * [Method] Returns true if this node has one or more child nodes or if the expandable node attribute is explicitly specified as
 * @return {boolean} Boolean
 */
Ext.data.INodeInterface.prototype.isExpandable = function() {};

/**
 * [Method] Returns true if this node is expaned
 * @return {boolean} Boolean
 */
Ext.data.INodeInterface.prototype.isExpanded = function() {};

/**
 * [Method] Returns true if this node is a leaf
 * @return {boolean} Boolean
 */
Ext.data.INodeInterface.prototype.isLeaf = function() {};

/**
 * [Method] Returns true if this node is loaded
 * @return {boolean} Boolean
 */
Ext.data.INodeInterface.prototype.isLoaded = function() {};

/**
 * [Method] Returns true if this node is loading
 * @return {boolean} Boolean
 */
Ext.data.INodeInterface.prototype.isLoading = function() {};

/**
 * [Method] Returns true if this node is the root node
 * @return {boolean} Boolean
 */
Ext.data.INodeInterface.prototype.isRoot = function() {};

/**
 * [Method] Returns true if this node is visible
 * @return {boolean} Boolean
 */
Ext.data.INodeInterface.prototype.isVisible = function() {};

/**
 * [Method] Removes this node from its parent
 * @param {boolean=} destroy Boolean True to destroy the node upon removal.
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface this
 */
Ext.data.INodeInterface.prototype.remove = function(destroy) {};

/**
 * [Method] Removes all child nodes from this node
 * @param {boolean=} destroy Boolean True to destroy the node upon removal.
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface this
 */
Ext.data.INodeInterface.prototype.removeAll = function(destroy) {};

/**
 * [Method] Removes a child node from this node
 * @param {!Ext.data.INodeInterface=} node Ext.data.NodeInterface The node to remove
 * @param {boolean=} destroy Boolean True to destroy the node upon removal.
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface The removed node
 */
Ext.data.INodeInterface.prototype.removeChild = function(node, destroy) {};

/**
 * [Method] Replaces one child node in this node with another
 * @param {!Ext.data.INodeInterface=} newChild Ext.data.NodeInterface The replacement node
 * @param {!Ext.data.INodeInterface=} oldChild Ext.data.NodeInterface The node to replace
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface The replaced node
 */
Ext.data.INodeInterface.prototype.replaceChild = function(newChild, oldChild) {};

/**
 * [Method] Creates an object representation of this node including its children
 * @return {void}
 */
Ext.data.INodeInterface.prototype.serialize = function() {};

/**
 * [Method] Sorts this nodes children using the supplied sort function
 * @param {?=} fn Function A function which, when passed two Nodes, returns -1, 0 or 1 depending upon required sort order.
 * @param {boolean=} recursive Boolean True to apply this sort recursively
 * @param {boolean=} suppressEvent Boolean True to not fire a sort event.
 * @return {void}
 */
Ext.data.INodeInterface.prototype.sort = function(fn, recursive, suppressEvent) {};

/**
 * [Method] Updates general data of this node like isFirst isLast depth
 * @param {boolean=} commit Boolean
 * @param {?=} info Object The info to update. May contain any of the following
 * @return {void}
 */
Ext.data.INodeInterface.prototype.updateInfo = function(commit, info) {};
/**
 * @constructor
 * @struct
 */
Ext.data.NodeInterface = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.data.NodeInterface.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.data.NodeInterface.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.data.NodeInterface.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.data.NodeInterface.createAlias = function(alias, origin) {};

/**
 * [Method] This method allows you to decorate a Model s class to implement the NodeInterface
 * @param {?=} modelClass Ext.Class/Ext.data.Model The Model class or an instance of the Model class you want to decorate the prototype of.
 * @return {void}
 */
Ext.data.NodeInterface.decorate = function(modelClass) {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.data.NodeInterface.getName = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.data.NodeInterface.implement = function() {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.data.NodeInterface.override = function(members) {};
/**
 * @extends {Ext.data.IStore}
 * @record
 * @struct
 */
Ext.data.INodeStore = function() {};
 /** @type {!Ext.data.IModel} */
Ext.data.INodeStore.prototype.node;
 /** @type {boolean} */
Ext.data.INodeStore.prototype.recursive;
 /** @type {boolean} */
Ext.data.INodeStore.prototype.rootVisible;
 /** @type {!Ext.data.ITreeStore} */
Ext.data.INodeStore.prototype.treeStore;
 /** @type {number} */
Ext.data.INodeStore.prototype.isExpandingOrCollapsing;
 /** @type {boolean} */
Ext.data.INodeStore.prototype.isNodeStore;

/**
 * [Method] NodeStores are never buffered or paged
 * @return {number} Number The total number of Model instances available via the Proxy. 0 returned if no value has been set via the reader.
 */
Ext.data.INodeStore.prototype.getTotalCount = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.IOperation = function() {};
 /** @type {string} */
Ext.data.IOperation.prototype.action;
 /** @type {!Ext.data.IBatch} */
Ext.data.IOperation.prototype.batch;
 /** @type {?} */
Ext.data.IOperation.prototype.callback;
 /** @type {!Array<!Ext.util.IFilter>} */
Ext.data.IOperation.prototype.filters;
 /** @type {!Array<!Ext.util.IGrouper>} */
Ext.data.IOperation.prototype.groupers;
 /** @type {number} */
Ext.data.IOperation.prototype.limit;
 /** @type {?} */
Ext.data.IOperation.prototype.params;
 /** @type {?} */
Ext.data.IOperation.prototype.scope;
 /** @type {!Array<!Ext.util.ISorter>} */
Ext.data.IOperation.prototype.sorters;
 /** @type {number} */
Ext.data.IOperation.prototype.start;
 /** @type {boolean} */
Ext.data.IOperation.prototype.synchronous;
 /** @type {!RegExp} */
Ext.data.IOperation.prototype.actionCommitRecordsRe;
 /** @type {!RegExp} */
Ext.data.IOperation.prototype.actionSkipSyncRe;

/**
 * [Method] Checks whether this operation should cause writing to occur
 * @return {boolean} Boolean Whether the operation should cause a write to occur.
 */
Ext.data.IOperation.prototype.allowWrite = function() {};

/**
 * [Method] This method is called to commit data to this instance s records given the records in the server response
 * @param {!Array<!Ext.data.IModel>=} serverRecords Ext.data.Model[] An array of Ext.data.Model objects returned by the server.
 * @return {void}
 */
Ext.data.IOperation.prototype.commitRecords = function(serverRecords) {};

/**
 * [Method] Returns the error string or object that was set using setException
 * @return {?} String/Object The error object
 */
Ext.data.IOperation.prototype.getError = function() {};

/**
 * [Method] Returns the records associated with this operation
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[]
 */
Ext.data.IOperation.prototype.getRecords = function() {};

/**
 * [Method] Returns the ResultSet object if set by the Proxy
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet The ResultSet object
 */
Ext.data.IOperation.prototype.getResultSet = function() {};

/**
 * [Method] Returns true if this Operation encountered an exception see also getError
 * @return {boolean} Boolean True if there was an exception
 */
Ext.data.IOperation.prototype.hasException = function() {};

/**
 * [Method] Returns true if the Operation has been completed
 * @return {boolean} Boolean True if the Operation is complete
 */
Ext.data.IOperation.prototype.isComplete = function() {};

/**
 * [Method] Returns true if the Operation has been started but has not yet completed
 * @return {boolean} Boolean True if the Operation is currently running
 */
Ext.data.IOperation.prototype.isRunning = function() {};

/**
 * [Method] Returns true if the Operation has been started
 * @return {boolean} Boolean True if the Operation has started
 */
Ext.data.IOperation.prototype.isStarted = function() {};

/**
 * [Method] Marks the Operation as completed
 * @return {void}
 */
Ext.data.IOperation.prototype.setCompleted = function() {};

/**
 * [Method] Marks the Operation as having experienced an exception
 * @param {?=} error String/Object error string/object
 * @return {void}
 */
Ext.data.IOperation.prototype.setException = function(error) {};

/**
 * [Method] Marks the Operation as started
 * @return {void}
 */
Ext.data.IOperation.prototype.setStarted = function() {};

/**
 * [Method] Marks the Operation as successful
 * @return {void}
 */
Ext.data.IOperation.prototype.setSuccessful = function() {};

/**
 * [Method] Returns true if the Operation has completed and was successful
 * @return {boolean} Boolean True if successful
 */
Ext.data.IOperation.prototype.wasSuccessful = function() {};
/**
 * @extends {Ext.util.ILruCache}
 * @record
 * @struct
 */
Ext.data.IPageMap = function() {};

/**
 * [Method] Maintain a generation counter so that the Store can reject incoming pages destined for the previous generation
 * @param {?=} initial Object
 * @return {!Ext.util.IHashMap} Ext.util.HashMap this
 */
Ext.data.IPageMap.prototype.clear = function(initial) {};

/**
 * [Method] Returns the first record in this page map which elicits a true return value from the passed selection function
 * @param {?=} fn Function The selection function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this PageMap.
 * @return {?} Object The first record in this page map which returned true from the selection function, or null if none was found.
 */
Ext.data.IPageMap.prototype.findBy = function(fn, scope) {};

/**
 * [Method] Returns the index in the whole dataset of the first record in this page map which elicits a true return value from th
 * @param {?=} fn Function The selection function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this PageMap.
 * @return {number} Number The index first record in this page map which returned true from the selection function, or -1 if none was found.
 */
Ext.data.IPageMap.prototype.findIndexBy = function(fn, scope) {};

/**
 * [Method] Gets the number of items in the hash
 * @return {number} Number The number of items in the hash.
 */
Ext.data.IPageMap.prototype.getCount = function() {};

/**
 * [Method] Remove an item from the hash
 * @return {boolean} Boolean True if the item was successfully removed.
 */
Ext.data.IPageMap.prototype.remove = function() {};
/** @const */
Ext.data.proxy = {};
/**
 * @extends {Ext.data.proxy.IServer}
 * @record
 * @struct
 */
Ext.data.proxy.IAjax = function() {};
 /** @type {boolean} */
Ext.data.proxy.IAjax.prototype.binary;
 /** @type {?} */
Ext.data.proxy.IAjax.prototype.headers;
 /** @type {?} */
Ext.data.proxy.IAjax.prototype.actionMethods;

/**
 * [Method] Returns the HTTP method name for a given request
 * @param {!Ext.data.IRequest=} request Ext.data.Request The request object
 * @return {string} String The HTTP method to use (should be one of 'GET', 'POST', 'PUT' or 'DELETE')
 */
Ext.data.proxy.IAjax.prototype.getMethod = function(request) {};
/**
 * @extends {Ext.data.proxy.IServer}
 * @record
 * @struct
 */
Ext.data.IHttpProxy = function() {};
 /** @type {boolean} */
Ext.data.IHttpProxy.prototype.binary;
 /** @type {?} */
Ext.data.IHttpProxy.prototype.headers;
 /** @type {?} */
Ext.data.IHttpProxy.prototype.actionMethods;

/**
 * [Method] Returns the HTTP method name for a given request
 * @param {!Ext.data.IRequest=} request Ext.data.Request The request object
 * @return {string} String The HTTP method to use (should be one of 'GET', 'POST', 'PUT' or 'DELETE')
 */
Ext.data.IHttpProxy.prototype.getMethod = function(request) {};
/**
 * @extends {Ext.data.proxy.IServer}
 * @record
 * @struct
 */
Ext.data.IAjaxProxy = function() {};
 /** @type {boolean} */
Ext.data.IAjaxProxy.prototype.binary;
 /** @type {?} */
Ext.data.IAjaxProxy.prototype.headers;
 /** @type {?} */
Ext.data.IAjaxProxy.prototype.actionMethods;

/**
 * [Method] Returns the HTTP method name for a given request
 * @param {!Ext.data.IRequest=} request Ext.data.Request The request object
 * @return {string} String The HTTP method to use (should be one of 'GET', 'POST', 'PUT' or 'DELETE')
 */
Ext.data.IAjaxProxy.prototype.getMethod = function(request) {};
/**
 * @extends {Ext.data.proxy.IProxy}
 * @record
 * @struct
 */
Ext.data.proxy.IClient = function() {};
 /** @type {boolean} */
Ext.data.proxy.IClient.prototype.isSynchronous;

/**
 * [Method] Abstract function that must be implemented by each ClientProxy subclass
 * @return {void}
 */
Ext.data.proxy.IClient.prototype.clear = function() {};
/**
 * @extends {Ext.data.proxy.IProxy}
 * @record
 * @struct
 */
Ext.data.IClientProxy = function() {};
 /** @type {boolean} */
Ext.data.IClientProxy.prototype.isSynchronous;

/**
 * [Method] Abstract function that must be implemented by each ClientProxy subclass
 * @return {void}
 */
Ext.data.IClientProxy.prototype.clear = function() {};
/**
 * @extends {Ext.data.proxy.IServer}
 * @record
 * @struct
 */
Ext.data.proxy.IDirect = function() {};
 /** @type {?} */
Ext.data.proxy.IDirect.prototype.api;
 /** @type {?} */
Ext.data.proxy.IDirect.prototype.directFn;
 /** @type {?} */
Ext.data.proxy.IDirect.prototype.extraParams;
 /** @type {?} */
Ext.data.proxy.IDirect.prototype.paramOrder;
 /** @type {boolean} */
Ext.data.proxy.IDirect.prototype.paramsAsHash;

/**
 * [Method] inherit docs
 * @return {string} String The url
 */
Ext.data.proxy.IDirect.prototype.buildUrl = function() {};

/**
 * [Method] In ServerProxy subclasses the create read update and destroy methods all pass through to doRequest
 * @param {?=} operation Object
 * @param {?=} callback Object
 * @param {?=} scope Object
 * @return {void}
 */
Ext.data.proxy.IDirect.prototype.doRequest = function(operation, callback, scope) {};
/**
 * @extends {Ext.data.proxy.IServer}
 * @record
 * @struct
 */
Ext.data.IDirectProxy = function() {};
 /** @type {?} */
Ext.data.IDirectProxy.prototype.api;
 /** @type {?} */
Ext.data.IDirectProxy.prototype.directFn;
 /** @type {?} */
Ext.data.IDirectProxy.prototype.extraParams;
 /** @type {?} */
Ext.data.IDirectProxy.prototype.paramOrder;
 /** @type {boolean} */
Ext.data.IDirectProxy.prototype.paramsAsHash;

/**
 * [Method] inherit docs
 * @return {string} String The url
 */
Ext.data.IDirectProxy.prototype.buildUrl = function() {};

/**
 * [Method] In ServerProxy subclasses the create read update and destroy methods all pass through to doRequest
 * @param {?=} operation Object
 * @param {?=} callback Object
 * @param {?=} scope Object
 * @return {void}
 */
Ext.data.IDirectProxy.prototype.doRequest = function(operation, callback, scope) {};
/**
 * @extends {Ext.data.proxy.IServer}
 * @record
 * @struct
 */
Ext.data.proxy.IJsonP = function() {};
 /** @type {boolean} */
Ext.data.proxy.IJsonP.prototype.autoAppendParams;
 /** @type {string} */
Ext.data.proxy.IJsonP.prototype.callbackKey;
 /** @type {string} */
Ext.data.proxy.IJsonP.prototype.recordParam;

/**
 * [Method] Aborts the current server request if one is currently running
 * @return {void}
 */
Ext.data.proxy.IJsonP.prototype.abort = function() {};

/**
 * [Method] Generates a url based on a given Ext data Request object
 * @param {!Ext.data.IRequest=} request Ext.data.Request The request object
 * @return {string} String The url
 */
Ext.data.proxy.IJsonP.prototype.buildUrl = function(request) {};

/**
 * [Method] Encodes an array of records into a value suitable to be added to the request params as the recordParam parameter
 * @param {!Array<!Ext.data.IModel>=} records Ext.data.Model[] The records array
 * @return {!Array<?>} Array An array of record data objects
 */
Ext.data.proxy.IJsonP.prototype.encodeRecords = function(records) {};
/**
 * @extends {Ext.data.proxy.IServer}
 * @record
 * @struct
 */
Ext.data.IScriptTagProxy = function() {};
 /** @type {boolean} */
Ext.data.IScriptTagProxy.prototype.autoAppendParams;
 /** @type {string} */
Ext.data.IScriptTagProxy.prototype.callbackKey;
 /** @type {string} */
Ext.data.IScriptTagProxy.prototype.recordParam;

/**
 * [Method] Aborts the current server request if one is currently running
 * @return {void}
 */
Ext.data.IScriptTagProxy.prototype.abort = function() {};

/**
 * [Method] Generates a url based on a given Ext data Request object
 * @param {!Ext.data.IRequest=} request Ext.data.Request The request object
 * @return {string} String The url
 */
Ext.data.IScriptTagProxy.prototype.buildUrl = function(request) {};

/**
 * [Method] Encodes an array of records into a value suitable to be added to the request params as the recordParam parameter
 * @param {!Array<!Ext.data.IModel>=} records Ext.data.Model[] The records array
 * @return {!Array<?>} Array An array of record data objects
 */
Ext.data.IScriptTagProxy.prototype.encodeRecords = function(records) {};
/**
 * @extends {Ext.data.proxy.IWebStorage}
 * @record
 * @struct
 */
Ext.data.proxy.ILocalStorage = function() {};
/**
 * @extends {Ext.data.proxy.IWebStorage}
 * @record
 * @struct
 */
Ext.data.ILocalStorageProxy = function() {};
/**
 * @extends {Ext.data.proxy.IClient}
 * @record
 * @struct
 */
Ext.data.proxy.IMemory = function() {};
 /** @type {?} */
Ext.data.proxy.IMemory.prototype.data;
 /** @type {boolean} */
Ext.data.proxy.IMemory.prototype.enablePaging;

/**
 * [Method] Abstract function that must be implemented by each ClientProxy subclass
 * @return {void}
 */
Ext.data.proxy.IMemory.prototype.clear = function() {};

/**
 * [Method] Currently this is a hard coded method that simply commits any records and sets the operation to successful then call
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.proxy.IMemory.prototype.create = function(operation, callback, scope) {};

/**
 * [Method] Currently this is a hard coded method that simply commits any records and sets the operation to successful then call
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.proxy.IMemory.prototype.destroy = function(operation, callback, scope) {};

/**
 * [Method] Reads data from the configured data object
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The read Operation
 * @param {?=} callback Function The callback to call when reading has completed
 * @param {?=} scope Object The scope to call the callback function in
 * @return {void}
 */
Ext.data.proxy.IMemory.prototype.read = function(operation, callback, scope) {};

/**
 * [Method] Currently this is a hard coded method that simply commits any records and sets the operation to successful then call
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.proxy.IMemory.prototype.update = function(operation, callback, scope) {};
/**
 * @extends {Ext.data.proxy.IClient}
 * @record
 * @struct
 */
Ext.data.IMemoryProxy = function() {};
 /** @type {?} */
Ext.data.IMemoryProxy.prototype.data;
 /** @type {boolean} */
Ext.data.IMemoryProxy.prototype.enablePaging;

/**
 * [Method] Abstract function that must be implemented by each ClientProxy subclass
 * @return {void}
 */
Ext.data.IMemoryProxy.prototype.clear = function() {};

/**
 * [Method] Currently this is a hard coded method that simply commits any records and sets the operation to successful then call
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.IMemoryProxy.prototype.create = function(operation, callback, scope) {};

/**
 * [Method] Currently this is a hard coded method that simply commits any records and sets the operation to successful then call
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.IMemoryProxy.prototype.destroy = function(operation, callback, scope) {};

/**
 * [Method] Reads data from the configured data object
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The read Operation
 * @param {?=} callback Function The callback to call when reading has completed
 * @param {?=} scope Object The scope to call the callback function in
 * @return {void}
 */
Ext.data.IMemoryProxy.prototype.read = function(operation, callback, scope) {};

/**
 * [Method] Currently this is a hard coded method that simply commits any records and sets the operation to successful then call
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.IMemoryProxy.prototype.update = function(operation, callback, scope) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.data.proxy.IProxy = function() {};
 /** @type {boolean} */
Ext.data.proxy.IProxy.prototype.batchActions;
 /** @type {string} */
Ext.data.proxy.IProxy.prototype.batchOrder;
 /** @type {?} */
Ext.data.proxy.IProxy.prototype.model;
 /** @type {?} */
Ext.data.proxy.IProxy.prototype.reader;
 /** @type {?} */
Ext.data.proxy.IProxy.prototype.writer;
 /** @type {boolean} */
Ext.data.proxy.IProxy.prototype.isProxy;
 /** @type {boolean} */
Ext.data.proxy.IProxy.prototype.isSynchronous;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.proxy.IProxy.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.proxy.IProxy.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Performs a batch of Operations in the order specified by batchOrder
 * @param {?=} options Object Object containing one or more properties supported by the batch method:
 * @return {!Ext.data.IBatch} Ext.data.Batch The newly created Batch
 */
Ext.data.proxy.IProxy.prototype.batch = function(options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.clearManagedListeners = function() {};

/**
 * [Method] Performs the given create operation
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.create = function(operation, callback, scope) {};

/**
 * [Method] Performs the given destroy operation
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.destroy = function(operation, callback, scope) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.proxy.IProxy.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.proxy.IProxy.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the model attached to this Proxy
 * @return {!Ext.data.IModel} Ext.data.Model The model
 */
Ext.data.proxy.IProxy.prototype.getModel = function() {};

/**
 * [Method] Returns the reader currently attached to this proxy instance
 * @return {!Ext.data.reader.IReader} Ext.data.reader.Reader The Reader instance
 */
Ext.data.proxy.IProxy.prototype.getReader = function() {};

/**
 * [Method] Returns the writer currently attached to this proxy instance
 * @return {!Ext.data.writer.IWriter} Ext.data.writer.Writer The Writer instance
 */
Ext.data.proxy.IProxy.prototype.getWriter = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.data.proxy.IProxy.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.proxy.IProxy.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.proxy.IProxy.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Performs the given read operation
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.read = function(operation, callback, scope) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.data.proxy.IProxy.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.resumeEvents = function() {};

/**
 * [Method] Sets the model associated with this proxy
 * @param {?=} model String/Ext.data.Model The new model. Can be either the model name string, or a reference to the model's constructor
 * @param {boolean=} setOnStore Boolean Sets the new model on the associated Store, if one is present
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.setModel = function(model, setOnStore) {};

/**
 * [Method] Sets the Proxy s Reader by string config object or Reader instance
 * @param {?=} reader String/Object/Ext.data.reader.Reader The new Reader, which can be either a type string, a configuration object or an Ext.data.reader.Reader instance
 * @return {!Ext.data.reader.IReader} Ext.data.reader.Reader The attached Reader object
 */
Ext.data.proxy.IProxy.prototype.setReader = function(reader) {};

/**
 * [Method] Sets the Proxy s Writer by string config object or Writer instance
 * @param {?=} writer String/Object/Ext.data.writer.Writer The new Writer, which can be either a type string, a configuration object or an Ext.data.writer.Writer instance
 * @return {!Ext.data.writer.IWriter} Ext.data.writer.Writer The attached Writer object
 */
Ext.data.proxy.IProxy.prototype.setWriter = function(writer) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.un = function(eventName, fn, scope) {};

/**
 * [Method] Performs the given update operation
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.proxy.IProxy.prototype.update = function(operation, callback, scope) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.data.IDataProxy = function() {};
 /** @type {boolean} */
Ext.data.IDataProxy.prototype.batchActions;
 /** @type {string} */
Ext.data.IDataProxy.prototype.batchOrder;
 /** @type {?} */
Ext.data.IDataProxy.prototype.model;
 /** @type {?} */
Ext.data.IDataProxy.prototype.reader;
 /** @type {?} */
Ext.data.IDataProxy.prototype.writer;
 /** @type {boolean} */
Ext.data.IDataProxy.prototype.isProxy;
 /** @type {boolean} */
Ext.data.IDataProxy.prototype.isSynchronous;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.data.IDataProxy.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IDataProxy.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IDataProxy.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Performs a batch of Operations in the order specified by batchOrder
 * @param {?=} options Object Object containing one or more properties supported by the batch method:
 * @return {!Ext.data.IBatch} Ext.data.Batch The newly created Batch
 */
Ext.data.IDataProxy.prototype.batch = function(options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.data.IDataProxy.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.data.IDataProxy.prototype.clearManagedListeners = function() {};

/**
 * [Method] Performs the given create operation
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.IDataProxy.prototype.create = function(operation, callback, scope) {};

/**
 * [Method] Performs the given destroy operation
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.IDataProxy.prototype.destroy = function(operation, callback, scope) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.data.IDataProxy.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IDataProxy.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IDataProxy.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the model attached to this Proxy
 * @return {!Ext.data.IModel} Ext.data.Model The model
 */
Ext.data.IDataProxy.prototype.getModel = function() {};

/**
 * [Method] Returns the reader currently attached to this proxy instance
 * @return {!Ext.data.reader.IReader} Ext.data.reader.Reader The Reader instance
 */
Ext.data.IDataProxy.prototype.getReader = function() {};

/**
 * [Method] Returns the writer currently attached to this proxy instance
 * @return {!Ext.data.writer.IWriter} Ext.data.writer.Writer The Writer instance
 */
Ext.data.IDataProxy.prototype.getWriter = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.data.IDataProxy.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IDataProxy.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IDataProxy.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IDataProxy.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Performs the given read operation
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.IDataProxy.prototype.read = function(operation, callback, scope) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.data.IDataProxy.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IDataProxy.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IDataProxy.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.data.IDataProxy.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.data.IDataProxy.prototype.resumeEvents = function() {};

/**
 * [Method] Sets the model associated with this proxy
 * @param {?=} model String/Ext.data.Model The new model. Can be either the model name string, or a reference to the model's constructor
 * @param {boolean=} setOnStore Boolean Sets the new model on the associated Store, if one is present
 * @return {void}
 */
Ext.data.IDataProxy.prototype.setModel = function(model, setOnStore) {};

/**
 * [Method] Sets the Proxy s Reader by string config object or Reader instance
 * @param {?=} reader String/Object/Ext.data.reader.Reader The new Reader, which can be either a type string, a configuration object or an Ext.data.reader.Reader instance
 * @return {!Ext.data.reader.IReader} Ext.data.reader.Reader The attached Reader object
 */
Ext.data.IDataProxy.prototype.setReader = function(reader) {};

/**
 * [Method] Sets the Proxy s Writer by string config object or Writer instance
 * @param {?=} writer String/Object/Ext.data.writer.Writer The new Writer, which can be either a type string, a configuration object or an Ext.data.writer.Writer instance
 * @return {!Ext.data.writer.IWriter} Ext.data.writer.Writer The attached Writer object
 */
Ext.data.IDataProxy.prototype.setWriter = function(writer) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.data.IDataProxy.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.data.IDataProxy.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IDataProxy.prototype.un = function(eventName, fn, scope) {};

/**
 * [Method] Performs the given update operation
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.IDataProxy.prototype.update = function(operation, callback, scope) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.data.IProxy = function() {};
 /** @type {boolean} */
Ext.data.IProxy.prototype.batchActions;
 /** @type {string} */
Ext.data.IProxy.prototype.batchOrder;
 /** @type {?} */
Ext.data.IProxy.prototype.model;
 /** @type {?} */
Ext.data.IProxy.prototype.reader;
 /** @type {?} */
Ext.data.IProxy.prototype.writer;
 /** @type {boolean} */
Ext.data.IProxy.prototype.isProxy;
 /** @type {boolean} */
Ext.data.IProxy.prototype.isSynchronous;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.data.IProxy.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IProxy.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IProxy.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Performs a batch of Operations in the order specified by batchOrder
 * @param {?=} options Object Object containing one or more properties supported by the batch method:
 * @return {!Ext.data.IBatch} Ext.data.Batch The newly created Batch
 */
Ext.data.IProxy.prototype.batch = function(options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.data.IProxy.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.data.IProxy.prototype.clearManagedListeners = function() {};

/**
 * [Method] Performs the given create operation
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.IProxy.prototype.create = function(operation, callback, scope) {};

/**
 * [Method] Performs the given destroy operation
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.IProxy.prototype.destroy = function(operation, callback, scope) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.data.IProxy.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IProxy.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IProxy.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the model attached to this Proxy
 * @return {!Ext.data.IModel} Ext.data.Model The model
 */
Ext.data.IProxy.prototype.getModel = function() {};

/**
 * [Method] Returns the reader currently attached to this proxy instance
 * @return {!Ext.data.reader.IReader} Ext.data.reader.Reader The Reader instance
 */
Ext.data.IProxy.prototype.getReader = function() {};

/**
 * [Method] Returns the writer currently attached to this proxy instance
 * @return {!Ext.data.writer.IWriter} Ext.data.writer.Writer The Writer instance
 */
Ext.data.IProxy.prototype.getWriter = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.data.IProxy.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IProxy.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IProxy.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IProxy.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Performs the given read operation
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.IProxy.prototype.read = function(operation, callback, scope) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.data.IProxy.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IProxy.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IProxy.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.data.IProxy.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.data.IProxy.prototype.resumeEvents = function() {};

/**
 * [Method] Sets the model associated with this proxy
 * @param {?=} model String/Ext.data.Model The new model. Can be either the model name string, or a reference to the model's constructor
 * @param {boolean=} setOnStore Boolean Sets the new model on the associated Store, if one is present
 * @return {void}
 */
Ext.data.IProxy.prototype.setModel = function(model, setOnStore) {};

/**
 * [Method] Sets the Proxy s Reader by string config object or Reader instance
 * @param {?=} reader String/Object/Ext.data.reader.Reader The new Reader, which can be either a type string, a configuration object or an Ext.data.reader.Reader instance
 * @return {!Ext.data.reader.IReader} Ext.data.reader.Reader The attached Reader object
 */
Ext.data.IProxy.prototype.setReader = function(reader) {};

/**
 * [Method] Sets the Proxy s Writer by string config object or Writer instance
 * @param {?=} writer String/Object/Ext.data.writer.Writer The new Writer, which can be either a type string, a configuration object or an Ext.data.writer.Writer instance
 * @return {!Ext.data.writer.IWriter} Ext.data.writer.Writer The attached Writer object
 */
Ext.data.IProxy.prototype.setWriter = function(writer) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.data.IProxy.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.data.IProxy.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IProxy.prototype.un = function(eventName, fn, scope) {};

/**
 * [Method] Performs the given update operation
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Operation to perform
 * @param {?=} callback Function Callback function to be called when the Operation has completed (whether successful or not)
 * @param {?=} scope Object Scope to execute the callback function in
 * @return {void}
 */
Ext.data.IProxy.prototype.update = function(operation, callback, scope) {};
/**
 * @extends {Ext.data.proxy.IAjax}
 * @record
 * @struct
 */
Ext.data.proxy.IRest = function() {};
 /** @type {boolean} */
Ext.data.proxy.IRest.prototype.appendId;
 /** @type {boolean} */
Ext.data.proxy.IRest.prototype.batchActions;
 /** @type {string} */
Ext.data.proxy.IRest.prototype.format;
 /** @type {?} */
Ext.data.proxy.IRest.prototype.actionMethods;
/**
 * @extends {Ext.data.proxy.IAjax}
 * @record
 * @struct
 */
Ext.data.IRestProxy = function() {};
 /** @type {boolean} */
Ext.data.IRestProxy.prototype.appendId;
 /** @type {boolean} */
Ext.data.IRestProxy.prototype.batchActions;
 /** @type {string} */
Ext.data.IRestProxy.prototype.format;
 /** @type {?} */
Ext.data.IRestProxy.prototype.actionMethods;
/**
 * @extends {Ext.data.proxy.IProxy}
 * @record
 * @struct
 */
Ext.data.proxy.IServer = function() {};
 /** @type {?} */
Ext.data.proxy.IServer.prototype.api;
 /** @type {string} */
Ext.data.proxy.IServer.prototype.cacheString;
 /** @type {string} */
Ext.data.proxy.IServer.prototype.directionParam;
 /** @type {?} */
Ext.data.proxy.IServer.prototype.extraParams;
 /** @type {string} */
Ext.data.proxy.IServer.prototype.filterParam;
 /** @type {string} */
Ext.data.proxy.IServer.prototype.groupDirectionParam;
 /** @type {string} */
Ext.data.proxy.IServer.prototype.groupParam;
 /** @type {string} */
Ext.data.proxy.IServer.prototype.idParam;
 /** @type {string} */
Ext.data.proxy.IServer.prototype.limitParam;
 /** @type {boolean} */
Ext.data.proxy.IServer.prototype.noCache;
 /** @type {string} */
Ext.data.proxy.IServer.prototype.pageParam;
 /** @type {boolean} */
Ext.data.proxy.IServer.prototype.simpleGroupMode;
 /** @type {boolean} */
Ext.data.proxy.IServer.prototype.simpleSortMode;
 /** @type {string} */
Ext.data.proxy.IServer.prototype.sortParam;
 /** @type {string} */
Ext.data.proxy.IServer.prototype.startParam;
 /** @type {number} */
Ext.data.proxy.IServer.prototype.timeout;
 /** @type {string} */
Ext.data.proxy.IServer.prototype.url;

/**
 * [Method] Optional callback function which can be used to clean up after a request has been completed
 * @param {!Ext.data.IRequest=} request Ext.data.Request The Request object
 * @param {boolean=} success Boolean True if the request was successful
 * @return {void}
 */
Ext.data.proxy.IServer.prototype.afterRequest = function(request, success) {};

/**
 * [Method] Creates an Request object from Operation
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The operation to execute
 * @return {!Ext.data.IRequest} Ext.data.Request The request object
 */
Ext.data.proxy.IServer.prototype.buildRequest = function(operation) {};

/**
 * [Method] Generates a url based on a given Ext data Request object
 * @param {!Ext.data.IRequest=} request Ext.data.Request The request object
 * @return {string} String The url
 */
Ext.data.proxy.IServer.prototype.buildUrl = function(request) {};

/**
 * [Method] in a ServerProxy all four CRUD operations are executed in the same manner so we delegate to doRequest in each case
 * @return {void}
 */
Ext.data.proxy.IServer.prototype.create = function() {};

/**
 * [Method] Performs the given destroy operation
 * @return {void}
 */
Ext.data.proxy.IServer.prototype.destroy = function() {};

/**
 * [Method] In ServerProxy subclasses the create read update and destroy methods all pass through to doRequest
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Ext.data.Operation object
 * @param {?=} callback Function The callback function to call when the Operation has completed
 * @param {?=} scope Object The scope in which to execute the callback
 * @return {void}
 */
Ext.data.proxy.IServer.prototype.doRequest = function(operation, callback, scope) {};

/**
 * [Method] Encodes the array of Ext util Filter objects into a string to be sent in the request url
 * @param {!Array<!Ext.util.IFilter>=} filters Ext.util.Filter[] The array of Filter objects
 * @return {string} String The encoded filters
 */
Ext.data.proxy.IServer.prototype.encodeFilters = function(filters) {};

/**
 * [Method] Encodes the array of Ext util Sorter objects into a string to be sent in the request url
 * @param {!Array<!Ext.util.ISorter>=} sorters Ext.util.Sorter[] The array of Sorter objects
 * @return {string} String The encoded sorters
 */
Ext.data.proxy.IServer.prototype.encodeSorters = function(sorters) {};

/**
 * [Method] Performs the given read operation
 * @return {void}
 */
Ext.data.proxy.IServer.prototype.read = function() {};

/**
 * [Method] Sets a value in the underlying extraParams
 * @param {string=} name String The key for the new value
 * @param {?=} value Object The value
 * @return {void}
 */
Ext.data.proxy.IServer.prototype.setExtraParam = function(name, value) {};

/**
 * [Method] Performs the given update operation
 * @return {void}
 */
Ext.data.proxy.IServer.prototype.update = function() {};
/**
 * @extends {Ext.data.proxy.IProxy}
 * @record
 * @struct
 */
Ext.data.IServerProxy = function() {};
 /** @type {?} */
Ext.data.IServerProxy.prototype.api;
 /** @type {string} */
Ext.data.IServerProxy.prototype.cacheString;
 /** @type {string} */
Ext.data.IServerProxy.prototype.directionParam;
 /** @type {?} */
Ext.data.IServerProxy.prototype.extraParams;
 /** @type {string} */
Ext.data.IServerProxy.prototype.filterParam;
 /** @type {string} */
Ext.data.IServerProxy.prototype.groupDirectionParam;
 /** @type {string} */
Ext.data.IServerProxy.prototype.groupParam;
 /** @type {string} */
Ext.data.IServerProxy.prototype.idParam;
 /** @type {string} */
Ext.data.IServerProxy.prototype.limitParam;
 /** @type {boolean} */
Ext.data.IServerProxy.prototype.noCache;
 /** @type {string} */
Ext.data.IServerProxy.prototype.pageParam;
 /** @type {boolean} */
Ext.data.IServerProxy.prototype.simpleGroupMode;
 /** @type {boolean} */
Ext.data.IServerProxy.prototype.simpleSortMode;
 /** @type {string} */
Ext.data.IServerProxy.prototype.sortParam;
 /** @type {string} */
Ext.data.IServerProxy.prototype.startParam;
 /** @type {number} */
Ext.data.IServerProxy.prototype.timeout;
 /** @type {string} */
Ext.data.IServerProxy.prototype.url;

/**
 * [Method] Optional callback function which can be used to clean up after a request has been completed
 * @param {!Ext.data.IRequest=} request Ext.data.Request The Request object
 * @param {boolean=} success Boolean True if the request was successful
 * @return {void}
 */
Ext.data.IServerProxy.prototype.afterRequest = function(request, success) {};

/**
 * [Method] Creates an Request object from Operation
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The operation to execute
 * @return {!Ext.data.IRequest} Ext.data.Request The request object
 */
Ext.data.IServerProxy.prototype.buildRequest = function(operation) {};

/**
 * [Method] Generates a url based on a given Ext data Request object
 * @param {!Ext.data.IRequest=} request Ext.data.Request The request object
 * @return {string} String The url
 */
Ext.data.IServerProxy.prototype.buildUrl = function(request) {};

/**
 * [Method] in a ServerProxy all four CRUD operations are executed in the same manner so we delegate to doRequest in each case
 * @return {void}
 */
Ext.data.IServerProxy.prototype.create = function() {};

/**
 * [Method] Performs the given destroy operation
 * @return {void}
 */
Ext.data.IServerProxy.prototype.destroy = function() {};

/**
 * [Method] In ServerProxy subclasses the create read update and destroy methods all pass through to doRequest
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation The Ext.data.Operation object
 * @param {?=} callback Function The callback function to call when the Operation has completed
 * @param {?=} scope Object The scope in which to execute the callback
 * @return {void}
 */
Ext.data.IServerProxy.prototype.doRequest = function(operation, callback, scope) {};

/**
 * [Method] Encodes the array of Ext util Filter objects into a string to be sent in the request url
 * @param {!Array<!Ext.util.IFilter>=} filters Ext.util.Filter[] The array of Filter objects
 * @return {string} String The encoded filters
 */
Ext.data.IServerProxy.prototype.encodeFilters = function(filters) {};

/**
 * [Method] Encodes the array of Ext util Sorter objects into a string to be sent in the request url
 * @param {!Array<!Ext.util.ISorter>=} sorters Ext.util.Sorter[] The array of Sorter objects
 * @return {string} String The encoded sorters
 */
Ext.data.IServerProxy.prototype.encodeSorters = function(sorters) {};

/**
 * [Method] Performs the given read operation
 * @return {void}
 */
Ext.data.IServerProxy.prototype.read = function() {};

/**
 * [Method] Sets a value in the underlying extraParams
 * @param {string=} name String The key for the new value
 * @param {?=} value Object The value
 * @return {void}
 */
Ext.data.IServerProxy.prototype.setExtraParam = function(name, value) {};

/**
 * [Method] Performs the given update operation
 * @return {void}
 */
Ext.data.IServerProxy.prototype.update = function() {};
/**
 * @extends {Ext.data.proxy.IWebStorage}
 * @record
 * @struct
 */
Ext.data.proxy.ISessionStorage = function() {};
/**
 * @extends {Ext.data.proxy.IWebStorage}
 * @record
 * @struct
 */
Ext.data.ISessionStorageProxy = function() {};
/**
 * @extends {Ext.data.proxy.IClient}
 * @record
 * @struct
 */
Ext.data.proxy.IWebStorage = function() {};
 /** @type {string} */
Ext.data.proxy.IWebStorage.prototype.id;
 /** @type {?} */
Ext.data.proxy.IWebStorage.prototype.cache;

/**
 * [Method] Destroys all records stored in the proxy and removes all keys and values used to support the proxy from the storage o
 * @return {void}
 */
Ext.data.proxy.IWebStorage.prototype.clear = function() {};

/**
 * [Method] inherit docs
 * @param {?=} operation Object
 * @param {?=} callback Object
 * @param {?=} scope Object
 * @return {void}
 */
Ext.data.proxy.IWebStorage.prototype.create = function(operation, callback, scope) {};

/**
 * [Method] inherit
 * @param {?=} operation Object
 * @param {?=} callback Object
 * @param {?=} scope Object
 * @return {void}
 */
Ext.data.proxy.IWebStorage.prototype.destroy = function(operation, callback, scope) {};

/**
 * [Method] inherit docs
 * @param {?=} operation Object
 * @param {?=} callback Object
 * @param {?=} scope Object
 * @return {void}
 */
Ext.data.proxy.IWebStorage.prototype.read = function(operation, callback, scope) {};

/**
 * [Method] Saves the given record in the Proxy
 * @param {!Ext.data.IModel=} record Ext.data.Model The model instance
 * @param {string=} id String The id to save the record under (defaults to the value of the record's getId() function)
 * @return {void}
 */
Ext.data.proxy.IWebStorage.prototype.setRecord = function(record, id) {};

/**
 * [Method] inherit docs
 * @param {?=} operation Object
 * @param {?=} callback Object
 * @param {?=} scope Object
 * @return {void}
 */
Ext.data.proxy.IWebStorage.prototype.update = function(operation, callback, scope) {};
/**
 * @extends {Ext.data.proxy.IClient}
 * @record
 * @struct
 */
Ext.data.IWebStorageProxy = function() {};
 /** @type {string} */
Ext.data.IWebStorageProxy.prototype.id;
 /** @type {?} */
Ext.data.IWebStorageProxy.prototype.cache;

/**
 * [Method] Destroys all records stored in the proxy and removes all keys and values used to support the proxy from the storage o
 * @return {void}
 */
Ext.data.IWebStorageProxy.prototype.clear = function() {};

/**
 * [Method] inherit docs
 * @param {?=} operation Object
 * @param {?=} callback Object
 * @param {?=} scope Object
 * @return {void}
 */
Ext.data.IWebStorageProxy.prototype.create = function(operation, callback, scope) {};

/**
 * [Method] inherit
 * @param {?=} operation Object
 * @param {?=} callback Object
 * @param {?=} scope Object
 * @return {void}
 */
Ext.data.IWebStorageProxy.prototype.destroy = function(operation, callback, scope) {};

/**
 * [Method] inherit docs
 * @param {?=} operation Object
 * @param {?=} callback Object
 * @param {?=} scope Object
 * @return {void}
 */
Ext.data.IWebStorageProxy.prototype.read = function(operation, callback, scope) {};

/**
 * [Method] Saves the given record in the Proxy
 * @param {!Ext.data.IModel=} record Ext.data.Model The model instance
 * @param {string=} id String The id to save the record under (defaults to the value of the record's getId() function)
 * @return {void}
 */
Ext.data.IWebStorageProxy.prototype.setRecord = function(record, id) {};

/**
 * [Method] inherit docs
 * @param {?=} operation Object
 * @param {?=} callback Object
 * @param {?=} scope Object
 * @return {void}
 */
Ext.data.IWebStorageProxy.prototype.update = function(operation, callback, scope) {};
/** @const */
Ext.data.reader = {};
/**
 * @extends {Ext.data.reader.IJson}
 * @record
 * @struct
 */
Ext.data.reader.IArray = function() {};
 /** @type {string} */
Ext.data.reader.IArray.prototype.successProperty;
 /** @type {string} */
Ext.data.reader.IArray.prototype.totalProperty;
/**
 * @extends {Ext.data.reader.IJson}
 * @record
 * @struct
 */
Ext.data.IArrayReader = function() {};
 /** @type {string} */
Ext.data.IArrayReader.prototype.successProperty;
 /** @type {string} */
Ext.data.IArrayReader.prototype.totalProperty;
/**
 * @extends {Ext.data.reader.IReader}
 * @record
 * @struct
 */
Ext.data.reader.IJson = function() {};
 /** @type {string} */
Ext.data.reader.IJson.prototype.metaProperty;
 /** @type {string} */
Ext.data.reader.IJson.prototype.record;
 /** @type {string} */
Ext.data.reader.IJson.prototype.root;
 /** @type {boolean} */
Ext.data.reader.IJson.prototype.useSimpleAccessors;
 /** @type {?} */
Ext.data.reader.IJson.prototype.jsonData;

/**
 * [Method] inherit docs
 * @param {?=} response Object
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet A ResultSet object
 */
Ext.data.reader.IJson.prototype.getResponseData = function(response) {};

/**
 * [Method] Reads a JSON object and returns a ResultSet
 * @param {?=} data Object The raw JSON data
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet A ResultSet containing model instances and meta data about the results
 */
Ext.data.reader.IJson.prototype.readRecords = function(data) {};
/**
 * @extends {Ext.data.reader.IReader}
 * @record
 * @struct
 */
Ext.data.IJsonReader = function() {};
 /** @type {string} */
Ext.data.IJsonReader.prototype.metaProperty;
 /** @type {string} */
Ext.data.IJsonReader.prototype.record;
 /** @type {string} */
Ext.data.IJsonReader.prototype.root;
 /** @type {boolean} */
Ext.data.IJsonReader.prototype.useSimpleAccessors;
 /** @type {?} */
Ext.data.IJsonReader.prototype.jsonData;

/**
 * [Method] inherit docs
 * @param {?=} response Object
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet A ResultSet object
 */
Ext.data.IJsonReader.prototype.getResponseData = function(response) {};

/**
 * [Method] Reads a JSON object and returns a ResultSet
 * @param {?=} data Object The raw JSON data
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet A ResultSet containing model instances and meta data about the results
 */
Ext.data.IJsonReader.prototype.readRecords = function(data) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.data.reader.IReader = function() {};
 /** @type {string} */
Ext.data.reader.IReader.prototype.idProperty;
 /** @type {boolean} */
Ext.data.reader.IReader.prototype.implicitIncludes;
 /** @type {string} */
Ext.data.reader.IReader.prototype.messageProperty;
 /** @type {boolean} */
Ext.data.reader.IReader.prototype.readRecordsOnFailure;
 /** @type {string} */
Ext.data.reader.IReader.prototype.root;
 /** @type {string} */
Ext.data.reader.IReader.prototype.successProperty;
 /** @type {string} */
Ext.data.reader.IReader.prototype.totalProperty;
 /** @type {?} */
Ext.data.reader.IReader.prototype.metaData;
 /** @type {?} */
Ext.data.reader.IReader.prototype.rawData;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.data.reader.IReader.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.reader.IReader.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.reader.IReader.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.data.reader.IReader.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.data.reader.IReader.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.data.reader.IReader.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.reader.IReader.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.reader.IReader.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Takes a raw response object as passed to the read method and returns the useful data segment from it
 * @param {?=} response Object The response object
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet A ResultSet object
 */
Ext.data.reader.IReader.prototype.getResponseData = function(response) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.data.reader.IReader.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.reader.IReader.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.reader.IReader.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.reader.IReader.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Reads the given response object
 * @param {?=} response Object The response object. This may be either an XMLHttpRequest object or a plain JS object
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet The parsed or default ResultSet object
 */
Ext.data.reader.IReader.prototype.read = function(response) {};

/**
 * [Method] Abstracts common functionality used by all Reader subclasses
 * @param {?=} data Object The raw data object
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet A ResultSet object
 */
Ext.data.reader.IReader.prototype.readRecords = function(data) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.data.reader.IReader.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.reader.IReader.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.reader.IReader.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.data.reader.IReader.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.data.reader.IReader.prototype.resumeEvents = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.data.reader.IReader.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.data.reader.IReader.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.reader.IReader.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.data.IReader = function() {};
 /** @type {string} */
Ext.data.IReader.prototype.idProperty;
 /** @type {boolean} */
Ext.data.IReader.prototype.implicitIncludes;
 /** @type {string} */
Ext.data.IReader.prototype.messageProperty;
 /** @type {boolean} */
Ext.data.IReader.prototype.readRecordsOnFailure;
 /** @type {string} */
Ext.data.IReader.prototype.root;
 /** @type {string} */
Ext.data.IReader.prototype.successProperty;
 /** @type {string} */
Ext.data.IReader.prototype.totalProperty;
 /** @type {?} */
Ext.data.IReader.prototype.metaData;
 /** @type {?} */
Ext.data.IReader.prototype.rawData;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.data.IReader.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IReader.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IReader.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.data.IReader.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.data.IReader.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.data.IReader.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IReader.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IReader.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Takes a raw response object as passed to the read method and returns the useful data segment from it
 * @param {?=} response Object The response object
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet A ResultSet object
 */
Ext.data.IReader.prototype.getResponseData = function(response) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.data.IReader.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IReader.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IReader.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IReader.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Reads the given response object
 * @param {?=} response Object The response object. This may be either an XMLHttpRequest object or a plain JS object
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet The parsed or default ResultSet object
 */
Ext.data.IReader.prototype.read = function(response) {};

/**
 * [Method] Abstracts common functionality used by all Reader subclasses
 * @param {?=} data Object The raw data object
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet A ResultSet object
 */
Ext.data.IReader.prototype.readRecords = function(data) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.data.IReader.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IReader.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IReader.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.data.IReader.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.data.IReader.prototype.resumeEvents = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.data.IReader.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.data.IReader.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IReader.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.data.IDataReader = function() {};
 /** @type {string} */
Ext.data.IDataReader.prototype.idProperty;
 /** @type {boolean} */
Ext.data.IDataReader.prototype.implicitIncludes;
 /** @type {string} */
Ext.data.IDataReader.prototype.messageProperty;
 /** @type {boolean} */
Ext.data.IDataReader.prototype.readRecordsOnFailure;
 /** @type {string} */
Ext.data.IDataReader.prototype.root;
 /** @type {string} */
Ext.data.IDataReader.prototype.successProperty;
 /** @type {string} */
Ext.data.IDataReader.prototype.totalProperty;
 /** @type {?} */
Ext.data.IDataReader.prototype.metaData;
 /** @type {?} */
Ext.data.IDataReader.prototype.rawData;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.data.IDataReader.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IDataReader.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IDataReader.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.data.IDataReader.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.data.IDataReader.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.data.IDataReader.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IDataReader.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.IDataReader.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Takes a raw response object as passed to the read method and returns the useful data segment from it
 * @param {?=} response Object The response object
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet A ResultSet object
 */
Ext.data.IDataReader.prototype.getResponseData = function(response) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.data.IDataReader.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IDataReader.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IDataReader.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.IDataReader.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Reads the given response object
 * @param {?=} response Object The response object. This may be either an XMLHttpRequest object or a plain JS object
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet The parsed or default ResultSet object
 */
Ext.data.IDataReader.prototype.read = function(response) {};

/**
 * [Method] Abstracts common functionality used by all Reader subclasses
 * @param {?=} data Object The raw data object
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet A ResultSet object
 */
Ext.data.IDataReader.prototype.readRecords = function(data) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.data.IDataReader.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IDataReader.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.IDataReader.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.data.IDataReader.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.data.IDataReader.prototype.resumeEvents = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.data.IDataReader.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.data.IDataReader.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.IDataReader.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.data.reader.IReader}
 * @record
 * @struct
 */
Ext.data.reader.IXml = function() {};
 /** @type {string} */
Ext.data.reader.IXml.prototype.namespace;
 /** @type {string} */
Ext.data.reader.IXml.prototype.record;
 /** @type {?} */
Ext.data.reader.IXml.prototype.xmlData;

/**
 * [Method] Normalizes the data object
 * @param {?=} data Object The raw data object
 * @return {?} Object The documentElement property of the data object if present, or the same object if not.
 */
Ext.data.reader.IXml.prototype.getData = function(data) {};

/**
 * [Method] inherit docs
 * @param {?=} response Object
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet A ResultSet object
 */
Ext.data.reader.IXml.prototype.getResponseData = function(response) {};

/**
 * [Method] Parses an XML document and returns a ResultSet containing the model instances
 * @param {?=} doc Object Parsed XML document
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet The parsed result set
 */
Ext.data.reader.IXml.prototype.readRecords = function(doc) {};
/**
 * @extends {Ext.data.reader.IReader}
 * @record
 * @struct
 */
Ext.data.IXmlReader = function() {};
 /** @type {string} */
Ext.data.IXmlReader.prototype.namespace;
 /** @type {string} */
Ext.data.IXmlReader.prototype.record;
 /** @type {?} */
Ext.data.IXmlReader.prototype.xmlData;

/**
 * [Method] Normalizes the data object
 * @param {?=} data Object The raw data object
 * @return {?} Object The documentElement property of the data object if present, or the same object if not.
 */
Ext.data.IXmlReader.prototype.getData = function(data) {};

/**
 * [Method] inherit docs
 * @param {?=} response Object
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet A ResultSet object
 */
Ext.data.IXmlReader.prototype.getResponseData = function(response) {};

/**
 * [Method] Parses an XML document and returns a ResultSet containing the model instances
 * @param {?=} doc Object Parsed XML document
 * @return {!Ext.data.IResultSet} Ext.data.ResultSet The parsed result set
 */
Ext.data.IXmlReader.prototype.readRecords = function(doc) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.IRequest = function() {};
 /** @type {string} */
Ext.data.IRequest.prototype.action;
 /** @type {string} */
Ext.data.IRequest.prototype.method;
 /** @type {?} */
Ext.data.IRequest.prototype.params;
 /** @type {string} */
Ext.data.IRequest.prototype.url;
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.IResultSet = function() {};
 /** @type {number} */
Ext.data.IResultSet.prototype.count;
 /** @type {boolean} */
Ext.data.IResultSet.prototype.loaded;
 /** @type {!Array<!Ext.data.IModel>} */
Ext.data.IResultSet.prototype.records;
 /** @type {boolean} */
Ext.data.IResultSet.prototype.success;
 /** @type {number} */
Ext.data.IResultSet.prototype.total;
 /** @type {number} */
Ext.data.IResultSet.prototype.totalRecords;
/**
 * @extends {Ext.data.IIdGenerator}
 * @record
 * @struct
 */
Ext.data.ISequentialIdGenerator = function() {};
 /** @type {string} */
Ext.data.ISequentialIdGenerator.prototype.prefix;
 /** @type {number} */
Ext.data.ISequentialIdGenerator.prototype.seed;

/**
 * [Method] Generates and returns the next id
 * @return {string} String The next id.
 */
Ext.data.ISequentialIdGenerator.prototype.generate = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.ISortTypes = function() {};
/**
 * @constructor
 * @struct
 */
Ext.data.SortTypes = function() {};
 /** @type {!Ext.IClass} */
Ext.data.SortTypes.self;
 /** @type {!RegExp} */
Ext.data.SortTypes.stripTagsRE;

/**
 * [Method] Date sorting
 * @param {?=} s Object The value being converted
 * @return {number} Number The comparison value
 */
Ext.data.SortTypes.asDate = function(s) {};

/**
 * [Method] Float sorting
 * @param {?=} s Object The value being converted
 * @return {number} Number The comparison value
 */
Ext.data.SortTypes.asFloat = function(s) {};

/**
 * [Method] Integer sorting
 * @param {?=} s Object The value being converted
 * @return {number} Number The comparison value
 */
Ext.data.SortTypes.asInt = function(s) {};

/**
 * [Method] Strips all HTML tags to sort on text only
 * @param {?=} s Object The value being converted
 * @return {string} String The comparison value
 */
Ext.data.SortTypes.asText = function(s) {};

/**
 * [Method] Case insensitive string
 * @param {?=} s Object The value being converted
 * @return {string} String The comparison value
 */
Ext.data.SortTypes.asUCString = function(s) {};

/**
 * [Method] Strips all HTML tags to sort on text only  Case insensitive
 * @param {?=} s Object The value being converted
 * @return {string} String The comparison value
 */
Ext.data.SortTypes.asUCText = function(s) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.data.SortTypes.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.data.SortTypes.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.data.SortTypes.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.data.SortTypes.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.data.SortTypes.initConfig = function(config) {};

/**
 * [Method] Default sort that does nothing
 * @param {?=} s Object The value being converted
 * @return {?} Object The comparison value
 */
Ext.data.SortTypes.none = function(s) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.data.SortTypes.statics = function() {};
/**
 * @extends {Ext.data.IAbstractStore}
 * @record
 * @struct
 */
Ext.data.IStore = function() {};
 /** @type {boolean} */
Ext.data.IStore.prototype.autoDestroy;
 /** @type {boolean} */
Ext.data.IStore.prototype.buffered;
 /** @type {boolean} */
Ext.data.IStore.prototype.clearOnPageLoad;
 /** @type {boolean} */
Ext.data.IStore.prototype.clearRemovedOnLoad;
 /** @type {?} */
Ext.data.IStore.prototype.data;
 /** @type {string} */
Ext.data.IStore.prototype.groupDir;
 /** @type {string} */
Ext.data.IStore.prototype.groupField;
 /** @type {!Ext.util.IMixedCollection} */
Ext.data.IStore.prototype.groupers;
 /** @type {number} */
Ext.data.IStore.prototype.leadingBufferZone;
 /** @type {number} */
Ext.data.IStore.prototype.pageSize;
 /** @type {?} */
Ext.data.IStore.prototype.proxy;
 /** @type {number} */
Ext.data.IStore.prototype.purgePageCount;
 /** @type {boolean} */
Ext.data.IStore.prototype.remoteFilter;
 /** @type {boolean} */
Ext.data.IStore.prototype.remoteGroup;
 /** @type {boolean} */
Ext.data.IStore.prototype.remoteSort;
 /** @type {boolean} */
Ext.data.IStore.prototype.sortOnFilter;
 /** @type {number} */
Ext.data.IStore.prototype.trailingBufferZone;
 /** @type {number} */
Ext.data.IStore.prototype.currentPage;
 /** @type {!Ext.util.IMixedCollection} */
Ext.data.IStore.prototype.snapshot;

/**
 * [Method] Adds Model instance to the Store
 * @param {?=} model Ext.data.Model[]/Ext.data.Model.../Object[]/Object... An array of Model instances or Model configuration objects, or variable number of Model instance or config arguments.
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] The model instances that were added
 */
Ext.data.IStore.prototype.add = function(model) {};

/**
 * [Method] Adds a new Filter to this Store s filter set and by default applys the updated filter set to the Store s unfiltered
 * @param {?=} filters Object[]/Ext.util.Filter[] The set of filters to add to the current filter set.
 * @param {boolean=} applyFilters Boolean Pass as false to add the filter but not apply the updated filter set.
 * @return {void}
 */
Ext.data.IStore.prototype.addFilter = function(filters, applyFilters) {};

/**
 * [Method] Local sort only Inserts the passed Record into the Store at the index where it should go based on the current sort
 * @param {!Ext.data.IRecord=} record Ext.data.Record
 * @return {void}
 */
Ext.data.IStore.prototype.addSorted = function(record) {};

/**
 * [Method] Runs the aggregate function for all the records in the store
 * @param {?=} fn Function The function to execute. The function is called with a single parameter, an array of records for that group.
 * @param {?=} scope Object The scope to execute the function in. Defaults to the store.
 * @param {boolean=} grouped Boolean True to perform the operation for each group in the store. The value returned will be an object literal with the key being the group name and the group average being the value. The grouped parameter is only honored if the store has a groupField.
 * @param {!Array<?>=} args Array Any arguments to append to the function call
 * @return {?} Object An object literal with the group names and their appropriate values.
 */
Ext.data.IStore.prototype.aggregate = function(fn, scope, grouped, args) {};

/**
 * [Method] Gets the average value in the store
 * @param {string=} field String The field in each record
 * @param {boolean=} grouped Boolean True to perform the operation for each group in the store. The value returned will be an object literal with the key being the group name and the group average being the value. The grouped parameter is only honored if the store has a groupField.
 * @return {?} Object The average value, if no items exist, 0.
 */
Ext.data.IStore.prototype.average = function(field, grouped) {};

/**
 * [Method] Reverts to a view of the Record cache with no filtering applied
 * @param {boolean=} suppressEvent Boolean If true the filter is cleared silently. For a locally filtered Store, this means that the filter collection is cleared without firing the datachanged event. For a remotely filtered Store, this means that the filter collection is cleared, but the store is not reloaded from the server.
 * @return {void}
 */
Ext.data.IStore.prototype.clearFilter = function(suppressEvent) {};

/**
 * [Method] Clear any groupers in the store
 * @return {void}
 */
Ext.data.IStore.prototype.clearGrouping = function() {};

/**
 * [Method] Collects unique values for a particular dataIndex from this store
 * @param {string=} dataIndex String The property to collect
 * @param {boolean=} allowNull Boolean Pass true to allow null, undefined or empty string values
 * @param {boolean=} bypassFilter Boolean Pass true to collect from all records, even ones which are filtered.
 * @return {!Array<?>} Object[] An array of the unique values
 */
Ext.data.IStore.prototype.collect = function(dataIndex, allowNull, bypassFilter) {};

/**
 * [Method] Commits all Records with outstanding changes
 * @return {void}
 */
Ext.data.IStore.prototype.commitChanges = function() {};

/**
 * [Method] Gets the count of items in the store
 * @param {boolean=} grouped Boolean True to perform the operation for each group in the store. The value returned will be an object literal with the key being the group name and the count for each group being the value. The grouped parameter is only honored if the store has a groupField.
 * @return {number} Number the count
 */
Ext.data.IStore.prototype.count = function(grouped) {};

/**
 * [Method] Calls the specified function for each record in the store
 * @param {?=} fn Function The function to call. The Record is passed as the first parameter. Returning false aborts and exits the iteration.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current record in the iteration.
 * @return {void}
 */
Ext.data.IStore.prototype.each = function(fn, scope) {};

/**
 * [Method] Filters the loaded set of records by a given set of filters
 * @param {?=} filters Object[]/Ext.util.Filter[]/String The set of filters to apply to the data. These are stored internally on the store, but the filtering itself is done on the Store's MixedCollection. See MixedCollection's filter method for filter syntax. Alternatively, pass in a property string. If no parameters are passed, the Store's existing filter set is applied.
 * @param {string=} value String value to filter by (only if using a property string as the first argument)
 * @return {void}
 */
Ext.data.IStore.prototype.filter = function(filters, value) {};

/**
 * [Method] Filters by a function
 * @param {?=} fn Function The function to be called. It will be passed the following parameters:
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this Store.
 * @return {void}
 */
Ext.data.IStore.prototype.filterBy = function(fn, scope) {};

/**
 * [Method] Finds the index of the first matching Record in this store by a specific field value
 * @param {string=} fieldName String The name of the Record field to test.
 * @param {?=} value String/RegExp Either a string that the field value should begin with, or a RegExp to test against the field.
 * @param {number=} startIndex Number The index to start searching at
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison
 * @param {boolean=} exactMatch Boolean True to force exact match (^ and $ characters added to the regex).
 * @return {number} Number The matched index or -1
 */
Ext.data.IStore.prototype.find = function(fieldName, value, startIndex, anyMatch, caseSensitive, exactMatch) {};

/**
 * [Method] Find the index of the first matching Record in this Store by a function
 * @param {?=} fn Function The function to be called. It will be passed the following parameters:
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this Store.
 * @param {number=} startIndex Number The index to start searching at
 * @return {number} Number The matched index or -1
 */
Ext.data.IStore.prototype.findBy = function(fn, scope, startIndex) {};

/**
 * [Method] Finds the index of the first matching Record in this store by a specific field value
 * @param {string=} fieldName String The name of the Record field to test.
 * @param {?=} value Object The value to match the field against.
 * @param {number=} startIndex Number The index to start searching at
 * @return {number} Number The matched index or -1
 */
Ext.data.IStore.prototype.findExact = function(fieldName, value, startIndex) {};

/**
 * [Method] Finds the first matching Record in this store by a specific field value
 * @param {string=} fieldName String The name of the Record field to test.
 * @param {?=} value String/RegExp Either a string that the field value should begin with, or a RegExp to test against the field.
 * @param {number=} startIndex Number The index to start searching at
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison
 * @param {boolean=} exactMatch Boolean True to force exact match (^ and $ characters added to the regex).
 * @return {!Ext.data.IModel} Ext.data.Model The matched record or null
 */
Ext.data.IStore.prototype.findRecord = function(fieldName, value, startIndex, anyMatch, caseSensitive, exactMatch) {};

/**
 * [Method] Convenience function for getting the first model instance in the store
 * @param {boolean=} grouped Boolean True to perform the operation for each group in the store. The value returned will be an object literal with the key being the group name and the first record being the value. The grouped parameter is only honored if the store has a groupField.
 * @return {?} Ext.data.Model/undefined The first model instance in the store, or undefined
 */
Ext.data.IStore.prototype.first = function(grouped) {};

/**
 * [Method] Get the Record at the specified index
 * @param {number=} index Number The index of the Record to find.
 * @return {!Ext.data.IModel} Ext.data.Model The Record at the passed index. Returns undefined if not found.
 */
Ext.data.IStore.prototype.getAt = function(index) {};

/**
 * [Method] Get the Record with the specified id
 * @param {?=} id Mixed The id of the Record to find.
 * @return {!Ext.data.IModel} Ext.data.Model The Record with the passed id. Returns null if not found.
 */
Ext.data.IStore.prototype.getById = function(id) {};

/**
 * [Method] Gets the number of records in store
 * @return {number} Number The number of Records in the Store.
 */
Ext.data.IStore.prototype.getCount = function() {};

/**
 * [Method] Returns the string to group on for a given model instance
 * @param {!Ext.data.IModel=} instance Ext.data.Model The model instance
 * @return {string} String The string to compare when forming groups
 */
Ext.data.IStore.prototype.getGroupString = function(instance) {};

/**
 * [Method] Returns an array containing the result of applying grouping to the records in this store
 * @param {string=} groupName String Pass in an optional groupName argument to access a specific group as defined by getGroupString.
 * @return {?} Object/Object[] The grouped data
 */
Ext.data.IStore.prototype.getGroups = function(groupName) {};

/**
 * [Method] inherit docs
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] The Model instances
 */
Ext.data.IStore.prototype.getNewRecords = function() {};

/**
 * [Method] Determines the page from a record index
 * @param {number=} index Number The record index
 * @return {number} Number The page the record belongs to
 */
Ext.data.IStore.prototype.getPageFromRecordIndex = function(index) {};

/**
 * [Method] Gathers a range of Records between specified indices
 * @param {number=} start Number The starting index. Defaults to zero for non buffered Stores.
 * @param {number=} end Number The ending index. Defaults to the last Record for non buffered Stores.
 * @param {?=} options Object Used when the Store is {\@link buffered] and the range may not be available synchronously.
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] An array of records if the records are immediately available. For buffered stores, you should pass the callback option unless you know that the range will be present - see rangeCached.
 */
Ext.data.IStore.prototype.getRange = function(start, end, options) {};

/**
 * [Method] Returns the total number of Model instances that the Proxy indicates exist
 * @return {number} Number The total number of Model instances available via the Proxy. 0 returned if no value has been set via the reader.
 */
Ext.data.IStore.prototype.getTotalCount = function() {};

/**
 * [Method] inherit docs
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] The updated Model instances
 */
Ext.data.IStore.prototype.getUpdatedRecords = function() {};

/**
 * [Method] Groups data inside the store
 * @param {?=} groupers String/Object[] Either a string name of one of the fields in this Store's configured Model, or an Array of grouper configurations.
 * @param {string=} direction String The overall direction to group the data by.
 * @return {void}
 */
Ext.data.IStore.prototype.group = function(groupers, direction) {};

/**
 * [Method] Guarantee a specific range this will load the store with a range that must be the pageSize or smaller and take car
 * @param {?=} start Object
 * @param {?=} end Object
 * @param {?=} callback Object
 * @param {?=} scope Object
 * @param {?=} options Object
 * @return {void}
 */
Ext.data.IStore.prototype.guaranteeRange = function(start, end, callback, scope, options) {};

/**
 * [Method] Get the index of the record within the store
 * @param {!Ext.data.IModel=} record Ext.data.Model The Ext.data.Model object to find.
 * @return {number} Number The index of the passed Record. Returns -1 if not found.
 */
Ext.data.IStore.prototype.indexOf = function(record) {};

/**
 * [Method] Get the index within the store of the Record with the passed id
 * @param {string=} id String The id of the Record to find.
 * @return {number} Number The index of the Record. Returns -1 if not found.
 */
Ext.data.IStore.prototype.indexOfId = function(id) {};

/**
 * [Method] Get the index within the entire dataset
 * @param {!Ext.data.IModel=} record Ext.data.Model The Ext.data.Model object to find.
 * @return {number} Number The index of the passed Record. Returns -1 if not found.
 */
Ext.data.IStore.prototype.indexOfTotal = function(record) {};

/**
 * [Method] Inserts Model instances into the Store at the given index and fires the add event
 * @param {number=} index Number The start index at which to insert the passed Records.
 * @param {!Array<!Ext.data.IModel>=} records Ext.data.Model[] An Array of Ext.data.Model objects to add to the store.
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] records The added records
 */
Ext.data.IStore.prototype.insert = function(index, records) {};

/**
 * [Method] Returns true if this store is currently filtered
 * @return {boolean} Boolean
 */
Ext.data.IStore.prototype.isFiltered = function() {};

/**
 * [Method] Checks if the store is currently grouped
 * @return {boolean} Boolean true if the store is grouped.
 */
Ext.data.IStore.prototype.isGrouped = function() {};

/**
 * [Method] Convenience function for getting the last model instance in the store
 * @param {boolean=} grouped Boolean True to perform the operation for each group in the store. The value returned will be an object literal with the key being the group name and the last record being the value. The grouped parameter is only honored if the store has a groupField.
 * @return {?} Ext.data.Model/undefined The last model instance in the store, or undefined
 */
Ext.data.IStore.prototype.last = function(grouped) {};

/**
 * [Method] Loads data into the Store via the configured proxy
 * @param {?=} options Object/Function config object, passed into the Ext.data.Operation object before loading. Additionally addRecords: true can be specified to add these records to the existing records, default is to remove the Store's existing records first.
 * @return {void}
 */
Ext.data.IStore.prototype.load = function(options) {};

/**
 * [Method] Loads an array of data straight into the Store
 * @param {?=} data Ext.data.Model[]/Object[] Array of data to load. Any non-model instances will be cast into model instances first.
 * @param {boolean=} append Boolean true to add the records to the existing records in the store, false to remove the old ones first.
 * @return {void}
 */
Ext.data.IStore.prototype.loadData = function(data, append) {};

/**
 * [Method] Loads a given page of data by setting the start and limit values appropriately
 * @param {number=} page Number The number of the page to load.
 * @param {?=} options Object See options for load.
 * @return {void}
 */
Ext.data.IStore.prototype.loadPage = function(page, options) {};

/**
 * [Method] Loads data via the bound Proxy s reader Use this method if you are attempting to load data and want to utilize the c
 * @param {!Array<?>=} data Object[] The full JSON object you'd like to load into the Data store.
 * @param {boolean=} append Boolean true to add the records to the existing records in the store, false to remove the old ones first.
 * @return {void}
 */
Ext.data.IStore.prototype.loadRawData = function(data, append) {};

/**
 * [Method] Loads an array of model instances into the store fires the datachanged event
 * @param {!Array<!Ext.data.IModel>=} records Ext.data.Model[] The array of records to load
 * @param {?=} options Object
 * @return {void}
 */
Ext.data.IStore.prototype.loadRecords = function(records, options) {};

/**
 * [Method] Gets the maximum value in the store
 * @param {string=} field String The field in each record
 * @param {boolean=} grouped Boolean True to perform the operation for each group in the store. The value returned will be an object literal with the key being the group name and the maximum in the group being the value. The grouped parameter is only honored if the store has a groupField.
 * @return {?} Object The maximum value, if no items exist, undefined.
 */
Ext.data.IStore.prototype.max = function(field, grouped) {};

/**
 * [Method] Gets the minimum value in the store
 * @param {string=} field String The field in each record
 * @param {boolean=} grouped Boolean True to perform the operation for each group in the store. The value returned will be an object literal with the key being the group name and the minimum in the group being the value. The grouped parameter is only honored if the store has a groupField.
 * @return {?} Object The minimum value, if no items exist, undefined.
 */
Ext.data.IStore.prototype.min = function(field, grouped) {};

/**
 * [Method] Loads the next page in the current data set
 * @param {?=} options Object See options for load
 * @return {void}
 */
Ext.data.IStore.prototype.nextPage = function(options) {};

/**
 * [Method] Prefetches data into the store using its configured proxy
 * @param {?=} options Object config object, passed into the Ext.data.Operation object before loading. See load
 * @return {void}
 */
Ext.data.IStore.prototype.prefetch = function(options) {};

/**
 * [Method] Prefetches a page of data
 * @param {number=} page Number The page to prefetch
 * @param {?=} options Object config object, passed into the Ext.data.Operation object before loading. See load
 * @return {void}
 */
Ext.data.IStore.prototype.prefetchPage = function(page, options) {};

/**
 * [Method] Ensures that the specified range of rows is present in the cache
 * @param {?=} start Object
 * @param {?=} end Object
 * @return {void}
 */
Ext.data.IStore.prototype.prefetchRange = function(start, end) {};

/**
 * [Method] Loads the previous page in the current data set
 * @param {?=} options Object See options for load
 * @return {void}
 */
Ext.data.IStore.prototype.previousPage = function(options) {};

/**
 * [Method] Query all the cached records in this Store by name value pair
 * @param {string=} property String The property to create the filter function for
 * @param {?=} value String/RegExp The string/regex to compare the property value to
 * @param {boolean=} anyMatch Boolean true if we don't care if the filter value is not the full value.
 * @param {boolean=} caseSensitive Boolean true to create a case-sensitive regex.
 * @param {boolean=} exactMatch Boolean true to force exact match (^ and $ characters added to the regex). Ignored if anyMatch is true.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection Returns an Ext.util.MixedCollection of the matched records
 */
Ext.data.IStore.prototype.query = function(property, value, anyMatch, caseSensitive, exactMatch) {};

/**
 * [Method] Query all the cached records in this Store using a filtering function
 * @param {?=} fn Function The function to be called. It will be passed the following parameters:
 * @param {?=} scope Object The scope (this reference) in which the function is executed Defaults to this Store.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection Returns an Ext.util.MixedCollection of the matched records
 */
Ext.data.IStore.prototype.queryBy = function(fn, scope) {};

/**
 * [Method] Rejects outstanding changes on all modified records and re insert any records that were removed locally
 * @return {void}
 */
Ext.data.IStore.prototype.rejectChanges = function() {};

/**
 * [Method] Reloads the store using the last options passed to the load method
 * @param {?=} options Object
 * @return {void}
 */
Ext.data.IStore.prototype.reload = function(options) {};

/**
 * [Method] Removes the specified record s from the Store firing the remove event for each instance that is removed
 * @param {?=} records Ext.data.Model/Ext.data.Model[]/Number/Number[] Model instance or array of instances to remove or an array of indices from which to remove records.
 * @return {void}
 */
Ext.data.IStore.prototype.remove = function(records) {};

/**
 * [Method] Removes all items from the store
 * @param {boolean=} silent Boolean Pass true to prevent the record bulkremove and clear events from being fired.
 * @return {void}
 */
Ext.data.IStore.prototype.removeAll = function(silent) {};

/**
 * [Method] Removes the model instance s at the given index
 * @param {number=} index Number The record index
 * @param {number=} count Number The number of records to delete
 * @return {void}
 */
Ext.data.IStore.prototype.removeAt = function(index, count) {};

/**
 * [Method] Removes an individual Filter from the current filter set using the passed Filter Filter id and by default applys the
 * @param {?=} toRemove Mixed The id of a Filter to remove from the filter set, or a Filter instance to remove.
 * @param {boolean=} applyFilters Boolean Pass as false to remove the filter but not apply the updated filter set. If null is passed, all anonymous Filters (Filters with no id property) will be removed.
 * @return {void}
 */
Ext.data.IStore.prototype.removeFilter = function(toRemove, applyFilters) {};

/**
 * [Method] because prefetchData is stored by index this invalidates all of the prefetchedData
 * @return {!Array<!Ext.util.ISorter>} Ext.util.Sorter[]
 */
Ext.data.IStore.prototype.sort = function() {};

/**
 * [Method] Sums the value of field for each record in store and returns the result
 * @param {string=} field String A field in each record
 * @param {boolean=} grouped Boolean True to perform the operation for each group in the store. The value returned will be an object literal with the key being the group name and the sum for that group being the value. The grouped parameter is only honored if the store has a groupField.
 * @return {number} Number The sum
 */
Ext.data.IStore.prototype.sum = function(field, grouped) {};
/**
 * @extends {Ext.util.IMixedCollection}
 * @record
 * @struct
 */
Ext.data.IStoreManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.data.StoreManager = function() {};
 /** @type {?} */
Ext.data.StoreManager.hasListeners;
 /** @type {boolean} */
Ext.data.StoreManager.isMixedCollection;
 /** @type {boolean} */
Ext.data.StoreManager.isObservable;
 /** @type {boolean} */
Ext.data.StoreManager.isSortable;
 /** @type {!Ext.IClass} */
Ext.data.StoreManager.self;
 /** @type {!Ext.util.IMixedCollection} */
Ext.data.StoreManager.sorters;

/**
 * [Method] Adds an item to the collection
 * @param {?=} key String/Object The key to associate with the item, or the new item. If a getKey implementation was specified for this MixedCollection, or if the key of the stored items is in a property called id, the MixedCollection will be able to derive the key for the new item. In this case just pass the new item in this parameter.
 * @param {?=} obj Object The item to add.
 * @return {?} Object The item added.
 */
Ext.data.StoreManager.add = function(key, obj) {};

/**
 * [Method] Adds all elements of an Array or an Object to the collection
 * @param {?=} objs Object/Array An Object containing properties which will be added to the collection, or an Array of values, each of which are added to the collection. Functions references will be added to the collection if allowFunctions has been set to true.
 * @return {void}
 */
Ext.data.StoreManager.addAll = function(objs) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.data.StoreManager.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.StoreManager.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.StoreManager.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.data.StoreManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.data.StoreManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.data.StoreManager.callSuper = function(args) {};

/**
 * [Method] Removes all items from the collection
 * @return {void}
 */
Ext.data.StoreManager.clear = function() {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.data.StoreManager.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.data.StoreManager.clearManagedListeners = function() {};

/**
 * [Method] Creates a shallow copy of this collection
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection
 */
Ext.data.StoreManager.clone = function() {};

/**
 * [Method] Collects unique values of a particular property in this MixedCollection
 * @param {string=} property String The property to collect on
 * @param {string=} root String 'root' property to extract the first argument from. This is used mainly when summing fields in records, where the fields are all stored inside the 'data' object
 * @param {boolean=} allowBlank Boolean Pass true to allow null, undefined or empty string values
 * @return {!Array<?>} Array The unique values
 */
Ext.data.StoreManager.collect = function(property, root, allowBlank) {};

/**
 * [Method] Returns true if the collection contains the passed Object as an item
 * @param {?=} o Object The Object to look for in the collection.
 * @return {boolean} Boolean True if the collection contains the Object as an item.
 */
Ext.data.StoreManager.contains = function(o) {};

/**
 * [Method] Returns true if the collection contains the passed Object as a key
 * @param {string=} key String The key to look for in the collection.
 * @return {boolean} Boolean True if the collection contains the Object as a key.
 */
Ext.data.StoreManager.containsKey = function(key) {};

/**
 * [Method] Executes the specified function once for every item in the collection
 * @param {?=} fn Function The function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current item in the iteration.
 * @return {void}
 */
Ext.data.StoreManager.each = function(fn, scope) {};

/**
 * [Method] Executes the specified function once for every key in the collection passing each key and its associated item as th
 * @param {?=} fn Function The function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {void}
 */
Ext.data.StoreManager.eachKey = function(fn, scope) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.data.StoreManager.enableBubble = function(eventNames) {};

/**
 * [Method] Filters the objects in this collection by a set of Filters or by a single property value pair with optional paramete
 * @param {?=} property Ext.util.Filter[]/String A property on your objects, or an array of Filter objects
 * @param {?=} value String/RegExp Either string that the property values should start with or a RegExp to test against the property
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection The new filtered collection
 */
Ext.data.StoreManager.filter = function(property, value, anyMatch, caseSensitive) {};

/**
 * [Method] Filter by a function
 * @param {?=} fn Function The function to be called.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this MixedCollection.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection The new filtered collection
 */
Ext.data.StoreManager.filterBy = function(fn, scope) {};

/**
 * [Method] Returns the first item in the collection which elicits a true return value from the passed selection function
 * @return {void}
 */
Ext.data.StoreManager.find = function() {};

/**
 * [Method] Returns the first item in the collection which elicits a true return value from the passed selection function
 * @param {?=} fn Function The selection function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {?} Object The first item in the collection which returned true from the selection function, or null if none was found.
 */
Ext.data.StoreManager.findBy = function(fn, scope) {};

/**
 * [Method] Finds the index of the first matching object in this collection by a specific property value
 * @param {string=} property String The name of a property on your objects.
 * @param {?=} value String/RegExp A string that the property values should start with or a RegExp to test against the property.
 * @param {number=} start Number The index to start searching at.
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning.
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison.
 * @return {number} Number The matched index or -1
 */
Ext.data.StoreManager.findIndex = function(property, value, start, anyMatch, caseSensitive) {};

/**
 * [Method] Find the index of the first matching object in this collection by a function
 * @param {?=} fn Function The function to be called.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this MixedCollection.
 * @param {number=} start Number The index to start searching at.
 * @return {number} Number The matched index or -1
 */
Ext.data.StoreManager.findIndexBy = function(fn, scope, start) {};

/**
 * [Method] Calculates the insertion index of the new item based upon the comparison function passed or the current sort order
 * @param {?=} newItem Object The new object to find the insertion position of.
 * @param {?=} sorterFn Function The function to sort by. This is the same as the sorting function passed to sortBy. It accepts 2 items from this MixedCollection, and returns -1 0, or 1 depending on the relative sort positions of the 2 compared items. If omitted, a function generated from the currently defined set of sorters will be used.
 * @return {number} Number The insertion point to add the new item into this MixedCollection at using insert
 */
Ext.data.StoreManager.findInsertionIndex = function(newItem, sorterFn) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.StoreManager.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.StoreManager.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the first item in the collection
 * @return {?} Object the first item in the collection..
 */
Ext.data.StoreManager.first = function() {};

/**
 * [Method] Returns a comparator function which compares two items and returns 1 0 or 1 depending on the currently defined set
 * @return {void}
 */
Ext.data.StoreManager.generateComparator = function() {};

/**
 * [Method] Returns the item associated with the passed key OR index
 * @param {?=} key String/Number The key or index of the item.
 * @return {?} Object If the item is found, returns the item. If the item was not found, returns undefined. If an item was found, but is a Class, returns null.
 */
Ext.data.StoreManager.get = function(key) {};

/**
 * [Method] Returns the item at the specified index
 * @param {number=} index Number The index of the item.
 * @return {?} Object The item at the specified index.
 */
Ext.data.StoreManager.getAt = function(index) {};

/**
 * [Method] Returns the item associated with the passed key
 * @param {?=} key String/Number The key of the item.
 * @return {?} Object The item associated with the passed key.
 */
Ext.data.StoreManager.getByKey = function(key) {};

/**
 * [Method] Returns the number of items in the collection
 * @return {number} Number the number of items in the collection.
 */
Ext.data.StoreManager.getCount = function() {};

/**
 * [Method] Gets the first sorter from the sorters collection excluding any groupers that may be in place
 * @return {!Ext.util.ISorter} Ext.util.Sorter The sorter, null if none exist
 */
Ext.data.StoreManager.getFirstSorter = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.data.StoreManager.getInitialConfig = function(name) {};

/**
 * [Method] getKey implementation for MixedCollection
 * @param {?=} o Object
 * @return {?} Object The key for the passed item.
 */
Ext.data.StoreManager.getKey = function(o) {};

/**
 * [Method] Returns a range of items in this collection
 * @param {number=} startIndex Number The starting index. Defaults to 0.
 * @param {number=} endIndex Number The ending index. Defaults to the last item.
 * @return {!Array<?>} Array An array of items
 */
Ext.data.StoreManager.getRange = function(startIndex, endIndex) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.data.StoreManager.hasListener = function(eventName) {};

/**
 * [Method] Returns index within the collection of the passed Object
 * @param {?=} o Object The item to find the index of.
 * @return {number} Number index of the item. Returns -1 if not found.
 */
Ext.data.StoreManager.indexOf = function(o) {};

/**
 * [Method] Returns index within the collection of the passed key
 * @param {string=} key String The key to find the index of.
 * @return {number} Number index of the key.
 */
Ext.data.StoreManager.indexOfKey = function(key) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.data.StoreManager.initConfig = function(config) {};

/**
 * [Method] Performs initialization of this mixin
 * @return {void}
 */
Ext.data.StoreManager.initSortable = function() {};

/**
 * [Method] Inserts an item at the specified index in the collection
 * @param {number=} index Number The index to insert the item at.
 * @param {?=} key String/Object/String[]/Object[] The key to associate with the new item, or the item itself. May also be an array of either to insert multiple items at once.
 * @param {?=} o Object/Object[] If the second parameter was a key, the new item. May also be an array to insert multiple items at once.
 * @return {?} Object The item inserted or an array of items inserted.
 */
Ext.data.StoreManager.insert = function(index, key, o) {};

/**
 * [Method] Returns the last item in the collection
 * @return {?} Object the last item in the collection..
 */
Ext.data.StoreManager.last = function() {};

/**
 * [Method] Gets a registered Store by id
 * @param {?=} store String/Object The id of the Store, or a Store instance, or a store configuration
 * @return {!Ext.data.IStore} Ext.data.Store
 */
Ext.data.StoreManager.lookup = function(store) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.StoreManager.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.StoreManager.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.StoreManager.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Registers one or more Stores with the StoreManager
 * @param {!Ext.data.IStore} stores Ext.data.Store... Any number of Store instances
 * @return {void}
 */
Ext.data.StoreManager.register = function(stores) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.data.StoreManager.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Remove an item from the collection
 * @param {?=} o Object The item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.data.StoreManager.remove = function(o) {};

/**
 * [Method] Remove all items in the collection
 * @param {!Array<?>=} items Array An array of items to be removed.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection this object
 */
Ext.data.StoreManager.removeAll = function(items) {};

/**
 * [Method] Remove an item from a specified index in the collection
 * @param {number=} index Number The index within the collection of the item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.data.StoreManager.removeAt = function(index) {};

/**
 * [Method] Removes an item associated with the passed key fom the collection
 * @param {string=} key String The key of the item to remove. If null is passed, all objects which yielded no key from the configured getKey function are removed.
 * @return {?} Object Only returned if removing at a specified key. The item removed or false if no item was removed.
 */
Ext.data.StoreManager.removeAtKey = function(key) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.StoreManager.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.StoreManager.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Remove a range of items starting at a specified index in the collection
 * @param {number=} index Number The index within the collection of the item to remove.
 * @param {number=} removeCount Number The nuber of items to remove beginning at the specified index.
 * @return {?} Object The last item removed or false if no item was removed.
 */
Ext.data.StoreManager.removeRange = function(index, removeCount) {};

/**
 * [Method] Reorders each of the items based on a mapping from old index to new index
 * @param {?=} mapping Object Mapping from old item index to new item index
 * @return {void}
 */
Ext.data.StoreManager.reorder = function(mapping) {};

/**
 * [Method] Replaces an item in the collection
 * @param {string=} key String The key associated with the item to replace, or the replacement item. If you supplied a getKey implementation for this MixedCollection, or if the key of your stored items is in a property called id, then the MixedCollection will be able to derive the key of the replacement item. If you want to replace an item with one having the same key value, then just pass the replacement item in this parameter.
 * @param {?=} o Object {Object} o (optional) If the first parameter passed was a key, the item to associate with that key.
 * @return {?} Object The new item.
 */
Ext.data.StoreManager.replace = function(key, o) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.data.StoreManager.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.data.StoreManager.resumeEvents = function() {};

/**
 * [Method] Sorts the data in the Store by one or more of its properties
 * @param {?=} sorters String/Ext.util.Sorter[] Either a string name of one of the fields in this Store's configured Model, or an array of sorter configurations.
 * @param {string=} direction String The overall direction to sort the data by.
 * @return {!Array<!Ext.util.ISorter>} Ext.util.Sorter[]
 */
Ext.data.StoreManager.sort = function(sorters, direction) {};

/**
 * [Method] Sorts the collection by a single sorter function
 * @param {?=} sorterFn Function The function to sort by
 * @return {void}
 */
Ext.data.StoreManager.sortBy = function(sorterFn) {};

/**
 * [Method] Sorts this collection by keys
 * @param {string=} direction String 'ASC' or 'DESC'. Defaults to 'ASC'.
 * @param {?=} fn Function Comparison function that defines the sort order. Defaults to sorting by case insensitive string.
 * @return {void}
 */
Ext.data.StoreManager.sortByKey = function(direction, fn) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.data.StoreManager.statics = function() {};

/**
 * [Method] Collects all of the values of the given property and returns their sum
 * @param {string=} property String The property to sum by
 * @param {string=} root String 'root' property to extract the first argument from. This is used mainly when summing fields in records, where the fields are all stored inside the 'data' object
 * @param {number=} start Number The record index to start at
 * @param {number=} end Number The record index to end at
 * @return {number} Number The total
 */
Ext.data.StoreManager.sum = function(property, root, start, end) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.data.StoreManager.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.data.StoreManager.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.StoreManager.un = function(eventName, fn, scope) {};

/**
 * [Method] Unregisters one or more Stores with the StoreManager
 * @param {?=} stores String/Object... Any number of Store instances or ID-s
 * @return {void}
 */
Ext.data.StoreManager.unregister = function(stores) {};

/**
 * [Method] Change the key for an existing item in the collection
 * @param {?=} oldKey Object The old key
 * @param {?=} newKey Object The new key
 * @return {void}
 */
Ext.data.StoreManager.updateKey = function(oldKey, newKey) {};
/**
 * @extends {Ext.util.IMixedCollection}
 * @record
 * @struct
 */
Ext.IStoreMgr = function() {};
/**
 * @constructor
 * @struct
 */
Ext.StoreMgr = function() {};
 /** @type {?} */
Ext.StoreMgr.hasListeners;
 /** @type {boolean} */
Ext.StoreMgr.isMixedCollection;
 /** @type {boolean} */
Ext.StoreMgr.isObservable;
 /** @type {boolean} */
Ext.StoreMgr.isSortable;
 /** @type {!Ext.IClass} */
Ext.StoreMgr.self;
 /** @type {!Ext.util.IMixedCollection} */
Ext.StoreMgr.sorters;

/**
 * [Method] Adds an item to the collection
 * @param {?=} key String/Object The key to associate with the item, or the new item. If a getKey implementation was specified for this MixedCollection, or if the key of the stored items is in a property called id, the MixedCollection will be able to derive the key for the new item. In this case just pass the new item in this parameter.
 * @param {?=} obj Object The item to add.
 * @return {?} Object The item added.
 */
Ext.StoreMgr.add = function(key, obj) {};

/**
 * [Method] Adds all elements of an Array or an Object to the collection
 * @param {?=} objs Object/Array An Object containing properties which will be added to the collection, or an Array of values, each of which are added to the collection. Functions references will be added to the collection if allowFunctions has been set to true.
 * @return {void}
 */
Ext.StoreMgr.addAll = function(objs) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.StoreMgr.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.StoreMgr.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.StoreMgr.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.StoreMgr.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.StoreMgr.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.StoreMgr.callSuper = function(args) {};

/**
 * [Method] Removes all items from the collection
 * @return {void}
 */
Ext.StoreMgr.clear = function() {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.StoreMgr.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.StoreMgr.clearManagedListeners = function() {};

/**
 * [Method] Creates a shallow copy of this collection
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection
 */
Ext.StoreMgr.clone = function() {};

/**
 * [Method] Collects unique values of a particular property in this MixedCollection
 * @param {string=} property String The property to collect on
 * @param {string=} root String 'root' property to extract the first argument from. This is used mainly when summing fields in records, where the fields are all stored inside the 'data' object
 * @param {boolean=} allowBlank Boolean Pass true to allow null, undefined or empty string values
 * @return {!Array<?>} Array The unique values
 */
Ext.StoreMgr.collect = function(property, root, allowBlank) {};

/**
 * [Method] Returns true if the collection contains the passed Object as an item
 * @param {?=} o Object The Object to look for in the collection.
 * @return {boolean} Boolean True if the collection contains the Object as an item.
 */
Ext.StoreMgr.contains = function(o) {};

/**
 * [Method] Returns true if the collection contains the passed Object as a key
 * @param {string=} key String The key to look for in the collection.
 * @return {boolean} Boolean True if the collection contains the Object as a key.
 */
Ext.StoreMgr.containsKey = function(key) {};

/**
 * [Method] Executes the specified function once for every item in the collection
 * @param {?=} fn Function The function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current item in the iteration.
 * @return {void}
 */
Ext.StoreMgr.each = function(fn, scope) {};

/**
 * [Method] Executes the specified function once for every key in the collection passing each key and its associated item as th
 * @param {?=} fn Function The function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {void}
 */
Ext.StoreMgr.eachKey = function(fn, scope) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.StoreMgr.enableBubble = function(eventNames) {};

/**
 * [Method] Filters the objects in this collection by a set of Filters or by a single property value pair with optional paramete
 * @param {?=} property Ext.util.Filter[]/String A property on your objects, or an array of Filter objects
 * @param {?=} value String/RegExp Either string that the property values should start with or a RegExp to test against the property
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection The new filtered collection
 */
Ext.StoreMgr.filter = function(property, value, anyMatch, caseSensitive) {};

/**
 * [Method] Filter by a function
 * @param {?=} fn Function The function to be called.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this MixedCollection.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection The new filtered collection
 */
Ext.StoreMgr.filterBy = function(fn, scope) {};

/**
 * [Method] Returns the first item in the collection which elicits a true return value from the passed selection function
 * @return {void}
 */
Ext.StoreMgr.find = function() {};

/**
 * [Method] Returns the first item in the collection which elicits a true return value from the passed selection function
 * @param {?=} fn Function The selection function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {?} Object The first item in the collection which returned true from the selection function, or null if none was found.
 */
Ext.StoreMgr.findBy = function(fn, scope) {};

/**
 * [Method] Finds the index of the first matching object in this collection by a specific property value
 * @param {string=} property String The name of a property on your objects.
 * @param {?=} value String/RegExp A string that the property values should start with or a RegExp to test against the property.
 * @param {number=} start Number The index to start searching at.
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning.
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison.
 * @return {number} Number The matched index or -1
 */
Ext.StoreMgr.findIndex = function(property, value, start, anyMatch, caseSensitive) {};

/**
 * [Method] Find the index of the first matching object in this collection by a function
 * @param {?=} fn Function The function to be called.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this MixedCollection.
 * @param {number=} start Number The index to start searching at.
 * @return {number} Number The matched index or -1
 */
Ext.StoreMgr.findIndexBy = function(fn, scope, start) {};

/**
 * [Method] Calculates the insertion index of the new item based upon the comparison function passed or the current sort order
 * @param {?=} newItem Object The new object to find the insertion position of.
 * @param {?=} sorterFn Function The function to sort by. This is the same as the sorting function passed to sortBy. It accepts 2 items from this MixedCollection, and returns -1 0, or 1 depending on the relative sort positions of the 2 compared items. If omitted, a function generated from the currently defined set of sorters will be used.
 * @return {number} Number The insertion point to add the new item into this MixedCollection at using insert
 */
Ext.StoreMgr.findInsertionIndex = function(newItem, sorterFn) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.StoreMgr.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.StoreMgr.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the first item in the collection
 * @return {?} Object the first item in the collection..
 */
Ext.StoreMgr.first = function() {};

/**
 * [Method] Returns a comparator function which compares two items and returns 1 0 or 1 depending on the currently defined set
 * @return {void}
 */
Ext.StoreMgr.generateComparator = function() {};

/**
 * [Method] Returns the item associated with the passed key OR index
 * @param {?=} key String/Number The key or index of the item.
 * @return {?} Object If the item is found, returns the item. If the item was not found, returns undefined. If an item was found, but is a Class, returns null.
 */
Ext.StoreMgr.get = function(key) {};

/**
 * [Method] Returns the item at the specified index
 * @param {number=} index Number The index of the item.
 * @return {?} Object The item at the specified index.
 */
Ext.StoreMgr.getAt = function(index) {};

/**
 * [Method] Returns the item associated with the passed key
 * @param {?=} key String/Number The key of the item.
 * @return {?} Object The item associated with the passed key.
 */
Ext.StoreMgr.getByKey = function(key) {};

/**
 * [Method] Returns the number of items in the collection
 * @return {number} Number the number of items in the collection.
 */
Ext.StoreMgr.getCount = function() {};

/**
 * [Method] Gets the first sorter from the sorters collection excluding any groupers that may be in place
 * @return {!Ext.util.ISorter} Ext.util.Sorter The sorter, null if none exist
 */
Ext.StoreMgr.getFirstSorter = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.StoreMgr.getInitialConfig = function(name) {};

/**
 * [Method] getKey implementation for MixedCollection
 * @param {?=} o Object
 * @return {?} Object The key for the passed item.
 */
Ext.StoreMgr.getKey = function(o) {};

/**
 * [Method] Returns a range of items in this collection
 * @param {number=} startIndex Number The starting index. Defaults to 0.
 * @param {number=} endIndex Number The ending index. Defaults to the last item.
 * @return {!Array<?>} Array An array of items
 */
Ext.StoreMgr.getRange = function(startIndex, endIndex) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.StoreMgr.hasListener = function(eventName) {};

/**
 * [Method] Returns index within the collection of the passed Object
 * @param {?=} o Object The item to find the index of.
 * @return {number} Number index of the item. Returns -1 if not found.
 */
Ext.StoreMgr.indexOf = function(o) {};

/**
 * [Method] Returns index within the collection of the passed key
 * @param {string=} key String The key to find the index of.
 * @return {number} Number index of the key.
 */
Ext.StoreMgr.indexOfKey = function(key) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.StoreMgr.initConfig = function(config) {};

/**
 * [Method] Performs initialization of this mixin
 * @return {void}
 */
Ext.StoreMgr.initSortable = function() {};

/**
 * [Method] Inserts an item at the specified index in the collection
 * @param {number=} index Number The index to insert the item at.
 * @param {?=} key String/Object/String[]/Object[] The key to associate with the new item, or the item itself. May also be an array of either to insert multiple items at once.
 * @param {?=} o Object/Object[] If the second parameter was a key, the new item. May also be an array to insert multiple items at once.
 * @return {?} Object The item inserted or an array of items inserted.
 */
Ext.StoreMgr.insert = function(index, key, o) {};

/**
 * [Method] Returns the last item in the collection
 * @return {?} Object the last item in the collection..
 */
Ext.StoreMgr.last = function() {};

/**
 * [Method] Gets a registered Store by id
 * @param {?=} store String/Object The id of the Store, or a Store instance, or a store configuration
 * @return {!Ext.data.IStore} Ext.data.Store
 */
Ext.StoreMgr.lookup = function(store) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.StoreMgr.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.StoreMgr.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.StoreMgr.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Registers one or more Stores with the StoreManager
 * @param {!Ext.data.IStore} stores Ext.data.Store... Any number of Store instances
 * @return {void}
 */
Ext.StoreMgr.register = function(stores) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.StoreMgr.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Remove an item from the collection
 * @param {?=} o Object The item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.StoreMgr.remove = function(o) {};

/**
 * [Method] Remove all items in the collection
 * @param {!Array<?>=} items Array An array of items to be removed.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection this object
 */
Ext.StoreMgr.removeAll = function(items) {};

/**
 * [Method] Remove an item from a specified index in the collection
 * @param {number=} index Number The index within the collection of the item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.StoreMgr.removeAt = function(index) {};

/**
 * [Method] Removes an item associated with the passed key fom the collection
 * @param {string=} key String The key of the item to remove. If null is passed, all objects which yielded no key from the configured getKey function are removed.
 * @return {?} Object Only returned if removing at a specified key. The item removed or false if no item was removed.
 */
Ext.StoreMgr.removeAtKey = function(key) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.StoreMgr.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.StoreMgr.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Remove a range of items starting at a specified index in the collection
 * @param {number=} index Number The index within the collection of the item to remove.
 * @param {number=} removeCount Number The nuber of items to remove beginning at the specified index.
 * @return {?} Object The last item removed or false if no item was removed.
 */
Ext.StoreMgr.removeRange = function(index, removeCount) {};

/**
 * [Method] Reorders each of the items based on a mapping from old index to new index
 * @param {?=} mapping Object Mapping from old item index to new item index
 * @return {void}
 */
Ext.StoreMgr.reorder = function(mapping) {};

/**
 * [Method] Replaces an item in the collection
 * @param {string=} key String The key associated with the item to replace, or the replacement item. If you supplied a getKey implementation for this MixedCollection, or if the key of your stored items is in a property called id, then the MixedCollection will be able to derive the key of the replacement item. If you want to replace an item with one having the same key value, then just pass the replacement item in this parameter.
 * @param {?=} o Object {Object} o (optional) If the first parameter passed was a key, the item to associate with that key.
 * @return {?} Object The new item.
 */
Ext.StoreMgr.replace = function(key, o) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.StoreMgr.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.StoreMgr.resumeEvents = function() {};

/**
 * [Method] Sorts the data in the Store by one or more of its properties
 * @param {?=} sorters String/Ext.util.Sorter[] Either a string name of one of the fields in this Store's configured Model, or an array of sorter configurations.
 * @param {string=} direction String The overall direction to sort the data by.
 * @return {!Array<!Ext.util.ISorter>} Ext.util.Sorter[]
 */
Ext.StoreMgr.sort = function(sorters, direction) {};

/**
 * [Method] Sorts the collection by a single sorter function
 * @param {?=} sorterFn Function The function to sort by
 * @return {void}
 */
Ext.StoreMgr.sortBy = function(sorterFn) {};

/**
 * [Method] Sorts this collection by keys
 * @param {string=} direction String 'ASC' or 'DESC'. Defaults to 'ASC'.
 * @param {?=} fn Function Comparison function that defines the sort order. Defaults to sorting by case insensitive string.
 * @return {void}
 */
Ext.StoreMgr.sortByKey = function(direction, fn) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.StoreMgr.statics = function() {};

/**
 * [Method] Collects all of the values of the given property and returns their sum
 * @param {string=} property String The property to sum by
 * @param {string=} root String 'root' property to extract the first argument from. This is used mainly when summing fields in records, where the fields are all stored inside the 'data' object
 * @param {number=} start Number The record index to start at
 * @param {number=} end Number The record index to end at
 * @return {number} Number The total
 */
Ext.StoreMgr.sum = function(property, root, start, end) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.StoreMgr.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.StoreMgr.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.StoreMgr.un = function(eventName, fn, scope) {};

/**
 * [Method] Unregisters one or more Stores with the StoreManager
 * @param {?=} stores String/Object... Any number of Store instances or ID-s
 * @return {void}
 */
Ext.StoreMgr.unregister = function(stores) {};

/**
 * [Method] Change the key for an existing item in the collection
 * @param {?=} oldKey Object The old key
 * @param {?=} newKey Object The new key
 * @return {void}
 */
Ext.StoreMgr.updateKey = function(oldKey, newKey) {};
/**
 * @extends {Ext.util.IMixedCollection}
 * @record
 * @struct
 */
Ext.data.IStoreMgr = function() {};
/**
 * @constructor
 * @struct
 */
Ext.data.StoreMgr = function() {};
 /** @type {?} */
Ext.data.StoreMgr.hasListeners;
 /** @type {boolean} */
Ext.data.StoreMgr.isMixedCollection;
 /** @type {boolean} */
Ext.data.StoreMgr.isObservable;
 /** @type {boolean} */
Ext.data.StoreMgr.isSortable;
 /** @type {!Ext.IClass} */
Ext.data.StoreMgr.self;
 /** @type {!Ext.util.IMixedCollection} */
Ext.data.StoreMgr.sorters;

/**
 * [Method] Adds an item to the collection
 * @param {?=} key String/Object The key to associate with the item, or the new item. If a getKey implementation was specified for this MixedCollection, or if the key of the stored items is in a property called id, the MixedCollection will be able to derive the key for the new item. In this case just pass the new item in this parameter.
 * @param {?=} obj Object The item to add.
 * @return {?} Object The item added.
 */
Ext.data.StoreMgr.add = function(key, obj) {};

/**
 * [Method] Adds all elements of an Array or an Object to the collection
 * @param {?=} objs Object/Array An Object containing properties which will be added to the collection, or an Array of values, each of which are added to the collection. Functions references will be added to the collection if allowFunctions has been set to true.
 * @return {void}
 */
Ext.data.StoreMgr.addAll = function(objs) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.data.StoreMgr.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.StoreMgr.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.StoreMgr.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.data.StoreMgr.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.data.StoreMgr.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.data.StoreMgr.callSuper = function(args) {};

/**
 * [Method] Removes all items from the collection
 * @return {void}
 */
Ext.data.StoreMgr.clear = function() {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.data.StoreMgr.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.data.StoreMgr.clearManagedListeners = function() {};

/**
 * [Method] Creates a shallow copy of this collection
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection
 */
Ext.data.StoreMgr.clone = function() {};

/**
 * [Method] Collects unique values of a particular property in this MixedCollection
 * @param {string=} property String The property to collect on
 * @param {string=} root String 'root' property to extract the first argument from. This is used mainly when summing fields in records, where the fields are all stored inside the 'data' object
 * @param {boolean=} allowBlank Boolean Pass true to allow null, undefined or empty string values
 * @return {!Array<?>} Array The unique values
 */
Ext.data.StoreMgr.collect = function(property, root, allowBlank) {};

/**
 * [Method] Returns true if the collection contains the passed Object as an item
 * @param {?=} o Object The Object to look for in the collection.
 * @return {boolean} Boolean True if the collection contains the Object as an item.
 */
Ext.data.StoreMgr.contains = function(o) {};

/**
 * [Method] Returns true if the collection contains the passed Object as a key
 * @param {string=} key String The key to look for in the collection.
 * @return {boolean} Boolean True if the collection contains the Object as a key.
 */
Ext.data.StoreMgr.containsKey = function(key) {};

/**
 * [Method] Executes the specified function once for every item in the collection
 * @param {?=} fn Function The function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current item in the iteration.
 * @return {void}
 */
Ext.data.StoreMgr.each = function(fn, scope) {};

/**
 * [Method] Executes the specified function once for every key in the collection passing each key and its associated item as th
 * @param {?=} fn Function The function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {void}
 */
Ext.data.StoreMgr.eachKey = function(fn, scope) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.data.StoreMgr.enableBubble = function(eventNames) {};

/**
 * [Method] Filters the objects in this collection by a set of Filters or by a single property value pair with optional paramete
 * @param {?=} property Ext.util.Filter[]/String A property on your objects, or an array of Filter objects
 * @param {?=} value String/RegExp Either string that the property values should start with or a RegExp to test against the property
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection The new filtered collection
 */
Ext.data.StoreMgr.filter = function(property, value, anyMatch, caseSensitive) {};

/**
 * [Method] Filter by a function
 * @param {?=} fn Function The function to be called.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this MixedCollection.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection The new filtered collection
 */
Ext.data.StoreMgr.filterBy = function(fn, scope) {};

/**
 * [Method] Returns the first item in the collection which elicits a true return value from the passed selection function
 * @return {void}
 */
Ext.data.StoreMgr.find = function() {};

/**
 * [Method] Returns the first item in the collection which elicits a true return value from the passed selection function
 * @param {?=} fn Function The selection function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {?} Object The first item in the collection which returned true from the selection function, or null if none was found.
 */
Ext.data.StoreMgr.findBy = function(fn, scope) {};

/**
 * [Method] Finds the index of the first matching object in this collection by a specific property value
 * @param {string=} property String The name of a property on your objects.
 * @param {?=} value String/RegExp A string that the property values should start with or a RegExp to test against the property.
 * @param {number=} start Number The index to start searching at.
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning.
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison.
 * @return {number} Number The matched index or -1
 */
Ext.data.StoreMgr.findIndex = function(property, value, start, anyMatch, caseSensitive) {};

/**
 * [Method] Find the index of the first matching object in this collection by a function
 * @param {?=} fn Function The function to be called.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this MixedCollection.
 * @param {number=} start Number The index to start searching at.
 * @return {number} Number The matched index or -1
 */
Ext.data.StoreMgr.findIndexBy = function(fn, scope, start) {};

/**
 * [Method] Calculates the insertion index of the new item based upon the comparison function passed or the current sort order
 * @param {?=} newItem Object The new object to find the insertion position of.
 * @param {?=} sorterFn Function The function to sort by. This is the same as the sorting function passed to sortBy. It accepts 2 items from this MixedCollection, and returns -1 0, or 1 depending on the relative sort positions of the 2 compared items. If omitted, a function generated from the currently defined set of sorters will be used.
 * @return {number} Number The insertion point to add the new item into this MixedCollection at using insert
 */
Ext.data.StoreMgr.findInsertionIndex = function(newItem, sorterFn) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.StoreMgr.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.StoreMgr.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the first item in the collection
 * @return {?} Object the first item in the collection..
 */
Ext.data.StoreMgr.first = function() {};

/**
 * [Method] Returns a comparator function which compares two items and returns 1 0 or 1 depending on the currently defined set
 * @return {void}
 */
Ext.data.StoreMgr.generateComparator = function() {};

/**
 * [Method] Returns the item associated with the passed key OR index
 * @param {?=} key String/Number The key or index of the item.
 * @return {?} Object If the item is found, returns the item. If the item was not found, returns undefined. If an item was found, but is a Class, returns null.
 */
Ext.data.StoreMgr.get = function(key) {};

/**
 * [Method] Returns the item at the specified index
 * @param {number=} index Number The index of the item.
 * @return {?} Object The item at the specified index.
 */
Ext.data.StoreMgr.getAt = function(index) {};

/**
 * [Method] Returns the item associated with the passed key
 * @param {?=} key String/Number The key of the item.
 * @return {?} Object The item associated with the passed key.
 */
Ext.data.StoreMgr.getByKey = function(key) {};

/**
 * [Method] Returns the number of items in the collection
 * @return {number} Number the number of items in the collection.
 */
Ext.data.StoreMgr.getCount = function() {};

/**
 * [Method] Gets the first sorter from the sorters collection excluding any groupers that may be in place
 * @return {!Ext.util.ISorter} Ext.util.Sorter The sorter, null if none exist
 */
Ext.data.StoreMgr.getFirstSorter = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.data.StoreMgr.getInitialConfig = function(name) {};

/**
 * [Method] getKey implementation for MixedCollection
 * @param {?=} o Object
 * @return {?} Object The key for the passed item.
 */
Ext.data.StoreMgr.getKey = function(o) {};

/**
 * [Method] Returns a range of items in this collection
 * @param {number=} startIndex Number The starting index. Defaults to 0.
 * @param {number=} endIndex Number The ending index. Defaults to the last item.
 * @return {!Array<?>} Array An array of items
 */
Ext.data.StoreMgr.getRange = function(startIndex, endIndex) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.data.StoreMgr.hasListener = function(eventName) {};

/**
 * [Method] Returns index within the collection of the passed Object
 * @param {?=} o Object The item to find the index of.
 * @return {number} Number index of the item. Returns -1 if not found.
 */
Ext.data.StoreMgr.indexOf = function(o) {};

/**
 * [Method] Returns index within the collection of the passed key
 * @param {string=} key String The key to find the index of.
 * @return {number} Number index of the key.
 */
Ext.data.StoreMgr.indexOfKey = function(key) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.data.StoreMgr.initConfig = function(config) {};

/**
 * [Method] Performs initialization of this mixin
 * @return {void}
 */
Ext.data.StoreMgr.initSortable = function() {};

/**
 * [Method] Inserts an item at the specified index in the collection
 * @param {number=} index Number The index to insert the item at.
 * @param {?=} key String/Object/String[]/Object[] The key to associate with the new item, or the item itself. May also be an array of either to insert multiple items at once.
 * @param {?=} o Object/Object[] If the second parameter was a key, the new item. May also be an array to insert multiple items at once.
 * @return {?} Object The item inserted or an array of items inserted.
 */
Ext.data.StoreMgr.insert = function(index, key, o) {};

/**
 * [Method] Returns the last item in the collection
 * @return {?} Object the last item in the collection..
 */
Ext.data.StoreMgr.last = function() {};

/**
 * [Method] Gets a registered Store by id
 * @param {?=} store String/Object The id of the Store, or a Store instance, or a store configuration
 * @return {!Ext.data.IStore} Ext.data.Store
 */
Ext.data.StoreMgr.lookup = function(store) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.StoreMgr.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.StoreMgr.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.StoreMgr.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Registers one or more Stores with the StoreManager
 * @param {!Ext.data.IStore} stores Ext.data.Store... Any number of Store instances
 * @return {void}
 */
Ext.data.StoreMgr.register = function(stores) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.data.StoreMgr.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Remove an item from the collection
 * @param {?=} o Object The item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.data.StoreMgr.remove = function(o) {};

/**
 * [Method] Remove all items in the collection
 * @param {!Array<?>=} items Array An array of items to be removed.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection this object
 */
Ext.data.StoreMgr.removeAll = function(items) {};

/**
 * [Method] Remove an item from a specified index in the collection
 * @param {number=} index Number The index within the collection of the item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.data.StoreMgr.removeAt = function(index) {};

/**
 * [Method] Removes an item associated with the passed key fom the collection
 * @param {string=} key String The key of the item to remove. If null is passed, all objects which yielded no key from the configured getKey function are removed.
 * @return {?} Object Only returned if removing at a specified key. The item removed or false if no item was removed.
 */
Ext.data.StoreMgr.removeAtKey = function(key) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.StoreMgr.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.StoreMgr.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Remove a range of items starting at a specified index in the collection
 * @param {number=} index Number The index within the collection of the item to remove.
 * @param {number=} removeCount Number The nuber of items to remove beginning at the specified index.
 * @return {?} Object The last item removed or false if no item was removed.
 */
Ext.data.StoreMgr.removeRange = function(index, removeCount) {};

/**
 * [Method] Reorders each of the items based on a mapping from old index to new index
 * @param {?=} mapping Object Mapping from old item index to new item index
 * @return {void}
 */
Ext.data.StoreMgr.reorder = function(mapping) {};

/**
 * [Method] Replaces an item in the collection
 * @param {string=} key String The key associated with the item to replace, or the replacement item. If you supplied a getKey implementation for this MixedCollection, or if the key of your stored items is in a property called id, then the MixedCollection will be able to derive the key of the replacement item. If you want to replace an item with one having the same key value, then just pass the replacement item in this parameter.
 * @param {?=} o Object {Object} o (optional) If the first parameter passed was a key, the item to associate with that key.
 * @return {?} Object The new item.
 */
Ext.data.StoreMgr.replace = function(key, o) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.data.StoreMgr.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.data.StoreMgr.resumeEvents = function() {};

/**
 * [Method] Sorts the data in the Store by one or more of its properties
 * @param {?=} sorters String/Ext.util.Sorter[] Either a string name of one of the fields in this Store's configured Model, or an array of sorter configurations.
 * @param {string=} direction String The overall direction to sort the data by.
 * @return {!Array<!Ext.util.ISorter>} Ext.util.Sorter[]
 */
Ext.data.StoreMgr.sort = function(sorters, direction) {};

/**
 * [Method] Sorts the collection by a single sorter function
 * @param {?=} sorterFn Function The function to sort by
 * @return {void}
 */
Ext.data.StoreMgr.sortBy = function(sorterFn) {};

/**
 * [Method] Sorts this collection by keys
 * @param {string=} direction String 'ASC' or 'DESC'. Defaults to 'ASC'.
 * @param {?=} fn Function Comparison function that defines the sort order. Defaults to sorting by case insensitive string.
 * @return {void}
 */
Ext.data.StoreMgr.sortByKey = function(direction, fn) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.data.StoreMgr.statics = function() {};

/**
 * [Method] Collects all of the values of the given property and returns their sum
 * @param {string=} property String The property to sum by
 * @param {string=} root String 'root' property to extract the first argument from. This is used mainly when summing fields in records, where the fields are all stored inside the 'data' object
 * @param {number=} start Number The record index to start at
 * @param {number=} end Number The record index to end at
 * @return {number} Number The total
 */
Ext.data.StoreMgr.sum = function(property, root, start, end) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.data.StoreMgr.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.data.StoreMgr.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.StoreMgr.un = function(eventName, fn, scope) {};

/**
 * [Method] Unregisters one or more Stores with the StoreManager
 * @param {?=} stores String/Object... Any number of Store instances or ID-s
 * @return {void}
 */
Ext.data.StoreMgr.unregister = function(stores) {};

/**
 * [Method] Change the key for an existing item in the collection
 * @param {?=} oldKey Object The old key
 * @param {?=} newKey Object The new key
 * @return {void}
 */
Ext.data.StoreMgr.updateKey = function(oldKey, newKey) {};
/**
 * @extends {Ext.util.IMixedCollection}
 * @record
 * @struct
 */
Ext.IStoreManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.StoreManager = function() {};
 /** @type {?} */
Ext.StoreManager.hasListeners;
 /** @type {boolean} */
Ext.StoreManager.isMixedCollection;
 /** @type {boolean} */
Ext.StoreManager.isObservable;
 /** @type {boolean} */
Ext.StoreManager.isSortable;
 /** @type {!Ext.IClass} */
Ext.StoreManager.self;
 /** @type {!Ext.util.IMixedCollection} */
Ext.StoreManager.sorters;

/**
 * [Method] Adds an item to the collection
 * @param {?=} key String/Object The key to associate with the item, or the new item. If a getKey implementation was specified for this MixedCollection, or if the key of the stored items is in a property called id, the MixedCollection will be able to derive the key for the new item. In this case just pass the new item in this parameter.
 * @param {?=} obj Object The item to add.
 * @return {?} Object The item added.
 */
Ext.StoreManager.add = function(key, obj) {};

/**
 * [Method] Adds all elements of an Array or an Object to the collection
 * @param {?=} objs Object/Array An Object containing properties which will be added to the collection, or an Array of values, each of which are added to the collection. Functions references will be added to the collection if allowFunctions has been set to true.
 * @return {void}
 */
Ext.StoreManager.addAll = function(objs) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.StoreManager.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.StoreManager.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.StoreManager.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.StoreManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.StoreManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.StoreManager.callSuper = function(args) {};

/**
 * [Method] Removes all items from the collection
 * @return {void}
 */
Ext.StoreManager.clear = function() {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.StoreManager.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.StoreManager.clearManagedListeners = function() {};

/**
 * [Method] Creates a shallow copy of this collection
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection
 */
Ext.StoreManager.clone = function() {};

/**
 * [Method] Collects unique values of a particular property in this MixedCollection
 * @param {string=} property String The property to collect on
 * @param {string=} root String 'root' property to extract the first argument from. This is used mainly when summing fields in records, where the fields are all stored inside the 'data' object
 * @param {boolean=} allowBlank Boolean Pass true to allow null, undefined or empty string values
 * @return {!Array<?>} Array The unique values
 */
Ext.StoreManager.collect = function(property, root, allowBlank) {};

/**
 * [Method] Returns true if the collection contains the passed Object as an item
 * @param {?=} o Object The Object to look for in the collection.
 * @return {boolean} Boolean True if the collection contains the Object as an item.
 */
Ext.StoreManager.contains = function(o) {};

/**
 * [Method] Returns true if the collection contains the passed Object as a key
 * @param {string=} key String The key to look for in the collection.
 * @return {boolean} Boolean True if the collection contains the Object as a key.
 */
Ext.StoreManager.containsKey = function(key) {};

/**
 * [Method] Executes the specified function once for every item in the collection
 * @param {?=} fn Function The function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current item in the iteration.
 * @return {void}
 */
Ext.StoreManager.each = function(fn, scope) {};

/**
 * [Method] Executes the specified function once for every key in the collection passing each key and its associated item as th
 * @param {?=} fn Function The function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {void}
 */
Ext.StoreManager.eachKey = function(fn, scope) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.StoreManager.enableBubble = function(eventNames) {};

/**
 * [Method] Filters the objects in this collection by a set of Filters or by a single property value pair with optional paramete
 * @param {?=} property Ext.util.Filter[]/String A property on your objects, or an array of Filter objects
 * @param {?=} value String/RegExp Either string that the property values should start with or a RegExp to test against the property
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection The new filtered collection
 */
Ext.StoreManager.filter = function(property, value, anyMatch, caseSensitive) {};

/**
 * [Method] Filter by a function
 * @param {?=} fn Function The function to be called.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this MixedCollection.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection The new filtered collection
 */
Ext.StoreManager.filterBy = function(fn, scope) {};

/**
 * [Method] Returns the first item in the collection which elicits a true return value from the passed selection function
 * @return {void}
 */
Ext.StoreManager.find = function() {};

/**
 * [Method] Returns the first item in the collection which elicits a true return value from the passed selection function
 * @param {?=} fn Function The selection function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {?} Object The first item in the collection which returned true from the selection function, or null if none was found.
 */
Ext.StoreManager.findBy = function(fn, scope) {};

/**
 * [Method] Finds the index of the first matching object in this collection by a specific property value
 * @param {string=} property String The name of a property on your objects.
 * @param {?=} value String/RegExp A string that the property values should start with or a RegExp to test against the property.
 * @param {number=} start Number The index to start searching at.
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning.
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison.
 * @return {number} Number The matched index or -1
 */
Ext.StoreManager.findIndex = function(property, value, start, anyMatch, caseSensitive) {};

/**
 * [Method] Find the index of the first matching object in this collection by a function
 * @param {?=} fn Function The function to be called.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this MixedCollection.
 * @param {number=} start Number The index to start searching at.
 * @return {number} Number The matched index or -1
 */
Ext.StoreManager.findIndexBy = function(fn, scope, start) {};

/**
 * [Method] Calculates the insertion index of the new item based upon the comparison function passed or the current sort order
 * @param {?=} newItem Object The new object to find the insertion position of.
 * @param {?=} sorterFn Function The function to sort by. This is the same as the sorting function passed to sortBy. It accepts 2 items from this MixedCollection, and returns -1 0, or 1 depending on the relative sort positions of the 2 compared items. If omitted, a function generated from the currently defined set of sorters will be used.
 * @return {number} Number The insertion point to add the new item into this MixedCollection at using insert
 */
Ext.StoreManager.findInsertionIndex = function(newItem, sorterFn) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.StoreManager.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.StoreManager.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the first item in the collection
 * @return {?} Object the first item in the collection..
 */
Ext.StoreManager.first = function() {};

/**
 * [Method] Returns a comparator function which compares two items and returns 1 0 or 1 depending on the currently defined set
 * @return {void}
 */
Ext.StoreManager.generateComparator = function() {};

/**
 * [Method] Returns the item associated with the passed key OR index
 * @param {?=} key String/Number The key or index of the item.
 * @return {?} Object If the item is found, returns the item. If the item was not found, returns undefined. If an item was found, but is a Class, returns null.
 */
Ext.StoreManager.get = function(key) {};

/**
 * [Method] Returns the item at the specified index
 * @param {number=} index Number The index of the item.
 * @return {?} Object The item at the specified index.
 */
Ext.StoreManager.getAt = function(index) {};

/**
 * [Method] Returns the item associated with the passed key
 * @param {?=} key String/Number The key of the item.
 * @return {?} Object The item associated with the passed key.
 */
Ext.StoreManager.getByKey = function(key) {};

/**
 * [Method] Returns the number of items in the collection
 * @return {number} Number the number of items in the collection.
 */
Ext.StoreManager.getCount = function() {};

/**
 * [Method] Gets the first sorter from the sorters collection excluding any groupers that may be in place
 * @return {!Ext.util.ISorter} Ext.util.Sorter The sorter, null if none exist
 */
Ext.StoreManager.getFirstSorter = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.StoreManager.getInitialConfig = function(name) {};

/**
 * [Method] getKey implementation for MixedCollection
 * @param {?=} o Object
 * @return {?} Object The key for the passed item.
 */
Ext.StoreManager.getKey = function(o) {};

/**
 * [Method] Returns a range of items in this collection
 * @param {number=} startIndex Number The starting index. Defaults to 0.
 * @param {number=} endIndex Number The ending index. Defaults to the last item.
 * @return {!Array<?>} Array An array of items
 */
Ext.StoreManager.getRange = function(startIndex, endIndex) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.StoreManager.hasListener = function(eventName) {};

/**
 * [Method] Returns index within the collection of the passed Object
 * @param {?=} o Object The item to find the index of.
 * @return {number} Number index of the item. Returns -1 if not found.
 */
Ext.StoreManager.indexOf = function(o) {};

/**
 * [Method] Returns index within the collection of the passed key
 * @param {string=} key String The key to find the index of.
 * @return {number} Number index of the key.
 */
Ext.StoreManager.indexOfKey = function(key) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.StoreManager.initConfig = function(config) {};

/**
 * [Method] Performs initialization of this mixin
 * @return {void}
 */
Ext.StoreManager.initSortable = function() {};

/**
 * [Method] Inserts an item at the specified index in the collection
 * @param {number=} index Number The index to insert the item at.
 * @param {?=} key String/Object/String[]/Object[] The key to associate with the new item, or the item itself. May also be an array of either to insert multiple items at once.
 * @param {?=} o Object/Object[] If the second parameter was a key, the new item. May also be an array to insert multiple items at once.
 * @return {?} Object The item inserted or an array of items inserted.
 */
Ext.StoreManager.insert = function(index, key, o) {};

/**
 * [Method] Returns the last item in the collection
 * @return {?} Object the last item in the collection..
 */
Ext.StoreManager.last = function() {};

/**
 * [Method] Gets a registered Store by id
 * @param {?=} store String/Object The id of the Store, or a Store instance, or a store configuration
 * @return {!Ext.data.IStore} Ext.data.Store
 */
Ext.StoreManager.lookup = function(store) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.StoreManager.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.StoreManager.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.StoreManager.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Registers one or more Stores with the StoreManager
 * @param {!Ext.data.IStore} stores Ext.data.Store... Any number of Store instances
 * @return {void}
 */
Ext.StoreManager.register = function(stores) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.StoreManager.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Remove an item from the collection
 * @param {?=} o Object The item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.StoreManager.remove = function(o) {};

/**
 * [Method] Remove all items in the collection
 * @param {!Array<?>=} items Array An array of items to be removed.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection this object
 */
Ext.StoreManager.removeAll = function(items) {};

/**
 * [Method] Remove an item from a specified index in the collection
 * @param {number=} index Number The index within the collection of the item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.StoreManager.removeAt = function(index) {};

/**
 * [Method] Removes an item associated with the passed key fom the collection
 * @param {string=} key String The key of the item to remove. If null is passed, all objects which yielded no key from the configured getKey function are removed.
 * @return {?} Object Only returned if removing at a specified key. The item removed or false if no item was removed.
 */
Ext.StoreManager.removeAtKey = function(key) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.StoreManager.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.StoreManager.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Remove a range of items starting at a specified index in the collection
 * @param {number=} index Number The index within the collection of the item to remove.
 * @param {number=} removeCount Number The nuber of items to remove beginning at the specified index.
 * @return {?} Object The last item removed or false if no item was removed.
 */
Ext.StoreManager.removeRange = function(index, removeCount) {};

/**
 * [Method] Reorders each of the items based on a mapping from old index to new index
 * @param {?=} mapping Object Mapping from old item index to new item index
 * @return {void}
 */
Ext.StoreManager.reorder = function(mapping) {};

/**
 * [Method] Replaces an item in the collection
 * @param {string=} key String The key associated with the item to replace, or the replacement item. If you supplied a getKey implementation for this MixedCollection, or if the key of your stored items is in a property called id, then the MixedCollection will be able to derive the key of the replacement item. If you want to replace an item with one having the same key value, then just pass the replacement item in this parameter.
 * @param {?=} o Object {Object} o (optional) If the first parameter passed was a key, the item to associate with that key.
 * @return {?} Object The new item.
 */
Ext.StoreManager.replace = function(key, o) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.StoreManager.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.StoreManager.resumeEvents = function() {};

/**
 * [Method] Sorts the data in the Store by one or more of its properties
 * @param {?=} sorters String/Ext.util.Sorter[] Either a string name of one of the fields in this Store's configured Model, or an array of sorter configurations.
 * @param {string=} direction String The overall direction to sort the data by.
 * @return {!Array<!Ext.util.ISorter>} Ext.util.Sorter[]
 */
Ext.StoreManager.sort = function(sorters, direction) {};

/**
 * [Method] Sorts the collection by a single sorter function
 * @param {?=} sorterFn Function The function to sort by
 * @return {void}
 */
Ext.StoreManager.sortBy = function(sorterFn) {};

/**
 * [Method] Sorts this collection by keys
 * @param {string=} direction String 'ASC' or 'DESC'. Defaults to 'ASC'.
 * @param {?=} fn Function Comparison function that defines the sort order. Defaults to sorting by case insensitive string.
 * @return {void}
 */
Ext.StoreManager.sortByKey = function(direction, fn) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.StoreManager.statics = function() {};

/**
 * [Method] Collects all of the values of the given property and returns their sum
 * @param {string=} property String The property to sum by
 * @param {string=} root String 'root' property to extract the first argument from. This is used mainly when summing fields in records, where the fields are all stored inside the 'data' object
 * @param {number=} start Number The record index to start at
 * @param {number=} end Number The record index to end at
 * @return {number} Number The total
 */
Ext.StoreManager.sum = function(property, root, start, end) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.StoreManager.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.StoreManager.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.StoreManager.un = function(eventName, fn, scope) {};

/**
 * [Method] Unregisters one or more Stores with the StoreManager
 * @param {?=} stores String/Object... Any number of Store instances or ID-s
 * @return {void}
 */
Ext.StoreManager.unregister = function(stores) {};

/**
 * [Method] Change the key for an existing item in the collection
 * @param {?=} oldKey Object The old key
 * @param {?=} newKey Object The new key
 * @return {void}
 */
Ext.StoreManager.updateKey = function(oldKey, newKey) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.data.ITree = function() {};
 /** @type {!Ext.data.INodeInterface} */
Ext.data.ITree.prototype.root;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.data.ITree.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.ITree.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.ITree.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.data.ITree.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.data.ITree.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.data.ITree.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.ITree.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.data.ITree.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Gets a node in this tree by its id
 * @param {string=} id String
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface The match node.
 */
Ext.data.ITree.prototype.getNodeById = function(id) {};

/**
 * [Method] Returns the root node for this tree
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface
 */
Ext.data.ITree.prototype.getRootNode = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.data.ITree.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.ITree.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.ITree.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.data.ITree.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.data.ITree.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.ITree.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.data.ITree.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Removes the root node from this tree
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface The root node
 */
Ext.data.ITree.prototype.removeRootNode = function() {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.data.ITree.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.data.ITree.prototype.resumeEvents = function() {};

/**
 * [Method] Sets the root node for this tree
 * @param {!Ext.data.INodeInterface=} node Ext.data.NodeInterface
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface The root node
 */
Ext.data.ITree.prototype.setRootNode = function(node) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.data.ITree.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.data.ITree.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.data.ITree.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.data.IModel}
 * @record
 * @struct
 */
Ext.data.ITreeModel = function() {};
/**
 * @extends {Ext.data.IAbstractStore}
 * @record
 * @struct
 */
Ext.data.ITreeStore = function() {};
 /** @type {boolean} */
Ext.data.ITreeStore.prototype.clearOnLoad;
 /** @type {boolean} */
Ext.data.ITreeStore.prototype.clearRemovedOnLoad;
 /** @type {string} */
Ext.data.ITreeStore.prototype.defaultRootId;
 /** @type {string} */
Ext.data.ITreeStore.prototype.defaultRootProperty;
 /** @type {string} */
Ext.data.ITreeStore.prototype.defaultRootText;
 /** @type {boolean} */
Ext.data.ITreeStore.prototype.folderSort;
 /** @type {string} */
Ext.data.ITreeStore.prototype.nodeParam;
 /** @type {?} */
Ext.data.ITreeStore.prototype.root;

/**
 * [Method] inherit docs
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] The Model instances
 */
Ext.data.ITreeStore.prototype.getNewRecords = function() {};

/**
 * [Method] Returns the record node by id
 * @param {?=} id Object
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface
 */
Ext.data.ITreeStore.prototype.getNodeById = function(id) {};

/**
 * [Method] Returns the root node for this tree
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface
 */
Ext.data.ITreeStore.prototype.getRootNode = function() {};

/**
 * [Method] inherit docs
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] The updated Model instances
 */
Ext.data.ITreeStore.prototype.getUpdatedRecords = function() {};

/**
 * [Method] Loads the Store using its configured proxy
 * @param {?=} options Object config object. This is passed into the Operation object that is created and then sent to the proxy's Ext.data.proxy.Proxy.read function. The options can also contain a node, which indicates which node is to be loaded. If not specified, it will default to the root node.
 * @return {void}
 */
Ext.data.ITreeStore.prototype.load = function(options) {};

/**
 * [Method] inherit docs
 * @return {void}
 */
Ext.data.ITreeStore.prototype.removeAll = function() {};

/**
 * [Method] inherit docs
 * @param {?=} proxy Object
 * @return {!Ext.data.proxy.IProxy} Ext.data.proxy.Proxy The attached Proxy object
 */
Ext.data.ITreeStore.prototype.setProxy = function(proxy) {};

/**
 * [Method] Sets the root node for this store
 * @param {?=} root Ext.data.Model/Ext.data.NodeInterface/Object
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface The new root
 */
Ext.data.ITreeStore.prototype.setRootNode = function(root) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.ITypes = function() {};
/**
 * @constructor
 * @struct
 */
Ext.data.Types = function() {};
 /** @type {?} */
Ext.data.Types.AUTO;
 /** @type {?} */
Ext.data.Types.BOOL;
 /** @type {?} */
Ext.data.Types.BOOLEAN;
 /** @type {?} */
Ext.data.Types.DATE;
 /** @type {?} */
Ext.data.Types.FLOAT;
 /** @type {?} */
Ext.data.Types.INT;
 /** @type {?} */
Ext.data.Types.INTEGER;
 /** @type {?} */
Ext.data.Types.NUMBER;
 /** @type {?} */
Ext.data.Types.STRING;
 /** @type {!Ext.IClass} */
Ext.data.Types.self;
 /** @type {!RegExp} */
Ext.data.Types.stripRe;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.data.Types.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.data.Types.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.data.Types.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.data.Types.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.data.Types.initConfig = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.data.Types.statics = function() {};
/**
 * @extends {Ext.data.IIdGenerator}
 * @record
 * @struct
 */
Ext.data.IUuidGenerator = function() {};
 /** @type {number} */
Ext.data.IUuidGenerator.prototype.version;
 /** @type {?} */
Ext.data.IUuidGenerator.prototype.salt;
 /** @type {?} */
Ext.data.IUuidGenerator.prototype.timestamp;

/**
 * [Method] Reconfigures this generator given new config properties
 * @param {?=} config Object
 * @return {void}
 */
Ext.data.IUuidGenerator.prototype.reconfigure = function(config) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.IValidations = function() {};
/**
 * @constructor
 * @struct
 */
Ext.data.Validations = function() {};
 /** @type {string} */
Ext.data.Validations.emailMessage;
 /** @type {!RegExp} */
Ext.data.Validations.emailRe;
 /** @type {string} */
Ext.data.Validations.exclusionMessage;
 /** @type {string} */
Ext.data.Validations.formatMessage;
 /** @type {string} */
Ext.data.Validations.inclusionMessage;
 /** @type {string} */
Ext.data.Validations.lengthMessage;
 /** @type {string} */
Ext.data.Validations.presenceMessage;
 /** @type {!Ext.IClass} */
Ext.data.Validations.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.data.Validations.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.data.Validations.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.data.Validations.callSuper = function(args) {};

/**
 * [Method] Validates that an email string is in the correct format
 * @param {?=} config Object Config object
 * @param {string=} email String The email address
 * @return {boolean} Boolean True if the value passes validation
 */
Ext.data.Validations.email = function(config, email) {};

/**
 * [Method] Validates that the given value is not present in the configured list
 * @param {?=} config Object Config object
 * @param {string=} value String The value to validate
 * @return {boolean} Boolean True if the value is not present in the list
 */
Ext.data.Validations.exclusion = function(config, value) {};

/**
 * [Method] Returns true if the given value passes validation against the configured matcher regex
 * @param {?=} config Object Config object
 * @param {string=} value String The value to validate
 * @return {boolean} Boolean True if the value passes the format validation
 */
Ext.data.Validations.format = function(config, value) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.data.Validations.getInitialConfig = function(name) {};

/**
 * [Method] Validates that the given value is present in the configured list
 * @param {?=} config Object Config object
 * @param {string=} value String The value to validate
 * @return {boolean} Boolean True if the value is present in the list
 */
Ext.data.Validations.inclusion = function(config, value) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.data.Validations.initConfig = function(config) {};

/**
 * [Method] Returns true if the given value is between the configured min and max values
 * @param {?=} config Object Config object
 * @param {string=} value String The value to validate
 * @return {boolean} Boolean True if the value passes validation
 */
Ext.data.Validations.length = function(config, value) {};

/**
 * [Method] Validates that the given value is present
 * @param {?=} config Object Config object
 * @param {?=} value Object The value to validate
 * @return {boolean} Boolean True if validation passed
 */
Ext.data.Validations.presence = function(config, value) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.data.Validations.statics = function() {};
/** @const */
Ext.data.writer = {};
/**
 * @extends {Ext.data.writer.IWriter}
 * @record
 * @struct
 */
Ext.data.writer.IJson = function() {};
 /** @type {boolean} */
Ext.data.writer.IJson.prototype.allowSingle;
 /** @type {boolean} */
Ext.data.writer.IJson.prototype.encode;
 /** @type {boolean} */
Ext.data.writer.IJson.prototype.expandData;
 /** @type {string} */
Ext.data.writer.IJson.prototype.root;

/**
 * [Method] The Reader classes support dot delimited data mappings for extracting nested raw data into fields so the writer must
 * @param {?=} data Object
 * @return {void}
 */
Ext.data.writer.IJson.prototype.getExpandedData = function(data) {};
/**
 * @extends {Ext.data.writer.IWriter}
 * @record
 * @struct
 */
Ext.data.IJsonWriter = function() {};
 /** @type {boolean} */
Ext.data.IJsonWriter.prototype.allowSingle;
 /** @type {boolean} */
Ext.data.IJsonWriter.prototype.encode;
 /** @type {boolean} */
Ext.data.IJsonWriter.prototype.expandData;
 /** @type {string} */
Ext.data.IJsonWriter.prototype.root;

/**
 * [Method] The Reader classes support dot delimited data mappings for extracting nested raw data into fields so the writer must
 * @param {?=} data Object
 * @return {void}
 */
Ext.data.IJsonWriter.prototype.getExpandedData = function(data) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.writer.IWriter = function() {};
 /** @type {string} */
Ext.data.writer.IWriter.prototype.dateFormat;
 /** @type {string} */
Ext.data.writer.IWriter.prototype.nameProperty;
 /** @type {boolean} */
Ext.data.writer.IWriter.prototype.writeAllFields;
 /** @type {boolean} */
Ext.data.writer.IWriter.prototype.writeRecordId;

/**
 * [Method] Formats the data for each record before sending it to the server
 * @param {!Ext.data.IModel=} record Ext.data.Model The record that we are writing to the server.
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation An operation object.
 * @return {?} Object An object literal of name/value keys to be written to the server. By default this method returns the data property on the record.
 */
Ext.data.writer.IWriter.prototype.getRecordData = function(record, operation) {};

/**
 * [Method] Prepares a Proxy s Ext data Request object
 * @param {!Ext.data.IRequest=} request Ext.data.Request The request object
 * @return {!Ext.data.IRequest} Ext.data.Request The modified request object
 */
Ext.data.writer.IWriter.prototype.write = function(request) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.IDataWriter = function() {};
 /** @type {string} */
Ext.data.IDataWriter.prototype.dateFormat;
 /** @type {string} */
Ext.data.IDataWriter.prototype.nameProperty;
 /** @type {boolean} */
Ext.data.IDataWriter.prototype.writeAllFields;
 /** @type {boolean} */
Ext.data.IDataWriter.prototype.writeRecordId;

/**
 * [Method] Formats the data for each record before sending it to the server
 * @param {!Ext.data.IModel=} record Ext.data.Model The record that we are writing to the server.
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation An operation object.
 * @return {?} Object An object literal of name/value keys to be written to the server. By default this method returns the data property on the record.
 */
Ext.data.IDataWriter.prototype.getRecordData = function(record, operation) {};

/**
 * [Method] Prepares a Proxy s Ext data Request object
 * @param {!Ext.data.IRequest=} request Ext.data.Request The request object
 * @return {!Ext.data.IRequest} Ext.data.Request The modified request object
 */
Ext.data.IDataWriter.prototype.write = function(request) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.data.IWriter = function() {};
 /** @type {string} */
Ext.data.IWriter.prototype.dateFormat;
 /** @type {string} */
Ext.data.IWriter.prototype.nameProperty;
 /** @type {boolean} */
Ext.data.IWriter.prototype.writeAllFields;
 /** @type {boolean} */
Ext.data.IWriter.prototype.writeRecordId;

/**
 * [Method] Formats the data for each record before sending it to the server
 * @param {!Ext.data.IModel=} record Ext.data.Model The record that we are writing to the server.
 * @param {!Ext.data.IOperation=} operation Ext.data.Operation An operation object.
 * @return {?} Object An object literal of name/value keys to be written to the server. By default this method returns the data property on the record.
 */
Ext.data.IWriter.prototype.getRecordData = function(record, operation) {};

/**
 * [Method] Prepares a Proxy s Ext data Request object
 * @param {!Ext.data.IRequest=} request Ext.data.Request The request object
 * @return {!Ext.data.IRequest} Ext.data.Request The modified request object
 */
Ext.data.IWriter.prototype.write = function(request) {};
/**
 * @extends {Ext.data.writer.IWriter}
 * @record
 * @struct
 */
Ext.data.writer.IXml = function() {};
 /** @type {string} */
Ext.data.writer.IXml.prototype.defaultDocumentRoot;
 /** @type {string} */
Ext.data.writer.IXml.prototype.documentRoot;
 /** @type {string} */
Ext.data.writer.IXml.prototype.header;
 /** @type {string} */
Ext.data.writer.IXml.prototype.record;
/**
 * @extends {Ext.data.writer.IWriter}
 * @record
 * @struct
 */
Ext.data.IXmlWriter = function() {};
 /** @type {string} */
Ext.data.IXmlWriter.prototype.defaultDocumentRoot;
 /** @type {string} */
Ext.data.IXmlWriter.prototype.documentRoot;
 /** @type {string} */
Ext.data.IXmlWriter.prototype.header;
 /** @type {string} */
Ext.data.IXmlWriter.prototype.record;
/**
 * @extends {Ext.data.IStore}
 * @record
 * @struct
 */
Ext.data.IXmlStore = function() {};
/**
 * @record
 * @struct
 */
Ext.IDate = function() {};
/**
 * @constructor
 * @struct
 */
Ext.Date = function() {};
 /** @type {string} */
Ext.Date.DAY;
 /** @type {string} */
Ext.Date.HOUR;
 /** @type {string} */
Ext.Date.MILLI;
 /** @type {string} */
Ext.Date.MINUTE;
 /** @type {string} */
Ext.Date.MONTH;
 /** @type {string} */
Ext.Date.SECOND;
 /** @type {string} */
Ext.Date.YEAR;
 /** @type {!Array<string>} */
Ext.Date.dayNames;
 /** @type {string} */
Ext.Date.defaultFormat;
 /** @type {?} */
Ext.Date.defaults;
 /** @type {?} */
Ext.Date.formatCodes;
 /** @type {?} */
Ext.Date.formatFunctions;
 /** @type {!Array<string>} */
Ext.Date.monthNames;
 /** @type {?} */
Ext.Date.monthNumbers;
 /** @type {?} */
Ext.Date.parseFunctions;
 /** @type {boolean} */
Ext.Date.useStrict;

/**
 * [Method] Provides a convenient method for performing basic date arithmetic
 * @param {?=} date Date The date to modify
 * @param {string=} interval String A valid date interval enum value.
 * @param {number=} value Number The amount to add to the current date.
 * @return {?} Date The new Date instance.
 */
Ext.Date.add = function(date, interval, value) {};

/**
 * [Method] Checks if a date falls on or between the given start and end dates
 * @param {?=} date Date The date to check
 * @param {?=} start Date Start date
 * @param {?=} end Date End date
 * @return {boolean} Boolean true if this date falls on or between the given start and end dates.
 */
Ext.Date.between = function(date, start, end) {};

/**
 * [Method] Attempts to clear all time information from this Date by setting the time to midnight of the same day automatically
 * @param {?=} date Date The date
 * @param {boolean=} clone Boolean true to create a clone of this date, clear the time and return it.
 * @return {?} Date this or the clone.
 */
Ext.Date.clearTime = function(date, clone) {};

/**
 * [Method] Creates and returns a new Date instance with the exact same date value as the called instance
 * @param {?=} date Date The date.
 * @return {?} Date The new Date instance.
 */
Ext.Date.clone = function(date) {};

/**
 * [Method] Formats a date given the supplied format string
 * @param {?=} date Date The date to format
 * @param {string=} format String The format string
 * @return {string} String The formatted date or an empty string if date parameter is not a JavaScript Date object
 */
Ext.Date.format = function(date, format) {};

/**
 * [Method] Checks if the specified format contains information about anything other than the time
 * @param {string=} format String The format to check
 * @return {boolean} Boolean True if the format contains information about date/day information.
 */
Ext.Date.formatContainsDateInfo = function(format) {};

/**
 * [Method] Checks if the specified format contains hour information
 * @param {string=} format String The format to check
 * @return {boolean} Boolean True if the format contains hour information
 */
Ext.Date.formatContainsHourInfo = function(format) {};

/**
 * [Method] Get the numeric day number of the year adjusted for leap year
 * @param {?=} date Date The date
 * @return {number} Number 0 to 364 (365 in leap years).
 */
Ext.Date.getDayOfYear = function(date) {};

/**
 * [Method] Get the number of days in the current month adjusted for leap year
 * @param {?=} date Date The date
 * @return {number} Number The number of days in the month.
 */
Ext.Date.getDaysInMonth = function(date) {};

/**
 * [Method] Returns the number of milliseconds between two dates
 * @param {?=} dateA Date The first date.
 * @param {?=} dateB Date The second date.
 * @return {number} Number The difference in milliseconds
 */
Ext.Date.getElapsed = function(dateA, dateB) {};

/**
 * [Method] Get the date of the first day of the month in which this date resides
 * @param {?=} date Date The date
 * @return {?} Date
 */
Ext.Date.getFirstDateOfMonth = function(date) {};

/**
 * [Method] Get the first day of the current month adjusted for leap year
 * @param {?=} date Date The date
 * @return {number} Number The day number (0-6).
 */
Ext.Date.getFirstDayOfMonth = function(date) {};

/**
 * [Method] Get the offset from GMT of the current date equivalent to the format specifier O
 * @param {?=} date Date The date
 * @param {boolean=} colon Boolean true to separate the hours and minutes with a colon.
 * @return {string} String The 4-character offset string prefixed with + or - (e.g. '-0600').
 */
Ext.Date.getGMTOffset = function(date, colon) {};

/**
 * [Method] Get the date of the last day of the month in which this date resides
 * @param {?=} date Date The date
 * @return {?} Date
 */
Ext.Date.getLastDateOfMonth = function(date) {};

/**
 * [Method] Get the last day of the current month adjusted for leap year
 * @param {?=} date Date The date
 * @return {number} Number The day number (0-6).
 */
Ext.Date.getLastDayOfMonth = function(date) {};

/**
 * [Method] Get the zero based JavaScript month number for the given short full month name
 * @param {string=} name String The short/full month name.
 * @return {number} Number The zero-based JavaScript month number.
 */
Ext.Date.getMonthNumber = function(name) {};

/**
 * [Method] Get the short day name for the given day number
 * @param {number=} day Number A zero-based JavaScript day number.
 * @return {string} String The short day name.
 */
Ext.Date.getShortDayName = function(day) {};

/**
 * [Method] Get the short month name for the given month number
 * @param {number=} month Number A zero-based JavaScript month number.
 * @return {string} String The short month name.
 */
Ext.Date.getShortMonthName = function(month) {};

/**
 * [Method] Get the English ordinal suffix of the current day equivalent to the format specifier S
 * @param {?=} date Date The date
 * @return {string} String 'st, 'nd', 'rd' or 'th'.
 */
Ext.Date.getSuffix = function(date) {};

/**
 * [Method] Get the timezone abbreviation of the current date equivalent to the format specifier T
 * @param {?=} date Date The date
 * @return {string} String The abbreviated timezone name (e.g. 'CST', 'PDT', 'EDT', 'MPST' ...).
 */
Ext.Date.getTimezone = function(date) {};

/**
 * [Method] Get the numeric ISO 8601 week number of the year
 * @param {?=} date Date The date
 * @return {number} Number 1 to 53
 */
Ext.Date.getWeekOfYear = function(date) {};

/**
 * [Method] Checks if the current date is affected by Daylight Saving Time DST
 * @param {?=} date Date The date
 * @return {boolean} Boolean true if the current date is affected by DST.
 */
Ext.Date.isDST = function(date) {};

/**
 * [Method] Compares if two dates are equal by comparing their values
 * @param {?=} date1 Date
 * @param {?=} date2 Date
 * @return {boolean} Boolean true if the date values are equal
 */
Ext.Date.isEqual = function(date1, date2) {};

/**
 * [Method] Checks if the current date falls within a leap year
 * @param {?=} date Date The date
 * @return {boolean} Boolean True if the current date falls within a leap year, false otherwise.
 */
Ext.Date.isLeapYear = function(date) {};

/**
 * [Method] Checks if the passed Date parameters will cause a JavaScript Date rollover
 * @param {number=} year Number 4-digit year
 * @param {number=} month Number 1-based month-of-year
 * @param {number=} day Number Day of month
 * @param {number=} hour Number Hour
 * @param {number=} minute Number Minute
 * @param {number=} second Number Second
 * @param {number=} millisecond Number Millisecond
 * @return {boolean} Boolean true if the passed parameters do not cause a Date "rollover", false otherwise.
 */
Ext.Date.isValid = function(year, month, day, hour, minute, second, millisecond) {};

/**
 * [Method] Returns the current timestamp
 * @return {number} Number Milliseconds since UNIX epoch.
 */
Ext.Date.now = function() {};

/**
 * [Method] Parses the passed string using the specified date format
 * @param {string=} input String The raw date string.
 * @param {string=} format String The expected date string format.
 * @param {boolean=} strict Boolean true to validate date strings while parsing (i.e. prevents JavaScript Date "rollover"). Invalid date strings will return null when parsed.
 * @return {?} Date The parsed Date.
 */
Ext.Date.parse = function(input, format, strict) {};

/**
 * [Method] Provides a convenient method for performing basic date arithmetic
 * @param {?=} date Date The date to modify
 * @param {string=} interval String A valid date interval enum value.
 * @param {number=} value Number The amount to subtract from the current date.
 * @return {?} Date The new Date instance.
 */
Ext.Date.subtract = function(date, interval, value) {};

/**
 * [Method] Removes all escaping for a date format string
 * @param {string=} format String The format to unescape
 * @return {string} String The unescaped format
 */
Ext.Date.unescapeFormat = function(format) {};
/** @const */
Ext.dd = {};
/**
 * @extends {Ext.dd.IDragDrop}
 * @record
 * @struct
 */
Ext.dd.IDD = function() {};
 /** @type {boolean} */
Ext.dd.IDD.prototype.scroll;

/**
 * [Method] Sets the element to the location of the mousedown or click event maintaining the cursor location relative to the loc
 * @param {!HTMLElement=} el HTMLElement the element to move
 * @param {number=} iPageX Number the X coordinate of the mousedown or drag event
 * @param {number=} iPageY Number the Y coordinate of the mousedown or drag event
 * @return {void}
 */
Ext.dd.IDD.prototype.alignElWithMouse = function(el, iPageX, iPageY) {};

/**
 * [Method] Sets up config options specific to this class
 * @return {void}
 */
Ext.dd.IDD.prototype.applyConfig = function() {};

/**
 * [Method] Sets the pointer offset to the distance between the linked element s top left corner and the location the element was
 * @param {number=} iPageX Number the X coordinate of the click
 * @param {number=} iPageY Number the Y coordinate of the click
 * @return {void}
 */
Ext.dd.IDD.prototype.autoOffset = function(iPageX, iPageY) {};

/**
 * [Method] Event that fires prior to the onDrag event
 * @param {?=} e Object
 * @return {void}
 */
Ext.dd.IDD.prototype.b4Drag = function(e) {};

/**
 * [Method] Event that fires prior to the onMouseDown event
 * @param {?=} e Object
 * @return {void}
 */
Ext.dd.IDD.prototype.b4MouseDown = function(e) {};

/**
 * [Method] Saves the most recent position so that we can reset the constraints and tick marks on demand
 * @param {number=} iPageX Number the current x position (this just makes it so we don't have to look it up again)
 * @param {number=} iPageY Number the current y position (this just makes it so we don't have to look it up again)
 * @return {void}
 */
Ext.dd.IDD.prototype.cachePosition = function(iPageX, iPageY) {};

/**
 * [Method] Sets the pointer offset
 * @param {number=} iDeltaX Number the distance from the left
 * @param {number=} iDeltaY Number the distance from the top
 * @return {void}
 */
Ext.dd.IDD.prototype.setDelta = function(iDeltaX, iDeltaY) {};

/**
 * [Method] Sets the drag element to the location of the mousedown or click event maintaining the cursor location relative to th
 * @param {number=} iPageX Number the X coordinate of the mousedown or drag event
 * @param {number=} iPageY Number the Y coordinate of the mousedown or drag event
 * @return {void}
 */
Ext.dd.IDD.prototype.setDragElPos = function(iPageX, iPageY) {};

/**
 * [Method] toString method
 * @return {string} String string representation of the dd obj
 */
Ext.dd.IDD.prototype.toString = function() {};
/**
 * @extends {Ext.dd.IDD}
 * @record
 * @struct
 */
Ext.dd.IDDProxy = function() {};
 /** @type {boolean} */
Ext.dd.IDDProxy.prototype.centerFrame;
 /** @type {boolean} */
Ext.dd.IDDProxy.prototype.resizeFrame;
 /** @type {string} */
Ext.dd.IDDProxy.prototype.dragElId;

/**
 * [Method] Sets up config options specific to this class
 * @return {void}
 */
Ext.dd.IDDProxy.prototype.applyConfig = function() {};

/**
 * [Method] overrides Ext dd DragDrop
 * @param {?=} e Object
 * @return {void}
 */
Ext.dd.IDDProxy.prototype.b4MouseDown = function(e) {};

/**
 * [Method] Creates the proxy element if it does not yet exist
 * @return {void}
 */
Ext.dd.IDDProxy.prototype.createFrame = function() {};

/**
 * [Method] overrides Ext dd DragDrop By default we try to move the element to the last location of the frame
 * @param {?=} e Object
 * @return {void}
 */
Ext.dd.IDDProxy.prototype.endDrag = function(e) {};

/**
 * [Method] Initialization for the drag frame element
 * @return {void}
 */
Ext.dd.IDDProxy.prototype.initFrame = function() {};

/**
 * [Method] toString method
 * @return {string} String string representation of the dd obj
 */
Ext.dd.IDDProxy.prototype.toString = function() {};
/**
 * @extends {Ext.dd.IDragDrop}
 * @record
 * @struct
 */
Ext.dd.IDDTarget = function() {};

/**
 * [Method] toString method
 * @return {string} String string representation of the dd obj
 */
Ext.dd.IDDTarget.prototype.toString = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.dd.IDragDrop = function() {};
 /** @type {boolean} */
Ext.dd.IDragDrop.prototype.available;
 /** @type {?} */
Ext.dd.IDragDrop.prototype.config;
 /** @type {?} */
Ext.dd.IDragDrop.prototype.defaultPadding;
 /** @type {?} */
Ext.dd.IDragDrop.prototype.groups;
 /** @type {boolean} */
Ext.dd.IDragDrop.prototype.hasOuterHandles;
 /** @type {string} */
Ext.dd.IDragDrop.prototype.id;
 /** @type {boolean} */
Ext.dd.IDragDrop.prototype.ignoreSelf;
 /** @type {!Array<string>} */
Ext.dd.IDragDrop.prototype.invalidHandleClasses;
 /** @type {?} */
Ext.dd.IDragDrop.prototype.invalidHandleIds;
 /** @type {?} */
Ext.dd.IDragDrop.prototype.invalidHandleTypes;
 /** @type {boolean} */
Ext.dd.IDragDrop.prototype.isTarget;
 /** @type {boolean} */
Ext.dd.IDragDrop.prototype.maintainOffset;
 /** @type {boolean} */
Ext.dd.IDragDrop.prototype.moveOnly;
 /** @type {!Array<number>} */
Ext.dd.IDragDrop.prototype.padding;
 /** @type {boolean} */
Ext.dd.IDragDrop.prototype.primaryButtonOnly;
 /** @type {!Array<number>} */
Ext.dd.IDragDrop.prototype.xTicks;
 /** @type {!Array<number>} */
Ext.dd.IDragDrop.prototype.yTicks;

/**
 * [Method] Lets you specify a css class of elements that will not initiate a drag
 * @param {string=} cssClass String the class of the elements you wish to ignore
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.addInvalidHandleClass = function(cssClass) {};

/**
 * [Method] Lets you to specify an element id for a child of a drag handle that should not initiate a drag
 * @param {string=} id String the element id of the element you wish to ignore
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.addInvalidHandleId = function(id) {};

/**
 * [Method] Allows you to specify a tag name that should not start a drag operation when clicked
 * @param {string=} tagName String the type of element to exclude
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.addInvalidHandleType = function(tagName) {};

/**
 * [Method] Adds this instance to a group of related drag drop objects
 * @param {string=} sGroup String the name of the group
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.addToGroup = function(sGroup) {};

/**
 * [Method] Applies the configuration parameters that were passed into the constructor
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.applyConfig = function() {};

/**
 * [Method] Clears any constraints applied to this instance
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.clearConstraints = function() {};

/**
 * [Method] Clears any tick interval defined for this instance
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.clearTicks = function() {};

/**
 * [Method] Initializes the drag drop object s constraints to restrict movement to a certain element
 * @param {?=} constrainTo String/HTMLElement/Ext.Element The element or element ID to constrain to.
 * @param {?=} pad Object/Number Pad provides a way to specify "padding" of the constraints, and can be either a number for symmetrical padding (4 would be equal to {left:4, right:4, top:4, bottom:4}) or an object containing the sides to pad. For example: {right:10, bottom:10}
 * @param {boolean=} inContent Boolean Constrain the draggable in the content box of the element (inside padding and borders)
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.constrainTo = function(constrainTo, pad, inContent) {};

/**
 * [Method] Destroy this DragDrop instance
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.destroy = function() {};

/**
 * [Method] Called when we are done dragging the object
 * @param {!Event=} e Event the mouseup event
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.endDrag = function(e) {};

/**
 * [Method] Returns a reference to the actual element to drag
 * @return {!HTMLElement} HTMLElement the html element
 */
Ext.dd.IDragDrop.prototype.getDragEl = function() {};

/**
 * [Method] Returns a reference to the linked element
 * @return {!HTMLElement} HTMLElement the html element
 */
Ext.dd.IDragDrop.prototype.getEl = function() {};

/**
 * [Method] Sets up the DragDrop object
 * @param {string=} id String the id of the linked element
 * @param {string=} sGroup String the group of related items
 * @param {?=} config Object configuration attributes
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.init = function(id, sGroup, config) {};

/**
 * [Method] Initializes Targeting functionality only
 * @param {string=} id String the id of the linked element
 * @param {string=} sGroup String the group of related items
 * @param {?=} config Object configuration attributes
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.initTarget = function(id, sGroup, config) {};

/**
 * [Method] Returns true if this instance is locked or the drag drop mgr is locked meaning that all drag drop is disabled on th
 * @return {boolean} Boolean true if this obj or all drag/drop is locked, else false
 */
Ext.dd.IDragDrop.prototype.isLocked = function() {};

/**
 * [Method] Checks the tag exclusion list to see if this click should be ignored
 * @param {!HTMLElement=} node HTMLElement the HTMLElement to evaluate
 * @return {boolean} Boolean true if this is a valid tag type, false if not
 */
Ext.dd.IDragDrop.prototype.isValidHandleChild = function(node) {};

/**
 * [Method] Locks this instance
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.lock = function() {};

/**
 * [Method] Override the onAvailable method to do what is needed after the initial position was determined
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.onAvailable = function() {};

/**
 * [Method] Abstract method called during the onMouseMove event while dragging an object
 * @param {!Event=} e Event the mousemove event
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.onDrag = function(e) {};

/**
 * [Method] Abstract method called when this item is dropped on another DragDrop obj
 * @param {!Event=} e Event the mouseup event
 * @param {?=} id String/Ext.dd.DragDrop[] In POINT mode, the element id this was dropped on. In INTERSECT mode, an array of dd items this was dropped on.
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.onDragDrop = function(e, id) {};

/**
 * [Method] Abstract method called when this element fist begins hovering over another DragDrop obj
 * @param {!Event=} e Event the mousemove event
 * @param {?=} id String/Ext.dd.DragDrop[] In POINT mode, the element id this is hovering over. In INTERSECT mode, an array of one or more dragdrop items being hovered over.
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.onDragEnter = function(e, id) {};

/**
 * [Method] Abstract method called when we are no longer hovering over an element
 * @param {!Event=} e Event the mousemove event
 * @param {?=} id String/Ext.dd.DragDrop[] In POINT mode, the element id this was hovering over. In INTERSECT mode, an array of dd items that the mouse is no longer over.
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.onDragOut = function(e, id) {};

/**
 * [Method] Abstract method called when this element is hovering over another DragDrop obj
 * @param {!Event=} e Event the mousemove event
 * @param {?=} id String/Ext.dd.DragDrop[] In POINT mode, the element id this is hovering over. In INTERSECT mode, an array of dd items being hovered over.
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.onDragOver = function(e, id) {};

/**
 * [Method] Abstract method called when this item is dropped on an area with no drop target
 * @param {!Event=} e Event the mouseup event
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.onInvalidDrop = function(e) {};

/**
 * [Method] Called when a drag drop obj gets a mousedown
 * @param {!Event=} e Event the mousedown event
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.onMouseDown = function(e) {};

/**
 * [Method] Called when a drag drop obj gets a mouseup
 * @param {!Event=} e Event the mouseup event
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.onMouseUp = function(e) {};

/**
 * [Method] Removes this instance from the supplied interaction group
 * @param {string=} sGroup String The group to drop
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.removeFromGroup = function(sGroup) {};

/**
 * [Method] Unsets an invalid css class
 * @param {string=} cssClass String the class of the element(s) you wish to re-enable
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.removeInvalidHandleClass = function(cssClass) {};

/**
 * [Method] Unsets an invalid handle id
 * @param {string=} id String the id of the element to re-enable
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.removeInvalidHandleId = function(id) {};

/**
 * [Method] Unsets an excluded tag name set by addInvalidHandleType
 * @param {string=} tagName String the type of element to unexclude
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.removeInvalidHandleType = function(tagName) {};

/**
 * [Method] Must be called if you manually reposition a dd element
 * @param {boolean=} maintainOffset Boolean
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.resetConstraints = function(maintainOffset) {};

/**
 * [Method] Allows you to specify that an element other than the linked element will be moved with the cursor during a drag
 * @param {string=} id String the id of the element that will be used to initiate the drag
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.setDragElId = function(id) {};

/**
 * [Method] Allows you to specify a child of the linked element that should be used to initiate the drag operation
 * @param {string=} id String the id of the element that will be used to initiate the drag.
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.setHandleElId = function(id) {};

/**
 * [Method] Stores the initial placement of the linked element
 * @param {number=} diffX Number the X offset, default 0
 * @param {number=} diffY Number the Y offset, default 0
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.setInitPosition = function(diffX, diffY) {};

/**
 * [Method] Allows you to set an element outside of the linked element as a drag handle
 * @param {string=} id String the id of the element that will be used to initiate the drag
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.setOuterHandleElId = function(id) {};

/**
 * [Method] Configures the padding for the target zone in px
 * @param {number=} iTop Number Top pad
 * @param {number=} iRight Number Right pad
 * @param {number=} iBot Number Bot pad
 * @param {number=} iLeft Number Left pad
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.setPadding = function(iTop, iRight, iBot, iLeft) {};

/**
 * [Method] By default the element can be dragged any place on the screen
 * @param {number=} iLeft Number the number of pixels the element can move to the left
 * @param {number=} iRight Number the number of pixels the element can move to the right
 * @param {number=} iTickSize Number parameter for specifying that the element should move iTickSize pixels at a time.
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.setXConstraint = function(iLeft, iRight, iTickSize) {};

/**
 * [Method] By default the element can be dragged any place on the screen
 * @param {number=} iUp Number the number of pixels the element can move up
 * @param {number=} iDown Number the number of pixels the element can move down
 * @param {number=} iTickSize Number parameter for specifying that the element should move iTickSize pixels at a time.
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.setYConstraint = function(iUp, iDown, iTickSize) {};

/**
 * [Method] Abstract method called after a drag drop object is clicked and the drag or mousedown time thresholds have beeen met
 * @param {number=} x Number X click location
 * @param {number=} y Number Y click location
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.startDrag = function(x, y) {};

/**
 * [Method] toString method
 * @return {string} String string representation of the dd obj
 */
Ext.dd.IDragDrop.prototype.toString = function() {};

/**
 * [Method] Unlocks this instace
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.unlock = function() {};

/**
 * [Method] Removes all drag and drop hooks for this element
 * @return {void}
 */
Ext.dd.IDragDrop.prototype.unreg = function() {};
/**
 * @record
 * @struct
 */
Ext.dd.IDragDropElement = function() {};

/**
 * [Method] Returns the X position of an html element
 * @param {!HTMLElement=} el HTMLElement the element for which to get the position
 * @return {number} Number the X coordinate
 */
Ext.dd.IDragDropElement.prototype.getPosX = function(el) {};

/**
 * [Method] Returns the Y position of an html element
 * @param {!HTMLElement=} el HTMLElement the element for which to get the position
 * @return {number} Number the Y coordinate
 */
Ext.dd.IDragDropElement.prototype.getPosY = function(el) {};

/**
 * [Method] Gets the scrollLeft
 * @return {number} Number the document's scrollTop
 */
Ext.dd.IDragDropElement.prototype.getScrollLeft = function() {};

/**
 * [Method] Gets the scrollTop
 * @return {number} Number the document's scrollTop
 */
Ext.dd.IDragDropElement.prototype.getScrollTop = function() {};

/**
 * [Method] Returns the specified element style property
 * @param {!HTMLElement=} el HTMLElement the element
 * @param {string=} styleProp String the style property
 * @return {string} String The value of the style property
 */
Ext.dd.IDragDropElement.prototype.getStyle = function(el, styleProp) {};

/**
 * [Method] Recursively searches the immediate parent and all child nodes for the handle element in order to determine wheter or
 * @param {!HTMLElement=} node HTMLElement the html element to inspect
 * @return {void}
 */
Ext.dd.IDragDropElement.prototype.handleWasClicked = function(node) {};

/**
 * [Method] Sets the x y position of an element to the location of the target element
 * @param {!HTMLElement=} moveEl HTMLElement The element to move
 * @param {!HTMLElement=} targetEl HTMLElement The position reference element
 * @return {void}
 */
Ext.dd.IDragDropElement.prototype.moveToEl = function(moveEl, targetEl) {};

/**
 * [Method] Numeric array sort function
 * @param {number=} a Number
 * @param {number=} b Number
 * @return {number} Number positive, negative or 0
 */
Ext.dd.IDragDropElement.prototype.numericSort = function(a, b) {};

/**
 * [Method] Swap two nodes
 * @param {!HTMLElement=} n1 HTMLElement the first node to swap
 * @param {!HTMLElement=} n2 HTMLElement the other node to swap
 * @return {void}
 */
Ext.dd.IDragDropElement.prototype.swapNode = function(n1, n2) {};
/** @const */
Ext.dd.dragdropmanager = {};
/**
 * @record
 * @struct
 */
Ext.dd.dragdropmanager.IElementWrapper = function() {};
 /** @type {?} */
Ext.dd.dragdropmanager.IElementWrapper.prototype.css;
 /** @type {?} */
Ext.dd.dragdropmanager.IElementWrapper.prototype.el;
 /** @type {?} */
Ext.dd.dragdropmanager.IElementWrapper.prototype.id;
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.dd.IDragDropManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.dd.DragDropManager = function() {};
 /** @type {number} */
Ext.dd.DragDropManager.INTERSECT;
 /** @type {number} */
Ext.dd.DragDropManager.POINT;
 /** @type {number} */
Ext.dd.DragDropManager.clickPixelThresh;
 /** @type {number} */
Ext.dd.DragDropManager.clickTimeThresh;
 /** @type {string} */
Ext.dd.DragDropManager.dragCls;
 /** @type {number} */
Ext.dd.DragDropManager.mode;
 /** @type {boolean} */
Ext.dd.DragDropManager.notifyOccluded;
 /** @type {boolean} */
Ext.dd.DragDropManager.preventDefault;
 /** @type {!Ext.IClass} */
Ext.dd.DragDropManager.self;
 /** @type {boolean} */
Ext.dd.DragDropManager.stopPropagation;
 /** @type {boolean} */
Ext.dd.DragDropManager.useCache;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.dd.DragDropManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.dd.DragDropManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.dd.DragDropManager.callSuper = function(args) {};

/**
 * [Method] Helper function for getting the best match from the list of drag and drop objects returned by the drag and drop event
 * @param {!Array<!Ext.dd.IDragDrop>=} dds Ext.dd.DragDrop[] The array of drag and drop objects targeted
 * @return {!Ext.dd.IDragDrop} Ext.dd.DragDrop The best single match
 */
Ext.dd.DragDropManager.getBestMatch = function(dds) {};

/**
 * [Method] Returns the style property for the DOM element i e  document getElById id style
 * @param {string=} id String the id of the elment to get
 * @return {?} Object The style property of the element
 */
Ext.dd.DragDropManager.getCss = function(id) {};

/**
 * [Method] Returns the DragDrop instance for a given id
 * @param {string=} id String the id of the DragDrop object
 * @return {!Ext.dd.IDragDrop} Ext.dd.DragDrop the drag drop object, null if it is not found
 */
Ext.dd.DragDropManager.getDDById = function(id) {};

/**
 * [Method] Returns the actual DOM element
 * @param {string=} id String the id of the elment to get
 * @return {?} Object The element
 */
Ext.dd.DragDropManager.getElement = function(id) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.dd.DragDropManager.getInitialConfig = function(name) {};

/**
 * [Method] Returns a Region object containing the drag and drop element s position and size including the padding configured fo
 * @param {!Ext.dd.IDragDrop=} oDD Ext.dd.DragDrop the drag and drop object to get the location for.
 * @return {!Ext.util.IRegion} Ext.util.Region a Region object representing the total area the element occupies, including any padding the instance is configured for.
 */
Ext.dd.DragDropManager.getLocation = function(oDD) {};

/**
 * [Method] Returns the drag and drop instances that are in all groups the passed in instance belongs to
 * @param {!Ext.dd.IDragDrop=} p_oDD Ext.dd.DragDrop the obj to get related data for
 * @param {boolean=} bTargetsOnly Boolean if true, only return targetable objs
 * @return {!Array<!Ext.dd.IDragDrop>} Ext.dd.DragDrop[] the related instances
 */
Ext.dd.DragDropManager.getRelated = function(p_oDD, bTargetsOnly) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.dd.DragDropManager.initConfig = function(config) {};

/**
 * [Method] Utility function to determine if a given element has been registered as a drag drop item
 * @param {string=} id String the element id to check
 * @return {boolean} Boolean true if this element is a DragDrop item, false otherwise
 */
Ext.dd.DragDropManager.isDragDrop = function(id) {};

/**
 * [Method] Utility function to determine if a given element has been registered as a drag drop handle for the given Drag Drop ob
 * @param {string=} id String the element id to check
 * @return {boolean} Boolean true if this element is a DragDrop handle, false otherwise
 */
Ext.dd.DragDropManager.isHandle = function(id) {};

/**
 * [Method] Returns true if the specified dd target is a legal target for the specifice drag obj
 * @param {!Ext.dd.IDragDrop=} oDD Ext.dd.DragDrop the drag obj
 * @param {!Ext.dd.IDragDrop=} oTargetDD Ext.dd.DragDrop the target
 * @return {boolean} Boolean true if the target is a legal target for the dd obj
 */
Ext.dd.DragDropManager.isLegalTarget = function(oDD, oTargetDD) {};

/**
 * [Method] Is drag and drop locked
 * @return {boolean} Boolean True if drag and drop is locked, false otherwise.
 */
Ext.dd.DragDropManager.isLocked = function() {};

/**
 * [Method] My goal is to be able to transparently determine if an object is typeof DragDrop and the exact subclass of DragDrop
 * @param {?=} the Object object to evaluate
 * @return {boolean} Boolean true if typeof oDD = DragDrop
 */
Ext.dd.DragDropManager.isTypeOfDD = function(the) {};

/**
 * [Method] Lock all drag and drop functionality
 * @return {void}
 */
Ext.dd.DragDropManager.lock = function() {};

/**
 * [Method] Refreshes the cache of the top left and bottom right points of the drag and drop objects in the specified group s
 * @param {?=} groups Object an associative array of groups to refresh
 * @return {void}
 */
Ext.dd.DragDropManager.refreshCache = function(groups) {};

/**
 * [Method] Each DragDrop instance must be registered with the DragDropManager
 * @param {!Ext.dd.IDragDrop=} oDD Ext.dd.DragDrop the DragDrop object to register
 * @param {string=} sGroup String the name of the group this element belongs to
 * @return {void}
 */
Ext.dd.DragDropManager.regDragDrop = function(oDD, sGroup) {};

/**
 * [Method] Each DragDrop handle element must be registered
 * @param {string=} sDDId String the DragDrop id this element is a handle for
 * @param {string=} sHandleId String the id of the element that is the drag handle
 * @return {void}
 */
Ext.dd.DragDropManager.regHandle = function(sDDId, sHandleId) {};

/**
 * [Method] Fired when either the drag pixel threshold or the mousedown hold time threshold has been met
 * @param {number=} x Number the X position of the original mousedown
 * @param {number=} y Number the Y position of the original mousedown
 * @return {void}
 */
Ext.dd.DragDropManager.startDrag = function(x, y) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.dd.DragDropManager.statics = function() {};

/**
 * [Method] Utility to stop event propagation and event default if these features are turned on
 * @param {!Event=} e Event the event as returned by this.getEvent()
 * @return {void}
 */
Ext.dd.DragDropManager.stopEvent = function(e) {};

/**
 * [Method] Unlock all drag and drop functionality
 * @return {void}
 */
Ext.dd.DragDropManager.unlock = function() {};

/**
 * [Method] This checks to make sure an element exists and is in the DOM
 * @param {!HTMLElement=} el HTMLElement the element to check
 * @return {boolean} Boolean true if the element looks usable
 */
Ext.dd.DragDropManager.verifyEl = function(el) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.dd.IDragDropMgr = function() {};
/**
 * @constructor
 * @struct
 */
Ext.dd.DragDropMgr = function() {};
 /** @type {number} */
Ext.dd.DragDropMgr.INTERSECT;
 /** @type {number} */
Ext.dd.DragDropMgr.POINT;
 /** @type {number} */
Ext.dd.DragDropMgr.clickPixelThresh;
 /** @type {number} */
Ext.dd.DragDropMgr.clickTimeThresh;
 /** @type {string} */
Ext.dd.DragDropMgr.dragCls;
 /** @type {number} */
Ext.dd.DragDropMgr.mode;
 /** @type {boolean} */
Ext.dd.DragDropMgr.notifyOccluded;
 /** @type {boolean} */
Ext.dd.DragDropMgr.preventDefault;
 /** @type {!Ext.IClass} */
Ext.dd.DragDropMgr.self;
 /** @type {boolean} */
Ext.dd.DragDropMgr.stopPropagation;
 /** @type {boolean} */
Ext.dd.DragDropMgr.useCache;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.dd.DragDropMgr.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.dd.DragDropMgr.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.dd.DragDropMgr.callSuper = function(args) {};

/**
 * [Method] Helper function for getting the best match from the list of drag and drop objects returned by the drag and drop event
 * @param {!Array<!Ext.dd.IDragDrop>=} dds Ext.dd.DragDrop[] The array of drag and drop objects targeted
 * @return {!Ext.dd.IDragDrop} Ext.dd.DragDrop The best single match
 */
Ext.dd.DragDropMgr.getBestMatch = function(dds) {};

/**
 * [Method] Returns the style property for the DOM element i e  document getElById id style
 * @param {string=} id String the id of the elment to get
 * @return {?} Object The style property of the element
 */
Ext.dd.DragDropMgr.getCss = function(id) {};

/**
 * [Method] Returns the DragDrop instance for a given id
 * @param {string=} id String the id of the DragDrop object
 * @return {!Ext.dd.IDragDrop} Ext.dd.DragDrop the drag drop object, null if it is not found
 */
Ext.dd.DragDropMgr.getDDById = function(id) {};

/**
 * [Method] Returns the actual DOM element
 * @param {string=} id String the id of the elment to get
 * @return {?} Object The element
 */
Ext.dd.DragDropMgr.getElement = function(id) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.dd.DragDropMgr.getInitialConfig = function(name) {};

/**
 * [Method] Returns a Region object containing the drag and drop element s position and size including the padding configured fo
 * @param {!Ext.dd.IDragDrop=} oDD Ext.dd.DragDrop the drag and drop object to get the location for.
 * @return {!Ext.util.IRegion} Ext.util.Region a Region object representing the total area the element occupies, including any padding the instance is configured for.
 */
Ext.dd.DragDropMgr.getLocation = function(oDD) {};

/**
 * [Method] Returns the drag and drop instances that are in all groups the passed in instance belongs to
 * @param {!Ext.dd.IDragDrop=} p_oDD Ext.dd.DragDrop the obj to get related data for
 * @param {boolean=} bTargetsOnly Boolean if true, only return targetable objs
 * @return {!Array<!Ext.dd.IDragDrop>} Ext.dd.DragDrop[] the related instances
 */
Ext.dd.DragDropMgr.getRelated = function(p_oDD, bTargetsOnly) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.dd.DragDropMgr.initConfig = function(config) {};

/**
 * [Method] Utility function to determine if a given element has been registered as a drag drop item
 * @param {string=} id String the element id to check
 * @return {boolean} Boolean true if this element is a DragDrop item, false otherwise
 */
Ext.dd.DragDropMgr.isDragDrop = function(id) {};

/**
 * [Method] Utility function to determine if a given element has been registered as a drag drop handle for the given Drag Drop ob
 * @param {string=} id String the element id to check
 * @return {boolean} Boolean true if this element is a DragDrop handle, false otherwise
 */
Ext.dd.DragDropMgr.isHandle = function(id) {};

/**
 * [Method] Returns true if the specified dd target is a legal target for the specifice drag obj
 * @param {!Ext.dd.IDragDrop=} oDD Ext.dd.DragDrop the drag obj
 * @param {!Ext.dd.IDragDrop=} oTargetDD Ext.dd.DragDrop the target
 * @return {boolean} Boolean true if the target is a legal target for the dd obj
 */
Ext.dd.DragDropMgr.isLegalTarget = function(oDD, oTargetDD) {};

/**
 * [Method] Is drag and drop locked
 * @return {boolean} Boolean True if drag and drop is locked, false otherwise.
 */
Ext.dd.DragDropMgr.isLocked = function() {};

/**
 * [Method] My goal is to be able to transparently determine if an object is typeof DragDrop and the exact subclass of DragDrop
 * @param {?=} the Object object to evaluate
 * @return {boolean} Boolean true if typeof oDD = DragDrop
 */
Ext.dd.DragDropMgr.isTypeOfDD = function(the) {};

/**
 * [Method] Lock all drag and drop functionality
 * @return {void}
 */
Ext.dd.DragDropMgr.lock = function() {};

/**
 * [Method] Refreshes the cache of the top left and bottom right points of the drag and drop objects in the specified group s
 * @param {?=} groups Object an associative array of groups to refresh
 * @return {void}
 */
Ext.dd.DragDropMgr.refreshCache = function(groups) {};

/**
 * [Method] Each DragDrop instance must be registered with the DragDropManager
 * @param {!Ext.dd.IDragDrop=} oDD Ext.dd.DragDrop the DragDrop object to register
 * @param {string=} sGroup String the name of the group this element belongs to
 * @return {void}
 */
Ext.dd.DragDropMgr.regDragDrop = function(oDD, sGroup) {};

/**
 * [Method] Each DragDrop handle element must be registered
 * @param {string=} sDDId String the DragDrop id this element is a handle for
 * @param {string=} sHandleId String the id of the element that is the drag handle
 * @return {void}
 */
Ext.dd.DragDropMgr.regHandle = function(sDDId, sHandleId) {};

/**
 * [Method] Fired when either the drag pixel threshold or the mousedown hold time threshold has been met
 * @param {number=} x Number the X position of the original mousedown
 * @param {number=} y Number the Y position of the original mousedown
 * @return {void}
 */
Ext.dd.DragDropMgr.startDrag = function(x, y) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.dd.DragDropMgr.statics = function() {};

/**
 * [Method] Utility to stop event propagation and event default if these features are turned on
 * @param {!Event=} e Event the event as returned by this.getEvent()
 * @return {void}
 */
Ext.dd.DragDropMgr.stopEvent = function(e) {};

/**
 * [Method] Unlock all drag and drop functionality
 * @return {void}
 */
Ext.dd.DragDropMgr.unlock = function() {};

/**
 * [Method] This checks to make sure an element exists and is in the DOM
 * @param {!HTMLElement=} el HTMLElement the element to check
 * @return {boolean} Boolean true if the element looks usable
 */
Ext.dd.DragDropMgr.verifyEl = function(el) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.dd.IDDM = function() {};
/**
 * @constructor
 * @struct
 */
Ext.dd.DDM = function() {};
 /** @type {number} */
Ext.dd.DDM.INTERSECT;
 /** @type {number} */
Ext.dd.DDM.POINT;
 /** @type {number} */
Ext.dd.DDM.clickPixelThresh;
 /** @type {number} */
Ext.dd.DDM.clickTimeThresh;
 /** @type {string} */
Ext.dd.DDM.dragCls;
 /** @type {number} */
Ext.dd.DDM.mode;
 /** @type {boolean} */
Ext.dd.DDM.notifyOccluded;
 /** @type {boolean} */
Ext.dd.DDM.preventDefault;
 /** @type {!Ext.IClass} */
Ext.dd.DDM.self;
 /** @type {boolean} */
Ext.dd.DDM.stopPropagation;
 /** @type {boolean} */
Ext.dd.DDM.useCache;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.dd.DDM.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.dd.DDM.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.dd.DDM.callSuper = function(args) {};

/**
 * [Method] Helper function for getting the best match from the list of drag and drop objects returned by the drag and drop event
 * @param {!Array<!Ext.dd.IDragDrop>=} dds Ext.dd.DragDrop[] The array of drag and drop objects targeted
 * @return {!Ext.dd.IDragDrop} Ext.dd.DragDrop The best single match
 */
Ext.dd.DDM.getBestMatch = function(dds) {};

/**
 * [Method] Returns the style property for the DOM element i e  document getElById id style
 * @param {string=} id String the id of the elment to get
 * @return {?} Object The style property of the element
 */
Ext.dd.DDM.getCss = function(id) {};

/**
 * [Method] Returns the DragDrop instance for a given id
 * @param {string=} id String the id of the DragDrop object
 * @return {!Ext.dd.IDragDrop} Ext.dd.DragDrop the drag drop object, null if it is not found
 */
Ext.dd.DDM.getDDById = function(id) {};

/**
 * [Method] Returns the actual DOM element
 * @param {string=} id String the id of the elment to get
 * @return {?} Object The element
 */
Ext.dd.DDM.getElement = function(id) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.dd.DDM.getInitialConfig = function(name) {};

/**
 * [Method] Returns a Region object containing the drag and drop element s position and size including the padding configured fo
 * @param {!Ext.dd.IDragDrop=} oDD Ext.dd.DragDrop the drag and drop object to get the location for.
 * @return {!Ext.util.IRegion} Ext.util.Region a Region object representing the total area the element occupies, including any padding the instance is configured for.
 */
Ext.dd.DDM.getLocation = function(oDD) {};

/**
 * [Method] Returns the drag and drop instances that are in all groups the passed in instance belongs to
 * @param {!Ext.dd.IDragDrop=} p_oDD Ext.dd.DragDrop the obj to get related data for
 * @param {boolean=} bTargetsOnly Boolean if true, only return targetable objs
 * @return {!Array<!Ext.dd.IDragDrop>} Ext.dd.DragDrop[] the related instances
 */
Ext.dd.DDM.getRelated = function(p_oDD, bTargetsOnly) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.dd.DDM.initConfig = function(config) {};

/**
 * [Method] Utility function to determine if a given element has been registered as a drag drop item
 * @param {string=} id String the element id to check
 * @return {boolean} Boolean true if this element is a DragDrop item, false otherwise
 */
Ext.dd.DDM.isDragDrop = function(id) {};

/**
 * [Method] Utility function to determine if a given element has been registered as a drag drop handle for the given Drag Drop ob
 * @param {string=} id String the element id to check
 * @return {boolean} Boolean true if this element is a DragDrop handle, false otherwise
 */
Ext.dd.DDM.isHandle = function(id) {};

/**
 * [Method] Returns true if the specified dd target is a legal target for the specifice drag obj
 * @param {!Ext.dd.IDragDrop=} oDD Ext.dd.DragDrop the drag obj
 * @param {!Ext.dd.IDragDrop=} oTargetDD Ext.dd.DragDrop the target
 * @return {boolean} Boolean true if the target is a legal target for the dd obj
 */
Ext.dd.DDM.isLegalTarget = function(oDD, oTargetDD) {};

/**
 * [Method] Is drag and drop locked
 * @return {boolean} Boolean True if drag and drop is locked, false otherwise.
 */
Ext.dd.DDM.isLocked = function() {};

/**
 * [Method] My goal is to be able to transparently determine if an object is typeof DragDrop and the exact subclass of DragDrop
 * @param {?=} the Object object to evaluate
 * @return {boolean} Boolean true if typeof oDD = DragDrop
 */
Ext.dd.DDM.isTypeOfDD = function(the) {};

/**
 * [Method] Lock all drag and drop functionality
 * @return {void}
 */
Ext.dd.DDM.lock = function() {};

/**
 * [Method] Refreshes the cache of the top left and bottom right points of the drag and drop objects in the specified group s
 * @param {?=} groups Object an associative array of groups to refresh
 * @return {void}
 */
Ext.dd.DDM.refreshCache = function(groups) {};

/**
 * [Method] Each DragDrop instance must be registered with the DragDropManager
 * @param {!Ext.dd.IDragDrop=} oDD Ext.dd.DragDrop the DragDrop object to register
 * @param {string=} sGroup String the name of the group this element belongs to
 * @return {void}
 */
Ext.dd.DDM.regDragDrop = function(oDD, sGroup) {};

/**
 * [Method] Each DragDrop handle element must be registered
 * @param {string=} sDDId String the DragDrop id this element is a handle for
 * @param {string=} sHandleId String the id of the element that is the drag handle
 * @return {void}
 */
Ext.dd.DDM.regHandle = function(sDDId, sHandleId) {};

/**
 * [Method] Fired when either the drag pixel threshold or the mousedown hold time threshold has been met
 * @param {number=} x Number the X position of the original mousedown
 * @param {number=} y Number the Y position of the original mousedown
 * @return {void}
 */
Ext.dd.DDM.startDrag = function(x, y) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.dd.DDM.statics = function() {};

/**
 * [Method] Utility to stop event propagation and event default if these features are turned on
 * @param {!Event=} e Event the event as returned by this.getEvent()
 * @return {void}
 */
Ext.dd.DDM.stopEvent = function(e) {};

/**
 * [Method] Unlock all drag and drop functionality
 * @return {void}
 */
Ext.dd.DDM.unlock = function() {};

/**
 * [Method] This checks to make sure an element exists and is in the DOM
 * @param {!HTMLElement=} el HTMLElement the element to check
 * @return {boolean} Boolean true if the element looks usable
 */
Ext.dd.DDM.verifyEl = function(el) {};
/**
 * @extends {Ext.dd.IDDProxy}
 * @record
 * @struct
 */
Ext.dd.IDragSource = function() {};
 /** @type {boolean} */
Ext.dd.IDragSource.prototype.animRepair;
 /** @type {string} */
Ext.dd.IDragSource.prototype.ddGroup;
 /** @type {string} */
Ext.dd.IDragSource.prototype.dropAllowed;
 /** @type {string} */
Ext.dd.IDragSource.prototype.dropNotAllowed;
 /** @type {string} */
Ext.dd.IDragSource.prototype.repairHighlightColor;
 /** @type {?} */
Ext.dd.IDragSource.prototype.dragData;

/**
 * [Method] An empty function by default but provided so that you can perform a custom action after a valid drag drop has occurr
 * @param {!Ext.dd.IDragDrop=} target Ext.dd.DragDrop The drop target
 * @param {!Event=} e Event The event object
 * @param {string=} id String The id of the dropped element
 * @return {void}
 */
Ext.dd.IDragSource.prototype.afterDragDrop = function(target, e, id) {};

/**
 * [Method] An empty function by default but provided so that you can perform a custom action when the dragged item enters the d
 * @param {!Ext.dd.IDragDrop=} target Ext.dd.DragDrop The drop target
 * @param {!Event=} e Event The event object
 * @param {string=} id String The id of the dragged element
 * @return {void}
 */
Ext.dd.IDragSource.prototype.afterDragEnter = function(target, e, id) {};

/**
 * [Method] An empty function by default but provided so that you can perform a custom action after the dragged item is dragged
 * @param {!Ext.dd.IDragDrop=} target Ext.dd.DragDrop The drop target
 * @param {!Event=} e Event The event object
 * @param {string=} id String The id of the dragged element
 * @return {void}
 */
Ext.dd.IDragSource.prototype.afterDragOut = function(target, e, id) {};

/**
 * [Method] An empty function by default but provided so that you can perform a custom action while the dragged item is over the
 * @param {!Ext.dd.IDragDrop=} target Ext.dd.DragDrop The drop target
 * @param {!Event=} e Event The event object
 * @param {string=} id String The id of the dragged element
 * @return {void}
 */
Ext.dd.IDragSource.prototype.afterDragOver = function(target, e, id) {};

/**
 * [Method] An empty function by default but provided so that you can perform a custom action after an invalid drop has occurred
 * @param {!Event=} e Event The event object
 * @param {string=} id String The id of the dropped element
 * @return {void}
 */
Ext.dd.IDragSource.prototype.afterInvalidDrop = function(e, id) {};

/**
 * [Method] An empty function by default but provided so that you can perform a custom action after a valid drop has occurred by
 * @param {?=} target Object The target DD
 * @param {!Event=} e Event The event object
 * @param {string=} id String The id of the dropped element
 * @return {void}
 */
Ext.dd.IDragSource.prototype.afterValidDrop = function(target, e, id) {};

/**
 * [Method] Sets the element to the location of the mousedown or click event maintaining the cursor location relative to the loc
 * @return {void}
 */
Ext.dd.IDragSource.prototype.alignElWithMouse = function() {};

/**
 * [Method] An empty function by default but provided so that you can perform a custom action before the dragged item is dropped
 * @param {!Ext.dd.IDragDrop=} target Ext.dd.DragDrop The drop target
 * @param {!Event=} e Event The event object
 * @param {string=} id String The id of the dragged element
 * @return {boolean} Boolean isValid True if the drag drop event is valid, else false to cancel
 */
Ext.dd.IDragSource.prototype.beforeDragDrop = function(target, e, id) {};

/**
 * [Method] An empty function by default but provided so that you can perform a custom action before the dragged item enters the
 * @param {!Ext.dd.IDragDrop=} target Ext.dd.DragDrop The drop target
 * @param {!Event=} e Event The event object
 * @param {string=} id String The id of the dragged element
 * @return {boolean} Boolean isValid True if the drag event is valid, else false to cancel
 */
Ext.dd.IDragSource.prototype.beforeDragEnter = function(target, e, id) {};

/**
 * [Method] An empty function by default but provided so that you can perform a custom action before the dragged item is dragged
 * @param {!Ext.dd.IDragDrop=} target Ext.dd.DragDrop The drop target
 * @param {!Event=} e Event The event object
 * @param {string=} id String The id of the dragged element
 * @return {boolean} Boolean isValid True if the drag event is valid, else false to cancel
 */
Ext.dd.IDragSource.prototype.beforeDragOut = function(target, e, id) {};

/**
 * [Method] An empty function by default but provided so that you can perform a custom action while the dragged item is over the
 * @param {!Ext.dd.IDragDrop=} target Ext.dd.DragDrop The drop target
 * @param {!Event=} e Event The event object
 * @param {string=} id String The id of the dragged element
 * @return {boolean} Boolean isValid True if the drag event is valid, else false to cancel
 */
Ext.dd.IDragSource.prototype.beforeDragOver = function(target, e, id) {};

/**
 * [Method] An empty function by default but provided so that you can perform a custom action after an invalid drop has occurred
 * @param {!Ext.dd.IDragDrop=} target Ext.dd.DragDrop The drop target
 * @param {!Event=} e Event The event object
 * @param {string=} id String The id of the dragged element
 * @return {boolean} Boolean isValid True if the invalid drop should proceed, else false to cancel
 */
Ext.dd.IDragSource.prototype.beforeInvalidDrop = function(target, e, id) {};

/**
 * [Method] Destroy this DragDrop instance
 * @return {void}
 */
Ext.dd.IDragSource.prototype.destroy = function() {};

/**
 * [Method] Returns the data object associated with this drag source
 * @param {?=} e Object
 * @return {?} Object data An object containing arbitrary data
 */
Ext.dd.IDragSource.prototype.getDragData = function(e) {};

/**
 * [Method] Returns the drag source s underlying Ext dd StatusProxy
 * @return {!Ext.dd.IStatusProxy} Ext.dd.StatusProxy proxy The StatusProxy
 */
Ext.dd.IDragSource.prototype.getProxy = function() {};

/**
 * [Method] Hides the drag source s Ext dd StatusProxy
 * @return {void}
 */
Ext.dd.IDragSource.prototype.hideProxy = function() {};

/**
 * [Method] An empty function by default but provided so that you can perform a custom action before the initial drag event begi
 * @param {?=} data Object An object containing arbitrary data to be shared with drop targets
 * @param {!Event=} e Event The event object
 * @return {boolean} Boolean isValid True if the drag event is valid, else false to cancel
 */
Ext.dd.IDragSource.prototype.onBeforeDrag = function(data, e) {};

/**
 * [Method] An empty function by default but provided so that you can perform a custom action once the initial drag event has be
 * @param {number=} x Number The x position of the click on the dragged object
 * @param {number=} y Number The y position of the click on the dragged object
 * @return {void}
 */
Ext.dd.IDragSource.prototype.onStartDrag = function(x, y) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.dd.IDragTracker = function() {};
 /** @type {?} */
Ext.dd.IDragTracker.prototype.autoStart;
 /** @type {?} */
Ext.dd.IDragTracker.prototype.constrainTo;
 /** @type {string} */
Ext.dd.IDragTracker.prototype.delegate;
 /** @type {string} */
Ext.dd.IDragTracker.prototype.overCls;
 /** @type {boolean} */
Ext.dd.IDragTracker.prototype.preventDefault;
 /** @type {boolean} */
Ext.dd.IDragTracker.prototype.stopEvent;
 /** @type {number} */
Ext.dd.IDragTracker.prototype.tolerance;
 /** @type {boolean} */
Ext.dd.IDragTracker.prototype.trackOver;
 /** @type {boolean} */
Ext.dd.IDragTracker.prototype.active;
 /** @type {!HTMLElement} */
Ext.dd.IDragTracker.prototype.dragTarget;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.dd.IDragTracker.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.dd.IDragTracker.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.dd.IDragTracker.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.dd.IDragTracker.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the drag target
 * @return {!Ext.IElement} Ext.Element The element currently being tracked.
 */
Ext.dd.IDragTracker.prototype.getDragTarget = function() {};

/**
 * [Method] Returns the X Y offset of the current mouse position from the mousedown point
 * @param {string=} constrainMode String If omitted the true mouse position is returned. May be passed as point or dragTarget. See above.
 * @return {!Array<number>} Number[] The X, Y offset from the mousedown point, optionally constrained.
 */
Ext.dd.IDragTracker.prototype.getOffset = function(constrainMode) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.dd.IDragTracker.prototype.hasListener = function(eventName) {};

/**
 * [Method] Initializes the DragTracker on a given element
 * @param {?=} el Ext.Element/HTMLElement The element
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.initEl = function(el) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.dd.IDragTracker.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.dd.IDragTracker.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Template method which should be overridden by each DragTracker instance
 * @param {!Ext.IEventObject=} e Ext.EventObject The event object
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.onBeforeStart = function(e) {};

/**
 * [Method] Template method which should be overridden by each DragTracker instance
 * @param {!Ext.IEventObject=} e Ext.EventObject The event object
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.onDrag = function(e) {};

/**
 * [Method] Template method which should be overridden by each DragTracker instance
 * @param {!Ext.IEventObject=} e Ext.EventObject The event object
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.onEnd = function(e) {};

/**
 * [Method] Template method which should be overridden by each DragTracker instance
 * @param {!Ext.IEventObject=} e Ext.EventObject The event object
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.onStart = function(e) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.dd.IDragTracker.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.resumeEvents = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.dd.IDragTracker.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.dd.IDragSource}
 * @record
 * @struct
 */
Ext.dd.IDragZone = function() {};
 /** @type {?} */
Ext.dd.IDragZone.prototype.containerScroll;
 /** @type {?} */
Ext.dd.IDragZone.prototype.scrollEl;

/**
 * [Method] Destroy this DragDrop instance
 * @return {void}
 */
Ext.dd.IDragZone.prototype.destroy = function() {};

/**
 * [Method] Called when a mousedown occurs in this container
 * @param {!Event=} e Event The mouse down event
 * @return {?} Object The dragData
 */
Ext.dd.IDragZone.prototype.getDragData = function(e) {};

/**
 * [Method] Called before a repair of an invalid drop to get the XY to animate to
 * @param {!Event=} e Event The mouse up event
 * @return {!Array<number>} Number[] The xy location (e.g. [100, 200])
 */
Ext.dd.IDragZone.prototype.getRepairXY = function(e) {};

/**
 * [Method] Called once drag threshold has been reached to initialize the proxy element
 * @param {number=} x Number The x position of the click on the dragged object
 * @param {number=} y Number The y position of the click on the dragged object
 * @return {boolean} Boolean true to continue the drag, false to cancel
 */
Ext.dd.IDragZone.prototype.onInitDrag = function(x, y) {};
/**
 * @extends {Ext.dd.IDDTarget}
 * @record
 * @struct
 */
Ext.dd.IDropTarget = function() {};
 /** @type {string} */
Ext.dd.IDropTarget.prototype.ddGroup;
 /** @type {string} */
Ext.dd.IDropTarget.prototype.dropAllowed;
 /** @type {string} */
Ext.dd.IDropTarget.prototype.dropNotAllowed;
 /** @type {string} */
Ext.dd.IDropTarget.prototype.overClass;
 /** @type {boolean} */
Ext.dd.IDropTarget.prototype.isTarget;

/**
 * [Method] Destroy this DragDrop instance
 * @return {void}
 */
Ext.dd.IDropTarget.prototype.destroy = function() {};

/**
 * [Method] The function a Ext dd DragSource calls once to notify this drop target that the dragged item has been dropped on it
 * @param {!Ext.dd.IDragSource=} source Ext.dd.DragSource The drag source that was dragged over this drop target
 * @param {!Event=} e Event The event
 * @param {?=} data Object An object containing arbitrary data supplied by the drag source
 * @return {boolean} Boolean False if the drop was invalid.
 */
Ext.dd.IDropTarget.prototype.notifyDrop = function(source, e, data) {};

/**
 * [Method] The function a Ext dd DragSource calls once to notify this drop target that the source is now over the target
 * @param {!Ext.dd.IDragSource=} source Ext.dd.DragSource The drag source that was dragged over this drop target
 * @param {!Event=} e Event The event
 * @param {?=} data Object An object containing arbitrary data supplied by the drag source
 * @return {string} String status The CSS class that communicates the drop status back to the source so that the underlying Ext.dd.StatusProxy can be updated
 */
Ext.dd.IDropTarget.prototype.notifyEnter = function(source, e, data) {};

/**
 * [Method] The function a Ext dd DragSource calls once to notify this drop target that the source has been dragged out of the ta
 * @param {!Ext.dd.IDragSource=} source Ext.dd.DragSource The drag source that was dragged over this drop target
 * @param {!Event=} e Event The event
 * @param {?=} data Object An object containing arbitrary data supplied by the drag source
 * @return {void}
 */
Ext.dd.IDropTarget.prototype.notifyOut = function(source, e, data) {};

/**
 * [Method] The function a Ext dd DragSource calls continuously while it is being dragged over the target
 * @param {!Ext.dd.IDragSource=} source Ext.dd.DragSource The drag source that was dragged over this drop target
 * @param {!Event=} e Event The event
 * @param {?=} data Object An object containing arbitrary data supplied by the drag source
 * @return {string} String status The CSS class that communicates the drop status back to the source so that the underlying Ext.dd.StatusProxy can be updated
 */
Ext.dd.IDropTarget.prototype.notifyOver = function(source, e, data) {};
/**
 * @extends {Ext.dd.IDropTarget}
 * @record
 * @struct
 */
Ext.dd.IDropZone = function() {};

/**
 * [Method] Returns a custom data object associated with the DOM node that is the target of the event
 * @param {!Event=} e Event The event
 * @return {?} Object data The custom data
 */
Ext.dd.IDropZone.prototype.getTargetFromEvent = function(e) {};

/**
 * [Method] The function a Ext dd DragSource calls once to notify this drop zone that the dragged item has been dropped on it
 * @param {!Ext.dd.IDragSource=} source Ext.dd.DragSource The drag source that was dragged over this drop zone
 * @param {!Event=} e Event The event
 * @param {?=} data Object An object containing arbitrary data supplied by the drag source
 * @return {boolean} Boolean False if the drop was invalid.
 */
Ext.dd.IDropZone.prototype.notifyDrop = function(source, e, data) {};

/**
 * [Method] The function a Ext dd DragSource calls once to notify this drop zone that the source is now over the zone
 * @param {!Ext.dd.IDragSource=} source Ext.dd.DragSource The drag source that was dragged over this drop zone
 * @param {!Event=} e Event The event
 * @param {?=} data Object An object containing arbitrary data supplied by the drag source
 * @return {string} String status The CSS class that communicates the drop status back to the source so that the underlying Ext.dd.StatusProxy can be updated
 */
Ext.dd.IDropZone.prototype.notifyEnter = function(source, e, data) {};

/**
 * [Method] The function a Ext dd DragSource calls once to notify this drop zone that the source has been dragged out of the zone
 * @param {!Ext.dd.IDragSource=} source Ext.dd.DragSource The drag source that was dragged over this drop target
 * @param {!Event=} e Event The event
 * @param {?=} data Object An object containing arbitrary data supplied by the drag zone
 * @return {void}
 */
Ext.dd.IDropZone.prototype.notifyOut = function(source, e, data) {};

/**
 * [Method] The function a Ext dd DragSource calls continuously while it is being dragged over the drop zone
 * @param {!Ext.dd.IDragSource=} source Ext.dd.DragSource The drag source that was dragged over this drop zone
 * @param {!Event=} e Event The event
 * @param {?=} data Object An object containing arbitrary data supplied by the drag source
 * @return {string} String status The CSS class that communicates the drop status back to the source so that the underlying Ext.dd.StatusProxy can be updated
 */
Ext.dd.IDropZone.prototype.notifyOver = function(source, e, data) {};

/**
 * [Method] Called when the DropZone determines that a Ext dd DragSource has been dropped on it but not on any of its registered
 * @param {!Ext.dd.IDragSource=} source Ext.dd.DragSource The drag source that was dragged over this drop zone
 * @param {!Event=} e Event The event
 * @param {?=} data Object An object containing arbitrary data supplied by the drag source
 * @return {boolean} Boolean True if the drop was valid, else false
 */
Ext.dd.IDropZone.prototype.onContainerDrop = function(source, e, data) {};

/**
 * [Method] Called while the DropZone determines that a Ext dd DragSource is being dragged over it but not over any of its regis
 * @param {!Ext.dd.IDragSource=} source Ext.dd.DragSource The drag source that was dragged over this drop zone
 * @param {!Event=} e Event The event
 * @param {?=} data Object An object containing arbitrary data supplied by the drag source
 * @return {string} String status The CSS class that communicates the drop status back to the source so that the underlying Ext.dd.StatusProxy can be updated
 */
Ext.dd.IDropZone.prototype.onContainerOver = function(source, e, data) {};

/**
 * [Method] Called when the DropZone determines that a Ext dd DragSource has been dropped onto the drop node
 * @param {?=} nodeData Object The custom data associated with the drop node (this is the same value returned from getTargetFromEvent for this node)
 * @param {!Ext.dd.IDragSource=} source Ext.dd.DragSource The drag source that was dragged over this drop zone
 * @param {!Event=} e Event The event
 * @param {?=} data Object An object containing arbitrary data supplied by the drag source
 * @return {boolean} Boolean True if the drop was valid, else false
 */
Ext.dd.IDropZone.prototype.onNodeDrop = function(nodeData, source, e, data) {};

/**
 * [Method] Called when the DropZone determines that a Ext dd DragSource has entered a drop node that has either been registered
 * @param {?=} nodeData Object The custom data associated with the drop node (this is the same value returned from getTargetFromEvent for this node)
 * @param {!Ext.dd.IDragSource=} source Ext.dd.DragSource The drag source that was dragged over this drop zone
 * @param {!Event=} e Event The event
 * @param {?=} data Object An object containing arbitrary data supplied by the drag source
 * @return {void}
 */
Ext.dd.IDropZone.prototype.onNodeEnter = function(nodeData, source, e, data) {};

/**
 * [Method] Called when the DropZone determines that a Ext dd DragSource has been dragged out of the drop node without dropping
 * @param {?=} nodeData Object The custom data associated with the drop node (this is the same value returned from getTargetFromEvent for this node)
 * @param {!Ext.dd.IDragSource=} source Ext.dd.DragSource The drag source that was dragged over this drop zone
 * @param {!Event=} e Event The event
 * @param {?=} data Object An object containing arbitrary data supplied by the drag source
 * @return {void}
 */
Ext.dd.IDropZone.prototype.onNodeOut = function(nodeData, source, e, data) {};

/**
 * [Method] Called while the DropZone determines that a Ext dd DragSource is over a drop node that has either been registered or
 * @param {?=} nodeData Object The custom data associated with the drop node (this is the same value returned from getTargetFromEvent for this node)
 * @param {!Ext.dd.IDragSource=} source Ext.dd.DragSource The drag source that was dragged over this drop zone
 * @param {!Event=} e Event The event
 * @param {?=} data Object An object containing arbitrary data supplied by the drag source
 * @return {string} String status The CSS class that communicates the drop status back to the source so that the underlying Ext.dd.StatusProxy can be updated
 */
Ext.dd.IDropZone.prototype.onNodeOver = function(nodeData, source, e, data) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.dd.IRegistry = function() {};
/**
 * @constructor
 * @struct
 */
Ext.dd.Registry = function() {};
 /** @type {!Ext.IClass} */
Ext.dd.Registry.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.dd.Registry.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.dd.Registry.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.dd.Registry.callSuper = function(args) {};

/**
 * [Method] Returns the handle registered for a DOM Node by id
 * @param {?=} id String/HTMLElement The DOM node or id to look up
 * @return {?} Object handle The custom handle data
 */
Ext.dd.Registry.getHandle = function(id) {};

/**
 * [Method] Returns the handle that is registered for the DOM node that is the target of the event
 * @param {!Event=} e Event The event
 * @return {?} Object handle The custom handle data
 */
Ext.dd.Registry.getHandleFromEvent = function(e) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.dd.Registry.getInitialConfig = function(name) {};

/**
 * [Method] Returns a custom data object that is registered for a DOM node by id
 * @param {?=} id String/HTMLElement The DOM node or id to look up
 * @return {?} Object data The custom data
 */
Ext.dd.Registry.getTarget = function(id) {};

/**
 * [Method] Returns a custom data object that is registered for the DOM node that is the target of the event
 * @param {!Event=} e Event The event
 * @return {?} Object data The custom data
 */
Ext.dd.Registry.getTargetFromEvent = function(e) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.dd.Registry.initConfig = function(config) {};

/**
 * [Method] Registers a drag drop element
 * @param {?=} element String/HTMLElement The id or DOM node to register
 * @param {?=} data Object An custom data object that will be passed between the elements that are involved in drag drop operations. You can populate this object with any arbitrary properties that your own code knows how to interpret, plus there are some specific properties known to the Registry that should be populated in the data object (if applicable):
 * @return {void}
 */
Ext.dd.Registry.register = function(element, data) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.dd.Registry.statics = function() {};

/**
 * [Method] Unregister a drag drop element
 * @param {?=} element String/HTMLElement The id or DOM node to unregister
 * @return {void}
 */
Ext.dd.Registry.unregister = function(element) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.dd.IScrollManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.dd.ScrollManager = function() {};
 /** @type {number} */
Ext.dd.ScrollManager.animDuration;
 /** @type {boolean} */
Ext.dd.ScrollManager.animate;
 /** @type {string} */
Ext.dd.ScrollManager.ddGroup;
 /** @type {number} */
Ext.dd.ScrollManager.frequency;
 /** @type {number} */
Ext.dd.ScrollManager.hthresh;
 /** @type {number} */
Ext.dd.ScrollManager.increment;
 /** @type {!Ext.IClass} */
Ext.dd.ScrollManager.self;
 /** @type {number} */
Ext.dd.ScrollManager.vthresh;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.dd.ScrollManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.dd.ScrollManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.dd.ScrollManager.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.dd.ScrollManager.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.dd.ScrollManager.initConfig = function(config) {};

/**
 * [Method] Manually trigger a cache refresh
 * @return {void}
 */
Ext.dd.ScrollManager.refreshCache = function() {};

/**
 * [Method] Registers new overflow element s to auto scroll
 * @param {?=} el String/HTMLElement/Ext.Element/String[]/HTMLElement[]/Ext.Element[] The id of or the element to be scrolled or an array of either
 * @return {void}
 */
Ext.dd.ScrollManager.register = function(el) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.dd.ScrollManager.statics = function() {};

/**
 * [Method] Unregisters overflow element s so they are no longer scrolled
 * @param {?=} el String/HTMLElement/Ext.Element/String[]/HTMLElement[]/Ext.Element[] The id of or the element to be removed or an array of either
 * @return {void}
 */
Ext.dd.ScrollManager.unregister = function(el) {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.dd.IStatusProxy = function() {};
 /** @type {string} */
Ext.dd.IStatusProxy.prototype.dropAllowed;
 /** @type {string} */
Ext.dd.IStatusProxy.prototype.dropNotAllowed;
 /** @type {?} */
Ext.dd.IStatusProxy.prototype.renderTpl;

/**
 * [Method] Returns the ghost element
 * @return {!Ext.IElement} Ext.Element el
 */
Ext.dd.IStatusProxy.prototype.getGhost = function() {};

/**
 * [Method] Causes the proxy to return to its position of origin via an animation
 * @param {!Array<number>=} xy Number[] The XY position of the element ([x, y])
 * @param {?=} callback Function The function to call after the repair is complete.
 * @param {?=} scope Object The scope (this reference) in which the callback function is executed. Defaults to the browser window.
 * @return {void}
 */
Ext.dd.IStatusProxy.prototype.repair = function(xy, callback, scope) {};

/**
 * [Method] Resets the status indicator to the default dropNotAllowed value
 * @param {boolean=} clearGhost Boolean True to also remove all content from the ghost, false to preserve it
 * @return {void}
 */
Ext.dd.IStatusProxy.prototype.reset = function(clearGhost) {};

/**
 * [Method] Updates the proxy s visual element to indicate the status of whether or not drop is allowed over the current target e
 * @param {string=} cssClass String The css class for the new drop status indicator image
 * @return {void}
 */
Ext.dd.IStatusProxy.prototype.setStatus = function(cssClass) {};

/**
 * [Method] Stops the repair animation if it s currently running
 * @return {void}
 */
Ext.dd.IStatusProxy.prototype.stop = function() {};

/**
 * [Method] Force the Layer to sync its shadow and shim positions to the element
 * @return {void}
 */
Ext.dd.IStatusProxy.prototype.sync = function() {};

/**
 * [Method] Updates the contents of the ghost element
 * @param {?=} html String/HTMLElement The html that will replace the current innerHTML of the ghost element, or a DOM node to append as the child of the ghost element (in which case the innerHTML will be cleared first).
 * @return {void}
 */
Ext.dd.IStatusProxy.prototype.update = function(html) {};
/** @const */
Ext.direct = {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.direct.IEvent = function() {};

/**
 * [Method] Return the raw data for this event
 * @return {?} Mixed The data from the event
 */
Ext.direct.IEvent.prototype.getData = function() {};

/**
 * [Method] Return the name for this event
 * @return {string} String The name of event
 */
Ext.direct.IEvent.prototype.getName = function() {};
/**
 * @extends {Ext.direct.IRemotingEvent}
 * @record
 * @struct
 */
Ext.direct.IExceptionEvent = function() {};
/**
 * @extends {Ext.direct.IProvider}
 * @record
 * @struct
 */
Ext.direct.IJsonProvider = function() {};

/**
 * [Method] Create an event from a response object
 * @param {?=} response Object Response object
 * @return {!Ext.direct.IEvent} Ext.direct.Event The event
 */
Ext.direct.IJsonProvider.prototype.createEvent = function(response) {};

/**
 * [Method] Creates a set of events based on the XHR response
 * @param {?=} response Object The XHR response
 * @return {!Array<!Ext.direct.IEvent>} Ext.direct.Event[] An array of Ext.direct.Event
 */
Ext.direct.IJsonProvider.prototype.createEvents = function(response) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.direct.IManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.direct.Manager = function() {};
 /** @type {?} */
Ext.direct.Manager.exceptions;
 /** @type {?} */
Ext.direct.Manager.hasListeners;
 /** @type {boolean} */
Ext.direct.Manager.isObservable;
 /** @type {!Ext.IClass} */
Ext.direct.Manager.self;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.direct.Manager.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.direct.Manager.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.direct.Manager.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Adds an Ext Direct Provider and creates the proxy or stub methods to execute server side methods
 * @param {?=} provider Ext.direct.Provider/Object... Accepts any number of Provider descriptions (an instance or config object for a Provider). Each Provider description instructs Ext.Direct how to create client-side stub methods.
 * @return {void}
 */
Ext.direct.Manager.addProvider = function(provider) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.direct.Manager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.direct.Manager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.direct.Manager.callSuper = function(args) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.direct.Manager.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.direct.Manager.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.direct.Manager.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.direct.Manager.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.direct.Manager.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.direct.Manager.getInitialConfig = function(name) {};

/**
 * [Method] Retrieves a provider by the id specified when the provider is added
 * @param {?=} id String/Ext.direct.Provider The id of the provider, or the provider instance.
 * @return {void}
 */
Ext.direct.Manager.getProvider = function(id) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.direct.Manager.hasListener = function(eventName) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.direct.Manager.initConfig = function(config) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.direct.Manager.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.direct.Manager.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.direct.Manager.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Parses a direct function
 * @param {?=} fn String/Function The direct function
 * @return {?} Function The function to use in the direct call. Null if not found
 */
Ext.direct.Manager.parseMethod = function(fn) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.direct.Manager.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.direct.Manager.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.direct.Manager.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Removes the provider
 * @param {?=} provider String/Ext.direct.Provider The provider instance or the id of the provider.
 * @return {!Ext.direct.IProvider} Ext.direct.Provider The provider, null if not found.
 */
Ext.direct.Manager.removeProvider = function(provider) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.direct.Manager.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.direct.Manager.resumeEvents = function() {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.direct.Manager.statics = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.direct.Manager.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.direct.Manager.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.direct.Manager.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.IDirect = function() {};
/**
 * @constructor
 * @struct
 */
Ext.Direct = function() {};
 /** @type {?} */
Ext.Direct.exceptions;
 /** @type {?} */
Ext.Direct.hasListeners;
 /** @type {boolean} */
Ext.Direct.isObservable;
 /** @type {!Ext.IClass} */
Ext.Direct.self;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.Direct.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.Direct.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.Direct.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Adds an Ext Direct Provider and creates the proxy or stub methods to execute server side methods
 * @param {?=} provider Ext.direct.Provider/Object... Accepts any number of Provider descriptions (an instance or config object for a Provider). Each Provider description instructs Ext.Direct how to create client-side stub methods.
 * @return {void}
 */
Ext.Direct.addProvider = function(provider) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.Direct.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.Direct.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.Direct.callSuper = function(args) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.Direct.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.Direct.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.Direct.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.Direct.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.Direct.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.Direct.getInitialConfig = function(name) {};

/**
 * [Method] Retrieves a provider by the id specified when the provider is added
 * @param {?=} id String/Ext.direct.Provider The id of the provider, or the provider instance.
 * @return {void}
 */
Ext.Direct.getProvider = function(id) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.Direct.hasListener = function(eventName) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.Direct.initConfig = function(config) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.Direct.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.Direct.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.Direct.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Parses a direct function
 * @param {?=} fn String/Function The direct function
 * @return {?} Function The function to use in the direct call. Null if not found
 */
Ext.Direct.parseMethod = function(fn) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.Direct.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.Direct.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.Direct.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Removes the provider
 * @param {?=} provider String/Ext.direct.Provider The provider instance or the id of the provider.
 * @return {!Ext.direct.IProvider} Ext.direct.Provider The provider, null if not found.
 */
Ext.Direct.removeProvider = function(provider) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.Direct.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.Direct.resumeEvents = function() {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.Direct.statics = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.Direct.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.Direct.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.Direct.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.direct.IJsonProvider}
 * @record
 * @struct
 */
Ext.direct.IPollingProvider = function() {};
 /** @type {?} */
Ext.direct.IPollingProvider.prototype.baseParams;
 /** @type {number} */
Ext.direct.IPollingProvider.prototype.interval;
 /** @type {?} */
Ext.direct.IPollingProvider.prototype.url;

/**
 * [Method] Connect to the server side and begin the polling process
 * @return {void}
 */
Ext.direct.IPollingProvider.prototype.connect = function() {};

/**
 * [Method] Disconnect from the server side and stop the polling process
 * @return {void}
 */
Ext.direct.IPollingProvider.prototype.disconnect = function() {};

/**
 * [Method] Returns whether or not the server side is currently connected
 * @return {void}
 */
Ext.direct.IPollingProvider.prototype.isConnected = function() {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.direct.IProvider = function() {};
 /** @type {string} */
Ext.direct.IProvider.prototype.id;
 /** @type {!Array<string>} */
Ext.direct.IProvider.prototype.relayedEvents;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.direct.IProvider.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.direct.IProvider.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.direct.IProvider.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.direct.IProvider.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.direct.IProvider.prototype.clearManagedListeners = function() {};

/**
 * [Method] Abstract method for subclasses to implement
 * @return {void}
 */
Ext.direct.IProvider.prototype.connect = function() {};

/**
 * [Method] Abstract method for subclasses to implement
 * @return {void}
 */
Ext.direct.IProvider.prototype.disconnect = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.direct.IProvider.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.direct.IProvider.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.direct.IProvider.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.direct.IProvider.prototype.hasListener = function(eventName) {};

/**
 * [Method] Returns whether or not the server side is currently connected
 * @return {void}
 */
Ext.direct.IProvider.prototype.isConnected = function() {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.direct.IProvider.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.direct.IProvider.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.direct.IProvider.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.direct.IProvider.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.direct.IProvider.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.direct.IProvider.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.direct.IProvider.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.direct.IProvider.prototype.resumeEvents = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.direct.IProvider.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.direct.IProvider.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.direct.IProvider.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.direct.IEvent}
 * @record
 * @struct
 */
Ext.direct.IRemotingEvent = function() {};

/**
 * [Method] Get the transaction associated with this event
 * @return {!Ext.direct.ITransaction} Ext.direct.Transaction The transaction
 */
Ext.direct.IRemotingEvent.prototype.getTransaction = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.direct.IRemotingMethod = function() {};

/**
 * [Method] Takes the arguments for the Direct function and splits the arguments from the scope and the callback
 * @param {!Array<?>=} args Array The arguments passed to the direct call
 * @return {?} Object An object with 3 properties: args, callback &amp; scope.
 */
Ext.direct.IRemotingMethod.prototype.getCallData = function(args) {};
/**
 * @extends {Ext.direct.IJsonProvider}
 * @record
 * @struct
 */
Ext.direct.IRemotingProvider = function() {};
 /** @type {?} */
Ext.direct.IRemotingProvider.prototype.actions;
 /** @type {boolean} */
Ext.direct.IRemotingProvider.prototype.disableNestedActions;
 /** @type {?} */
Ext.direct.IRemotingProvider.prototype.enableBuffer;
 /** @type {string} */
Ext.direct.IRemotingProvider.prototype.enableUrlEncode;
 /** @type {number} */
Ext.direct.IRemotingProvider.prototype.maxRetries;
 /** @type {?} */
Ext.direct.IRemotingProvider.prototype.namespace;
 /** @type {number} */
Ext.direct.IRemotingProvider.prototype.timeout;
 /** @type {string} */
Ext.direct.IRemotingProvider.prototype.url;

/**
 * [Method] Abstract method for subclasses to implement
 * @return {void}
 */
Ext.direct.IRemotingProvider.prototype.connect = function() {};

/**
 * [Method] Abstract method for subclasses to implement
 * @return {void}
 */
Ext.direct.IRemotingProvider.prototype.disconnect = function() {};

/**
 * [Method] Returns whether or not the server side is currently connected
 * @return {void}
 */
Ext.direct.IRemotingProvider.prototype.isConnected = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.direct.ITransaction = function() {};
 /** @type {!Ext.direct.IProvider} */
Ext.direct.ITransaction.prototype.provider;
/** @const */
Ext.dom = {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.dom.IAbstractElement = function() {};
 /** @type {string} */
Ext.dom.IAbstractElement.prototype.defaultUnit;
 /** @type {!HTMLElement} */
Ext.dom.IAbstractElement.prototype.dom;
 /** @type {string} */
Ext.dom.IAbstractElement.prototype.id;
 /** @type {number} */
Ext.dom.IAbstractElement.prototype.ASCLASS;
 /** @type {number} */
Ext.dom.IAbstractElement.prototype.DISPLAY;
 /** @type {number} */
Ext.dom.IAbstractElement.prototype.OFFSETS;
 /** @type {number} */
Ext.dom.IAbstractElement.prototype.VISIBILITY;

/**
 * [Method] Adds one or more CSS classes to the element
 * @param {?=} className String/String[] The CSS classes to add separated by space, or an array of classes
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.addCls = function(className) {};

/**
 * [Method] Appends the passed element s to this element Defined in override Ext dom AbstractElement_insertion
 * @param {?=} el String/HTMLElement/Ext.dom.AbstractElement/Object The id or element to insert or a DomHelper config The id of the node, a DOM Node or an existing Element.
 * @param {boolean=} returnDom Boolean True to return the raw DOM element instead of Ext.dom.AbstractElement
 * @return {!Ext.dom.IAbstractElement} Ext.dom.AbstractElement The inserted Element.
 */
Ext.dom.IAbstractElement.prototype.appendChild = function(el, returnDom) {};

/**
 * [Method] Appends this element to the passed element Defined in override Ext dom AbstractElement_insertion
 * @param {?=} el String/HTMLElement/Ext.dom.AbstractElement The new parent element. The id of the node, a DOM Node or an existing Element.
 * @return {!Ext.dom.IAbstractElement} Ext.dom.AbstractElement This element
 */
Ext.dom.IAbstractElement.prototype.appendTo = function(el) {};

/**
 * [Method] More flexible version of setStyle for setting style properties
 * @param {?=} styles String/Object/Function A style specification string, e.g. "width:100px", or object in the form {width:"100px"}, or a function which returns such a specification.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.applyStyles = function(styles) {};

/**
 * [Method] Selects a single direct child based on the passed CSS selector the selector should not contain an id
 * @param {string=} selector String The CSS selector
 * @param {boolean=} returnDom Boolean True to return the DOM node instead of Ext.dom.Element.
 * @return {?} HTMLElement/Ext.dom.Element The child Ext.dom.Element (or DOM node if returnDom = true)
 */
Ext.dom.IAbstractElement.prototype.child = function(selector, returnDom) {};

/**
 * [Method] Returns true if this element is an ancestor of the passed element
 * @param {?=} el HTMLElement/String The element to check
 * @return {boolean} Boolean True if this element is an ancestor of el, else false
 */
Ext.dom.IAbstractElement.prototype.contains = function(el) {};

/**
 * [Method] Creates the passed DomHelper config and appends it to this element or optionally inserts it before the passed child e
 * @param {?=} config Object DomHelper element config object. If no tag is specified (e.g., {tag:'input'}) then a div will be automatically generated with the specified attributes.
 * @param {!HTMLElement=} insertBefore HTMLElement a child element of this element
 * @param {boolean=} returnDom Boolean true to return the dom node instead of creating an Element
 * @return {!Ext.dom.IAbstractElement} Ext.dom.AbstractElement The new child element
 */
Ext.dom.IAbstractElement.prototype.createChild = function(config, insertBefore, returnDom) {};

/**
 * [Method] Alias to remove
 * @return {void}
 */
Ext.dom.IAbstractElement.prototype.destroy = function() {};

/**
 * [Method] Selects a single child at any depth below this element based on the passed CSS selector the selector should not cont
 * @param {string=} selector String The CSS selector
 * @param {boolean=} returnDom Boolean True to return the DOM node instead of Ext.dom.Element
 * @return {?} HTMLElement/Ext.dom.Element The child Ext.dom.Element (or DOM node if returnDom = true)
 */
Ext.dom.IAbstractElement.prototype.down = function(selector, returnDom) {};

/**
 * [Method] Looks at this node and then at parent nodes for a match of the passed simple selector e g
 * @param {string=} selector String The simple selector to test
 * @param {?=} limit Number/String/HTMLElement/Ext.Element The max depth to search as a number or an element which causes the upward traversal to stop and is not considered for inclusion as the result. (defaults to 50 || document.documentElement)
 * @param {boolean=} returnEl Boolean True to return a Ext.Element object instead of DOM node
 * @return {!HTMLElement} HTMLElement The matching DOM node (or null if no match was found)
 */
Ext.dom.IAbstractElement.prototype.findParent = function(selector, limit, returnEl) {};

/**
 * [Method] Looks at parent nodes for a match of the passed simple selector e g
 * @param {string=} selector String The simple selector to test
 * @param {?=} limit Number/String/HTMLElement/Ext.Element The max depth to search as a number or an element which causes the upward traversal to stop and is not considered for inclusion as the result. (defaults to 50 || document.documentElement)
 * @param {boolean=} returnEl Boolean True to return a Ext.Element object instead of DOM node
 * @return {!HTMLElement} HTMLElement The matching DOM node (or null if no match was found)
 */
Ext.dom.IAbstractElement.prototype.findParentNode = function(selector, limit, returnEl) {};

/**
 * [Method] Gets the first child skipping text nodes Defined in override Ext dom AbstractElement_traversal
 * @param {string=} selector String Find the next sibling that matches the passed simple selector
 * @param {boolean=} returnDom Boolean True to return a raw dom node instead of an Ext.dom.Element
 * @return {?} Ext.dom.Element/HTMLElement The first child or null
 */
Ext.dom.IAbstractElement.prototype.first = function(selector, returnDom) {};

/**
 * [Method] Returns the active element in the DOM
 * @return {!HTMLElement} HTMLElement The active (focused) element in the document.
 */
Ext.dom.IAbstractElement.prototype.getActiveElement = function() {};

/**
 * [Method] Returns the value of an attribute from the element s underlying DOM node
 * @param {string=} name String The attribute name
 * @param {string=} namespace String The namespace in which to look for the attribute
 * @return {string} String The attribute value
 */
Ext.dom.IAbstractElement.prototype.getAttribute = function(name, namespace) {};

/**
 * [Method] Gets the width of the border s for the specified side s  Defined in override Ext dom AbstractElement_style
 * @param {string=} side String Can be t, l, r, b or any combination of those to add multiple values. For example, passing 'lr' would get the border left width + the border right width.
 * @return {number} Number The width of the sides passed added together
 */
Ext.dom.IAbstractElement.prototype.getBorderWidth = function(side) {};

/**
 * [Method] Returns a child element of this element given its id
 * @param {string=} id String The id of the desired child element.
 * @param {boolean=} asDom Boolean True to return the DOM element, false to return a wrapped Element object.
 * @return {void}
 */
Ext.dom.IAbstractElement.prototype.getById = function(id, asDom) {};

/**
 * [Method] Returns the innerHTML of an Element or an empty string if the element s dom no longer exists
 * @return {void}
 */
Ext.dom.IAbstractElement.prototype.getHTML = function() {};

/**
 * [Method] Returns the offset height of the element Defined in override Ext dom AbstractElement_style
 * @param {boolean=} contentHeight Boolean true to get the height minus borders and padding
 * @return {number} Number The element's height
 */
Ext.dom.IAbstractElement.prototype.getHeight = function(contentHeight) {};

/**
 * [Method] Returns an object with properties top left right and bottom representing the margins of this element unless sides i
 * @param {string=} sides String Any combination of l, r, t, b to get the sum of those sides
 * @return {?} Object/Number
 */
Ext.dom.IAbstractElement.prototype.getMargin = function(sides) {};

/**
 * [Method] Gets the width of the padding s for the specified side s  Defined in override Ext dom AbstractElement_style
 * @param {string=} side String Can be t, l, r, b or any combination of those to add multiple values. For example, passing 'lr' would get the padding left + the padding right.
 * @return {number} Number The padding of the sides passed added together
 */
Ext.dom.IAbstractElement.prototype.getPadding = function(side) {};

/**
 * [Method] Returns the size of the element
 * @param {boolean=} contentSize Boolean true to get the width/size minus borders and padding
 * @return {?} Object An object containing the element's size:
 */
Ext.dom.IAbstractElement.prototype.getSize = function(contentSize) {};

/**
 * [Method] Returns a named style property based on computed currentStyle primary and inline style if primary is not available
 * @param {?=} property String/String[] The style property (or multiple property names in an array) whose value is returned.
 * @param {boolean=} inline Boolean if true only inline styles will be returned.
 * @return {?} String/Object The current value of the style property for this element (or a hash of named style values if multiple property arguments are requested).
 */
Ext.dom.IAbstractElement.prototype.getStyle = function(property, inline) {};

/**
 * [Method] Returns the value of the value attribute
 * @param {boolean=} asNumber Boolean true to parse the value as a number
 * @return {?} String/Number
 */
Ext.dom.IAbstractElement.prototype.getValue = function(asNumber) {};

/**
 * [Method] Returns the dimensions of the element available to lay content out in
 * @return {?} Object Object describing width and height.
 */
Ext.dom.IAbstractElement.prototype.getViewSize = function() {};

/**
 * [Method] Returns the offset width of the element Defined in override Ext dom AbstractElement_style
 * @param {boolean=} contentWidth Boolean true to get the width minus borders and padding
 * @return {number} Number The element's width
 */
Ext.dom.IAbstractElement.prototype.getWidth = function(contentWidth) {};

/**
 * [Method] Checks if the specified CSS class exists on this element s DOM node
 * @param {string=} className String The CSS class to check for
 * @return {boolean} Boolean True if the class exists, else false
 */
Ext.dom.IAbstractElement.prototype.hasCls = function(className) {};

/**
 * [Method] Hide this element  Uses display mode to determine whether to use display or visibility
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.hide = function(animate) {};

/**
 * [Method] Inserts this element after the passed element in the DOM Defined in override Ext dom AbstractElement_insertion
 * @param {?=} el String/HTMLElement/Ext.dom.AbstractElement The element to insert after. The id of the node, a DOM Node or an existing Element.
 * @return {!Ext.dom.IAbstractElement} Ext.dom.AbstractElement This element
 */
Ext.dom.IAbstractElement.prototype.insertAfter = function(el) {};

/**
 * [Method] Inserts this element before the passed element in the DOM Defined in override Ext dom AbstractElement_insertion
 * @param {?=} el String/HTMLElement/Ext.dom.AbstractElement The element before which this element will be inserted. The id of the node, a DOM Node or an existing Element.
 * @return {!Ext.dom.IAbstractElement} Ext.dom.AbstractElement This element
 */
Ext.dom.IAbstractElement.prototype.insertBefore = function(el) {};

/**
 * [Method] Inserts or creates an element or DomHelper config as the first child of this element Defined in override Ext dom
 * @param {?=} el String/HTMLElement/Ext.dom.AbstractElement/Object The id or element to insert or a DomHelper config to create and insert
 * @return {!Ext.dom.IAbstractElement} Ext.dom.AbstractElement The new child
 */
Ext.dom.IAbstractElement.prototype.insertFirst = function(el) {};

/**
 * [Method] Inserts an html fragment into this element Defined in override Ext dom AbstractElement_insertion
 * @param {string=} where String Where to insert the html in relation to this element - beforeBegin, afterBegin, beforeEnd, afterEnd. See Ext.dom.Helper.insertHtml for details.
 * @param {string=} html String The HTML fragment
 * @param {boolean=} returnEl Boolean True to return an Ext.dom.AbstractElement
 * @return {?} HTMLElement/Ext.dom.AbstractElement The inserted node (or nearest related if more than 1 inserted)
 */
Ext.dom.IAbstractElement.prototype.insertHtml = function(where, html, returnEl) {};

/**
 * [Method] Inserts or creates the passed element or DomHelper config as a sibling of this element Defined in override Ext d
 * @param {?=} el String/HTMLElement/Ext.dom.AbstractElement/Object/Array The id, element to insert or a DomHelper config to create and insert or an array of any of those.
 * @param {string=} where String 'before' or 'after'
 * @param {boolean=} returnDom Boolean True to return the raw DOM element instead of Ext.dom.AbstractElement
 * @return {!Ext.dom.IAbstractElement} Ext.dom.AbstractElement The inserted Element. If an array is passed, the last inserted element is returned.
 */
Ext.dom.IAbstractElement.prototype.insertSibling = function(el, where, returnDom) {};

/**
 * [Method] Returns true if this element matches the passed simple selector e g
 * @param {string=} selector String The simple selector to test
 * @return {boolean} Boolean True if this element matches the selector, else false
 */
Ext.dom.IAbstractElement.prototype.is = function(selector) {};

/**
 * [Method] Checks if the current value of a style is equal to a given value
 * @param {string=} style String property whose value is returned.
 * @param {string=} value String to check against.
 * @return {boolean} Boolean true for when the current value equals the given value.
 */
Ext.dom.IAbstractElement.prototype.isStyle = function(style, value) {};

/**
 * [Method] Returns true if the value of the given property is visually transparent
 * @param {string=} prop String The style property whose value is to be tested.
 * @return {boolean} Boolean True if the style property is visually transparent.
 */
Ext.dom.IAbstractElement.prototype.isTransparent = function(prop) {};

/**
 * [Method] Gets the last child skipping text nodes Defined in override Ext dom AbstractElement_traversal
 * @param {string=} selector String Find the previous sibling that matches the passed simple selector
 * @param {boolean=} returnDom Boolean True to return a raw dom node instead of an Ext.dom.Element
 * @return {?} Ext.dom.Element/HTMLElement The last child or null
 */
Ext.dom.IAbstractElement.prototype.last = function(selector, returnDom) {};

/**
 * [Method] Puts a mask over this element to disable user interaction
 * @param {string=} msg String A message to display in the mask
 * @param {string=} msgCls String A css class to apply to the msg element
 * @return {void}
 */
Ext.dom.IAbstractElement.prototype.mask = function(msg, msgCls) {};

/**
 * [Method] Gets the next sibling skipping text nodes Defined in override Ext dom AbstractElement_traversal
 * @param {string=} selector String Find the next sibling that matches the passed simple selector
 * @param {boolean=} returnDom Boolean True to return a raw dom node instead of an Ext.dom.Element
 * @return {?} Ext.dom.Element/HTMLElement The next sibling or null
 */
Ext.dom.IAbstractElement.prototype.next = function(selector, returnDom) {};

/**
 * [Method] Gets the parent node for this element optionally chaining up trying to match a selector Defined in override Ext dom
 * @param {string=} selector String Find a parent node that matches the passed simple selector
 * @param {boolean=} returnDom Boolean True to return a raw dom node instead of an Ext.dom.Element
 * @return {?} Ext.dom.Element/HTMLElement The parent node or null
 */
Ext.dom.IAbstractElement.prototype.parent = function(selector, returnDom) {};

/**
 * [Method] Gets the previous sibling skipping text nodes Defined in override Ext dom AbstractElement_traversal
 * @param {string=} selector String Find the previous sibling that matches the passed simple selector
 * @param {boolean=} returnDom Boolean True to return a raw dom node instead of an Ext.dom.Element
 * @return {?} Ext.dom.Element/HTMLElement The previous sibling or null
 */
Ext.dom.IAbstractElement.prototype.prev = function(selector, returnDom) {};

/**
 * [Method] Selects child nodes based on the passed CSS selector the selector should not contain an id
 * @param {string=} selector String The CSS selector
 * @return {!Array<!HTMLElement>} HTMLElement[] An array of the matched nodes
 */
Ext.dom.IAbstractElement.prototype.query = function(selector) {};

/**
 * [Method] Adds one or more CSS classes to this element and removes the same class es from all siblings
 * @param {?=} className String/String[] The CSS class to add, or an array of classes
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.radioCls = function(className) {};

/**
 * [Method] Removes this element s dom reference
 * @return {void}
 */
Ext.dom.IAbstractElement.prototype.remove = function() {};

/**
 * [Method] Removes one or more CSS classes from the element
 * @param {?=} className String/String[] The CSS classes to remove separated by space, or an array of classes
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.removeCls = function(className) {};

/**
 * [Method] Forces the browser to repaint this element Defined in override Ext dom AbstractElement_style
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.repaint = function() {};

/**
 * [Method] Replaces the passed element with this element Defined in override Ext dom AbstractElement_insertion
 * @param {?=} el String/HTMLElement/Ext.dom.AbstractElement The element to replace. The id of the node, a DOM Node or an existing Element.
 * @return {!Ext.dom.IAbstractElement} Ext.dom.AbstractElement This element
 */
Ext.dom.IAbstractElement.prototype.replace = function(el) {};

/**
 * [Method] Replaces a CSS class on the element with another
 * @param {string=} oldClassName String The CSS class to replace
 * @param {string=} newClassName String The replacement CSS class
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.replaceCls = function(oldClassName, newClassName) {};

/**
 * [Method] Replaces this element with the passed element Defined in override Ext dom AbstractElement_insertion
 * @param {?=} el String/HTMLElement/Ext.dom.AbstractElement/Object The new element (id of the node, a DOM Node or an existing Element) or a DomHelper config of an element to create
 * @return {!Ext.dom.IAbstractElement} Ext.dom.AbstractElement This element
 */
Ext.dom.IAbstractElement.prototype.replaceWith = function(el) {};

/**
 * [Method] Creates a Ext CompositeElement for child nodes based on the passed CSS selector the selector should not contain an id
 * @param {string=} selector String The CSS selector
 * @param {boolean=} unique Boolean True to create a unique Ext.Element for each element. Defaults to a shared flyweight object.
 * @return {!Ext.ICompositeElement} Ext.CompositeElement The composite element
 */
Ext.dom.IAbstractElement.prototype.select = function(selector, unique) {};

/**
 * [Method] Serializes a DOM form into a url encoded string Defined in override Ext dom AbstractElement_static
 * @param {?=} form Object The form
 * @return {string} String The url encoded form
 */
Ext.dom.IAbstractElement.prototype.serializeForm = function(form) {};

/**
 * [Method] Sets the passed attributes as attributes of this element a style attribute can be a string object or function
 * @param {?=} o Object The object with the attributes
 * @param {boolean=} useSet Boolean false to override the default setAttribute to use expandos.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.set = function(o, useSet) {};

/**
 * [Method] Set the innerHTML of this element
 * @param {string=} html String The new HTML
 * @return {!Ext.IElement} Ext.Element this
 */
Ext.dom.IAbstractElement.prototype.setHTML = function(html) {};

/**
 * [Method] Set the height of this Element
 * @param {?=} height Number/String The new height. This may be one of:  A Number specifying the new height in this Element's defaultUnits (by default, pixels.) A String used to set the CSS height style. Animation may not be used.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.setHeight = function(height) {};

/**
 * [Method] Set the size of this Element
 * @param {?=} width Number/String The new width. This may be one of:  A Number specifying the new width in this Element's defaultUnits (by default, pixels). A String used to set the CSS width style. Animation may not be used. A size object in the format {width: widthValue, height: heightValue}.
 * @param {?=} height Number/String The new height. This may be one of:  A Number specifying the new height in this Element's defaultUnits (by default, pixels). A String used to set the CSS height style. Animation may not be used.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.setSize = function(width, height) {};

/**
 * [Method] Wrapper for setting style properties also takes single object parameter of multiple styles
 * @param {?=} property String/Object The style property to be set, or an object of multiple styles.
 * @param {string=} value String The value to apply to the given property, or null if an object was passed.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.setStyle = function(property, value) {};

/**
 * [Method] Use this to change the visibility mode between VISIBILITY DISPLAY OFFSETS or ASCLASS
 * @param {?=} mode Object
 * @return {!Ext.dom.IAbstractElement} Ext.dom.AbstractElement this
 */
Ext.dom.IAbstractElement.prototype.setVisibilityMode = function(mode) {};

/**
 * [Method] Sets the visibility of the element see details
 * @param {boolean=} visible Boolean Whether the element is visible
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.setVisible = function(visible, animate) {};

/**
 * [Method] Set the width of this Element
 * @param {?=} width Number/String The new width. This may be one of:  A Number specifying the new width in this Element's defaultUnits (by default, pixels). A String used to set the CSS width style. Animation may not be used.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.setWidth = function(width) {};

/**
 * [Method] Show this element  Uses display mode to determine whether to use display or visibility
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.show = function(animate) {};

/**
 * [Method] Toggles the specified CSS class on this element removes it if it already exists otherwise adds it
 * @param {string=} className String The CSS class to toggle
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.toggleCls = function(className) {};

/**
 * [Method] Removes a previously applied mask
 * @return {void}
 */
Ext.dom.IAbstractElement.prototype.unmask = function() {};

/**
 * [Method] Walks up the DOM looking for a parent node that matches the passed simple selector e g
 * @param {string=} selector String The simple selector to test
 * @param {?=} limit Number/String/HTMLElement/Ext.Element The max depth to search as a number or an element which causes the upward traversal to stop and is not considered for inclusion as the result. (defaults to 50 || document.documentElement)
 * @param {boolean=} returnDom Boolean True to return the DOM node instead of Ext.dom.Element
 * @return {!Ext.IElement} Ext.Element The matching DOM node (or null if no match was found)
 */
Ext.dom.IAbstractElement.prototype.up = function(selector, limit, returnDom) {};

/**
 * [Method] Update the innerHTML of this element
 * @param {string=} html String The new HTML
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IAbstractElement.prototype.update = function(html) {};

/**
 * [Method] Creates and wraps this element with another element Defined in override Ext dom AbstractElement_insertion
 * @param {?=} config Object DomHelper element config object for the wrapper element or null for an empty div
 * @param {boolean=} returnDom Boolean True to return the raw DOM element instead of Ext.dom.AbstractElement
 * @param {string=} selector String A DomQuery selector to select a descendant node within the created element to use as the wrapping element.
 * @return {?} HTMLElement/Ext.dom.AbstractElement The newly created wrapper element
 */
Ext.dom.IAbstractElement.prototype.wrap = function(config, returnDom, selector) {};
/**
 * @constructor
 * @struct
 */
Ext.dom.AbstractElement = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.dom.AbstractElement.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.dom.AbstractElement.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.dom.AbstractElement.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.dom.AbstractElement.createAlias = function(alias, origin) {};

/**
 * [Method] Gets the singleton flyweight element with the passed node as the active element
 * @param {?=} dom String/HTMLElement The dom node or id
 * @param {string=} named String Allows for creation of named reusable flyweights to prevent conflicts (e.g. internally Ext uses "_global")
 * @return {!Ext.dom.element.IFly} Ext.dom.Element.Fly The singleton flyweight object (or null if no matching element was found)
 */
Ext.dom.AbstractElement.fly = function(dom, named) {};

/**
 * [Method] Returns the top Element that is located at the passed coordinates Defined in override Ext dom AbstractElement_static
 * @param {number=} x Number The x coordinate
 * @param {number=} y Number The y coordinate
 * @return {string} String The found Element
 */
Ext.dom.AbstractElement.fromPoint = function(x, y) {};

/**
 * [Method] Retrieves Ext dom Element objects
 * @param {?=} el String/HTMLElement/Ext.Element The id of the node, a DOM Node or an existing Element.
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element object (or null if no matching element was found)
 */
Ext.dom.AbstractElement.get = function(el) {};

/**
 * [Method] Retrieves the document height Defined in override Ext dom AbstractElement_static
 * @return {number} Number documentHeight
 */
Ext.dom.AbstractElement.getDocumentHeight = function() {};

/**
 * [Method] Retrieves the document width Defined in override Ext dom AbstractElement_static
 * @return {number} Number documentWidth
 */
Ext.dom.AbstractElement.getDocumentWidth = function() {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.dom.AbstractElement.getName = function() {};

/**
 * [Method] Retrieves the current orientation of the window
 * @return {string} String Orientation of window: 'portrait' or 'landscape'
 */
Ext.dom.AbstractElement.getOrientation = function() {};

/**
 * [Method] Retrieves the viewport size of the window
 * @return {?} Object object containing width and height properties
 */
Ext.dom.AbstractElement.getViewSize = function() {};

/**
 * [Method] Retrieves the viewport height of the window
 * @return {number} Number viewportHeight
 */
Ext.dom.AbstractElement.getViewportHeight = function() {};

/**
 * [Method] Retrieves the viewport width of the window
 * @return {number} Number viewportWidth
 */
Ext.dom.AbstractElement.getViewportWidth = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.dom.AbstractElement.implement = function() {};

/**
 * [Method] Returns an array of unique class names based upon the input strings or string arrays
 * @param {?=} clsList1 Mixed A string of class names, or an array of class names.
 * @param {?=} clsList2 Mixed A string of class names, or an array of class names.
 * @return {!Array<?>} Array An array of strings representing remaining unique, merged class names. If class names were added to the first list, the changed property will be true.
 */
Ext.dom.AbstractElement.mergeClsList = function(clsList1, clsList2) {};

/**
 * [Method] Normalizes CSS property keys from dash delimited to camel case JavaScript Syntax
 * @param {string=} prop String The property to normalize
 * @return {string} String The normalized string
 */
Ext.dom.AbstractElement.normalize = function(prop) {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.dom.AbstractElement.override = function(members) {};

/**
 * [Method] Parses a number or string representing margin sizes into an object
 * @param {?=} box Number/String The encoded margins
 * @return {?} Object An object with margin sizes for top, right, bottom and left
 */
Ext.dom.AbstractElement.parseBox = function(box) {};

/**
 * [Method] Converts a CSS string into an object with a property for each style
 * @param {string=} styles String A CSS string
 * @return {?} Object styles
 */
Ext.dom.AbstractElement.parseStyles = function(styles) {};

/**
 * [Method] Returns an array of unique class names deom the first parameter with all class names from the second parameter removed
 * @param {?=} existingClsList Mixed A string of class names, or an array of class names.
 * @param {?=} removeClsList Mixed A string of class names, or an array of class names to remove from existingClsList.
 * @return {!Array<?>} Array An array of strings representing remaining class names. If class names were removed, the changed property will be true.
 */
Ext.dom.AbstractElement.removeCls = function(existingClsList, removeClsList) {};

/**
 * [Method] Parses a number or string representing margin sizes into an object
 * @param {?=} box Number/String/Object The encoded margins, or an object with top, right, bottom, and left properties
 * @param {string=} units String The type of units to add
 * @return {string} String An string with unitized (px if units is not specified) metrics for top, right, bottom and left
 */
Ext.dom.AbstractElement.unitizeBox = function(box, units) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.dom.IAbstractHelper = function() {};

/**
 * [Method] Creates new DOM element s and appends them to el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @param {boolean=} returnElement Boolean true to return a Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.dom.IAbstractHelper.prototype.append = function(el, o, returnElement) {};

/**
 * [Method] Applies a style specification to an element
 * @param {?=} el String/HTMLElement The element to apply styles to
 * @param {?=} styles String/Object/Function A style specification string e.g. 'width:100px', or object in the form {width:'100px'}, or a function which returns such a specification.
 * @return {void}
 */
Ext.dom.IAbstractHelper.prototype.applyStyles = function(el, styles) {};

/**
 * [Method] Converts the styles from the given object to text
 * @param {?=} styles Object The object describing the styles.
 * @param {!Array<string>=} buffer String[] The output buffer.
 * @return {?} String/String[] If buffer is passed, it is returned. Otherwise the style string is returned.
 */
Ext.dom.IAbstractHelper.prototype.generateStyles = function(styles, buffer) {};

/**
 * [Method] Creates new DOM element s and inserts them after el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object The DOM object spec (and children)
 * @param {boolean=} returnElement Boolean true to return a Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.dom.IAbstractHelper.prototype.insertAfter = function(el, o, returnElement) {};

/**
 * [Method] Creates new DOM element s and inserts them before el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @param {boolean=} returnElement Boolean true to return a Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.dom.IAbstractHelper.prototype.insertBefore = function(el, o, returnElement) {};

/**
 * [Method] Creates new DOM element s and inserts them as the first child of el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @param {boolean=} returnElement Boolean true to return a Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.dom.IAbstractHelper.prototype.insertFirst = function(el, o, returnElement) {};

/**
 * [Method] Inserts an HTML fragment into the DOM
 * @param {string=} where String Where to insert the html in relation to el - beforeBegin, afterBegin, beforeEnd, afterEnd. For example take the following HTML: &lt;div&gt;Contents&lt;/div&gt; Using different where values inserts element to the following places:  beforeBegin: &lt;HERE&gt;&lt;div&gt;Contents&lt;/div&gt; afterBegin: &lt;div&gt;&lt;HERE&gt;Contents&lt;/div&gt; beforeEnd: &lt;div&gt;Contents&lt;HERE&gt;&lt;/div&gt; afterEnd: &lt;div&gt;Contents&lt;/div&gt;&lt;HERE&gt;
 * @param {?=} el HTMLElement/TextNode The context element
 * @param {string=} html String The HTML fragment
 * @return {!HTMLElement} HTMLElement The new node
 */
Ext.dom.IAbstractHelper.prototype.insertHtml = function(where, el, html) {};

/**
 * [Method] Returns the markup for the passed Element s config
 * @param {?=} spec Object The DOM object spec (and children)
 * @return {string} String
 */
Ext.dom.IAbstractHelper.prototype.markup = function(spec) {};

/**
 * [Method] Creates new DOM element s and overwrites the contents of el with them
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @param {boolean=} returnElement Boolean true to return a Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.dom.IAbstractHelper.prototype.overwrite = function(el, o, returnElement) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.dom.IAbstractQuery = function() {};

/**
 * [Method] Returns true if the passed element s match the passed simple selector e g
 * @param {?=} el String/HTMLElement/Array An element id, element or array of elements
 * @param {string=} selector String The simple selector to test
 * @return {boolean} Boolean
 */
Ext.dom.IAbstractQuery.prototype.is = function(el, selector) {};

/**
 * [Method] Selects a group of elements
 * @param {string=} selector String The selector/xpath query (can be a comma separated list of selectors)
 * @param {?=} root HTMLElement/String The start of the query (defaults to document).
 * @return {!Array<!HTMLElement>} HTMLElement[] An Array of DOM elements which match the selector. If there are no matches, and empty Array is returned.
 */
Ext.dom.IAbstractQuery.prototype.select = function(selector, root) {};

/**
 * [Method] Selects a single element
 * @param {string=} selector String The selector/xpath query
 * @param {?=} root HTMLElement/String The start of the query (defaults to document).
 * @return {!HTMLElement} HTMLElement The DOM element which matched the selector.
 */
Ext.dom.IAbstractQuery.prototype.selectNode = function(selector, root) {};
/**
 * @extends {Ext.dom.ICompositeElementLite}
 * @record
 * @struct
 */
Ext.dom.ICompositeElement = function() {};
/**
 * @extends {Ext.dom.ICompositeElementLite}
 * @record
 * @struct
 */
Ext.ICompositeElement = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.dom.ICompositeElementLite = function() {};
 /** @type {!Array<!HTMLElement>} */
Ext.dom.ICompositeElementLite.prototype.elements;
 /** @type {boolean} */
Ext.dom.ICompositeElementLite.prototype.isComposite;

/**
 * [Method] Adds elements to this Composite object
 * @param {?=} els HTMLElement[]/Ext.dom.CompositeElement Either an Array of DOM elements to add, or another Composite object who's elements should be added.
 * @return {!Ext.dom.ICompositeElement} Ext.dom.CompositeElement This Composite object.
 */
Ext.dom.ICompositeElementLite.prototype.add = function(els) {};

/**
 * [Method] Removes all elements from this Composite
 * @param {boolean=} removeDom Boolean True to also remove the elements from the document.
 * @return {void}
 */
Ext.dom.ICompositeElementLite.prototype.clear = function(removeDom) {};

/**
 * [Method] Returns true if this composite contains the passed element
 * @param {?=} el String/HTMLElement/Ext.Element/Number The id of an element, or an Ext.Element, or an HtmlElement to find within the composite collection.
 * @return {boolean} Boolean
 */
Ext.dom.ICompositeElementLite.prototype.contains = function(el) {};

/**
 * [Method] Calls the passed function for each element in this composite
 * @param {?=} fn Function The function to call.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the Element.
 * @return {!Ext.dom.ICompositeElement} Ext.dom.CompositeElement this
 */
Ext.dom.ICompositeElementLite.prototype.each = function(fn, scope) {};

/**
 * [Method] Clears this Composite and adds the elements passed
 * @param {?=} els HTMLElement[]/Ext.dom.CompositeElement Either an array of DOM elements, or another Composite from which to fill this Composite.
 * @return {!Ext.dom.ICompositeElement} Ext.dom.CompositeElement this
 */
Ext.dom.ICompositeElementLite.prototype.fill = function(els) {};

/**
 * [Method] Filters this composite to only elements that match the passed selector
 * @param {?=} selector String/Function A string CSS selector or a comparison function. The comparison function will be called with the following arguments:
 * @return {!Ext.dom.ICompositeElement} Ext.dom.CompositeElement this
 */
Ext.dom.ICompositeElementLite.prototype.filter = function(selector) {};

/**
 * [Method] Returns the first Element
 * @return {!Ext.dom.IElement} Ext.dom.Element
 */
Ext.dom.ICompositeElementLite.prototype.first = function() {};

/**
 * [Method] Returns the number of elements in this Composite
 * @return {number} Number
 */
Ext.dom.ICompositeElementLite.prototype.getCount = function() {};

/**
 * [Method] Find the index of the passed element within the composite collection
 * @param {?=} el String/HTMLElement/Ext.Element/Number The id of an element, or an Ext.dom.Element, or an HtmlElement to find within the composite collection.
 * @return {number} Number The index of the passed Ext.dom.Element in the composite collection, or -1 if not found.
 */
Ext.dom.ICompositeElementLite.prototype.indexOf = function(el) {};

/**
 * [Method] Returns a flyweight Element of the dom element object at the specified index
 * @param {number=} index Number
 * @return {!Ext.dom.IElement} Ext.dom.Element
 */
Ext.dom.ICompositeElementLite.prototype.item = function(index) {};

/**
 * [Method] Returns the last Element
 * @return {!Ext.dom.IElement} Ext.dom.Element
 */
Ext.dom.ICompositeElementLite.prototype.last = function() {};

/**
 * [Method] Removes the specified element s
 * @param {?=} el String/HTMLElement/Ext.Element/Number The id of an element, the Element itself, the index of the element in this composite or an array of any of those.
 * @param {boolean=} removeDom Boolean True to also remove the element from the document.
 * @return {!Ext.dom.ICompositeElement} Ext.dom.CompositeElement this
 */
Ext.dom.ICompositeElementLite.prototype.removeElement = function(el, removeDom) {};

/**
 * [Method] Replaces the specified element with the passed element
 * @param {?=} el String/HTMLElement/Ext.Element/Number The id of an element, the Element itself, the index of the element in this composite to replace.
 * @param {?=} replacement String/Ext.Element The id of an element or the Element itself.
 * @param {boolean=} domReplace Boolean True to remove and replace the element in the document too.
 * @return {!Ext.dom.ICompositeElement} Ext.dom.CompositeElement this
 */
Ext.dom.ICompositeElementLite.prototype.replaceElement = function(el, replacement, domReplace) {};

/**
 * [Method] Gets a range nodes
 * @param {number=} start Number The index of the first node in the range
 * @param {number=} end Number The index of the last node in the range
 * @return {!Array<!HTMLElement>} HTMLElement[] An array of nodes
 */
Ext.dom.ICompositeElementLite.prototype.slice = function(start, end) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.ICompositeElementLite = function() {};
 /** @type {!Array<!HTMLElement>} */
Ext.ICompositeElementLite.prototype.elements;
 /** @type {boolean} */
Ext.ICompositeElementLite.prototype.isComposite;

/**
 * [Method] Adds elements to this Composite object
 * @param {?=} els HTMLElement[]/Ext.dom.CompositeElement Either an Array of DOM elements to add, or another Composite object who's elements should be added.
 * @return {!Ext.dom.ICompositeElement} Ext.dom.CompositeElement This Composite object.
 */
Ext.ICompositeElementLite.prototype.add = function(els) {};

/**
 * [Method] Removes all elements from this Composite
 * @param {boolean=} removeDom Boolean True to also remove the elements from the document.
 * @return {void}
 */
Ext.ICompositeElementLite.prototype.clear = function(removeDom) {};

/**
 * [Method] Returns true if this composite contains the passed element
 * @param {?=} el String/HTMLElement/Ext.Element/Number The id of an element, or an Ext.Element, or an HtmlElement to find within the composite collection.
 * @return {boolean} Boolean
 */
Ext.ICompositeElementLite.prototype.contains = function(el) {};

/**
 * [Method] Calls the passed function for each element in this composite
 * @param {?=} fn Function The function to call.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the Element.
 * @return {!Ext.dom.ICompositeElement} Ext.dom.CompositeElement this
 */
Ext.ICompositeElementLite.prototype.each = function(fn, scope) {};

/**
 * [Method] Clears this Composite and adds the elements passed
 * @param {?=} els HTMLElement[]/Ext.dom.CompositeElement Either an array of DOM elements, or another Composite from which to fill this Composite.
 * @return {!Ext.dom.ICompositeElement} Ext.dom.CompositeElement this
 */
Ext.ICompositeElementLite.prototype.fill = function(els) {};

/**
 * [Method] Filters this composite to only elements that match the passed selector
 * @param {?=} selector String/Function A string CSS selector or a comparison function. The comparison function will be called with the following arguments:
 * @return {!Ext.dom.ICompositeElement} Ext.dom.CompositeElement this
 */
Ext.ICompositeElementLite.prototype.filter = function(selector) {};

/**
 * [Method] Returns the first Element
 * @return {!Ext.dom.IElement} Ext.dom.Element
 */
Ext.ICompositeElementLite.prototype.first = function() {};

/**
 * [Method] Returns the number of elements in this Composite
 * @return {number} Number
 */
Ext.ICompositeElementLite.prototype.getCount = function() {};

/**
 * [Method] Find the index of the passed element within the composite collection
 * @param {?=} el String/HTMLElement/Ext.Element/Number The id of an element, or an Ext.dom.Element, or an HtmlElement to find within the composite collection.
 * @return {number} Number The index of the passed Ext.dom.Element in the composite collection, or -1 if not found.
 */
Ext.ICompositeElementLite.prototype.indexOf = function(el) {};

/**
 * [Method] Returns a flyweight Element of the dom element object at the specified index
 * @param {number=} index Number
 * @return {!Ext.dom.IElement} Ext.dom.Element
 */
Ext.ICompositeElementLite.prototype.item = function(index) {};

/**
 * [Method] Returns the last Element
 * @return {!Ext.dom.IElement} Ext.dom.Element
 */
Ext.ICompositeElementLite.prototype.last = function() {};

/**
 * [Method] Removes the specified element s
 * @param {?=} el String/HTMLElement/Ext.Element/Number The id of an element, the Element itself, the index of the element in this composite or an array of any of those.
 * @param {boolean=} removeDom Boolean True to also remove the element from the document.
 * @return {!Ext.dom.ICompositeElement} Ext.dom.CompositeElement this
 */
Ext.ICompositeElementLite.prototype.removeElement = function(el, removeDom) {};

/**
 * [Method] Replaces the specified element with the passed element
 * @param {?=} el String/HTMLElement/Ext.Element/Number The id of an element, the Element itself, the index of the element in this composite to replace.
 * @param {?=} replacement String/Ext.Element The id of an element or the Element itself.
 * @param {boolean=} domReplace Boolean True to remove and replace the element in the document too.
 * @return {!Ext.dom.ICompositeElement} Ext.dom.CompositeElement this
 */
Ext.ICompositeElementLite.prototype.replaceElement = function(el, replacement, domReplace) {};

/**
 * [Method] Gets a range nodes
 * @param {number=} start Number The index of the first node in the range
 * @param {number=} end Number The index of the last node in the range
 * @return {!Array<!HTMLElement>} HTMLElement[] An array of nodes
 */
Ext.ICompositeElementLite.prototype.slice = function(start, end) {};
/** @const */
Ext.dom.element = {};
/**
 * @extends {Ext.dom.IElement}
 * @record
 * @struct
 */
Ext.dom.element.IFly = function() {};
 /** @type {boolean} */
Ext.dom.element.IFly.prototype.isFly;
/** @const */
Ext.dom.abstractelement = {};
/**
 * @extends {Ext.dom.IElement}
 * @record
 * @struct
 */
Ext.dom.abstractelement.IFly = function() {};
 /** @type {boolean} */
Ext.dom.abstractelement.IFly.prototype.isFly;
/**
 * @extends {Ext.dom.IAbstractElement}
 * @record
 * @struct
 */
Ext.dom.IElement = function() {};
 /** @type {boolean} */
Ext.dom.IElement.prototype.autoBoxAdjust;
 /** @type {string} */
Ext.dom.IElement.prototype.originalDisplay;

/**
 * [Method] Sets up event handlers to add and remove a css class when the mouse is down and then up on this element a click effe
 * @param {string=} className String The class to add
 * @param {?=} testFn Function A test function to execute before adding the class. The passed parameter will be the Element instance. If this functions returns false, the class will not be added.
 * @param {?=} scope Object The scope to execute the testFn in.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.addClsOnClick = function(className, testFn, scope) {};

/**
 * [Method] Sets up event handlers to add and remove a css class when this element has the focus Defined in override Ext dom Ele
 * @param {string=} className String The class to add
 * @param {?=} testFn Function A test function to execute before adding the class. The passed parameter will be the Element instance. If this functions returns false, the class will not be added.
 * @param {?=} scope Object The scope to execute the testFn in.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.addClsOnFocus = function(className, testFn, scope) {};

/**
 * [Method] Sets up event handlers to add and remove a css class when the mouse is over this element Defined in override Ext dom
 * @param {string=} className String The class to add
 * @param {?=} testFn Function A test function to execute before adding the class. The passed parameter will be the Element instance. If this functions returns false, the class will not be added.
 * @param {?=} scope Object The scope to execute the testFn in.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.addClsOnOver = function(className, testFn, scope) {};

/**
 * [Method] Convenience method for constructing a KeyMap
 * @param {?=} key String/Number/Number[]/Object Either a string with the keys to listen for, the numeric key code, array of key codes or an object with the following options:
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope (this reference) in which the specified function is executed. Defaults to this Element.
 * @return {!Ext.util.IKeyMap} Ext.util.KeyMap The KeyMap created
 */
Ext.dom.IElement.prototype.addKeyListener = function(key, fn, scope) {};

/**
 * [Method] Creates a KeyMap for this element
 * @param {?=} config Object The KeyMap config. See Ext.util.KeyMap for more details
 * @return {!Ext.util.IKeyMap} Ext.util.KeyMap The KeyMap created
 */
Ext.dom.IElement.prototype.addKeyMap = function(config) {};

/**
 * [Method] Shorthand for on
 * @param {string=} eventName String The name of event to handle.
 * @param {?=} fn Function The handler function the event invokes. This function is passed the following parameters: evt : EventObject The EventObject describing the event. el : HtmlElement The DOM element which was the target of the event. Note that this may be filtered by using the delegate option. o : Object The options object from the call that setup the listener.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to this Element.
 * @param {?=} options Object An object containing handler configuration properties. This may contain any of the following properties: scope Object : The scope (this reference) in which the handler function is executed. If omitted, defaults to this Element. delegate String: A simple selector to filter the target or look for a descendant of the target. See below for additional details. stopEvent Boolean: True to stop the event. That is stop propagation, and prevent the default action. preventDefault Boolean: True to prevent the default action stopPropagation Boolean: True to prevent event propagation normalized Boolean: False to pass a browser event to the handler function instead of an Ext.EventObject target Ext.dom.Element: Only call the handler if the event was fired on the target Element, not if the event was bubbled up from a child node. delay Number: The number of milliseconds to delay the invocation of the handler after the event fires. single Boolean: True to add a handler to handle just the next firing of the event, and then remove itself. buffer Number: Causes the handler to be scheduled to run in an Ext.util.DelayedTask delayed by the specified number of milliseconds. If the event fires again within that time, the original handler is not invoked, but the new handler is scheduled in its place. Combining Options  Using the options argument, it is possible to combine different types of listeners:  A delayed, one-time listener that auto stops the event and adds a custom argument (forumId) to the options object. The options object is available as the third parameter in the handler function.  Code:  el.on('click', this.onClick, this, {  single: true,  delay: 100,  stopEvent : true,  forumId: 4 }); Attaching multiple handlers in 1 call  The method also allows for a single argument to be passed which is a config object containing properties which specify multiple handlers.  Code:  el.on({  'click' : {  fn: this.onClick,  scope: this,  delay: 100  },  'mouseover' : {  fn: this.onMouseOver,  scope: this  },  'mouseout' : {  fn: this.onMouseOut,  scope: this  } }); Or a shorthand syntax:  Code:  el.on({  'click' : this.onClick,  'mouseover' : this.onMouseOver,  'mouseout' : this.onMouseOut,  scope: this }); delegate  This is a configuration option that you can pass along when registering a handler for an event to assist with event delegation. Event delegation is a technique that is used to reduce memory consumption and prevent exposure to memory-leaks. By registering an event for a container element as opposed to each element within a container. By setting this configuration option to a simple selector, the target element will be filtered to look for a descendant of the target. For example:  // using this markup: &lt;div id='elId'&gt;  &lt;p id='p1'&gt;paragraph one&lt;/p&gt;  &lt;p id='p2' class='clickable'&gt;paragraph two&lt;/p&gt;  &lt;p id='p3'&gt;paragraph three&lt;/p&gt; &lt;/div&gt; // utilize event delegation to registering just one handler on the container element: el = Ext.get('elId'); el.on(  'click',  function(e,t) {  // handle click  console.info(t.id); // 'p2'  },  this,  {  // filter the target element to be a descendant with the class 'clickable'  delegate: '.clickable'  } );
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Performs custom animation on this Element
 * @param {?=} config Object Configuration for Ext.fx.Anim. Note that the to config is required.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.animate = function(config) {};

/**
 * [Method] Tries to blur the element
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.blur = function() {};

/**
 * [Method] Wraps the specified element with a special 9 element markup CSS block that renders by default as a gray container wit
 * @param {string=} clazz
 * @return {!Ext.dom.IElement} Ext.dom.Element The outermost wrapping element of the created box structure.
 */
Ext.dom.IElement.prototype.boxWrap = function(clazz) {};

/**
 * [Method] When an element is moved around in the DOM or is hidden using display none it loses layout and therefore all scrol
 * @return {?} Function A function which will restore all descentant elements of this Element to their scroll positions recorded when this function was executed. Be aware that the returned function is a closure which has captured the scope of cacheScrollValues, so take care to derefence it as soon as not needed - if is it is a var it will drop out of scope, and the reference will be freed.
 */
Ext.dom.IElement.prototype.cacheScrollValues = function() {};

/**
 * [Method] Centers the Element in either the viewport or another Element
 * @param {?=} centerIn String/HTMLElement/Ext.dom.Element element in which to center the element.
 * @return {void}
 */
Ext.dom.IElement.prototype.center = function(centerIn) {};

/**
 * [Method] Removes Empty or whitespace filled text nodes
 * @param {boolean=} forceReclean Boolean By default the element keeps track if it has been cleaned already so you can call this over and over. However, if you update the element and need to force a reclean, you can pass true.
 * @return {void}
 */
Ext.dom.IElement.prototype.clean = function(forceReclean) {};

/**
 * [Method] Alias for removeAllListeners
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.clearListeners = function() {};

/**
 * [Method] Clears any opacity settings from this element
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.clearOpacity = function() {};

/**
 * [Method] Clears positioning back to the default when the document was loaded
 * @param {string=} value String The value to use for the left, right, top, bottom. You could use 'auto'.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.clearPositioning = function(value) {};

/**
 * [Method] Store the current overflow setting and clip overflow on the element  use unclip to remove Defined in override Ext d
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.clip = function() {};

/**
 * [Method] Creates a proxy element of this element
 * @param {?=} config String/Object The class name of the proxy element or a DomHelper config object
 * @param {?=} renderTo String/HTMLElement The element or element id to render the proxy to. Defaults to: document.body.
 * @param {boolean=} matchBox Boolean True to align and size the proxy to this element now.
 * @return {!Ext.dom.IElement} Ext.dom.Element The new proxy element
 */
Ext.dom.IElement.prototype.createProxy = function(config, renderTo, matchBox) {};

/**
 * [Method] Creates an iframe shim for this element to keep selects and other windowed objects from showing through
 * @return {!Ext.dom.IElement} Ext.dom.Element The new shim element
 */
Ext.dom.IElement.prototype.createShim = function() {};

/**
 * [Method] Convenience method for setVisibilityMode Element DISPLAY
 * @param {string=} display String What to set display to when visible
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.enableDisplayMode = function(display) {};

/**
 * [Method] Fade an element in from transparent to opaque
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.dom.IElement.prototype.fadeIn = function(options) {};

/**
 * [Method] Fade an element out from opaque to transparent
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.dom.IElement.prototype.fadeOut = function(options) {};

/**
 * [Method] Tries to focus the element
 * @param {number=} defer Number Milliseconds to defer the focus
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.focus = function(defer) {};

/**
 * [Method] Alias for isFocusable
 * @return {boolean} Boolean True if the element is focusable
 */
Ext.dom.IElement.prototype.focusable = function() {};

/**
 * [Method] Shows a ripple of exploding attenuating borders to draw attention to an Element
 * @param {string=} color String The hex color value for the border.
 * @param {number=} count Number The number of ripples to display.
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.dom.IElement.prototype.frame = function(color, count, options) {};

/**
 * [Method] Returns the value of a namespaced attribute from the element s underlying DOM node
 * @param {string=} namespace String The namespace in which to look for the attribute
 * @param {string=} name String The attribute name
 * @return {string} String The attribute value
 */
Ext.dom.IElement.prototype.getAttributeNS = function(namespace, name) {};

/**
 * [Method] Gets the bottom Y coordinate of the element element Y position  element height  Defined in override Ext dom Elemen
 * @param {boolean=} local Boolean True to get the local css position instead of page coordinate
 * @return {number} Number
 */
Ext.dom.IElement.prototype.getBottom = function(local) {};

/**
 * [Method] Calculates the x y to center this element on the screen Defined in override Ext dom Element_position
 * @return {!Array<number>} Number[] The x, y values [x, y]
 */
Ext.dom.IElement.prototype.getCenterXY = function() {};

/**
 * [Method] Return the CSS color for the specified CSS attribute
 * @param {string=} attr String The css attribute
 * @param {string=} defaultValue String The default value to use when a valid color isn't found
 * @param {string=} prefix String defaults to #. Use an empty string when working with color anims.
 * @return {void}
 */
Ext.dom.IElement.prototype.getColor = function(attr, defaultValue, prefix) {};

/**
 * [Method] Returns either the offsetHeight or the height of this element based on CSS height adjusted by padding or borders when
 * @return {number} Number
 */
Ext.dom.IElement.prototype.getComputedHeight = function() {};

/**
 * [Method] Returns either the offsetWidth or the width of this element based on CSS width adjusted by padding or borders when ne
 * @return {number} Number
 */
Ext.dom.IElement.prototype.getComputedWidth = function() {};

/**
 * [Method] Returns the sum width of the padding and borders for the passed sides
 * @param {string=} sides String
 * @return {number} Number
 */
Ext.dom.IElement.prototype.getFrameWidth = function(sides) {};

/**
 * [Method] Gets the left X coordinate Defined in override Ext dom Element_position
 * @param {boolean=} local Boolean True to get the local css position instead of page coordinate
 * @return {number} Number
 */
Ext.dom.IElement.prototype.getLeft = function(local) {};

/**
 * [Method] Gets this element s ElementLoader
 * @return {!Ext.IElementLoader} Ext.ElementLoader The loader
 */
Ext.dom.IElement.prototype.getLoader = function() {};

/**
 * [Method] Gets the local CSS X position for the element Defined in override Ext dom Element_position
 * @return {number} Number
 */
Ext.dom.IElement.prototype.getLocalX = function() {};

/**
 * [Method] Gets the local CSS X and Y position for the element Defined in override Ext dom Element_position
 * @return {!Array<?>} Array [x, y]
 */
Ext.dom.IElement.prototype.getLocalXY = function() {};

/**
 * [Method] Gets the local CSS Y position for the element Defined in override Ext dom Element_position
 * @return {number} Number
 */
Ext.dom.IElement.prototype.getLocalY = function() {};

/**
 * [Method] Returns an object defining the area of this Element which can be passed to Ext util Positionable setBox to set anothe
 * @param {boolean=} asRegion Boolean If true an Ext.util.Region will be returned
 * @return {?} Object/Ext.util.Region box An object in the following format: {  left: &lt;Element's X position&gt;,  top: &lt;Element's Y position&gt;,  width: &lt;Element's width&gt;,  height: &lt;Element's height&gt;,  bottom: &lt;Element's lower bound&gt;,  right: &lt;Element's rightmost bound&gt; }  The returned object may also be addressed as an Array where index 0 contains the X position and index 1 contains the Y position. So the result may also be used for setXY
 */
Ext.dom.IElement.prototype.getPageBox = function(asRegion) {};

/**
 * [Method] Gets an object with all CSS positioning properties
 * @param {boolean=} autoPx Boolean true to return pixel values for "auto" styles.
 * @return {?} Object
 */
Ext.dom.IElement.prototype.getPositioning = function(autoPx) {};

/**
 * [Method] Gets the right X coordinate of the element element X position  element width  Defined in override Ext dom Element_
 * @param {boolean=} local Boolean True to get the local css position instead of page coordinates
 * @return {number} Number
 */
Ext.dom.IElement.prototype.getRight = function(local) {};

/**
 * [Method] Returns the current scroll position of the element
 * @return {?} Object An object containing the scroll position in the format {left: (scrollLeft), top: (scrollTop)}
 */
Ext.dom.IElement.prototype.getScroll = function() {};

/**
 * [Method] Gets the left scroll position Defined in override Ext dom Element_scroll
 * @return {number} Number The left scroll position
 */
Ext.dom.IElement.prototype.getScrollLeft = function() {};

/**
 * [Method] Gets the top scroll position Defined in override Ext dom Element_scroll
 * @return {number} Number The top scroll position
 */
Ext.dom.IElement.prototype.getScrollTop = function() {};

/**
 * [Method] Returns the dimensions of the element available to lay content out in
 * @return {?} Object Object describing width and height.
 */
Ext.dom.IElement.prototype.getStyleSize = function() {};

/**
 * [Method] Returns the width in pixels of the passed text or the width of the text in this Element
 * @param {string=} text String The text to measure. Defaults to the innerHTML of the element.
 * @param {number=} min Number The minumum value to return.
 * @param {number=} max Number The maximum value to return.
 * @return {number} Number The text width in pixels.
 */
Ext.dom.IElement.prototype.getTextWidth = function(text, min, max) {};

/**
 * [Method] Gets the top Y coordinate Defined in override Ext dom Element_position
 * @param {boolean=} local Boolean True to get the local css position instead of page coordinates
 * @return {number} Number
 */
Ext.dom.IElement.prototype.getTop = function(local) {};

/**
 * [Method] Gets element X position in page coordinates Defined in override Ext dom Element_position
 * @return {number} Number
 */
Ext.dom.IElement.prototype.getX = function() {};

/**
 * [Method] Gets element X and Y positions in page coordinates Defined in override Ext dom Element_position
 * @return {!Array<?>} Array [x, y]
 */
Ext.dom.IElement.prototype.getXY = function() {};

/**
 * [Method] Gets element Y position in page coordinates Defined in override Ext dom Element_position
 * @return {number} Number
 */
Ext.dom.IElement.prototype.getY = function() {};

/**
 * [Method] Slides the element while fading it out of view
 * @param {string=} anchor String One of the valid Ext.fx.Anim anchor positions (defaults to bottom: 'b')
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.dom.IElement.prototype.ghost = function(anchor, options) {};

/**
 * [Method] Hide this element  Uses display mode to determine whether to use display or visibility
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.hide = function(animate) {};

/**
 * [Method] Highlights the Element by setting a color applies to the background color by default but can be changed using the
 * @param {string=} color String The highlight color. Should be a 6 char hex color without the leading # (defaults to yellow: 'ffff9c')
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.dom.IElement.prototype.highlight = function(color, options) {};

/**
 * [Method] Sets up event handlers to call the passed functions when the mouse is moved into and out of the Element
 * @param {?=} overFn Function The function to call when the mouse enters the Element.
 * @param {?=} outFn Function The function to call when the mouse leaves the Element.
 * @param {?=} scope Object The scope (this reference) in which the functions are executed. Defaults to the Element's DOM element.
 * @param {?=} options Object Options for the listener. See the options parameter.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.hover = function(overFn, outFn, scope, options) {};

/**
 * [Method] Initializes a Ext dd DD drag drop object for this element
 * @param {string=} group String The group the DD object is member of
 * @param {?=} config Object The DD config object
 * @param {?=} overrides Object An object containing methods to override/implement on the DD object
 * @return {!Ext.dd.IDD} Ext.dd.DD The DD object
 */
Ext.dom.IElement.prototype.initDD = function(group, config, overrides) {};

/**
 * [Method] Initializes a Ext dd DDProxy object for this element
 * @param {string=} group String The group the DDProxy object is member of
 * @param {?=} config Object The DDProxy config object
 * @param {?=} overrides Object An object containing methods to override/implement on the DDProxy object
 * @return {!Ext.dd.IDDProxy} Ext.dd.DDProxy The DDProxy object
 */
Ext.dom.IElement.prototype.initDDProxy = function(group, config, overrides) {};

/**
 * [Method] Initializes a Ext dd DDTarget object for this element
 * @param {string=} group String The group the DDTarget object is member of
 * @param {?=} config Object The DDTarget config object
 * @param {?=} overrides Object An object containing methods to override/implement on the DDTarget object
 * @return {!Ext.dd.IDDTarget} Ext.dd.DDTarget The DDTarget object
 */
Ext.dom.IElement.prototype.initDDTarget = function(group, config, overrides) {};

/**
 * [Method] Tests various css rules browsers to determine if this element uses a border box
 * @return {boolean} Boolean
 */
Ext.dom.IElement.prototype.isBorderBox = function() {};

/**
 * [Method] Returns true if display is not none
 * @return {boolean} Boolean
 */
Ext.dom.IElement.prototype.isDisplayed = function() {};

/**
 * [Method] Checks whether this element can be focused
 * @param {?=} asFocusEl Object
 * @return {boolean} Boolean True if the element is focusable
 */
Ext.dom.IElement.prototype.isFocusable = function(asFocusEl) {};

/**
 * [Method] Returns true if this element is masked
 * @return {boolean} Boolean
 */
Ext.dom.IElement.prototype.isMasked = function() {};

/**
 * [Method] Returns true if this element is scrollable
 * @return {boolean} Boolean
 */
Ext.dom.IElement.prototype.isScrollable = function() {};

/**
 * [Method] Checks whether the element is currently visible using both visibility and display properties
 * @param {boolean=} deep Boolean True to walk the dom and see if parent elements are hidden. If false, the function only checks the visibility of the element itself and it may return true even though a parent is not visible.
 * @return {boolean} Boolean true if the element is currently visible, else false
 */
Ext.dom.IElement.prototype.isVisible = function(deep) {};

/**
 * [Method] Direct access to the Ext ElementLoader Ext ElementLoader load method
 * @param {?=} options Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.load = function(options) {};

/**
 * [Method] Puts a mask over this element to disable user interaction
 * @param {string=} msg String A message to display in the mask
 * @param {string=} msgCls String A css class to apply to the msg element
 * @return {!Ext.dom.IElement} Ext.dom.Element The mask element
 */
Ext.dom.IElement.prototype.mask = function(msg, msgCls) {};

/**
 * [Method] Monitors this Element for the mouse leaving
 * @param {number=} delay Number The delay in milliseconds to wait for possible mouse re-entry before calling the handler function.
 * @param {?=} handler Function The function to call if the mouse remains outside of this Element for the specified time.
 * @param {?=} scope Object The scope (this reference) in which the handler function executes. Defaults to this Element.
 * @return {?} Object The listeners object which was added to this element so that monitoring can be stopped. Example usage: // Hide the menu if the mouse moves out for 250ms or more this.mouseLeaveMonitor = this.menuEl.monitorMouseLeave(250, this.hideMenu, this); ... // Remove mouseleave monitor on menu destroy this.menuEl.un(this.mouseLeaveMonitor);
 */
Ext.dom.IElement.prototype.monitorMouseLeave = function(delay, handler, scope) {};

/**
 * [Method] Sets the position of the element in page coordinates
 * @param {number=} x Number X value for new position (coordinates are page-based)
 * @param {number=} y Number Y value for new position (coordinates are page-based)
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.moveTo = function(x, y, animate) {};

/**
 * [Method] Returns true if this element needs an explicit tabIndex to make it focusable
 * @return {void}
 */
Ext.dom.IElement.prototype.needsTabIndex = function() {};

/**
 * [Method] Appends an event handler to this element
 * @param {string=} eventName String The name of event to handle.
 * @param {?=} fn Function The handler function the event invokes. This function is passed the following parameters: evt : EventObject The EventObject describing the event. el : HtmlElement The DOM element which was the target of the event. Note that this may be filtered by using the delegate option. o : Object The options object from the call that setup the listener.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to this Element.
 * @param {?=} options Object An object containing handler configuration properties. This may contain any of the following properties: scope Object : The scope (this reference) in which the handler function is executed. If omitted, defaults to this Element. delegate String: A simple selector to filter the target or look for a descendant of the target. See below for additional details. stopEvent Boolean: True to stop the event. That is stop propagation, and prevent the default action. preventDefault Boolean: True to prevent the default action stopPropagation Boolean: True to prevent event propagation normalized Boolean: False to pass a browser event to the handler function instead of an Ext.EventObject target Ext.dom.Element: Only call the handler if the event was fired on the target Element, not if the event was bubbled up from a child node. delay Number: The number of milliseconds to delay the invocation of the handler after the event fires. single Boolean: True to add a handler to handle just the next firing of the event, and then remove itself. buffer Number: Causes the handler to be scheduled to run in an Ext.util.DelayedTask delayed by the specified number of milliseconds. If the event fires again within that time, the original handler is not invoked, but the new handler is scheduled in its place. Combining Options  Using the options argument, it is possible to combine different types of listeners:  A delayed, one-time listener that auto stops the event and adds a custom argument (forumId) to the options object. The options object is available as the third parameter in the handler function.  Code:  el.on('click', this.onClick, this, {  single: true,  delay: 100,  stopEvent : true,  forumId: 4 }); Attaching multiple handlers in 1 call  The method also allows for a single argument to be passed which is a config object containing properties which specify multiple handlers.  Code:  el.on({  'click' : {  fn: this.onClick,  scope: this,  delay: 100  },  'mouseover' : {  fn: this.onMouseOver,  scope: this  },  'mouseout' : {  fn: this.onMouseOut,  scope: this  } }); Or a shorthand syntax:  Code:  el.on({  'click' : this.onClick,  'mouseover' : this.onMouseOver,  'mouseout' : this.onMouseOut,  scope: this }); delegate  This is a configuration option that you can pass along when registering a handler for an event to assist with event delegation. Event delegation is a technique that is used to reduce memory consumption and prevent exposure to memory-leaks. By registering an event for a container element as opposed to each element within a container. By setting this configuration option to a simple selector, the target element will be filtered to look for a descendant of the target. For example:  // using this markup: &lt;div id='elId'&gt;  &lt;p id='p1'&gt;paragraph one&lt;/p&gt;  &lt;p id='p2' class='clickable'&gt;paragraph two&lt;/p&gt;  &lt;p id='p3'&gt;paragraph three&lt;/p&gt; &lt;/div&gt; // utilize event delegation to registering just one handler on the container element: el = Ext.get('elId'); el.on(  'click',  function(e,t) {  // handle click  console.info(t.id); // 'p2'  },  this,  {  // filter the target element to be a descendant with the class 'clickable'  delegate: '.clickable'  } );
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Creates a pause before any subsequent queued effects begin
 * @param {number=} seconds Number The length of time to pause (in seconds)
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.dom.IElement.prototype.pause = function(seconds) {};

/**
 * [Method] Initializes positioning on this element
 * @param {string=} pos String Positioning to use "relative", "absolute" or "fixed"
 * @param {number=} zIndex Number The zIndex to apply
 * @param {number=} x Number Set the page X position
 * @param {number=} y Number Set the page Y position
 * @return {void}
 */
Ext.dom.IElement.prototype.position = function(pos, zIndex, x, y) {};

/**
 * [Method] Fades the element out while slowly expanding it in all directions
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.dom.IElement.prototype.puff = function(options) {};

/**
 * [Method] Recursively removes all previous added listeners from this element and its children
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.purgeAllListeners = function() {};

/**
 * [Method] Create an event handler on this element such that when the event fires and is handled by this element it will be rel
 * @param {string=} eventName String The type of event to relay
 * @param {?=} observable Object Any object that extends Ext.util.Observable that will provide the context for firing the relayed event
 * @return {void}
 */
Ext.dom.IElement.prototype.relayEvent = function(eventName, observable) {};

/**
 * [Method] Removes all previous added listeners from this element
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.removeAllListeners = function() {};

/**
 * [Method] Shorthand for un
 * @param {string=} eventName String The name of the event from which to remove the handler.
 * @param {?=} fn Function The handler function to remove. This must be a reference to the function passed into the on call.
 * @param {?=} scope Object If a scope (this reference) was specified when the listener was added, then this must refer to the same object.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Animates the transition of an element s dimensions from a starting height width to an ending height width
 * @param {number=} width Number The new width (pass undefined to keep the original width)
 * @param {number=} height Number The new height (pass undefined to keep the original height)
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.dom.IElement.prototype.scale = function(width, height, options) {};

/**
 * [Method] Scrolls this element the specified direction
 * @param {string=} direction String Possible values are:  "l" (or "left") "r" (or "right") "t" (or "top", or "up") "b" (or "bottom", or "down")
 * @param {number=} distance Number How far to scroll the element in pixels
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {boolean} Boolean Returns true if a scroll was triggered or false if the element was scrolled as far as it could go.
 */
Ext.dom.IElement.prototype.scroll = function(direction, distance, animate) {};

/**
 * [Method] Scrolls this element by the passed delta values optionally animating
 * @param {?=} deltaX Number/Number[]/Object Either the x delta, an Array specifying x and y deltas or an object with "x" and "y" properties.
 * @param {?=} deltaY Number/Boolean/Object Either the y delta, or an animate flag or config object.
 * @param {?=} animate Boolean/Object Animate flag/config object if the delta values were passed separately.
 * @return {!Ext.IElement} Ext.Element this
 */
Ext.dom.IElement.prototype.scrollBy = function(deltaX, deltaY, animate) {};

/**
 * [Method] Scrolls this element into view within the passed container
 * @param {?=} container String/HTMLElement/Ext.Element The container element to scroll. Should be a string (id), dom node, or Ext.Element.
 * @param {boolean=} hscroll Boolean False to disable horizontal scroll.
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element
 * @param {boolean=} highlight Boolean true to highlight the element when it is in view. animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.scrollIntoView = function(container, hscroll, animate, highlight) {};

/**
 * [Method] Scrolls this element the specified scroll point
 * @param {string=} side String Either "left" for scrollLeft values or "top" for scrollTop values.
 * @param {number=} value Number The new scroll value
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.IElement} Ext.Element this
 */
Ext.dom.IElement.prototype.scrollTo = function(side, value, animate) {};

/**
 * [Method] Enable text selection for this element normalized across browsers  Defined in override Ext dom Element_style
 * @return {!Ext.IElement} Ext.Element this
 */
Ext.dom.IElement.prototype.selectable = function() {};

/**
 * [Method] Sets the element s CSS bottom style
 * @param {?=} bottom Number/String Number of pixels or CSS string value to set as the bottom CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.setBottom = function(bottom) {};

/**
 * [Method] Sets the element s position and size in one shot
 * @param {number=} x Number X value for new position (coordinates are page-based)
 * @param {number=} y Number Y value for new position (coordinates are page-based)
 * @param {?=} width Number/String The new width. This may be one of:  A Number specifying the new width in this Element's defaultUnits (by default, pixels) A String used to set the CSS width style. Animation may not be used.
 * @param {?=} height Number/String The new height. This may be one of:  A Number specifying the new height in this Element's defaultUnits (by default, pixels) A String used to set the CSS height style. Animation may not be used.
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.setBounds = function(x, y, width, height, animate) {};

/**
 * [Method] Sets the CSS display property
 * @param {?=} value Boolean/String Boolean value to display the element using its default display, or a string to set the display directly.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.setDisplayed = function(value) {};

/**
 * [Method] Sets the element s left position directly using CSS style instead of setX
 * @param {?=} left Number/String Number of pixels or CSS string value to set as the left CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.setLeft = function(left) {};

/**
 * [Method] Sets the element s left and top positions directly using CSS style Defined in override Ext dom Element_position
 * @param {?=} left Number/String Number of pixels or CSS string value to set as the left CSS property value
 * @param {?=} top Number/String Number of pixels or CSS string value to set as the top CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.setLeftTop = function(left, top) {};

/**
 * [Method] Sets the position of the element in page coordinates
 * @param {number=} x Number X value for new position
 * @param {number=} y Number Y value for new position
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.setLocation = function(x, y, animate) {};

/**
 * [Method] Set the opacity of the element Defined in override Ext dom Element_style
 * @param {number=} opacity Number The new opacity. 0 = transparent, .5 = 50% visibile, 1 = fully visible, etc
 * @param {?=} animate Boolean/Object a standard Element animation config object or true for the default animation ({duration: 350, easing: 'easeIn'})
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.setOpacity = function(opacity, animate) {};

/**
 * [Method] Set positioning with an object returned by getPositioning
 * @param {?=} posCfg Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.setPositioning = function(posCfg) {};

/**
 * [Method] Sets the element s CSS right style
 * @param {?=} right Number/String Number of pixels or CSS string value to set as the right CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.setRight = function(right) {};

/**
 * [Method] Sets the left scroll position Defined in override Ext dom Element_scroll
 * @param {number=} left Number The left scroll position
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.setScrollLeft = function(left) {};

/**
 * [Method] Sets the top scroll position Defined in override Ext dom Element_scroll
 * @param {number=} top Number The top scroll position
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.setScrollTop = function(top) {};

/**
 * [Method] Sets the element s top position directly using CSS style instead of setY
 * @param {?=} top Number/String Number of pixels or CSS string value to set as the top CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.setTop = function(top) {};

/**
 * [Method] Sets the visibility of the element see details
 * @param {boolean=} visible Boolean Whether the element is visible
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.setVisible = function(visible, animate) {};

/**
 * [Method] Animates the transition of any combination of an element s dimensions xy position and or opacity
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.dom.IElement.prototype.shift = function(options) {};

/**
 * [Method] Show this element  Uses display mode to determine whether to use display or visibility
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.show = function(animate) {};

/**
 * [Method] Slides the element into view
 * @param {string=} anchor String One of the valid Ext.fx.Anim anchor positions (defaults to top: 't')
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.dom.IElement.prototype.slideIn = function(anchor, options) {};

/**
 * [Method] Slides the element out of view
 * @param {string=} anchor String One of the valid Ext.fx.Anim anchor positions (defaults to top: 't')
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.dom.IElement.prototype.slideOut = function(anchor, options) {};

/**
 * [Method] Stops the specified event s from bubbling and optionally prevents the default action
 * @param {?=} eventName String/String[] an event / array of events to stop from bubbling
 * @param {boolean=} preventDefault Boolean true to prevent the default action too
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.swallowEvent = function(eventName, preventDefault) {};

/**
 * [Method] Blinks the element as if it was clicked and then collapses on its center similar to switching off a television
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.dom.IElement.prototype.switchOff = function(options) {};

/**
 * [Method] Toggles the element s visibility or display depending on visibility mode
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.toggle = function(animate) {};

/**
 * [Method] Removes an event handler from this element
 * @param {string=} eventName String The name of the event from which to remove the handler.
 * @param {?=} fn Function The handler function to remove. This must be a reference to the function passed into the on call.
 * @param {?=} scope Object If a scope (this reference) was specified when the listener was added, then this must refer to the same object.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.un = function(eventName, fn, scope) {};

/**
 * [Method] Return clipping overflow to original clipping before clip was called Defined in override Ext dom Element_style
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.unclip = function() {};

/**
 * [Method] Hides a previously applied mask
 * @return {void}
 */
Ext.dom.IElement.prototype.unmask = function() {};

/**
 * [Method] Disables text selection for this element normalized across browsers  Defined in override Ext dom Element_style
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.unselectable = function() {};

/**
 * [Method] Updates the innerHTML of this element optionally searching for and processing scripts
 * @param {string=} html String The new HTML
 * @param {boolean=} loadScripts Boolean True to look for and process scripts (defaults to false)
 * @param {?=} callback Function For async script loading you can be notified when the update completes
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.IElement.prototype.update = function(html, loadScripts, callback) {};
/**
 * @constructor
 * @struct
 */
Ext.dom.Element = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.dom.Element.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.dom.Element.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.dom.Element.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.dom.Element.createAlias = function(alias, origin) {};

/**
 * [Method] Returns the top Element that is located at the passed coordinates Defined in override Ext dom AbstractElement_static
 * @param {number=} x Number The x coordinate
 * @param {number=} y Number The y coordinate
 * @return {string} String The found Element
 */
Ext.dom.Element.fromPoint = function(x, y) {};

/**
 * [Method] Retrieves Ext dom Element objects
 * @param {?=} el String/HTMLElement/Ext.Element The id of the node, a DOM Node or an existing Element.
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element object (or null if no matching element was found)
 */
Ext.dom.Element.get = function(el) {};

/**
 * [Method] Retrieves the document height Defined in override Ext dom AbstractElement_static
 * @return {number} Number documentHeight
 */
Ext.dom.Element.getDocumentHeight = function() {};

/**
 * [Method] Retrieves the document width Defined in override Ext dom AbstractElement_static
 * @return {number} Number documentWidth
 */
Ext.dom.Element.getDocumentWidth = function() {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.dom.Element.getName = function() {};

/**
 * [Method] Retrieves the current orientation of the window
 * @return {string} String Orientation of window: 'portrait' or 'landscape'
 */
Ext.dom.Element.getOrientation = function() {};

/**
 * [Method] Retrieves the viewport size of the window
 * @return {?} Object object containing width and height properties
 */
Ext.dom.Element.getViewSize = function() {};

/**
 * [Method] Retrieves the viewport height of the window
 * @return {number} Number viewportHeight
 */
Ext.dom.Element.getViewportHeight = function() {};

/**
 * [Method] Retrieves the viewport width of the window
 * @return {number} Number viewportWidth
 */
Ext.dom.Element.getViewportWidth = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.dom.Element.implement = function() {};

/**
 * [Method] Returns an array of unique class names based upon the input strings or string arrays
 * @param {?=} clsList1 Mixed A string of class names, or an array of class names.
 * @param {?=} clsList2 Mixed A string of class names, or an array of class names.
 * @return {!Array<?>} Array An array of strings representing remaining unique, merged class names. If class names were added to the first list, the changed property will be true.
 */
Ext.dom.Element.mergeClsList = function(clsList1, clsList2) {};

/**
 * [Method] Normalizes CSS property keys from dash delimited to camel case JavaScript Syntax
 * @param {string=} prop String The property to normalize
 * @return {string} String The normalized string
 */
Ext.dom.Element.normalize = function(prop) {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.dom.Element.override = function(members) {};

/**
 * [Method] Parses a number or string representing margin sizes into an object
 * @param {?=} box Number/String The encoded margins
 * @return {?} Object An object with margin sizes for top, right, bottom and left
 */
Ext.dom.Element.parseBox = function(box) {};

/**
 * [Method] Converts a CSS string into an object with a property for each style
 * @param {string=} styles String A CSS string
 * @return {?} Object styles
 */
Ext.dom.Element.parseStyles = function(styles) {};

/**
 * [Method] Returns an array of unique class names deom the first parameter with all class names from the second parameter removed
 * @param {?=} existingClsList Mixed A string of class names, or an array of class names.
 * @param {?=} removeClsList Mixed A string of class names, or an array of class names to remove from existingClsList.
 * @return {!Array<?>} Array An array of strings representing remaining class names. If class names were removed, the changed property will be true.
 */
Ext.dom.Element.removeCls = function(existingClsList, removeClsList) {};

/**
 * [Method] Selects elements based on the passed CSS selector to enable Element methods to be applied to many related elements in
 * @param {?=} selector String/HTMLElement[] The CSS selector or an array of elements
 * @param {boolean=} unique Boolean true to create a unique Ext.Element for each element (defaults to a shared flyweight object)
 * @param {?=} root HTMLElement/String The root element of the query or id of the root
 * @return {?} Ext.CompositeElementLite/Ext.CompositeElement
 */
Ext.dom.Element.select = function(selector, unique, root) {};

/**
 * [Method] Parses a number or string representing margin sizes into an object
 * @param {?=} box Number/String/Object The encoded margins, or an object with top, right, bottom, and left properties
 * @param {string=} units String The type of units to add
 * @return {string} String An string with unitized (px if units is not specified) metrics for top, right, bottom and left
 */
Ext.dom.Element.unitizeBox = function(box, units) {};
/**
 * @extends {Ext.dom.IAbstractElement}
 * @record
 * @struct
 */
Ext.IElement = function() {};
 /** @type {boolean} */
Ext.IElement.prototype.autoBoxAdjust;
 /** @type {string} */
Ext.IElement.prototype.originalDisplay;

/**
 * [Method] Sets up event handlers to add and remove a css class when the mouse is down and then up on this element a click effe
 * @param {string=} className String The class to add
 * @param {?=} testFn Function A test function to execute before adding the class. The passed parameter will be the Element instance. If this functions returns false, the class will not be added.
 * @param {?=} scope Object The scope to execute the testFn in.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.addClsOnClick = function(className, testFn, scope) {};

/**
 * [Method] Sets up event handlers to add and remove a css class when this element has the focus Defined in override Ext dom Ele
 * @param {string=} className String The class to add
 * @param {?=} testFn Function A test function to execute before adding the class. The passed parameter will be the Element instance. If this functions returns false, the class will not be added.
 * @param {?=} scope Object The scope to execute the testFn in.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.addClsOnFocus = function(className, testFn, scope) {};

/**
 * [Method] Sets up event handlers to add and remove a css class when the mouse is over this element Defined in override Ext dom
 * @param {string=} className String The class to add
 * @param {?=} testFn Function A test function to execute before adding the class. The passed parameter will be the Element instance. If this functions returns false, the class will not be added.
 * @param {?=} scope Object The scope to execute the testFn in.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.addClsOnOver = function(className, testFn, scope) {};

/**
 * [Method] Convenience method for constructing a KeyMap
 * @param {?=} key String/Number/Number[]/Object Either a string with the keys to listen for, the numeric key code, array of key codes or an object with the following options:
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope (this reference) in which the specified function is executed. Defaults to this Element.
 * @return {!Ext.util.IKeyMap} Ext.util.KeyMap The KeyMap created
 */
Ext.IElement.prototype.addKeyListener = function(key, fn, scope) {};

/**
 * [Method] Creates a KeyMap for this element
 * @param {?=} config Object The KeyMap config. See Ext.util.KeyMap for more details
 * @return {!Ext.util.IKeyMap} Ext.util.KeyMap The KeyMap created
 */
Ext.IElement.prototype.addKeyMap = function(config) {};

/**
 * [Method] Shorthand for on
 * @param {string=} eventName String The name of event to handle.
 * @param {?=} fn Function The handler function the event invokes. This function is passed the following parameters: evt : EventObject The EventObject describing the event. el : HtmlElement The DOM element which was the target of the event. Note that this may be filtered by using the delegate option. o : Object The options object from the call that setup the listener.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to this Element.
 * @param {?=} options Object An object containing handler configuration properties. This may contain any of the following properties: scope Object : The scope (this reference) in which the handler function is executed. If omitted, defaults to this Element. delegate String: A simple selector to filter the target or look for a descendant of the target. See below for additional details. stopEvent Boolean: True to stop the event. That is stop propagation, and prevent the default action. preventDefault Boolean: True to prevent the default action stopPropagation Boolean: True to prevent event propagation normalized Boolean: False to pass a browser event to the handler function instead of an Ext.EventObject target Ext.dom.Element: Only call the handler if the event was fired on the target Element, not if the event was bubbled up from a child node. delay Number: The number of milliseconds to delay the invocation of the handler after the event fires. single Boolean: True to add a handler to handle just the next firing of the event, and then remove itself. buffer Number: Causes the handler to be scheduled to run in an Ext.util.DelayedTask delayed by the specified number of milliseconds. If the event fires again within that time, the original handler is not invoked, but the new handler is scheduled in its place. Combining Options  Using the options argument, it is possible to combine different types of listeners:  A delayed, one-time listener that auto stops the event and adds a custom argument (forumId) to the options object. The options object is available as the third parameter in the handler function.  Code:  el.on('click', this.onClick, this, {  single: true,  delay: 100,  stopEvent : true,  forumId: 4 }); Attaching multiple handlers in 1 call  The method also allows for a single argument to be passed which is a config object containing properties which specify multiple handlers.  Code:  el.on({  'click' : {  fn: this.onClick,  scope: this,  delay: 100  },  'mouseover' : {  fn: this.onMouseOver,  scope: this  },  'mouseout' : {  fn: this.onMouseOut,  scope: this  } }); Or a shorthand syntax:  Code:  el.on({  'click' : this.onClick,  'mouseover' : this.onMouseOver,  'mouseout' : this.onMouseOut,  scope: this }); delegate  This is a configuration option that you can pass along when registering a handler for an event to assist with event delegation. Event delegation is a technique that is used to reduce memory consumption and prevent exposure to memory-leaks. By registering an event for a container element as opposed to each element within a container. By setting this configuration option to a simple selector, the target element will be filtered to look for a descendant of the target. For example:  // using this markup: &lt;div id='elId'&gt;  &lt;p id='p1'&gt;paragraph one&lt;/p&gt;  &lt;p id='p2' class='clickable'&gt;paragraph two&lt;/p&gt;  &lt;p id='p3'&gt;paragraph three&lt;/p&gt; &lt;/div&gt; // utilize event delegation to registering just one handler on the container element: el = Ext.get('elId'); el.on(  'click',  function(e,t) {  // handle click  console.info(t.id); // 'p2'  },  this,  {  // filter the target element to be a descendant with the class 'clickable'  delegate: '.clickable'  } );
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Performs custom animation on this Element
 * @param {?=} config Object Configuration for Ext.fx.Anim. Note that the to config is required.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.animate = function(config) {};

/**
 * [Method] Tries to blur the element
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.blur = function() {};

/**
 * [Method] Wraps the specified element with a special 9 element markup CSS block that renders by default as a gray container wit
 * @param {string=} clazz
 * @return {!Ext.dom.IElement} Ext.dom.Element The outermost wrapping element of the created box structure.
 */
Ext.IElement.prototype.boxWrap = function(clazz) {};

/**
 * [Method] When an element is moved around in the DOM or is hidden using display none it loses layout and therefore all scrol
 * @return {?} Function A function which will restore all descentant elements of this Element to their scroll positions recorded when this function was executed. Be aware that the returned function is a closure which has captured the scope of cacheScrollValues, so take care to derefence it as soon as not needed - if is it is a var it will drop out of scope, and the reference will be freed.
 */
Ext.IElement.prototype.cacheScrollValues = function() {};

/**
 * [Method] Centers the Element in either the viewport or another Element
 * @param {?=} centerIn String/HTMLElement/Ext.dom.Element element in which to center the element.
 * @return {void}
 */
Ext.IElement.prototype.center = function(centerIn) {};

/**
 * [Method] Removes Empty or whitespace filled text nodes
 * @param {boolean=} forceReclean Boolean By default the element keeps track if it has been cleaned already so you can call this over and over. However, if you update the element and need to force a reclean, you can pass true.
 * @return {void}
 */
Ext.IElement.prototype.clean = function(forceReclean) {};

/**
 * [Method] Alias for removeAllListeners
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.clearListeners = function() {};

/**
 * [Method] Clears any opacity settings from this element
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.clearOpacity = function() {};

/**
 * [Method] Clears positioning back to the default when the document was loaded
 * @param {string=} value String The value to use for the left, right, top, bottom. You could use 'auto'.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.clearPositioning = function(value) {};

/**
 * [Method] Store the current overflow setting and clip overflow on the element  use unclip to remove Defined in override Ext d
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.clip = function() {};

/**
 * [Method] Creates a proxy element of this element
 * @param {?=} config String/Object The class name of the proxy element or a DomHelper config object
 * @param {?=} renderTo String/HTMLElement The element or element id to render the proxy to. Defaults to: document.body.
 * @param {boolean=} matchBox Boolean True to align and size the proxy to this element now.
 * @return {!Ext.dom.IElement} Ext.dom.Element The new proxy element
 */
Ext.IElement.prototype.createProxy = function(config, renderTo, matchBox) {};

/**
 * [Method] Creates an iframe shim for this element to keep selects and other windowed objects from showing through
 * @return {!Ext.dom.IElement} Ext.dom.Element The new shim element
 */
Ext.IElement.prototype.createShim = function() {};

/**
 * [Method] Convenience method for setVisibilityMode Element DISPLAY
 * @param {string=} display String What to set display to when visible
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.enableDisplayMode = function(display) {};

/**
 * [Method] Fade an element in from transparent to opaque
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.IElement.prototype.fadeIn = function(options) {};

/**
 * [Method] Fade an element out from opaque to transparent
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.IElement.prototype.fadeOut = function(options) {};

/**
 * [Method] Tries to focus the element
 * @param {number=} defer Number Milliseconds to defer the focus
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.focus = function(defer) {};

/**
 * [Method] Alias for isFocusable
 * @return {boolean} Boolean True if the element is focusable
 */
Ext.IElement.prototype.focusable = function() {};

/**
 * [Method] Shows a ripple of exploding attenuating borders to draw attention to an Element
 * @param {string=} color String The hex color value for the border.
 * @param {number=} count Number The number of ripples to display.
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.IElement.prototype.frame = function(color, count, options) {};

/**
 * [Method] Returns the value of a namespaced attribute from the element s underlying DOM node
 * @param {string=} namespace String The namespace in which to look for the attribute
 * @param {string=} name String The attribute name
 * @return {string} String The attribute value
 */
Ext.IElement.prototype.getAttributeNS = function(namespace, name) {};

/**
 * [Method] Gets the bottom Y coordinate of the element element Y position  element height  Defined in override Ext dom Elemen
 * @param {boolean=} local Boolean True to get the local css position instead of page coordinate
 * @return {number} Number
 */
Ext.IElement.prototype.getBottom = function(local) {};

/**
 * [Method] Calculates the x y to center this element on the screen Defined in override Ext dom Element_position
 * @return {!Array<number>} Number[] The x, y values [x, y]
 */
Ext.IElement.prototype.getCenterXY = function() {};

/**
 * [Method] Return the CSS color for the specified CSS attribute
 * @param {string=} attr String The css attribute
 * @param {string=} defaultValue String The default value to use when a valid color isn't found
 * @param {string=} prefix String defaults to #. Use an empty string when working with color anims.
 * @return {void}
 */
Ext.IElement.prototype.getColor = function(attr, defaultValue, prefix) {};

/**
 * [Method] Returns either the offsetHeight or the height of this element based on CSS height adjusted by padding or borders when
 * @return {number} Number
 */
Ext.IElement.prototype.getComputedHeight = function() {};

/**
 * [Method] Returns either the offsetWidth or the width of this element based on CSS width adjusted by padding or borders when ne
 * @return {number} Number
 */
Ext.IElement.prototype.getComputedWidth = function() {};

/**
 * [Method] Returns the sum width of the padding and borders for the passed sides
 * @param {string=} sides String
 * @return {number} Number
 */
Ext.IElement.prototype.getFrameWidth = function(sides) {};

/**
 * [Method] Gets the left X coordinate Defined in override Ext dom Element_position
 * @param {boolean=} local Boolean True to get the local css position instead of page coordinate
 * @return {number} Number
 */
Ext.IElement.prototype.getLeft = function(local) {};

/**
 * [Method] Gets this element s ElementLoader
 * @return {!Ext.IElementLoader} Ext.ElementLoader The loader
 */
Ext.IElement.prototype.getLoader = function() {};

/**
 * [Method] Gets the local CSS X position for the element Defined in override Ext dom Element_position
 * @return {number} Number
 */
Ext.IElement.prototype.getLocalX = function() {};

/**
 * [Method] Gets the local CSS X and Y position for the element Defined in override Ext dom Element_position
 * @return {!Array<?>} Array [x, y]
 */
Ext.IElement.prototype.getLocalXY = function() {};

/**
 * [Method] Gets the local CSS Y position for the element Defined in override Ext dom Element_position
 * @return {number} Number
 */
Ext.IElement.prototype.getLocalY = function() {};

/**
 * [Method] Returns an object defining the area of this Element which can be passed to Ext util Positionable setBox to set anothe
 * @param {boolean=} asRegion Boolean If true an Ext.util.Region will be returned
 * @return {?} Object/Ext.util.Region box An object in the following format: {  left: &lt;Element's X position&gt;,  top: &lt;Element's Y position&gt;,  width: &lt;Element's width&gt;,  height: &lt;Element's height&gt;,  bottom: &lt;Element's lower bound&gt;,  right: &lt;Element's rightmost bound&gt; }  The returned object may also be addressed as an Array where index 0 contains the X position and index 1 contains the Y position. So the result may also be used for setXY
 */
Ext.IElement.prototype.getPageBox = function(asRegion) {};

/**
 * [Method] Gets an object with all CSS positioning properties
 * @param {boolean=} autoPx Boolean true to return pixel values for "auto" styles.
 * @return {?} Object
 */
Ext.IElement.prototype.getPositioning = function(autoPx) {};

/**
 * [Method] Gets the right X coordinate of the element element X position  element width  Defined in override Ext dom Element_
 * @param {boolean=} local Boolean True to get the local css position instead of page coordinates
 * @return {number} Number
 */
Ext.IElement.prototype.getRight = function(local) {};

/**
 * [Method] Returns the current scroll position of the element
 * @return {?} Object An object containing the scroll position in the format {left: (scrollLeft), top: (scrollTop)}
 */
Ext.IElement.prototype.getScroll = function() {};

/**
 * [Method] Gets the left scroll position Defined in override Ext dom Element_scroll
 * @return {number} Number The left scroll position
 */
Ext.IElement.prototype.getScrollLeft = function() {};

/**
 * [Method] Gets the top scroll position Defined in override Ext dom Element_scroll
 * @return {number} Number The top scroll position
 */
Ext.IElement.prototype.getScrollTop = function() {};

/**
 * [Method] Returns the dimensions of the element available to lay content out in
 * @return {?} Object Object describing width and height.
 */
Ext.IElement.prototype.getStyleSize = function() {};

/**
 * [Method] Returns the width in pixels of the passed text or the width of the text in this Element
 * @param {string=} text String The text to measure. Defaults to the innerHTML of the element.
 * @param {number=} min Number The minumum value to return.
 * @param {number=} max Number The maximum value to return.
 * @return {number} Number The text width in pixels.
 */
Ext.IElement.prototype.getTextWidth = function(text, min, max) {};

/**
 * [Method] Gets the top Y coordinate Defined in override Ext dom Element_position
 * @param {boolean=} local Boolean True to get the local css position instead of page coordinates
 * @return {number} Number
 */
Ext.IElement.prototype.getTop = function(local) {};

/**
 * [Method] Gets element X position in page coordinates Defined in override Ext dom Element_position
 * @return {number} Number
 */
Ext.IElement.prototype.getX = function() {};

/**
 * [Method] Gets element X and Y positions in page coordinates Defined in override Ext dom Element_position
 * @return {!Array<?>} Array [x, y]
 */
Ext.IElement.prototype.getXY = function() {};

/**
 * [Method] Gets element Y position in page coordinates Defined in override Ext dom Element_position
 * @return {number} Number
 */
Ext.IElement.prototype.getY = function() {};

/**
 * [Method] Slides the element while fading it out of view
 * @param {string=} anchor String One of the valid Ext.fx.Anim anchor positions (defaults to bottom: 'b')
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.IElement.prototype.ghost = function(anchor, options) {};

/**
 * [Method] Hide this element  Uses display mode to determine whether to use display or visibility
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.hide = function(animate) {};

/**
 * [Method] Highlights the Element by setting a color applies to the background color by default but can be changed using the
 * @param {string=} color String The highlight color. Should be a 6 char hex color without the leading # (defaults to yellow: 'ffff9c')
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.IElement.prototype.highlight = function(color, options) {};

/**
 * [Method] Sets up event handlers to call the passed functions when the mouse is moved into and out of the Element
 * @param {?=} overFn Function The function to call when the mouse enters the Element.
 * @param {?=} outFn Function The function to call when the mouse leaves the Element.
 * @param {?=} scope Object The scope (this reference) in which the functions are executed. Defaults to the Element's DOM element.
 * @param {?=} options Object Options for the listener. See the options parameter.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.hover = function(overFn, outFn, scope, options) {};

/**
 * [Method] Initializes a Ext dd DD drag drop object for this element
 * @param {string=} group String The group the DD object is member of
 * @param {?=} config Object The DD config object
 * @param {?=} overrides Object An object containing methods to override/implement on the DD object
 * @return {!Ext.dd.IDD} Ext.dd.DD The DD object
 */
Ext.IElement.prototype.initDD = function(group, config, overrides) {};

/**
 * [Method] Initializes a Ext dd DDProxy object for this element
 * @param {string=} group String The group the DDProxy object is member of
 * @param {?=} config Object The DDProxy config object
 * @param {?=} overrides Object An object containing methods to override/implement on the DDProxy object
 * @return {!Ext.dd.IDDProxy} Ext.dd.DDProxy The DDProxy object
 */
Ext.IElement.prototype.initDDProxy = function(group, config, overrides) {};

/**
 * [Method] Initializes a Ext dd DDTarget object for this element
 * @param {string=} group String The group the DDTarget object is member of
 * @param {?=} config Object The DDTarget config object
 * @param {?=} overrides Object An object containing methods to override/implement on the DDTarget object
 * @return {!Ext.dd.IDDTarget} Ext.dd.DDTarget The DDTarget object
 */
Ext.IElement.prototype.initDDTarget = function(group, config, overrides) {};

/**
 * [Method] Tests various css rules browsers to determine if this element uses a border box
 * @return {boolean} Boolean
 */
Ext.IElement.prototype.isBorderBox = function() {};

/**
 * [Method] Returns true if display is not none
 * @return {boolean} Boolean
 */
Ext.IElement.prototype.isDisplayed = function() {};

/**
 * [Method] Checks whether this element can be focused
 * @param {?=} asFocusEl Object
 * @return {boolean} Boolean True if the element is focusable
 */
Ext.IElement.prototype.isFocusable = function(asFocusEl) {};

/**
 * [Method] Returns true if this element is masked
 * @return {boolean} Boolean
 */
Ext.IElement.prototype.isMasked = function() {};

/**
 * [Method] Returns true if this element is scrollable
 * @return {boolean} Boolean
 */
Ext.IElement.prototype.isScrollable = function() {};

/**
 * [Method] Checks whether the element is currently visible using both visibility and display properties
 * @param {boolean=} deep Boolean True to walk the dom and see if parent elements are hidden. If false, the function only checks the visibility of the element itself and it may return true even though a parent is not visible.
 * @return {boolean} Boolean true if the element is currently visible, else false
 */
Ext.IElement.prototype.isVisible = function(deep) {};

/**
 * [Method] Direct access to the Ext ElementLoader Ext ElementLoader load method
 * @param {?=} options Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.load = function(options) {};

/**
 * [Method] Puts a mask over this element to disable user interaction
 * @param {string=} msg String A message to display in the mask
 * @param {string=} msgCls String A css class to apply to the msg element
 * @return {!Ext.dom.IElement} Ext.dom.Element The mask element
 */
Ext.IElement.prototype.mask = function(msg, msgCls) {};

/**
 * [Method] Monitors this Element for the mouse leaving
 * @param {number=} delay Number The delay in milliseconds to wait for possible mouse re-entry before calling the handler function.
 * @param {?=} handler Function The function to call if the mouse remains outside of this Element for the specified time.
 * @param {?=} scope Object The scope (this reference) in which the handler function executes. Defaults to this Element.
 * @return {?} Object The listeners object which was added to this element so that monitoring can be stopped. Example usage: // Hide the menu if the mouse moves out for 250ms or more this.mouseLeaveMonitor = this.menuEl.monitorMouseLeave(250, this.hideMenu, this); ... // Remove mouseleave monitor on menu destroy this.menuEl.un(this.mouseLeaveMonitor);
 */
Ext.IElement.prototype.monitorMouseLeave = function(delay, handler, scope) {};

/**
 * [Method] Sets the position of the element in page coordinates
 * @param {number=} x Number X value for new position (coordinates are page-based)
 * @param {number=} y Number Y value for new position (coordinates are page-based)
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.moveTo = function(x, y, animate) {};

/**
 * [Method] Returns true if this element needs an explicit tabIndex to make it focusable
 * @return {void}
 */
Ext.IElement.prototype.needsTabIndex = function() {};

/**
 * [Method] Appends an event handler to this element
 * @param {string=} eventName String The name of event to handle.
 * @param {?=} fn Function The handler function the event invokes. This function is passed the following parameters: evt : EventObject The EventObject describing the event. el : HtmlElement The DOM element which was the target of the event. Note that this may be filtered by using the delegate option. o : Object The options object from the call that setup the listener.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to this Element.
 * @param {?=} options Object An object containing handler configuration properties. This may contain any of the following properties: scope Object : The scope (this reference) in which the handler function is executed. If omitted, defaults to this Element. delegate String: A simple selector to filter the target or look for a descendant of the target. See below for additional details. stopEvent Boolean: True to stop the event. That is stop propagation, and prevent the default action. preventDefault Boolean: True to prevent the default action stopPropagation Boolean: True to prevent event propagation normalized Boolean: False to pass a browser event to the handler function instead of an Ext.EventObject target Ext.dom.Element: Only call the handler if the event was fired on the target Element, not if the event was bubbled up from a child node. delay Number: The number of milliseconds to delay the invocation of the handler after the event fires. single Boolean: True to add a handler to handle just the next firing of the event, and then remove itself. buffer Number: Causes the handler to be scheduled to run in an Ext.util.DelayedTask delayed by the specified number of milliseconds. If the event fires again within that time, the original handler is not invoked, but the new handler is scheduled in its place. Combining Options  Using the options argument, it is possible to combine different types of listeners:  A delayed, one-time listener that auto stops the event and adds a custom argument (forumId) to the options object. The options object is available as the third parameter in the handler function.  Code:  el.on('click', this.onClick, this, {  single: true,  delay: 100,  stopEvent : true,  forumId: 4 }); Attaching multiple handlers in 1 call  The method also allows for a single argument to be passed which is a config object containing properties which specify multiple handlers.  Code:  el.on({  'click' : {  fn: this.onClick,  scope: this,  delay: 100  },  'mouseover' : {  fn: this.onMouseOver,  scope: this  },  'mouseout' : {  fn: this.onMouseOut,  scope: this  } }); Or a shorthand syntax:  Code:  el.on({  'click' : this.onClick,  'mouseover' : this.onMouseOver,  'mouseout' : this.onMouseOut,  scope: this }); delegate  This is a configuration option that you can pass along when registering a handler for an event to assist with event delegation. Event delegation is a technique that is used to reduce memory consumption and prevent exposure to memory-leaks. By registering an event for a container element as opposed to each element within a container. By setting this configuration option to a simple selector, the target element will be filtered to look for a descendant of the target. For example:  // using this markup: &lt;div id='elId'&gt;  &lt;p id='p1'&gt;paragraph one&lt;/p&gt;  &lt;p id='p2' class='clickable'&gt;paragraph two&lt;/p&gt;  &lt;p id='p3'&gt;paragraph three&lt;/p&gt; &lt;/div&gt; // utilize event delegation to registering just one handler on the container element: el = Ext.get('elId'); el.on(  'click',  function(e,t) {  // handle click  console.info(t.id); // 'p2'  },  this,  {  // filter the target element to be a descendant with the class 'clickable'  delegate: '.clickable'  } );
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Creates a pause before any subsequent queued effects begin
 * @param {number=} seconds Number The length of time to pause (in seconds)
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.IElement.prototype.pause = function(seconds) {};

/**
 * [Method] Initializes positioning on this element
 * @param {string=} pos String Positioning to use "relative", "absolute" or "fixed"
 * @param {number=} zIndex Number The zIndex to apply
 * @param {number=} x Number Set the page X position
 * @param {number=} y Number Set the page Y position
 * @return {void}
 */
Ext.IElement.prototype.position = function(pos, zIndex, x, y) {};

/**
 * [Method] Fades the element out while slowly expanding it in all directions
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.IElement.prototype.puff = function(options) {};

/**
 * [Method] Recursively removes all previous added listeners from this element and its children
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.purgeAllListeners = function() {};

/**
 * [Method] Create an event handler on this element such that when the event fires and is handled by this element it will be rel
 * @param {string=} eventName String The type of event to relay
 * @param {?=} observable Object Any object that extends Ext.util.Observable that will provide the context for firing the relayed event
 * @return {void}
 */
Ext.IElement.prototype.relayEvent = function(eventName, observable) {};

/**
 * [Method] Removes all previous added listeners from this element
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.removeAllListeners = function() {};

/**
 * [Method] Shorthand for un
 * @param {string=} eventName String The name of the event from which to remove the handler.
 * @param {?=} fn Function The handler function to remove. This must be a reference to the function passed into the on call.
 * @param {?=} scope Object If a scope (this reference) was specified when the listener was added, then this must refer to the same object.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Animates the transition of an element s dimensions from a starting height width to an ending height width
 * @param {number=} width Number The new width (pass undefined to keep the original width)
 * @param {number=} height Number The new height (pass undefined to keep the original height)
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.IElement.prototype.scale = function(width, height, options) {};

/**
 * [Method] Scrolls this element the specified direction
 * @param {string=} direction String Possible values are:  "l" (or "left") "r" (or "right") "t" (or "top", or "up") "b" (or "bottom", or "down")
 * @param {number=} distance Number How far to scroll the element in pixels
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {boolean} Boolean Returns true if a scroll was triggered or false if the element was scrolled as far as it could go.
 */
Ext.IElement.prototype.scroll = function(direction, distance, animate) {};

/**
 * [Method] Scrolls this element by the passed delta values optionally animating
 * @param {?=} deltaX Number/Number[]/Object Either the x delta, an Array specifying x and y deltas or an object with "x" and "y" properties.
 * @param {?=} deltaY Number/Boolean/Object Either the y delta, or an animate flag or config object.
 * @param {?=} animate Boolean/Object Animate flag/config object if the delta values were passed separately.
 * @return {!Ext.IElement} Ext.Element this
 */
Ext.IElement.prototype.scrollBy = function(deltaX, deltaY, animate) {};

/**
 * [Method] Scrolls this element into view within the passed container
 * @param {?=} container String/HTMLElement/Ext.Element The container element to scroll. Should be a string (id), dom node, or Ext.Element.
 * @param {boolean=} hscroll Boolean False to disable horizontal scroll.
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element
 * @param {boolean=} highlight Boolean true to highlight the element when it is in view. animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.scrollIntoView = function(container, hscroll, animate, highlight) {};

/**
 * [Method] Scrolls this element the specified scroll point
 * @param {string=} side String Either "left" for scrollLeft values or "top" for scrollTop values.
 * @param {number=} value Number The new scroll value
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.IElement} Ext.Element this
 */
Ext.IElement.prototype.scrollTo = function(side, value, animate) {};

/**
 * [Method] Enable text selection for this element normalized across browsers  Defined in override Ext dom Element_style
 * @return {!Ext.IElement} Ext.Element this
 */
Ext.IElement.prototype.selectable = function() {};

/**
 * [Method] Sets the element s CSS bottom style
 * @param {?=} bottom Number/String Number of pixels or CSS string value to set as the bottom CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.setBottom = function(bottom) {};

/**
 * [Method] Sets the element s position and size in one shot
 * @param {number=} x Number X value for new position (coordinates are page-based)
 * @param {number=} y Number Y value for new position (coordinates are page-based)
 * @param {?=} width Number/String The new width. This may be one of:  A Number specifying the new width in this Element's defaultUnits (by default, pixels) A String used to set the CSS width style. Animation may not be used.
 * @param {?=} height Number/String The new height. This may be one of:  A Number specifying the new height in this Element's defaultUnits (by default, pixels) A String used to set the CSS height style. Animation may not be used.
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.setBounds = function(x, y, width, height, animate) {};

/**
 * [Method] Sets the CSS display property
 * @param {?=} value Boolean/String Boolean value to display the element using its default display, or a string to set the display directly.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.setDisplayed = function(value) {};

/**
 * [Method] Sets the element s left position directly using CSS style instead of setX
 * @param {?=} left Number/String Number of pixels or CSS string value to set as the left CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.setLeft = function(left) {};

/**
 * [Method] Sets the element s left and top positions directly using CSS style Defined in override Ext dom Element_position
 * @param {?=} left Number/String Number of pixels or CSS string value to set as the left CSS property value
 * @param {?=} top Number/String Number of pixels or CSS string value to set as the top CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.setLeftTop = function(left, top) {};

/**
 * [Method] Sets the position of the element in page coordinates
 * @param {number=} x Number X value for new position
 * @param {number=} y Number Y value for new position
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.setLocation = function(x, y, animate) {};

/**
 * [Method] Set the opacity of the element Defined in override Ext dom Element_style
 * @param {number=} opacity Number The new opacity. 0 = transparent, .5 = 50% visibile, 1 = fully visible, etc
 * @param {?=} animate Boolean/Object a standard Element animation config object or true for the default animation ({duration: 350, easing: 'easeIn'})
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.setOpacity = function(opacity, animate) {};

/**
 * [Method] Set positioning with an object returned by getPositioning
 * @param {?=} posCfg Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.setPositioning = function(posCfg) {};

/**
 * [Method] Sets the element s CSS right style
 * @param {?=} right Number/String Number of pixels or CSS string value to set as the right CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.setRight = function(right) {};

/**
 * [Method] Sets the left scroll position Defined in override Ext dom Element_scroll
 * @param {number=} left Number The left scroll position
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.setScrollLeft = function(left) {};

/**
 * [Method] Sets the top scroll position Defined in override Ext dom Element_scroll
 * @param {number=} top Number The top scroll position
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.setScrollTop = function(top) {};

/**
 * [Method] Sets the element s top position directly using CSS style instead of setY
 * @param {?=} top Number/String Number of pixels or CSS string value to set as the top CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.setTop = function(top) {};

/**
 * [Method] Sets the visibility of the element see details
 * @param {boolean=} visible Boolean Whether the element is visible
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.setVisible = function(visible, animate) {};

/**
 * [Method] Animates the transition of any combination of an element s dimensions xy position and or opacity
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.IElement.prototype.shift = function(options) {};

/**
 * [Method] Show this element  Uses display mode to determine whether to use display or visibility
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.show = function(animate) {};

/**
 * [Method] Slides the element into view
 * @param {string=} anchor String One of the valid Ext.fx.Anim anchor positions (defaults to top: 't')
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.IElement.prototype.slideIn = function(anchor, options) {};

/**
 * [Method] Slides the element out of view
 * @param {string=} anchor String One of the valid Ext.fx.Anim anchor positions (defaults to top: 't')
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.IElement.prototype.slideOut = function(anchor, options) {};

/**
 * [Method] Stops the specified event s from bubbling and optionally prevents the default action
 * @param {?=} eventName String/String[] an event / array of events to stop from bubbling
 * @param {boolean=} preventDefault Boolean true to prevent the default action too
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.swallowEvent = function(eventName, preventDefault) {};

/**
 * [Method] Blinks the element as if it was clicked and then collapses on its center similar to switching off a television
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.IElement.prototype.switchOff = function(options) {};

/**
 * [Method] Toggles the element s visibility or display depending on visibility mode
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.toggle = function(animate) {};

/**
 * [Method] Removes an event handler from this element
 * @param {string=} eventName String The name of the event from which to remove the handler.
 * @param {?=} fn Function The handler function to remove. This must be a reference to the function passed into the on call.
 * @param {?=} scope Object If a scope (this reference) was specified when the listener was added, then this must refer to the same object.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.un = function(eventName, fn, scope) {};

/**
 * [Method] Return clipping overflow to original clipping before clip was called Defined in override Ext dom Element_style
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.unclip = function() {};

/**
 * [Method] Hides a previously applied mask
 * @return {void}
 */
Ext.IElement.prototype.unmask = function() {};

/**
 * [Method] Disables text selection for this element normalized across browsers  Defined in override Ext dom Element_style
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.unselectable = function() {};

/**
 * [Method] Updates the innerHTML of this element optionally searching for and processing scripts
 * @param {string=} html String The new HTML
 * @param {boolean=} loadScripts Boolean True to look for and process scripts (defaults to false)
 * @param {?=} callback Function For async script loading you can be notified when the update completes
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.IElement.prototype.update = function(html, loadScripts, callback) {};
/**
 * @constructor
 * @struct
 */
Ext.Element = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.Element.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.Element.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.Element.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.Element.createAlias = function(alias, origin) {};

/**
 * [Method] Returns the top Element that is located at the passed coordinates Defined in override Ext dom AbstractElement_static
 * @param {number=} x Number The x coordinate
 * @param {number=} y Number The y coordinate
 * @return {string} String The found Element
 */
Ext.Element.fromPoint = function(x, y) {};

/**
 * [Method] Retrieves Ext dom Element objects
 * @param {?=} el String/HTMLElement/Ext.Element The id of the node, a DOM Node or an existing Element.
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element object (or null if no matching element was found)
 */
Ext.Element.get = function(el) {};

/**
 * [Method] Retrieves the document height Defined in override Ext dom AbstractElement_static
 * @return {number} Number documentHeight
 */
Ext.Element.getDocumentHeight = function() {};

/**
 * [Method] Retrieves the document width Defined in override Ext dom AbstractElement_static
 * @return {number} Number documentWidth
 */
Ext.Element.getDocumentWidth = function() {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.Element.getName = function() {};

/**
 * [Method] Retrieves the current orientation of the window
 * @return {string} String Orientation of window: 'portrait' or 'landscape'
 */
Ext.Element.getOrientation = function() {};

/**
 * [Method] Retrieves the viewport size of the window
 * @return {?} Object object containing width and height properties
 */
Ext.Element.getViewSize = function() {};

/**
 * [Method] Retrieves the viewport height of the window
 * @return {number} Number viewportHeight
 */
Ext.Element.getViewportHeight = function() {};

/**
 * [Method] Retrieves the viewport width of the window
 * @return {number} Number viewportWidth
 */
Ext.Element.getViewportWidth = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.Element.implement = function() {};

/**
 * [Method] Returns an array of unique class names based upon the input strings or string arrays
 * @param {?=} clsList1 Mixed A string of class names, or an array of class names.
 * @param {?=} clsList2 Mixed A string of class names, or an array of class names.
 * @return {!Array<?>} Array An array of strings representing remaining unique, merged class names. If class names were added to the first list, the changed property will be true.
 */
Ext.Element.mergeClsList = function(clsList1, clsList2) {};

/**
 * [Method] Normalizes CSS property keys from dash delimited to camel case JavaScript Syntax
 * @param {string=} prop String The property to normalize
 * @return {string} String The normalized string
 */
Ext.Element.normalize = function(prop) {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.Element.override = function(members) {};

/**
 * [Method] Parses a number or string representing margin sizes into an object
 * @param {?=} box Number/String The encoded margins
 * @return {?} Object An object with margin sizes for top, right, bottom and left
 */
Ext.Element.parseBox = function(box) {};

/**
 * [Method] Converts a CSS string into an object with a property for each style
 * @param {string=} styles String A CSS string
 * @return {?} Object styles
 */
Ext.Element.parseStyles = function(styles) {};

/**
 * [Method] Returns an array of unique class names deom the first parameter with all class names from the second parameter removed
 * @param {?=} existingClsList Mixed A string of class names, or an array of class names.
 * @param {?=} removeClsList Mixed A string of class names, or an array of class names to remove from existingClsList.
 * @return {!Array<?>} Array An array of strings representing remaining class names. If class names were removed, the changed property will be true.
 */
Ext.Element.removeCls = function(existingClsList, removeClsList) {};

/**
 * [Method] Selects elements based on the passed CSS selector to enable Element methods to be applied to many related elements in
 * @param {?=} selector String/HTMLElement[] The CSS selector or an array of elements
 * @param {boolean=} unique Boolean true to create a unique Ext.Element for each element (defaults to a shared flyweight object)
 * @param {?=} root HTMLElement/String The root element of the query or id of the root
 * @return {?} Ext.CompositeElementLite/Ext.CompositeElement
 */
Ext.Element.select = function(selector, unique, root) {};

/**
 * [Method] Parses a number or string representing margin sizes into an object
 * @param {?=} box Number/String/Object The encoded margins, or an object with top, right, bottom, and left properties
 * @param {string=} units String The type of units to add
 * @return {string} String An string with unitized (px if units is not specified) metrics for top, right, bottom and left
 */
Ext.Element.unitizeBox = function(box, units) {};
/** @const */
Ext.core = {};
/**
 * @extends {Ext.dom.IAbstractElement}
 * @record
 * @struct
 */
Ext.core.IElement = function() {};
 /** @type {boolean} */
Ext.core.IElement.prototype.autoBoxAdjust;
 /** @type {string} */
Ext.core.IElement.prototype.originalDisplay;

/**
 * [Method] Sets up event handlers to add and remove a css class when the mouse is down and then up on this element a click effe
 * @param {string=} className String The class to add
 * @param {?=} testFn Function A test function to execute before adding the class. The passed parameter will be the Element instance. If this functions returns false, the class will not be added.
 * @param {?=} scope Object The scope to execute the testFn in.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.addClsOnClick = function(className, testFn, scope) {};

/**
 * [Method] Sets up event handlers to add and remove a css class when this element has the focus Defined in override Ext dom Ele
 * @param {string=} className String The class to add
 * @param {?=} testFn Function A test function to execute before adding the class. The passed parameter will be the Element instance. If this functions returns false, the class will not be added.
 * @param {?=} scope Object The scope to execute the testFn in.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.addClsOnFocus = function(className, testFn, scope) {};

/**
 * [Method] Sets up event handlers to add and remove a css class when the mouse is over this element Defined in override Ext dom
 * @param {string=} className String The class to add
 * @param {?=} testFn Function A test function to execute before adding the class. The passed parameter will be the Element instance. If this functions returns false, the class will not be added.
 * @param {?=} scope Object The scope to execute the testFn in.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.addClsOnOver = function(className, testFn, scope) {};

/**
 * [Method] Convenience method for constructing a KeyMap
 * @param {?=} key String/Number/Number[]/Object Either a string with the keys to listen for, the numeric key code, array of key codes or an object with the following options:
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope (this reference) in which the specified function is executed. Defaults to this Element.
 * @return {!Ext.util.IKeyMap} Ext.util.KeyMap The KeyMap created
 */
Ext.core.IElement.prototype.addKeyListener = function(key, fn, scope) {};

/**
 * [Method] Creates a KeyMap for this element
 * @param {?=} config Object The KeyMap config. See Ext.util.KeyMap for more details
 * @return {!Ext.util.IKeyMap} Ext.util.KeyMap The KeyMap created
 */
Ext.core.IElement.prototype.addKeyMap = function(config) {};

/**
 * [Method] Shorthand for on
 * @param {string=} eventName String The name of event to handle.
 * @param {?=} fn Function The handler function the event invokes. This function is passed the following parameters: evt : EventObject The EventObject describing the event. el : HtmlElement The DOM element which was the target of the event. Note that this may be filtered by using the delegate option. o : Object The options object from the call that setup the listener.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to this Element.
 * @param {?=} options Object An object containing handler configuration properties. This may contain any of the following properties: scope Object : The scope (this reference) in which the handler function is executed. If omitted, defaults to this Element. delegate String: A simple selector to filter the target or look for a descendant of the target. See below for additional details. stopEvent Boolean: True to stop the event. That is stop propagation, and prevent the default action. preventDefault Boolean: True to prevent the default action stopPropagation Boolean: True to prevent event propagation normalized Boolean: False to pass a browser event to the handler function instead of an Ext.EventObject target Ext.dom.Element: Only call the handler if the event was fired on the target Element, not if the event was bubbled up from a child node. delay Number: The number of milliseconds to delay the invocation of the handler after the event fires. single Boolean: True to add a handler to handle just the next firing of the event, and then remove itself. buffer Number: Causes the handler to be scheduled to run in an Ext.util.DelayedTask delayed by the specified number of milliseconds. If the event fires again within that time, the original handler is not invoked, but the new handler is scheduled in its place. Combining Options  Using the options argument, it is possible to combine different types of listeners:  A delayed, one-time listener that auto stops the event and adds a custom argument (forumId) to the options object. The options object is available as the third parameter in the handler function.  Code:  el.on('click', this.onClick, this, {  single: true,  delay: 100,  stopEvent : true,  forumId: 4 }); Attaching multiple handlers in 1 call  The method also allows for a single argument to be passed which is a config object containing properties which specify multiple handlers.  Code:  el.on({  'click' : {  fn: this.onClick,  scope: this,  delay: 100  },  'mouseover' : {  fn: this.onMouseOver,  scope: this  },  'mouseout' : {  fn: this.onMouseOut,  scope: this  } }); Or a shorthand syntax:  Code:  el.on({  'click' : this.onClick,  'mouseover' : this.onMouseOver,  'mouseout' : this.onMouseOut,  scope: this }); delegate  This is a configuration option that you can pass along when registering a handler for an event to assist with event delegation. Event delegation is a technique that is used to reduce memory consumption and prevent exposure to memory-leaks. By registering an event for a container element as opposed to each element within a container. By setting this configuration option to a simple selector, the target element will be filtered to look for a descendant of the target. For example:  // using this markup: &lt;div id='elId'&gt;  &lt;p id='p1'&gt;paragraph one&lt;/p&gt;  &lt;p id='p2' class='clickable'&gt;paragraph two&lt;/p&gt;  &lt;p id='p3'&gt;paragraph three&lt;/p&gt; &lt;/div&gt; // utilize event delegation to registering just one handler on the container element: el = Ext.get('elId'); el.on(  'click',  function(e,t) {  // handle click  console.info(t.id); // 'p2'  },  this,  {  // filter the target element to be a descendant with the class 'clickable'  delegate: '.clickable'  } );
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Performs custom animation on this Element
 * @param {?=} config Object Configuration for Ext.fx.Anim. Note that the to config is required.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.animate = function(config) {};

/**
 * [Method] Tries to blur the element
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.blur = function() {};

/**
 * [Method] Wraps the specified element with a special 9 element markup CSS block that renders by default as a gray container wit
 * @param {string=} clazz
 * @return {!Ext.dom.IElement} Ext.dom.Element The outermost wrapping element of the created box structure.
 */
Ext.core.IElement.prototype.boxWrap = function(clazz) {};

/**
 * [Method] When an element is moved around in the DOM or is hidden using display none it loses layout and therefore all scrol
 * @return {?} Function A function which will restore all descentant elements of this Element to their scroll positions recorded when this function was executed. Be aware that the returned function is a closure which has captured the scope of cacheScrollValues, so take care to derefence it as soon as not needed - if is it is a var it will drop out of scope, and the reference will be freed.
 */
Ext.core.IElement.prototype.cacheScrollValues = function() {};

/**
 * [Method] Centers the Element in either the viewport or another Element
 * @param {?=} centerIn String/HTMLElement/Ext.dom.Element element in which to center the element.
 * @return {void}
 */
Ext.core.IElement.prototype.center = function(centerIn) {};

/**
 * [Method] Removes Empty or whitespace filled text nodes
 * @param {boolean=} forceReclean Boolean By default the element keeps track if it has been cleaned already so you can call this over and over. However, if you update the element and need to force a reclean, you can pass true.
 * @return {void}
 */
Ext.core.IElement.prototype.clean = function(forceReclean) {};

/**
 * [Method] Alias for removeAllListeners
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.clearListeners = function() {};

/**
 * [Method] Clears any opacity settings from this element
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.clearOpacity = function() {};

/**
 * [Method] Clears positioning back to the default when the document was loaded
 * @param {string=} value String The value to use for the left, right, top, bottom. You could use 'auto'.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.clearPositioning = function(value) {};

/**
 * [Method] Store the current overflow setting and clip overflow on the element  use unclip to remove Defined in override Ext d
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.clip = function() {};

/**
 * [Method] Creates a proxy element of this element
 * @param {?=} config String/Object The class name of the proxy element or a DomHelper config object
 * @param {?=} renderTo String/HTMLElement The element or element id to render the proxy to. Defaults to: document.body.
 * @param {boolean=} matchBox Boolean True to align and size the proxy to this element now.
 * @return {!Ext.dom.IElement} Ext.dom.Element The new proxy element
 */
Ext.core.IElement.prototype.createProxy = function(config, renderTo, matchBox) {};

/**
 * [Method] Creates an iframe shim for this element to keep selects and other windowed objects from showing through
 * @return {!Ext.dom.IElement} Ext.dom.Element The new shim element
 */
Ext.core.IElement.prototype.createShim = function() {};

/**
 * [Method] Convenience method for setVisibilityMode Element DISPLAY
 * @param {string=} display String What to set display to when visible
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.enableDisplayMode = function(display) {};

/**
 * [Method] Fade an element in from transparent to opaque
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.core.IElement.prototype.fadeIn = function(options) {};

/**
 * [Method] Fade an element out from opaque to transparent
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.core.IElement.prototype.fadeOut = function(options) {};

/**
 * [Method] Tries to focus the element
 * @param {number=} defer Number Milliseconds to defer the focus
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.focus = function(defer) {};

/**
 * [Method] Alias for isFocusable
 * @return {boolean} Boolean True if the element is focusable
 */
Ext.core.IElement.prototype.focusable = function() {};

/**
 * [Method] Shows a ripple of exploding attenuating borders to draw attention to an Element
 * @param {string=} color String The hex color value for the border.
 * @param {number=} count Number The number of ripples to display.
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.core.IElement.prototype.frame = function(color, count, options) {};

/**
 * [Method] Returns the value of a namespaced attribute from the element s underlying DOM node
 * @param {string=} namespace String The namespace in which to look for the attribute
 * @param {string=} name String The attribute name
 * @return {string} String The attribute value
 */
Ext.core.IElement.prototype.getAttributeNS = function(namespace, name) {};

/**
 * [Method] Gets the bottom Y coordinate of the element element Y position  element height  Defined in override Ext dom Elemen
 * @param {boolean=} local Boolean True to get the local css position instead of page coordinate
 * @return {number} Number
 */
Ext.core.IElement.prototype.getBottom = function(local) {};

/**
 * [Method] Calculates the x y to center this element on the screen Defined in override Ext dom Element_position
 * @return {!Array<number>} Number[] The x, y values [x, y]
 */
Ext.core.IElement.prototype.getCenterXY = function() {};

/**
 * [Method] Return the CSS color for the specified CSS attribute
 * @param {string=} attr String The css attribute
 * @param {string=} defaultValue String The default value to use when a valid color isn't found
 * @param {string=} prefix String defaults to #. Use an empty string when working with color anims.
 * @return {void}
 */
Ext.core.IElement.prototype.getColor = function(attr, defaultValue, prefix) {};

/**
 * [Method] Returns either the offsetHeight or the height of this element based on CSS height adjusted by padding or borders when
 * @return {number} Number
 */
Ext.core.IElement.prototype.getComputedHeight = function() {};

/**
 * [Method] Returns either the offsetWidth or the width of this element based on CSS width adjusted by padding or borders when ne
 * @return {number} Number
 */
Ext.core.IElement.prototype.getComputedWidth = function() {};

/**
 * [Method] Returns the sum width of the padding and borders for the passed sides
 * @param {string=} sides String
 * @return {number} Number
 */
Ext.core.IElement.prototype.getFrameWidth = function(sides) {};

/**
 * [Method] Gets the left X coordinate Defined in override Ext dom Element_position
 * @param {boolean=} local Boolean True to get the local css position instead of page coordinate
 * @return {number} Number
 */
Ext.core.IElement.prototype.getLeft = function(local) {};

/**
 * [Method] Gets this element s ElementLoader
 * @return {!Ext.IElementLoader} Ext.ElementLoader The loader
 */
Ext.core.IElement.prototype.getLoader = function() {};

/**
 * [Method] Gets the local CSS X position for the element Defined in override Ext dom Element_position
 * @return {number} Number
 */
Ext.core.IElement.prototype.getLocalX = function() {};

/**
 * [Method] Gets the local CSS X and Y position for the element Defined in override Ext dom Element_position
 * @return {!Array<?>} Array [x, y]
 */
Ext.core.IElement.prototype.getLocalXY = function() {};

/**
 * [Method] Gets the local CSS Y position for the element Defined in override Ext dom Element_position
 * @return {number} Number
 */
Ext.core.IElement.prototype.getLocalY = function() {};

/**
 * [Method] Returns an object defining the area of this Element which can be passed to Ext util Positionable setBox to set anothe
 * @param {boolean=} asRegion Boolean If true an Ext.util.Region will be returned
 * @return {?} Object/Ext.util.Region box An object in the following format: {  left: &lt;Element's X position&gt;,  top: &lt;Element's Y position&gt;,  width: &lt;Element's width&gt;,  height: &lt;Element's height&gt;,  bottom: &lt;Element's lower bound&gt;,  right: &lt;Element's rightmost bound&gt; }  The returned object may also be addressed as an Array where index 0 contains the X position and index 1 contains the Y position. So the result may also be used for setXY
 */
Ext.core.IElement.prototype.getPageBox = function(asRegion) {};

/**
 * [Method] Gets an object with all CSS positioning properties
 * @param {boolean=} autoPx Boolean true to return pixel values for "auto" styles.
 * @return {?} Object
 */
Ext.core.IElement.prototype.getPositioning = function(autoPx) {};

/**
 * [Method] Gets the right X coordinate of the element element X position  element width  Defined in override Ext dom Element_
 * @param {boolean=} local Boolean True to get the local css position instead of page coordinates
 * @return {number} Number
 */
Ext.core.IElement.prototype.getRight = function(local) {};

/**
 * [Method] Returns the current scroll position of the element
 * @return {?} Object An object containing the scroll position in the format {left: (scrollLeft), top: (scrollTop)}
 */
Ext.core.IElement.prototype.getScroll = function() {};

/**
 * [Method] Gets the left scroll position Defined in override Ext dom Element_scroll
 * @return {number} Number The left scroll position
 */
Ext.core.IElement.prototype.getScrollLeft = function() {};

/**
 * [Method] Gets the top scroll position Defined in override Ext dom Element_scroll
 * @return {number} Number The top scroll position
 */
Ext.core.IElement.prototype.getScrollTop = function() {};

/**
 * [Method] Returns the dimensions of the element available to lay content out in
 * @return {?} Object Object describing width and height.
 */
Ext.core.IElement.prototype.getStyleSize = function() {};

/**
 * [Method] Returns the width in pixels of the passed text or the width of the text in this Element
 * @param {string=} text String The text to measure. Defaults to the innerHTML of the element.
 * @param {number=} min Number The minumum value to return.
 * @param {number=} max Number The maximum value to return.
 * @return {number} Number The text width in pixels.
 */
Ext.core.IElement.prototype.getTextWidth = function(text, min, max) {};

/**
 * [Method] Gets the top Y coordinate Defined in override Ext dom Element_position
 * @param {boolean=} local Boolean True to get the local css position instead of page coordinates
 * @return {number} Number
 */
Ext.core.IElement.prototype.getTop = function(local) {};

/**
 * [Method] Gets element X position in page coordinates Defined in override Ext dom Element_position
 * @return {number} Number
 */
Ext.core.IElement.prototype.getX = function() {};

/**
 * [Method] Gets element X and Y positions in page coordinates Defined in override Ext dom Element_position
 * @return {!Array<?>} Array [x, y]
 */
Ext.core.IElement.prototype.getXY = function() {};

/**
 * [Method] Gets element Y position in page coordinates Defined in override Ext dom Element_position
 * @return {number} Number
 */
Ext.core.IElement.prototype.getY = function() {};

/**
 * [Method] Slides the element while fading it out of view
 * @param {string=} anchor String One of the valid Ext.fx.Anim anchor positions (defaults to bottom: 'b')
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.core.IElement.prototype.ghost = function(anchor, options) {};

/**
 * [Method] Hide this element  Uses display mode to determine whether to use display or visibility
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.hide = function(animate) {};

/**
 * [Method] Highlights the Element by setting a color applies to the background color by default but can be changed using the
 * @param {string=} color String The highlight color. Should be a 6 char hex color without the leading # (defaults to yellow: 'ffff9c')
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.core.IElement.prototype.highlight = function(color, options) {};

/**
 * [Method] Sets up event handlers to call the passed functions when the mouse is moved into and out of the Element
 * @param {?=} overFn Function The function to call when the mouse enters the Element.
 * @param {?=} outFn Function The function to call when the mouse leaves the Element.
 * @param {?=} scope Object The scope (this reference) in which the functions are executed. Defaults to the Element's DOM element.
 * @param {?=} options Object Options for the listener. See the options parameter.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.hover = function(overFn, outFn, scope, options) {};

/**
 * [Method] Initializes a Ext dd DD drag drop object for this element
 * @param {string=} group String The group the DD object is member of
 * @param {?=} config Object The DD config object
 * @param {?=} overrides Object An object containing methods to override/implement on the DD object
 * @return {!Ext.dd.IDD} Ext.dd.DD The DD object
 */
Ext.core.IElement.prototype.initDD = function(group, config, overrides) {};

/**
 * [Method] Initializes a Ext dd DDProxy object for this element
 * @param {string=} group String The group the DDProxy object is member of
 * @param {?=} config Object The DDProxy config object
 * @param {?=} overrides Object An object containing methods to override/implement on the DDProxy object
 * @return {!Ext.dd.IDDProxy} Ext.dd.DDProxy The DDProxy object
 */
Ext.core.IElement.prototype.initDDProxy = function(group, config, overrides) {};

/**
 * [Method] Initializes a Ext dd DDTarget object for this element
 * @param {string=} group String The group the DDTarget object is member of
 * @param {?=} config Object The DDTarget config object
 * @param {?=} overrides Object An object containing methods to override/implement on the DDTarget object
 * @return {!Ext.dd.IDDTarget} Ext.dd.DDTarget The DDTarget object
 */
Ext.core.IElement.prototype.initDDTarget = function(group, config, overrides) {};

/**
 * [Method] Tests various css rules browsers to determine if this element uses a border box
 * @return {boolean} Boolean
 */
Ext.core.IElement.prototype.isBorderBox = function() {};

/**
 * [Method] Returns true if display is not none
 * @return {boolean} Boolean
 */
Ext.core.IElement.prototype.isDisplayed = function() {};

/**
 * [Method] Checks whether this element can be focused
 * @param {?=} asFocusEl Object
 * @return {boolean} Boolean True if the element is focusable
 */
Ext.core.IElement.prototype.isFocusable = function(asFocusEl) {};

/**
 * [Method] Returns true if this element is masked
 * @return {boolean} Boolean
 */
Ext.core.IElement.prototype.isMasked = function() {};

/**
 * [Method] Returns true if this element is scrollable
 * @return {boolean} Boolean
 */
Ext.core.IElement.prototype.isScrollable = function() {};

/**
 * [Method] Checks whether the element is currently visible using both visibility and display properties
 * @param {boolean=} deep Boolean True to walk the dom and see if parent elements are hidden. If false, the function only checks the visibility of the element itself and it may return true even though a parent is not visible.
 * @return {boolean} Boolean true if the element is currently visible, else false
 */
Ext.core.IElement.prototype.isVisible = function(deep) {};

/**
 * [Method] Direct access to the Ext ElementLoader Ext ElementLoader load method
 * @param {?=} options Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.load = function(options) {};

/**
 * [Method] Puts a mask over this element to disable user interaction
 * @param {string=} msg String A message to display in the mask
 * @param {string=} msgCls String A css class to apply to the msg element
 * @return {!Ext.dom.IElement} Ext.dom.Element The mask element
 */
Ext.core.IElement.prototype.mask = function(msg, msgCls) {};

/**
 * [Method] Monitors this Element for the mouse leaving
 * @param {number=} delay Number The delay in milliseconds to wait for possible mouse re-entry before calling the handler function.
 * @param {?=} handler Function The function to call if the mouse remains outside of this Element for the specified time.
 * @param {?=} scope Object The scope (this reference) in which the handler function executes. Defaults to this Element.
 * @return {?} Object The listeners object which was added to this element so that monitoring can be stopped. Example usage: // Hide the menu if the mouse moves out for 250ms or more this.mouseLeaveMonitor = this.menuEl.monitorMouseLeave(250, this.hideMenu, this); ... // Remove mouseleave monitor on menu destroy this.menuEl.un(this.mouseLeaveMonitor);
 */
Ext.core.IElement.prototype.monitorMouseLeave = function(delay, handler, scope) {};

/**
 * [Method] Sets the position of the element in page coordinates
 * @param {number=} x Number X value for new position (coordinates are page-based)
 * @param {number=} y Number Y value for new position (coordinates are page-based)
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.moveTo = function(x, y, animate) {};

/**
 * [Method] Returns true if this element needs an explicit tabIndex to make it focusable
 * @return {void}
 */
Ext.core.IElement.prototype.needsTabIndex = function() {};

/**
 * [Method] Appends an event handler to this element
 * @param {string=} eventName String The name of event to handle.
 * @param {?=} fn Function The handler function the event invokes. This function is passed the following parameters: evt : EventObject The EventObject describing the event. el : HtmlElement The DOM element which was the target of the event. Note that this may be filtered by using the delegate option. o : Object The options object from the call that setup the listener.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to this Element.
 * @param {?=} options Object An object containing handler configuration properties. This may contain any of the following properties: scope Object : The scope (this reference) in which the handler function is executed. If omitted, defaults to this Element. delegate String: A simple selector to filter the target or look for a descendant of the target. See below for additional details. stopEvent Boolean: True to stop the event. That is stop propagation, and prevent the default action. preventDefault Boolean: True to prevent the default action stopPropagation Boolean: True to prevent event propagation normalized Boolean: False to pass a browser event to the handler function instead of an Ext.EventObject target Ext.dom.Element: Only call the handler if the event was fired on the target Element, not if the event was bubbled up from a child node. delay Number: The number of milliseconds to delay the invocation of the handler after the event fires. single Boolean: True to add a handler to handle just the next firing of the event, and then remove itself. buffer Number: Causes the handler to be scheduled to run in an Ext.util.DelayedTask delayed by the specified number of milliseconds. If the event fires again within that time, the original handler is not invoked, but the new handler is scheduled in its place. Combining Options  Using the options argument, it is possible to combine different types of listeners:  A delayed, one-time listener that auto stops the event and adds a custom argument (forumId) to the options object. The options object is available as the third parameter in the handler function.  Code:  el.on('click', this.onClick, this, {  single: true,  delay: 100,  stopEvent : true,  forumId: 4 }); Attaching multiple handlers in 1 call  The method also allows for a single argument to be passed which is a config object containing properties which specify multiple handlers.  Code:  el.on({  'click' : {  fn: this.onClick,  scope: this,  delay: 100  },  'mouseover' : {  fn: this.onMouseOver,  scope: this  },  'mouseout' : {  fn: this.onMouseOut,  scope: this  } }); Or a shorthand syntax:  Code:  el.on({  'click' : this.onClick,  'mouseover' : this.onMouseOver,  'mouseout' : this.onMouseOut,  scope: this }); delegate  This is a configuration option that you can pass along when registering a handler for an event to assist with event delegation. Event delegation is a technique that is used to reduce memory consumption and prevent exposure to memory-leaks. By registering an event for a container element as opposed to each element within a container. By setting this configuration option to a simple selector, the target element will be filtered to look for a descendant of the target. For example:  // using this markup: &lt;div id='elId'&gt;  &lt;p id='p1'&gt;paragraph one&lt;/p&gt;  &lt;p id='p2' class='clickable'&gt;paragraph two&lt;/p&gt;  &lt;p id='p3'&gt;paragraph three&lt;/p&gt; &lt;/div&gt; // utilize event delegation to registering just one handler on the container element: el = Ext.get('elId'); el.on(  'click',  function(e,t) {  // handle click  console.info(t.id); // 'p2'  },  this,  {  // filter the target element to be a descendant with the class 'clickable'  delegate: '.clickable'  } );
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Creates a pause before any subsequent queued effects begin
 * @param {number=} seconds Number The length of time to pause (in seconds)
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.core.IElement.prototype.pause = function(seconds) {};

/**
 * [Method] Initializes positioning on this element
 * @param {string=} pos String Positioning to use "relative", "absolute" or "fixed"
 * @param {number=} zIndex Number The zIndex to apply
 * @param {number=} x Number Set the page X position
 * @param {number=} y Number Set the page Y position
 * @return {void}
 */
Ext.core.IElement.prototype.position = function(pos, zIndex, x, y) {};

/**
 * [Method] Fades the element out while slowly expanding it in all directions
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.core.IElement.prototype.puff = function(options) {};

/**
 * [Method] Recursively removes all previous added listeners from this element and its children
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.purgeAllListeners = function() {};

/**
 * [Method] Create an event handler on this element such that when the event fires and is handled by this element it will be rel
 * @param {string=} eventName String The type of event to relay
 * @param {?=} observable Object Any object that extends Ext.util.Observable that will provide the context for firing the relayed event
 * @return {void}
 */
Ext.core.IElement.prototype.relayEvent = function(eventName, observable) {};

/**
 * [Method] Removes all previous added listeners from this element
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.removeAllListeners = function() {};

/**
 * [Method] Shorthand for un
 * @param {string=} eventName String The name of the event from which to remove the handler.
 * @param {?=} fn Function The handler function to remove. This must be a reference to the function passed into the on call.
 * @param {?=} scope Object If a scope (this reference) was specified when the listener was added, then this must refer to the same object.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Animates the transition of an element s dimensions from a starting height width to an ending height width
 * @param {number=} width Number The new width (pass undefined to keep the original width)
 * @param {number=} height Number The new height (pass undefined to keep the original height)
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.core.IElement.prototype.scale = function(width, height, options) {};

/**
 * [Method] Scrolls this element the specified direction
 * @param {string=} direction String Possible values are:  "l" (or "left") "r" (or "right") "t" (or "top", or "up") "b" (or "bottom", or "down")
 * @param {number=} distance Number How far to scroll the element in pixels
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {boolean} Boolean Returns true if a scroll was triggered or false if the element was scrolled as far as it could go.
 */
Ext.core.IElement.prototype.scroll = function(direction, distance, animate) {};

/**
 * [Method] Scrolls this element by the passed delta values optionally animating
 * @param {?=} deltaX Number/Number[]/Object Either the x delta, an Array specifying x and y deltas or an object with "x" and "y" properties.
 * @param {?=} deltaY Number/Boolean/Object Either the y delta, or an animate flag or config object.
 * @param {?=} animate Boolean/Object Animate flag/config object if the delta values were passed separately.
 * @return {!Ext.IElement} Ext.Element this
 */
Ext.core.IElement.prototype.scrollBy = function(deltaX, deltaY, animate) {};

/**
 * [Method] Scrolls this element into view within the passed container
 * @param {?=} container String/HTMLElement/Ext.Element The container element to scroll. Should be a string (id), dom node, or Ext.Element.
 * @param {boolean=} hscroll Boolean False to disable horizontal scroll.
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element
 * @param {boolean=} highlight Boolean true to highlight the element when it is in view. animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.scrollIntoView = function(container, hscroll, animate, highlight) {};

/**
 * [Method] Scrolls this element the specified scroll point
 * @param {string=} side String Either "left" for scrollLeft values or "top" for scrollTop values.
 * @param {number=} value Number The new scroll value
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.IElement} Ext.Element this
 */
Ext.core.IElement.prototype.scrollTo = function(side, value, animate) {};

/**
 * [Method] Enable text selection for this element normalized across browsers  Defined in override Ext dom Element_style
 * @return {!Ext.IElement} Ext.Element this
 */
Ext.core.IElement.prototype.selectable = function() {};

/**
 * [Method] Sets the element s CSS bottom style
 * @param {?=} bottom Number/String Number of pixels or CSS string value to set as the bottom CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.setBottom = function(bottom) {};

/**
 * [Method] Sets the element s position and size in one shot
 * @param {number=} x Number X value for new position (coordinates are page-based)
 * @param {number=} y Number Y value for new position (coordinates are page-based)
 * @param {?=} width Number/String The new width. This may be one of:  A Number specifying the new width in this Element's defaultUnits (by default, pixels) A String used to set the CSS width style. Animation may not be used.
 * @param {?=} height Number/String The new height. This may be one of:  A Number specifying the new height in this Element's defaultUnits (by default, pixels) A String used to set the CSS height style. Animation may not be used.
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.setBounds = function(x, y, width, height, animate) {};

/**
 * [Method] Sets the CSS display property
 * @param {?=} value Boolean/String Boolean value to display the element using its default display, or a string to set the display directly.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.setDisplayed = function(value) {};

/**
 * [Method] Sets the element s left position directly using CSS style instead of setX
 * @param {?=} left Number/String Number of pixels or CSS string value to set as the left CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.setLeft = function(left) {};

/**
 * [Method] Sets the element s left and top positions directly using CSS style Defined in override Ext dom Element_position
 * @param {?=} left Number/String Number of pixels or CSS string value to set as the left CSS property value
 * @param {?=} top Number/String Number of pixels or CSS string value to set as the top CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.setLeftTop = function(left, top) {};

/**
 * [Method] Sets the position of the element in page coordinates
 * @param {number=} x Number X value for new position
 * @param {number=} y Number Y value for new position
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.setLocation = function(x, y, animate) {};

/**
 * [Method] Set the opacity of the element Defined in override Ext dom Element_style
 * @param {number=} opacity Number The new opacity. 0 = transparent, .5 = 50% visibile, 1 = fully visible, etc
 * @param {?=} animate Boolean/Object a standard Element animation config object or true for the default animation ({duration: 350, easing: 'easeIn'})
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.setOpacity = function(opacity, animate) {};

/**
 * [Method] Set positioning with an object returned by getPositioning
 * @param {?=} posCfg Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.setPositioning = function(posCfg) {};

/**
 * [Method] Sets the element s CSS right style
 * @param {?=} right Number/String Number of pixels or CSS string value to set as the right CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.setRight = function(right) {};

/**
 * [Method] Sets the left scroll position Defined in override Ext dom Element_scroll
 * @param {number=} left Number The left scroll position
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.setScrollLeft = function(left) {};

/**
 * [Method] Sets the top scroll position Defined in override Ext dom Element_scroll
 * @param {number=} top Number The top scroll position
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.setScrollTop = function(top) {};

/**
 * [Method] Sets the element s top position directly using CSS style instead of setY
 * @param {?=} top Number/String Number of pixels or CSS string value to set as the top CSS property value
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.setTop = function(top) {};

/**
 * [Method] Sets the visibility of the element see details
 * @param {boolean=} visible Boolean Whether the element is visible
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.setVisible = function(visible, animate) {};

/**
 * [Method] Animates the transition of any combination of an element s dimensions xy position and or opacity
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.core.IElement.prototype.shift = function(options) {};

/**
 * [Method] Show this element  Uses display mode to determine whether to use display or visibility
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.show = function(animate) {};

/**
 * [Method] Slides the element into view
 * @param {string=} anchor String One of the valid Ext.fx.Anim anchor positions (defaults to top: 't')
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.core.IElement.prototype.slideIn = function(anchor, options) {};

/**
 * [Method] Slides the element out of view
 * @param {string=} anchor String One of the valid Ext.fx.Anim anchor positions (defaults to top: 't')
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.core.IElement.prototype.slideOut = function(anchor, options) {};

/**
 * [Method] Stops the specified event s from bubbling and optionally prevents the default action
 * @param {?=} eventName String/String[] an event / array of events to stop from bubbling
 * @param {boolean=} preventDefault Boolean true to prevent the default action too
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.swallowEvent = function(eventName, preventDefault) {};

/**
 * [Method] Blinks the element as if it was clicked and then collapses on its center similar to switching off a television
 * @param {?=} options Object Object literal with any of the Ext.fx.Anim config options
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element
 */
Ext.core.IElement.prototype.switchOff = function(options) {};

/**
 * [Method] Toggles the element s visibility or display depending on visibility mode
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.toggle = function(animate) {};

/**
 * [Method] Removes an event handler from this element
 * @param {string=} eventName String The name of the event from which to remove the handler.
 * @param {?=} fn Function The handler function to remove. This must be a reference to the function passed into the on call.
 * @param {?=} scope Object If a scope (this reference) was specified when the listener was added, then this must refer to the same object.
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.un = function(eventName, fn, scope) {};

/**
 * [Method] Return clipping overflow to original clipping before clip was called Defined in override Ext dom Element_style
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.unclip = function() {};

/**
 * [Method] Hides a previously applied mask
 * @return {void}
 */
Ext.core.IElement.prototype.unmask = function() {};

/**
 * [Method] Disables text selection for this element normalized across browsers  Defined in override Ext dom Element_style
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.unselectable = function() {};

/**
 * [Method] Updates the innerHTML of this element optionally searching for and processing scripts
 * @param {string=} html String The new HTML
 * @param {boolean=} loadScripts Boolean True to look for and process scripts (defaults to false)
 * @param {?=} callback Function For async script loading you can be notified when the update completes
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.core.IElement.prototype.update = function(html, loadScripts, callback) {};
/**
 * @constructor
 * @struct
 */
Ext.core.Element = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.core.Element.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.core.Element.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.core.Element.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.core.Element.createAlias = function(alias, origin) {};

/**
 * [Method] Returns the top Element that is located at the passed coordinates Defined in override Ext dom AbstractElement_static
 * @param {number=} x Number The x coordinate
 * @param {number=} y Number The y coordinate
 * @return {string} String The found Element
 */
Ext.core.Element.fromPoint = function(x, y) {};

/**
 * [Method] Retrieves Ext dom Element objects
 * @param {?=} el String/HTMLElement/Ext.Element The id of the node, a DOM Node or an existing Element.
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element object (or null if no matching element was found)
 */
Ext.core.Element.get = function(el) {};

/**
 * [Method] Retrieves the document height Defined in override Ext dom AbstractElement_static
 * @return {number} Number documentHeight
 */
Ext.core.Element.getDocumentHeight = function() {};

/**
 * [Method] Retrieves the document width Defined in override Ext dom AbstractElement_static
 * @return {number} Number documentWidth
 */
Ext.core.Element.getDocumentWidth = function() {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.core.Element.getName = function() {};

/**
 * [Method] Retrieves the current orientation of the window
 * @return {string} String Orientation of window: 'portrait' or 'landscape'
 */
Ext.core.Element.getOrientation = function() {};

/**
 * [Method] Retrieves the viewport size of the window
 * @return {?} Object object containing width and height properties
 */
Ext.core.Element.getViewSize = function() {};

/**
 * [Method] Retrieves the viewport height of the window
 * @return {number} Number viewportHeight
 */
Ext.core.Element.getViewportHeight = function() {};

/**
 * [Method] Retrieves the viewport width of the window
 * @return {number} Number viewportWidth
 */
Ext.core.Element.getViewportWidth = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.core.Element.implement = function() {};

/**
 * [Method] Returns an array of unique class names based upon the input strings or string arrays
 * @param {?=} clsList1 Mixed A string of class names, or an array of class names.
 * @param {?=} clsList2 Mixed A string of class names, or an array of class names.
 * @return {!Array<?>} Array An array of strings representing remaining unique, merged class names. If class names were added to the first list, the changed property will be true.
 */
Ext.core.Element.mergeClsList = function(clsList1, clsList2) {};

/**
 * [Method] Normalizes CSS property keys from dash delimited to camel case JavaScript Syntax
 * @param {string=} prop String The property to normalize
 * @return {string} String The normalized string
 */
Ext.core.Element.normalize = function(prop) {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.core.Element.override = function(members) {};

/**
 * [Method] Parses a number or string representing margin sizes into an object
 * @param {?=} box Number/String The encoded margins
 * @return {?} Object An object with margin sizes for top, right, bottom and left
 */
Ext.core.Element.parseBox = function(box) {};

/**
 * [Method] Converts a CSS string into an object with a property for each style
 * @param {string=} styles String A CSS string
 * @return {?} Object styles
 */
Ext.core.Element.parseStyles = function(styles) {};

/**
 * [Method] Returns an array of unique class names deom the first parameter with all class names from the second parameter removed
 * @param {?=} existingClsList Mixed A string of class names, or an array of class names.
 * @param {?=} removeClsList Mixed A string of class names, or an array of class names to remove from existingClsList.
 * @return {!Array<?>} Array An array of strings representing remaining class names. If class names were removed, the changed property will be true.
 */
Ext.core.Element.removeCls = function(existingClsList, removeClsList) {};

/**
 * [Method] Selects elements based on the passed CSS selector to enable Element methods to be applied to many related elements in
 * @param {?=} selector String/HTMLElement[] The CSS selector or an array of elements
 * @param {boolean=} unique Boolean true to create a unique Ext.Element for each element (defaults to a shared flyweight object)
 * @param {?=} root HTMLElement/String The root element of the query or id of the root
 * @return {?} Ext.CompositeElementLite/Ext.CompositeElement
 */
Ext.core.Element.select = function(selector, unique, root) {};

/**
 * [Method] Parses a number or string representing margin sizes into an object
 * @param {?=} box Number/String/Object The encoded margins, or an object with top, right, bottom, and left properties
 * @param {string=} units String The type of units to add
 * @return {string} String An string with unitized (px if units is not specified) metrics for top, right, bottom and left
 */
Ext.core.Element.unitizeBox = function(box, units) {};
/**
 * @extends {Ext.dom.IAbstractHelper}
 * @record
 * @struct
 */
Ext.dom.IHelper = function() {};
 /** @type {boolean} */
Ext.dom.IHelper.prototype.useDom;

/**
 * [Method] Creates new DOM element s without inserting them to the document
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @return {!HTMLElement} HTMLElement The new uninserted node
 */
Ext.dom.IHelper.prototype.createDom = function(o) {};

/**
 * [Method] Alias for markup
 * @param {?=} spec Object The DOM object spec (and children)
 * @return {string} String
 */
Ext.dom.IHelper.prototype.createHtml = function(spec) {};

/**
 * [Method] Creates a new Ext Template from the DOM object spec
 * @param {?=} o Object The DOM object spec (and children)
 * @return {!Ext.ITemplate} Ext.Template The new template
 */
Ext.dom.IHelper.prototype.createTemplate = function(o) {};

/**
 * [Method] Creates new DOM element s and overwrites the contents of el with them
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @param {boolean=} returnElement Boolean true to return an Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.dom.IHelper.prototype.overwrite = function(el, o, returnElement) {};
/**
 * @extends {Ext.IElement}
 * @record
 * @struct
 */
Ext.dom.ILayer = function() {};
 /** @type {string} */
Ext.dom.ILayer.prototype.cls;
 /** @type {boolean} */
Ext.dom.ILayer.prototype.constrain;
 /** @type {?} */
Ext.dom.ILayer.prototype.dh;
 /** @type {string} */
Ext.dom.ILayer.prototype.hideMode;
 /** @type {?} */
Ext.dom.ILayer.prototype.shadow;
 /** @type {number} */
Ext.dom.ILayer.prototype.shadowOffset;
 /** @type {boolean} */
Ext.dom.ILayer.prototype.shim;
 /** @type {boolean} */
Ext.dom.ILayer.prototype.useDisplay;
 /** @type {string} */
Ext.dom.ILayer.prototype.visibilityCls;
 /** @type {number} */
Ext.dom.ILayer.prototype.zindex;

/**
 * [Method] Removes this element s dom reference
 * @return {void}
 */
Ext.dom.ILayer.prototype.remove = function() {};

/**
 * [Method] overridden Element method
 * @param {?=} x Object
 * @param {?=} y Object
 * @param {?=} width Object
 * @param {?=} height Object
 * @param {?=} animate Object
 * @param {?=} duration Object
 * @param {?=} callback Object
 * @param {?=} easing Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.ILayer.prototype.setBounds = function(x, y, width, height, animate, duration, callback, easing) {};

/**
 * [Method] overridden Element method
 * @param {?=} h Object
 * @param {?=} animate Object
 * @param {?=} duration Object
 * @param {?=} callback Object
 * @param {?=} easing Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.ILayer.prototype.setHeight = function(h, animate, duration, callback, easing) {};

/**
 * [Method] overridden Element method
 * @param {?=} left Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.ILayer.prototype.setLeft = function(left) {};

/**
 * [Method] Sets the element s left and top positions directly using CSS style Defined in override Ext dom Element_position
 * @param {?=} left Object
 * @param {?=} top Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.ILayer.prototype.setLeftTop = function(left, top) {};

/**
 * [Method] overridden Element method
 * @param {?=} w Object
 * @param {?=} h Object
 * @param {?=} animate Object
 * @param {?=} duration Object
 * @param {?=} callback Object
 * @param {?=} easing Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.ILayer.prototype.setSize = function(w, h, animate, duration, callback, easing) {};

/**
 * [Method] Sets the element s top position directly using CSS style instead of setY
 * @param {?=} top Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.ILayer.prototype.setTop = function(top) {};

/**
 * [Method] overridden Element method
 * @param {?=} visible Object
 * @param {?=} animate Object
 * @param {?=} duration Object
 * @param {?=} callback Object
 * @param {?=} easing Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.ILayer.prototype.setVisible = function(visible, animate, duration, callback, easing) {};

/**
 * [Method] overridden Element method
 * @param {?=} w Object
 * @param {?=} animate Object
 * @param {?=} duration Object
 * @param {?=} callback Object
 * @param {?=} easing Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.dom.ILayer.prototype.setWidth = function(w, animate, duration, callback, easing) {};

/**
 * [Method] Sets the z index of this layer and adjusts any shadow and shim z indexes
 * @param {number=} zindex Number The new z-index to set
 * @return {!Ext.ILayer} Ext.Layer The Layer
 */
Ext.dom.ILayer.prototype.setZIndex = function(zindex) {};
/**
 * @extends {Ext.IElement}
 * @record
 * @struct
 */
Ext.ILayer = function() {};
 /** @type {string} */
Ext.ILayer.prototype.cls;
 /** @type {boolean} */
Ext.ILayer.prototype.constrain;
 /** @type {?} */
Ext.ILayer.prototype.dh;
 /** @type {string} */
Ext.ILayer.prototype.hideMode;
 /** @type {?} */
Ext.ILayer.prototype.shadow;
 /** @type {number} */
Ext.ILayer.prototype.shadowOffset;
 /** @type {boolean} */
Ext.ILayer.prototype.shim;
 /** @type {boolean} */
Ext.ILayer.prototype.useDisplay;
 /** @type {string} */
Ext.ILayer.prototype.visibilityCls;
 /** @type {number} */
Ext.ILayer.prototype.zindex;

/**
 * [Method] Removes this element s dom reference
 * @return {void}
 */
Ext.ILayer.prototype.remove = function() {};

/**
 * [Method] overridden Element method
 * @param {?=} x Object
 * @param {?=} y Object
 * @param {?=} width Object
 * @param {?=} height Object
 * @param {?=} animate Object
 * @param {?=} duration Object
 * @param {?=} callback Object
 * @param {?=} easing Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.ILayer.prototype.setBounds = function(x, y, width, height, animate, duration, callback, easing) {};

/**
 * [Method] overridden Element method
 * @param {?=} h Object
 * @param {?=} animate Object
 * @param {?=} duration Object
 * @param {?=} callback Object
 * @param {?=} easing Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.ILayer.prototype.setHeight = function(h, animate, duration, callback, easing) {};

/**
 * [Method] overridden Element method
 * @param {?=} left Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.ILayer.prototype.setLeft = function(left) {};

/**
 * [Method] Sets the element s left and top positions directly using CSS style Defined in override Ext dom Element_position
 * @param {?=} left Object
 * @param {?=} top Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.ILayer.prototype.setLeftTop = function(left, top) {};

/**
 * [Method] overridden Element method
 * @param {?=} w Object
 * @param {?=} h Object
 * @param {?=} animate Object
 * @param {?=} duration Object
 * @param {?=} callback Object
 * @param {?=} easing Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.ILayer.prototype.setSize = function(w, h, animate, duration, callback, easing) {};

/**
 * [Method] Sets the element s top position directly using CSS style instead of setY
 * @param {?=} top Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.ILayer.prototype.setTop = function(top) {};

/**
 * [Method] overridden Element method
 * @param {?=} visible Object
 * @param {?=} animate Object
 * @param {?=} duration Object
 * @param {?=} callback Object
 * @param {?=} easing Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.ILayer.prototype.setVisible = function(visible, animate, duration, callback, easing) {};

/**
 * [Method] overridden Element method
 * @param {?=} w Object
 * @param {?=} animate Object
 * @param {?=} duration Object
 * @param {?=} callback Object
 * @param {?=} easing Object
 * @return {!Ext.dom.IElement} Ext.dom.Element this
 */
Ext.ILayer.prototype.setWidth = function(w, animate, duration, callback, easing) {};

/**
 * [Method] Sets the z index of this layer and adjusts any shadow and shim z indexes
 * @param {number=} zindex Number The new z-index to set
 * @return {!Ext.ILayer} Ext.Layer The Layer
 */
Ext.ILayer.prototype.setZIndex = function(zindex) {};
/**
 * @record
 * @struct
 */
Ext.dom.IQuery = function() {};
/**
 * @constructor
 * @struct
 */
Ext.dom.Query = function() {};
 /** @type {?} */
Ext.dom.Query.matchers;
 /** @type {?} */
Ext.dom.Query.operators;
 /** @type {?} */
Ext.dom.Query.pseudos;

/**
 * [Method] Compiles a selector xpath query into a reusable function
 * @param {string=} selector String The selector/xpath query
 * @param {string=} type String Either "select" or "simple" for a simple selector match
 * @return {?} Function
 */
Ext.dom.Query.compile = function(selector, type) {};

/**
 * [Method] Filters an array of elements to only include matches of a simple selector e g
 * @param {!Array<!HTMLElement>=} el HTMLElement[] An array of elements to filter
 * @param {string=} selector String The simple selector to test
 * @param {boolean=} nonMatches Boolean If true, it returns the elements that DON'T match the selector instead of the ones that match
 * @return {!Array<!HTMLElement>} HTMLElement[] An Array of DOM elements which match the selector. If there are no matches, and empty Array is returned.
 */
Ext.dom.Query.filter = function(el, selector, nonMatches) {};

/**
 * [Method] Returns true if the passed element s match the passed simple selector e g
 * @param {?=} el String/HTMLElement/HTMLElement[] An element id, element or array of elements
 * @param {string=} selector String The simple selector to test
 * @return {boolean} Boolean
 */
Ext.dom.Query.is = function(el, selector) {};

/**
 * [Method] Selects an array of DOM nodes using JavaScript only implementation
 * @param {string=} selector String The selector/xpath query (can be a comma separated list of selectors)
 * @param {?=} root HTMLElement/String The start of the query.
 * @return {!Array<!HTMLElement>} HTMLElement[] An Array of DOM elements which match the selector. If there are no matches, and empty Array is returned.
 */
Ext.dom.Query.jsSelect = function(selector, root) {};

/**
 * [Method] Selects an array of DOM nodes by CSS XPath selector
 * @param {string=} path String The selector/xpath query
 * @param {!HTMLElement=} root HTMLElement The start of the query.
 * @param {string=} type String Either "select" or "simple" for a simple selector match (only valid when used when the call is deferred to the jsSelect method)
 * @param {boolean=} single Boolean Pass true to select only the first matching node using document.querySelector (where available)
 * @return {!Array<!HTMLElement>} HTMLElement[] An array of DOM elements (not a NodeList as returned by querySelectorAll).
 */
Ext.dom.Query.select = function(path, root, type, single) {};

/**
 * [Method] Selects a single element
 * @param {string=} selector String The selector/xpath query
 * @param {!HTMLElement=} root HTMLElement The start of the query.
 * @return {!HTMLElement} HTMLElement The DOM element which matched the selector.
 */
Ext.dom.Query.selectNode = function(selector, root) {};

/**
 * [Method] Selects the value of a node parsing integers and floats
 * @param {string=} selector String The selector/xpath query
 * @param {!HTMLElement=} root HTMLElement The start of the query.
 * @param {number=} defaultValue Number When specified, this is return as empty value.
 * @return {number} Number
 */
Ext.dom.Query.selectNumber = function(selector, root, defaultValue) {};

/**
 * [Method] Selects the value of a node optionally replacing null with the defaultValue
 * @param {string=} selector String The selector/xpath query
 * @param {!HTMLElement=} root HTMLElement The start of the query.
 * @param {string=} defaultValue String When specified, this is return as empty value.
 * @return {string} String
 */
Ext.dom.Query.selectValue = function(selector, root, defaultValue) {};
/**
 * @record
 * @struct
 */
Ext.IDomQuery = function() {};
/**
 * @constructor
 * @struct
 */
Ext.DomQuery = function() {};
 /** @type {?} */
Ext.DomQuery.matchers;
 /** @type {?} */
Ext.DomQuery.operators;
 /** @type {?} */
Ext.DomQuery.pseudos;

/**
 * [Method] Compiles a selector xpath query into a reusable function
 * @param {string=} selector String The selector/xpath query
 * @param {string=} type String Either "select" or "simple" for a simple selector match
 * @return {?} Function
 */
Ext.DomQuery.compile = function(selector, type) {};

/**
 * [Method] Filters an array of elements to only include matches of a simple selector e g
 * @param {!Array<!HTMLElement>=} el HTMLElement[] An array of elements to filter
 * @param {string=} selector String The simple selector to test
 * @param {boolean=} nonMatches Boolean If true, it returns the elements that DON'T match the selector instead of the ones that match
 * @return {!Array<!HTMLElement>} HTMLElement[] An Array of DOM elements which match the selector. If there are no matches, and empty Array is returned.
 */
Ext.DomQuery.filter = function(el, selector, nonMatches) {};

/**
 * [Method] Returns true if the passed element s match the passed simple selector e g
 * @param {?=} el String/HTMLElement/HTMLElement[] An element id, element or array of elements
 * @param {string=} selector String The simple selector to test
 * @return {boolean} Boolean
 */
Ext.DomQuery.is = function(el, selector) {};

/**
 * [Method] Selects an array of DOM nodes using JavaScript only implementation
 * @param {string=} selector String The selector/xpath query (can be a comma separated list of selectors)
 * @param {?=} root HTMLElement/String The start of the query.
 * @return {!Array<!HTMLElement>} HTMLElement[] An Array of DOM elements which match the selector. If there are no matches, and empty Array is returned.
 */
Ext.DomQuery.jsSelect = function(selector, root) {};

/**
 * [Method] Selects an array of DOM nodes by CSS XPath selector
 * @param {string=} path String The selector/xpath query
 * @param {!HTMLElement=} root HTMLElement The start of the query.
 * @param {string=} type String Either "select" or "simple" for a simple selector match (only valid when used when the call is deferred to the jsSelect method)
 * @param {boolean=} single Boolean Pass true to select only the first matching node using document.querySelector (where available)
 * @return {!Array<!HTMLElement>} HTMLElement[] An array of DOM elements (not a NodeList as returned by querySelectorAll).
 */
Ext.DomQuery.select = function(path, root, type, single) {};

/**
 * [Method] Selects a single element
 * @param {string=} selector String The selector/xpath query
 * @param {!HTMLElement=} root HTMLElement The start of the query.
 * @return {!HTMLElement} HTMLElement The DOM element which matched the selector.
 */
Ext.DomQuery.selectNode = function(selector, root) {};

/**
 * [Method] Selects the value of a node parsing integers and floats
 * @param {string=} selector String The selector/xpath query
 * @param {!HTMLElement=} root HTMLElement The start of the query.
 * @param {number=} defaultValue Number When specified, this is return as empty value.
 * @return {number} Number
 */
Ext.DomQuery.selectNumber = function(selector, root, defaultValue) {};

/**
 * [Method] Selects the value of a node optionally replacing null with the defaultValue
 * @param {string=} selector String The selector/xpath query
 * @param {!HTMLElement=} root HTMLElement The start of the query.
 * @param {string=} defaultValue String When specified, this is return as empty value.
 * @return {string} String
 */
Ext.DomQuery.selectValue = function(selector, root, defaultValue) {};
/**
 * @record
 * @struct
 */
Ext.core.IDomQuery = function() {};
/**
 * @constructor
 * @struct
 */
Ext.core.DomQuery = function() {};
 /** @type {?} */
Ext.core.DomQuery.matchers;
 /** @type {?} */
Ext.core.DomQuery.operators;
 /** @type {?} */
Ext.core.DomQuery.pseudos;

/**
 * [Method] Compiles a selector xpath query into a reusable function
 * @param {string=} selector String The selector/xpath query
 * @param {string=} type String Either "select" or "simple" for a simple selector match
 * @return {?} Function
 */
Ext.core.DomQuery.compile = function(selector, type) {};

/**
 * [Method] Filters an array of elements to only include matches of a simple selector e g
 * @param {!Array<!HTMLElement>=} el HTMLElement[] An array of elements to filter
 * @param {string=} selector String The simple selector to test
 * @param {boolean=} nonMatches Boolean If true, it returns the elements that DON'T match the selector instead of the ones that match
 * @return {!Array<!HTMLElement>} HTMLElement[] An Array of DOM elements which match the selector. If there are no matches, and empty Array is returned.
 */
Ext.core.DomQuery.filter = function(el, selector, nonMatches) {};

/**
 * [Method] Returns true if the passed element s match the passed simple selector e g
 * @param {?=} el String/HTMLElement/HTMLElement[] An element id, element or array of elements
 * @param {string=} selector String The simple selector to test
 * @return {boolean} Boolean
 */
Ext.core.DomQuery.is = function(el, selector) {};

/**
 * [Method] Selects an array of DOM nodes using JavaScript only implementation
 * @param {string=} selector String The selector/xpath query (can be a comma separated list of selectors)
 * @param {?=} root HTMLElement/String The start of the query.
 * @return {!Array<!HTMLElement>} HTMLElement[] An Array of DOM elements which match the selector. If there are no matches, and empty Array is returned.
 */
Ext.core.DomQuery.jsSelect = function(selector, root) {};

/**
 * [Method] Selects an array of DOM nodes by CSS XPath selector
 * @param {string=} path String The selector/xpath query
 * @param {!HTMLElement=} root HTMLElement The start of the query.
 * @param {string=} type String Either "select" or "simple" for a simple selector match (only valid when used when the call is deferred to the jsSelect method)
 * @param {boolean=} single Boolean Pass true to select only the first matching node using document.querySelector (where available)
 * @return {!Array<!HTMLElement>} HTMLElement[] An array of DOM elements (not a NodeList as returned by querySelectorAll).
 */
Ext.core.DomQuery.select = function(path, root, type, single) {};

/**
 * [Method] Selects a single element
 * @param {string=} selector String The selector/xpath query
 * @param {!HTMLElement=} root HTMLElement The start of the query.
 * @return {!HTMLElement} HTMLElement The DOM element which matched the selector.
 */
Ext.core.DomQuery.selectNode = function(selector, root) {};

/**
 * [Method] Selects the value of a node parsing integers and floats
 * @param {string=} selector String The selector/xpath query
 * @param {!HTMLElement=} root HTMLElement The start of the query.
 * @param {number=} defaultValue Number When specified, this is return as empty value.
 * @return {number} Number
 */
Ext.core.DomQuery.selectNumber = function(selector, root, defaultValue) {};

/**
 * [Method] Selects the value of a node optionally replacing null with the defaultValue
 * @param {string=} selector String The selector/xpath query
 * @param {!HTMLElement=} root HTMLElement The start of the query.
 * @param {string=} defaultValue String When specified, this is return as empty value.
 * @return {string} String
 */
Ext.core.DomQuery.selectValue = function(selector, root, defaultValue) {};
/**
 * @extends {Ext.dom.IHelper}
 * @record
 * @struct
 */
Ext.IDomHelper = function() {};
/**
 * @constructor
 * @struct
 */
Ext.DomHelper = function() {};
 /** @type {!Ext.IClass} */
Ext.DomHelper.self;
 /** @type {boolean} */
Ext.DomHelper.useDom;

/**
 * [Method] Creates new DOM element s and appends them to el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @param {boolean=} returnElement Boolean true to return a Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.DomHelper.append = function(el, o, returnElement) {};

/**
 * [Method] Applies a style specification to an element
 * @param {?=} el String/HTMLElement The element to apply styles to
 * @param {?=} styles String/Object/Function A style specification string e.g. 'width:100px', or object in the form {width:'100px'}, or a function which returns such a specification.
 * @return {void}
 */
Ext.DomHelper.applyStyles = function(el, styles) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.DomHelper.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.DomHelper.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.DomHelper.callSuper = function(args) {};

/**
 * [Method] Creates new DOM element s without inserting them to the document
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @return {!HTMLElement} HTMLElement The new uninserted node
 */
Ext.DomHelper.createDom = function(o) {};

/**
 * [Method] Alias for markup
 * @param {?=} spec Object The DOM object spec (and children)
 * @return {string} String
 */
Ext.DomHelper.createHtml = function(spec) {};

/**
 * [Method] Creates a new Ext Template from the DOM object spec
 * @param {?=} o Object The DOM object spec (and children)
 * @return {!Ext.ITemplate} Ext.Template The new template
 */
Ext.DomHelper.createTemplate = function(o) {};

/**
 * [Method] Converts the styles from the given object to text
 * @param {?=} styles Object The object describing the styles.
 * @param {!Array<string>=} buffer String[] The output buffer.
 * @return {?} String/String[] If buffer is passed, it is returned. Otherwise the style string is returned.
 */
Ext.DomHelper.generateStyles = function(styles, buffer) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.DomHelper.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.DomHelper.initConfig = function(config) {};

/**
 * [Method] Creates new DOM element s and inserts them after el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object The DOM object spec (and children)
 * @param {boolean=} returnElement Boolean true to return a Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.DomHelper.insertAfter = function(el, o, returnElement) {};

/**
 * [Method] Creates new DOM element s and inserts them before el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @param {boolean=} returnElement Boolean true to return a Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.DomHelper.insertBefore = function(el, o, returnElement) {};

/**
 * [Method] Creates new DOM element s and inserts them as the first child of el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @param {boolean=} returnElement Boolean true to return a Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.DomHelper.insertFirst = function(el, o, returnElement) {};

/**
 * [Method] Inserts an HTML fragment into the DOM
 * @param {string=} where String Where to insert the html in relation to el - beforeBegin, afterBegin, beforeEnd, afterEnd. For example take the following HTML: &lt;div&gt;Contents&lt;/div&gt; Using different where values inserts element to the following places:  beforeBegin: &lt;HERE&gt;&lt;div&gt;Contents&lt;/div&gt; afterBegin: &lt;div&gt;&lt;HERE&gt;Contents&lt;/div&gt; beforeEnd: &lt;div&gt;Contents&lt;HERE&gt;&lt;/div&gt; afterEnd: &lt;div&gt;Contents&lt;/div&gt;&lt;HERE&gt;
 * @param {?=} el HTMLElement/TextNode The context element
 * @param {string=} html String The HTML fragment
 * @return {!HTMLElement} HTMLElement The new node
 */
Ext.DomHelper.insertHtml = function(where, el, html) {};

/**
 * [Method] Returns the markup for the passed Element s config
 * @param {?=} spec Object The DOM object spec (and children)
 * @return {string} String
 */
Ext.DomHelper.markup = function(spec) {};

/**
 * [Method] Creates new DOM element s and overwrites the contents of el with them
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @param {boolean=} returnElement Boolean true to return an Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.DomHelper.overwrite = function(el, o, returnElement) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.DomHelper.statics = function() {};
/**
 * @extends {Ext.dom.IHelper}
 * @record
 * @struct
 */
Ext.core.IDomHelper = function() {};
/**
 * @constructor
 * @struct
 */
Ext.core.DomHelper = function() {};
 /** @type {!Ext.IClass} */
Ext.core.DomHelper.self;
 /** @type {boolean} */
Ext.core.DomHelper.useDom;

/**
 * [Method] Creates new DOM element s and appends them to el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @param {boolean=} returnElement Boolean true to return a Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.core.DomHelper.append = function(el, o, returnElement) {};

/**
 * [Method] Applies a style specification to an element
 * @param {?=} el String/HTMLElement The element to apply styles to
 * @param {?=} styles String/Object/Function A style specification string e.g. 'width:100px', or object in the form {width:'100px'}, or a function which returns such a specification.
 * @return {void}
 */
Ext.core.DomHelper.applyStyles = function(el, styles) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.core.DomHelper.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.core.DomHelper.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.core.DomHelper.callSuper = function(args) {};

/**
 * [Method] Creates new DOM element s without inserting them to the document
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @return {!HTMLElement} HTMLElement The new uninserted node
 */
Ext.core.DomHelper.createDom = function(o) {};

/**
 * [Method] Alias for markup
 * @param {?=} spec Object The DOM object spec (and children)
 * @return {string} String
 */
Ext.core.DomHelper.createHtml = function(spec) {};

/**
 * [Method] Creates a new Ext Template from the DOM object spec
 * @param {?=} o Object The DOM object spec (and children)
 * @return {!Ext.ITemplate} Ext.Template The new template
 */
Ext.core.DomHelper.createTemplate = function(o) {};

/**
 * [Method] Converts the styles from the given object to text
 * @param {?=} styles Object The object describing the styles.
 * @param {!Array<string>=} buffer String[] The output buffer.
 * @return {?} String/String[] If buffer is passed, it is returned. Otherwise the style string is returned.
 */
Ext.core.DomHelper.generateStyles = function(styles, buffer) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.core.DomHelper.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.core.DomHelper.initConfig = function(config) {};

/**
 * [Method] Creates new DOM element s and inserts them after el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object The DOM object spec (and children)
 * @param {boolean=} returnElement Boolean true to return a Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.core.DomHelper.insertAfter = function(el, o, returnElement) {};

/**
 * [Method] Creates new DOM element s and inserts them before el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @param {boolean=} returnElement Boolean true to return a Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.core.DomHelper.insertBefore = function(el, o, returnElement) {};

/**
 * [Method] Creates new DOM element s and inserts them as the first child of el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @param {boolean=} returnElement Boolean true to return a Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.core.DomHelper.insertFirst = function(el, o, returnElement) {};

/**
 * [Method] Inserts an HTML fragment into the DOM
 * @param {string=} where String Where to insert the html in relation to el - beforeBegin, afterBegin, beforeEnd, afterEnd. For example take the following HTML: &lt;div&gt;Contents&lt;/div&gt; Using different where values inserts element to the following places:  beforeBegin: &lt;HERE&gt;&lt;div&gt;Contents&lt;/div&gt; afterBegin: &lt;div&gt;&lt;HERE&gt;Contents&lt;/div&gt; beforeEnd: &lt;div&gt;Contents&lt;HERE&gt;&lt;/div&gt; afterEnd: &lt;div&gt;Contents&lt;/div&gt;&lt;HERE&gt;
 * @param {?=} el HTMLElement/TextNode The context element
 * @param {string=} html String The HTML fragment
 * @return {!HTMLElement} HTMLElement The new node
 */
Ext.core.DomHelper.insertHtml = function(where, el, html) {};

/**
 * [Method] Returns the markup for the passed Element s config
 * @param {?=} spec Object The DOM object spec (and children)
 * @return {string} String
 */
Ext.core.DomHelper.markup = function(spec) {};

/**
 * [Method] Creates new DOM element s and overwrites the contents of el with them
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} o Object/String The DOM object spec (and children) or raw HTML blob
 * @param {boolean=} returnElement Boolean true to return an Ext.Element
 * @return {?} HTMLElement/Ext.Element The new node
 */
Ext.core.DomHelper.overwrite = function(el, o, returnElement) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.core.DomHelper.statics = function() {};
/** @const */
Ext.draw = {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.draw.IColor = function() {};
 /** @type {number} */
Ext.draw.IColor.prototype.lightnessFactor;

/**
 * [Method] Get the blue component of the color in the range 0 255
 * @return {number} Number
 */
Ext.draw.IColor.prototype.getBlue = function() {};

/**
 * [Method] Return a new color that is darker than this color
 * @param {number=} factor Number Darker factor (0..1), default to 0.2
 * @return {?} Object Ext.draw.Color
 */
Ext.draw.IColor.prototype.getDarker = function(factor) {};

/**
 * [Method] Returns the gray value 0 to 255 of the color
 * @return {number} Number
 */
Ext.draw.IColor.prototype.getGrayscale = function() {};

/**
 * [Method] Get the green component of the color in the range 0 255
 * @return {number} Number
 */
Ext.draw.IColor.prototype.getGreen = function() {};

/**
 * [Method] Get the equivalent HSL components of the color
 * @return {!Array<number>} Number[]
 */
Ext.draw.IColor.prototype.getHSL = function() {};

/**
 * [Method] Return a new color that is lighter than this color
 * @param {number=} factor Number Lighter factor (0..1), default to 0.2
 * @return {?} Object Ext.draw.Color
 */
Ext.draw.IColor.prototype.getLighter = function(factor) {};

/**
 * [Method] Get the RGB values
 * @return {!Array<number>} Number[]
 */
Ext.draw.IColor.prototype.getRGB = function() {};

/**
 * [Method] Get the red component of the color in the range 0 255
 * @return {number} Number
 */
Ext.draw.IColor.prototype.getRed = function() {};

/**
 * [Method] Return the color in the hex format i e
 * @return {string} String
 */
Ext.draw.IColor.prototype.toString = function() {};
/**
 * @constructor
 * @struct
 */
Ext.draw.Color = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.draw.Color.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.draw.Color.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.draw.Color.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.draw.Color.createAlias = function(alias, origin) {};

/**
 * [Method] Create a new color based on the specified HSL values
 * @param {number=} h Number Hue component (0..359)
 * @param {number=} s Number Saturation component (0..1)
 * @param {number=} l Number Lightness component (0..1)
 * @return {?} Object Ext.draw.Color
 */
Ext.draw.Color.fromHSL = function(h, s, l) {};

/**
 * [Method] Parse the string and create a new color
 * @param {string=} str String Color in string.
 * @return {?} Object Ext.draw.Color
 */
Ext.draw.Color.fromString = function(str) {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.draw.Color.getName = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.draw.Color.implement = function() {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.draw.Color.override = function(members) {};

/**
 * [Method] Convert a color to hexadecimal format
 * @param {?=} color String/String[] The color value (i.e 'rgb(255, 255, 255)', 'color: #ffffff'). Can also be an Array, in this case the function handles the first member.
 * @return {string} String The color in hexadecimal format.
 */
Ext.draw.Color.toHex = function(color) {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.draw.IComponent = function() {};
 /** @type {boolean} */
Ext.draw.IComponent.prototype.autoSize;
 /** @type {string} */
Ext.draw.IComponent.prototype.baseCls;
 /** @type {?} */
Ext.draw.IComponent.prototype.componentLayout;
 /** @type {!Array<string>} */
Ext.draw.IComponent.prototype.enginePriority;
 /** @type {!Array<?>} */
Ext.draw.IComponent.prototype.gradients;
 /** @type {!Array<!Ext.draw.ISprite>} */
Ext.draw.IComponent.prototype.items;
 /** @type {?} */
Ext.draw.IComponent.prototype.shrinkWrap;
 /** @type {boolean} */
Ext.draw.IComponent.prototype.viewBox;
 /** @type {!Ext.draw.ISurface} */
Ext.draw.IComponent.prototype.surface;
/**
 * @extends {Ext.util.IMixedCollection}
 * @extends {Ext.util.IAnimate}
 * @record
 * @struct
 */
Ext.draw.ICompositeSprite = function() {};

/**
 * [Method] Inherit docs from MixedCollection
 * @param {?=} key Object
 * @param {?=} o Object
 * @return {?} Object The item added.
 */
Ext.draw.ICompositeSprite.prototype.add = function(key, o) {};

/**
 * [Method] Adds class to all sprites
 * @param {string=} cls String CSS class name
 * @return {void}
 */
Ext.draw.ICompositeSprite.prototype.addCls = function(cls) {};

/**
 * [Method] Performs custom animation on this object
 * @param {?=} config Object Configuration for Ext.fx.Anim. Note that the to config is required.
 * @return {?} Object this
 */
Ext.draw.ICompositeSprite.prototype.animate = function(config) {};

/**
 * [Method] Destroys this CompositeSprite
 * @return {void}
 */
Ext.draw.ICompositeSprite.prototype.destroy = function() {};

/**
 * [Method] Returns the current animation if this object has any effects actively running or queued else returns false
 * @return {?} Ext.fx.Anim/Boolean Anim if element has active effects, else false
 */
Ext.draw.ICompositeSprite.prototype.getActiveAnimation = function() {};

/**
 * [Method] Returns the group bounding box
 * @return {?} Object an object with x, y, width, and height properties.
 */
Ext.draw.ICompositeSprite.prototype.getBBox = function() {};

/**
 * [Method] Returns the current animation if this object has any effects actively running or queued else returns false
 * @return {?} Ext.fx.Anim/Boolean Anim if element has active effects, else false
 */
Ext.draw.ICompositeSprite.prototype.hasActiveFx = function() {};

/**
 * [Method] Hides all sprites
 * @param {boolean=} redraw Boolean Flag to immediately draw the change.
 * @return {!Ext.draw.ICompositeSprite} Ext.draw.CompositeSprite this
 */
Ext.draw.ICompositeSprite.prototype.hide = function(redraw) {};

/**
 * [Method] Inserts an item at the specified index in the collection
 * @param {?=} index Object
 * @param {?=} key Object
 * @param {?=} o Object
 * @return {?} Object The item inserted or an array of items inserted.
 */
Ext.draw.ICompositeSprite.prototype.insert = function(index, key, o) {};

/**
 * [Method] Force redraw of all sprites
 * @return {void}
 */
Ext.draw.ICompositeSprite.prototype.redraw = function() {};

/**
 * [Method] Inherit docs from MixedCollection
 * @param {?=} o Object
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.draw.ICompositeSprite.prototype.remove = function(o) {};

/**
 * [Method] Removes class from all sprites
 * @param {string=} cls String CSS class name
 * @return {void}
 */
Ext.draw.ICompositeSprite.prototype.removeCls = function(cls) {};

/**
 * [Method] Ensures that all effects queued after sequenceFx is called on this object are run in sequence
 * @return {?} Object this
 */
Ext.draw.ICompositeSprite.prototype.sequenceFx = function() {};

/**
 * [Method] Iterates through all sprites calling setAttributes on each one
 * @param {?=} attrs Object Attributes to be changed on the sprite.
 * @param {boolean=} redraw Boolean Flag to immediately draw the change.
 * @return {!Ext.draw.ICompositeSprite} Ext.draw.CompositeSprite this
 */
Ext.draw.ICompositeSprite.prototype.setAttributes = function(attrs, redraw) {};

/**
 * [Method] Sets style for all sprites
 * @param {string=} style String CSS Style definition.
 * @return {void}
 */
Ext.draw.ICompositeSprite.prototype.setStyle = function(style) {};

/**
 * [Method] Shows all sprites
 * @param {boolean=} redraw Boolean Flag to immediately draw the change.
 * @return {!Ext.draw.ICompositeSprite} Ext.draw.CompositeSprite this
 */
Ext.draw.ICompositeSprite.prototype.show = function(redraw) {};

/**
 * [Method] Stops any running effects and clears this object s internal effects queue if it contains any additional effects that
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.draw.ICompositeSprite.prototype.stopAnimation = function() {};

/**
 * [Method] Stops any running effects and clears this object s internal effects queue if it contains any additional effects that
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.draw.ICompositeSprite.prototype.stopFx = function() {};

/**
 * [Method] Ensures that all effects queued after syncFx is called on this object are run concurrently
 * @return {?} Object this
 */
Ext.draw.ICompositeSprite.prototype.syncFx = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.draw.IDraw = function() {};
/**
 * @constructor
 * @struct
 */
Ext.draw.Draw = function() {};
 /** @type {!Ext.IClass} */
Ext.draw.Draw.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.draw.Draw.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.draw.Draw.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.draw.Draw.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.draw.Draw.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.draw.Draw.initConfig = function(config) {};

/**
 * [Method] snapEndsByDate is a utility method to deduce an appropriate tick configuration for the data set of given feature
 * @param {?=} from Date The minimum value in the data
 * @param {?=} to Date The maximum value in the data
 * @param {number=} stepsMax Number The maximum number of ticks
 * @param {boolean=} lockEnds Boolean If true, the 'from' and 'to' parameters will be used as fixed end values and will not be adjusted
 * @return {?} Object The calculated step and ends info; properties are: - from: The result start value, which may be lower than the original start value - to: The result end value, which may be higher than the original end value - step: The fixed value size of each step, or undefined if the steps are not fixed. - steps: The number of steps if the steps are fixed, or an array of step values. NOTE: Even when the steps have a fixed value, they may not divide the from/to range perfectly evenly; there may be a smaller distance between the last step and the end value than between prior steps, particularly when the endsLocked param is true. Therefore it is best to not use the steps result when finding the axis tick points, instead use the step, to, and from to find the correct point for each tick.
 */
Ext.draw.Draw.snapEndsByDate = function(from, to, stepsMax, lockEnds) {};

/**
 * [Method] snapEndsByDateAndStep is a utility method to deduce an appropriate tick configuration for the data set of given featu
 * @param {?=} from Date The minimum value in the data
 * @param {?=} to Date The maximum value in the data
 * @param {!Array<?>=} step Array An array with two components: The first is the unit of the step (day, month, year, etc). The second is the number of units for the step (1, 2, etc.). If the number is an integer, it represents the number of units for the step ([Ext.Date.DAY, 2] means "Every other day"). If the number is a fraction, it represents the number of steps per unit ([Ext.Date.DAY, 1/2] means "Twice a day"). If the unit is the month, the steps may be adjusted depending on the month. For instance [Ext.Date.MONTH, 1/3], which means "Three times a month", generates steps on the 1st, the 10th and the 20th of every month regardless of whether a month has 28 days or 31 days. The steps are generated as follows: - [Ext.Date.MONTH, n]: on the current date every 'n' months, maxed to the number of days in the month. - [Ext.Date.MONTH, 1/2]: on the 1st and 15th of every month. - [Ext.Date.MONTH, 1/3]: on the 1st, 10th and 20th of every month. - [Ext.Date.MONTH, 1/4]: on the 1st, 8th, 15th and 22nd of every month.
 * @param {boolean=} lockEnds Boolean If true, the 'from' and 'to' parameters will be used as fixed end values  and will not be adjusted
 * @return {?} Object The calculated step and ends info; properties are: - from: The result start value, which may be lower than the original start value - to: The result end value, which may be higher than the original end value - step: The fixed value size of each step, or undefined if the steps are not fixed. - steps: The number of steps if the steps are fixed, or an array of step values. NOTE: Even when the steps have a fixed value, they may not divide the from/to range perfectly evenly; there may be a smaller distance between the last step and the end value than between prior steps, particularly when the endsLocked param is true. Therefore it is best to not use the steps result when finding the axis tick points, instead use the step, to, and from to find the correct point for each tick.
 */
Ext.draw.Draw.snapEndsByDateAndStep = function(from, to, step, lockEnds) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.draw.Draw.statics = function() {};
/** @const */
Ext.draw.engine = {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.draw.engine.IImageExporter = function() {};
/**
 * @constructor
 * @struct
 */
Ext.draw.engine.ImageExporter = function() {};
 /** @type {string} */
Ext.draw.engine.ImageExporter.defaultUrl;
 /** @type {string} */
Ext.draw.engine.ImageExporter.heightParam;
 /** @type {!Ext.IClass} */
Ext.draw.engine.ImageExporter.self;
 /** @type {!Array<?>} */
Ext.draw.engine.ImageExporter.supportedTypes;
 /** @type {string} */
Ext.draw.engine.ImageExporter.svgParam;
 /** @type {string} */
Ext.draw.engine.ImageExporter.typeParam;
 /** @type {string} */
Ext.draw.engine.ImageExporter.widthParam;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.draw.engine.ImageExporter.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.draw.engine.ImageExporter.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.draw.engine.ImageExporter.callSuper = function(args) {};

/**
 * [Method] Exports the surface to an image
 * @param {!Ext.draw.ISurface=} surface Ext.draw.Surface The surface to export
 * @param {?=} config Object The following config options are supported:
 * @return {boolean} Boolean True if the surface was successfully sent to the server.
 */
Ext.draw.engine.ImageExporter.generate = function(surface, config) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.draw.engine.ImageExporter.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.draw.engine.ImageExporter.initConfig = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.draw.engine.ImageExporter.statics = function() {};
/**
 * @extends {Ext.draw.ISurface}
 * @record
 * @struct
 */
Ext.draw.engine.ISvg = function() {};

/**
 * [Method] Adds one or more CSS classes to the element
 * @param {?=} sprite Object
 * @param {?=} className Object
 * @return {void}
 */
Ext.draw.engine.ISvg.prototype.addCls = function(sprite, className) {};

/**
 * [Method] Adds a gradient definition to the Surface
 * @param {?=} gradient Object
 * @return {void}
 */
Ext.draw.engine.ISvg.prototype.addGradient = function(gradient) {};

/**
 * [Method] Insert or move a given sprite s element to the correct place in the DOM list for its zIndex
 * @param {!Ext.draw.ISprite=} sprite Ext.draw.Sprite
 * @return {void}
 */
Ext.draw.engine.ISvg.prototype.applyZIndex = function(sprite) {};

/**
 * [Method] Destroys the surface
 * @return {void}
 */
Ext.draw.engine.ISvg.prototype.destroy = function() {};

/**
 * [Method] Get the region for the surface s canvas area
 * @return {!Ext.util.IRegion} Ext.util.Region
 */
Ext.draw.engine.ISvg.prototype.getRegion = function() {};

/**
 * [Method] Checks if the specified CSS class exists on this element s DOM node
 * @param {!Ext.draw.ISprite=} sprite Ext.draw.Sprite The sprite to look into.
 * @param {string=} className String The CSS class to check for
 * @return {boolean} Boolean True if the class exists, else false
 */
Ext.draw.engine.ISvg.prototype.hasCls = function(sprite, className) {};

/**
 * [Method] Removes one or more CSS classes from the element
 * @param {?=} sprite Object
 * @param {?=} className Object
 * @return {void}
 */
Ext.draw.engine.ISvg.prototype.removeCls = function(sprite, className) {};

/**
 * [Method] Sets the size of the surface
 * @param {?=} width Object
 * @param {?=} height Object
 * @return {void}
 */
Ext.draw.engine.ISvg.prototype.setSize = function(width, height) {};

/**
 * [Method] Changes the text in the sprite element
 * @param {?=} sprite Object
 * @param {?=} textString Object
 * @return {void}
 */
Ext.draw.engine.ISvg.prototype.setText = function(sprite, textString) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.draw.engine.ISvgExporter = function() {};
/**
 * @constructor
 * @struct
 */
Ext.draw.engine.SvgExporter = function() {};
 /** @type {!Ext.IClass} */
Ext.draw.engine.SvgExporter.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.draw.engine.SvgExporter.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.draw.engine.SvgExporter.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.draw.engine.SvgExporter.callSuper = function(args) {};

/**
 * [Method] Exports the passed surface to a SVG string representation
 * @param {!Ext.draw.ISurface=} surface Ext.draw.Surface The surface to export
 * @param {?=} config Object Any configuration for the export. Currently this is unused but may provide more options in the future
 * @return {string} String The SVG as a string
 */
Ext.draw.engine.SvgExporter.generate = function(surface, config) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.draw.engine.SvgExporter.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.draw.engine.SvgExporter.initConfig = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.draw.engine.SvgExporter.statics = function() {};
/**
 * @extends {Ext.draw.ISurface}
 * @record
 * @struct
 */
Ext.draw.engine.IVml = function() {};

/**
 * [Method] Adds one or more CSS classes to the element
 * @param {?=} sprite Object
 * @param {?=} className Object
 * @return {void}
 */
Ext.draw.engine.IVml.prototype.addCls = function(sprite, className) {};

/**
 * [Method] Adds a definition to this Surface for a linear gradient
 * @param {?=} gradient Object
 * @return {void}
 */
Ext.draw.engine.IVml.prototype.addGradient = function(gradient) {};

/**
 * [Method] Destroys the surface
 * @return {void}
 */
Ext.draw.engine.IVml.prototype.destroy = function() {};

/**
 * [Method] Removes one or more CSS classes from the element
 * @param {?=} sprite Object
 * @param {?=} className Object
 * @return {void}
 */
Ext.draw.engine.IVml.prototype.removeCls = function(sprite, className) {};

/**
 * [Method] Sets the size of the surface
 * @param {?=} width Object
 * @param {?=} height Object
 * @return {void}
 */
Ext.draw.engine.IVml.prototype.setSize = function(width, height) {};

/**
 * [Method] Changes the text in the sprite element
 * @param {?=} sprite Object
 * @param {?=} text Object
 * @return {void}
 */
Ext.draw.engine.IVml.prototype.setText = function(sprite, text) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.draw.IMatrix = function() {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @extends {Ext.util.IAnimate}
 * @record
 * @struct
 */
Ext.draw.ISprite = function() {};
 /** @type {boolean} */
Ext.draw.ISprite.prototype.draggable;
 /** @type {string} */
Ext.draw.ISprite.prototype.fill;
 /** @type {string} */
Ext.draw.ISprite.prototype.font;
 /** @type {?} */
Ext.draw.ISprite.prototype.group;
 /** @type {number} */
Ext.draw.ISprite.prototype.height;
 /** @type {number} */
Ext.draw.ISprite.prototype.opacity;
 /** @type {string} */
Ext.draw.ISprite.prototype.path;
 /** @type {number} */
Ext.draw.ISprite.prototype.radius;
 /** @type {number} */
Ext.draw.ISprite.prototype.radiusX;
 /** @type {number} */
Ext.draw.ISprite.prototype.radiusY;
 /** @type {string} */
Ext.draw.ISprite.prototype.src;
 /** @type {string} */
Ext.draw.ISprite.prototype.stroke;
 /** @type {number} */
Ext.draw.ISprite.prototype.strokewidth;
 /** @type {string} */
Ext.draw.ISprite.prototype.text;
 /** @type {string} */
Ext.draw.ISprite.prototype.type;
 /** @type {number} */
Ext.draw.ISprite.prototype.width;
 /** @type {number} */
Ext.draw.ISprite.prototype.x;
 /** @type {number} */
Ext.draw.ISprite.prototype.y;
 /** @type {!Ext.dd.IDragSource} */
Ext.draw.ISprite.prototype.dd;
 /** @type {boolean} */
Ext.draw.ISprite.prototype.isSprite;

/**
 * [Method] Adds one or more CSS classes to the element
 * @param {?=} className String/String[] The CSS class to add, or an array of classes
 * @return {!Ext.draw.ISprite} Ext.draw.Sprite this
 */
Ext.draw.ISprite.prototype.addCls = function(className) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.draw.ISprite.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.draw.ISprite.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.draw.ISprite.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Performs custom animation on this object
 * @param {?=} config Object Configuration for Ext.fx.Anim. Note that the to config is required.
 * @return {?} Object this
 */
Ext.draw.ISprite.prototype.animate = function(config) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.draw.ISprite.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.draw.ISprite.prototype.clearManagedListeners = function() {};

/**
 * [Method] Removes the sprite and clears all listeners
 * @return {void}
 */
Ext.draw.ISprite.prototype.destroy = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.draw.ISprite.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.draw.ISprite.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.draw.ISprite.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the current animation if this object has any effects actively running or queued else returns false
 * @return {?} Ext.fx.Anim/Boolean Anim if element has active effects, else false
 */
Ext.draw.ISprite.prototype.getActiveAnimation = function() {};

/**
 * [Method] Retrieves the bounding box of the sprite
 * @return {?} Object bbox
 */
Ext.draw.ISprite.prototype.getBBox = function() {};

/**
 * [Method] Returns the current animation if this object has any effects actively running or queued else returns false
 * @return {?} Ext.fx.Anim/Boolean Anim if element has active effects, else false
 */
Ext.draw.ISprite.prototype.hasActiveFx = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.draw.ISprite.prototype.hasListener = function(eventName) {};

/**
 * [Method] Hides the sprite
 * @param {boolean=} redraw Boolean Flag to immediately draw the change.
 * @return {!Ext.draw.ISprite} Ext.draw.Sprite this
 */
Ext.draw.ISprite.prototype.hide = function(redraw) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.draw.ISprite.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.draw.ISprite.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.draw.ISprite.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Redraws the sprite
 * @return {!Ext.draw.ISprite} Ext.draw.Sprite this
 */
Ext.draw.ISprite.prototype.redraw = function() {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.draw.ISprite.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes the sprite
 * @return {boolean} Boolean True if sprite was successfully removed. False when there was no surface to remove it from.
 */
Ext.draw.ISprite.prototype.remove = function() {};

/**
 * [Method] Removes one or more CSS classes from the element
 * @param {?=} className String/String[] The CSS class to remove, or an array of classes. Note this method is severly limited in VML.
 * @return {!Ext.draw.ISprite} Ext.draw.Sprite this
 */
Ext.draw.ISprite.prototype.removeCls = function(className) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.draw.ISprite.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.draw.ISprite.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.draw.ISprite.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.draw.ISprite.prototype.resumeEvents = function() {};

/**
 * [Method] Ensures that all effects queued after sequenceFx is called on this object are run in sequence
 * @return {?} Object this
 */
Ext.draw.ISprite.prototype.sequenceFx = function() {};

/**
 * [Method] Change the attributes of the sprite
 * @param {?=} attrs Object attributes to be changed on the sprite.
 * @param {boolean=} redraw Boolean Flag to immediately draw the change.
 * @return {!Ext.draw.ISprite} Ext.draw.Sprite this
 */
Ext.draw.ISprite.prototype.setAttributes = function(attrs, redraw) {};

/**
 * [Method] Wrapper for setting style properties also takes single object parameter of multiple styles
 * @param {?=} property String/Object The style property to be set, or an object of multiple styles.
 * @param {string=} value String The value to apply to the given property, or null if an object was passed.
 * @return {!Ext.draw.ISprite} Ext.draw.Sprite this
 */
Ext.draw.ISprite.prototype.setStyle = function(property, value) {};

/**
 * [Method] Shows the sprite
 * @param {boolean=} redraw Boolean Flag to immediately draw the change.
 * @return {!Ext.draw.ISprite} Ext.draw.Sprite this
 */
Ext.draw.ISprite.prototype.show = function(redraw) {};

/**
 * [Method] Stops any running effects and clears this object s internal effects queue if it contains any additional effects that
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.draw.ISprite.prototype.stopAnimation = function() {};

/**
 * [Method] Stops any running effects and clears this object s internal effects queue if it contains any additional effects that
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.draw.ISprite.prototype.stopFx = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.draw.ISprite.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.draw.ISprite.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Ensures that all effects queued after syncFx is called on this object are run concurrently
 * @return {?} Object this
 */
Ext.draw.ISprite.prototype.syncFx = function() {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.draw.ISprite.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.dd.IDragSource}
 * @record
 * @struct
 */
Ext.draw.ISpriteDD = function() {};

/**
 * [Method] Creates the proxy element if it does not yet exist
 * @return {void}
 */
Ext.draw.ISpriteDD.prototype.createFrame = function() {};

/**
 * [Method] Returns a reference to the actual element to drag
 * @param {?=} e Object
 * @return {!HTMLElement} HTMLElement the html element
 */
Ext.draw.ISpriteDD.prototype.getDragEl = function(e) {};

/**
 * [Method] Abstract method called during the onMouseMove event while dragging an object
 * @param {?=} e Object
 * @return {void}
 */
Ext.draw.ISpriteDD.prototype.onDrag = function(e) {};

/**
 * [Method] Sets the drag element to the location of the mousedown or click event maintaining the cursor location relative to th
 * @return {void}
 */
Ext.draw.ISpriteDD.prototype.setDragElPos = function() {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.draw.ISurface = function() {};
 /** @type {number} */
Ext.draw.ISurface.prototype.height;
 /** @type {!Array<!Ext.draw.ISprite>} */
Ext.draw.ISurface.prototype.items;
 /** @type {number} */
Ext.draw.ISurface.prototype.width;

/**
 * [Method] Adds a Sprite to the surface
 * @param {?=} args Ext.draw.Sprite[]/Ext.draw.Sprite... One or more Sprite objects or configs.
 * @return {?} Ext.draw.Sprite[]/Ext.draw.Sprite The sprites added.
 */
Ext.draw.ISurface.prototype.add = function(args) {};

/**
 * [Method] Adds one or more CSS classes to the element
 * @param {?=} sprite Object The sprite to add the class to.
 * @param {?=} className String/String[] The CSS class to add, or an array of classes
 * @return {void}
 */
Ext.draw.ISurface.prototype.addCls = function(sprite, className) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.draw.ISurface.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Adds a gradient definition to the Surface
 * @param {?=} gradient Object A gradient config.
 * @return {void}
 */
Ext.draw.ISurface.prototype.addGradient = function(gradient) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.draw.ISurface.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.draw.ISurface.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.draw.ISurface.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.draw.ISurface.prototype.clearManagedListeners = function() {};

/**
 * [Method] Destroys the surface
 * @return {void}
 */
Ext.draw.ISurface.prototype.destroy = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.draw.ISurface.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.draw.ISurface.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.draw.ISurface.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns a new group or an existent group associated with the current surface
 * @param {string=} id String The unique identifier of the group.
 * @return {?} Object The Ext.draw.CompositeSprite.
 */
Ext.draw.ISurface.prototype.getGroup = function(id) {};

/**
 * [Method] Retrieves the id of this component
 * @return {void}
 */
Ext.draw.ISurface.prototype.getId = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.draw.ISurface.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.draw.ISurface.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.draw.ISurface.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.draw.ISurface.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.draw.ISurface.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes a given sprite from the surface optionally destroying the sprite in the process
 * @param {!Ext.draw.ISprite=} sprite Ext.draw.Sprite
 * @param {boolean=} destroySprite Boolean
 * @return {void}
 */
Ext.draw.ISurface.prototype.remove = function(sprite, destroySprite) {};

/**
 * [Method] Removes all sprites from the surface optionally destroying the sprites in the process
 * @param {boolean=} destroySprites Boolean Whether to destroy all sprites when removing them.
 * @return {void}
 */
Ext.draw.ISurface.prototype.removeAll = function(destroySprites) {};

/**
 * [Method] Removes one or more CSS classes from the element
 * @param {?=} sprite Object The sprite to remove the class from.
 * @param {?=} className String/String[] The CSS class to remove, or an array of classes
 * @return {void}
 */
Ext.draw.ISurface.prototype.removeCls = function(sprite, className) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.draw.ISurface.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.draw.ISurface.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.draw.ISurface.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.draw.ISurface.prototype.resumeEvents = function() {};

/**
 * [Method] Sets the size of the surface
 * @param {number=} w Number The new width of the canvas.
 * @param {number=} h Number The new height of the canvas.
 * @return {void}
 */
Ext.draw.ISurface.prototype.setSize = function(w, h) {};

/**
 * [Method] Sets CSS style attributes to an element
 * @param {?=} sprite Object The sprite to add, or an array of classes to
 * @param {?=} styles Object An Object with CSS styles.
 * @return {void}
 */
Ext.draw.ISurface.prototype.setStyle = function(sprite, styles) {};

/**
 * [Method] Changes the text in the sprite element
 * @param {?=} sprite Object The Sprite to change the text.
 * @param {string=} text String The new text to be set.
 * @return {void}
 */
Ext.draw.ISurface.prototype.setText = function(sprite, text) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.draw.ISurface.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.draw.ISurface.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.draw.ISurface.prototype.un = function(eventName, fn, scope) {};
/**
 * @constructor
 * @struct
 */
Ext.draw.Surface = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.draw.Surface.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.draw.Surface.addStatics = function(members) {};

/**
 * [Method] Creates and returns a new concrete Surface instance appropriate for the current environment
 * @param {?=} config Object Initial configuration for the Surface instance
 * @param {!Array<string>=} enginePriority String[] order of implementations to use; the first one that is available in the current environment will be used. Defaults to ['Svg', 'Vml'].
 * @return {?} Object The created Surface or false.
 */
Ext.draw.Surface.create = function(config, enginePriority) {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.draw.Surface.createAlias = function(alias, origin) {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.draw.Surface.getName = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.draw.Surface.implement = function() {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.draw.Surface.override = function(members) {};

/**
 * [Method] Exports a surface in a different format
 * @param {!Ext.draw.ISurface=} surface Ext.draw.Surface The surface to export.
 * @param {?=} config Object The configuration to be passed to the exporter. See the export method for the appropriate exporter for the relevant configuration options
 * @return {?} Object See the return types for the appropriate exporter
 */
Ext.draw.Surface.save = function(surface, config) {};
/**
 * @extends {Ext.draw.IComponent}
 * @record
 * @struct
 */
Ext.draw.IText = function() {};
 /** @type {boolean} */
Ext.draw.IText.prototype.autoSize;
 /** @type {string} */
Ext.draw.IText.prototype.baseCls;
 /** @type {number} */
Ext.draw.IText.prototype.degrees;
 /** @type {string} */
Ext.draw.IText.prototype.styleSelector;
 /** @type {string} */
Ext.draw.IText.prototype.text;
 /** @type {boolean} */
Ext.draw.IText.prototype.viewBox;

/**
 * [Method] The initComponent template method is an important initialization step for a Component
 * @return {void}
 */
Ext.draw.IText.prototype.initComponent = function() {};

/**
 * [Method] Sets the clockwise rotation angle relative to the horizontal axis
 * @param {number=} degrees Number The clockwise angle (in degrees) from the horizontal axis by which the text should be rotated.
 * @return {void}
 */
Ext.draw.IText.prototype.setAngle = function(degrees) {};

/**
 * [Method] Updates this item s text
 * @param {string=} t String The text to display (html not accepted).
 * @return {void}
 */
Ext.draw.IText.prototype.setText = function(t) {};
/**
 * @extends {Ext.container.IContainer}
 * @record
 * @struct
 */
Ext.IEditor = function() {};
 /** @type {string} */
Ext.IEditor.prototype.alignment;
 /** @type {boolean} */
Ext.IEditor.prototype.allowBlur;
 /** @type {?} */
Ext.IEditor.prototype.autoSize;
 /** @type {string} */
Ext.IEditor.prototype.baseCls;
 /** @type {boolean} */
Ext.IEditor.prototype.cancelOnEsc;
 /** @type {boolean} */
Ext.IEditor.prototype.completeOnEnter;
 /** @type {boolean} */
Ext.IEditor.prototype.constrain;
 /** @type {!Ext.form.field.IField} */
Ext.IEditor.prototype.field;
 /** @type {boolean} */
Ext.IEditor.prototype.focusOnToFront;
 /** @type {boolean} */
Ext.IEditor.prototype.hidden;
 /** @type {boolean} */
Ext.IEditor.prototype.hideEl;
 /** @type {boolean} */
Ext.IEditor.prototype.ignoreNoChange;
 /** @type {?} */
Ext.IEditor.prototype.layout;
 /** @type {!Array<number>} */
Ext.IEditor.prototype.offsets;
 /** @type {?} */
Ext.IEditor.prototype.parentEl;
 /** @type {boolean} */
Ext.IEditor.prototype.revertInvalid;
 /** @type {?} */
Ext.IEditor.prototype.shadow;
 /** @type {boolean} */
Ext.IEditor.prototype.swallowKeys;
 /** @type {boolean} */
Ext.IEditor.prototype.updateEl;
 /** @type {?} */
Ext.IEditor.prototype.value;

/**
 * [Method] private
 * @param {?=} ct Object
 * @param {?=} position Object
 * @return {void}
 */
Ext.IEditor.prototype.afterRender = function(ct, position) {};

/**
 * [Method] Cancels the editing process and hides the editor without persisting any changes
 * @param {boolean=} remainVisible Boolean Override the default behavior and keep the editor visible after cancel
 * @return {void}
 */
Ext.IEditor.prototype.cancelEdit = function(remainVisible) {};

/**
 * [Method] Ends the editing process persists the changed value to the underlying field and hides the editor
 * @param {boolean=} remainVisible Boolean Override the default behavior and keep the editor visible after edit
 * @return {void}
 */
Ext.IEditor.prototype.completeEdit = function(remainVisible) {};

/**
 * [Method] Gets the data value of the editor
 * @return {?} Object The data value
 */
Ext.IEditor.prototype.getValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.IEditor.prototype.onHide = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.IEditor.prototype.onShow = function() {};

/**
 * [Method] Realigns the editor to the bound field based on the current alignment config value
 * @param {boolean=} autoSize Boolean True to size the field to the dimensions of the bound element.
 * @return {void}
 */
Ext.IEditor.prototype.realign = function(autoSize) {};

/**
 * [Method] Sets the data value of the editor
 * @param {?=} value Object Any valid value supported by the underlying field
 * @return {void}
 */
Ext.IEditor.prototype.setValue = function(value) {};

/**
 * [Method] Starts the editing process and shows the editor
 * @param {?=} el String/HTMLElement/Ext.Element The element to edit
 * @param {string=} value String A value to initialize the editor with. If a value is not provided, it defaults to the innerHTML of el.
 * @return {void}
 */
Ext.IEditor.prototype.startEdit = function(el, value) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.IElementLoader = function() {};
 /** @type {?} */
Ext.IElementLoader.prototype.ajaxOptions;
 /** @type {?} */
Ext.IElementLoader.prototype.autoLoad;
 /** @type {?} */
Ext.IElementLoader.prototype.baseParams;
 /** @type {?} */
Ext.IElementLoader.prototype.callback;
 /** @type {?} */
Ext.IElementLoader.prototype.failure;
 /** @type {?} */
Ext.IElementLoader.prototype.loadMask;
 /** @type {?} */
Ext.IElementLoader.prototype.params;
 /** @type {?} */
Ext.IElementLoader.prototype.renderer;
 /** @type {?} */
Ext.IElementLoader.prototype.scope;
 /** @type {boolean} */
Ext.IElementLoader.prototype.scripts;
 /** @type {?} */
Ext.IElementLoader.prototype.success;
 /** @type {?} */
Ext.IElementLoader.prototype.target;
 /** @type {string} */
Ext.IElementLoader.prototype.url;
 /** @type {boolean} */
Ext.IElementLoader.prototype.isLoader;

/**
 * [Method] Aborts the active load request
 * @return {void}
 */
Ext.IElementLoader.prototype.abort = function() {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.IElementLoader.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.IElementLoader.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.IElementLoader.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.IElementLoader.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.IElementLoader.prototype.clearManagedListeners = function() {};

/**
 * [Method] Destroys the loader
 * @return {void}
 */
Ext.IElementLoader.prototype.destroy = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.IElementLoader.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.IElementLoader.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.IElementLoader.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the target of this loader
 * @return {!Ext.IComponent} Ext.Component The target or null if none exists.
 */
Ext.IElementLoader.prototype.getTarget = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.IElementLoader.prototype.hasListener = function(eventName) {};

/**
 * [Method] Checks whether the loader is automatically refreshing
 * @return {boolean} Boolean True if the loader is automatically refreshing
 */
Ext.IElementLoader.prototype.isAutoRefreshing = function() {};

/**
 * [Method] Loads new data from the server
 * @param {?=} options Object The options for the request. They can be any configuration option that can be specified for the class, with the exception of the target option. Note that any options passed to the method will override any class defaults.
 * @return {void}
 */
Ext.IElementLoader.prototype.load = function(options) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.IElementLoader.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.IElementLoader.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.IElementLoader.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.IElementLoader.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.IElementLoader.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.IElementLoader.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.IElementLoader.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.IElementLoader.prototype.resumeEvents = function() {};

/**
 * [Method] Sets an Ext Element as the target of this loader
 * @param {?=} target String/HTMLElement/Ext.Element The element or its ID.
 * @return {void}
 */
Ext.IElementLoader.prototype.setTarget = function(target) {};

/**
 * [Method] Automatically refreshes the content over a specified period
 * @param {number=} interval Number The interval to refresh in ms.
 * @param {?=} options Object The options to pass to the load method. See load
 * @return {void}
 */
Ext.IElementLoader.prototype.startAutoRefresh = function(interval, options) {};

/**
 * [Method] Clears any auto refresh
 * @return {void}
 */
Ext.IElementLoader.prototype.stopAutoRefresh = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.IElementLoader.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.IElementLoader.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.IElementLoader.prototype.un = function(eventName, fn, scope) {};
/** @const */
Ext.enums = {};
/**
 * @record
 * @struct
 */
Ext.enums.IFeature = function() {};
 /** @type {string} */
Ext.enums.IFeature.prototype.abstractsummary;
 /** @type {string} */
Ext.enums.IFeature.prototype.feature;
 /** @type {string} */
Ext.enums.IFeature.prototype.grouping;
 /** @type {string} */
Ext.enums.IFeature.prototype.groupingsummary;
 /** @type {string} */
Ext.enums.IFeature.prototype.rowbody;
 /** @type {string} */
Ext.enums.IFeature.prototype.summary;
/**
 * @record
 * @struct
 */
Ext.enums.ILayout = function() {};
 /** @type {string} */
Ext.enums.ILayout.prototype.absolute;
 /** @type {string} */
Ext.enums.ILayout.prototype.accordion;
 /** @type {string} */
Ext.enums.ILayout.prototype.anchor;
 /** @type {string} */
Ext.enums.ILayout.prototype.auto;
 /** @type {string} */
Ext.enums.ILayout.prototype.autocomponent;
 /** @type {string} */
Ext.enums.ILayout.prototype.autocontainer;
 /** @type {string} */
Ext.enums.ILayout.prototype.border;
 /** @type {string} */
Ext.enums.ILayout.prototype.box;
 /** @type {string} */
Ext.enums.ILayout.prototype.card;
 /** @type {string} */
Ext.enums.ILayout.prototype.checkboxgroup;
 /** @type {string} */
Ext.enums.ILayout.prototype.column;
 /** @type {string} */
Ext.enums.ILayout.prototype.container;
 /** @type {string} */
Ext.enums.ILayout.prototype.fit;
 /** @type {string} */
Ext.enums.ILayout.prototype.form;
 /** @type {string} */
Ext.enums.ILayout.prototype.hbox;
 /** @type {string} */
Ext.enums.ILayout.prototype.table;
 /** @type {string} */
Ext.enums.ILayout.prototype.vbox;
/**
 * @record
 * @struct
 */
Ext.enums.IPlugin = function() {};
 /** @type {string} */
Ext.enums.IPlugin.prototype.bufferedrenderer;
 /** @type {string} */
Ext.enums.IPlugin.prototype.cellediting;
 /** @type {string} */
Ext.enums.IPlugin.prototype.gridheaderresizer;
 /** @type {string} */
Ext.enums.IPlugin.prototype.gridviewdragdrop;
 /** @type {string} */
Ext.enums.IPlugin.prototype.rowediting;
 /** @type {string} */
Ext.enums.IPlugin.prototype.rowexpander;
 /** @type {string} */
Ext.enums.IPlugin.prototype.treeviewdragdrop;
/**
 * @record
 * @struct
 */
Ext.enums.IWidget = function() {};
 /** @type {string} */
Ext.enums.IWidget.prototype.actioncolumn;
 /** @type {string} */
Ext.enums.IWidget.prototype.booleancolumn;
 /** @type {string} */
Ext.enums.IWidget.prototype.boundlist;
 /** @type {string} */
Ext.enums.IWidget.prototype.box;
 /** @type {string} */
Ext.enums.IWidget.prototype.button;
 /** @type {string} */
Ext.enums.IWidget.prototype.buttongroup;
 /** @type {string} */
Ext.enums.IWidget.prototype.chart;
 /** @type {string} */
Ext.enums.IWidget.prototype.checkbox;
 /** @type {string} */
Ext.enums.IWidget.prototype.checkboxfield;
 /** @type {string} */
Ext.enums.IWidget.prototype.checkboxgroup;
 /** @type {string} */
Ext.enums.IWidget.prototype.checkcolumn;
 /** @type {string} */
Ext.enums.IWidget.prototype.colormenu;
 /** @type {string} */
Ext.enums.IWidget.prototype.colorpicker;
 /** @type {string} */
Ext.enums.IWidget.prototype.combo;
 /** @type {string} */
Ext.enums.IWidget.prototype.combobox;
 /** @type {string} */
Ext.enums.IWidget.prototype.component;
 /** @type {string} */
Ext.enums.IWidget.prototype.container;
 /** @type {string} */
Ext.enums.IWidget.prototype.cycle;
 /** @type {string} */
Ext.enums.IWidget.prototype.dataview;
 /** @type {string} */
Ext.enums.IWidget.prototype.datecolumn;
 /** @type {string} */
Ext.enums.IWidget.prototype.datefield;
 /** @type {string} */
Ext.enums.IWidget.prototype.datemenu;
 /** @type {string} */
Ext.enums.IWidget.prototype.datepicker;
 /** @type {string} */
Ext.enums.IWidget.prototype.displayfield;
 /** @type {string} */
Ext.enums.IWidget.prototype.draw;
 /** @type {string} */
Ext.enums.IWidget.prototype.editor;
 /** @type {string} */
Ext.enums.IWidget.prototype.field;
 /** @type {string} */
Ext.enums.IWidget.prototype.fieldcontainer;
 /** @type {string} */
Ext.enums.IWidget.prototype.fieldset;
 /** @type {string} */
Ext.enums.IWidget.prototype.filebutton;
 /** @type {string} */
Ext.enums.IWidget.prototype.filefield;
 /** @type {string} */
Ext.enums.IWidget.prototype.fileuploadfield;
 /** @type {string} */
Ext.enums.IWidget.prototype.flash;
 /** @type {string} */
Ext.enums.IWidget.prototype.form;
 /** @type {string} */
Ext.enums.IWidget.prototype.grid;
 /** @type {string} */
Ext.enums.IWidget.prototype.gridcolumn;
 /** @type {string} */
Ext.enums.IWidget.prototype.gridpanel;
 /** @type {string} */
Ext.enums.IWidget.prototype.gridview;
 /** @type {string} */
Ext.enums.IWidget.prototype.header;
 /** @type {string} */
Ext.enums.IWidget.prototype.headercontainer;
 /** @type {string} */
Ext.enums.IWidget.prototype.hidden;
 /** @type {string} */
Ext.enums.IWidget.prototype.hiddenfield;
 /** @type {string} */
Ext.enums.IWidget.prototype.htmleditor;
 /** @type {string} */
Ext.enums.IWidget.prototype.image;
 /** @type {string} */
Ext.enums.IWidget.prototype.imagecomponent;
 /** @type {string} */
Ext.enums.IWidget.prototype.jsonpstore;
 /** @type {string} */
Ext.enums.IWidget.prototype.label;
 /** @type {string} */
Ext.enums.IWidget.prototype.loadmask;
 /** @type {string} */
Ext.enums.IWidget.prototype.menu;
 /** @type {string} */
Ext.enums.IWidget.prototype.menucheckitem;
 /** @type {string} */
Ext.enums.IWidget.prototype.menuitem;
 /** @type {string} */
Ext.enums.IWidget.prototype.menuseparator;
 /** @type {string} */
Ext.enums.IWidget.prototype.messagebox;
 /** @type {string} */
Ext.enums.IWidget.prototype.multislider;
 /** @type {string} */
Ext.enums.IWidget.prototype.numbercolumn;
 /** @type {string} */
Ext.enums.IWidget.prototype.numberfield;
 /** @type {string} */
Ext.enums.IWidget.prototype.pagingtoolbar;
 /** @type {string} */
Ext.enums.IWidget.prototype.panel;
 /** @type {string} */
Ext.enums.IWidget.prototype.pickerfield;
 /** @type {string} */
Ext.enums.IWidget.prototype.progressbar;
 /** @type {string} */
Ext.enums.IWidget.prototype.propertygrid;
 /** @type {string} */
Ext.enums.IWidget.prototype.quicktip;
 /** @type {string} */
Ext.enums.IWidget.prototype.radio;
 /** @type {string} */
Ext.enums.IWidget.prototype.radiofield;
 /** @type {string} */
Ext.enums.IWidget.prototype.radiogroup;
 /** @type {string} */
Ext.enums.IWidget.prototype.rownumberer;
 /** @type {string} */
Ext.enums.IWidget.prototype.slider;
 /** @type {string} */
Ext.enums.IWidget.prototype.sliderfield;
 /** @type {string} */
Ext.enums.IWidget.prototype.slidertip;
 /** @type {string} */
Ext.enums.IWidget.prototype.spinnerfield;
 /** @type {string} */
Ext.enums.IWidget.prototype.splitbutton;
 /** @type {string} */
Ext.enums.IWidget.prototype.splitter;
 /** @type {string} */
Ext.enums.IWidget.prototype.tab;
 /** @type {string} */
Ext.enums.IWidget.prototype.tabbar;
 /** @type {string} */
Ext.enums.IWidget.prototype.tablepanel;
 /** @type {string} */
Ext.enums.IWidget.prototype.tableview;
 /** @type {string} */
Ext.enums.IWidget.prototype.tabpanel;
 /** @type {string} */
Ext.enums.IWidget.prototype.tbfill;
 /** @type {string} */
Ext.enums.IWidget.prototype.tbitem;
 /** @type {string} */
Ext.enums.IWidget.prototype.tbseparator;
 /** @type {string} */
Ext.enums.IWidget.prototype.tbspacer;
 /** @type {string} */
Ext.enums.IWidget.prototype.tbtext;
 /** @type {string} */
Ext.enums.IWidget.prototype.templatecolumn;
 /** @type {string} */
Ext.enums.IWidget.prototype.text;
 /** @type {string} */
Ext.enums.IWidget.prototype.textarea;
 /** @type {string} */
Ext.enums.IWidget.prototype.textareafield;
 /** @type {string} */
Ext.enums.IWidget.prototype.textfield;
 /** @type {string} */
Ext.enums.IWidget.prototype.timefield;
 /** @type {string} */
Ext.enums.IWidget.prototype.timepicker;
 /** @type {string} */
Ext.enums.IWidget.prototype.tip;
 /** @type {string} */
Ext.enums.IWidget.prototype.tool;
 /** @type {string} */
Ext.enums.IWidget.prototype.toolbar;
 /** @type {string} */
Ext.enums.IWidget.prototype.tooltip;
 /** @type {string} */
Ext.enums.IWidget.prototype.treepanel;
 /** @type {string} */
Ext.enums.IWidget.prototype.treeview;
 /** @type {string} */
Ext.enums.IWidget.prototype.trigger;
 /** @type {string} */
Ext.enums.IWidget.prototype.triggerfield;
 /** @type {string} */
Ext.enums.IWidget.prototype.viewport;
 /** @type {string} */
Ext.enums.IWidget.prototype.window;
/**
 * @record
 * @struct
 */
Ext.IError = function() {};
 /** @type {boolean} */
Ext.IError.prototype.ignore;
 /** @type {boolean} */
Ext.IError.prototype.notify;

/**
 * [Method] Provides a custom string representation of the error object
 * @return {string} String The error message. If raised from within the Ext 4 class system, the error message will also include the raising class and method names, if available.
 */
Ext.IError.prototype.toString = function() {};
/**
 * @constructor
 * @struct
 */
Ext.Error = function() {};

/**
 * [Method] Globally handle any Ext errors that may be raised optionally providing custom logic to handle different errors indiv
 * @param {!Ext.IError=} err Ext.Error The Ext.Error object being raised. It will contain any attributes that were originally raised with it, plus properties about the method and class from which the error originated (if raised from a class that uses the Ext 4 class system).
 * @return {void}
 */
Ext.Error.handle = function(err) {};

/**
 * [Method] Raise an error that can include additional data and supports automatic console logging if available
 * @param {?=} err String/Object The error message string, or an object containing the attribute "msg" that will be used as the error message. Any other data included in the object will also be logged to the browser console, if available.
 * @return {void}
 */
Ext.Error.raise = function(err) {};
/**
 * @record
 * @struct
 */
Ext.IEventManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.EventManager = function() {};
 /** @type {?} */
Ext.EventManager.idleEvent;

/**
 * [Method] Appends an event handler to an element
 * @param {?=} el String/Ext.Element/HTMLElement/Window The html element or id to assign the event handler to.
 * @param {string=} eventName String The name of the event to listen for.
 * @param {?=} handler Function/String The handler function the event invokes. A String parameter is assumed to be method name in scope object, or Element object if no scope is provided.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. Defaults to the Element.
 * @param {?=} options Object An object containing handler configuration properties. This may contain any of the following properties (See Ext.Element.addListener for examples of how to use these options.):
 * @return {void}
 */
Ext.EventManager.addListener = function(el, eventName, handler, scope, options) {};

/**
 * [Method] Get the id of the element
 * @param {?=} element HTMLElement/Ext.Element The element to get the id for.
 * @return {string} String id
 */
Ext.EventManager.getId = function(element) {};

/**
 * [Method] Indicates which event to use for getting key presses
 * @return {string} String The appropriate event name.
 */
Ext.EventManager.getKeyEvent = function() {};

/**
 * [Method] Gets the x coordinate from the event
 * @param {?=} event Object The event
 * @return {number} Number The x coordinate
 */
Ext.EventManager.getPageX = function(event) {};

/**
 * [Method] Gets the x amp y coordinate from the event
 * @param {?=} event Object The event
 * @return {!Array<number>} Number[] The x/y coordinate
 */
Ext.EventManager.getPageXY = function(event) {};

/**
 * [Method] Gets the y coordinate from the event
 * @param {?=} event Object The event
 * @return {number} Number The y coordinate
 */
Ext.EventManager.getPageY = function(event) {};

/**
 * [Method] Gets the related target from the event
 * @param {?=} event Object The event
 * @return {!HTMLElement} HTMLElement The related target.
 */
Ext.EventManager.getRelatedTarget = function(event) {};

/**
 * [Method] Gets the target of the event
 * @param {?=} event Object The event
 * @return {!HTMLElement} HTMLElement target
 */
Ext.EventManager.getTarget = function(event) {};

/**
 * [Method] Appends an event handler to an element
 * @param {?=} el String/Ext.Element/HTMLElement/Window The html element or id to assign the event handler to.
 * @param {string=} eventName String The name of the event to listen for.
 * @param {?=} handler Function/String The handler function the event invokes. A String parameter is assumed to be method name in scope object, or Element object if no scope is provided.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. Defaults to the Element.
 * @param {?=} options Object An object containing handler configuration properties. This may contain any of the following properties (See Ext.Element.addListener for examples of how to use these options.):
 * @return {void}
 */
Ext.EventManager.on = function(el, eventName, handler, scope, options) {};

/**
 * [Method] Adds a listener to be notified when the document is ready before onload and before images are loaded
 * @param {?=} fn Function The method the event invokes.
 * @param {?=} scope Object The scope (this reference) in which the handler function executes. Defaults to the browser window.
 * @param {?=} options Object Options object as passed to Ext.Element.addListener.
 * @return {void}
 */
Ext.EventManager.onDocumentReady = function(fn, scope, options) {};

/**
 * [Method] Adds a listener to be notified when the browser window is resized and provides resize event buffering 100 millisecon
 * @param {?=} fn Function The handler function the window resize event invokes.
 * @param {?=} scope Object The scope (this reference) in which the handler function executes. Defaults to the browser window.
 * @param {boolean=} options Boolean Options object as passed to Ext.Element.addListener
 * @return {void}
 */
Ext.EventManager.onWindowResize = function(fn, scope, options) {};

/**
 * [Method] Adds a listener to be notified when the browser window is unloaded
 * @param {?=} fn Function The handler function the window unload event invokes.
 * @param {?=} scope Object The scope (this reference) in which the handler function executes. Defaults to the browser window.
 * @param {boolean=} options Boolean Options object as passed to Ext.Element.addListener
 * @return {void}
 */
Ext.EventManager.onWindowUnload = function(fn, scope, options) {};

/**
 * [Method] This strategy has minimal benefits for Sencha solutions that build themselves ie
 * @return {void}
 */
Ext.EventManager.pollScroll = function() {};

/**
 * [Method] Prevents the browsers default handling of the event
 * @param {!Event=} event Event The event to prevent the default
 * @return {void}
 */
Ext.EventManager.preventDefault = function(event) {};

/**
 * [Method] Recursively removes all previous added listeners from an element and its children
 * @param {?=} el String/Ext.Element/HTMLElement/Window The id or html element from which to remove all event handlers.
 * @param {string=} eventName String The name of the event.
 * @return {void}
 */
Ext.EventManager.purgeElement = function(el, eventName) {};

/**
 * [Method] Removes all event handers from an element
 * @param {?=} el String/Ext.Element/HTMLElement/Window The id or html element from which to remove all event handlers.
 * @return {void}
 */
Ext.EventManager.removeAll = function(el) {};

/**
 * [Method] Removes an event handler from an element
 * @param {?=} el String/Ext.Element/HTMLElement/Window The id or html element from which to remove the listener.
 * @param {string=} eventName String The name of the event.
 * @param {?=} fn Function The handler function to remove. This must be a reference to the function passed into the addListener call.
 * @param {?=} scope Object If a scope (this reference) was specified when the listener was added, then this must refer to the same object.
 * @return {void}
 */
Ext.EventManager.removeListener = function(el, eventName, fn, scope) {};

/**
 * [Method] Removes the passed window resize listener
 * @param {?=} fn Function The method the event invokes
 * @param {?=} scope Object The scope of handler
 * @return {void}
 */
Ext.EventManager.removeResizeListener = function(fn, scope) {};

/**
 * [Method] Removes the passed window unload listener
 * @param {?=} fn Function The method the event invokes
 * @param {?=} scope Object The scope of handler
 * @return {void}
 */
Ext.EventManager.removeUnloadListener = function(fn, scope) {};

/**
 * [Method] Stop the event preventDefault and stopPropagation
 * @param {!Event=} event Event The event to stop
 * @return {void}
 */
Ext.EventManager.stopEvent = function(event) {};

/**
 * [Method] Cancels bubbling of the event
 * @param {!Event=} event Event The event to stop bubbling.
 * @return {void}
 */
Ext.EventManager.stopPropagation = function(event) {};

/**
 * [Method] Removes an event handler from an element
 * @param {?=} el String/Ext.Element/HTMLElement/Window The id or html element from which to remove the listener.
 * @param {string=} eventName String The name of the event.
 * @param {?=} fn Function The handler function to remove. This must be a reference to the function passed into the addListener call.
 * @param {?=} scope Object If a scope (this reference) was specified when the listener was added, then this must refer to the same object.
 * @return {void}
 */
Ext.EventManager.un = function(el, eventName, fn, scope) {};
/**
 * @record
 * @struct
 */
Ext.IEventObject = function() {};
/**
 * @constructor
 * @struct
 */
Ext.EventObject = function() {};
 /** @type {number} */
Ext.EventObject.A;
 /** @type {number} */
Ext.EventObject.ALT;
 /** @type {number} */
Ext.EventObject.B;
 /** @type {number} */
Ext.EventObject.BACKSPACE;
 /** @type {number} */
Ext.EventObject.C;
 /** @type {number} */
Ext.EventObject.CAPS_LOCK;
 /** @type {number} */
Ext.EventObject.CONTEXT_MENU;
 /** @type {number} */
Ext.EventObject.CTRL;
 /** @type {number} */
Ext.EventObject.D;
 /** @type {number} */
Ext.EventObject.DELETE;
 /** @type {number} */
Ext.EventObject.DOWN;
 /** @type {number} */
Ext.EventObject.E;
 /** @type {number} */
Ext.EventObject.EIGHT;
 /** @type {number} */
Ext.EventObject.END;
 /** @type {number} */
Ext.EventObject.ENTER;
 /** @type {number} */
Ext.EventObject.ESC;
 /** @type {number} */
Ext.EventObject.F;
 /** @type {number} */
Ext.EventObject.F1;
 /** @type {number} */
Ext.EventObject.F10;
 /** @type {number} */
Ext.EventObject.F11;
 /** @type {number} */
Ext.EventObject.F12;
 /** @type {number} */
Ext.EventObject.F2;
 /** @type {number} */
Ext.EventObject.F3;
 /** @type {number} */
Ext.EventObject.F4;
 /** @type {number} */
Ext.EventObject.F5;
 /** @type {number} */
Ext.EventObject.F6;
 /** @type {number} */
Ext.EventObject.F7;
 /** @type {number} */
Ext.EventObject.F8;
 /** @type {number} */
Ext.EventObject.F9;
 /** @type {number} */
Ext.EventObject.FIVE;
 /** @type {number} */
Ext.EventObject.FOUR;
 /** @type {number} */
Ext.EventObject.G;
 /** @type {number} */
Ext.EventObject.H;
 /** @type {number} */
Ext.EventObject.HOME;
 /** @type {number} */
Ext.EventObject.I;
 /** @type {number} */
Ext.EventObject.INSERT;
 /** @type {number} */
Ext.EventObject.J;
 /** @type {number} */
Ext.EventObject.K;
 /** @type {number} */
Ext.EventObject.L;
 /** @type {number} */
Ext.EventObject.LEFT;
 /** @type {number} */
Ext.EventObject.M;
 /** @type {number} */
Ext.EventObject.N;
 /** @type {number} */
Ext.EventObject.NINE;
 /** @type {number} */
Ext.EventObject.NUM_CENTER;
 /** @type {number} */
Ext.EventObject.NUM_DIVISION;
 /** @type {number} */
Ext.EventObject.NUM_EIGHT;
 /** @type {number} */
Ext.EventObject.NUM_FIVE;
 /** @type {number} */
Ext.EventObject.NUM_FOUR;
 /** @type {number} */
Ext.EventObject.NUM_MINUS;
 /** @type {number} */
Ext.EventObject.NUM_MULTIPLY;
 /** @type {number} */
Ext.EventObject.NUM_NINE;
 /** @type {number} */
Ext.EventObject.NUM_ONE;
 /** @type {number} */
Ext.EventObject.NUM_PERIOD;
 /** @type {number} */
Ext.EventObject.NUM_PLUS;
 /** @type {number} */
Ext.EventObject.NUM_SEVEN;
 /** @type {number} */
Ext.EventObject.NUM_SIX;
 /** @type {number} */
Ext.EventObject.NUM_THREE;
 /** @type {number} */
Ext.EventObject.NUM_TWO;
 /** @type {number} */
Ext.EventObject.NUM_ZERO;
 /** @type {number} */
Ext.EventObject.O;
 /** @type {number} */
Ext.EventObject.ONE;
 /** @type {number} */
Ext.EventObject.P;
 /** @type {number} */
Ext.EventObject.PAGE_DOWN;
 /** @type {number} */
Ext.EventObject.PAGE_UP;
 /** @type {number} */
Ext.EventObject.PAUSE;
 /** @type {number} */
Ext.EventObject.PRINT_SCREEN;
 /** @type {number} */
Ext.EventObject.Q;
 /** @type {number} */
Ext.EventObject.R;
 /** @type {number} */
Ext.EventObject.RETURN;
 /** @type {number} */
Ext.EventObject.RIGHT;
 /** @type {number} */
Ext.EventObject.S;
 /** @type {number} */
Ext.EventObject.SEVEN;
 /** @type {number} */
Ext.EventObject.SHIFT;
 /** @type {number} */
Ext.EventObject.SIX;
 /** @type {number} */
Ext.EventObject.SPACE;
 /** @type {number} */
Ext.EventObject.T;
 /** @type {number} */
Ext.EventObject.TAB;
 /** @type {number} */
Ext.EventObject.THREE;
 /** @type {number} */
Ext.EventObject.TWO;
 /** @type {number} */
Ext.EventObject.U;
 /** @type {number} */
Ext.EventObject.UP;
 /** @type {number} */
Ext.EventObject.V;
 /** @type {number} */
Ext.EventObject.W;
 /** @type {number} */
Ext.EventObject.WHEEL_SCALE;
 /** @type {number} */
Ext.EventObject.X;
 /** @type {number} */
Ext.EventObject.Y;
 /** @type {number} */
Ext.EventObject.Z;
 /** @type {number} */
Ext.EventObject.ZERO;
 /** @type {boolean} */
Ext.EventObject.altKey;
 /** @type {boolean} */
Ext.EventObject.ctrlKey;
 /** @type {boolean} */
Ext.EventObject.shiftKey;

/**
 * [Method] Correctly scales a given wheel delta
 * @param {number=} delta Number The delta value.
 * @return {void}
 */
Ext.EventObject.correctWheelDelta = function(delta) {};

/**
 * [Method] Gets the character code for the event
 * @return {number} Number
 */
Ext.EventObject.getCharCode = function() {};

/**
 * [Method] Returns a normalized keyCode for the event
 * @return {number} Number The key code
 */
Ext.EventObject.getKey = function() {};

/**
 * [Method] Gets the x coordinate of the event
 * @return {number} Number
 */
Ext.EventObject.getPageX = function() {};

/**
 * [Method] Gets the y coordinate of the event
 * @return {number} Number
 */
Ext.EventObject.getPageY = function() {};

/**
 * [Method] Returns a point object that consists of the object coordinates
 * @return {!Ext.util.IPoint} Ext.util.Point point
 */
Ext.EventObject.getPoint = function() {};

/**
 * [Method] Gets the related target
 * @param {string=} selector String A simple selector to filter the target or look for an ancestor of the target
 * @param {?=} maxDepth Number/HTMLElement The max depth to search as a number or element (defaults to 10 || document.body)
 * @param {boolean=} returnEl Boolean True to return a Ext.Element object instead of DOM node
 * @return {!HTMLElement} HTMLElement
 */
Ext.EventObject.getRelatedTarget = function(selector, maxDepth, returnEl) {};

/**
 * [Method] Gets the target for the event
 * @param {string=} selector String A simple selector to filter the target or look for an ancestor of the target
 * @param {?=} maxDepth Number/HTMLElement The max depth to search as a number or element (defaults to 10 || document.body)
 * @param {boolean=} returnEl Boolean True to return a Ext.Element object instead of DOM node
 * @return {!HTMLElement} HTMLElement
 */
Ext.EventObject.getTarget = function(selector, maxDepth, returnEl) {};

/**
 * [Method] Normalizes mouse wheel y delta across browsers
 * @return {number} Number The mouse wheel y-delta
 */
Ext.EventObject.getWheelDelta = function() {};

/**
 * [Method] Returns the mouse wheel deltas for this event
 * @return {?} Object An object with "x" and "y" properties holding the mouse wheel deltas.
 */
Ext.EventObject.getWheelDeltas = function() {};

/**
 * [Method] Gets the x coordinate of the event
 * @return {number} Number
 */
Ext.EventObject.getX = function() {};

/**
 * [Method] Gets the page coordinates of the event
 * @return {!Array<number>} Number[] The xy values like [x, y]
 */
Ext.EventObject.getXY = function() {};

/**
 * [Method] Gets the y coordinate of the event
 * @return {number} Number
 */
Ext.EventObject.getY = function() {};

/**
 * [Method] Returns true if the control meta shift or alt key was pressed during this event
 * @return {boolean} Boolean
 */
Ext.EventObject.hasModifier = function() {};

/**
 * [Method] Injects a DOM event using the data in this object and optionally a new target
 * @param {?=} target Ext.Element/HTMLElement If specified, the target for the event. This is likely to be used when relaying a DOM event. If not specified, getTarget is used to determine the target.
 * @return {void}
 */
Ext.EventObject.injectEvent = function(target) {};

/**
 * [Method] Checks if the key pressed was a navigation key
 * @return {boolean} Boolean True if the press is a navigation keypress
 */
Ext.EventObject.isNavKeyPress = function() {};

/**
 * [Method] Checks if the key pressed was a special key
 * @return {boolean} Boolean True if the press is a special keypress
 */
Ext.EventObject.isSpecialKey = function() {};

/**
 * [Method] Prevents the browsers default handling of the event
 * @return {void}
 */
Ext.EventObject.preventDefault = function() {};

/**
 * [Method] Stop the event preventDefault and stopPropagation
 * @return {void}
 */
Ext.EventObject.stopEvent = function() {};

/**
 * [Method] Cancels bubbling of the event
 * @return {void}
 */
Ext.EventObject.stopPropagation = function() {};

/**
 * [Method] Returns true if the target of this event is a child of el
 * @param {?=} el String/HTMLElement/Ext.Element The id, DOM element or Ext.Element to check
 * @param {boolean=} related Boolean true to test if the related target is within el instead of the target
 * @param {boolean=} allowEl Boolean true to also check if the passed element is the target or related target
 * @return {boolean} Boolean
 */
Ext.EventObject.within = function(el, related, allowEl) {};
/** @const */
Ext.flash = {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.flash.IComponent = function() {};
 /** @type {string} */
Ext.flash.IComponent.prototype.backgroundColor;
 /** @type {boolean} */
Ext.flash.IComponent.prototype.expressInstall;
 /** @type {?} */
Ext.flash.IComponent.prototype.flashAttributes;
 /** @type {?} */
Ext.flash.IComponent.prototype.flashParams;
 /** @type {?} */
Ext.flash.IComponent.prototype.flashVars;
 /** @type {string} */
Ext.flash.IComponent.prototype.flashVersion;
 /** @type {?} */
Ext.flash.IComponent.prototype.renderTpl;
 /** @type {?} */
Ext.flash.IComponent.prototype.swfHeight;
 /** @type {?} */
Ext.flash.IComponent.prototype.swfWidth;
 /** @type {string} */
Ext.flash.IComponent.prototype.url;
 /** @type {string} */
Ext.flash.IComponent.prototype.wmode;
 /** @type {!Ext.IElement} */
Ext.flash.IComponent.prototype.swf;
 /** @type {string} */
Ext.flash.IComponent.prototype.EXPRESS_INSTALL_URL;

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.flash.IComponent.prototype.afterRender = function() {};

/**
 * [Method] Invoked before the Component is destroyed
 * @return {void}
 */
Ext.flash.IComponent.prototype.beforeDestroy = function() {};

/**
 * [Method] Retrieves the id of the SWF object embed element
 * @return {void}
 */
Ext.flash.IComponent.prototype.getSwfId = function() {};

/**
 * [Method] The initComponent template method is an important initialization step for a Component
 * @return {void}
 */
Ext.flash.IComponent.prototype.initComponent = function() {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.IFlashComponent = function() {};
 /** @type {string} */
Ext.IFlashComponent.prototype.backgroundColor;
 /** @type {boolean} */
Ext.IFlashComponent.prototype.expressInstall;
 /** @type {?} */
Ext.IFlashComponent.prototype.flashAttributes;
 /** @type {?} */
Ext.IFlashComponent.prototype.flashParams;
 /** @type {?} */
Ext.IFlashComponent.prototype.flashVars;
 /** @type {string} */
Ext.IFlashComponent.prototype.flashVersion;
 /** @type {?} */
Ext.IFlashComponent.prototype.renderTpl;
 /** @type {?} */
Ext.IFlashComponent.prototype.swfHeight;
 /** @type {?} */
Ext.IFlashComponent.prototype.swfWidth;
 /** @type {string} */
Ext.IFlashComponent.prototype.url;
 /** @type {string} */
Ext.IFlashComponent.prototype.wmode;
 /** @type {!Ext.IElement} */
Ext.IFlashComponent.prototype.swf;
 /** @type {string} */
Ext.IFlashComponent.prototype.EXPRESS_INSTALL_URL;

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.IFlashComponent.prototype.afterRender = function() {};

/**
 * [Method] Invoked before the Component is destroyed
 * @return {void}
 */
Ext.IFlashComponent.prototype.beforeDestroy = function() {};

/**
 * [Method] Retrieves the id of the SWF object embed element
 * @return {void}
 */
Ext.IFlashComponent.prototype.getSwfId = function() {};

/**
 * [Method] The initComponent template method is an important initialization step for a Component
 * @return {void}
 */
Ext.IFlashComponent.prototype.initComponent = function() {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.IFocusManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.FocusManager = function() {};
 /** @type {boolean} */
Ext.FocusManager.enabled;
 /** @type {!Ext.IComponent} */
Ext.FocusManager.focusedCmp;
 /** @type {?} */
Ext.FocusManager.hasListeners;
 /** @type {boolean} */
Ext.FocusManager.isObservable;
 /** @type {!Ext.IClass} */
Ext.FocusManager.self;
 /** @type {!Array<string>} */
Ext.FocusManager.whitelist;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.FocusManager.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.FocusManager.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.FocusManager.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Adds the specified xtype to the whitelist
 * @param {?=} xtype String/String[] Adds the xtype(s) to the whitelist.
 * @return {void}
 */
Ext.FocusManager.addXTypeToWhitelist = function(xtype) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.FocusManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.FocusManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.FocusManager.callSuper = function(args) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.FocusManager.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.FocusManager.clearManagedListeners = function() {};

/**
 * [Method] Disables the FocusManager by turning of all automatic focus management and keyboard navigation
 * @return {void}
 */
Ext.FocusManager.disable = function() {};

/**
 * [Method] Enables the FocusManager by turning on all automatic focus management and keyboard navigation
 * @param {?=} options Boolean/Object Either true/false to turn on the focus frame, or an object with the following options:
 * @return {void}
 */
Ext.FocusManager.enable = function(options) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.FocusManager.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.FocusManager.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.FocusManager.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.FocusManager.getInitialConfig = function(name) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.FocusManager.hasListener = function(eventName) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.FocusManager.initConfig = function(config) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.FocusManager.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.FocusManager.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.FocusManager.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.FocusManager.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.FocusManager.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.FocusManager.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Removes the specified xtype from the whitelist
 * @param {?=} xtype String/String[] Removes the xtype(s) from the whitelist.
 * @return {void}
 */
Ext.FocusManager.removeXTypeFromWhitelist = function(xtype) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.FocusManager.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.FocusManager.resumeEvents = function() {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.FocusManager.statics = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.FocusManager.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.FocusManager.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.FocusManager.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.IFocusMgr = function() {};
/**
 * @constructor
 * @struct
 */
Ext.FocusMgr = function() {};
 /** @type {boolean} */
Ext.FocusMgr.enabled;
 /** @type {!Ext.IComponent} */
Ext.FocusMgr.focusedCmp;
 /** @type {?} */
Ext.FocusMgr.hasListeners;
 /** @type {boolean} */
Ext.FocusMgr.isObservable;
 /** @type {!Ext.IClass} */
Ext.FocusMgr.self;
 /** @type {!Array<string>} */
Ext.FocusMgr.whitelist;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.FocusMgr.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.FocusMgr.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.FocusMgr.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Adds the specified xtype to the whitelist
 * @param {?=} xtype String/String[] Adds the xtype(s) to the whitelist.
 * @return {void}
 */
Ext.FocusMgr.addXTypeToWhitelist = function(xtype) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.FocusMgr.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.FocusMgr.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.FocusMgr.callSuper = function(args) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.FocusMgr.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.FocusMgr.clearManagedListeners = function() {};

/**
 * [Method] Disables the FocusManager by turning of all automatic focus management and keyboard navigation
 * @return {void}
 */
Ext.FocusMgr.disable = function() {};

/**
 * [Method] Enables the FocusManager by turning on all automatic focus management and keyboard navigation
 * @param {?=} options Boolean/Object Either true/false to turn on the focus frame, or an object with the following options:
 * @return {void}
 */
Ext.FocusMgr.enable = function(options) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.FocusMgr.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.FocusMgr.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.FocusMgr.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.FocusMgr.getInitialConfig = function(name) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.FocusMgr.hasListener = function(eventName) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.FocusMgr.initConfig = function(config) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.FocusMgr.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.FocusMgr.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.FocusMgr.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.FocusMgr.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.FocusMgr.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.FocusMgr.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Removes the specified xtype from the whitelist
 * @param {?=} xtype String/String[] Removes the xtype(s) from the whitelist.
 * @return {void}
 */
Ext.FocusMgr.removeXTypeFromWhitelist = function(xtype) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.FocusMgr.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.FocusMgr.resumeEvents = function() {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.FocusMgr.statics = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.FocusMgr.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.FocusMgr.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.FocusMgr.un = function(eventName, fn, scope) {};
/** @const */
Ext.form = {};
/** @const */
Ext.form.action = {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.form.action.IAction = function() {};
 /** @type {?} */
Ext.form.action.IAction.prototype.failure;
 /** @type {!Ext.form.IBasic} */
Ext.form.action.IAction.prototype.form;
 /** @type {?} */
Ext.form.action.IAction.prototype.headers;
 /** @type {string} */
Ext.form.action.IAction.prototype.method;
 /** @type {?} */
Ext.form.action.IAction.prototype.params;
 /** @type {boolean} */
Ext.form.action.IAction.prototype.reset;
 /** @type {?} */
Ext.form.action.IAction.prototype.scope;
 /** @type {boolean} */
Ext.form.action.IAction.prototype.submitEmptyText;
 /** @type {?} */
Ext.form.action.IAction.prototype.success;
 /** @type {number} */
Ext.form.action.IAction.prototype.timeout;
 /** @type {string} */
Ext.form.action.IAction.prototype.url;
 /** @type {string} */
Ext.form.action.IAction.prototype.waitMsg;
 /** @type {string} */
Ext.form.action.IAction.prototype.waitTitle;
 /** @type {string} */
Ext.form.action.IAction.prototype.failureType;
 /** @type {?} */
Ext.form.action.IAction.prototype.response;
 /** @type {?} */
Ext.form.action.IAction.prototype.result;
 /** @type {string} */
Ext.form.action.IAction.prototype.type;
 /** @type {string} */
Ext.form.action.IAction.prototype.CLIENT_INVALID;
 /** @type {string} */
Ext.form.action.IAction.prototype.CONNECT_FAILURE;
 /** @type {string} */
Ext.form.action.IAction.prototype.LOAD_FAILURE;
 /** @type {string} */
Ext.form.action.IAction.prototype.SERVER_INVALID;

/**
 * [Method] Invokes this action using the current configuration
 * @return {void}
 */
Ext.form.action.IAction.prototype.run = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.form.IAction = function() {};
 /** @type {?} */
Ext.form.IAction.prototype.failure;
 /** @type {!Ext.form.IBasic} */
Ext.form.IAction.prototype.form;
 /** @type {?} */
Ext.form.IAction.prototype.headers;
 /** @type {string} */
Ext.form.IAction.prototype.method;
 /** @type {?} */
Ext.form.IAction.prototype.params;
 /** @type {boolean} */
Ext.form.IAction.prototype.reset;
 /** @type {?} */
Ext.form.IAction.prototype.scope;
 /** @type {boolean} */
Ext.form.IAction.prototype.submitEmptyText;
 /** @type {?} */
Ext.form.IAction.prototype.success;
 /** @type {number} */
Ext.form.IAction.prototype.timeout;
 /** @type {string} */
Ext.form.IAction.prototype.url;
 /** @type {string} */
Ext.form.IAction.prototype.waitMsg;
 /** @type {string} */
Ext.form.IAction.prototype.waitTitle;
 /** @type {string} */
Ext.form.IAction.prototype.failureType;
 /** @type {?} */
Ext.form.IAction.prototype.response;
 /** @type {?} */
Ext.form.IAction.prototype.result;
 /** @type {string} */
Ext.form.IAction.prototype.type;
 /** @type {string} */
Ext.form.IAction.prototype.CLIENT_INVALID;
 /** @type {string} */
Ext.form.IAction.prototype.CONNECT_FAILURE;
 /** @type {string} */
Ext.form.IAction.prototype.LOAD_FAILURE;
 /** @type {string} */
Ext.form.IAction.prototype.SERVER_INVALID;

/**
 * [Method] Invokes this action using the current configuration
 * @return {void}
 */
Ext.form.IAction.prototype.run = function() {};
/**
 * @extends {Ext.form.action.ILoad}
 * @record
 * @struct
 */
Ext.form.action.IDirectLoad = function() {};
 /** @type {string} */
Ext.form.action.IDirectLoad.prototype.type;
/**
 * @extends {Ext.form.action.ISubmit}
 * @record
 * @struct
 */
Ext.form.action.IDirectSubmit = function() {};
 /** @type {string} */
Ext.form.action.IDirectSubmit.prototype.type;
/**
 * @extends {Ext.form.action.IAction}
 * @record
 * @struct
 */
Ext.form.action.ILoad = function() {};
 /** @type {string} */
Ext.form.action.ILoad.prototype.type;
/**
 * @extends {Ext.form.action.ISubmit}
 * @record
 * @struct
 */
Ext.form.action.IStandardSubmit = function() {};
 /** @type {string} */
Ext.form.action.IStandardSubmit.prototype.target;
/**
 * @extends {Ext.form.action.IAction}
 * @record
 * @struct
 */
Ext.form.action.ISubmit = function() {};
 /** @type {boolean} */
Ext.form.action.ISubmit.prototype.clientValidation;
 /** @type {string} */
Ext.form.action.ISubmit.prototype.type;

/**
 * [Method] inherit docs
 * @return {void}
 */
Ext.form.action.ISubmit.prototype.run = function() {};
/**
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.form.IBasic = function() {};
 /** @type {?} */
Ext.form.IBasic.prototype.api;
 /** @type {?} */
Ext.form.IBasic.prototype.baseParams;
 /** @type {?} */
Ext.form.IBasic.prototype.errorReader;
 /** @type {boolean} */
Ext.form.IBasic.prototype.jsonSubmit;
 /** @type {string} */
Ext.form.IBasic.prototype.method;
 /** @type {?} */
Ext.form.IBasic.prototype.paramOrder;
 /** @type {boolean} */
Ext.form.IBasic.prototype.paramsAsHash;
 /** @type {?} */
Ext.form.IBasic.prototype.reader;
 /** @type {boolean} */
Ext.form.IBasic.prototype.standardSubmit;
 /** @type {number} */
Ext.form.IBasic.prototype.timeout;
 /** @type {boolean} */
Ext.form.IBasic.prototype.trackResetOnLoad;
 /** @type {string} */
Ext.form.IBasic.prototype.url;
 /** @type {?} */
Ext.form.IBasic.prototype.waitMsgTarget;
 /** @type {string} */
Ext.form.IBasic.prototype.waitTitle;
 /** @type {!Ext.container.IContainer} */
Ext.form.IBasic.prototype.owner;

/**
 * [Method] Calls Ext applyIf for all field in this form with the passed object
 * @param {?=} obj Object The object to be applied
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasic.prototype.applyIfToFields = function(obj) {};

/**
 * [Method] Calls Ext apply for all fields in this form with the passed object
 * @param {?=} obj Object The object to be applied
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasic.prototype.applyToFields = function(obj) {};

/**
 * [Method] Check whether the dirty state of the entire form has changed since it was last checked and if so fire the dirtychang
 * @return {void}
 */
Ext.form.IBasic.prototype.checkDirty = function() {};

/**
 * [Method] Check whether the validity of the entire form has changed since it was last checked and if so fire the validitychang
 * @return {void}
 */
Ext.form.IBasic.prototype.checkValidity = function() {};

/**
 * [Method] Clears all invalid field messages in this form
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasic.prototype.clearInvalid = function() {};

/**
 * [Method] Destroys this object
 * @return {void}
 */
Ext.form.IBasic.prototype.destroy = function() {};

/**
 * [Method] Performs a predefined action an implementation of Ext form action Action to perform application specific processing
 * @param {?=} action String/Ext.form.action.Action The name of the predefined action type, or instance of Ext.form.action.Action to perform.
 * @param {?=} options Object The options to pass to the Ext.form.action.Action that will get created, if the action argument is a String. All of the config options listed below are supported by both the submit and load actions unless otherwise noted (custom actions could also accept other config options):
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasic.prototype.doAction = function(action, options) {};

/**
 * [Method] Find a specific Ext form field Field in this form by id or name
 * @param {string=} id String The value to search for (specify either a id or name or hiddenName).
 * @return {?} any The first matching field, or null if none was found.
 */
Ext.form.IBasic.prototype.findField = function(id) {};

/**
 * [Method] Retrieves the fields in the form as a set of key value pairs using their getModelData  method to collect the values
 * @param {boolean=} dirtyOnly Boolean If true, only fields that are dirty will be included in the result.
 * @return {?} Object
 */
Ext.form.IBasic.prototype.getFieldValues = function(dirtyOnly) {};

/**
 * [Method] Return all the Ext form field Field components in the owner container
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection Collection of the Field objects
 */
Ext.form.IBasic.prototype.getFields = function() {};

/**
 * [Method] Returns the last Ext data Model instance that was loaded via loadRecord
 * @return {!Ext.data.IModel} Ext.data.Model The record
 */
Ext.form.IBasic.prototype.getRecord = function() {};

/**
 * [Method] Retrieves the fields in the form as a set of key value pairs using their getSubmitData  method to collect the values
 * @param {boolean=} asString Boolean If true, will return the key/value collection as a single URL-encoded param string.
 * @param {boolean=} dirtyOnly Boolean If true, only fields that are dirty will be included in the result.
 * @param {boolean=} includeEmptyText Boolean If true, the configured emptyText of empty fields will be used.
 * @param {boolean=} useDataValues Boolean If true, the getModelData method is used to retrieve values from fields, otherwise the getSubmitData method is used.
 * @return {?} String/Object
 */
Ext.form.IBasic.prototype.getValues = function(asString, dirtyOnly, includeEmptyText, useDataValues) {};

/**
 * [Method] Returns true if the form contains any invalid fields
 * @return {void}
 */
Ext.form.IBasic.prototype.hasInvalidField = function() {};

/**
 * [Method] Returns true if the form contains a file upload field
 * @return {boolean} Boolean
 */
Ext.form.IBasic.prototype.hasUpload = function() {};

/**
 * [Method] Returns true if any fields in this form have changed from their original values
 * @return {boolean} Boolean
 */
Ext.form.IBasic.prototype.isDirty = function() {};

/**
 * [Method] Returns true if client side validation on the form is successful
 * @return {boolean} Boolean
 */
Ext.form.IBasic.prototype.isValid = function() {};

/**
 * [Method] Shortcut to do a load action
 * @param {?=} options Object The options to pass to the action (see doAction for details)
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasic.prototype.load = function(options) {};

/**
 * [Method] Loads an Ext data Model into this form by calling setValues with the record data
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to load
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasic.prototype.loadRecord = function(record) {};

/**
 * [Method] Mark fields in this form invalid in bulk
 * @param {?=} errors Object/Object[]/Ext.data.Errors Either an array in the form [{id:'fieldId', msg:'The message'}, ...], an object hash of {id: msg, id2: msg2}, or a Ext.data.Errors object.
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasic.prototype.markInvalid = function(errors) {};

/**
 * [Method] Resets all fields in this form
 * @param {boolean=} resetRecord Boolean True to unbind any record set by loadRecord
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasic.prototype.reset = function(resetRecord) {};

/**
 * [Method] Set values for fields in this form in bulk
 * @param {?=} values Object/Object[] Either an array in the form: [{id:'clientName', value:'Fred. Olsen Lines'}, {id:'portOfLoading', value:'FXT'}, {id:'portOfDischarge', value:'OSL'} ]  or an object hash of the form: {  clientName: 'Fred. Olsen Lines',  portOfLoading: 'FXT',  portOfDischarge: 'OSL' }
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasic.prototype.setValues = function(values) {};

/**
 * [Method] Shortcut to do a submit action
 * @param {?=} options Object The options to pass to the action (see doAction for details).
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasic.prototype.submit = function(options) {};

/**
 * [Method] Persists the values in this form into the passed Ext data Model object in a beginEdit endEdit block
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to edit
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasic.prototype.updateRecord = function(record) {};
/**
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.form.IBasicForm = function() {};
 /** @type {?} */
Ext.form.IBasicForm.prototype.api;
 /** @type {?} */
Ext.form.IBasicForm.prototype.baseParams;
 /** @type {?} */
Ext.form.IBasicForm.prototype.errorReader;
 /** @type {boolean} */
Ext.form.IBasicForm.prototype.jsonSubmit;
 /** @type {string} */
Ext.form.IBasicForm.prototype.method;
 /** @type {?} */
Ext.form.IBasicForm.prototype.paramOrder;
 /** @type {boolean} */
Ext.form.IBasicForm.prototype.paramsAsHash;
 /** @type {?} */
Ext.form.IBasicForm.prototype.reader;
 /** @type {boolean} */
Ext.form.IBasicForm.prototype.standardSubmit;
 /** @type {number} */
Ext.form.IBasicForm.prototype.timeout;
 /** @type {boolean} */
Ext.form.IBasicForm.prototype.trackResetOnLoad;
 /** @type {string} */
Ext.form.IBasicForm.prototype.url;
 /** @type {?} */
Ext.form.IBasicForm.prototype.waitMsgTarget;
 /** @type {string} */
Ext.form.IBasicForm.prototype.waitTitle;
 /** @type {!Ext.container.IContainer} */
Ext.form.IBasicForm.prototype.owner;

/**
 * [Method] Calls Ext applyIf for all field in this form with the passed object
 * @param {?=} obj Object The object to be applied
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasicForm.prototype.applyIfToFields = function(obj) {};

/**
 * [Method] Calls Ext apply for all fields in this form with the passed object
 * @param {?=} obj Object The object to be applied
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasicForm.prototype.applyToFields = function(obj) {};

/**
 * [Method] Check whether the dirty state of the entire form has changed since it was last checked and if so fire the dirtychang
 * @return {void}
 */
Ext.form.IBasicForm.prototype.checkDirty = function() {};

/**
 * [Method] Check whether the validity of the entire form has changed since it was last checked and if so fire the validitychang
 * @return {void}
 */
Ext.form.IBasicForm.prototype.checkValidity = function() {};

/**
 * [Method] Clears all invalid field messages in this form
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasicForm.prototype.clearInvalid = function() {};

/**
 * [Method] Destroys this object
 * @return {void}
 */
Ext.form.IBasicForm.prototype.destroy = function() {};

/**
 * [Method] Performs a predefined action an implementation of Ext form action Action to perform application specific processing
 * @param {?=} action String/Ext.form.action.Action The name of the predefined action type, or instance of Ext.form.action.Action to perform.
 * @param {?=} options Object The options to pass to the Ext.form.action.Action that will get created, if the action argument is a String. All of the config options listed below are supported by both the submit and load actions unless otherwise noted (custom actions could also accept other config options):
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasicForm.prototype.doAction = function(action, options) {};

/**
 * [Method] Find a specific Ext form field Field in this form by id or name
 * @param {string=} id String The value to search for (specify either a id or name or hiddenName).
 * @return {?} any The first matching field, or null if none was found.
 */
Ext.form.IBasicForm.prototype.findField = function(id) {};

/**
 * [Method] Retrieves the fields in the form as a set of key value pairs using their getModelData  method to collect the values
 * @param {boolean=} dirtyOnly Boolean If true, only fields that are dirty will be included in the result.
 * @return {?} Object
 */
Ext.form.IBasicForm.prototype.getFieldValues = function(dirtyOnly) {};

/**
 * [Method] Return all the Ext form field Field components in the owner container
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection Collection of the Field objects
 */
Ext.form.IBasicForm.prototype.getFields = function() {};

/**
 * [Method] Returns the last Ext data Model instance that was loaded via loadRecord
 * @return {!Ext.data.IModel} Ext.data.Model The record
 */
Ext.form.IBasicForm.prototype.getRecord = function() {};

/**
 * [Method] Retrieves the fields in the form as a set of key value pairs using their getSubmitData  method to collect the values
 * @param {boolean=} asString Boolean If true, will return the key/value collection as a single URL-encoded param string.
 * @param {boolean=} dirtyOnly Boolean If true, only fields that are dirty will be included in the result.
 * @param {boolean=} includeEmptyText Boolean If true, the configured emptyText of empty fields will be used.
 * @param {boolean=} useDataValues Boolean If true, the getModelData method is used to retrieve values from fields, otherwise the getSubmitData method is used.
 * @return {?} String/Object
 */
Ext.form.IBasicForm.prototype.getValues = function(asString, dirtyOnly, includeEmptyText, useDataValues) {};

/**
 * [Method] Returns true if the form contains any invalid fields
 * @return {void}
 */
Ext.form.IBasicForm.prototype.hasInvalidField = function() {};

/**
 * [Method] Returns true if the form contains a file upload field
 * @return {boolean} Boolean
 */
Ext.form.IBasicForm.prototype.hasUpload = function() {};

/**
 * [Method] Returns true if any fields in this form have changed from their original values
 * @return {boolean} Boolean
 */
Ext.form.IBasicForm.prototype.isDirty = function() {};

/**
 * [Method] Returns true if client side validation on the form is successful
 * @return {boolean} Boolean
 */
Ext.form.IBasicForm.prototype.isValid = function() {};

/**
 * [Method] Shortcut to do a load action
 * @param {?=} options Object The options to pass to the action (see doAction for details)
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasicForm.prototype.load = function(options) {};

/**
 * [Method] Loads an Ext data Model into this form by calling setValues with the record data
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to load
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasicForm.prototype.loadRecord = function(record) {};

/**
 * [Method] Mark fields in this form invalid in bulk
 * @param {?=} errors Object/Object[]/Ext.data.Errors Either an array in the form [{id:'fieldId', msg:'The message'}, ...], an object hash of {id: msg, id2: msg2}, or a Ext.data.Errors object.
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasicForm.prototype.markInvalid = function(errors) {};

/**
 * [Method] Resets all fields in this form
 * @param {boolean=} resetRecord Boolean True to unbind any record set by loadRecord
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasicForm.prototype.reset = function(resetRecord) {};

/**
 * [Method] Set values for fields in this form in bulk
 * @param {?=} values Object/Object[] Either an array in the form: [{id:'clientName', value:'Fred. Olsen Lines'}, {id:'portOfLoading', value:'FXT'}, {id:'portOfDischarge', value:'OSL'} ]  or an object hash of the form: {  clientName: 'Fred. Olsen Lines',  portOfLoading: 'FXT',  portOfDischarge: 'OSL' }
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasicForm.prototype.setValues = function(values) {};

/**
 * [Method] Shortcut to do a submit action
 * @param {?=} options Object The options to pass to the action (see doAction for details).
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasicForm.prototype.submit = function(options) {};

/**
 * [Method] Persists the values in this form into the passed Ext data Model object in a beginEdit endEdit block
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to edit
 * @return {!Ext.form.IBasic} Ext.form.Basic this
 */
Ext.form.IBasicForm.prototype.updateRecord = function(record) {};
/**
 * @extends {Ext.form.IFieldContainer}
 * @extends {Ext.form.field.IField}
 * @record
 * @struct
 */
Ext.form.ICheckboxGroup = function() {};
 /** @type {boolean} */
Ext.form.ICheckboxGroup.prototype.allowBlank;
 /** @type {string} */
Ext.form.ICheckboxGroup.prototype.blankText;
 /** @type {?} */
Ext.form.ICheckboxGroup.prototype.columns;
 /** @type {string} */
Ext.form.ICheckboxGroup.prototype.componentCls;
 /** @type {string} */
Ext.form.ICheckboxGroup.prototype.defaultType;
 /** @type {?} */
Ext.form.ICheckboxGroup.prototype.items;
 /** @type {?} */
Ext.form.ICheckboxGroup.prototype.layout;
 /** @type {boolean} */
Ext.form.ICheckboxGroup.prototype.vertical;

/**
 * [Method] A utility for grouping a set of modifications which may trigger value changes into a single transaction to prevent e
 * @param {?=} fn Object A function containing the transaction code
 * @return {void}
 */
Ext.form.ICheckboxGroup.prototype.batchChanges = function(fn) {};

/**
 * [Method] Template method before a field is reset
 * @return {void}
 */
Ext.form.ICheckboxGroup.prototype.beforeReset = function() {};

/**
 * [Method] Checks whether the value of the field has changed since the last time it was checked
 * @return {void}
 */
Ext.form.ICheckboxGroup.prototype.checkChange = function() {};

/**
 * [Method] Checks the isDirty state of the field and if it has changed since the last time it was checked fires the dirtychange
 * @return {void}
 */
Ext.form.ICheckboxGroup.prototype.checkDirty = function() {};

/**
 * [Method] Clear any invalid styles messages for this field
 * @return {void}
 */
Ext.form.ICheckboxGroup.prototype.clearInvalid = function() {};

/**
 * [Method] Only relevant if the instance s isFileUpload method returns true
 * @return {!HTMLElement} HTMLElement
 */
Ext.form.ICheckboxGroup.prototype.extractFileInput = function() {};

/**
 * [Method] Returns an Array of all checkboxes in the container which are currently checked
 * @return {!Array<!Ext.form.field.ICheckbox>} Ext.form.field.Checkbox[] Array of Ext.form.field.Checkbox components
 */
Ext.form.ICheckboxGroup.prototype.getChecked = function() {};

/**
 * [Method] Runs CheckboxGroup s validations and returns an array of any errors
 * @return {!Array<string>} String[] Array of all validation errors
 */
Ext.form.ICheckboxGroup.prototype.getErrors = function() {};

/**
 * [Method] Don t return any data for the model the form will get the info from the individual checkboxes themselves
 * @return {?} Object A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.ICheckboxGroup.prototype.getModelData = function() {};

/**
 * [Method] Returns the name attribute of the field
 * @return {string} String name The field name
 */
Ext.form.ICheckboxGroup.prototype.getName = function() {};

/**
 * [Method] Don t return any data for submit the form will get the info from the individual checkboxes themselves
 * @return {?} Object A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.ICheckboxGroup.prototype.getSubmitData = function() {};

/**
 * [Method] Returns an object containing the values of all checked checkboxes within the group
 * @return {void}
 */
Ext.form.ICheckboxGroup.prototype.getValue = function() {};

/**
 * [Method] Initializes this Field mixin on the current instance
 * @return {void}
 */
Ext.form.ICheckboxGroup.prototype.initField = function() {};

/**
 * [Method] Initializes the field s value based on the initial config
 * @return {void}
 */
Ext.form.ICheckboxGroup.prototype.initValue = function() {};

/**
 * [Method] private override
 * @return {boolean} Boolean True if this field has been changed from its original value (and is not disabled), false otherwise.
 */
Ext.form.ICheckboxGroup.prototype.isDirty = function() {};

/**
 * [Method] private override  the group value is a complex object compare using object serialization
 * @param {?=} value1 Object
 * @param {?=} value2 Object
 * @return {boolean} Boolean True if the values are equal, false if inequal.
 */
Ext.form.ICheckboxGroup.prototype.isEqual = function(value1, value2) {};

/**
 * [Method] Returns whether this Field is a file upload field if it returns true forms will use special techniques for submitti
 * @return {boolean} Boolean
 */
Ext.form.ICheckboxGroup.prototype.isFileUpload = function() {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the field s current value
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.ICheckboxGroup.prototype.isValid = function() {};

/**
 * [Method] Associate one or more error messages with this field
 * @param {?=} errors String/String[] The error message(s) for the field.
 * @return {void}
 */
Ext.form.ICheckboxGroup.prototype.markInvalid = function(errors) {};

/**
 * [Method] When a checkbox is added to the group monitor it for changes
 * @param {?=} field Object
 * @return {void}
 */
Ext.form.ICheckboxGroup.prototype.onAdd = function(field) {};

/**
 * [Method] Called when a Ext form Labelable instance is removed from the container s subtree
 * @param {?=} item Object
 * @return {void}
 */
Ext.form.ICheckboxGroup.prototype.onRemove = function(item) {};

/**
 * [Method] Resets the checked state of all checkboxes in the group to their originally loaded values and clears any validation m
 * @return {void}
 */
Ext.form.ICheckboxGroup.prototype.reset = function() {};

/**
 * [Method] Resets the field s originalValue property so it matches the current value
 * @return {void}
 */
Ext.form.ICheckboxGroup.prototype.resetOriginalValue = function() {};

/**
 * [Method] Sets the value s of all checkboxes in the group
 * @param {?=} value Object The mapping of checkbox names to values.
 * @return {!Ext.form.ICheckboxGroup} Ext.form.CheckboxGroup this
 */
Ext.form.ICheckboxGroup.prototype.setValue = function(value) {};

/**
 * [Method] Allows for any necessary modifications before the original value is set
 * @param {?=} value Object The initial value
 * @return {?} Object The modified initial value
 */
Ext.form.ICheckboxGroup.prototype.transformOriginalValue = function(value) {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the field s current value and fires the vali
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.ICheckboxGroup.prototype.validate = function() {};
/**
 * @extends {Ext.util.IMixedCollection}
 * @record
 * @struct
 */
Ext.form.ICheckboxManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.form.CheckboxManager = function() {};
 /** @type {?} */
Ext.form.CheckboxManager.hasListeners;
 /** @type {boolean} */
Ext.form.CheckboxManager.isMixedCollection;
 /** @type {boolean} */
Ext.form.CheckboxManager.isObservable;
 /** @type {boolean} */
Ext.form.CheckboxManager.isSortable;
 /** @type {!Ext.IClass} */
Ext.form.CheckboxManager.self;
 /** @type {!Ext.util.IMixedCollection} */
Ext.form.CheckboxManager.sorters;

/**
 * [Method] Adds an item to the collection
 * @param {?=} key String/Object The key to associate with the item, or the new item. If a getKey implementation was specified for this MixedCollection, or if the key of the stored items is in a property called id, the MixedCollection will be able to derive the key for the new item. In this case just pass the new item in this parameter.
 * @param {?=} obj Object The item to add.
 * @return {?} Object The item added.
 */
Ext.form.CheckboxManager.add = function(key, obj) {};

/**
 * [Method] Adds all elements of an Array or an Object to the collection
 * @param {?=} objs Object/Array An Object containing properties which will be added to the collection, or an Array of values, each of which are added to the collection. Functions references will be added to the collection if allowFunctions has been set to true.
 * @return {void}
 */
Ext.form.CheckboxManager.addAll = function(objs) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.form.CheckboxManager.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.form.CheckboxManager.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.form.CheckboxManager.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.form.CheckboxManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.form.CheckboxManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.form.CheckboxManager.callSuper = function(args) {};

/**
 * [Method] Removes all items from the collection
 * @return {void}
 */
Ext.form.CheckboxManager.clear = function() {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.form.CheckboxManager.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.form.CheckboxManager.clearManagedListeners = function() {};

/**
 * [Method] Creates a shallow copy of this collection
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection
 */
Ext.form.CheckboxManager.clone = function() {};

/**
 * [Method] Collects unique values of a particular property in this MixedCollection
 * @param {string=} property String The property to collect on
 * @param {string=} root String 'root' property to extract the first argument from. This is used mainly when summing fields in records, where the fields are all stored inside the 'data' object
 * @param {boolean=} allowBlank Boolean Pass true to allow null, undefined or empty string values
 * @return {!Array<?>} Array The unique values
 */
Ext.form.CheckboxManager.collect = function(property, root, allowBlank) {};

/**
 * [Method] Returns true if the collection contains the passed Object as an item
 * @param {?=} o Object The Object to look for in the collection.
 * @return {boolean} Boolean True if the collection contains the Object as an item.
 */
Ext.form.CheckboxManager.contains = function(o) {};

/**
 * [Method] Returns true if the collection contains the passed Object as a key
 * @param {string=} key String The key to look for in the collection.
 * @return {boolean} Boolean True if the collection contains the Object as a key.
 */
Ext.form.CheckboxManager.containsKey = function(key) {};

/**
 * [Method] Executes the specified function once for every item in the collection
 * @param {?=} fn Function The function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current item in the iteration.
 * @return {void}
 */
Ext.form.CheckboxManager.each = function(fn, scope) {};

/**
 * [Method] Executes the specified function once for every key in the collection passing each key and its associated item as th
 * @param {?=} fn Function The function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {void}
 */
Ext.form.CheckboxManager.eachKey = function(fn, scope) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.form.CheckboxManager.enableBubble = function(eventNames) {};

/**
 * [Method] Filters the objects in this collection by a set of Filters or by a single property value pair with optional paramete
 * @param {?=} property Ext.util.Filter[]/String A property on your objects, or an array of Filter objects
 * @param {?=} value String/RegExp Either string that the property values should start with or a RegExp to test against the property
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection The new filtered collection
 */
Ext.form.CheckboxManager.filter = function(property, value, anyMatch, caseSensitive) {};

/**
 * [Method] Filter by a function
 * @param {?=} fn Function The function to be called.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this MixedCollection.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection The new filtered collection
 */
Ext.form.CheckboxManager.filterBy = function(fn, scope) {};

/**
 * [Method] Returns the first item in the collection which elicits a true return value from the passed selection function
 * @return {void}
 */
Ext.form.CheckboxManager.find = function() {};

/**
 * [Method] Returns the first item in the collection which elicits a true return value from the passed selection function
 * @param {?=} fn Function The selection function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {?} Object The first item in the collection which returned true from the selection function, or null if none was found.
 */
Ext.form.CheckboxManager.findBy = function(fn, scope) {};

/**
 * [Method] Finds the index of the first matching object in this collection by a specific property value
 * @param {string=} property String The name of a property on your objects.
 * @param {?=} value String/RegExp A string that the property values should start with or a RegExp to test against the property.
 * @param {number=} start Number The index to start searching at.
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning.
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison.
 * @return {number} Number The matched index or -1
 */
Ext.form.CheckboxManager.findIndex = function(property, value, start, anyMatch, caseSensitive) {};

/**
 * [Method] Find the index of the first matching object in this collection by a function
 * @param {?=} fn Function The function to be called.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this MixedCollection.
 * @param {number=} start Number The index to start searching at.
 * @return {number} Number The matched index or -1
 */
Ext.form.CheckboxManager.findIndexBy = function(fn, scope, start) {};

/**
 * [Method] Calculates the insertion index of the new item based upon the comparison function passed or the current sort order
 * @param {?=} newItem Object The new object to find the insertion position of.
 * @param {?=} sorterFn Function The function to sort by. This is the same as the sorting function passed to sortBy. It accepts 2 items from this MixedCollection, and returns -1 0, or 1 depending on the relative sort positions of the 2 compared items. If omitted, a function generated from the currently defined set of sorters will be used.
 * @return {number} Number The insertion point to add the new item into this MixedCollection at using insert
 */
Ext.form.CheckboxManager.findInsertionIndex = function(newItem, sorterFn) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.form.CheckboxManager.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.form.CheckboxManager.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the first item in the collection
 * @return {?} Object the first item in the collection..
 */
Ext.form.CheckboxManager.first = function() {};

/**
 * [Method] Returns a comparator function which compares two items and returns 1 0 or 1 depending on the currently defined set
 * @return {void}
 */
Ext.form.CheckboxManager.generateComparator = function() {};

/**
 * [Method] Returns the item associated with the passed key OR index
 * @param {?=} key String/Number The key or index of the item.
 * @return {?} Object If the item is found, returns the item. If the item was not found, returns undefined. If an item was found, but is a Class, returns null.
 */
Ext.form.CheckboxManager.get = function(key) {};

/**
 * [Method] Returns the item at the specified index
 * @param {number=} index Number The index of the item.
 * @return {?} Object The item at the specified index.
 */
Ext.form.CheckboxManager.getAt = function(index) {};

/**
 * [Method] Returns the item associated with the passed key
 * @param {?=} key String/Number The key of the item.
 * @return {?} Object The item associated with the passed key.
 */
Ext.form.CheckboxManager.getByKey = function(key) {};

/**
 * [Method] Returns the number of items in the collection
 * @return {number} Number the number of items in the collection.
 */
Ext.form.CheckboxManager.getCount = function() {};

/**
 * [Method] Gets the first sorter from the sorters collection excluding any groupers that may be in place
 * @return {!Ext.util.ISorter} Ext.util.Sorter The sorter, null if none exist
 */
Ext.form.CheckboxManager.getFirstSorter = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.form.CheckboxManager.getInitialConfig = function(name) {};

/**
 * [Method] A function which will be called passing a newly added object when the object is added without a separate id
 * @param {?=} item Object The item for which to find the key.
 * @return {?} Object The key for the passed item.
 */
Ext.form.CheckboxManager.getKey = function(item) {};

/**
 * [Method] Returns a range of items in this collection
 * @param {number=} startIndex Number The starting index. Defaults to 0.
 * @param {number=} endIndex Number The ending index. Defaults to the last item.
 * @return {!Array<?>} Array An array of items
 */
Ext.form.CheckboxManager.getRange = function(startIndex, endIndex) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.form.CheckboxManager.hasListener = function(eventName) {};

/**
 * [Method] Returns index within the collection of the passed Object
 * @param {?=} o Object The item to find the index of.
 * @return {number} Number index of the item. Returns -1 if not found.
 */
Ext.form.CheckboxManager.indexOf = function(o) {};

/**
 * [Method] Returns index within the collection of the passed key
 * @param {string=} key String The key to find the index of.
 * @return {number} Number index of the key.
 */
Ext.form.CheckboxManager.indexOfKey = function(key) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.form.CheckboxManager.initConfig = function(config) {};

/**
 * [Method] Performs initialization of this mixin
 * @return {void}
 */
Ext.form.CheckboxManager.initSortable = function() {};

/**
 * [Method] Inserts an item at the specified index in the collection
 * @param {number=} index Number The index to insert the item at.
 * @param {?=} key String/Object/String[]/Object[] The key to associate with the new item, or the item itself. May also be an array of either to insert multiple items at once.
 * @param {?=} o Object/Object[] If the second parameter was a key, the new item. May also be an array to insert multiple items at once.
 * @return {?} Object The item inserted or an array of items inserted.
 */
Ext.form.CheckboxManager.insert = function(index, key, o) {};

/**
 * [Method] Returns the last item in the collection
 * @return {?} Object the last item in the collection..
 */
Ext.form.CheckboxManager.last = function() {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.form.CheckboxManager.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.form.CheckboxManager.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.form.CheckboxManager.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.form.CheckboxManager.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Remove an item from the collection
 * @param {?=} o Object The item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.form.CheckboxManager.remove = function(o) {};

/**
 * [Method] Remove all items in the collection
 * @param {!Array<?>=} items Array An array of items to be removed.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection this object
 */
Ext.form.CheckboxManager.removeAll = function(items) {};

/**
 * [Method] Remove an item from a specified index in the collection
 * @param {number=} index Number The index within the collection of the item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.form.CheckboxManager.removeAt = function(index) {};

/**
 * [Method] Removes an item associated with the passed key fom the collection
 * @param {string=} key String The key of the item to remove. If null is passed, all objects which yielded no key from the configured getKey function are removed.
 * @return {?} Object Only returned if removing at a specified key. The item removed or false if no item was removed.
 */
Ext.form.CheckboxManager.removeAtKey = function(key) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.form.CheckboxManager.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.form.CheckboxManager.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Remove a range of items starting at a specified index in the collection
 * @param {number=} index Number The index within the collection of the item to remove.
 * @param {number=} removeCount Number The nuber of items to remove beginning at the specified index.
 * @return {?} Object The last item removed or false if no item was removed.
 */
Ext.form.CheckboxManager.removeRange = function(index, removeCount) {};

/**
 * [Method] Reorders each of the items based on a mapping from old index to new index
 * @param {?=} mapping Object Mapping from old item index to new item index
 * @return {void}
 */
Ext.form.CheckboxManager.reorder = function(mapping) {};

/**
 * [Method] Replaces an item in the collection
 * @param {string=} key String The key associated with the item to replace, or the replacement item. If you supplied a getKey implementation for this MixedCollection, or if the key of your stored items is in a property called id, then the MixedCollection will be able to derive the key of the replacement item. If you want to replace an item with one having the same key value, then just pass the replacement item in this parameter.
 * @param {?=} o Object {Object} o (optional) If the first parameter passed was a key, the item to associate with that key.
 * @return {?} Object The new item.
 */
Ext.form.CheckboxManager.replace = function(key, o) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.form.CheckboxManager.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.form.CheckboxManager.resumeEvents = function() {};

/**
 * [Method] Sorts the data in the Store by one or more of its properties
 * @param {?=} sorters String/Ext.util.Sorter[] Either a string name of one of the fields in this Store's configured Model, or an array of sorter configurations.
 * @param {string=} direction String The overall direction to sort the data by.
 * @return {!Array<!Ext.util.ISorter>} Ext.util.Sorter[]
 */
Ext.form.CheckboxManager.sort = function(sorters, direction) {};

/**
 * [Method] Sorts the collection by a single sorter function
 * @param {?=} sorterFn Function The function to sort by
 * @return {void}
 */
Ext.form.CheckboxManager.sortBy = function(sorterFn) {};

/**
 * [Method] Sorts this collection by keys
 * @param {string=} direction String 'ASC' or 'DESC'. Defaults to 'ASC'.
 * @param {?=} fn Function Comparison function that defines the sort order. Defaults to sorting by case insensitive string.
 * @return {void}
 */
Ext.form.CheckboxManager.sortByKey = function(direction, fn) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.form.CheckboxManager.statics = function() {};

/**
 * [Method] Collects all of the values of the given property and returns their sum
 * @param {string=} property String The property to sum by
 * @param {string=} root String 'root' property to extract the first argument from. This is used mainly when summing fields in records, where the fields are all stored inside the 'data' object
 * @param {number=} start Number The record index to start at
 * @param {number=} end Number The record index to end at
 * @return {number} Number The total
 */
Ext.form.CheckboxManager.sum = function(property, root, start, end) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.form.CheckboxManager.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.form.CheckboxManager.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.form.CheckboxManager.un = function(eventName, fn, scope) {};

/**
 * [Method] Change the key for an existing item in the collection
 * @param {?=} oldKey Object The old key
 * @param {?=} newKey Object The new key
 * @return {void}
 */
Ext.form.CheckboxManager.updateKey = function(oldKey, newKey) {};
/** @const */
Ext.form.field = {};
/**
 * @extends {Ext.IComponent}
 * @extends {Ext.form.ILabelable}
 * @extends {Ext.form.field.IField}
 * @record
 * @struct
 */
Ext.form.field.IBase = function() {};
 /** @type {string} */
Ext.form.field.IBase.prototype.baseCls;
 /** @type {number} */
Ext.form.field.IBase.prototype.checkChangeBuffer;
 /** @type {!Array<string>} */
Ext.form.field.IBase.prototype.checkChangeEvents;
 /** @type {?} */
Ext.form.field.IBase.prototype.componentLayout;
 /** @type {string} */
Ext.form.field.IBase.prototype.dirtyCls;
 /** @type {string} */
Ext.form.field.IBase.prototype.fieldCls;
 /** @type {string} */
Ext.form.field.IBase.prototype.fieldStyle;
 /** @type {string} */
Ext.form.field.IBase.prototype.focusCls;
 /** @type {?} */
Ext.form.field.IBase.prototype.inputAttrTpl;
 /** @type {string} */
Ext.form.field.IBase.prototype.inputId;
 /** @type {string} */
Ext.form.field.IBase.prototype.inputType;
 /** @type {string} */
Ext.form.field.IBase.prototype.invalidText;
 /** @type {string} */
Ext.form.field.IBase.prototype.name;
 /** @type {boolean} */
Ext.form.field.IBase.prototype.readOnly;
 /** @type {string} */
Ext.form.field.IBase.prototype.readOnlyCls;
 /** @type {number} */
Ext.form.field.IBase.prototype.tabIndex;
 /** @type {boolean} */
Ext.form.field.IBase.prototype.validateOnBlur;
 /** @type {!Ext.IElement} */
Ext.form.field.IBase.prototype.inputEl;
 /** @type {boolean} */
Ext.form.field.IBase.prototype.maskOnDisable;

/**
 * [Method] A utility for grouping a set of modifications which may trigger value changes into a single transaction to prevent e
 * @param {?=} fn Object A function containing the transaction code
 * @return {void}
 */
Ext.form.field.IBase.prototype.batchChanges = function(fn) {};

/**
 * [Method] Template method before a field is reset
 * @return {void}
 */
Ext.form.field.IBase.prototype.beforeReset = function() {};

/**
 * [Method] Checks whether the value of the field has changed since the last time it was checked
 * @return {void}
 */
Ext.form.field.IBase.prototype.checkChange = function() {};

/**
 * [Method] Checks the isDirty state of the field and if it has changed since the last time it was checked fires the dirtychange
 * @return {void}
 */
Ext.form.field.IBase.prototype.checkDirty = function() {};

/**
 * [Method] Clear any invalid styles messages for this field
 * @return {void}
 */
Ext.form.field.IBase.prototype.clearInvalid = function() {};

/**
 * [Method] This method needs to be called whenever you change something on this component that requires the Component s layout t
 * @return {!Ext.container.IContainer} Ext.container.Container this
 */
Ext.form.field.IBase.prototype.doComponentLayout = function() {};

/**
 * [Method] Only relevant if the instance s isFileUpload method returns true
 * @return {!HTMLElement} HTMLElement
 */
Ext.form.field.IBase.prototype.extractFileInput = function() {};

/**
 * [Method] Gets the active error message for this component if any
 * @return {string} String The active error message on the component; if there is no error, an empty string is returned.
 */
Ext.form.field.IBase.prototype.getActiveError = function() {};

/**
 * [Method] Gets an Array of any active error messages currently applied to the field
 * @return {!Array<string>} String[] The active error messages on the component; if there are no errors, an empty Array is returned.
 */
Ext.form.field.IBase.prototype.getActiveErrors = function() {};

/**
 * [Method] Runs this field s validators and returns an array of error messages for any validation failures
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {!Array<string>} String[] All error messages for this field; an empty Array if none.
 */
Ext.form.field.IBase.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the label for the field
 * @return {string} String The configured field label, or empty string if not defined
 */
Ext.form.field.IBase.prototype.getFieldLabel = function() {};

/**
 * [Method] Gets the width of the label if visible
 * @return {number} Number The label width
 */
Ext.form.field.IBase.prototype.getLabelWidth = function() {};

/**
 * [Method] Generates the arguments for the field decorations rendering template
 * @return {?} Object The template arguments
 */
Ext.form.field.IBase.prototype.getLabelableRenderData = function() {};

/**
 * [Method] Returns the value s that should be saved to the Ext data Model instance for this field when Ext form Basic updateRe
 * @return {?} Object A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.field.IBase.prototype.getModelData = function() {};

/**
 * [Method] Returns the name attribute of the field
 * @return {string} String name The field name
 */
Ext.form.field.IBase.prototype.getName = function() {};

/**
 * [Method] Returns the raw value of the field without performing any normalization conversion or validation
 * @return {?} any value The raw String value of the field
 */
Ext.form.field.IBase.prototype.getRawValue = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.field.IBase.prototype.getSubTplData = function() {};

/**
 * [Method] private override to use getSubmitValue  as a convenience
 * @return {?} Object A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.field.IBase.prototype.getSubmitData = function() {};

/**
 * [Method] Returns the value that would be included in a standard form submit for this field
 * @return {?} any The value to be submitted, or null.
 */
Ext.form.field.IBase.prototype.getSubmitValue = function() {};

/**
 * [Method] Returns the current data value of the field
 * @return {?} Object value The field value
 */
Ext.form.field.IBase.prototype.getValue = function() {};

/**
 * [Method] Tells whether the field currently has an active error message
 * @return {boolean} Boolean
 */
Ext.form.field.IBase.prototype.hasActiveError = function() {};

/**
 * [Method] Checks if the field has a visible label
 * @return {boolean} Boolean True if the field has a visible label
 */
Ext.form.field.IBase.prototype.hasVisibleLabel = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IBase.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IBase.prototype.initEvents = function() {};

/**
 * [Method] Initializes this Field mixin on the current instance
 * @return {void}
 */
Ext.form.field.IBase.prototype.initField = function() {};

/**
 * [Method] Performs initialization of this mixin
 * @return {void}
 */
Ext.form.field.IBase.prototype.initLabelable = function() {};

/**
 * [Method] Initialized the renderData to be used when rendering the renderTpl
 * @return {?} Object Object with keys and values that are going to be applied to the renderTpl
 */
Ext.form.field.IBase.prototype.initRenderData = function() {};

/**
 * [Method] Initializes the field s value based on the initial config
 * @return {void}
 */
Ext.form.field.IBase.prototype.initValue = function() {};

/**
 * [Method] Returns true if the value of this Field has been changed from its originalValue
 * @return {boolean} Boolean True if this field has been changed from its original value (and is not disabled), false otherwise.
 */
Ext.form.field.IBase.prototype.isDirty = function() {};

/**
 * [Method] Returns whether two field values are logically equal
 * @param {?=} value1 Object The first value to compare
 * @param {?=} value2 Object The second value to compare
 * @return {boolean} Boolean True if the values are equal, false if inequal.
 */
Ext.form.field.IBase.prototype.isEqual = function(value1, value2) {};

/**
 * [Method] Returns whether this Field is a file upload field if it returns true forms will use special techniques for submitti
 * @return {boolean} Boolean
 */
Ext.form.field.IBase.prototype.isFileUpload = function() {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the processed raw value of the field
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.field.IBase.prototype.isValid = function() {};

/**
 * [Method] Display one or more error messages associated with this field using msgTarget to determine how to display the messag
 * @param {?=} errors String/String[] The validation message(s) to display.
 * @return {void}
 */
Ext.form.field.IBase.prototype.markInvalid = function(errors) {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IBase.prototype.onDisable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IBase.prototype.onEnable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IBase.prototype.onRender = function() {};

/**
 * [Method] Performs any necessary manipulation of a raw field value to prepare it for conversion and or validation for instance
 * @param {?=} value Object The unprocessed string value
 * @return {?} Object The processed string value
 */
Ext.form.field.IBase.prototype.processRawValue = function(value) {};

/**
 * [Method] Converts a raw input field value into a mixed type value that is suitable for this particular field type
 * @param {?=} rawValue Object
 * @return {?} Object The converted value.
 */
Ext.form.field.IBase.prototype.rawToValue = function(rawValue) {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.form.field.IBase.prototype.reset = function() {};

/**
 * [Method] Resets the field s originalValue property so it matches the current value
 * @return {void}
 */
Ext.form.field.IBase.prototype.resetOriginalValue = function() {};

/**
 * [Method] Sets the active error message to the given string
 * @param {string=} msg String The error message
 * @return {void}
 */
Ext.form.field.IBase.prototype.setActiveError = function(msg) {};

/**
 * [Method] Set the active error message to an Array of error messages
 * @param {!Array<string>=} errors String[] The error messages
 * @return {void}
 */
Ext.form.field.IBase.prototype.setActiveErrors = function(errors) {};

/**
 * [Method] Applies a set of default configuration values to this Labelable instance
 * @param {?=} defaults Object The defaults to apply to the object.
 * @return {void}
 */
Ext.form.field.IBase.prototype.setFieldDefaults = function(defaults) {};

/**
 * [Method] Set the label of this field
 * @param {string=} label String The new label. The labelSeparator will be automatically appended to the label string.
 * @return {void}
 */
Ext.form.field.IBase.prototype.setFieldLabel = function(label) {};

/**
 * [Method] Set the CSS style of the field input element
 * @param {?=} style String/Object/Function The style(s) to apply. Should be a valid argument to Ext.Element.applyStyles.
 * @return {void}
 */
Ext.form.field.IBase.prototype.setFieldStyle = function(style) {};

/**
 * [Method] Sets the field s raw value directly bypassing value conversion change detection and validation
 * @param {?=} value Object The value to set
 * @return {?} Object value The field value that is set
 */
Ext.form.field.IBase.prototype.setRawValue = function(value) {};

/**
 * [Method] Sets the read only state of this field
 * @param {boolean=} readOnly Boolean Whether the field should be read only.
 * @return {void}
 */
Ext.form.field.IBase.prototype.setReadOnly = function(readOnly) {};

/**
 * [Method] Sets a data value into the field and runs the change detection and validation
 * @param {?=} value Object The value to set
 * @return {?} any this
 */
Ext.form.field.IBase.prototype.setValue = function(value) {};

/**
 * [Method] Allows for any necessary modifications before the original value is set
 * @param {?=} value Object The initial value
 * @return {?} Object The modified initial value
 */
Ext.form.field.IBase.prototype.transformOriginalValue = function(value) {};

/**
 * [Method] Transform the raw value before it is set
 * @param {?=} value Object The value
 * @return {?} Object The value to set
 */
Ext.form.field.IBase.prototype.transformRawValue = function(value) {};

/**
 * [Method] Returns the trimmed label by slicing off the label separator character
 * @return {string} String The trimmed field label, or empty string if not defined
 */
Ext.form.field.IBase.prototype.trimLabelSeparator = function() {};

/**
 * [Method] Clears the active error message s
 * @return {void}
 */
Ext.form.field.IBase.prototype.unsetActiveError = function() {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the field s current value and fires the vali
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.field.IBase.prototype.validate = function() {};

/**
 * [Method] Uses getErrors to build an array of validation errors
 * @param {?=} value Object The value to validate
 * @return {boolean} Boolean True if all validations passed, false if one or more failed
 */
Ext.form.field.IBase.prototype.validateValue = function(value) {};

/**
 * [Method] Converts a mixed type value to a raw representation suitable for displaying in the field
 * @param {?=} value Object The mixed-type value to convert to the raw representation.
 * @return {?} Object The converted raw value.
 */
Ext.form.field.IBase.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.IComponent}
 * @extends {Ext.form.ILabelable}
 * @extends {Ext.form.field.IField}
 * @record
 * @struct
 */
Ext.form.IField = function() {};
 /** @type {string} */
Ext.form.IField.prototype.baseCls;
 /** @type {number} */
Ext.form.IField.prototype.checkChangeBuffer;
 /** @type {!Array<string>} */
Ext.form.IField.prototype.checkChangeEvents;
 /** @type {?} */
Ext.form.IField.prototype.componentLayout;
 /** @type {string} */
Ext.form.IField.prototype.dirtyCls;
 /** @type {string} */
Ext.form.IField.prototype.fieldCls;
 /** @type {string} */
Ext.form.IField.prototype.fieldStyle;
 /** @type {string} */
Ext.form.IField.prototype.focusCls;
 /** @type {?} */
Ext.form.IField.prototype.inputAttrTpl;
 /** @type {string} */
Ext.form.IField.prototype.inputId;
 /** @type {string} */
Ext.form.IField.prototype.inputType;
 /** @type {string} */
Ext.form.IField.prototype.invalidText;
 /** @type {string} */
Ext.form.IField.prototype.name;
 /** @type {boolean} */
Ext.form.IField.prototype.readOnly;
 /** @type {string} */
Ext.form.IField.prototype.readOnlyCls;
 /** @type {number} */
Ext.form.IField.prototype.tabIndex;
 /** @type {boolean} */
Ext.form.IField.prototype.validateOnBlur;
 /** @type {!Ext.IElement} */
Ext.form.IField.prototype.inputEl;
 /** @type {boolean} */
Ext.form.IField.prototype.maskOnDisable;

/**
 * [Method] A utility for grouping a set of modifications which may trigger value changes into a single transaction to prevent e
 * @param {?=} fn Object A function containing the transaction code
 * @return {void}
 */
Ext.form.IField.prototype.batchChanges = function(fn) {};

/**
 * [Method] Template method before a field is reset
 * @return {void}
 */
Ext.form.IField.prototype.beforeReset = function() {};

/**
 * [Method] Checks whether the value of the field has changed since the last time it was checked
 * @return {void}
 */
Ext.form.IField.prototype.checkChange = function() {};

/**
 * [Method] Checks the isDirty state of the field and if it has changed since the last time it was checked fires the dirtychange
 * @return {void}
 */
Ext.form.IField.prototype.checkDirty = function() {};

/**
 * [Method] Clear any invalid styles messages for this field
 * @return {void}
 */
Ext.form.IField.prototype.clearInvalid = function() {};

/**
 * [Method] This method needs to be called whenever you change something on this component that requires the Component s layout t
 * @return {!Ext.container.IContainer} Ext.container.Container this
 */
Ext.form.IField.prototype.doComponentLayout = function() {};

/**
 * [Method] Only relevant if the instance s isFileUpload method returns true
 * @return {!HTMLElement} HTMLElement
 */
Ext.form.IField.prototype.extractFileInput = function() {};

/**
 * [Method] Gets the active error message for this component if any
 * @return {string} String The active error message on the component; if there is no error, an empty string is returned.
 */
Ext.form.IField.prototype.getActiveError = function() {};

/**
 * [Method] Gets an Array of any active error messages currently applied to the field
 * @return {!Array<string>} String[] The active error messages on the component; if there are no errors, an empty Array is returned.
 */
Ext.form.IField.prototype.getActiveErrors = function() {};

/**
 * [Method] Runs this field s validators and returns an array of error messages for any validation failures
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {!Array<string>} String[] All error messages for this field; an empty Array if none.
 */
Ext.form.IField.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the label for the field
 * @return {string} String The configured field label, or empty string if not defined
 */
Ext.form.IField.prototype.getFieldLabel = function() {};

/**
 * [Method] Gets the width of the label if visible
 * @return {number} Number The label width
 */
Ext.form.IField.prototype.getLabelWidth = function() {};

/**
 * [Method] Generates the arguments for the field decorations rendering template
 * @return {?} Object The template arguments
 */
Ext.form.IField.prototype.getLabelableRenderData = function() {};

/**
 * [Method] Returns the value s that should be saved to the Ext data Model instance for this field when Ext form Basic updateRe
 * @return {?} Object A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.IField.prototype.getModelData = function() {};

/**
 * [Method] Returns the name attribute of the field
 * @return {string} String name The field name
 */
Ext.form.IField.prototype.getName = function() {};

/**
 * [Method] Returns the raw value of the field without performing any normalization conversion or validation
 * @return {?} any value The raw String value of the field
 */
Ext.form.IField.prototype.getRawValue = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.IField.prototype.getSubTplData = function() {};

/**
 * [Method] private override to use getSubmitValue  as a convenience
 * @return {?} Object A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.IField.prototype.getSubmitData = function() {};

/**
 * [Method] Returns the value that would be included in a standard form submit for this field
 * @return {?} any The value to be submitted, or null.
 */
Ext.form.IField.prototype.getSubmitValue = function() {};

/**
 * [Method] Returns the current data value of the field
 * @return {?} Object value The field value
 */
Ext.form.IField.prototype.getValue = function() {};

/**
 * [Method] Tells whether the field currently has an active error message
 * @return {boolean} Boolean
 */
Ext.form.IField.prototype.hasActiveError = function() {};

/**
 * [Method] Checks if the field has a visible label
 * @return {boolean} Boolean True if the field has a visible label
 */
Ext.form.IField.prototype.hasVisibleLabel = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IField.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IField.prototype.initEvents = function() {};

/**
 * [Method] Initializes this Field mixin on the current instance
 * @return {void}
 */
Ext.form.IField.prototype.initField = function() {};

/**
 * [Method] Performs initialization of this mixin
 * @return {void}
 */
Ext.form.IField.prototype.initLabelable = function() {};

/**
 * [Method] Initialized the renderData to be used when rendering the renderTpl
 * @return {?} Object Object with keys and values that are going to be applied to the renderTpl
 */
Ext.form.IField.prototype.initRenderData = function() {};

/**
 * [Method] Initializes the field s value based on the initial config
 * @return {void}
 */
Ext.form.IField.prototype.initValue = function() {};

/**
 * [Method] Returns true if the value of this Field has been changed from its originalValue
 * @return {boolean} Boolean True if this field has been changed from its original value (and is not disabled), false otherwise.
 */
Ext.form.IField.prototype.isDirty = function() {};

/**
 * [Method] Returns whether two field values are logically equal
 * @param {?=} value1 Object The first value to compare
 * @param {?=} value2 Object The second value to compare
 * @return {boolean} Boolean True if the values are equal, false if inequal.
 */
Ext.form.IField.prototype.isEqual = function(value1, value2) {};

/**
 * [Method] Returns whether this Field is a file upload field if it returns true forms will use special techniques for submitti
 * @return {boolean} Boolean
 */
Ext.form.IField.prototype.isFileUpload = function() {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the processed raw value of the field
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.IField.prototype.isValid = function() {};

/**
 * [Method] Display one or more error messages associated with this field using msgTarget to determine how to display the messag
 * @param {?=} errors String/String[] The validation message(s) to display.
 * @return {void}
 */
Ext.form.IField.prototype.markInvalid = function(errors) {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IField.prototype.onDisable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IField.prototype.onEnable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IField.prototype.onRender = function() {};

/**
 * [Method] Performs any necessary manipulation of a raw field value to prepare it for conversion and or validation for instance
 * @param {?=} value Object The unprocessed string value
 * @return {?} Object The processed string value
 */
Ext.form.IField.prototype.processRawValue = function(value) {};

/**
 * [Method] Converts a raw input field value into a mixed type value that is suitable for this particular field type
 * @param {?=} rawValue Object
 * @return {?} Object The converted value.
 */
Ext.form.IField.prototype.rawToValue = function(rawValue) {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.form.IField.prototype.reset = function() {};

/**
 * [Method] Resets the field s originalValue property so it matches the current value
 * @return {void}
 */
Ext.form.IField.prototype.resetOriginalValue = function() {};

/**
 * [Method] Sets the active error message to the given string
 * @param {string=} msg String The error message
 * @return {void}
 */
Ext.form.IField.prototype.setActiveError = function(msg) {};

/**
 * [Method] Set the active error message to an Array of error messages
 * @param {!Array<string>=} errors String[] The error messages
 * @return {void}
 */
Ext.form.IField.prototype.setActiveErrors = function(errors) {};

/**
 * [Method] Applies a set of default configuration values to this Labelable instance
 * @param {?=} defaults Object The defaults to apply to the object.
 * @return {void}
 */
Ext.form.IField.prototype.setFieldDefaults = function(defaults) {};

/**
 * [Method] Set the label of this field
 * @param {string=} label String The new label. The labelSeparator will be automatically appended to the label string.
 * @return {void}
 */
Ext.form.IField.prototype.setFieldLabel = function(label) {};

/**
 * [Method] Set the CSS style of the field input element
 * @param {?=} style String/Object/Function The style(s) to apply. Should be a valid argument to Ext.Element.applyStyles.
 * @return {void}
 */
Ext.form.IField.prototype.setFieldStyle = function(style) {};

/**
 * [Method] Sets the field s raw value directly bypassing value conversion change detection and validation
 * @param {?=} value Object The value to set
 * @return {?} Object value The field value that is set
 */
Ext.form.IField.prototype.setRawValue = function(value) {};

/**
 * [Method] Sets the read only state of this field
 * @param {boolean=} readOnly Boolean Whether the field should be read only.
 * @return {void}
 */
Ext.form.IField.prototype.setReadOnly = function(readOnly) {};

/**
 * [Method] Sets a data value into the field and runs the change detection and validation
 * @param {?=} value Object The value to set
 * @return {?} any this
 */
Ext.form.IField.prototype.setValue = function(value) {};

/**
 * [Method] Allows for any necessary modifications before the original value is set
 * @param {?=} value Object The initial value
 * @return {?} Object The modified initial value
 */
Ext.form.IField.prototype.transformOriginalValue = function(value) {};

/**
 * [Method] Transform the raw value before it is set
 * @param {?=} value Object The value
 * @return {?} Object The value to set
 */
Ext.form.IField.prototype.transformRawValue = function(value) {};

/**
 * [Method] Returns the trimmed label by slicing off the label separator character
 * @return {string} String The trimmed field label, or empty string if not defined
 */
Ext.form.IField.prototype.trimLabelSeparator = function() {};

/**
 * [Method] Clears the active error message s
 * @return {void}
 */
Ext.form.IField.prototype.unsetActiveError = function() {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the field s current value and fires the vali
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.IField.prototype.validate = function() {};

/**
 * [Method] Uses getErrors to build an array of validation errors
 * @param {?=} value Object The value to validate
 * @return {boolean} Boolean True if all validations passed, false if one or more failed
 */
Ext.form.IField.prototype.validateValue = function(value) {};

/**
 * [Method] Converts a mixed type value to a raw representation suitable for displaying in the field
 * @param {?=} value Object The mixed-type value to convert to the raw representation.
 * @return {?} Object The converted raw value.
 */
Ext.form.IField.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.IComponent}
 * @extends {Ext.form.ILabelable}
 * @extends {Ext.form.field.IField}
 * @record
 * @struct
 */
Ext.form.IBaseField = function() {};
 /** @type {string} */
Ext.form.IBaseField.prototype.baseCls;
 /** @type {number} */
Ext.form.IBaseField.prototype.checkChangeBuffer;
 /** @type {!Array<string>} */
Ext.form.IBaseField.prototype.checkChangeEvents;
 /** @type {?} */
Ext.form.IBaseField.prototype.componentLayout;
 /** @type {string} */
Ext.form.IBaseField.prototype.dirtyCls;
 /** @type {string} */
Ext.form.IBaseField.prototype.fieldCls;
 /** @type {string} */
Ext.form.IBaseField.prototype.fieldStyle;
 /** @type {string} */
Ext.form.IBaseField.prototype.focusCls;
 /** @type {?} */
Ext.form.IBaseField.prototype.inputAttrTpl;
 /** @type {string} */
Ext.form.IBaseField.prototype.inputId;
 /** @type {string} */
Ext.form.IBaseField.prototype.inputType;
 /** @type {string} */
Ext.form.IBaseField.prototype.invalidText;
 /** @type {string} */
Ext.form.IBaseField.prototype.name;
 /** @type {boolean} */
Ext.form.IBaseField.prototype.readOnly;
 /** @type {string} */
Ext.form.IBaseField.prototype.readOnlyCls;
 /** @type {number} */
Ext.form.IBaseField.prototype.tabIndex;
 /** @type {boolean} */
Ext.form.IBaseField.prototype.validateOnBlur;
 /** @type {!Ext.IElement} */
Ext.form.IBaseField.prototype.inputEl;
 /** @type {boolean} */
Ext.form.IBaseField.prototype.maskOnDisable;

/**
 * [Method] A utility for grouping a set of modifications which may trigger value changes into a single transaction to prevent e
 * @param {?=} fn Object A function containing the transaction code
 * @return {void}
 */
Ext.form.IBaseField.prototype.batchChanges = function(fn) {};

/**
 * [Method] Template method before a field is reset
 * @return {void}
 */
Ext.form.IBaseField.prototype.beforeReset = function() {};

/**
 * [Method] Checks whether the value of the field has changed since the last time it was checked
 * @return {void}
 */
Ext.form.IBaseField.prototype.checkChange = function() {};

/**
 * [Method] Checks the isDirty state of the field and if it has changed since the last time it was checked fires the dirtychange
 * @return {void}
 */
Ext.form.IBaseField.prototype.checkDirty = function() {};

/**
 * [Method] Clear any invalid styles messages for this field
 * @return {void}
 */
Ext.form.IBaseField.prototype.clearInvalid = function() {};

/**
 * [Method] This method needs to be called whenever you change something on this component that requires the Component s layout t
 * @return {!Ext.container.IContainer} Ext.container.Container this
 */
Ext.form.IBaseField.prototype.doComponentLayout = function() {};

/**
 * [Method] Only relevant if the instance s isFileUpload method returns true
 * @return {!HTMLElement} HTMLElement
 */
Ext.form.IBaseField.prototype.extractFileInput = function() {};

/**
 * [Method] Gets the active error message for this component if any
 * @return {string} String The active error message on the component; if there is no error, an empty string is returned.
 */
Ext.form.IBaseField.prototype.getActiveError = function() {};

/**
 * [Method] Gets an Array of any active error messages currently applied to the field
 * @return {!Array<string>} String[] The active error messages on the component; if there are no errors, an empty Array is returned.
 */
Ext.form.IBaseField.prototype.getActiveErrors = function() {};

/**
 * [Method] Runs this field s validators and returns an array of error messages for any validation failures
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {!Array<string>} String[] All error messages for this field; an empty Array if none.
 */
Ext.form.IBaseField.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the label for the field
 * @return {string} String The configured field label, or empty string if not defined
 */
Ext.form.IBaseField.prototype.getFieldLabel = function() {};

/**
 * [Method] Gets the width of the label if visible
 * @return {number} Number The label width
 */
Ext.form.IBaseField.prototype.getLabelWidth = function() {};

/**
 * [Method] Generates the arguments for the field decorations rendering template
 * @return {?} Object The template arguments
 */
Ext.form.IBaseField.prototype.getLabelableRenderData = function() {};

/**
 * [Method] Returns the value s that should be saved to the Ext data Model instance for this field when Ext form Basic updateRe
 * @return {?} Object A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.IBaseField.prototype.getModelData = function() {};

/**
 * [Method] Returns the name attribute of the field
 * @return {string} String name The field name
 */
Ext.form.IBaseField.prototype.getName = function() {};

/**
 * [Method] Returns the raw value of the field without performing any normalization conversion or validation
 * @return {?} any value The raw String value of the field
 */
Ext.form.IBaseField.prototype.getRawValue = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.IBaseField.prototype.getSubTplData = function() {};

/**
 * [Method] private override to use getSubmitValue  as a convenience
 * @return {?} Object A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.IBaseField.prototype.getSubmitData = function() {};

/**
 * [Method] Returns the value that would be included in a standard form submit for this field
 * @return {?} any The value to be submitted, or null.
 */
Ext.form.IBaseField.prototype.getSubmitValue = function() {};

/**
 * [Method] Returns the current data value of the field
 * @return {?} Object value The field value
 */
Ext.form.IBaseField.prototype.getValue = function() {};

/**
 * [Method] Tells whether the field currently has an active error message
 * @return {boolean} Boolean
 */
Ext.form.IBaseField.prototype.hasActiveError = function() {};

/**
 * [Method] Checks if the field has a visible label
 * @return {boolean} Boolean True if the field has a visible label
 */
Ext.form.IBaseField.prototype.hasVisibleLabel = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IBaseField.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IBaseField.prototype.initEvents = function() {};

/**
 * [Method] Initializes this Field mixin on the current instance
 * @return {void}
 */
Ext.form.IBaseField.prototype.initField = function() {};

/**
 * [Method] Performs initialization of this mixin
 * @return {void}
 */
Ext.form.IBaseField.prototype.initLabelable = function() {};

/**
 * [Method] Initialized the renderData to be used when rendering the renderTpl
 * @return {?} Object Object with keys and values that are going to be applied to the renderTpl
 */
Ext.form.IBaseField.prototype.initRenderData = function() {};

/**
 * [Method] Initializes the field s value based on the initial config
 * @return {void}
 */
Ext.form.IBaseField.prototype.initValue = function() {};

/**
 * [Method] Returns true if the value of this Field has been changed from its originalValue
 * @return {boolean} Boolean True if this field has been changed from its original value (and is not disabled), false otherwise.
 */
Ext.form.IBaseField.prototype.isDirty = function() {};

/**
 * [Method] Returns whether two field values are logically equal
 * @param {?=} value1 Object The first value to compare
 * @param {?=} value2 Object The second value to compare
 * @return {boolean} Boolean True if the values are equal, false if inequal.
 */
Ext.form.IBaseField.prototype.isEqual = function(value1, value2) {};

/**
 * [Method] Returns whether this Field is a file upload field if it returns true forms will use special techniques for submitti
 * @return {boolean} Boolean
 */
Ext.form.IBaseField.prototype.isFileUpload = function() {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the processed raw value of the field
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.IBaseField.prototype.isValid = function() {};

/**
 * [Method] Display one or more error messages associated with this field using msgTarget to determine how to display the messag
 * @param {?=} errors String/String[] The validation message(s) to display.
 * @return {void}
 */
Ext.form.IBaseField.prototype.markInvalid = function(errors) {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IBaseField.prototype.onDisable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IBaseField.prototype.onEnable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IBaseField.prototype.onRender = function() {};

/**
 * [Method] Performs any necessary manipulation of a raw field value to prepare it for conversion and or validation for instance
 * @param {?=} value Object The unprocessed string value
 * @return {?} Object The processed string value
 */
Ext.form.IBaseField.prototype.processRawValue = function(value) {};

/**
 * [Method] Converts a raw input field value into a mixed type value that is suitable for this particular field type
 * @param {?=} rawValue Object
 * @return {?} Object The converted value.
 */
Ext.form.IBaseField.prototype.rawToValue = function(rawValue) {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.form.IBaseField.prototype.reset = function() {};

/**
 * [Method] Resets the field s originalValue property so it matches the current value
 * @return {void}
 */
Ext.form.IBaseField.prototype.resetOriginalValue = function() {};

/**
 * [Method] Sets the active error message to the given string
 * @param {string=} msg String The error message
 * @return {void}
 */
Ext.form.IBaseField.prototype.setActiveError = function(msg) {};

/**
 * [Method] Set the active error message to an Array of error messages
 * @param {!Array<string>=} errors String[] The error messages
 * @return {void}
 */
Ext.form.IBaseField.prototype.setActiveErrors = function(errors) {};

/**
 * [Method] Applies a set of default configuration values to this Labelable instance
 * @param {?=} defaults Object The defaults to apply to the object.
 * @return {void}
 */
Ext.form.IBaseField.prototype.setFieldDefaults = function(defaults) {};

/**
 * [Method] Set the label of this field
 * @param {string=} label String The new label. The labelSeparator will be automatically appended to the label string.
 * @return {void}
 */
Ext.form.IBaseField.prototype.setFieldLabel = function(label) {};

/**
 * [Method] Set the CSS style of the field input element
 * @param {?=} style String/Object/Function The style(s) to apply. Should be a valid argument to Ext.Element.applyStyles.
 * @return {void}
 */
Ext.form.IBaseField.prototype.setFieldStyle = function(style) {};

/**
 * [Method] Sets the field s raw value directly bypassing value conversion change detection and validation
 * @param {?=} value Object The value to set
 * @return {?} Object value The field value that is set
 */
Ext.form.IBaseField.prototype.setRawValue = function(value) {};

/**
 * [Method] Sets the read only state of this field
 * @param {boolean=} readOnly Boolean Whether the field should be read only.
 * @return {void}
 */
Ext.form.IBaseField.prototype.setReadOnly = function(readOnly) {};

/**
 * [Method] Sets a data value into the field and runs the change detection and validation
 * @param {?=} value Object The value to set
 * @return {?} any this
 */
Ext.form.IBaseField.prototype.setValue = function(value) {};

/**
 * [Method] Allows for any necessary modifications before the original value is set
 * @param {?=} value Object The initial value
 * @return {?} Object The modified initial value
 */
Ext.form.IBaseField.prototype.transformOriginalValue = function(value) {};

/**
 * [Method] Transform the raw value before it is set
 * @param {?=} value Object The value
 * @return {?} Object The value to set
 */
Ext.form.IBaseField.prototype.transformRawValue = function(value) {};

/**
 * [Method] Returns the trimmed label by slicing off the label separator character
 * @return {string} String The trimmed field label, or empty string if not defined
 */
Ext.form.IBaseField.prototype.trimLabelSeparator = function() {};

/**
 * [Method] Clears the active error message s
 * @return {void}
 */
Ext.form.IBaseField.prototype.unsetActiveError = function() {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the field s current value and fires the vali
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.IBaseField.prototype.validate = function() {};

/**
 * [Method] Uses getErrors to build an array of validation errors
 * @param {?=} value Object The value to validate
 * @return {boolean} Boolean True if all validations passed, false if one or more failed
 */
Ext.form.IBaseField.prototype.validateValue = function(value) {};

/**
 * [Method] Converts a mixed type value to a raw representation suitable for displaying in the field
 * @param {?=} value Object The mixed-type value to convert to the raw representation.
 * @return {?} Object The converted raw value.
 */
Ext.form.IBaseField.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.form.field.IBase}
 * @record
 * @struct
 */
Ext.form.field.ICheckbox = function() {};
 /** @type {?} */
Ext.form.field.ICheckbox.prototype.afterBoxLabelTextTpl;
 /** @type {?} */
Ext.form.field.ICheckbox.prototype.afterBoxLabelTpl;
 /** @type {?} */
Ext.form.field.ICheckbox.prototype.beforeBoxLabelTextTpl;
 /** @type {?} */
Ext.form.field.ICheckbox.prototype.beforeBoxLabelTpl;
 /** @type {string} */
Ext.form.field.ICheckbox.prototype.boxLabel;
 /** @type {string} */
Ext.form.field.ICheckbox.prototype.boxLabelAlign;
 /** @type {?} */
Ext.form.field.ICheckbox.prototype.boxLabelAttrTpl;
 /** @type {string} */
Ext.form.field.ICheckbox.prototype.boxLabelCls;
 /** @type {!Array<string>} */
Ext.form.field.ICheckbox.prototype.checkChangeEvents;
 /** @type {boolean} */
Ext.form.field.ICheckbox.prototype.checked;
 /** @type {string} */
Ext.form.field.ICheckbox.prototype.checkedCls;
 /** @type {?} */
Ext.form.field.ICheckbox.prototype.componentLayout;
 /** @type {string} */
Ext.form.field.ICheckbox.prototype.fieldCls;
 /** @type {string} */
Ext.form.field.ICheckbox.prototype.focusCls;
 /** @type {?} */
Ext.form.field.ICheckbox.prototype.handler;
 /** @type {string} */
Ext.form.field.ICheckbox.prototype.inputType;
 /** @type {string} */
Ext.form.field.ICheckbox.prototype.inputValue;
 /** @type {?} */
Ext.form.field.ICheckbox.prototype.scope;
 /** @type {string} */
Ext.form.field.ICheckbox.prototype.uncheckedValue;
 /** @type {!Ext.IElement} */
Ext.form.field.ICheckbox.prototype.boxLabelEl;
 /** @type {?} */
Ext.form.field.ICheckbox.prototype.originalValue;

/**
 * [Method] inherit docs
 * @return {void}
 */
Ext.form.field.ICheckbox.prototype.beforeDestroy = function() {};

/**
 * [Method] Returns the checked state of the checkbox
 * @return {boolean} Boolean True if checked, else false
 */
Ext.form.field.ICheckbox.prototype.getRawValue = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.field.ICheckbox.prototype.getSubTplData = function() {};

/**
 * [Method] Returns the submit value for the checkbox which can be used when submitting forms
 * @return {?} any If checked the inputValue is returned; otherwise the uncheckedValue (or null if the latter is not configured).
 */
Ext.form.field.ICheckbox.prototype.getSubmitValue = function() {};

/**
 * [Method] Returns the checked state of the checkbox
 * @return {boolean} Boolean True if checked, else false
 */
Ext.form.field.ICheckbox.prototype.getValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.ICheckbox.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.ICheckbox.prototype.initEvents = function() {};

/**
 * [Method] Initializes the field s value based on the initial config
 * @return {void}
 */
Ext.form.field.ICheckbox.prototype.initValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.ICheckbox.prototype.onEnable = function() {};

/**
 * [Method] Resets the field s originalValue property so it matches the current value
 * @param {?=} fromBoxInGroup Object
 * @return {void}
 */
Ext.form.field.ICheckbox.prototype.resetOriginalValue = function(fromBoxInGroup) {};

/**
 * [Method] Sets the boxLabel for this checkbox
 * @param {string=} boxLabel String The new label
 * @return {void}
 */
Ext.form.field.ICheckbox.prototype.setBoxLabel = function(boxLabel) {};

/**
 * [Method] Sets the checked state of the checkbox
 * @param {?=} value Boolean/String/Number The following values will check the checkbox: true, 'true', '1', 1, or 'on', as well as a String that matches the inputValue. Any other value will uncheck the checkbox.
 * @return {boolean} Boolean the new checked state of the checkbox
 */
Ext.form.field.ICheckbox.prototype.setRawValue = function(value) {};

/**
 * [Method] Sets the read only state of this field
 * @param {?=} readOnly Object
 * @return {void}
 */
Ext.form.field.ICheckbox.prototype.setReadOnly = function(readOnly) {};

/**
 * [Method] Sets the checked state of the checkbox and invokes change detection
 * @param {?=} checked Boolean/String The following values will check the checkbox: true, 'true', '1', or 'on', as well as a String that matches the inputValue. Any other value will uncheck the checkbox.
 * @return {!Ext.form.field.ICheckbox} Ext.form.field.Checkbox this
 */
Ext.form.field.ICheckbox.prototype.setValue = function(checked) {};

/**
 * [Method] private
 * @param {?=} value Object
 * @return {?} Object The converted raw value.
 */
Ext.form.field.ICheckbox.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.form.field.IBase}
 * @record
 * @struct
 */
Ext.form.ICheckbox = function() {};
 /** @type {?} */
Ext.form.ICheckbox.prototype.afterBoxLabelTextTpl;
 /** @type {?} */
Ext.form.ICheckbox.prototype.afterBoxLabelTpl;
 /** @type {?} */
Ext.form.ICheckbox.prototype.beforeBoxLabelTextTpl;
 /** @type {?} */
Ext.form.ICheckbox.prototype.beforeBoxLabelTpl;
 /** @type {string} */
Ext.form.ICheckbox.prototype.boxLabel;
 /** @type {string} */
Ext.form.ICheckbox.prototype.boxLabelAlign;
 /** @type {?} */
Ext.form.ICheckbox.prototype.boxLabelAttrTpl;
 /** @type {string} */
Ext.form.ICheckbox.prototype.boxLabelCls;
 /** @type {!Array<string>} */
Ext.form.ICheckbox.prototype.checkChangeEvents;
 /** @type {boolean} */
Ext.form.ICheckbox.prototype.checked;
 /** @type {string} */
Ext.form.ICheckbox.prototype.checkedCls;
 /** @type {?} */
Ext.form.ICheckbox.prototype.componentLayout;
 /** @type {string} */
Ext.form.ICheckbox.prototype.fieldCls;
 /** @type {string} */
Ext.form.ICheckbox.prototype.focusCls;
 /** @type {?} */
Ext.form.ICheckbox.prototype.handler;
 /** @type {string} */
Ext.form.ICheckbox.prototype.inputType;
 /** @type {string} */
Ext.form.ICheckbox.prototype.inputValue;
 /** @type {?} */
Ext.form.ICheckbox.prototype.scope;
 /** @type {string} */
Ext.form.ICheckbox.prototype.uncheckedValue;
 /** @type {!Ext.IElement} */
Ext.form.ICheckbox.prototype.boxLabelEl;
 /** @type {?} */
Ext.form.ICheckbox.prototype.originalValue;

/**
 * [Method] inherit docs
 * @return {void}
 */
Ext.form.ICheckbox.prototype.beforeDestroy = function() {};

/**
 * [Method] Returns the checked state of the checkbox
 * @return {boolean} Boolean True if checked, else false
 */
Ext.form.ICheckbox.prototype.getRawValue = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.ICheckbox.prototype.getSubTplData = function() {};

/**
 * [Method] Returns the submit value for the checkbox which can be used when submitting forms
 * @return {?} any If checked the inputValue is returned; otherwise the uncheckedValue (or null if the latter is not configured).
 */
Ext.form.ICheckbox.prototype.getSubmitValue = function() {};

/**
 * [Method] Returns the checked state of the checkbox
 * @return {boolean} Boolean True if checked, else false
 */
Ext.form.ICheckbox.prototype.getValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ICheckbox.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ICheckbox.prototype.initEvents = function() {};

/**
 * [Method] Initializes the field s value based on the initial config
 * @return {void}
 */
Ext.form.ICheckbox.prototype.initValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ICheckbox.prototype.onEnable = function() {};

/**
 * [Method] Resets the field s originalValue property so it matches the current value
 * @param {?=} fromBoxInGroup Object
 * @return {void}
 */
Ext.form.ICheckbox.prototype.resetOriginalValue = function(fromBoxInGroup) {};

/**
 * [Method] Sets the boxLabel for this checkbox
 * @param {string=} boxLabel String The new label
 * @return {void}
 */
Ext.form.ICheckbox.prototype.setBoxLabel = function(boxLabel) {};

/**
 * [Method] Sets the checked state of the checkbox
 * @param {?=} value Boolean/String/Number The following values will check the checkbox: true, 'true', '1', 1, or 'on', as well as a String that matches the inputValue. Any other value will uncheck the checkbox.
 * @return {boolean} Boolean the new checked state of the checkbox
 */
Ext.form.ICheckbox.prototype.setRawValue = function(value) {};

/**
 * [Method] Sets the read only state of this field
 * @param {?=} readOnly Object
 * @return {void}
 */
Ext.form.ICheckbox.prototype.setReadOnly = function(readOnly) {};

/**
 * [Method] Sets the checked state of the checkbox and invokes change detection
 * @param {?=} checked Boolean/String The following values will check the checkbox: true, 'true', '1', or 'on', as well as a String that matches the inputValue. Any other value will uncheck the checkbox.
 * @return {!Ext.form.field.ICheckbox} Ext.form.field.Checkbox this
 */
Ext.form.ICheckbox.prototype.setValue = function(checked) {};

/**
 * [Method] private
 * @param {?=} value Object
 * @return {?} Object The converted raw value.
 */
Ext.form.ICheckbox.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.form.field.IPicker}
 * @extends {Ext.util.IBindable}
 * @record
 * @struct
 */
Ext.form.field.IComboBox = function() {};
 /** @type {string} */
Ext.form.field.IComboBox.prototype.allQuery;
 /** @type {boolean} */
Ext.form.field.IComboBox.prototype.anyMatch;
 /** @type {boolean} */
Ext.form.field.IComboBox.prototype.autoSelect;
 /** @type {boolean} */
Ext.form.field.IComboBox.prototype.caseSensitive;
 /** @type {?} */
Ext.form.field.IComboBox.prototype.componentLayout;
 /** @type {?} */
Ext.form.field.IComboBox.prototype.defaultListConfig;
 /** @type {string} */
Ext.form.field.IComboBox.prototype.delimiter;
 /** @type {string} */
Ext.form.field.IComboBox.prototype.displayField;
 /** @type {boolean} */
Ext.form.field.IComboBox.prototype.enableRegEx;
 /** @type {!Ext.IXTemplate} */
Ext.form.field.IComboBox.prototype.fieldSubTpl;
 /** @type {boolean} */
Ext.form.field.IComboBox.prototype.forceSelection;
 /** @type {boolean} */
Ext.form.field.IComboBox.prototype.growToLongestValue;
 /** @type {string} */
Ext.form.field.IComboBox.prototype.hiddenName;
 /** @type {?} */
Ext.form.field.IComboBox.prototype.listConfig;
 /** @type {number} */
Ext.form.field.IComboBox.prototype.minChars;
 /** @type {boolean} */
Ext.form.field.IComboBox.prototype.multiSelect;
 /** @type {number} */
Ext.form.field.IComboBox.prototype.pageSize;
 /** @type {boolean} */
Ext.form.field.IComboBox.prototype.queryCaching;
 /** @type {number} */
Ext.form.field.IComboBox.prototype.queryDelay;
 /** @type {string} */
Ext.form.field.IComboBox.prototype.queryMode;
 /** @type {string} */
Ext.form.field.IComboBox.prototype.queryParam;
 /** @type {boolean} */
Ext.form.field.IComboBox.prototype.selectOnTab;
 /** @type {?} */
Ext.form.field.IComboBox.prototype.store;
 /** @type {?} */
Ext.form.field.IComboBox.prototype.transform;
 /** @type {string} */
Ext.form.field.IComboBox.prototype.triggerAction;
 /** @type {string} */
Ext.form.field.IComboBox.prototype.triggerCls;
 /** @type {boolean} */
Ext.form.field.IComboBox.prototype.typeAhead;
 /** @type {number} */
Ext.form.field.IComboBox.prototype.typeAheadDelay;
 /** @type {string} */
Ext.form.field.IComboBox.prototype.valueField;
 /** @type {string} */
Ext.form.field.IComboBox.prototype.valueNotFoundText;
 /** @type {string} */
Ext.form.field.IComboBox.prototype.lastQuery;

/**
 * [Method] A method called when the filtering caused by the doQuery call is complete and the store has been either filtered loca
 * @param {?=} queryPlan Object An object containing details about the query was executed.
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.afterQuery = function(queryPlan) {};

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.afterRender = function() {};

/**
 * [Method] Aligns the picker to the input element
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.alignPicker = function() {};

/**
 * [Method] Template method to do any pre blur processing
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.beforeBlur = function() {};

/**
 * [Method] A method which may modify aspects of how the store is to be filtered if queryMode is local  of loaded if queryMod
 * @param {?=} queryPlan Object An object containing details about the query to be executed.
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.beforeQuery = function(queryPlan) {};

/**
 * [Method] Template method before a field is reset
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.beforeReset = function() {};

/**
 * [Method] Binds a store to this instance
 * @param {?=} store Ext.data.AbstractStore/String The store to bind or ID of the store. When no store given (or when null or undefined passed), unbinds the existing store.
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.bindStore = function(store) {};

/**
 * [Method] Binds listeners for this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to bind to
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.bindStoreListeners = function(store) {};

/**
 * [Method] Clears any value currently set in the ComboBox
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.clearValue = function() {};

/**
 * [Method] Creates and returns the component to be used as this field s picker
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.createPicker = function() {};

/**
 * [Method] Executes a query to filter the dropdown list
 * @param {string=} queryString String The string to use to filter available items by matching against the configured valueField.
 * @param {boolean=} forceAll Boolean true to force the query to execute even if there are currently fewer characters in the field than the minimum specified by the minChars config option. It also clears any filter previously saved in the current store.
 * @param {boolean=} rawQuery Boolean Pass as true if the raw typed value is being used as the query string. This causes the resulting store load to leave the raw value undisturbed.
 * @return {boolean} Boolean true if the query was permitted to run, false if it was cancelled by a beforequery handler.
 */
Ext.form.field.IComboBox.prototype.doQuery = function(queryString, forceAll, rawQuery) {};

/**
 * [Method] Finds the record by searching for a specific field value combination
 * @param {string=} field String The name of the field to test.
 * @param {?=} value Object The value to match the field against.
 * @return {!Ext.data.IModel} Ext.data.Model The matched record or false.
 */
Ext.form.field.IComboBox.prototype.findRecord = function(field, value) {};

/**
 * [Method] Finds the record by searching values in the displayField
 * @param {?=} value Object The value to match the field against.
 * @return {!Ext.data.IModel} Ext.data.Model The matched record or false.
 */
Ext.form.field.IComboBox.prototype.findRecordByDisplay = function(value) {};

/**
 * [Method] Finds the record by searching values in the valueField
 * @param {?=} value Object The value to match the field against.
 * @return {!Ext.data.IModel} Ext.data.Model The matched record or false.
 */
Ext.form.field.IComboBox.prototype.findRecordByValue = function(value) {};

/**
 * [Method] Returns the store associated with this ComboBox
 * @return {!Ext.data.IStore} Ext.data.Store The store
 */
Ext.form.field.IComboBox.prototype.getStore = function() {};

/**
 * [Method] Gets the listeners to bind to a new store
 * @return {?} Object The listeners to be bound to the store in object literal form. The scope may be omitted, it is assumed to be the current instance.
 */
Ext.form.field.IComboBox.prototype.getStoreListeners = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.field.IComboBox.prototype.getSubTplData = function() {};

/**
 * [Method] Returns the value that would be included in a standard form submit for this field
 * @return {string} String The value to be submitted, or null.
 */
Ext.form.field.IComboBox.prototype.getSubmitValue = function() {};

/**
 * [Method] Returns the current data value of the field
 * @return {?} Object value The field value
 */
Ext.form.field.IComboBox.prototype.getValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.initEvents = function() {};

/**
 * [Method] The picker the dropdown must have its zIndex managed by the same ZIndexManager which is providing the zIndex of our
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.onAdded = function() {};

/**
 * [Method] Template method it is called when a new store is bound to the current instance
 * @param {?=} store Object
 * @param {?=} initial Object
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.onBindStore = function(store, initial) {};

/**
 * [Method] Handles the trigger click by default toggles between expanding and collapsing the picker component
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.onTriggerClick = function() {};

/**
 * [Method] Template method it is called when an existing store is unbound from the current instance
 * @param {?=} store Object
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.onUnbindStore = function(store) {};

/**
 * [Method] Selects an item by a Model or by a key value
 * @param {?=} r Object
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.select = function(r) {};

/**
 * [Method] Sets the specified value s into the field
 * @param {?=} value String/String[] The value(s) to be set. Can be either a single String or Ext.data.Model, or an Array of Strings or Models.
 * @return {?} any this
 */
Ext.form.field.IComboBox.prototype.setValue = function(value) {};

/**
 * [Method] Unbinds listeners from this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to unbind from
 * @return {void}
 */
Ext.form.field.IComboBox.prototype.unbindStoreListeners = function(store) {};
/**
 * @extends {Ext.form.field.IPicker}
 * @extends {Ext.util.IBindable}
 * @record
 * @struct
 */
Ext.form.IComboBox = function() {};
 /** @type {string} */
Ext.form.IComboBox.prototype.allQuery;
 /** @type {boolean} */
Ext.form.IComboBox.prototype.anyMatch;
 /** @type {boolean} */
Ext.form.IComboBox.prototype.autoSelect;
 /** @type {boolean} */
Ext.form.IComboBox.prototype.caseSensitive;
 /** @type {?} */
Ext.form.IComboBox.prototype.componentLayout;
 /** @type {?} */
Ext.form.IComboBox.prototype.defaultListConfig;
 /** @type {string} */
Ext.form.IComboBox.prototype.delimiter;
 /** @type {string} */
Ext.form.IComboBox.prototype.displayField;
 /** @type {boolean} */
Ext.form.IComboBox.prototype.enableRegEx;
 /** @type {!Ext.IXTemplate} */
Ext.form.IComboBox.prototype.fieldSubTpl;
 /** @type {boolean} */
Ext.form.IComboBox.prototype.forceSelection;
 /** @type {boolean} */
Ext.form.IComboBox.prototype.growToLongestValue;
 /** @type {string} */
Ext.form.IComboBox.prototype.hiddenName;
 /** @type {?} */
Ext.form.IComboBox.prototype.listConfig;
 /** @type {number} */
Ext.form.IComboBox.prototype.minChars;
 /** @type {boolean} */
Ext.form.IComboBox.prototype.multiSelect;
 /** @type {number} */
Ext.form.IComboBox.prototype.pageSize;
 /** @type {boolean} */
Ext.form.IComboBox.prototype.queryCaching;
 /** @type {number} */
Ext.form.IComboBox.prototype.queryDelay;
 /** @type {string} */
Ext.form.IComboBox.prototype.queryMode;
 /** @type {string} */
Ext.form.IComboBox.prototype.queryParam;
 /** @type {boolean} */
Ext.form.IComboBox.prototype.selectOnTab;
 /** @type {?} */
Ext.form.IComboBox.prototype.store;
 /** @type {?} */
Ext.form.IComboBox.prototype.transform;
 /** @type {string} */
Ext.form.IComboBox.prototype.triggerAction;
 /** @type {string} */
Ext.form.IComboBox.prototype.triggerCls;
 /** @type {boolean} */
Ext.form.IComboBox.prototype.typeAhead;
 /** @type {number} */
Ext.form.IComboBox.prototype.typeAheadDelay;
 /** @type {string} */
Ext.form.IComboBox.prototype.valueField;
 /** @type {string} */
Ext.form.IComboBox.prototype.valueNotFoundText;
 /** @type {string} */
Ext.form.IComboBox.prototype.lastQuery;

/**
 * [Method] A method called when the filtering caused by the doQuery call is complete and the store has been either filtered loca
 * @param {?=} queryPlan Object An object containing details about the query was executed.
 * @return {void}
 */
Ext.form.IComboBox.prototype.afterQuery = function(queryPlan) {};

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.form.IComboBox.prototype.afterRender = function() {};

/**
 * [Method] Aligns the picker to the input element
 * @return {void}
 */
Ext.form.IComboBox.prototype.alignPicker = function() {};

/**
 * [Method] Template method to do any pre blur processing
 * @return {void}
 */
Ext.form.IComboBox.prototype.beforeBlur = function() {};

/**
 * [Method] A method which may modify aspects of how the store is to be filtered if queryMode is local  of loaded if queryMod
 * @param {?=} queryPlan Object An object containing details about the query to be executed.
 * @return {void}
 */
Ext.form.IComboBox.prototype.beforeQuery = function(queryPlan) {};

/**
 * [Method] Template method before a field is reset
 * @return {void}
 */
Ext.form.IComboBox.prototype.beforeReset = function() {};

/**
 * [Method] Binds a store to this instance
 * @param {?=} store Ext.data.AbstractStore/String The store to bind or ID of the store. When no store given (or when null or undefined passed), unbinds the existing store.
 * @return {void}
 */
Ext.form.IComboBox.prototype.bindStore = function(store) {};

/**
 * [Method] Binds listeners for this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to bind to
 * @return {void}
 */
Ext.form.IComboBox.prototype.bindStoreListeners = function(store) {};

/**
 * [Method] Clears any value currently set in the ComboBox
 * @return {void}
 */
Ext.form.IComboBox.prototype.clearValue = function() {};

/**
 * [Method] Creates and returns the component to be used as this field s picker
 * @return {void}
 */
Ext.form.IComboBox.prototype.createPicker = function() {};

/**
 * [Method] Executes a query to filter the dropdown list
 * @param {string=} queryString String The string to use to filter available items by matching against the configured valueField.
 * @param {boolean=} forceAll Boolean true to force the query to execute even if there are currently fewer characters in the field than the minimum specified by the minChars config option. It also clears any filter previously saved in the current store.
 * @param {boolean=} rawQuery Boolean Pass as true if the raw typed value is being used as the query string. This causes the resulting store load to leave the raw value undisturbed.
 * @return {boolean} Boolean true if the query was permitted to run, false if it was cancelled by a beforequery handler.
 */
Ext.form.IComboBox.prototype.doQuery = function(queryString, forceAll, rawQuery) {};

/**
 * [Method] Finds the record by searching for a specific field value combination
 * @param {string=} field String The name of the field to test.
 * @param {?=} value Object The value to match the field against.
 * @return {!Ext.data.IModel} Ext.data.Model The matched record or false.
 */
Ext.form.IComboBox.prototype.findRecord = function(field, value) {};

/**
 * [Method] Finds the record by searching values in the displayField
 * @param {?=} value Object The value to match the field against.
 * @return {!Ext.data.IModel} Ext.data.Model The matched record or false.
 */
Ext.form.IComboBox.prototype.findRecordByDisplay = function(value) {};

/**
 * [Method] Finds the record by searching values in the valueField
 * @param {?=} value Object The value to match the field against.
 * @return {!Ext.data.IModel} Ext.data.Model The matched record or false.
 */
Ext.form.IComboBox.prototype.findRecordByValue = function(value) {};

/**
 * [Method] Returns the store associated with this ComboBox
 * @return {!Ext.data.IStore} Ext.data.Store The store
 */
Ext.form.IComboBox.prototype.getStore = function() {};

/**
 * [Method] Gets the listeners to bind to a new store
 * @return {?} Object The listeners to be bound to the store in object literal form. The scope may be omitted, it is assumed to be the current instance.
 */
Ext.form.IComboBox.prototype.getStoreListeners = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.IComboBox.prototype.getSubTplData = function() {};

/**
 * [Method] Returns the value that would be included in a standard form submit for this field
 * @return {string} String The value to be submitted, or null.
 */
Ext.form.IComboBox.prototype.getSubmitValue = function() {};

/**
 * [Method] Returns the current data value of the field
 * @return {?} Object value The field value
 */
Ext.form.IComboBox.prototype.getValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IComboBox.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IComboBox.prototype.initEvents = function() {};

/**
 * [Method] The picker the dropdown must have its zIndex managed by the same ZIndexManager which is providing the zIndex of our
 * @return {void}
 */
Ext.form.IComboBox.prototype.onAdded = function() {};

/**
 * [Method] Template method it is called when a new store is bound to the current instance
 * @param {?=} store Object
 * @param {?=} initial Object
 * @return {void}
 */
Ext.form.IComboBox.prototype.onBindStore = function(store, initial) {};

/**
 * [Method] Handles the trigger click by default toggles between expanding and collapsing the picker component
 * @return {void}
 */
Ext.form.IComboBox.prototype.onTriggerClick = function() {};

/**
 * [Method] Template method it is called when an existing store is unbound from the current instance
 * @param {?=} store Object
 * @return {void}
 */
Ext.form.IComboBox.prototype.onUnbindStore = function(store) {};

/**
 * [Method] Selects an item by a Model or by a key value
 * @param {?=} r Object
 * @return {void}
 */
Ext.form.IComboBox.prototype.select = function(r) {};

/**
 * [Method] Sets the specified value s into the field
 * @param {?=} value String/String[] The value(s) to be set. Can be either a single String or Ext.data.Model, or an Array of Strings or Models.
 * @return {?} any this
 */
Ext.form.IComboBox.prototype.setValue = function(value) {};

/**
 * [Method] Unbinds listeners from this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to unbind from
 * @return {void}
 */
Ext.form.IComboBox.prototype.unbindStoreListeners = function(store) {};
/**
 * @extends {Ext.form.field.IPicker}
 * @record
 * @struct
 */
Ext.form.field.IDate = function() {};
 /** @type {string} */
Ext.form.field.IDate.prototype.altFormats;
 /** @type {!Array<string>} */
Ext.form.field.IDate.prototype.disabledDates;
 /** @type {string} */
Ext.form.field.IDate.prototype.disabledDatesText;
 /** @type {!Array<number>} */
Ext.form.field.IDate.prototype.disabledDays;
 /** @type {string} */
Ext.form.field.IDate.prototype.disabledDaysText;
 /** @type {string} */
Ext.form.field.IDate.prototype.format;
 /** @type {string} */
Ext.form.field.IDate.prototype.invalidText;
 /** @type {boolean} */
Ext.form.field.IDate.prototype.matchFieldWidth;
 /** @type {string} */
Ext.form.field.IDate.prototype.maxText;
 /** @type {?} */
Ext.form.field.IDate.prototype.maxValue;
 /** @type {string} */
Ext.form.field.IDate.prototype.minText;
 /** @type {?} */
Ext.form.field.IDate.prototype.minValue;
 /** @type {boolean} */
Ext.form.field.IDate.prototype.showToday;
 /** @type {number} */
Ext.form.field.IDate.prototype.startDay;
 /** @type {string} */
Ext.form.field.IDate.prototype.submitFormat;
 /** @type {string} */
Ext.form.field.IDate.prototype.triggerCls;
 /** @type {boolean} */
Ext.form.field.IDate.prototype.useStrict;
 /** @type {?} */
Ext.form.field.IDate.prototype.safeParse;

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IDate.prototype.beforeBlur = function() {};

/**
 * [Method] Creates and returns the component to be used as this field s picker
 * @return {void}
 */
Ext.form.field.IDate.prototype.createPicker = function() {};

/**
 * [Method] Runs all of Date s validations and returns an array of any errors
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {!Array<string>} String[] All validation errors for this field
 */
Ext.form.field.IDate.prototype.getErrors = function(value) {};

/**
 * [Method]
 * @return {void}
 */
Ext.form.field.IDate.prototype.initComponent = function() {};

/**
 * [Method] Initializes the field s value based on the initial config
 * @return {void}
 */
Ext.form.field.IDate.prototype.initValue = function() {};

/**
 * [Method] Converts a raw input field value into a mixed type value that is suitable for this particular field type
 * @param {?=} rawValue Object
 * @return {?} Object The converted value.
 */
Ext.form.field.IDate.prototype.rawToValue = function(rawValue) {};

/**
 * [Method] Replaces any existing disabled dates with new values and refreshes the Date picker
 * @param {!Array<string>=} disabledDates String[] An array of date strings (see the disabledDates config for details on supported values) used to disable a pattern of dates.
 * @return {void}
 */
Ext.form.field.IDate.prototype.setDisabledDates = function(disabledDates) {};

/**
 * [Method] Replaces any existing disabled days by index 0 6 with new values and refreshes the Date picker
 * @param {!Array<number>=} disabledDays Number[] An array of disabled day indexes. See the disabledDays config for details on supported values.
 * @return {void}
 */
Ext.form.field.IDate.prototype.setDisabledDays = function(disabledDays) {};

/**
 * [Method] Replaces any existing maxValue with the new value and refreshes the Date picker
 * @param {?=} value Date The maximum date that can be selected
 * @return {void}
 */
Ext.form.field.IDate.prototype.setMaxValue = function(value) {};

/**
 * [Method] Replaces any existing minValue with the new value and refreshes the Date picker
 * @param {?=} value Date The minimum date that can be selected
 * @return {void}
 */
Ext.form.field.IDate.prototype.setMinValue = function(value) {};

/**
 * [Method] Sets the value of the date field
 * @param {?=} date String/Date The date or valid date string
 * @return {!Ext.form.field.IDate} Ext.form.field.Date this
 */
Ext.form.field.IDate.prototype.setValue = function(date) {};

/**
 * [Method] Converts a mixed type value to a raw representation suitable for displaying in the field
 * @param {?=} value Object
 * @return {?} Object The converted raw value.
 */
Ext.form.field.IDate.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.form.field.IPicker}
 * @record
 * @struct
 */
Ext.form.IDateField = function() {};
 /** @type {string} */
Ext.form.IDateField.prototype.altFormats;
 /** @type {!Array<string>} */
Ext.form.IDateField.prototype.disabledDates;
 /** @type {string} */
Ext.form.IDateField.prototype.disabledDatesText;
 /** @type {!Array<number>} */
Ext.form.IDateField.prototype.disabledDays;
 /** @type {string} */
Ext.form.IDateField.prototype.disabledDaysText;
 /** @type {string} */
Ext.form.IDateField.prototype.format;
 /** @type {string} */
Ext.form.IDateField.prototype.invalidText;
 /** @type {boolean} */
Ext.form.IDateField.prototype.matchFieldWidth;
 /** @type {string} */
Ext.form.IDateField.prototype.maxText;
 /** @type {?} */
Ext.form.IDateField.prototype.maxValue;
 /** @type {string} */
Ext.form.IDateField.prototype.minText;
 /** @type {?} */
Ext.form.IDateField.prototype.minValue;
 /** @type {boolean} */
Ext.form.IDateField.prototype.showToday;
 /** @type {number} */
Ext.form.IDateField.prototype.startDay;
 /** @type {string} */
Ext.form.IDateField.prototype.submitFormat;
 /** @type {string} */
Ext.form.IDateField.prototype.triggerCls;
 /** @type {boolean} */
Ext.form.IDateField.prototype.useStrict;
 /** @type {?} */
Ext.form.IDateField.prototype.safeParse;

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IDateField.prototype.beforeBlur = function() {};

/**
 * [Method] Creates and returns the component to be used as this field s picker
 * @return {void}
 */
Ext.form.IDateField.prototype.createPicker = function() {};

/**
 * [Method] Runs all of Date s validations and returns an array of any errors
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {!Array<string>} String[] All validation errors for this field
 */
Ext.form.IDateField.prototype.getErrors = function(value) {};

/**
 * [Method]
 * @return {void}
 */
Ext.form.IDateField.prototype.initComponent = function() {};

/**
 * [Method] Initializes the field s value based on the initial config
 * @return {void}
 */
Ext.form.IDateField.prototype.initValue = function() {};

/**
 * [Method] Converts a raw input field value into a mixed type value that is suitable for this particular field type
 * @param {?=} rawValue Object
 * @return {?} Object The converted value.
 */
Ext.form.IDateField.prototype.rawToValue = function(rawValue) {};

/**
 * [Method] Replaces any existing disabled dates with new values and refreshes the Date picker
 * @param {!Array<string>=} disabledDates String[] An array of date strings (see the disabledDates config for details on supported values) used to disable a pattern of dates.
 * @return {void}
 */
Ext.form.IDateField.prototype.setDisabledDates = function(disabledDates) {};

/**
 * [Method] Replaces any existing disabled days by index 0 6 with new values and refreshes the Date picker
 * @param {!Array<number>=} disabledDays Number[] An array of disabled day indexes. See the disabledDays config for details on supported values.
 * @return {void}
 */
Ext.form.IDateField.prototype.setDisabledDays = function(disabledDays) {};

/**
 * [Method] Replaces any existing maxValue with the new value and refreshes the Date picker
 * @param {?=} value Date The maximum date that can be selected
 * @return {void}
 */
Ext.form.IDateField.prototype.setMaxValue = function(value) {};

/**
 * [Method] Replaces any existing minValue with the new value and refreshes the Date picker
 * @param {?=} value Date The minimum date that can be selected
 * @return {void}
 */
Ext.form.IDateField.prototype.setMinValue = function(value) {};

/**
 * [Method] Sets the value of the date field
 * @param {?=} date String/Date The date or valid date string
 * @return {!Ext.form.field.IDate} Ext.form.field.Date this
 */
Ext.form.IDateField.prototype.setValue = function(date) {};

/**
 * [Method] Converts a mixed type value to a raw representation suitable for displaying in the field
 * @param {?=} value Object
 * @return {?} Object The converted raw value.
 */
Ext.form.IDateField.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.form.field.IPicker}
 * @record
 * @struct
 */
Ext.form.IDate = function() {};
 /** @type {string} */
Ext.form.IDate.prototype.altFormats;
 /** @type {!Array<string>} */
Ext.form.IDate.prototype.disabledDates;
 /** @type {string} */
Ext.form.IDate.prototype.disabledDatesText;
 /** @type {!Array<number>} */
Ext.form.IDate.prototype.disabledDays;
 /** @type {string} */
Ext.form.IDate.prototype.disabledDaysText;
 /** @type {string} */
Ext.form.IDate.prototype.format;
 /** @type {string} */
Ext.form.IDate.prototype.invalidText;
 /** @type {boolean} */
Ext.form.IDate.prototype.matchFieldWidth;
 /** @type {string} */
Ext.form.IDate.prototype.maxText;
 /** @type {?} */
Ext.form.IDate.prototype.maxValue;
 /** @type {string} */
Ext.form.IDate.prototype.minText;
 /** @type {?} */
Ext.form.IDate.prototype.minValue;
 /** @type {boolean} */
Ext.form.IDate.prototype.showToday;
 /** @type {number} */
Ext.form.IDate.prototype.startDay;
 /** @type {string} */
Ext.form.IDate.prototype.submitFormat;
 /** @type {string} */
Ext.form.IDate.prototype.triggerCls;
 /** @type {boolean} */
Ext.form.IDate.prototype.useStrict;
 /** @type {?} */
Ext.form.IDate.prototype.safeParse;

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IDate.prototype.beforeBlur = function() {};

/**
 * [Method] Creates and returns the component to be used as this field s picker
 * @return {void}
 */
Ext.form.IDate.prototype.createPicker = function() {};

/**
 * [Method] Runs all of Date s validations and returns an array of any errors
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {!Array<string>} String[] All validation errors for this field
 */
Ext.form.IDate.prototype.getErrors = function(value) {};

/**
 * [Method]
 * @return {void}
 */
Ext.form.IDate.prototype.initComponent = function() {};

/**
 * [Method] Initializes the field s value based on the initial config
 * @return {void}
 */
Ext.form.IDate.prototype.initValue = function() {};

/**
 * [Method] Converts a raw input field value into a mixed type value that is suitable for this particular field type
 * @param {?=} rawValue Object
 * @return {?} Object The converted value.
 */
Ext.form.IDate.prototype.rawToValue = function(rawValue) {};

/**
 * [Method] Replaces any existing disabled dates with new values and refreshes the Date picker
 * @param {!Array<string>=} disabledDates String[] An array of date strings (see the disabledDates config for details on supported values) used to disable a pattern of dates.
 * @return {void}
 */
Ext.form.IDate.prototype.setDisabledDates = function(disabledDates) {};

/**
 * [Method] Replaces any existing disabled days by index 0 6 with new values and refreshes the Date picker
 * @param {!Array<number>=} disabledDays Number[] An array of disabled day indexes. See the disabledDays config for details on supported values.
 * @return {void}
 */
Ext.form.IDate.prototype.setDisabledDays = function(disabledDays) {};

/**
 * [Method] Replaces any existing maxValue with the new value and refreshes the Date picker
 * @param {?=} value Date The maximum date that can be selected
 * @return {void}
 */
Ext.form.IDate.prototype.setMaxValue = function(value) {};

/**
 * [Method] Replaces any existing minValue with the new value and refreshes the Date picker
 * @param {?=} value Date The minimum date that can be selected
 * @return {void}
 */
Ext.form.IDate.prototype.setMinValue = function(value) {};

/**
 * [Method] Sets the value of the date field
 * @param {?=} date String/Date The date or valid date string
 * @return {!Ext.form.field.IDate} Ext.form.field.Date this
 */
Ext.form.IDate.prototype.setValue = function(date) {};

/**
 * [Method] Converts a mixed type value to a raw representation suitable for displaying in the field
 * @param {?=} value Object
 * @return {?} Object The converted raw value.
 */
Ext.form.IDate.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.form.field.IBase}
 * @record
 * @struct
 */
Ext.form.field.IDisplay = function() {};
 /** @type {string} */
Ext.form.field.IDisplay.prototype.fieldBodyCls;
 /** @type {string} */
Ext.form.field.IDisplay.prototype.fieldCls;
 /** @type {boolean} */
Ext.form.field.IDisplay.prototype.htmlEncode;
 /** @type {?} */
Ext.form.field.IDisplay.prototype.renderer;
 /** @type {?} */
Ext.form.field.IDisplay.prototype.scope;
 /** @type {boolean} */
Ext.form.field.IDisplay.prototype.submitValue;

/**
 * [Method] Returns the raw value of the field without performing any normalization conversion or validation
 * @return {string} String value The raw String value of the field
 */
Ext.form.field.IDisplay.prototype.getRawValue = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.field.IDisplay.prototype.getSubTplData = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IDisplay.prototype.initEvents = function() {};

/**
 * [Method] Returns true if the value of this Field has been changed from its originalValue
 * @return {boolean} Boolean True if this field has been changed from its original value (and is not disabled), false otherwise.
 */
Ext.form.field.IDisplay.prototype.isDirty = function() {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the processed raw value of the field
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.field.IDisplay.prototype.isValid = function() {};

/**
 * [Method] Sets the field s raw value directly bypassing value conversion change detection and validation
 * @param {?=} value Object
 * @return {?} Object value The field value that is set
 */
Ext.form.field.IDisplay.prototype.setRawValue = function(value) {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the field s current value and fires the vali
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.field.IDisplay.prototype.validate = function() {};
/**
 * @extends {Ext.form.field.IBase}
 * @record
 * @struct
 */
Ext.form.IDisplayField = function() {};
 /** @type {string} */
Ext.form.IDisplayField.prototype.fieldBodyCls;
 /** @type {string} */
Ext.form.IDisplayField.prototype.fieldCls;
 /** @type {boolean} */
Ext.form.IDisplayField.prototype.htmlEncode;
 /** @type {?} */
Ext.form.IDisplayField.prototype.renderer;
 /** @type {?} */
Ext.form.IDisplayField.prototype.scope;
 /** @type {boolean} */
Ext.form.IDisplayField.prototype.submitValue;

/**
 * [Method] Returns the raw value of the field without performing any normalization conversion or validation
 * @return {string} String value The raw String value of the field
 */
Ext.form.IDisplayField.prototype.getRawValue = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.IDisplayField.prototype.getSubTplData = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IDisplayField.prototype.initEvents = function() {};

/**
 * [Method] Returns true if the value of this Field has been changed from its originalValue
 * @return {boolean} Boolean True if this field has been changed from its original value (and is not disabled), false otherwise.
 */
Ext.form.IDisplayField.prototype.isDirty = function() {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the processed raw value of the field
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.IDisplayField.prototype.isValid = function() {};

/**
 * [Method] Sets the field s raw value directly bypassing value conversion change detection and validation
 * @param {?=} value Object
 * @return {?} Object value The field value that is set
 */
Ext.form.IDisplayField.prototype.setRawValue = function(value) {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the field s current value and fires the vali
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.IDisplayField.prototype.validate = function() {};
/**
 * @extends {Ext.form.field.IBase}
 * @record
 * @struct
 */
Ext.form.IDisplay = function() {};
 /** @type {string} */
Ext.form.IDisplay.prototype.fieldBodyCls;
 /** @type {string} */
Ext.form.IDisplay.prototype.fieldCls;
 /** @type {boolean} */
Ext.form.IDisplay.prototype.htmlEncode;
 /** @type {?} */
Ext.form.IDisplay.prototype.renderer;
 /** @type {?} */
Ext.form.IDisplay.prototype.scope;
 /** @type {boolean} */
Ext.form.IDisplay.prototype.submitValue;

/**
 * [Method] Returns the raw value of the field without performing any normalization conversion or validation
 * @return {string} String value The raw String value of the field
 */
Ext.form.IDisplay.prototype.getRawValue = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.IDisplay.prototype.getSubTplData = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IDisplay.prototype.initEvents = function() {};

/**
 * [Method] Returns true if the value of this Field has been changed from its originalValue
 * @return {boolean} Boolean True if this field has been changed from its original value (and is not disabled), false otherwise.
 */
Ext.form.IDisplay.prototype.isDirty = function() {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the processed raw value of the field
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.IDisplay.prototype.isValid = function() {};

/**
 * [Method] Sets the field s raw value directly bypassing value conversion change detection and validation
 * @param {?=} value Object
 * @return {?} Object value The field value that is set
 */
Ext.form.IDisplay.prototype.setRawValue = function(value) {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the field s current value and fires the vali
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.IDisplay.prototype.validate = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.form.field.IField = function() {};
 /** @type {boolean} */
Ext.form.field.IField.prototype.disabled;
 /** @type {string} */
Ext.form.field.IField.prototype.name;
 /** @type {boolean} */
Ext.form.field.IField.prototype.submitValue;
 /** @type {boolean} */
Ext.form.field.IField.prototype.validateOnChange;
 /** @type {?} */
Ext.form.field.IField.prototype.value;
 /** @type {boolean} */
Ext.form.field.IField.prototype.isFormField;
 /** @type {?} */
Ext.form.field.IField.prototype.originalValue;

/**
 * [Method] A utility for grouping a set of modifications which may trigger value changes into a single transaction to prevent e
 * @param {?=} fn Object A function containing the transaction code
 * @return {void}
 */
Ext.form.field.IField.prototype.batchChanges = function(fn) {};

/**
 * [Method] Template method before a field is reset
 * @return {void}
 */
Ext.form.field.IField.prototype.beforeReset = function() {};

/**
 * [Method] Checks whether the value of the field has changed since the last time it was checked
 * @return {void}
 */
Ext.form.field.IField.prototype.checkChange = function() {};

/**
 * [Method] Checks the isDirty state of the field and if it has changed since the last time it was checked fires the dirtychange
 * @return {void}
 */
Ext.form.field.IField.prototype.checkDirty = function() {};

/**
 * [Method] Clear any invalid styles messages for this field
 * @return {void}
 */
Ext.form.field.IField.prototype.clearInvalid = function() {};

/**
 * [Method] Only relevant if the instance s isFileUpload method returns true
 * @return {?} any
 */
Ext.form.field.IField.prototype.extractFileInput = function() {};

/**
 * [Method] Runs this field s validators and returns an array of error messages for any validation failures
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {?} any All error messages for this field; an empty Array if none.
 */
Ext.form.field.IField.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the value s that should be saved to the Ext data Model instance for this field when Ext form Basic updateRe
 * @return {?} any A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.field.IField.prototype.getModelData = function() {};

/**
 * [Method] Returns the name attribute of the field
 * @return {string} string name The field name
 */
Ext.form.field.IField.prototype.getName = function() {};

/**
 * [Method] Returns the parameter s that would be included in a standard form submit for this field
 * @return {?} any A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.field.IField.prototype.getSubmitData = function() {};

/**
 * [Method] Returns the current data value of the field
 * @return {?} any value The field value
 */
Ext.form.field.IField.prototype.getValue = function() {};

/**
 * [Method] Initializes this Field mixin on the current instance
 * @return {void}
 */
Ext.form.field.IField.prototype.initField = function() {};

/**
 * [Method] Initializes the field s value based on the initial config
 * @return {void}
 */
Ext.form.field.IField.prototype.initValue = function() {};

/**
 * [Method] Returns true if the value of this Field has been changed from its originalValue
 * @return {?} any True if this field has been changed from its original value (and is not disabled), false otherwise.
 */
Ext.form.field.IField.prototype.isDirty = function() {};

/**
 * [Method] Returns whether two field values are logically equal
 * @param {?=} value1 Object The first value to compare
 * @param {?=} value2 Object The second value to compare
 * @return {?} any True if the values are equal, false if inequal.
 */
Ext.form.field.IField.prototype.isEqual = function(value1, value2) {};

/**
 * [Method] Returns whether this Field is a file upload field if it returns true forms will use special techniques for submitti
 * @return {?} any
 */
Ext.form.field.IField.prototype.isFileUpload = function() {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the field s current value
 * @return {?} any True if the value is valid, else false
 */
Ext.form.field.IField.prototype.isValid = function() {};

/**
 * [Method] Associate one or more error messages with this field
 * @param {?=} errors String/String[] The error message(s) for the field.
 * @return {void}
 */
Ext.form.field.IField.prototype.markInvalid = function(errors) {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.form.field.IField.prototype.reset = function() {};

/**
 * [Method] Resets the field s originalValue property so it matches the current value
 * @return {void}
 */
Ext.form.field.IField.prototype.resetOriginalValue = function() {};

/**
 * [Method] Sets a data value into the field and runs the change detection and validation
 * @param {?=} value Object The value to set
 * @return {?} any this
 */
Ext.form.field.IField.prototype.setValue = function(value) {};

/**
 * [Method] Allows for any necessary modifications before the original value is set
 * @param {?=} value Object The initial value
 * @return {?} any The modified initial value
 */
Ext.form.field.IField.prototype.transformOriginalValue = function(value) {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the field s current value and fires the vali
 * @return {?} any True if the value is valid, else false
 */
Ext.form.field.IField.prototype.validate = function() {};
/**
 * @extends {Ext.form.field.ITrigger}
 * @record
 * @struct
 */
Ext.form.field.IFile = function() {};
 /** @type {?} */
Ext.form.field.IFile.prototype.buttonConfig;
 /** @type {number} */
Ext.form.field.IFile.prototype.buttonMargin;
 /** @type {boolean} */
Ext.form.field.IFile.prototype.buttonOnly;
 /** @type {string} */
Ext.form.field.IFile.prototype.buttonText;
 /** @type {boolean} */
Ext.form.field.IFile.prototype.clearOnSubmit;
 /** @type {?} */
Ext.form.field.IFile.prototype.componentLayout;
 /** @type {boolean} */
Ext.form.field.IFile.prototype.readOnly;
 /** @type {!Ext.button.IButton} */
Ext.form.field.IFile.prototype.button;
 /** @type {!Ext.IElement} */
Ext.form.field.IFile.prototype.fileInputEl;

/**
 * [Method] Only relevant if the instance s isFileUpload method returns true
 * @return {!HTMLElement} HTMLElement
 */
Ext.form.field.IFile.prototype.extractFileInput = function() {};

/**
 * [Method] Gets the markup to be inserted into the subTplMarkup
 * @return {void}
 */
Ext.form.field.IFile.prototype.getTriggerMarkup = function() {};

/**
 * [Method] Returns whether this Field is a file upload field if it returns true forms will use special techniques for submitti
 * @return {boolean} Boolean
 */
Ext.form.field.IFile.prototype.isFileUpload = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IFile.prototype.onDisable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IFile.prototype.onEnable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IFile.prototype.onRender = function() {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.form.field.IFile.prototype.onShow = function() {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.form.field.IFile.prototype.reset = function() {};

/**
 * [Method] Overridden to do nothing
 * @return {void}
 */
Ext.form.field.IFile.prototype.setValue = function() {};
/**
 * @extends {Ext.form.field.ITrigger}
 * @record
 * @struct
 */
Ext.form.IFileUploadField = function() {};
 /** @type {?} */
Ext.form.IFileUploadField.prototype.buttonConfig;
 /** @type {number} */
Ext.form.IFileUploadField.prototype.buttonMargin;
 /** @type {boolean} */
Ext.form.IFileUploadField.prototype.buttonOnly;
 /** @type {string} */
Ext.form.IFileUploadField.prototype.buttonText;
 /** @type {boolean} */
Ext.form.IFileUploadField.prototype.clearOnSubmit;
 /** @type {?} */
Ext.form.IFileUploadField.prototype.componentLayout;
 /** @type {boolean} */
Ext.form.IFileUploadField.prototype.readOnly;
 /** @type {!Ext.button.IButton} */
Ext.form.IFileUploadField.prototype.button;
 /** @type {!Ext.IElement} */
Ext.form.IFileUploadField.prototype.fileInputEl;

/**
 * [Method] Only relevant if the instance s isFileUpload method returns true
 * @return {!HTMLElement} HTMLElement
 */
Ext.form.IFileUploadField.prototype.extractFileInput = function() {};

/**
 * [Method] Gets the markup to be inserted into the subTplMarkup
 * @return {void}
 */
Ext.form.IFileUploadField.prototype.getTriggerMarkup = function() {};

/**
 * [Method] Returns whether this Field is a file upload field if it returns true forms will use special techniques for submitti
 * @return {boolean} Boolean
 */
Ext.form.IFileUploadField.prototype.isFileUpload = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IFileUploadField.prototype.onDisable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IFileUploadField.prototype.onEnable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IFileUploadField.prototype.onRender = function() {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.form.IFileUploadField.prototype.onShow = function() {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.form.IFileUploadField.prototype.reset = function() {};

/**
 * [Method] Overridden to do nothing
 * @return {void}
 */
Ext.form.IFileUploadField.prototype.setValue = function() {};
/** @const */
Ext.ux = {};
/** @const */
Ext.ux.form = {};
/**
 * @extends {Ext.form.field.ITrigger}
 * @record
 * @struct
 */
Ext.ux.form.IFileUploadField = function() {};
 /** @type {?} */
Ext.ux.form.IFileUploadField.prototype.buttonConfig;
 /** @type {number} */
Ext.ux.form.IFileUploadField.prototype.buttonMargin;
 /** @type {boolean} */
Ext.ux.form.IFileUploadField.prototype.buttonOnly;
 /** @type {string} */
Ext.ux.form.IFileUploadField.prototype.buttonText;
 /** @type {boolean} */
Ext.ux.form.IFileUploadField.prototype.clearOnSubmit;
 /** @type {?} */
Ext.ux.form.IFileUploadField.prototype.componentLayout;
 /** @type {boolean} */
Ext.ux.form.IFileUploadField.prototype.readOnly;
 /** @type {!Ext.button.IButton} */
Ext.ux.form.IFileUploadField.prototype.button;
 /** @type {!Ext.IElement} */
Ext.ux.form.IFileUploadField.prototype.fileInputEl;

/**
 * [Method] Only relevant if the instance s isFileUpload method returns true
 * @return {!HTMLElement} HTMLElement
 */
Ext.ux.form.IFileUploadField.prototype.extractFileInput = function() {};

/**
 * [Method] Gets the markup to be inserted into the subTplMarkup
 * @return {void}
 */
Ext.ux.form.IFileUploadField.prototype.getTriggerMarkup = function() {};

/**
 * [Method] Returns whether this Field is a file upload field if it returns true forms will use special techniques for submitti
 * @return {boolean} Boolean
 */
Ext.ux.form.IFileUploadField.prototype.isFileUpload = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.ux.form.IFileUploadField.prototype.onDisable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.ux.form.IFileUploadField.prototype.onEnable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.ux.form.IFileUploadField.prototype.onRender = function() {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.ux.form.IFileUploadField.prototype.onShow = function() {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.ux.form.IFileUploadField.prototype.reset = function() {};

/**
 * [Method] Overridden to do nothing
 * @return {void}
 */
Ext.ux.form.IFileUploadField.prototype.setValue = function() {};
/**
 * @extends {Ext.form.field.ITrigger}
 * @record
 * @struct
 */
Ext.form.IFile = function() {};
 /** @type {?} */
Ext.form.IFile.prototype.buttonConfig;
 /** @type {number} */
Ext.form.IFile.prototype.buttonMargin;
 /** @type {boolean} */
Ext.form.IFile.prototype.buttonOnly;
 /** @type {string} */
Ext.form.IFile.prototype.buttonText;
 /** @type {boolean} */
Ext.form.IFile.prototype.clearOnSubmit;
 /** @type {?} */
Ext.form.IFile.prototype.componentLayout;
 /** @type {boolean} */
Ext.form.IFile.prototype.readOnly;
 /** @type {!Ext.button.IButton} */
Ext.form.IFile.prototype.button;
 /** @type {!Ext.IElement} */
Ext.form.IFile.prototype.fileInputEl;

/**
 * [Method] Only relevant if the instance s isFileUpload method returns true
 * @return {!HTMLElement} HTMLElement
 */
Ext.form.IFile.prototype.extractFileInput = function() {};

/**
 * [Method] Gets the markup to be inserted into the subTplMarkup
 * @return {void}
 */
Ext.form.IFile.prototype.getTriggerMarkup = function() {};

/**
 * [Method] Returns whether this Field is a file upload field if it returns true forms will use special techniques for submitti
 * @return {boolean} Boolean
 */
Ext.form.IFile.prototype.isFileUpload = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IFile.prototype.onDisable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IFile.prototype.onEnable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IFile.prototype.onRender = function() {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.form.IFile.prototype.onShow = function() {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.form.IFile.prototype.reset = function() {};

/**
 * [Method] Overridden to do nothing
 * @return {void}
 */
Ext.form.IFile.prototype.setValue = function() {};
/**
 * @extends {Ext.button.IButton}
 * @record
 * @struct
 */
Ext.form.field.IFileButton = function() {};
 /** @type {string} */
Ext.form.field.IFileButton.prototype.cls;
 /** @type {boolean} */
Ext.form.field.IFileButton.prototype.preventDefault;
 /** @type {?} */
Ext.form.field.IFileButton.prototype.renderTpl;

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.form.field.IFileButton.prototype.afterRender = function() {};

/**
 * [Method] This method returns an object which provides substitution parameters for the XTemplate used to create this Button s D
 * @return {?} Object Substitution data for a Template. The default implementation which provides data for the default template returns an Object containing the following properties:
 */
Ext.form.field.IFileButton.prototype.getTemplateArgs = function() {};

/**
 * [Method] See comments in onFocus
 * @return {void}
 */
Ext.form.field.IFileButton.prototype.onDisable = function() {};

/**
 * [Method] Allows addition of behavior to the enable operation
 * @return {void}
 */
Ext.form.field.IFileButton.prototype.onEnable = function() {};
/**
 * @extends {Ext.form.field.IBase}
 * @record
 * @struct
 */
Ext.form.field.IHidden = function() {};
 /** @type {boolean} */
Ext.form.field.IHidden.prototype.hidden;
 /** @type {boolean} */
Ext.form.field.IHidden.prototype.hideLabel;
 /** @type {string} */
Ext.form.field.IHidden.prototype.inputType;

/**
 * [Method] Clear any invalid styles messages for this field
 * @return {void}
 */
Ext.form.field.IHidden.prototype.clearInvalid = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IHidden.prototype.initComponent = function() {};

/**
 * [Method] These are all private overrides
 * @return {void}
 */
Ext.form.field.IHidden.prototype.initEvents = function() {};

/**
 * [Method] Display one or more error messages associated with this field using msgTarget to determine how to display the messag
 * @return {void}
 */
Ext.form.field.IHidden.prototype.markInvalid = function() {};

/**
 * [Method] Sets the height of the component
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.form.field.IHidden.prototype.setHeight = function() {};

/**
 * [Method] Sets the page XY position of the component
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.form.field.IHidden.prototype.setPagePosition = function() {};

/**
 * [Method] Sets the left and top of the component
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.form.field.IHidden.prototype.setPosition = function() {};

/**
 * [Method] Sets the width and height of this Component
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.form.field.IHidden.prototype.setSize = function() {};

/**
 * [Method] Sets the width of the component
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.form.field.IHidden.prototype.setWidth = function() {};
/**
 * @extends {Ext.form.field.IBase}
 * @record
 * @struct
 */
Ext.form.IHidden = function() {};
 /** @type {boolean} */
Ext.form.IHidden.prototype.hidden;
 /** @type {boolean} */
Ext.form.IHidden.prototype.hideLabel;
 /** @type {string} */
Ext.form.IHidden.prototype.inputType;

/**
 * [Method] Clear any invalid styles messages for this field
 * @return {void}
 */
Ext.form.IHidden.prototype.clearInvalid = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IHidden.prototype.initComponent = function() {};

/**
 * [Method] These are all private overrides
 * @return {void}
 */
Ext.form.IHidden.prototype.initEvents = function() {};

/**
 * [Method] Display one or more error messages associated with this field using msgTarget to determine how to display the messag
 * @return {void}
 */
Ext.form.IHidden.prototype.markInvalid = function() {};

/**
 * [Method] Sets the height of the component
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.form.IHidden.prototype.setHeight = function() {};

/**
 * [Method] Sets the page XY position of the component
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.form.IHidden.prototype.setPagePosition = function() {};

/**
 * [Method] Sets the left and top of the component
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.form.IHidden.prototype.setPosition = function() {};

/**
 * [Method] Sets the width and height of this Component
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.form.IHidden.prototype.setSize = function() {};

/**
 * [Method] Sets the width of the component
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.form.IHidden.prototype.setWidth = function() {};
/**
 * @extends {Ext.form.IFieldContainer}
 * @extends {Ext.form.field.IField}
 * @record
 * @struct
 */
Ext.form.field.IHtmlEditor = function() {};
 /** @type {?} */
Ext.form.field.IHtmlEditor.prototype.afterIFrameTpl;
 /** @type {?} */
Ext.form.field.IHtmlEditor.prototype.afterTextAreaTpl;
 /** @type {?} */
Ext.form.field.IHtmlEditor.prototype.beforeIFrameTpl;
 /** @type {?} */
Ext.form.field.IHtmlEditor.prototype.beforeTextAreaTpl;
 /** @type {?} */
Ext.form.field.IHtmlEditor.prototype.componentLayout;
 /** @type {string} */
Ext.form.field.IHtmlEditor.prototype.createLinkText;
 /** @type {string} */
Ext.form.field.IHtmlEditor.prototype.defaultButtonUI;
 /** @type {string} */
Ext.form.field.IHtmlEditor.prototype.defaultLinkValue;
 /** @type {string} */
Ext.form.field.IHtmlEditor.prototype.defaultValue;
 /** @type {boolean} */
Ext.form.field.IHtmlEditor.prototype.enableAlignments;
 /** @type {boolean} */
Ext.form.field.IHtmlEditor.prototype.enableColors;
 /** @type {boolean} */
Ext.form.field.IHtmlEditor.prototype.enableFont;
 /** @type {boolean} */
Ext.form.field.IHtmlEditor.prototype.enableFontSize;
 /** @type {boolean} */
Ext.form.field.IHtmlEditor.prototype.enableFormat;
 /** @type {boolean} */
Ext.form.field.IHtmlEditor.prototype.enableLinks;
 /** @type {boolean} */
Ext.form.field.IHtmlEditor.prototype.enableLists;
 /** @type {boolean} */
Ext.form.field.IHtmlEditor.prototype.enableSourceEdit;
 /** @type {!Array<string>} */
Ext.form.field.IHtmlEditor.prototype.fontFamilies;
 /** @type {?} */
Ext.form.field.IHtmlEditor.prototype.iframeAttrTpl;
 /** @type {?} */
Ext.form.field.IHtmlEditor.prototype.buttonTips;
 /** @type {boolean} */
Ext.form.field.IHtmlEditor.prototype.maskOnDisable;

/**
 * [Method] A utility for grouping a set of modifications which may trigger value changes into a single transaction to prevent e
 * @param {?=} fn Object A function containing the transaction code
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.batchChanges = function(fn) {};

/**
 * [Method] Template method before a field is reset
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.beforeReset = function() {};

/**
 * [Method] Checks whether the value of the field has changed since the last time it was checked
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.checkChange = function() {};

/**
 * [Method] Checks the isDirty state of the field and if it has changed since the last time it was checked fires the dirtychange
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.checkDirty = function() {};

/**
 * [Method] If you need want custom HTML cleanup this is the method you should override
 * @param {string=} html String The HTML to be cleaned
 * @return {string} String The cleaned HTML
 */
Ext.form.field.IHtmlEditor.prototype.cleanHtml = function(html) {};

/**
 * [Method] Clear any invalid styles messages for this field
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.clearInvalid = function() {};

/**
 * [Method] Executes a Midas editor command directly on the editor document
 * @param {string=} cmd String The Midas command
 * @param {?=} value String/Boolean The value to pass to the command
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.execCmd = function(cmd, value) {};

/**
 * [Method] Only relevant if the instance s isFileUpload method returns true
 * @return {!HTMLElement} HTMLElement
 */
Ext.form.field.IHtmlEditor.prototype.extractFileInput = function() {};

/**
 * [Method] Try to focus this component
 * @param {?=} selectText Object
 * @param {?=} delay Object
 * @return {!Ext.IComponent} Ext.Component The focused Component. Usually this Component. Some Containers may delegate focus to a descendant Component (Windows can do this through their defaultFocus config option.
 */
Ext.form.field.IHtmlEditor.prototype.focus = function(selectText, delay) {};

/**
 * [Method] Called when the editor initializes the iframe with HTML contents
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.getDocMarkup = function() {};

/**
 * [Method] Runs this field s validators and returns an array of error messages for any validation failures
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {!Array<string>} String[] All error messages for this field; an empty Array if none.
 */
Ext.form.field.IHtmlEditor.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the value s that should be saved to the Ext data Model instance for this field when Ext form Basic updateRe
 * @return {?} Object A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.field.IHtmlEditor.prototype.getModelData = function() {};

/**
 * [Method] Returns the name attribute of the field
 * @return {string} String name The field name
 */
Ext.form.field.IHtmlEditor.prototype.getName = function() {};

/**
 * [Method] Returns the parameter s that would be included in a standard form submit for this field
 * @return {?} Object A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.field.IHtmlEditor.prototype.getSubmitData = function() {};

/**
 * [Method] Returns the editor s toolbar
 * @return {!Ext.toolbar.IToolbar} Ext.toolbar.Toolbar
 */
Ext.form.field.IHtmlEditor.prototype.getToolbar = function() {};

/**
 * [Method] Returns the current data value of the field
 * @return {?} Object value The field value
 */
Ext.form.field.IHtmlEditor.prototype.getValue = function() {};

/**
 * [Method] Initializes this Field mixin on the current instance
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.initField = function() {};

/**
 * [Method] Initializes the field s value based on the initial config
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.initValue = function() {};

/**
 * [Method] Inserts the passed text at the current cursor position
 * @param {string=} text String
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.insertAtCursor = function(text) {};

/**
 * [Method] Returns true if the value of this Field has been changed from its originalValue
 * @return {boolean} Boolean True if this field has been changed from its original value (and is not disabled), false otherwise.
 */
Ext.form.field.IHtmlEditor.prototype.isDirty = function() {};

/**
 * [Method] Returns whether two field values are logically equal
 * @param {?=} value1 Object
 * @param {?=} value2 Object
 * @return {boolean} Boolean True if the values are equal, false if inequal.
 */
Ext.form.field.IHtmlEditor.prototype.isEqual = function(value1, value2) {};

/**
 * [Method] Returns whether this Field is a file upload field if it returns true forms will use special techniques for submitti
 * @return {boolean} Boolean
 */
Ext.form.field.IHtmlEditor.prototype.isFileUpload = function() {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the field s current value
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.field.IHtmlEditor.prototype.isValid = function() {};

/**
 * [Method] Associate one or more error messages with this field
 * @param {?=} errors String/String[] The error message(s) for the field.
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.markInvalid = function(errors) {};

/**
 * [Method] Pushes the value of the textarea into the iframe editor
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.pushValue = function() {};

/**
 * [Method] Executes a Midas editor command on the editor document and performs necessary focus and toolbar updates
 * @param {string=} cmd String The Midas command
 * @param {?=} value String/Boolean The value to pass to the command
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.relayCmd = function(cmd, value) {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.reset = function() {};

/**
 * [Method] Resets the field s originalValue property so it matches the current value
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.resetOriginalValue = function() {};

/**
 * [Method] Sets the read only state of this field
 * @param {boolean=} readOnly Boolean Whether the field should be read only.
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.setReadOnly = function(readOnly) {};

/**
 * [Method] Sets a data value into the field and runs the change detection and validation
 * @param {?=} value Object
 * @return {?} any this
 */
Ext.form.field.IHtmlEditor.prototype.setValue = function(value) {};

/**
 * [Method] Syncs the contents of the editor iframe with the textarea
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.syncValue = function() {};

/**
 * [Method] Toggles the editor between standard and source edit mode
 * @param {boolean=} sourceEditMode Boolean True for source edit, false for standard
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.toggleSourceEdit = function(sourceEditMode) {};

/**
 * [Method] Allows for any necessary modifications before the original value is set
 * @param {?=} value Object The initial value
 * @return {?} Object The modified initial value
 */
Ext.form.field.IHtmlEditor.prototype.transformOriginalValue = function(value) {};

/**
 * [Method] Triggers a toolbar update by reading the markup state of the current selection in the editor
 * @return {void}
 */
Ext.form.field.IHtmlEditor.prototype.updateToolbar = function() {};
/**
 * @extends {Ext.form.IFieldContainer}
 * @extends {Ext.form.field.IField}
 * @record
 * @struct
 */
Ext.form.IHtmlEditor = function() {};
 /** @type {?} */
Ext.form.IHtmlEditor.prototype.afterIFrameTpl;
 /** @type {?} */
Ext.form.IHtmlEditor.prototype.afterTextAreaTpl;
 /** @type {?} */
Ext.form.IHtmlEditor.prototype.beforeIFrameTpl;
 /** @type {?} */
Ext.form.IHtmlEditor.prototype.beforeTextAreaTpl;
 /** @type {?} */
Ext.form.IHtmlEditor.prototype.componentLayout;
 /** @type {string} */
Ext.form.IHtmlEditor.prototype.createLinkText;
 /** @type {string} */
Ext.form.IHtmlEditor.prototype.defaultButtonUI;
 /** @type {string} */
Ext.form.IHtmlEditor.prototype.defaultLinkValue;
 /** @type {string} */
Ext.form.IHtmlEditor.prototype.defaultValue;
 /** @type {boolean} */
Ext.form.IHtmlEditor.prototype.enableAlignments;
 /** @type {boolean} */
Ext.form.IHtmlEditor.prototype.enableColors;
 /** @type {boolean} */
Ext.form.IHtmlEditor.prototype.enableFont;
 /** @type {boolean} */
Ext.form.IHtmlEditor.prototype.enableFontSize;
 /** @type {boolean} */
Ext.form.IHtmlEditor.prototype.enableFormat;
 /** @type {boolean} */
Ext.form.IHtmlEditor.prototype.enableLinks;
 /** @type {boolean} */
Ext.form.IHtmlEditor.prototype.enableLists;
 /** @type {boolean} */
Ext.form.IHtmlEditor.prototype.enableSourceEdit;
 /** @type {!Array<string>} */
Ext.form.IHtmlEditor.prototype.fontFamilies;
 /** @type {?} */
Ext.form.IHtmlEditor.prototype.iframeAttrTpl;
 /** @type {?} */
Ext.form.IHtmlEditor.prototype.buttonTips;
 /** @type {boolean} */
Ext.form.IHtmlEditor.prototype.maskOnDisable;

/**
 * [Method] A utility for grouping a set of modifications which may trigger value changes into a single transaction to prevent e
 * @param {?=} fn Object A function containing the transaction code
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.batchChanges = function(fn) {};

/**
 * [Method] Template method before a field is reset
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.beforeReset = function() {};

/**
 * [Method] Checks whether the value of the field has changed since the last time it was checked
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.checkChange = function() {};

/**
 * [Method] Checks the isDirty state of the field and if it has changed since the last time it was checked fires the dirtychange
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.checkDirty = function() {};

/**
 * [Method] If you need want custom HTML cleanup this is the method you should override
 * @param {string=} html String The HTML to be cleaned
 * @return {string} String The cleaned HTML
 */
Ext.form.IHtmlEditor.prototype.cleanHtml = function(html) {};

/**
 * [Method] Clear any invalid styles messages for this field
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.clearInvalid = function() {};

/**
 * [Method] Executes a Midas editor command directly on the editor document
 * @param {string=} cmd String The Midas command
 * @param {?=} value String/Boolean The value to pass to the command
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.execCmd = function(cmd, value) {};

/**
 * [Method] Only relevant if the instance s isFileUpload method returns true
 * @return {!HTMLElement} HTMLElement
 */
Ext.form.IHtmlEditor.prototype.extractFileInput = function() {};

/**
 * [Method] Try to focus this component
 * @param {?=} selectText Object
 * @param {?=} delay Object
 * @return {!Ext.IComponent} Ext.Component The focused Component. Usually this Component. Some Containers may delegate focus to a descendant Component (Windows can do this through their defaultFocus config option.
 */
Ext.form.IHtmlEditor.prototype.focus = function(selectText, delay) {};

/**
 * [Method] Called when the editor initializes the iframe with HTML contents
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.getDocMarkup = function() {};

/**
 * [Method] Runs this field s validators and returns an array of error messages for any validation failures
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {!Array<string>} String[] All error messages for this field; an empty Array if none.
 */
Ext.form.IHtmlEditor.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the value s that should be saved to the Ext data Model instance for this field when Ext form Basic updateRe
 * @return {?} Object A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.IHtmlEditor.prototype.getModelData = function() {};

/**
 * [Method] Returns the name attribute of the field
 * @return {string} String name The field name
 */
Ext.form.IHtmlEditor.prototype.getName = function() {};

/**
 * [Method] Returns the parameter s that would be included in a standard form submit for this field
 * @return {?} Object A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.IHtmlEditor.prototype.getSubmitData = function() {};

/**
 * [Method] Returns the editor s toolbar
 * @return {!Ext.toolbar.IToolbar} Ext.toolbar.Toolbar
 */
Ext.form.IHtmlEditor.prototype.getToolbar = function() {};

/**
 * [Method] Returns the current data value of the field
 * @return {?} Object value The field value
 */
Ext.form.IHtmlEditor.prototype.getValue = function() {};

/**
 * [Method] Initializes this Field mixin on the current instance
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.initField = function() {};

/**
 * [Method] Initializes the field s value based on the initial config
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.initValue = function() {};

/**
 * [Method] Inserts the passed text at the current cursor position
 * @param {string=} text String
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.insertAtCursor = function(text) {};

/**
 * [Method] Returns true if the value of this Field has been changed from its originalValue
 * @return {boolean} Boolean True if this field has been changed from its original value (and is not disabled), false otherwise.
 */
Ext.form.IHtmlEditor.prototype.isDirty = function() {};

/**
 * [Method] Returns whether two field values are logically equal
 * @param {?=} value1 Object
 * @param {?=} value2 Object
 * @return {boolean} Boolean True if the values are equal, false if inequal.
 */
Ext.form.IHtmlEditor.prototype.isEqual = function(value1, value2) {};

/**
 * [Method] Returns whether this Field is a file upload field if it returns true forms will use special techniques for submitti
 * @return {boolean} Boolean
 */
Ext.form.IHtmlEditor.prototype.isFileUpload = function() {};

/**
 * [Method] Returns whether or not the field value is currently valid by validating the field s current value
 * @return {boolean} Boolean True if the value is valid, else false
 */
Ext.form.IHtmlEditor.prototype.isValid = function() {};

/**
 * [Method] Associate one or more error messages with this field
 * @param {?=} errors String/String[] The error message(s) for the field.
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.markInvalid = function(errors) {};

/**
 * [Method] Pushes the value of the textarea into the iframe editor
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.pushValue = function() {};

/**
 * [Method] Executes a Midas editor command on the editor document and performs necessary focus and toolbar updates
 * @param {string=} cmd String The Midas command
 * @param {?=} value String/Boolean The value to pass to the command
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.relayCmd = function(cmd, value) {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.reset = function() {};

/**
 * [Method] Resets the field s originalValue property so it matches the current value
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.resetOriginalValue = function() {};

/**
 * [Method] Sets the read only state of this field
 * @param {boolean=} readOnly Boolean Whether the field should be read only.
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.setReadOnly = function(readOnly) {};

/**
 * [Method] Sets a data value into the field and runs the change detection and validation
 * @param {?=} value Object
 * @return {?} any this
 */
Ext.form.IHtmlEditor.prototype.setValue = function(value) {};

/**
 * [Method] Syncs the contents of the editor iframe with the textarea
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.syncValue = function() {};

/**
 * [Method] Toggles the editor between standard and source edit mode
 * @param {boolean=} sourceEditMode Boolean True for source edit, false for standard
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.toggleSourceEdit = function(sourceEditMode) {};

/**
 * [Method] Allows for any necessary modifications before the original value is set
 * @param {?=} value Object The initial value
 * @return {?} Object The modified initial value
 */
Ext.form.IHtmlEditor.prototype.transformOriginalValue = function(value) {};

/**
 * [Method] Triggers a toolbar update by reading the markup state of the current selection in the editor
 * @return {void}
 */
Ext.form.IHtmlEditor.prototype.updateToolbar = function() {};
/**
 * @extends {Ext.form.field.ISpinner}
 * @record
 * @struct
 */
Ext.form.field.INumber = function() {};
 /** @type {boolean} */
Ext.form.field.INumber.prototype.allowDecimals;
 /** @type {boolean} */
Ext.form.field.INumber.prototype.allowExponential;
 /** @type {boolean} */
Ext.form.field.INumber.prototype.autoStripChars;
 /** @type {string} */
Ext.form.field.INumber.prototype.baseChars;
 /** @type {number} */
Ext.form.field.INumber.prototype.decimalPrecision;
 /** @type {string} */
Ext.form.field.INumber.prototype.decimalSeparator;
 /** @type {string} */
Ext.form.field.INumber.prototype.maxText;
 /** @type {number} */
Ext.form.field.INumber.prototype.maxValue;
 /** @type {string} */
Ext.form.field.INumber.prototype.minText;
 /** @type {number} */
Ext.form.field.INumber.prototype.minValue;
 /** @type {string} */
Ext.form.field.INumber.prototype.nanText;
 /** @type {string} */
Ext.form.field.INumber.prototype.negativeText;
 /** @type {number} */
Ext.form.field.INumber.prototype.step;
 /** @type {boolean} */
Ext.form.field.INumber.prototype.submitLocaleSeparator;

/**
 * [Method] Template method to do any pre blur processing
 * @return {void}
 */
Ext.form.field.INumber.prototype.beforeBlur = function() {};

/**
 * [Method] Runs all of Number s validations and returns an array of any errors
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {!Array<string>} String[] All validation errors for this field
 */
Ext.form.field.INumber.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the value that would be included in a standard form submit for this field
 * @return {string} String The value to be submitted, or null.
 */
Ext.form.field.INumber.prototype.getSubmitValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.INumber.prototype.initComponent = function() {};

/**
 * [Method] This method is called when the spinner down button is clicked or when the down arrow key is pressed if keyNavEnabled
 * @return {void}
 */
Ext.form.field.INumber.prototype.onSpinDown = function() {};

/**
 * [Method] This method is called when the spinner up button is clicked or when the up arrow key is pressed if keyNavEnabled is
 * @return {void}
 */
Ext.form.field.INumber.prototype.onSpinUp = function() {};

/**
 * [Method] Converts a raw input field value into a mixed type value that is suitable for this particular field type
 * @param {?=} rawValue Object
 * @return {?} Object The converted value.
 */
Ext.form.field.INumber.prototype.rawToValue = function(rawValue) {};

/**
 * [Method] Replaces any existing maxValue with the new value
 * @param {number=} value Number The maximum value
 * @return {void}
 */
Ext.form.field.INumber.prototype.setMaxValue = function(value) {};

/**
 * [Method] Replaces any existing minValue with the new value
 * @param {number=} value Number The minimum value
 * @return {void}
 */
Ext.form.field.INumber.prototype.setMinValue = function(value) {};

/**
 * [Method] Sets whether the spinner down button is enabled
 * @param {?=} enabled Object
 * @param {?=} internal Object
 * @return {void}
 */
Ext.form.field.INumber.prototype.setSpinDownEnabled = function(enabled, internal) {};

/**
 * [Method] Sets whether the spinner up button is enabled
 * @param {?=} enabled Object
 * @param {?=} internal Object
 * @return {void}
 */
Ext.form.field.INumber.prototype.setSpinUpEnabled = function(enabled, internal) {};

/**
 * [Method] Converts a mixed type value to a raw representation suitable for displaying in the field
 * @param {?=} value Object
 * @return {?} Object The converted raw value.
 */
Ext.form.field.INumber.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.form.field.ISpinner}
 * @record
 * @struct
 */
Ext.form.INumberField = function() {};
 /** @type {boolean} */
Ext.form.INumberField.prototype.allowDecimals;
 /** @type {boolean} */
Ext.form.INumberField.prototype.allowExponential;
 /** @type {boolean} */
Ext.form.INumberField.prototype.autoStripChars;
 /** @type {string} */
Ext.form.INumberField.prototype.baseChars;
 /** @type {number} */
Ext.form.INumberField.prototype.decimalPrecision;
 /** @type {string} */
Ext.form.INumberField.prototype.decimalSeparator;
 /** @type {string} */
Ext.form.INumberField.prototype.maxText;
 /** @type {number} */
Ext.form.INumberField.prototype.maxValue;
 /** @type {string} */
Ext.form.INumberField.prototype.minText;
 /** @type {number} */
Ext.form.INumberField.prototype.minValue;
 /** @type {string} */
Ext.form.INumberField.prototype.nanText;
 /** @type {string} */
Ext.form.INumberField.prototype.negativeText;
 /** @type {number} */
Ext.form.INumberField.prototype.step;
 /** @type {boolean} */
Ext.form.INumberField.prototype.submitLocaleSeparator;

/**
 * [Method] Template method to do any pre blur processing
 * @return {void}
 */
Ext.form.INumberField.prototype.beforeBlur = function() {};

/**
 * [Method] Runs all of Number s validations and returns an array of any errors
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {!Array<string>} String[] All validation errors for this field
 */
Ext.form.INumberField.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the value that would be included in a standard form submit for this field
 * @return {string} String The value to be submitted, or null.
 */
Ext.form.INumberField.prototype.getSubmitValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.INumberField.prototype.initComponent = function() {};

/**
 * [Method] This method is called when the spinner down button is clicked or when the down arrow key is pressed if keyNavEnabled
 * @return {void}
 */
Ext.form.INumberField.prototype.onSpinDown = function() {};

/**
 * [Method] This method is called when the spinner up button is clicked or when the up arrow key is pressed if keyNavEnabled is
 * @return {void}
 */
Ext.form.INumberField.prototype.onSpinUp = function() {};

/**
 * [Method] Converts a raw input field value into a mixed type value that is suitable for this particular field type
 * @param {?=} rawValue Object
 * @return {?} Object The converted value.
 */
Ext.form.INumberField.prototype.rawToValue = function(rawValue) {};

/**
 * [Method] Replaces any existing maxValue with the new value
 * @param {number=} value Number The maximum value
 * @return {void}
 */
Ext.form.INumberField.prototype.setMaxValue = function(value) {};

/**
 * [Method] Replaces any existing minValue with the new value
 * @param {number=} value Number The minimum value
 * @return {void}
 */
Ext.form.INumberField.prototype.setMinValue = function(value) {};

/**
 * [Method] Sets whether the spinner down button is enabled
 * @param {?=} enabled Object
 * @param {?=} internal Object
 * @return {void}
 */
Ext.form.INumberField.prototype.setSpinDownEnabled = function(enabled, internal) {};

/**
 * [Method] Sets whether the spinner up button is enabled
 * @param {?=} enabled Object
 * @param {?=} internal Object
 * @return {void}
 */
Ext.form.INumberField.prototype.setSpinUpEnabled = function(enabled, internal) {};

/**
 * [Method] Converts a mixed type value to a raw representation suitable for displaying in the field
 * @param {?=} value Object
 * @return {?} Object The converted raw value.
 */
Ext.form.INumberField.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.form.field.ISpinner}
 * @record
 * @struct
 */
Ext.form.INumber = function() {};
 /** @type {boolean} */
Ext.form.INumber.prototype.allowDecimals;
 /** @type {boolean} */
Ext.form.INumber.prototype.allowExponential;
 /** @type {boolean} */
Ext.form.INumber.prototype.autoStripChars;
 /** @type {string} */
Ext.form.INumber.prototype.baseChars;
 /** @type {number} */
Ext.form.INumber.prototype.decimalPrecision;
 /** @type {string} */
Ext.form.INumber.prototype.decimalSeparator;
 /** @type {string} */
Ext.form.INumber.prototype.maxText;
 /** @type {number} */
Ext.form.INumber.prototype.maxValue;
 /** @type {string} */
Ext.form.INumber.prototype.minText;
 /** @type {number} */
Ext.form.INumber.prototype.minValue;
 /** @type {string} */
Ext.form.INumber.prototype.nanText;
 /** @type {string} */
Ext.form.INumber.prototype.negativeText;
 /** @type {number} */
Ext.form.INumber.prototype.step;
 /** @type {boolean} */
Ext.form.INumber.prototype.submitLocaleSeparator;

/**
 * [Method] Template method to do any pre blur processing
 * @return {void}
 */
Ext.form.INumber.prototype.beforeBlur = function() {};

/**
 * [Method] Runs all of Number s validations and returns an array of any errors
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {!Array<string>} String[] All validation errors for this field
 */
Ext.form.INumber.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the value that would be included in a standard form submit for this field
 * @return {string} String The value to be submitted, or null.
 */
Ext.form.INumber.prototype.getSubmitValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.INumber.prototype.initComponent = function() {};

/**
 * [Method] This method is called when the spinner down button is clicked or when the down arrow key is pressed if keyNavEnabled
 * @return {void}
 */
Ext.form.INumber.prototype.onSpinDown = function() {};

/**
 * [Method] This method is called when the spinner up button is clicked or when the up arrow key is pressed if keyNavEnabled is
 * @return {void}
 */
Ext.form.INumber.prototype.onSpinUp = function() {};

/**
 * [Method] Converts a raw input field value into a mixed type value that is suitable for this particular field type
 * @param {?=} rawValue Object
 * @return {?} Object The converted value.
 */
Ext.form.INumber.prototype.rawToValue = function(rawValue) {};

/**
 * [Method] Replaces any existing maxValue with the new value
 * @param {number=} value Number The maximum value
 * @return {void}
 */
Ext.form.INumber.prototype.setMaxValue = function(value) {};

/**
 * [Method] Replaces any existing minValue with the new value
 * @param {number=} value Number The minimum value
 * @return {void}
 */
Ext.form.INumber.prototype.setMinValue = function(value) {};

/**
 * [Method] Sets whether the spinner down button is enabled
 * @param {?=} enabled Object
 * @param {?=} internal Object
 * @return {void}
 */
Ext.form.INumber.prototype.setSpinDownEnabled = function(enabled, internal) {};

/**
 * [Method] Sets whether the spinner up button is enabled
 * @param {?=} enabled Object
 * @param {?=} internal Object
 * @return {void}
 */
Ext.form.INumber.prototype.setSpinUpEnabled = function(enabled, internal) {};

/**
 * [Method] Converts a mixed type value to a raw representation suitable for displaying in the field
 * @param {?=} value Object
 * @return {?} Object The converted raw value.
 */
Ext.form.INumber.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.form.field.ITrigger}
 * @record
 * @struct
 */
Ext.form.field.IPicker = function() {};
 /** @type {boolean} */
Ext.form.field.IPicker.prototype.editable;
 /** @type {boolean} */
Ext.form.field.IPicker.prototype.matchFieldWidth;
 /** @type {string} */
Ext.form.field.IPicker.prototype.openCls;
 /** @type {string} */
Ext.form.field.IPicker.prototype.pickerAlign;
 /** @type {!Array<number>} */
Ext.form.field.IPicker.prototype.pickerOffset;
 /** @type {boolean} */
Ext.form.field.IPicker.prototype.isExpanded;

/**
 * [Method] Aligns the picker to the input element
 * @return {void}
 */
Ext.form.field.IPicker.prototype.alignPicker = function() {};

/**
 * [Method] Collapses this field s picker dropdown
 * @return {void}
 */
Ext.form.field.IPicker.prototype.collapse = function() {};

/**
 * [Method] Creates and returns the component to be used as this field s picker
 * @return {void}
 */
Ext.form.field.IPicker.prototype.createPicker = function() {};

/**
 * [Method] Expands this field s picker dropdown
 * @return {void}
 */
Ext.form.field.IPicker.prototype.expand = function() {};

/**
 * [Method] Returns a reference to the picker component for this field creating it if necessary by calling createPicker
 * @return {!Ext.IComponent} Ext.Component The picker component
 */
Ext.form.field.IPicker.prototype.getPicker = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IPicker.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IPicker.prototype.initEvents = function() {};

/**
 * [Method] Handles the trigger click by default toggles between expanding and collapsing the picker component
 * @return {void}
 */
Ext.form.field.IPicker.prototype.onTriggerClick = function() {};
/**
 * @extends {Ext.form.field.ITrigger}
 * @record
 * @struct
 */
Ext.form.IPicker = function() {};
 /** @type {boolean} */
Ext.form.IPicker.prototype.editable;
 /** @type {boolean} */
Ext.form.IPicker.prototype.matchFieldWidth;
 /** @type {string} */
Ext.form.IPicker.prototype.openCls;
 /** @type {string} */
Ext.form.IPicker.prototype.pickerAlign;
 /** @type {!Array<number>} */
Ext.form.IPicker.prototype.pickerOffset;
 /** @type {boolean} */
Ext.form.IPicker.prototype.isExpanded;

/**
 * [Method] Aligns the picker to the input element
 * @return {void}
 */
Ext.form.IPicker.prototype.alignPicker = function() {};

/**
 * [Method] Collapses this field s picker dropdown
 * @return {void}
 */
Ext.form.IPicker.prototype.collapse = function() {};

/**
 * [Method] Creates and returns the component to be used as this field s picker
 * @return {void}
 */
Ext.form.IPicker.prototype.createPicker = function() {};

/**
 * [Method] Expands this field s picker dropdown
 * @return {void}
 */
Ext.form.IPicker.prototype.expand = function() {};

/**
 * [Method] Returns a reference to the picker component for this field creating it if necessary by calling createPicker
 * @return {!Ext.IComponent} Ext.Component The picker component
 */
Ext.form.IPicker.prototype.getPicker = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IPicker.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IPicker.prototype.initEvents = function() {};

/**
 * [Method] Handles the trigger click by default toggles between expanding and collapsing the picker component
 * @return {void}
 */
Ext.form.IPicker.prototype.onTriggerClick = function() {};
/**
 * @extends {Ext.form.field.ICheckbox}
 * @record
 * @struct
 */
Ext.form.field.IRadio = function() {};
 /** @type {string} */
Ext.form.field.IRadio.prototype.focusCls;
 /** @type {string} */
Ext.form.field.IRadio.prototype.inputType;
 /** @type {boolean} */
Ext.form.field.IRadio.prototype.isRadio;

/**
 * [Method] If this radio is part of a group it will return the selected value
 * @return {string} String
 */
Ext.form.field.IRadio.prototype.getGroupValue = function() {};

/**
 * [Method] Returns the value s that should be saved to the Ext data Model instance for this field when Ext form Basic updateRe
 * @return {?} Object A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.field.IRadio.prototype.getModelData = function() {};

/**
 * [Method] Returns the submit value for the checkbox which can be used when submitting forms
 * @return {?} Boolean/Object True if checked, null if not.
 */
Ext.form.field.IRadio.prototype.getSubmitValue = function() {};

/**
 * [Method] Method to manage awareness of when components are removed from their respective Container firing a removed event
 * @return {void}
 */
Ext.form.field.IRadio.prototype.onRemoved = function() {};

/**
 * [Method] Sets either the checked unchecked status of this Radio or if a string value is passed checks a sibling Radio of th
 * @param {?=} value String/Boolean Checked value, or the value of the sibling radio button to check.
 * @return {!Ext.form.field.IRadio} Ext.form.field.Radio this
 */
Ext.form.field.IRadio.prototype.setValue = function(value) {};
/**
 * @extends {Ext.form.field.ICheckbox}
 * @record
 * @struct
 */
Ext.form.IRadio = function() {};
 /** @type {string} */
Ext.form.IRadio.prototype.focusCls;
 /** @type {string} */
Ext.form.IRadio.prototype.inputType;
 /** @type {boolean} */
Ext.form.IRadio.prototype.isRadio;

/**
 * [Method] If this radio is part of a group it will return the selected value
 * @return {string} String
 */
Ext.form.IRadio.prototype.getGroupValue = function() {};

/**
 * [Method] Returns the value s that should be saved to the Ext data Model instance for this field when Ext form Basic updateRe
 * @return {?} Object A mapping of submit parameter names to values; each value should be a string, or an array of strings if that particular name has multiple values. It can also return null if there are no parameters to be submitted.
 */
Ext.form.IRadio.prototype.getModelData = function() {};

/**
 * [Method] Returns the submit value for the checkbox which can be used when submitting forms
 * @return {?} Boolean/Object True if checked, null if not.
 */
Ext.form.IRadio.prototype.getSubmitValue = function() {};

/**
 * [Method] Method to manage awareness of when components are removed from their respective Container firing a removed event
 * @return {void}
 */
Ext.form.IRadio.prototype.onRemoved = function() {};

/**
 * [Method] Sets either the checked unchecked status of this Radio or if a string value is passed checks a sibling Radio of th
 * @param {?=} value String/Boolean Checked value, or the value of the sibling radio button to check.
 * @return {!Ext.form.field.IRadio} Ext.form.field.Radio this
 */
Ext.form.IRadio.prototype.setValue = function(value) {};
/**
 * @extends {Ext.form.field.ITrigger}
 * @record
 * @struct
 */
Ext.form.field.ISpinner = function() {};
 /** @type {boolean} */
Ext.form.field.ISpinner.prototype.keyNavEnabled;
 /** @type {boolean} */
Ext.form.field.ISpinner.prototype.mouseWheelEnabled;
 /** @type {boolean} */
Ext.form.field.ISpinner.prototype.repeatTriggerClick;
 /** @type {boolean} */
Ext.form.field.ISpinner.prototype.spinDownEnabled;
 /** @type {boolean} */
Ext.form.field.ISpinner.prototype.spinUpEnabled;
 /** @type {!Ext.IElement} */
Ext.form.field.ISpinner.prototype.spinDownEl;
 /** @type {!Ext.IElement} */
Ext.form.field.ISpinner.prototype.spinUpEl;

/**
 * [Method] Get the total width of the spinner button area
 * @return {number} Number The total spinner button width
 */
Ext.form.field.ISpinner.prototype.getTriggerWidth = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.ISpinner.prototype.initComponent = function() {};

/**
 * [Method] This method is called when the spinner down button is clicked or when the down arrow key is pressed if keyNavEnabled
 * @return {void}
 */
Ext.form.field.ISpinner.prototype.onSpinDown = function() {};

/**
 * [Method] This method is called when the spinner up button is clicked or when the up arrow key is pressed if keyNavEnabled is
 * @return {void}
 */
Ext.form.field.ISpinner.prototype.onSpinUp = function() {};

/**
 * [Method] Sets whether the spinner down button is enabled
 * @param {boolean=} enabled Boolean true to enable the button, false to disable it.
 * @return {void}
 */
Ext.form.field.ISpinner.prototype.setSpinDownEnabled = function(enabled) {};

/**
 * [Method] Sets whether the spinner up button is enabled
 * @param {boolean=} enabled Boolean true to enable the button, false to disable it.
 * @return {void}
 */
Ext.form.field.ISpinner.prototype.setSpinUpEnabled = function(enabled) {};

/**
 * [Method] Triggers the spinner to step down fires the spin and spindown events and calls the onSpinDown method
 * @return {void}
 */
Ext.form.field.ISpinner.prototype.spinDown = function() {};

/**
 * [Method] Triggers the spinner to step up fires the spin and spinup events and calls the onSpinUp method
 * @return {void}
 */
Ext.form.field.ISpinner.prototype.spinUp = function() {};
/**
 * @extends {Ext.form.field.ITrigger}
 * @record
 * @struct
 */
Ext.form.ISpinner = function() {};
 /** @type {boolean} */
Ext.form.ISpinner.prototype.keyNavEnabled;
 /** @type {boolean} */
Ext.form.ISpinner.prototype.mouseWheelEnabled;
 /** @type {boolean} */
Ext.form.ISpinner.prototype.repeatTriggerClick;
 /** @type {boolean} */
Ext.form.ISpinner.prototype.spinDownEnabled;
 /** @type {boolean} */
Ext.form.ISpinner.prototype.spinUpEnabled;
 /** @type {!Ext.IElement} */
Ext.form.ISpinner.prototype.spinDownEl;
 /** @type {!Ext.IElement} */
Ext.form.ISpinner.prototype.spinUpEl;

/**
 * [Method] Get the total width of the spinner button area
 * @return {number} Number The total spinner button width
 */
Ext.form.ISpinner.prototype.getTriggerWidth = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ISpinner.prototype.initComponent = function() {};

/**
 * [Method] This method is called when the spinner down button is clicked or when the down arrow key is pressed if keyNavEnabled
 * @return {void}
 */
Ext.form.ISpinner.prototype.onSpinDown = function() {};

/**
 * [Method] This method is called when the spinner up button is clicked or when the up arrow key is pressed if keyNavEnabled is
 * @return {void}
 */
Ext.form.ISpinner.prototype.onSpinUp = function() {};

/**
 * [Method] Sets whether the spinner down button is enabled
 * @param {boolean=} enabled Boolean true to enable the button, false to disable it.
 * @return {void}
 */
Ext.form.ISpinner.prototype.setSpinDownEnabled = function(enabled) {};

/**
 * [Method] Sets whether the spinner up button is enabled
 * @param {boolean=} enabled Boolean true to enable the button, false to disable it.
 * @return {void}
 */
Ext.form.ISpinner.prototype.setSpinUpEnabled = function(enabled) {};

/**
 * [Method] Triggers the spinner to step down fires the spin and spindown events and calls the onSpinDown method
 * @return {void}
 */
Ext.form.ISpinner.prototype.spinDown = function() {};

/**
 * [Method] Triggers the spinner to step up fires the spin and spinup events and calls the onSpinUp method
 * @return {void}
 */
Ext.form.ISpinner.prototype.spinUp = function() {};
/**
 * @extends {Ext.form.field.IBase}
 * @record
 * @struct
 */
Ext.form.field.IText = function() {};
 /** @type {boolean} */
Ext.form.field.IText.prototype.allowBlank;
 /** @type {boolean} */
Ext.form.field.IText.prototype.allowOnlyWhitespace;
 /** @type {string} */
Ext.form.field.IText.prototype.blankText;
 /** @type {boolean} */
Ext.form.field.IText.prototype.disableKeyFilter;
 /** @type {string} */
Ext.form.field.IText.prototype.emptyCls;
 /** @type {string} */
Ext.form.field.IText.prototype.emptyText;
 /** @type {boolean} */
Ext.form.field.IText.prototype.enableKeyEvents;
 /** @type {boolean} */
Ext.form.field.IText.prototype.enforceMaxLength;
 /** @type {boolean} */
Ext.form.field.IText.prototype.grow;
 /** @type {string} */
Ext.form.field.IText.prototype.growAppend;
 /** @type {number} */
Ext.form.field.IText.prototype.growMax;
 /** @type {number} */
Ext.form.field.IText.prototype.growMin;
 /** @type {!RegExp} */
Ext.form.field.IText.prototype.maskRe;
 /** @type {number} */
Ext.form.field.IText.prototype.maxLength;
 /** @type {string} */
Ext.form.field.IText.prototype.maxLengthText;
 /** @type {number} */
Ext.form.field.IText.prototype.minLength;
 /** @type {string} */
Ext.form.field.IText.prototype.minLengthText;
 /** @type {!RegExp} */
Ext.form.field.IText.prototype.regex;
 /** @type {string} */
Ext.form.field.IText.prototype.regexText;
 /** @type {string} */
Ext.form.field.IText.prototype.requiredCls;
 /** @type {boolean} */
Ext.form.field.IText.prototype.selectOnFocus;
 /** @type {number} */
Ext.form.field.IText.prototype.size;
 /** @type {!RegExp} */
Ext.form.field.IText.prototype.stripCharsRe;
 /** @type {boolean} */
Ext.form.field.IText.prototype.validateBlank;
 /** @type {?} */
Ext.form.field.IText.prototype.validator;
 /** @type {string} */
Ext.form.field.IText.prototype.vtype;
 /** @type {string} */
Ext.form.field.IText.prototype.vtypeText;

/**
 * [Method] Called by the layout system after the Component has been laid out
 * @return {void}
 */
Ext.form.field.IText.prototype.afterComponentLayout = function() {};

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.form.field.IText.prototype.afterRender = function() {};

/**
 * [Method] Applies the state to the object
 * @param {?=} state Object
 * @return {void}
 */
Ext.form.field.IText.prototype.applyState = function(state) {};

/**
 * [Method] Automatically grows the field to accomodate the width of the text up to the maximum field width allowed
 * @return {void}
 */
Ext.form.field.IText.prototype.autoSize = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IText.prototype.beforeFocus = function() {};

/**
 * [Method] Validates a value according to the field s validation rules and returns an array of errors for any failing validations
 * @param {?=} value Object The value to validate. The processed raw value will be used if nothing is passed.
 * @return {!Array<string>} String[] Array of any validation errors
 */
Ext.form.field.IText.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the raw String value of the field without performing any normalization conversion or validation
 * @return {string} String The raw String value of the field
 */
Ext.form.field.IText.prototype.getRawValue = function() {};

/**
 * [Method] The supplied default state gathering method for the AbstractComponent class
 * @return {?} Object
 */
Ext.form.field.IText.prototype.getState = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.field.IText.prototype.getSubTplData = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IText.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IText.prototype.initEvents = function() {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.form.field.IText.prototype.onDestroy = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IText.prototype.onDisable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IText.prototype.onEnable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.IText.prototype.postBlur = function() {};

/**
 * [Method] Performs any necessary manipulation of a raw String value to prepare it for conversion and or validation
 * @param {string=} value String The unprocessed string value
 * @return {string} String The processed string value
 */
Ext.form.field.IText.prototype.processRawValue = function(value) {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.form.field.IText.prototype.reset = function() {};

/**
 * [Method] Selects text in this field
 * @param {number=} start Number The index where the selection should start
 * @param {number=} end Number The index where the selection should end (defaults to the text length)
 * @return {void}
 */
Ext.form.field.IText.prototype.selectText = function(start, end) {};

/**
 * [Method] Sets a data value into the field and runs the change detection and validation
 * @param {?=} value Object The value to set
 * @return {?} any this
 */
Ext.form.field.IText.prototype.setValue = function(value) {};
/**
 * @extends {Ext.form.field.IBase}
 * @record
 * @struct
 */
Ext.form.ITextField = function() {};
 /** @type {boolean} */
Ext.form.ITextField.prototype.allowBlank;
 /** @type {boolean} */
Ext.form.ITextField.prototype.allowOnlyWhitespace;
 /** @type {string} */
Ext.form.ITextField.prototype.blankText;
 /** @type {boolean} */
Ext.form.ITextField.prototype.disableKeyFilter;
 /** @type {string} */
Ext.form.ITextField.prototype.emptyCls;
 /** @type {string} */
Ext.form.ITextField.prototype.emptyText;
 /** @type {boolean} */
Ext.form.ITextField.prototype.enableKeyEvents;
 /** @type {boolean} */
Ext.form.ITextField.prototype.enforceMaxLength;
 /** @type {boolean} */
Ext.form.ITextField.prototype.grow;
 /** @type {string} */
Ext.form.ITextField.prototype.growAppend;
 /** @type {number} */
Ext.form.ITextField.prototype.growMax;
 /** @type {number} */
Ext.form.ITextField.prototype.growMin;
 /** @type {!RegExp} */
Ext.form.ITextField.prototype.maskRe;
 /** @type {number} */
Ext.form.ITextField.prototype.maxLength;
 /** @type {string} */
Ext.form.ITextField.prototype.maxLengthText;
 /** @type {number} */
Ext.form.ITextField.prototype.minLength;
 /** @type {string} */
Ext.form.ITextField.prototype.minLengthText;
 /** @type {!RegExp} */
Ext.form.ITextField.prototype.regex;
 /** @type {string} */
Ext.form.ITextField.prototype.regexText;
 /** @type {string} */
Ext.form.ITextField.prototype.requiredCls;
 /** @type {boolean} */
Ext.form.ITextField.prototype.selectOnFocus;
 /** @type {number} */
Ext.form.ITextField.prototype.size;
 /** @type {!RegExp} */
Ext.form.ITextField.prototype.stripCharsRe;
 /** @type {boolean} */
Ext.form.ITextField.prototype.validateBlank;
 /** @type {?} */
Ext.form.ITextField.prototype.validator;
 /** @type {string} */
Ext.form.ITextField.prototype.vtype;
 /** @type {string} */
Ext.form.ITextField.prototype.vtypeText;

/**
 * [Method] Called by the layout system after the Component has been laid out
 * @return {void}
 */
Ext.form.ITextField.prototype.afterComponentLayout = function() {};

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.form.ITextField.prototype.afterRender = function() {};

/**
 * [Method] Applies the state to the object
 * @param {?=} state Object
 * @return {void}
 */
Ext.form.ITextField.prototype.applyState = function(state) {};

/**
 * [Method] Automatically grows the field to accomodate the width of the text up to the maximum field width allowed
 * @return {void}
 */
Ext.form.ITextField.prototype.autoSize = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITextField.prototype.beforeFocus = function() {};

/**
 * [Method] Validates a value according to the field s validation rules and returns an array of errors for any failing validations
 * @param {?=} value Object The value to validate. The processed raw value will be used if nothing is passed.
 * @return {!Array<string>} String[] Array of any validation errors
 */
Ext.form.ITextField.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the raw String value of the field without performing any normalization conversion or validation
 * @return {string} String The raw String value of the field
 */
Ext.form.ITextField.prototype.getRawValue = function() {};

/**
 * [Method] The supplied default state gathering method for the AbstractComponent class
 * @return {?} Object
 */
Ext.form.ITextField.prototype.getState = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.ITextField.prototype.getSubTplData = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITextField.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITextField.prototype.initEvents = function() {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.form.ITextField.prototype.onDestroy = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITextField.prototype.onDisable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITextField.prototype.onEnable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITextField.prototype.postBlur = function() {};

/**
 * [Method] Performs any necessary manipulation of a raw String value to prepare it for conversion and or validation
 * @param {string=} value String The unprocessed string value
 * @return {string} String The processed string value
 */
Ext.form.ITextField.prototype.processRawValue = function(value) {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.form.ITextField.prototype.reset = function() {};

/**
 * [Method] Selects text in this field
 * @param {number=} start Number The index where the selection should start
 * @param {number=} end Number The index where the selection should end (defaults to the text length)
 * @return {void}
 */
Ext.form.ITextField.prototype.selectText = function(start, end) {};

/**
 * [Method] Sets a data value into the field and runs the change detection and validation
 * @param {?=} value Object The value to set
 * @return {?} any this
 */
Ext.form.ITextField.prototype.setValue = function(value) {};
/**
 * @extends {Ext.form.field.IBase}
 * @record
 * @struct
 */
Ext.form.IText = function() {};
 /** @type {boolean} */
Ext.form.IText.prototype.allowBlank;
 /** @type {boolean} */
Ext.form.IText.prototype.allowOnlyWhitespace;
 /** @type {string} */
Ext.form.IText.prototype.blankText;
 /** @type {boolean} */
Ext.form.IText.prototype.disableKeyFilter;
 /** @type {string} */
Ext.form.IText.prototype.emptyCls;
 /** @type {string} */
Ext.form.IText.prototype.emptyText;
 /** @type {boolean} */
Ext.form.IText.prototype.enableKeyEvents;
 /** @type {boolean} */
Ext.form.IText.prototype.enforceMaxLength;
 /** @type {boolean} */
Ext.form.IText.prototype.grow;
 /** @type {string} */
Ext.form.IText.prototype.growAppend;
 /** @type {number} */
Ext.form.IText.prototype.growMax;
 /** @type {number} */
Ext.form.IText.prototype.growMin;
 /** @type {!RegExp} */
Ext.form.IText.prototype.maskRe;
 /** @type {number} */
Ext.form.IText.prototype.maxLength;
 /** @type {string} */
Ext.form.IText.prototype.maxLengthText;
 /** @type {number} */
Ext.form.IText.prototype.minLength;
 /** @type {string} */
Ext.form.IText.prototype.minLengthText;
 /** @type {!RegExp} */
Ext.form.IText.prototype.regex;
 /** @type {string} */
Ext.form.IText.prototype.regexText;
 /** @type {string} */
Ext.form.IText.prototype.requiredCls;
 /** @type {boolean} */
Ext.form.IText.prototype.selectOnFocus;
 /** @type {number} */
Ext.form.IText.prototype.size;
 /** @type {!RegExp} */
Ext.form.IText.prototype.stripCharsRe;
 /** @type {boolean} */
Ext.form.IText.prototype.validateBlank;
 /** @type {?} */
Ext.form.IText.prototype.validator;
 /** @type {string} */
Ext.form.IText.prototype.vtype;
 /** @type {string} */
Ext.form.IText.prototype.vtypeText;

/**
 * [Method] Called by the layout system after the Component has been laid out
 * @return {void}
 */
Ext.form.IText.prototype.afterComponentLayout = function() {};

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.form.IText.prototype.afterRender = function() {};

/**
 * [Method] Applies the state to the object
 * @param {?=} state Object
 * @return {void}
 */
Ext.form.IText.prototype.applyState = function(state) {};

/**
 * [Method] Automatically grows the field to accomodate the width of the text up to the maximum field width allowed
 * @return {void}
 */
Ext.form.IText.prototype.autoSize = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IText.prototype.beforeFocus = function() {};

/**
 * [Method] Validates a value according to the field s validation rules and returns an array of errors for any failing validations
 * @param {?=} value Object The value to validate. The processed raw value will be used if nothing is passed.
 * @return {!Array<string>} String[] Array of any validation errors
 */
Ext.form.IText.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the raw String value of the field without performing any normalization conversion or validation
 * @return {string} String The raw String value of the field
 */
Ext.form.IText.prototype.getRawValue = function() {};

/**
 * [Method] The supplied default state gathering method for the AbstractComponent class
 * @return {?} Object
 */
Ext.form.IText.prototype.getState = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.IText.prototype.getSubTplData = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IText.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IText.prototype.initEvents = function() {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.form.IText.prototype.onDestroy = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IText.prototype.onDisable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IText.prototype.onEnable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.IText.prototype.postBlur = function() {};

/**
 * [Method] Performs any necessary manipulation of a raw String value to prepare it for conversion and or validation
 * @param {string=} value String The unprocessed string value
 * @return {string} String The processed string value
 */
Ext.form.IText.prototype.processRawValue = function(value) {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.form.IText.prototype.reset = function() {};

/**
 * [Method] Selects text in this field
 * @param {number=} start Number The index where the selection should start
 * @param {number=} end Number The index where the selection should end (defaults to the text length)
 * @return {void}
 */
Ext.form.IText.prototype.selectText = function(start, end) {};

/**
 * [Method] Sets a data value into the field and runs the change detection and validation
 * @param {?=} value Object The value to set
 * @return {?} any this
 */
Ext.form.IText.prototype.setValue = function(value) {};
/**
 * @extends {Ext.form.field.IText}
 * @record
 * @struct
 */
Ext.form.field.ITextArea = function() {};
 /** @type {number} */
Ext.form.field.ITextArea.prototype.cols;
 /** @type {?} */
Ext.form.field.ITextArea.prototype.componentLayout;
 /** @type {boolean} */
Ext.form.field.ITextArea.prototype.enterIsSpecial;
 /** @type {string} */
Ext.form.field.ITextArea.prototype.growAppend;
 /** @type {number} */
Ext.form.field.ITextArea.prototype.growMax;
 /** @type {number} */
Ext.form.field.ITextArea.prototype.growMin;
 /** @type {boolean} */
Ext.form.field.ITextArea.prototype.preventScrollbars;
 /** @type {number} */
Ext.form.field.ITextArea.prototype.rows;

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.form.field.ITextArea.prototype.afterRender = function() {};

/**
 * [Method] Automatically grows the field to accomodate the height of the text up to the maximum field height allowed
 * @return {void}
 */
Ext.form.field.ITextArea.prototype.autoSize = function() {};

/**
 * [Method] Invoked before the Component is destroyed
 * @return {void}
 */
Ext.form.field.ITextArea.prototype.beforeDestroy = function() {};

/**
 * [Method] private
 * @return {?} Object The template data
 */
Ext.form.field.ITextArea.prototype.getSubTplData = function() {};

/**
 * [Method] Returns the current data value of the field
 * @return {?} Object value The field value
 */
Ext.form.field.ITextArea.prototype.getValue = function() {};

/**
 * [Method] Allows for any necessary modifications before the original value is set
 * @param {?=} value Object
 * @return {?} Object The modified initial value
 */
Ext.form.field.ITextArea.prototype.transformOriginalValue = function(value) {};

/**
 * [Method] The following overrides deal with an issue whereby some browsers will strip carriage returns from the textarea input
 * @param {?=} value Object
 * @return {?} Object The value to set
 */
Ext.form.field.ITextArea.prototype.transformRawValue = function(value) {};

/**
 * [Method] Converts a mixed type value to a raw representation suitable for displaying in the field
 * @param {?=} value Object
 * @return {?} Object The converted raw value.
 */
Ext.form.field.ITextArea.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.form.field.IText}
 * @record
 * @struct
 */
Ext.form.ITextArea = function() {};
 /** @type {number} */
Ext.form.ITextArea.prototype.cols;
 /** @type {?} */
Ext.form.ITextArea.prototype.componentLayout;
 /** @type {boolean} */
Ext.form.ITextArea.prototype.enterIsSpecial;
 /** @type {string} */
Ext.form.ITextArea.prototype.growAppend;
 /** @type {number} */
Ext.form.ITextArea.prototype.growMax;
 /** @type {number} */
Ext.form.ITextArea.prototype.growMin;
 /** @type {boolean} */
Ext.form.ITextArea.prototype.preventScrollbars;
 /** @type {number} */
Ext.form.ITextArea.prototype.rows;

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.form.ITextArea.prototype.afterRender = function() {};

/**
 * [Method] Automatically grows the field to accomodate the height of the text up to the maximum field height allowed
 * @return {void}
 */
Ext.form.ITextArea.prototype.autoSize = function() {};

/**
 * [Method] Invoked before the Component is destroyed
 * @return {void}
 */
Ext.form.ITextArea.prototype.beforeDestroy = function() {};

/**
 * [Method] private
 * @return {?} Object The template data
 */
Ext.form.ITextArea.prototype.getSubTplData = function() {};

/**
 * [Method] Returns the current data value of the field
 * @return {?} Object value The field value
 */
Ext.form.ITextArea.prototype.getValue = function() {};

/**
 * [Method] Allows for any necessary modifications before the original value is set
 * @param {?=} value Object
 * @return {?} Object The modified initial value
 */
Ext.form.ITextArea.prototype.transformOriginalValue = function(value) {};

/**
 * [Method] The following overrides deal with an issue whereby some browsers will strip carriage returns from the textarea input
 * @param {?=} value Object
 * @return {?} Object The value to set
 */
Ext.form.ITextArea.prototype.transformRawValue = function(value) {};

/**
 * [Method] Converts a mixed type value to a raw representation suitable for displaying in the field
 * @param {?=} value Object
 * @return {?} Object The converted raw value.
 */
Ext.form.ITextArea.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.form.field.IComboBox}
 * @record
 * @struct
 */
Ext.form.field.ITime = function() {};
 /** @type {string} */
Ext.form.field.ITime.prototype.altFormats;
 /** @type {string} */
Ext.form.field.ITime.prototype.displayField;
 /** @type {string} */
Ext.form.field.ITime.prototype.format;
 /** @type {number} */
Ext.form.field.ITime.prototype.increment;
 /** @type {string} */
Ext.form.field.ITime.prototype.invalidText;
 /** @type {string} */
Ext.form.field.ITime.prototype.maxText;
 /** @type {?} */
Ext.form.field.ITime.prototype.maxValue;
 /** @type {string} */
Ext.form.field.ITime.prototype.minText;
 /** @type {?} */
Ext.form.field.ITime.prototype.minValue;
 /** @type {number} */
Ext.form.field.ITime.prototype.pickerMaxHeight;
 /** @type {string} */
Ext.form.field.ITime.prototype.queryMode;
 /** @type {boolean} */
Ext.form.field.ITime.prototype.selectOnTab;
 /** @type {boolean} */
Ext.form.field.ITime.prototype.snapToIncrement;
 /** @type {string} */
Ext.form.field.ITime.prototype.submitFormat;
 /** @type {string} */
Ext.form.field.ITime.prototype.triggerCls;
 /** @type {string} */
Ext.form.field.ITime.prototype.valueField;

/**
 * [Method] Runs all of Time s validations and returns an array of any errors
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {!Array<string>} String[] All validation errors for this field
 */
Ext.form.field.ITime.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the current data value of the field
 * @return {?} Object value The field value
 */
Ext.form.field.ITime.prototype.getValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.ITime.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.ITime.prototype.postBlur = function() {};

/**
 * [Method] Converts a raw input field value into a mixed type value that is suitable for this particular field type
 * @param {?=} rawValue Object
 * @return {?} Object The converted value.
 */
Ext.form.field.ITime.prototype.rawToValue = function(rawValue) {};

/**
 * [Method] Replaces any existing maxValue with the new time and refreshes the picker s range
 * @param {?=} value Date/String The maximum time that can be selected
 * @return {void}
 */
Ext.form.field.ITime.prototype.setMaxValue = function(value) {};

/**
 * [Method] Replaces any existing minValue with the new time and refreshes the picker s range
 * @param {?=} value Date/String The minimum time that can be selected
 * @return {void}
 */
Ext.form.field.ITime.prototype.setMinValue = function(value) {};

/**
 * [Method] Sets the specified value s into the field
 * @return {?} any this
 */
Ext.form.field.ITime.prototype.setValue = function() {};

/**
 * [Method] Converts a mixed type value to a raw representation suitable for displaying in the field
 * @param {?=} value Object
 * @return {?} Object The converted raw value.
 */
Ext.form.field.ITime.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.form.field.IComboBox}
 * @record
 * @struct
 */
Ext.form.ITimeField = function() {};
 /** @type {string} */
Ext.form.ITimeField.prototype.altFormats;
 /** @type {string} */
Ext.form.ITimeField.prototype.displayField;
 /** @type {string} */
Ext.form.ITimeField.prototype.format;
 /** @type {number} */
Ext.form.ITimeField.prototype.increment;
 /** @type {string} */
Ext.form.ITimeField.prototype.invalidText;
 /** @type {string} */
Ext.form.ITimeField.prototype.maxText;
 /** @type {?} */
Ext.form.ITimeField.prototype.maxValue;
 /** @type {string} */
Ext.form.ITimeField.prototype.minText;
 /** @type {?} */
Ext.form.ITimeField.prototype.minValue;
 /** @type {number} */
Ext.form.ITimeField.prototype.pickerMaxHeight;
 /** @type {string} */
Ext.form.ITimeField.prototype.queryMode;
 /** @type {boolean} */
Ext.form.ITimeField.prototype.selectOnTab;
 /** @type {boolean} */
Ext.form.ITimeField.prototype.snapToIncrement;
 /** @type {string} */
Ext.form.ITimeField.prototype.submitFormat;
 /** @type {string} */
Ext.form.ITimeField.prototype.triggerCls;
 /** @type {string} */
Ext.form.ITimeField.prototype.valueField;

/**
 * [Method] Runs all of Time s validations and returns an array of any errors
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {!Array<string>} String[] All validation errors for this field
 */
Ext.form.ITimeField.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the current data value of the field
 * @return {?} Object value The field value
 */
Ext.form.ITimeField.prototype.getValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITimeField.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITimeField.prototype.postBlur = function() {};

/**
 * [Method] Converts a raw input field value into a mixed type value that is suitable for this particular field type
 * @param {?=} rawValue Object
 * @return {?} Object The converted value.
 */
Ext.form.ITimeField.prototype.rawToValue = function(rawValue) {};

/**
 * [Method] Replaces any existing maxValue with the new time and refreshes the picker s range
 * @param {?=} value Date/String The maximum time that can be selected
 * @return {void}
 */
Ext.form.ITimeField.prototype.setMaxValue = function(value) {};

/**
 * [Method] Replaces any existing minValue with the new time and refreshes the picker s range
 * @param {?=} value Date/String The minimum time that can be selected
 * @return {void}
 */
Ext.form.ITimeField.prototype.setMinValue = function(value) {};

/**
 * [Method] Sets the specified value s into the field
 * @return {?} any this
 */
Ext.form.ITimeField.prototype.setValue = function() {};

/**
 * [Method] Converts a mixed type value to a raw representation suitable for displaying in the field
 * @param {?=} value Object
 * @return {?} Object The converted raw value.
 */
Ext.form.ITimeField.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.form.field.IComboBox}
 * @record
 * @struct
 */
Ext.form.ITime = function() {};
 /** @type {string} */
Ext.form.ITime.prototype.altFormats;
 /** @type {string} */
Ext.form.ITime.prototype.displayField;
 /** @type {string} */
Ext.form.ITime.prototype.format;
 /** @type {number} */
Ext.form.ITime.prototype.increment;
 /** @type {string} */
Ext.form.ITime.prototype.invalidText;
 /** @type {string} */
Ext.form.ITime.prototype.maxText;
 /** @type {?} */
Ext.form.ITime.prototype.maxValue;
 /** @type {string} */
Ext.form.ITime.prototype.minText;
 /** @type {?} */
Ext.form.ITime.prototype.minValue;
 /** @type {number} */
Ext.form.ITime.prototype.pickerMaxHeight;
 /** @type {string} */
Ext.form.ITime.prototype.queryMode;
 /** @type {boolean} */
Ext.form.ITime.prototype.selectOnTab;
 /** @type {boolean} */
Ext.form.ITime.prototype.snapToIncrement;
 /** @type {string} */
Ext.form.ITime.prototype.submitFormat;
 /** @type {string} */
Ext.form.ITime.prototype.triggerCls;
 /** @type {string} */
Ext.form.ITime.prototype.valueField;

/**
 * [Method] Runs all of Time s validations and returns an array of any errors
 * @param {?=} value Object The value to get errors for (defaults to the current field value)
 * @return {!Array<string>} String[] All validation errors for this field
 */
Ext.form.ITime.prototype.getErrors = function(value) {};

/**
 * [Method] Returns the current data value of the field
 * @return {?} Object value The field value
 */
Ext.form.ITime.prototype.getValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITime.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITime.prototype.postBlur = function() {};

/**
 * [Method] Converts a raw input field value into a mixed type value that is suitable for this particular field type
 * @param {?=} rawValue Object
 * @return {?} Object The converted value.
 */
Ext.form.ITime.prototype.rawToValue = function(rawValue) {};

/**
 * [Method] Replaces any existing maxValue with the new time and refreshes the picker s range
 * @param {?=} value Date/String The maximum time that can be selected
 * @return {void}
 */
Ext.form.ITime.prototype.setMaxValue = function(value) {};

/**
 * [Method] Replaces any existing minValue with the new time and refreshes the picker s range
 * @param {?=} value Date/String The minimum time that can be selected
 * @return {void}
 */
Ext.form.ITime.prototype.setMinValue = function(value) {};

/**
 * [Method] Sets the specified value s into the field
 * @return {?} any this
 */
Ext.form.ITime.prototype.setValue = function() {};

/**
 * [Method] Converts a mixed type value to a raw representation suitable for displaying in the field
 * @param {?=} value Object
 * @return {?} Object The converted raw value.
 */
Ext.form.ITime.prototype.valueToRaw = function(value) {};
/**
 * @extends {Ext.form.field.IText}
 * @record
 * @struct
 */
Ext.form.field.ITrigger = function() {};
 /** @type {?} */
Ext.form.field.ITrigger.prototype.componentLayout;
 /** @type {boolean} */
Ext.form.field.ITrigger.prototype.editable;
 /** @type {boolean} */
Ext.form.field.ITrigger.prototype.hideTrigger;
 /** @type {boolean} */
Ext.form.field.ITrigger.prototype.readOnly;
 /** @type {boolean} */
Ext.form.field.ITrigger.prototype.repeatTriggerClick;
 /** @type {boolean} */
Ext.form.field.ITrigger.prototype.selectOnFocus;
 /** @type {string} */
Ext.form.field.ITrigger.prototype.triggerBaseCls;
 /** @type {string} */
Ext.form.field.ITrigger.prototype.triggerCls;
 /** @type {string} */
Ext.form.field.ITrigger.prototype.triggerNoEditCls;
 /** @type {string} */
Ext.form.field.ITrigger.prototype.triggerWrapCls;
 /** @type {!Ext.IElement} */
Ext.form.field.ITrigger.prototype.inputCell;
 /** @type {!Ext.ICompositeElement} */
Ext.form.field.ITrigger.prototype.triggerEl;
 /** @type {!Ext.IElement} */
Ext.form.field.ITrigger.prototype.triggerWrap;

/**
 * [Method] Generates the arguments for the field decorations rendering template
 * @return {?} Object The template arguments
 */
Ext.form.field.ITrigger.prototype.getLabelableRenderData = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.field.ITrigger.prototype.getSubTplData = function() {};

/**
 * [Method] Get the total width of the trigger button area
 * @return {number} Number The total trigger width
 */
Ext.form.field.ITrigger.prototype.getTriggerWidth = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.ITrigger.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.field.ITrigger.prototype.onRender = function() {};

/**
 * [Method] The function that should handle the trigger s click event
 * @param {!Ext.IEventObject=} e Ext.EventObject
 * @return {void}
 */
Ext.form.field.ITrigger.prototype.onTriggerClick = function(e) {};

/**
 * [Method] Sets the editable state of this field
 * @param {boolean=} editable Boolean True to allow the user to directly edit the field text. If false is passed, the user will only be able to modify the field using the trigger. Will also add a click event to the text field which will call the trigger.
 * @return {void}
 */
Ext.form.field.ITrigger.prototype.setEditable = function(editable) {};

/**
 * [Method] Sets the read only state of this field
 * @param {boolean=} readOnly Boolean True to prevent the user changing the field and explicitly hide the trigger. Setting this to true will supercede settings editable and hideTrigger. Setting this to false will defer back to editable and hideTrigger.
 * @return {void}
 */
Ext.form.field.ITrigger.prototype.setReadOnly = function(readOnly) {};
/**
 * @extends {Ext.form.field.IText}
 * @record
 * @struct
 */
Ext.form.ITriggerField = function() {};
 /** @type {?} */
Ext.form.ITriggerField.prototype.componentLayout;
 /** @type {boolean} */
Ext.form.ITriggerField.prototype.editable;
 /** @type {boolean} */
Ext.form.ITriggerField.prototype.hideTrigger;
 /** @type {boolean} */
Ext.form.ITriggerField.prototype.readOnly;
 /** @type {boolean} */
Ext.form.ITriggerField.prototype.repeatTriggerClick;
 /** @type {boolean} */
Ext.form.ITriggerField.prototype.selectOnFocus;
 /** @type {string} */
Ext.form.ITriggerField.prototype.triggerBaseCls;
 /** @type {string} */
Ext.form.ITriggerField.prototype.triggerCls;
 /** @type {string} */
Ext.form.ITriggerField.prototype.triggerNoEditCls;
 /** @type {string} */
Ext.form.ITriggerField.prototype.triggerWrapCls;
 /** @type {!Ext.IElement} */
Ext.form.ITriggerField.prototype.inputCell;
 /** @type {!Ext.ICompositeElement} */
Ext.form.ITriggerField.prototype.triggerEl;
 /** @type {!Ext.IElement} */
Ext.form.ITriggerField.prototype.triggerWrap;

/**
 * [Method] Generates the arguments for the field decorations rendering template
 * @return {?} Object The template arguments
 */
Ext.form.ITriggerField.prototype.getLabelableRenderData = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.ITriggerField.prototype.getSubTplData = function() {};

/**
 * [Method] Get the total width of the trigger button area
 * @return {number} Number The total trigger width
 */
Ext.form.ITriggerField.prototype.getTriggerWidth = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITriggerField.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITriggerField.prototype.onRender = function() {};

/**
 * [Method] The function that should handle the trigger s click event
 * @param {!Ext.IEventObject=} e Ext.EventObject
 * @return {void}
 */
Ext.form.ITriggerField.prototype.onTriggerClick = function(e) {};

/**
 * [Method] Sets the editable state of this field
 * @param {boolean=} editable Boolean True to allow the user to directly edit the field text. If false is passed, the user will only be able to modify the field using the trigger. Will also add a click event to the text field which will call the trigger.
 * @return {void}
 */
Ext.form.ITriggerField.prototype.setEditable = function(editable) {};

/**
 * [Method] Sets the read only state of this field
 * @param {boolean=} readOnly Boolean True to prevent the user changing the field and explicitly hide the trigger. Setting this to true will supercede settings editable and hideTrigger. Setting this to false will defer back to editable and hideTrigger.
 * @return {void}
 */
Ext.form.ITriggerField.prototype.setReadOnly = function(readOnly) {};
/**
 * @extends {Ext.form.field.IText}
 * @record
 * @struct
 */
Ext.form.ITwinTriggerField = function() {};
 /** @type {?} */
Ext.form.ITwinTriggerField.prototype.componentLayout;
 /** @type {boolean} */
Ext.form.ITwinTriggerField.prototype.editable;
 /** @type {boolean} */
Ext.form.ITwinTriggerField.prototype.hideTrigger;
 /** @type {boolean} */
Ext.form.ITwinTriggerField.prototype.readOnly;
 /** @type {boolean} */
Ext.form.ITwinTriggerField.prototype.repeatTriggerClick;
 /** @type {boolean} */
Ext.form.ITwinTriggerField.prototype.selectOnFocus;
 /** @type {string} */
Ext.form.ITwinTriggerField.prototype.triggerBaseCls;
 /** @type {string} */
Ext.form.ITwinTriggerField.prototype.triggerCls;
 /** @type {string} */
Ext.form.ITwinTriggerField.prototype.triggerNoEditCls;
 /** @type {string} */
Ext.form.ITwinTriggerField.prototype.triggerWrapCls;
 /** @type {!Ext.IElement} */
Ext.form.ITwinTriggerField.prototype.inputCell;
 /** @type {!Ext.ICompositeElement} */
Ext.form.ITwinTriggerField.prototype.triggerEl;
 /** @type {!Ext.IElement} */
Ext.form.ITwinTriggerField.prototype.triggerWrap;

/**
 * [Method] Generates the arguments for the field decorations rendering template
 * @return {?} Object The template arguments
 */
Ext.form.ITwinTriggerField.prototype.getLabelableRenderData = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.ITwinTriggerField.prototype.getSubTplData = function() {};

/**
 * [Method] Get the total width of the trigger button area
 * @return {number} Number The total trigger width
 */
Ext.form.ITwinTriggerField.prototype.getTriggerWidth = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITwinTriggerField.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITwinTriggerField.prototype.onRender = function() {};

/**
 * [Method] The function that should handle the trigger s click event
 * @param {!Ext.IEventObject=} e Ext.EventObject
 * @return {void}
 */
Ext.form.ITwinTriggerField.prototype.onTriggerClick = function(e) {};

/**
 * [Method] Sets the editable state of this field
 * @param {boolean=} editable Boolean True to allow the user to directly edit the field text. If false is passed, the user will only be able to modify the field using the trigger. Will also add a click event to the text field which will call the trigger.
 * @return {void}
 */
Ext.form.ITwinTriggerField.prototype.setEditable = function(editable) {};

/**
 * [Method] Sets the read only state of this field
 * @param {boolean=} readOnly Boolean True to prevent the user changing the field and explicitly hide the trigger. Setting this to true will supercede settings editable and hideTrigger. Setting this to false will defer back to editable and hideTrigger.
 * @return {void}
 */
Ext.form.ITwinTriggerField.prototype.setReadOnly = function(readOnly) {};
/**
 * @extends {Ext.form.field.IText}
 * @record
 * @struct
 */
Ext.form.ITrigger = function() {};
 /** @type {?} */
Ext.form.ITrigger.prototype.componentLayout;
 /** @type {boolean} */
Ext.form.ITrigger.prototype.editable;
 /** @type {boolean} */
Ext.form.ITrigger.prototype.hideTrigger;
 /** @type {boolean} */
Ext.form.ITrigger.prototype.readOnly;
 /** @type {boolean} */
Ext.form.ITrigger.prototype.repeatTriggerClick;
 /** @type {boolean} */
Ext.form.ITrigger.prototype.selectOnFocus;
 /** @type {string} */
Ext.form.ITrigger.prototype.triggerBaseCls;
 /** @type {string} */
Ext.form.ITrigger.prototype.triggerCls;
 /** @type {string} */
Ext.form.ITrigger.prototype.triggerNoEditCls;
 /** @type {string} */
Ext.form.ITrigger.prototype.triggerWrapCls;
 /** @type {!Ext.IElement} */
Ext.form.ITrigger.prototype.inputCell;
 /** @type {!Ext.ICompositeElement} */
Ext.form.ITrigger.prototype.triggerEl;
 /** @type {!Ext.IElement} */
Ext.form.ITrigger.prototype.triggerWrap;

/**
 * [Method] Generates the arguments for the field decorations rendering template
 * @return {?} Object The template arguments
 */
Ext.form.ITrigger.prototype.getLabelableRenderData = function() {};

/**
 * [Method] Creates and returns the data object to be used when rendering the fieldSubTpl
 * @return {?} Object The template data
 */
Ext.form.ITrigger.prototype.getSubTplData = function() {};

/**
 * [Method] Get the total width of the trigger button area
 * @return {number} Number The total trigger width
 */
Ext.form.ITrigger.prototype.getTriggerWidth = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITrigger.prototype.initComponent = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.form.ITrigger.prototype.onRender = function() {};

/**
 * [Method] The function that should handle the trigger s click event
 * @param {!Ext.IEventObject=} e Ext.EventObject
 * @return {void}
 */
Ext.form.ITrigger.prototype.onTriggerClick = function(e) {};

/**
 * [Method] Sets the editable state of this field
 * @param {boolean=} editable Boolean True to allow the user to directly edit the field text. If false is passed, the user will only be able to modify the field using the trigger. Will also add a click event to the text field which will call the trigger.
 * @return {void}
 */
Ext.form.ITrigger.prototype.setEditable = function(editable) {};

/**
 * [Method] Sets the read only state of this field
 * @param {boolean=} readOnly Boolean True to prevent the user changing the field and explicitly hide the trigger. Setting this to true will supercede settings editable and hideTrigger. Setting this to false will defer back to editable and hideTrigger.
 * @return {void}
 */
Ext.form.ITrigger.prototype.setReadOnly = function(readOnly) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.form.field.IVTypes = function() {};
/**
 * @constructor
 * @struct
 */
Ext.form.field.VTypes = function() {};
 /** @type {!RegExp} */
Ext.form.field.VTypes.alphaMask;
 /** @type {string} */
Ext.form.field.VTypes.alphaText;
 /** @type {!RegExp} */
Ext.form.field.VTypes.alphanumMask;
 /** @type {string} */
Ext.form.field.VTypes.alphanumText;
 /** @type {!RegExp} */
Ext.form.field.VTypes.emailMask;
 /** @type {string} */
Ext.form.field.VTypes.emailText;
 /** @type {!Ext.IClass} */
Ext.form.field.VTypes.self;
 /** @type {string} */
Ext.form.field.VTypes.urlText;

/**
 * [Method] The function used to validate alpha values
 * @param {string=} value String The value
 * @return {boolean} Boolean true if the RegExp test passed, and false if not.
 */
Ext.form.field.VTypes.alpha = function(value) {};

/**
 * [Method] The function used to validate alphanumeric values
 * @param {string=} value String The value
 * @return {boolean} Boolean true if the RegExp test passed, and false if not.
 */
Ext.form.field.VTypes.alphanum = function(value) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.form.field.VTypes.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.form.field.VTypes.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.form.field.VTypes.callSuper = function(args) {};

/**
 * [Method] The function used to validate email addresses
 * @param {string=} value String The email address
 * @return {boolean} Boolean true if the RegExp test passed, and false if not.
 */
Ext.form.field.VTypes.email = function(value) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.form.field.VTypes.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.form.field.VTypes.initConfig = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.form.field.VTypes.statics = function() {};

/**
 * [Method] The function used to validate URLs
 * @param {string=} value String The URL
 * @return {boolean} Boolean true if the RegExp test passed, and false if not.
 */
Ext.form.field.VTypes.url = function(value) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.form.IVTypes = function() {};
/**
 * @constructor
 * @struct
 */
Ext.form.VTypes = function() {};
 /** @type {!RegExp} */
Ext.form.VTypes.alphaMask;
 /** @type {string} */
Ext.form.VTypes.alphaText;
 /** @type {!RegExp} */
Ext.form.VTypes.alphanumMask;
 /** @type {string} */
Ext.form.VTypes.alphanumText;
 /** @type {!RegExp} */
Ext.form.VTypes.emailMask;
 /** @type {string} */
Ext.form.VTypes.emailText;
 /** @type {!Ext.IClass} */
Ext.form.VTypes.self;
 /** @type {string} */
Ext.form.VTypes.urlText;

/**
 * [Method] The function used to validate alpha values
 * @param {string=} value String The value
 * @return {boolean} Boolean true if the RegExp test passed, and false if not.
 */
Ext.form.VTypes.alpha = function(value) {};

/**
 * [Method] The function used to validate alphanumeric values
 * @param {string=} value String The value
 * @return {boolean} Boolean true if the RegExp test passed, and false if not.
 */
Ext.form.VTypes.alphanum = function(value) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.form.VTypes.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.form.VTypes.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.form.VTypes.callSuper = function(args) {};

/**
 * [Method] The function used to validate email addresses
 * @param {string=} value String The email address
 * @return {boolean} Boolean true if the RegExp test passed, and false if not.
 */
Ext.form.VTypes.email = function(value) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.form.VTypes.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.form.VTypes.initConfig = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.form.VTypes.statics = function() {};

/**
 * [Method] The function used to validate URLs
 * @param {string=} value String The URL
 * @return {boolean} Boolean true if the RegExp test passed, and false if not.
 */
Ext.form.VTypes.url = function(value) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.form.IFieldAncestor = function() {};
 /** @type {?} */
Ext.form.IFieldAncestor.prototype.fieldDefaults;

/**
 * [Method] Initializes the FieldAncestor s state this must be called from the initComponent method of any components importing
 * @return {void}
 */
Ext.form.IFieldAncestor.prototype.initFieldAncestor = function() {};

/**
 * [Method] Fired when the error message of any field within the container changes
 * @param {!Ext.form.ILabelable=} field Ext.form.Labelable The sub-field whose active error changed
 * @param {string=} error String The new active error message
 * @return {void}
 */
Ext.form.IFieldAncestor.prototype.onFieldErrorChange = function(field, error) {};

/**
 * [Method] Fired when the validity of any field within the container changes
 * @param {!Ext.form.field.IField=} field Ext.form.field.Field The sub-field whose validity changed
 * @param {boolean=} valid Boolean The new validity state
 * @return {void}
 */
Ext.form.IFieldAncestor.prototype.onFieldValidityChange = function(field, valid) {};
/**
 * @extends {Ext.container.IContainer}
 * @extends {Ext.form.ILabelable}
 * @extends {Ext.form.IFieldAncestor}
 * @record
 * @struct
 */
Ext.form.IFieldContainer = function() {};
 /** @type {boolean} */
Ext.form.IFieldContainer.prototype.combineErrors;
 /** @type {boolean} */
Ext.form.IFieldContainer.prototype.combineLabels;
 /** @type {string} */
Ext.form.IFieldContainer.prototype.componentCls;
 /** @type {?} */
Ext.form.IFieldContainer.prototype.componentLayout;
 /** @type {string} */
Ext.form.IFieldContainer.prototype.invalidCls;
 /** @type {string} */
Ext.form.IFieldContainer.prototype.labelConnector;
 /** @type {boolean} */
Ext.form.IFieldContainer.prototype.maskOnDisable;

/**
 * [Method] Gets the active error message for this component if any
 * @return {string} String The active error message on the component; if there is no error, an empty string is returned.
 */
Ext.form.IFieldContainer.prototype.getActiveError = function() {};

/**
 * [Method] Gets an Array of any active error messages currently applied to the field
 * @return {!Array<string>} String[] The active error messages on the component; if there are no errors, an empty Array is returned.
 */
Ext.form.IFieldContainer.prototype.getActiveErrors = function() {};

/**
 * [Method] Takes an Array of invalid Ext form field Field objects and builds a combined list of error messages from them
 * @param {!Array<!Ext.form.field.IField>=} invalidFields Ext.form.field.Field[] An Array of the sub-fields which are currently invalid.
 * @return {!Array<string>} String[] The combined list of error messages
 */
Ext.form.IFieldContainer.prototype.getCombinedErrors = function(invalidFields) {};

/**
 * [Method] Returns the combined field label if combineLabels is set to true and if there is no set fieldLabel
 * @return {string} String The label, or empty string if none.
 */
Ext.form.IFieldContainer.prototype.getFieldLabel = function() {};

/**
 * [Method] Get the input id if any for this component
 * @return {string} String The input id
 */
Ext.form.IFieldContainer.prototype.getInputId = function() {};

/**
 * [Method] Gets the width of the label if visible
 * @return {number} Number The label width
 */
Ext.form.IFieldContainer.prototype.getLabelWidth = function() {};

/**
 * [Method] Generates the arguments for the field decorations rendering template
 * @return {?} Object The template arguments
 */
Ext.form.IFieldContainer.prototype.getLabelableRenderData = function() {};

/**
 * [Method] Gets the markup to be inserted into the outer template s bodyEl
 * @return {string} String The markup to be inserted
 */
Ext.form.IFieldContainer.prototype.getSubTplMarkup = function() {};

/**
 * [Method] Tells whether the field currently has an active error message
 * @return {boolean} Boolean
 */
Ext.form.IFieldContainer.prototype.hasActiveError = function() {};

/**
 * [Method] Checks if the field has a visible label
 * @return {boolean} Boolean True if the field has a visible label
 */
Ext.form.IFieldContainer.prototype.hasVisibleLabel = function() {};

/**
 * [Method] Initializes the FieldAncestor s state this must be called from the initComponent method of any components importing
 * @return {void}
 */
Ext.form.IFieldContainer.prototype.initFieldAncestor = function() {};

/**
 * [Method] Performs initialization of this mixin
 * @return {void}
 */
Ext.form.IFieldContainer.prototype.initLabelable = function() {};

/**
 * [Method] Initialized the renderData to be used when rendering the renderTpl
 * @return {?} Object Object with keys and values that are going to be applied to the renderTpl
 */
Ext.form.IFieldContainer.prototype.initRenderData = function() {};

/**
 * [Method] Called when a Ext form Labelable instance is added to the container s subtree
 * @param {!Ext.form.ILabelable=} labelable Ext.form.Labelable The instance that was added
 * @return {void}
 */
Ext.form.IFieldContainer.prototype.onAdd = function(labelable) {};

/**
 * [Method] Fired when the validity of any field within the container changes
 * @param {!Ext.form.field.IField=} field Ext.form.field.Field The sub-field whose validity changed
 * @param {boolean=} valid Boolean The new validity state
 * @return {void}
 */
Ext.form.IFieldContainer.prototype.onFieldValidityChange = function(field, valid) {};

/**
 * [Method] Called when a Ext form Labelable instance is removed from the container s subtree
 * @param {!Ext.form.ILabelable=} labelable Ext.form.Labelable The instance that was removed
 * @return {void}
 */
Ext.form.IFieldContainer.prototype.onRemove = function(labelable) {};

/**
 * [Method] Sets the active error message to the given string
 * @param {string=} msg String The error message
 * @return {void}
 */
Ext.form.IFieldContainer.prototype.setActiveError = function(msg) {};

/**
 * [Method] Set the active error message to an Array of error messages
 * @param {!Array<string>=} errors String[] The error messages
 * @return {void}
 */
Ext.form.IFieldContainer.prototype.setActiveErrors = function(errors) {};

/**
 * [Method] Applies a set of default configuration values to this Labelable instance
 * @param {?=} defaults Object The defaults to apply to the object.
 * @return {void}
 */
Ext.form.IFieldContainer.prototype.setFieldDefaults = function(defaults) {};

/**
 * [Method] Set the label of this field
 * @param {string=} label String The new label. The labelSeparator will be automatically appended to the label string.
 * @return {void}
 */
Ext.form.IFieldContainer.prototype.setFieldLabel = function(label) {};

/**
 * [Method] Returns the trimmed label by slicing off the label separator character
 * @return {string} String The trimmed field label, or empty string if not defined
 */
Ext.form.IFieldContainer.prototype.trimLabelSeparator = function() {};

/**
 * [Method] Clears the active error message s
 * @return {void}
 */
Ext.form.IFieldContainer.prototype.unsetActiveError = function() {};
/**
 * @extends {Ext.container.IContainer}
 * @extends {Ext.form.IFieldAncestor}
 * @record
 * @struct
 */
Ext.form.IFieldSet = function() {};
 /** @type {?} */
Ext.form.IFieldSet.prototype.autoEl;
 /** @type {string} */
Ext.form.IFieldSet.prototype.baseCls;
 /** @type {string} */
Ext.form.IFieldSet.prototype.checkboxName;
 /** @type {boolean} */
Ext.form.IFieldSet.prototype.checkboxToggle;
 /** @type {boolean} */
Ext.form.IFieldSet.prototype.collapsed;
 /** @type {boolean} */
Ext.form.IFieldSet.prototype.collapsible;
 /** @type {?} */
Ext.form.IFieldSet.prototype.componentLayout;
 /** @type {?} */
Ext.form.IFieldSet.prototype.layout;
 /** @type {?} */
Ext.form.IFieldSet.prototype.renderTpl;
 /** @type {!Array<string>} */
Ext.form.IFieldSet.prototype.stateEvents;
 /** @type {string} */
Ext.form.IFieldSet.prototype.title;
 /** @type {boolean} */
Ext.form.IFieldSet.prototype.toggleOnTitleClick;
 /** @type {!Ext.form.field.ICheckbox} */
Ext.form.IFieldSet.prototype.checkboxCmp;
 /** @type {!Ext.IComponent} */
Ext.form.IFieldSet.prototype.legend;
 /** @type {boolean} */
Ext.form.IFieldSet.prototype.maskOnDisable;
 /** @type {!Ext.panel.ITool} */
Ext.form.IFieldSet.prototype.toggleCmp;

/**
 * [Method] Collapses the fieldset
 * @return {!Ext.form.IFieldSet} Ext.form.FieldSet this
 */
Ext.form.IFieldSet.prototype.collapse = function() {};

/**
 * [Method] Creates the checkbox component
 * @return {!Ext.IComponent} Ext.Component
 */
Ext.form.IFieldSet.prototype.createCheckboxCmp = function() {};

/**
 * [Method] Creates the legend title component
 * @return {!Ext.IComponent} Ext.Component
 */
Ext.form.IFieldSet.prototype.createTitleCmp = function() {};

/**
 * [Method] Creates the toggle button component
 * @return {!Ext.IComponent} Ext.Component
 */
Ext.form.IFieldSet.prototype.createToggleCmp = function() {};

/**
 * [Method] Expands the fieldset
 * @return {!Ext.form.IFieldSet} Ext.form.FieldSet this
 */
Ext.form.IFieldSet.prototype.expand = function() {};

/**
 * [Method] Used by ComponentQuery child and down to retrieve all of the items which can potentially be considered a child of th
 * @param {?=} deep Object
 * @return {void}
 */
Ext.form.IFieldSet.prototype.getRefItems = function(deep) {};

/**
 * [Method] The supplied default state gathering method for the AbstractComponent class
 * @return {?} Object
 */
Ext.form.IFieldSet.prototype.getState = function() {};

/**
 * [Method] Initializes the FieldAncestor s state this must be called from the initComponent method of any components importing
 * @return {void}
 */
Ext.form.IFieldSet.prototype.initFieldAncestor = function() {};

/**
 * [Method] Fired when the error message of any field within the container changes
 * @param {!Ext.form.ILabelable=} field Ext.form.Labelable The sub-field whose active error changed
 * @param {string=} error String The new active error message
 * @return {void}
 */
Ext.form.IFieldSet.prototype.onFieldErrorChange = function(field, error) {};

/**
 * [Method] Fired when the validity of any field within the container changes
 * @param {!Ext.form.field.IField=} field Ext.form.field.Field The sub-field whose validity changed
 * @param {boolean=} valid Boolean The new validity state
 * @return {void}
 */
Ext.form.IFieldSet.prototype.onFieldValidityChange = function(field, valid) {};

/**
 * [Method] Sets the title of this fieldset
 * @param {string=} title String The new title.
 * @return {!Ext.form.IFieldSet} Ext.form.FieldSet this
 */
Ext.form.IFieldSet.prototype.setTitle = function(title) {};

/**
 * [Method] Toggle the fieldset s collapsed state to the opposite of what it is currently
 * @return {void}
 */
Ext.form.IFieldSet.prototype.toggle = function() {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.form.ILabel = function() {};
 /** @type {?} */
Ext.form.ILabel.prototype.autoEl;
 /** @type {string} */
Ext.form.ILabel.prototype.forId;
 /** @type {string} */
Ext.form.ILabel.prototype.html;
 /** @type {string} */
Ext.form.ILabel.prototype.text;

/**
 * [Method] Updates the label s innerHTML with the specified string
 * @param {string=} text String The new label text
 * @param {boolean=} encode Boolean False to skip HTML-encoding the text when rendering it to the label. This might be useful if you want to include tags in the label's innerHTML rather than rendering them as string literals per the default logic.
 * @return {!Ext.form.ILabel} Ext.form.Label this
 */
Ext.form.ILabel.prototype.setText = function(text, encode) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.form.ILabelable = function() {};
 /** @type {string} */
Ext.form.ILabelable.prototype.activeError;
 /** @type {?} */
Ext.form.ILabelable.prototype.activeErrorsTpl;
 /** @type {?} */
Ext.form.ILabelable.prototype.afterBodyEl;
 /** @type {?} */
Ext.form.ILabelable.prototype.afterLabelTextTpl;
 /** @type {?} */
Ext.form.ILabelable.prototype.afterLabelTpl;
 /** @type {?} */
Ext.form.ILabelable.prototype.afterSubTpl;
 /** @type {boolean} */
Ext.form.ILabelable.prototype.autoFitErrors;
 /** @type {string} */
Ext.form.ILabelable.prototype.baseBodyCls;
 /** @type {?} */
Ext.form.ILabelable.prototype.beforeBodyEl;
 /** @type {?} */
Ext.form.ILabelable.prototype.beforeLabelTextTpl;
 /** @type {?} */
Ext.form.ILabelable.prototype.beforeLabelTpl;
 /** @type {?} */
Ext.form.ILabelable.prototype.beforeSubTpl;
 /** @type {string} */
Ext.form.ILabelable.prototype.clearCls;
 /** @type {string} */
Ext.form.ILabelable.prototype.errorMsgCls;
 /** @type {string} */
Ext.form.ILabelable.prototype.fieldBodyCls;
 /** @type {string} */
Ext.form.ILabelable.prototype.fieldLabel;
 /** @type {string} */
Ext.form.ILabelable.prototype.formItemCls;
 /** @type {boolean} */
Ext.form.ILabelable.prototype.hideEmptyLabel;
 /** @type {boolean} */
Ext.form.ILabelable.prototype.hideLabel;
 /** @type {string} */
Ext.form.ILabelable.prototype.invalidCls;
 /** @type {string} */
Ext.form.ILabelable.prototype.labelAlign;
 /** @type {?} */
Ext.form.ILabelable.prototype.labelAttrTpl;
 /** @type {string} */
Ext.form.ILabelable.prototype.labelCls;
 /** @type {string} */
Ext.form.ILabelable.prototype.labelClsExtra;
 /** @type {number} */
Ext.form.ILabelable.prototype.labelPad;
 /** @type {string} */
Ext.form.ILabelable.prototype.labelSeparator;
 /** @type {string} */
Ext.form.ILabelable.prototype.labelStyle;
 /** @type {number} */
Ext.form.ILabelable.prototype.labelWidth;
 /** @type {string} */
Ext.form.ILabelable.prototype.msgTarget;
 /** @type {boolean} */
Ext.form.ILabelable.prototype.preventMark;
 /** @type {!Ext.IElement} */
Ext.form.ILabelable.prototype.bodyEl;
 /** @type {!Ext.IElement} */
Ext.form.ILabelable.prototype.errorEl;
 /** @type {boolean} */
Ext.form.ILabelable.prototype.isFieldLabelable;
 /** @type {!Ext.IElement} */
Ext.form.ILabelable.prototype.labelCell;
 /** @type {!Ext.IElement} */
Ext.form.ILabelable.prototype.labelEl;

/**
 * [Method] Gets the active error message for this component if any
 * @return {string} String The active error message on the component; if there is no error, an empty string is returned.
 */
Ext.form.ILabelable.prototype.getActiveError = function() {};

/**
 * [Method] Gets an Array of any active error messages currently applied to the field
 * @return {!Array<string>} String[] The active error messages on the component; if there are no errors, an empty Array is returned.
 */
Ext.form.ILabelable.prototype.getActiveErrors = function() {};

/**
 * [Method] Returns the label for the field
 * @return {string} String The configured field label, or empty string if not defined
 */
Ext.form.ILabelable.prototype.getFieldLabel = function() {};

/**
 * [Method] Get the input id if any for this component
 * @return {string} String The input id
 */
Ext.form.ILabelable.prototype.getInputId = function() {};

/**
 * [Method] Gets the width of the label if visible
 * @return {number} Number The label width
 */
Ext.form.ILabelable.prototype.getLabelWidth = function() {};

/**
 * [Method] Generates the arguments for the field decorations rendering template
 * @return {?} Object The template arguments
 */
Ext.form.ILabelable.prototype.getLabelableRenderData = function() {};

/**
 * [Method] Gets the markup to be inserted into the outer template s bodyEl
 * @return {string} String The markup to be inserted
 */
Ext.form.ILabelable.prototype.getSubTplMarkup = function() {};

/**
 * [Method] Tells whether the field currently has an active error message
 * @return {boolean} Boolean
 */
Ext.form.ILabelable.prototype.hasActiveError = function() {};

/**
 * [Method] Checks if the field has a visible label
 * @return {boolean} Boolean True if the field has a visible label
 */
Ext.form.ILabelable.prototype.hasVisibleLabel = function() {};

/**
 * [Method] Performs initialization of this mixin
 * @return {void}
 */
Ext.form.ILabelable.prototype.initLabelable = function() {};

/**
 * [Method] Sets the active error message to the given string
 * @param {string=} msg String The error message
 * @return {void}
 */
Ext.form.ILabelable.prototype.setActiveError = function(msg) {};

/**
 * [Method] Set the active error message to an Array of error messages
 * @param {!Array<string>=} errors String[] The error messages
 * @return {void}
 */
Ext.form.ILabelable.prototype.setActiveErrors = function(errors) {};

/**
 * [Method] Applies a set of default configuration values to this Labelable instance
 * @param {?=} defaults Object The defaults to apply to the object.
 * @return {void}
 */
Ext.form.ILabelable.prototype.setFieldDefaults = function(defaults) {};

/**
 * [Method] Set the label of this field
 * @param {string=} label String The new label. The labelSeparator will be automatically appended to the label string.
 * @return {void}
 */
Ext.form.ILabelable.prototype.setFieldLabel = function(label) {};

/**
 * [Method] Returns the trimmed label by slicing off the label separator character
 * @return {string} String The trimmed field label, or empty string if not defined
 */
Ext.form.ILabelable.prototype.trimLabelSeparator = function() {};

/**
 * [Method] Clears the active error message s
 * @return {void}
 */
Ext.form.ILabelable.prototype.unsetActiveError = function() {};
/**
 * @extends {Ext.panel.IPanel}
 * @extends {Ext.form.IFieldAncestor}
 * @record
 * @struct
 */
Ext.form.IPanel = function() {};
 /** @type {?} */
Ext.form.IPanel.prototype.layout;
 /** @type {boolean} */
Ext.form.IPanel.prototype.pollForChanges;
 /** @type {number} */
Ext.form.IPanel.prototype.pollInterval;

/**
 * [Method] Forces each field within the form panel to check if its value has changed
 * @return {void}
 */
Ext.form.IPanel.prototype.checkChange = function() {};

/**
 * [Method] Provides access to the Form which this Panel contains
 * @return {!Ext.form.IBasic} Ext.form.Basic The Form which this Panel contains.
 */
Ext.form.IPanel.prototype.getForm = function() {};

/**
 * [Method] Returns the currently loaded Ext data Model instance if one was loaded via loadRecord
 * @return {!Ext.data.IModel} Ext.data.Model The loaded instance
 */
Ext.form.IPanel.prototype.getRecord = function() {};

/**
 * [Method] Convenience function for fetching the current value of each field in the form
 * @param {boolean=} asString Boolean If true, will return the key/value collection as a single URL-encoded param string.
 * @param {boolean=} dirtyOnly Boolean If true, only fields that are dirty will be included in the result.
 * @param {boolean=} includeEmptyText Boolean If true, the configured emptyText of empty fields will be used.
 * @param {boolean=} useDataValues Boolean If true, the getModelData method is used to retrieve values from fields, otherwise the getSubmitData method is used.
 * @return {?} String/Object
 */
Ext.form.IPanel.prototype.getValues = function(asString, dirtyOnly, includeEmptyText, useDataValues) {};

/**
 * [Method] Convenience function to check if the form has any invalid fields
 * @return {void}
 */
Ext.form.IPanel.prototype.hasInvalidField = function() {};

/**
 * [Method] Initializes the FieldAncestor s state this must be called from the initComponent method of any components importing
 * @return {void}
 */
Ext.form.IPanel.prototype.initFieldAncestor = function() {};

/**
 * [Method] Convenience function to check if the form has any dirty fields
 * @return {boolean} Boolean
 */
Ext.form.IPanel.prototype.isDirty = function() {};

/**
 * [Method] Convenience function to check if the form has all valid fields
 * @return {boolean} Boolean
 */
Ext.form.IPanel.prototype.isValid = function() {};

/**
 * [Method] This is a proxy for the underlying BasicForm s Ext form Basic load call
 * @param {?=} options Object The options to pass to the action (see Ext.form.Basic.load and Ext.form.Basic.doAction for details)
 * @return {void}
 */
Ext.form.IPanel.prototype.load = function(options) {};

/**
 * [Method] Loads an Ext data Model into this form internally just calls Ext form Basic loadRecord See also trackResetOnLoad
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to load
 * @return {!Ext.form.IBasic} Ext.form.Basic The Ext.form.Basic attached to this FormPanel
 */
Ext.form.IPanel.prototype.loadRecord = function(record) {};

/**
 * [Method] Fired when the error message of any field within the container changes
 * @param {!Ext.form.ILabelable=} field Ext.form.Labelable The sub-field whose active error changed
 * @param {string=} error String The new active error message
 * @return {void}
 */
Ext.form.IPanel.prototype.onFieldErrorChange = function(field, error) {};

/**
 * [Method] Fired when the validity of any field within the container changes
 * @param {!Ext.form.field.IField=} field Ext.form.field.Field The sub-field whose validity changed
 * @param {boolean=} valid Boolean The new validity state
 * @return {void}
 */
Ext.form.IPanel.prototype.onFieldValidityChange = function(field, valid) {};

/**
 * [Method] Start an interval task to continuously poll all the fields in the form for changes in their values
 * @param {number=} interval Number The interval in milliseconds at which the check should run.
 * @return {void}
 */
Ext.form.IPanel.prototype.startPolling = function(interval) {};

/**
 * [Method] Stop a running interval task that was started by startPolling
 * @return {void}
 */
Ext.form.IPanel.prototype.stopPolling = function() {};

/**
 * [Method] This is a proxy for the underlying BasicForm s Ext form Basic submit call
 * @param {?=} options Object The options to pass to the action (see Ext.form.Basic.submit and Ext.form.Basic.doAction for details)
 * @return {void}
 */
Ext.form.IPanel.prototype.submit = function(options) {};

/**
 * [Method] Persists the values in this form into the passed Ext data Model object in a beginEdit endEdit block
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to edit
 * @return {!Ext.form.IBasic} Ext.form.Basic The Ext.form.Basic attached to this FormPanel
 */
Ext.form.IPanel.prototype.updateRecord = function(record) {};
/**
 * @extends {Ext.panel.IPanel}
 * @extends {Ext.form.IFieldAncestor}
 * @record
 * @struct
 */
Ext.IFormPanel = function() {};
 /** @type {?} */
Ext.IFormPanel.prototype.layout;
 /** @type {boolean} */
Ext.IFormPanel.prototype.pollForChanges;
 /** @type {number} */
Ext.IFormPanel.prototype.pollInterval;

/**
 * [Method] Forces each field within the form panel to check if its value has changed
 * @return {void}
 */
Ext.IFormPanel.prototype.checkChange = function() {};

/**
 * [Method] Provides access to the Form which this Panel contains
 * @return {!Ext.form.IBasic} Ext.form.Basic The Form which this Panel contains.
 */
Ext.IFormPanel.prototype.getForm = function() {};

/**
 * [Method] Returns the currently loaded Ext data Model instance if one was loaded via loadRecord
 * @return {!Ext.data.IModel} Ext.data.Model The loaded instance
 */
Ext.IFormPanel.prototype.getRecord = function() {};

/**
 * [Method] Convenience function for fetching the current value of each field in the form
 * @param {boolean=} asString Boolean If true, will return the key/value collection as a single URL-encoded param string.
 * @param {boolean=} dirtyOnly Boolean If true, only fields that are dirty will be included in the result.
 * @param {boolean=} includeEmptyText Boolean If true, the configured emptyText of empty fields will be used.
 * @param {boolean=} useDataValues Boolean If true, the getModelData method is used to retrieve values from fields, otherwise the getSubmitData method is used.
 * @return {?} String/Object
 */
Ext.IFormPanel.prototype.getValues = function(asString, dirtyOnly, includeEmptyText, useDataValues) {};

/**
 * [Method] Convenience function to check if the form has any invalid fields
 * @return {void}
 */
Ext.IFormPanel.prototype.hasInvalidField = function() {};

/**
 * [Method] Initializes the FieldAncestor s state this must be called from the initComponent method of any components importing
 * @return {void}
 */
Ext.IFormPanel.prototype.initFieldAncestor = function() {};

/**
 * [Method] Convenience function to check if the form has any dirty fields
 * @return {boolean} Boolean
 */
Ext.IFormPanel.prototype.isDirty = function() {};

/**
 * [Method] Convenience function to check if the form has all valid fields
 * @return {boolean} Boolean
 */
Ext.IFormPanel.prototype.isValid = function() {};

/**
 * [Method] This is a proxy for the underlying BasicForm s Ext form Basic load call
 * @param {?=} options Object The options to pass to the action (see Ext.form.Basic.load and Ext.form.Basic.doAction for details)
 * @return {void}
 */
Ext.IFormPanel.prototype.load = function(options) {};

/**
 * [Method] Loads an Ext data Model into this form internally just calls Ext form Basic loadRecord See also trackResetOnLoad
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to load
 * @return {!Ext.form.IBasic} Ext.form.Basic The Ext.form.Basic attached to this FormPanel
 */
Ext.IFormPanel.prototype.loadRecord = function(record) {};

/**
 * [Method] Fired when the error message of any field within the container changes
 * @param {!Ext.form.ILabelable=} field Ext.form.Labelable The sub-field whose active error changed
 * @param {string=} error String The new active error message
 * @return {void}
 */
Ext.IFormPanel.prototype.onFieldErrorChange = function(field, error) {};

/**
 * [Method] Fired when the validity of any field within the container changes
 * @param {!Ext.form.field.IField=} field Ext.form.field.Field The sub-field whose validity changed
 * @param {boolean=} valid Boolean The new validity state
 * @return {void}
 */
Ext.IFormPanel.prototype.onFieldValidityChange = function(field, valid) {};

/**
 * [Method] Start an interval task to continuously poll all the fields in the form for changes in their values
 * @param {number=} interval Number The interval in milliseconds at which the check should run.
 * @return {void}
 */
Ext.IFormPanel.prototype.startPolling = function(interval) {};

/**
 * [Method] Stop a running interval task that was started by startPolling
 * @return {void}
 */
Ext.IFormPanel.prototype.stopPolling = function() {};

/**
 * [Method] This is a proxy for the underlying BasicForm s Ext form Basic submit call
 * @param {?=} options Object The options to pass to the action (see Ext.form.Basic.submit and Ext.form.Basic.doAction for details)
 * @return {void}
 */
Ext.IFormPanel.prototype.submit = function(options) {};

/**
 * [Method] Persists the values in this form into the passed Ext data Model object in a beginEdit endEdit block
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to edit
 * @return {!Ext.form.IBasic} Ext.form.Basic The Ext.form.Basic attached to this FormPanel
 */
Ext.IFormPanel.prototype.updateRecord = function(record) {};
/**
 * @extends {Ext.panel.IPanel}
 * @extends {Ext.form.IFieldAncestor}
 * @record
 * @struct
 */
Ext.form.IFormPanel = function() {};
 /** @type {?} */
Ext.form.IFormPanel.prototype.layout;
 /** @type {boolean} */
Ext.form.IFormPanel.prototype.pollForChanges;
 /** @type {number} */
Ext.form.IFormPanel.prototype.pollInterval;

/**
 * [Method] Forces each field within the form panel to check if its value has changed
 * @return {void}
 */
Ext.form.IFormPanel.prototype.checkChange = function() {};

/**
 * [Method] Provides access to the Form which this Panel contains
 * @return {!Ext.form.IBasic} Ext.form.Basic The Form which this Panel contains.
 */
Ext.form.IFormPanel.prototype.getForm = function() {};

/**
 * [Method] Returns the currently loaded Ext data Model instance if one was loaded via loadRecord
 * @return {!Ext.data.IModel} Ext.data.Model The loaded instance
 */
Ext.form.IFormPanel.prototype.getRecord = function() {};

/**
 * [Method] Convenience function for fetching the current value of each field in the form
 * @param {boolean=} asString Boolean If true, will return the key/value collection as a single URL-encoded param string.
 * @param {boolean=} dirtyOnly Boolean If true, only fields that are dirty will be included in the result.
 * @param {boolean=} includeEmptyText Boolean If true, the configured emptyText of empty fields will be used.
 * @param {boolean=} useDataValues Boolean If true, the getModelData method is used to retrieve values from fields, otherwise the getSubmitData method is used.
 * @return {?} String/Object
 */
Ext.form.IFormPanel.prototype.getValues = function(asString, dirtyOnly, includeEmptyText, useDataValues) {};

/**
 * [Method] Convenience function to check if the form has any invalid fields
 * @return {void}
 */
Ext.form.IFormPanel.prototype.hasInvalidField = function() {};

/**
 * [Method] Initializes the FieldAncestor s state this must be called from the initComponent method of any components importing
 * @return {void}
 */
Ext.form.IFormPanel.prototype.initFieldAncestor = function() {};

/**
 * [Method] Convenience function to check if the form has any dirty fields
 * @return {boolean} Boolean
 */
Ext.form.IFormPanel.prototype.isDirty = function() {};

/**
 * [Method] Convenience function to check if the form has all valid fields
 * @return {boolean} Boolean
 */
Ext.form.IFormPanel.prototype.isValid = function() {};

/**
 * [Method] This is a proxy for the underlying BasicForm s Ext form Basic load call
 * @param {?=} options Object The options to pass to the action (see Ext.form.Basic.load and Ext.form.Basic.doAction for details)
 * @return {void}
 */
Ext.form.IFormPanel.prototype.load = function(options) {};

/**
 * [Method] Loads an Ext data Model into this form internally just calls Ext form Basic loadRecord See also trackResetOnLoad
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to load
 * @return {!Ext.form.IBasic} Ext.form.Basic The Ext.form.Basic attached to this FormPanel
 */
Ext.form.IFormPanel.prototype.loadRecord = function(record) {};

/**
 * [Method] Fired when the error message of any field within the container changes
 * @param {!Ext.form.ILabelable=} field Ext.form.Labelable The sub-field whose active error changed
 * @param {string=} error String The new active error message
 * @return {void}
 */
Ext.form.IFormPanel.prototype.onFieldErrorChange = function(field, error) {};

/**
 * [Method] Fired when the validity of any field within the container changes
 * @param {!Ext.form.field.IField=} field Ext.form.field.Field The sub-field whose validity changed
 * @param {boolean=} valid Boolean The new validity state
 * @return {void}
 */
Ext.form.IFormPanel.prototype.onFieldValidityChange = function(field, valid) {};

/**
 * [Method] Start an interval task to continuously poll all the fields in the form for changes in their values
 * @param {number=} interval Number The interval in milliseconds at which the check should run.
 * @return {void}
 */
Ext.form.IFormPanel.prototype.startPolling = function(interval) {};

/**
 * [Method] Stop a running interval task that was started by startPolling
 * @return {void}
 */
Ext.form.IFormPanel.prototype.stopPolling = function() {};

/**
 * [Method] This is a proxy for the underlying BasicForm s Ext form Basic submit call
 * @param {?=} options Object The options to pass to the action (see Ext.form.Basic.submit and Ext.form.Basic.doAction for details)
 * @return {void}
 */
Ext.form.IFormPanel.prototype.submit = function(options) {};

/**
 * [Method] Persists the values in this form into the passed Ext data Model object in a beginEdit endEdit block
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to edit
 * @return {!Ext.form.IBasic} Ext.form.Basic The Ext.form.Basic attached to this FormPanel
 */
Ext.form.IFormPanel.prototype.updateRecord = function(record) {};
/**
 * @extends {Ext.form.ICheckboxGroup}
 * @record
 * @struct
 */
Ext.form.IRadioGroup = function() {};
 /** @type {boolean} */
Ext.form.IRadioGroup.prototype.allowBlank;
 /** @type {string} */
Ext.form.IRadioGroup.prototype.blankText;
 /** @type {string} */
Ext.form.IRadioGroup.prototype.defaultType;
 /** @type {?} */
Ext.form.IRadioGroup.prototype.items;

/**
 * [Method] Checks whether the value of the field has changed since the last time it was checked
 * @return {void}
 */
Ext.form.IRadioGroup.prototype.checkChange = function() {};

/**
 * [Method] Sets the value of the radio group
 * @param {?=} value Object The map from names to values to be set.
 * @return {!Ext.form.ICheckboxGroup} Ext.form.CheckboxGroup this
 */
Ext.form.IRadioGroup.prototype.setValue = function(value) {};
/**
 * @extends {Ext.util.IMixedCollection}
 * @record
 * @struct
 */
Ext.form.IRadioManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.form.RadioManager = function() {};
 /** @type {?} */
Ext.form.RadioManager.hasListeners;
 /** @type {boolean} */
Ext.form.RadioManager.isMixedCollection;
 /** @type {boolean} */
Ext.form.RadioManager.isObservable;
 /** @type {boolean} */
Ext.form.RadioManager.isSortable;
 /** @type {!Ext.IClass} */
Ext.form.RadioManager.self;
 /** @type {!Ext.util.IMixedCollection} */
Ext.form.RadioManager.sorters;

/**
 * [Method] Adds an item to the collection
 * @param {?=} key String/Object The key to associate with the item, or the new item. If a getKey implementation was specified for this MixedCollection, or if the key of the stored items is in a property called id, the MixedCollection will be able to derive the key for the new item. In this case just pass the new item in this parameter.
 * @param {?=} obj Object The item to add.
 * @return {?} Object The item added.
 */
Ext.form.RadioManager.add = function(key, obj) {};

/**
 * [Method] Adds all elements of an Array or an Object to the collection
 * @param {?=} objs Object/Array An Object containing properties which will be added to the collection, or an Array of values, each of which are added to the collection. Functions references will be added to the collection if allowFunctions has been set to true.
 * @return {void}
 */
Ext.form.RadioManager.addAll = function(objs) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.form.RadioManager.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.form.RadioManager.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.form.RadioManager.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.form.RadioManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.form.RadioManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.form.RadioManager.callSuper = function(args) {};

/**
 * [Method] Removes all items from the collection
 * @return {void}
 */
Ext.form.RadioManager.clear = function() {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.form.RadioManager.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.form.RadioManager.clearManagedListeners = function() {};

/**
 * [Method] Creates a shallow copy of this collection
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection
 */
Ext.form.RadioManager.clone = function() {};

/**
 * [Method] Collects unique values of a particular property in this MixedCollection
 * @param {string=} property String The property to collect on
 * @param {string=} root String 'root' property to extract the first argument from. This is used mainly when summing fields in records, where the fields are all stored inside the 'data' object
 * @param {boolean=} allowBlank Boolean Pass true to allow null, undefined or empty string values
 * @return {!Array<?>} Array The unique values
 */
Ext.form.RadioManager.collect = function(property, root, allowBlank) {};

/**
 * [Method] Returns true if the collection contains the passed Object as an item
 * @param {?=} o Object The Object to look for in the collection.
 * @return {boolean} Boolean True if the collection contains the Object as an item.
 */
Ext.form.RadioManager.contains = function(o) {};

/**
 * [Method] Returns true if the collection contains the passed Object as a key
 * @param {string=} key String The key to look for in the collection.
 * @return {boolean} Boolean True if the collection contains the Object as a key.
 */
Ext.form.RadioManager.containsKey = function(key) {};

/**
 * [Method] Executes the specified function once for every item in the collection
 * @param {?=} fn Function The function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current item in the iteration.
 * @return {void}
 */
Ext.form.RadioManager.each = function(fn, scope) {};

/**
 * [Method] Executes the specified function once for every key in the collection passing each key and its associated item as th
 * @param {?=} fn Function The function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {void}
 */
Ext.form.RadioManager.eachKey = function(fn, scope) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.form.RadioManager.enableBubble = function(eventNames) {};

/**
 * [Method] Filters the objects in this collection by a set of Filters or by a single property value pair with optional paramete
 * @param {?=} property Ext.util.Filter[]/String A property on your objects, or an array of Filter objects
 * @param {?=} value String/RegExp Either string that the property values should start with or a RegExp to test against the property
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection The new filtered collection
 */
Ext.form.RadioManager.filter = function(property, value, anyMatch, caseSensitive) {};

/**
 * [Method] Filter by a function
 * @param {?=} fn Function The function to be called.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this MixedCollection.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection The new filtered collection
 */
Ext.form.RadioManager.filterBy = function(fn, scope) {};

/**
 * [Method] Returns the first item in the collection which elicits a true return value from the passed selection function
 * @return {void}
 */
Ext.form.RadioManager.find = function() {};

/**
 * [Method] Returns the first item in the collection which elicits a true return value from the passed selection function
 * @param {?=} fn Function The selection function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {?} Object The first item in the collection which returned true from the selection function, or null if none was found.
 */
Ext.form.RadioManager.findBy = function(fn, scope) {};

/**
 * [Method] Finds the index of the first matching object in this collection by a specific property value
 * @param {string=} property String The name of a property on your objects.
 * @param {?=} value String/RegExp A string that the property values should start with or a RegExp to test against the property.
 * @param {number=} start Number The index to start searching at.
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning.
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison.
 * @return {number} Number The matched index or -1
 */
Ext.form.RadioManager.findIndex = function(property, value, start, anyMatch, caseSensitive) {};

/**
 * [Method] Find the index of the first matching object in this collection by a function
 * @param {?=} fn Function The function to be called.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this MixedCollection.
 * @param {number=} start Number The index to start searching at.
 * @return {number} Number The matched index or -1
 */
Ext.form.RadioManager.findIndexBy = function(fn, scope, start) {};

/**
 * [Method] Calculates the insertion index of the new item based upon the comparison function passed or the current sort order
 * @param {?=} newItem Object The new object to find the insertion position of.
 * @param {?=} sorterFn Function The function to sort by. This is the same as the sorting function passed to sortBy. It accepts 2 items from this MixedCollection, and returns -1 0, or 1 depending on the relative sort positions of the 2 compared items. If omitted, a function generated from the currently defined set of sorters will be used.
 * @return {number} Number The insertion point to add the new item into this MixedCollection at using insert
 */
Ext.form.RadioManager.findInsertionIndex = function(newItem, sorterFn) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.form.RadioManager.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.form.RadioManager.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the first item in the collection
 * @return {?} Object the first item in the collection..
 */
Ext.form.RadioManager.first = function() {};

/**
 * [Method] Returns a comparator function which compares two items and returns 1 0 or 1 depending on the currently defined set
 * @return {void}
 */
Ext.form.RadioManager.generateComparator = function() {};

/**
 * [Method] Returns the item associated with the passed key OR index
 * @param {?=} key String/Number The key or index of the item.
 * @return {?} Object If the item is found, returns the item. If the item was not found, returns undefined. If an item was found, but is a Class, returns null.
 */
Ext.form.RadioManager.get = function(key) {};

/**
 * [Method] Returns the item at the specified index
 * @param {number=} index Number The index of the item.
 * @return {?} Object The item at the specified index.
 */
Ext.form.RadioManager.getAt = function(index) {};

/**
 * [Method] Returns the item associated with the passed key
 * @param {?=} key String/Number The key of the item.
 * @return {?} Object The item associated with the passed key.
 */
Ext.form.RadioManager.getByKey = function(key) {};

/**
 * [Method] Returns the number of items in the collection
 * @return {number} Number the number of items in the collection.
 */
Ext.form.RadioManager.getCount = function() {};

/**
 * [Method] Gets the first sorter from the sorters collection excluding any groupers that may be in place
 * @return {!Ext.util.ISorter} Ext.util.Sorter The sorter, null if none exist
 */
Ext.form.RadioManager.getFirstSorter = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.form.RadioManager.getInitialConfig = function(name) {};

/**
 * [Method] A function which will be called passing a newly added object when the object is added without a separate id
 * @param {?=} item Object The item for which to find the key.
 * @return {?} Object The key for the passed item.
 */
Ext.form.RadioManager.getKey = function(item) {};

/**
 * [Method] Returns a range of items in this collection
 * @param {number=} startIndex Number The starting index. Defaults to 0.
 * @param {number=} endIndex Number The ending index. Defaults to the last item.
 * @return {!Array<?>} Array An array of items
 */
Ext.form.RadioManager.getRange = function(startIndex, endIndex) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.form.RadioManager.hasListener = function(eventName) {};

/**
 * [Method] Returns index within the collection of the passed Object
 * @param {?=} o Object The item to find the index of.
 * @return {number} Number index of the item. Returns -1 if not found.
 */
Ext.form.RadioManager.indexOf = function(o) {};

/**
 * [Method] Returns index within the collection of the passed key
 * @param {string=} key String The key to find the index of.
 * @return {number} Number index of the key.
 */
Ext.form.RadioManager.indexOfKey = function(key) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.form.RadioManager.initConfig = function(config) {};

/**
 * [Method] Performs initialization of this mixin
 * @return {void}
 */
Ext.form.RadioManager.initSortable = function() {};

/**
 * [Method] Inserts an item at the specified index in the collection
 * @param {number=} index Number The index to insert the item at.
 * @param {?=} key String/Object/String[]/Object[] The key to associate with the new item, or the item itself. May also be an array of either to insert multiple items at once.
 * @param {?=} o Object/Object[] If the second parameter was a key, the new item. May also be an array to insert multiple items at once.
 * @return {?} Object The item inserted or an array of items inserted.
 */
Ext.form.RadioManager.insert = function(index, key, o) {};

/**
 * [Method] Returns the last item in the collection
 * @return {?} Object the last item in the collection..
 */
Ext.form.RadioManager.last = function() {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.form.RadioManager.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.form.RadioManager.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.form.RadioManager.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.form.RadioManager.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Remove an item from the collection
 * @param {?=} o Object The item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.form.RadioManager.remove = function(o) {};

/**
 * [Method] Remove all items in the collection
 * @param {!Array<?>=} items Array An array of items to be removed.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection this object
 */
Ext.form.RadioManager.removeAll = function(items) {};

/**
 * [Method] Remove an item from a specified index in the collection
 * @param {number=} index Number The index within the collection of the item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.form.RadioManager.removeAt = function(index) {};

/**
 * [Method] Removes an item associated with the passed key fom the collection
 * @param {string=} key String The key of the item to remove. If null is passed, all objects which yielded no key from the configured getKey function are removed.
 * @return {?} Object Only returned if removing at a specified key. The item removed or false if no item was removed.
 */
Ext.form.RadioManager.removeAtKey = function(key) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.form.RadioManager.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.form.RadioManager.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Remove a range of items starting at a specified index in the collection
 * @param {number=} index Number The index within the collection of the item to remove.
 * @param {number=} removeCount Number The nuber of items to remove beginning at the specified index.
 * @return {?} Object The last item removed or false if no item was removed.
 */
Ext.form.RadioManager.removeRange = function(index, removeCount) {};

/**
 * [Method] Reorders each of the items based on a mapping from old index to new index
 * @param {?=} mapping Object Mapping from old item index to new item index
 * @return {void}
 */
Ext.form.RadioManager.reorder = function(mapping) {};

/**
 * [Method] Replaces an item in the collection
 * @param {string=} key String The key associated with the item to replace, or the replacement item. If you supplied a getKey implementation for this MixedCollection, or if the key of your stored items is in a property called id, then the MixedCollection will be able to derive the key of the replacement item. If you want to replace an item with one having the same key value, then just pass the replacement item in this parameter.
 * @param {?=} o Object {Object} o (optional) If the first parameter passed was a key, the item to associate with that key.
 * @return {?} Object The new item.
 */
Ext.form.RadioManager.replace = function(key, o) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.form.RadioManager.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.form.RadioManager.resumeEvents = function() {};

/**
 * [Method] Sorts the data in the Store by one or more of its properties
 * @param {?=} sorters String/Ext.util.Sorter[] Either a string name of one of the fields in this Store's configured Model, or an array of sorter configurations.
 * @param {string=} direction String The overall direction to sort the data by.
 * @return {!Array<!Ext.util.ISorter>} Ext.util.Sorter[]
 */
Ext.form.RadioManager.sort = function(sorters, direction) {};

/**
 * [Method] Sorts the collection by a single sorter function
 * @param {?=} sorterFn Function The function to sort by
 * @return {void}
 */
Ext.form.RadioManager.sortBy = function(sorterFn) {};

/**
 * [Method] Sorts this collection by keys
 * @param {string=} direction String 'ASC' or 'DESC'. Defaults to 'ASC'.
 * @param {?=} fn Function Comparison function that defines the sort order. Defaults to sorting by case insensitive string.
 * @return {void}
 */
Ext.form.RadioManager.sortByKey = function(direction, fn) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.form.RadioManager.statics = function() {};

/**
 * [Method] Collects all of the values of the given property and returns their sum
 * @param {string=} property String The property to sum by
 * @param {string=} root String 'root' property to extract the first argument from. This is used mainly when summing fields in records, where the fields are all stored inside the 'data' object
 * @param {number=} start Number The record index to start at
 * @param {number=} end Number The record index to end at
 * @return {number} Number The total
 */
Ext.form.RadioManager.sum = function(property, root, start, end) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.form.RadioManager.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.form.RadioManager.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.form.RadioManager.un = function(eventName, fn, scope) {};

/**
 * [Method] Change the key for an existing item in the collection
 * @param {?=} oldKey Object The old key
 * @param {?=} newKey Object The new key
 * @return {void}
 */
Ext.form.RadioManager.updateKey = function(oldKey, newKey) {};
/**
 * @record
 * @struct
 */
Ext.IFunction = function() {};
/**
 * @constructor
 * @struct
 */
Ext.Function = function() {};

/**
 * [Method] Create an alias to the provided method property with name methodName of object
 * @param {?=} object Object/Function
 * @param {string=} methodName String
 * @return {?} Function aliasFn
 */
Ext.Function.alias = function(object, methodName) {};

/**
 * [Method] Create a new function from the provided fn change this to the provided scope optionally overrides arguments for the
 * @param {?=} fn Function The function to delegate.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. If omitted, defaults to the default global environment object (usually the browser window).
 * @param {!Array<?>=} args Array Overrides arguments for the call. (Defaults to the arguments passed by the caller)
 * @param {?=} appendArgs Boolean/Number if True args are appended to call args instead of overriding, if a number the args are inserted at the specified position
 * @return {?} Function The new function
 */
Ext.Function.bind = function(fn, scope, args, appendArgs) {};

/**
 * [Method] Create a clone of the provided method
 * @param {?=} method Function
 * @return {?} Function cloneFn
 */
Ext.Function.clone = function(method) {};

/**
 * [Method] Creates a delegate function optionally with a bound scope which when called buffers the execution of the passed fu
 * @param {?=} fn Function The function to invoke on a buffered timer.
 * @param {number=} buffer Number The number of milliseconds by which to buffer the invocation of the function.
 * @param {?=} scope Object The scope (this reference) in which the passed function is executed. If omitted, defaults to the scope specified by the caller.
 * @param {!Array<?>=} args Array Override arguments for the call. Defaults to the arguments passed by the caller.
 * @return {?} Function A function which invokes the passed function after buffering for the specified time.
 */
Ext.Function.createBuffered = function(fn, buffer, scope, args) {};

/**
 * [Method] Creates a delegate callback which when called executes after a specific delay
 * @param {?=} fn Function The function which will be called on a delay when the returned function is called. Optionally, a replacement (or additional) argument list may be specified.
 * @param {number=} delay Number The number of milliseconds to defer execution by whenever called.
 * @param {?=} scope Object The scope (this reference) used by the function at execution time.
 * @param {!Array<?>=} args Array Override arguments for the call. (Defaults to the arguments passed by the caller)
 * @param {?=} appendArgs Boolean/Number if True args are appended to call args instead of overriding, if a number the args are inserted at the specified position.
 * @return {?} Function A function which, when called, executes the original function after the specified delay.
 */
Ext.Function.createDelayed = function(fn, delay, scope, args, appendArgs) {};

/**
 * [Method] Creates an interceptor function
 * @param {?=} origFn Function The original function.
 * @param {?=} newFn Function The function to call before the original
 * @param {?=} scope Object The scope (this reference) in which the passed function is executed. If omitted, defaults to the scope in which the original function is called or the browser window.
 * @param {?=} returnValue Object The value to return if the passed function return false.
 * @return {?} Function The new function
 */
Ext.Function.createInterceptor = function(origFn, newFn, scope, returnValue) {};

/**
 * [Method] Create a combined function call sequence of the original function  the passed function
 * @param {?=} originalFn Function The original function.
 * @param {?=} newFn Function The function to sequence
 * @param {?=} scope Object The scope (this reference) in which the passed function is executed. If omitted, defaults to the scope in which the original function is called or the default global environment object (usually the browser window).
 * @return {?} Function The new function
 */
Ext.Function.createSequence = function(originalFn, newFn, scope) {};

/**
 * [Method] Creates a throttled version of the passed function which when called repeatedly and rapidly invokes the passed func
 * @param {?=} fn Function The function to execute at a regular time interval.
 * @param {number=} interval Number The interval in milliseconds on which the passed function is executed.
 * @param {?=} scope Object The scope (this reference) in which the passed function is executed. If omitted, defaults to the scope specified by the caller.
 * @return {?} Function A function which invokes the passed function at the specified interval.
 */
Ext.Function.createThrottled = function(fn, interval, scope) {};

/**
 * [Method] Calls this function after the number of millseconds specified optionally in a specific scope
 * @param {?=} fn Function The function to defer.
 * @param {number=} millis Number The number of milliseconds for the setTimeout call (if less than or equal to 0 the function is executed immediately)
 * @param {?=} scope Object The scope (this reference) in which the function is executed. If omitted, defaults to the browser window.
 * @param {!Array<?>=} args Array Overrides arguments for the call. (Defaults to the arguments passed by the caller)
 * @param {?=} appendArgs Boolean/Number if True args are appended to call args instead of overriding, if a number the args are inserted at the specified position
 * @return {number} Number The timeout id that can be used with clearTimeout
 */
Ext.Function.defer = function(fn, millis, scope, args, appendArgs) {};

/**
 * [Method] A very commonly used method throughout the framework
 * @param {?=} setter Function
 * @return {?} Function flexSetter
 */
Ext.Function.flexSetter = function(setter) {};

/**
 * [Method] Adds behavior to an existing method that is executed after the original behavior of the function
 * @param {?=} object Object The target object
 * @param {string=} methodName String Name of the method to override
 * @param {?=} fn Function Function with the new behavior. It will be called with the same arguments as the original method. The return value of this function will be the return value of the new method.
 * @param {?=} scope Object The scope to execute the interceptor function. Defaults to the object.
 * @return {?} Function The new function just created.
 */
Ext.Function.interceptAfter = function(object, methodName, fn, scope) {};

/**
 * [Method] Adds behavior to an existing method that is executed before the original behavior of the function
 * @param {?=} object Object The target object
 * @param {string=} methodName String Name of the method to override
 * @param {?=} fn Function Function with the new behavior. It will be called with the same arguments as the original method. The return value of this function will be the return value of the new method.
 * @param {?=} scope Object The scope to execute the interceptor function. Defaults to the object.
 * @return {?} Function The new function just created.
 */
Ext.Function.interceptBefore = function(object, methodName, fn, scope) {};

/**
 * [Method] Create a new function from the provided fn the arguments of which are pre set to args
 * @param {?=} fn Function The original function
 * @param {!Array<?>=} args Array The arguments to pass to new callback
 * @param {?=} scope Object The scope (this reference) in which the function is executed.
 * @return {?} Function The new callback function
 */
Ext.Function.pass = function(fn, args, scope) {};
/** @const */
Ext.util = {};
/**
 * @record
 * @struct
 */
Ext.util.IFunctions = function() {};
/**
 * @constructor
 * @struct
 */
Ext.util.Functions = function() {};

/**
 * [Method] Create an alias to the provided method property with name methodName of object
 * @param {?=} object Object/Function
 * @param {string=} methodName String
 * @return {?} Function aliasFn
 */
Ext.util.Functions.alias = function(object, methodName) {};

/**
 * [Method] Create a new function from the provided fn change this to the provided scope optionally overrides arguments for the
 * @param {?=} fn Function The function to delegate.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. If omitted, defaults to the default global environment object (usually the browser window).
 * @param {!Array<?>=} args Array Overrides arguments for the call. (Defaults to the arguments passed by the caller)
 * @param {?=} appendArgs Boolean/Number if True args are appended to call args instead of overriding, if a number the args are inserted at the specified position
 * @return {?} Function The new function
 */
Ext.util.Functions.bind = function(fn, scope, args, appendArgs) {};

/**
 * [Method] Create a clone of the provided method
 * @param {?=} method Function
 * @return {?} Function cloneFn
 */
Ext.util.Functions.clone = function(method) {};

/**
 * [Method] Creates a delegate function optionally with a bound scope which when called buffers the execution of the passed fu
 * @param {?=} fn Function The function to invoke on a buffered timer.
 * @param {number=} buffer Number The number of milliseconds by which to buffer the invocation of the function.
 * @param {?=} scope Object The scope (this reference) in which the passed function is executed. If omitted, defaults to the scope specified by the caller.
 * @param {!Array<?>=} args Array Override arguments for the call. Defaults to the arguments passed by the caller.
 * @return {?} Function A function which invokes the passed function after buffering for the specified time.
 */
Ext.util.Functions.createBuffered = function(fn, buffer, scope, args) {};

/**
 * [Method] Creates a delegate callback which when called executes after a specific delay
 * @param {?=} fn Function The function which will be called on a delay when the returned function is called. Optionally, a replacement (or additional) argument list may be specified.
 * @param {number=} delay Number The number of milliseconds to defer execution by whenever called.
 * @param {?=} scope Object The scope (this reference) used by the function at execution time.
 * @param {!Array<?>=} args Array Override arguments for the call. (Defaults to the arguments passed by the caller)
 * @param {?=} appendArgs Boolean/Number if True args are appended to call args instead of overriding, if a number the args are inserted at the specified position.
 * @return {?} Function A function which, when called, executes the original function after the specified delay.
 */
Ext.util.Functions.createDelayed = function(fn, delay, scope, args, appendArgs) {};

/**
 * [Method] Creates an interceptor function
 * @param {?=} origFn Function The original function.
 * @param {?=} newFn Function The function to call before the original
 * @param {?=} scope Object The scope (this reference) in which the passed function is executed. If omitted, defaults to the scope in which the original function is called or the browser window.
 * @param {?=} returnValue Object The value to return if the passed function return false.
 * @return {?} Function The new function
 */
Ext.util.Functions.createInterceptor = function(origFn, newFn, scope, returnValue) {};

/**
 * [Method] Create a combined function call sequence of the original function  the passed function
 * @param {?=} originalFn Function The original function.
 * @param {?=} newFn Function The function to sequence
 * @param {?=} scope Object The scope (this reference) in which the passed function is executed. If omitted, defaults to the scope in which the original function is called or the default global environment object (usually the browser window).
 * @return {?} Function The new function
 */
Ext.util.Functions.createSequence = function(originalFn, newFn, scope) {};

/**
 * [Method] Creates a throttled version of the passed function which when called repeatedly and rapidly invokes the passed func
 * @param {?=} fn Function The function to execute at a regular time interval.
 * @param {number=} interval Number The interval in milliseconds on which the passed function is executed.
 * @param {?=} scope Object The scope (this reference) in which the passed function is executed. If omitted, defaults to the scope specified by the caller.
 * @return {?} Function A function which invokes the passed function at the specified interval.
 */
Ext.util.Functions.createThrottled = function(fn, interval, scope) {};

/**
 * [Method] Calls this function after the number of millseconds specified optionally in a specific scope
 * @param {?=} fn Function The function to defer.
 * @param {number=} millis Number The number of milliseconds for the setTimeout call (if less than or equal to 0 the function is executed immediately)
 * @param {?=} scope Object The scope (this reference) in which the function is executed. If omitted, defaults to the browser window.
 * @param {!Array<?>=} args Array Overrides arguments for the call. (Defaults to the arguments passed by the caller)
 * @param {?=} appendArgs Boolean/Number if True args are appended to call args instead of overriding, if a number the args are inserted at the specified position
 * @return {number} Number The timeout id that can be used with clearTimeout
 */
Ext.util.Functions.defer = function(fn, millis, scope, args, appendArgs) {};

/**
 * [Method] A very commonly used method throughout the framework
 * @param {?=} setter Function
 * @return {?} Function flexSetter
 */
Ext.util.Functions.flexSetter = function(setter) {};

/**
 * [Method] Adds behavior to an existing method that is executed after the original behavior of the function
 * @param {?=} object Object The target object
 * @param {string=} methodName String Name of the method to override
 * @param {?=} fn Function Function with the new behavior. It will be called with the same arguments as the original method. The return value of this function will be the return value of the new method.
 * @param {?=} scope Object The scope to execute the interceptor function. Defaults to the object.
 * @return {?} Function The new function just created.
 */
Ext.util.Functions.interceptAfter = function(object, methodName, fn, scope) {};

/**
 * [Method] Adds behavior to an existing method that is executed before the original behavior of the function
 * @param {?=} object Object The target object
 * @param {string=} methodName String Name of the method to override
 * @param {?=} fn Function Function with the new behavior. It will be called with the same arguments as the original method. The return value of this function will be the return value of the new method.
 * @param {?=} scope Object The scope to execute the interceptor function. Defaults to the object.
 * @return {?} Function The new function just created.
 */
Ext.util.Functions.interceptBefore = function(object, methodName, fn, scope) {};

/**
 * [Method] Create a new function from the provided fn the arguments of which are pre set to args
 * @param {?=} fn Function The original function
 * @param {!Array<?>=} args Array The arguments to pass to new callback
 * @param {?=} scope Object The scope (this reference) in which the function is executed.
 * @return {?} Function The new callback function
 */
Ext.util.Functions.pass = function(fn, args, scope) {};
/** @const */
Ext.fx = {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.fx.IAnim = function() {};
 /** @type {boolean} */
Ext.fx.IAnim.prototype.alternate;
 /** @type {?} */
Ext.fx.IAnim.prototype.callback;
 /** @type {number} */
Ext.fx.IAnim.prototype.delay;
 /** @type {number} */
Ext.fx.IAnim.prototype.duration;
 /** @type {boolean} */
Ext.fx.IAnim.prototype.dynamic;
 /** @type {string} */
Ext.fx.IAnim.prototype.easing;
 /** @type {?} */
Ext.fx.IAnim.prototype.from;
 /** @type {number} */
Ext.fx.IAnim.prototype.iterations;
 /** @type {?} */
Ext.fx.IAnim.prototype.keyframes;
 /** @type {boolean} */
Ext.fx.IAnim.prototype.reverse;
 /** @type {?} */
Ext.fx.IAnim.prototype.scope;
 /** @type {?} */
Ext.fx.IAnim.prototype.target;
 /** @type {?} */
Ext.fx.IAnim.prototype.to;
 /** @type {number} */
Ext.fx.IAnim.prototype.currentIteration;
 /** @type {boolean} */
Ext.fx.IAnim.prototype.isAnimation;
 /** @type {boolean} */
Ext.fx.IAnim.prototype.paused;
 /** @type {boolean} */
Ext.fx.IAnim.prototype.running;
 /** @type {?} */
Ext.fx.IAnim.prototype.startTime;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.fx.IAnim.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.fx.IAnim.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.fx.IAnim.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.fx.IAnim.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.fx.IAnim.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.fx.IAnim.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fire afteranimate event and end the animation
 * @return {void}
 */
Ext.fx.IAnim.prototype.end = function() {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.fx.IAnim.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.fx.IAnim.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.fx.IAnim.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.fx.IAnim.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.fx.IAnim.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.fx.IAnim.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.fx.IAnim.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.fx.IAnim.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.fx.IAnim.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.fx.IAnim.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.fx.IAnim.prototype.resumeEvents = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.fx.IAnim.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.fx.IAnim.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.fx.IAnim.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.fx.IAnimator = function() {};
 /** @type {number} */
Ext.fx.IAnimator.prototype.delay;
 /** @type {number} */
Ext.fx.IAnimator.prototype.duration;
 /** @type {boolean} */
Ext.fx.IAnimator.prototype.dynamic;
 /** @type {string} */
Ext.fx.IAnimator.prototype.easing;
 /** @type {number} */
Ext.fx.IAnimator.prototype.iterations;
 /** @type {?} */
Ext.fx.IAnimator.prototype.keyframes;
 /** @type {!Ext.fx.target.ITarget} */
Ext.fx.IAnimator.prototype.target;
 /** @type {number} */
Ext.fx.IAnimator.prototype.currentIteration;
 /** @type {boolean} */
Ext.fx.IAnimator.prototype.isAnimator;
 /** @type {number} */
Ext.fx.IAnimator.prototype.keyframeStep;
 /** @type {boolean} */
Ext.fx.IAnimator.prototype.paused;
 /** @type {boolean} */
Ext.fx.IAnimator.prototype.running;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.fx.IAnimator.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.fx.IAnimator.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.fx.IAnimator.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.fx.IAnimator.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.fx.IAnimator.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.fx.IAnimator.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fire afteranimate event and end the animation
 * @return {void}
 */
Ext.fx.IAnimator.prototype.end = function() {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.fx.IAnimator.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.fx.IAnimator.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.fx.IAnimator.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.fx.IAnimator.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.fx.IAnimator.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.fx.IAnimator.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.fx.IAnimator.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.fx.IAnimator.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.fx.IAnimator.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.fx.IAnimator.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.fx.IAnimator.prototype.resumeEvents = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.fx.IAnimator.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.fx.IAnimator.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.fx.IAnimator.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.fx.ICubicBezier = function() {};
/**
 * @constructor
 * @struct
 */
Ext.fx.CubicBezier = function() {};
 /** @type {!Ext.IClass} */
Ext.fx.CubicBezier.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.fx.CubicBezier.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.fx.CubicBezier.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.fx.CubicBezier.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.fx.CubicBezier.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.fx.CubicBezier.initConfig = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.fx.CubicBezier.statics = function() {};
/**
 * @record
 * @struct
 */
Ext.fx.IEasing = function() {};
/**
 * @constructor
 * @struct
 */
Ext.fx.Easing = function() {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.fx.IQueue}
 * @record
 * @struct
 */
Ext.fx.IManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.fx.Manager = function() {};
 /** @type {boolean} */
Ext.fx.Manager.forceJS;
 /** @type {number} */
Ext.fx.Manager.interval;
 /** @type {!Ext.IClass} */
Ext.fx.Manager.self;

/**
 * [Method] Add an Anim to the manager
 * @param {!Ext.fx.IAnim=} anim Ext.fx.Anim
 * @return {void}
 */
Ext.fx.Manager.addAnim = function(anim) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.fx.Manager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.fx.Manager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.fx.Manager.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.fx.Manager.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.fx.Manager.initConfig = function(config) {};

/**
 * [Method] Remove an Anim from the manager
 * @param {!Ext.fx.IAnim=} anim Ext.fx.Anim
 * @return {void}
 */
Ext.fx.Manager.removeAnim = function(anim) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.fx.Manager.statics = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.fx.IPropertyHandler = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.fx.IQueue = function() {};
/** @const */
Ext.fx.target = {};
/**
 * @extends {Ext.fx.target.ITarget}
 * @record
 * @struct
 */
Ext.fx.target.IComponent = function() {};
/**
 * @extends {Ext.fx.target.IElement}
 * @record
 * @struct
 */
Ext.fx.target.ICompositeElement = function() {};
 /** @type {boolean} */
Ext.fx.target.ICompositeElement.prototype.isComposite;
/**
 * @extends {Ext.fx.target.ICompositeElement}
 * @record
 * @struct
 */
Ext.fx.target.ICompositeElementCSS = function() {};
/**
 * @extends {Ext.fx.target.ISprite}
 * @record
 * @struct
 */
Ext.fx.target.ICompositeSprite = function() {};
/**
 * @extends {Ext.fx.target.ITarget}
 * @record
 * @struct
 */
Ext.fx.target.IElement = function() {};
/**
 * @extends {Ext.fx.target.IElement}
 * @record
 * @struct
 */
Ext.fx.target.IElementCSS = function() {};
/**
 * @extends {Ext.fx.target.ITarget}
 * @record
 * @struct
 */
Ext.fx.target.ISprite = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.fx.target.ITarget = function() {};
/** @const */
Ext.grid = {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.grid.ICellContext = function() {};
 /** @type {boolean} */
Ext.grid.ICellContext.prototype.isCellContext;
/**
 * @extends {Ext.IEditor}
 * @record
 * @struct
 */
Ext.grid.ICellEditor = function() {};
 /** @type {string} */
Ext.grid.ICellEditor.prototype.alignment;
 /** @type {string} */
Ext.grid.ICellEditor.prototype.cls;
 /** @type {boolean} */
Ext.grid.ICellEditor.prototype.hideEl;
 /** @type {?} */
Ext.grid.ICellEditor.prototype.shadow;
/** @const */
Ext.grid.column = {};
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.grid.column.IAction = function() {};
 /** @type {string} */
Ext.grid.column.IAction.prototype.altText;
 /** @type {boolean} */
Ext.grid.column.IAction.prototype.disabled;
 /** @type {?} */
Ext.grid.column.IAction.prototype.getClass;
 /** @type {?} */
Ext.grid.column.IAction.prototype.getTip;
 /** @type {?} */
Ext.grid.column.IAction.prototype.handler;
 /** @type {string} */
Ext.grid.column.IAction.prototype.icon;
 /** @type {string} */
Ext.grid.column.IAction.prototype.iconCls;
 /** @type {!Array<?>} */
Ext.grid.column.IAction.prototype.items;
 /** @type {string} */
Ext.grid.column.IAction.prototype.menuText;
 /** @type {?} */
Ext.grid.column.IAction.prototype.scope;
 /** @type {boolean} */
Ext.grid.column.IAction.prototype.sortable;
 /** @type {boolean} */
Ext.grid.column.IAction.prototype.stopSelection;
 /** @type {string} */
Ext.grid.column.IAction.prototype.tooltip;

/**
 * [Method] Cascades down the component container heirarchy from this component passed in the first call  calling the specified
 * @param {?=} fn Object
 * @param {?=} scope Object
 * @return {!Ext.IContainer} Ext.Container this
 */
Ext.grid.column.IAction.prototype.cascade = function(fn, scope) {};

/**
 * [Method] Renderer closure iterates through items creating an element for each and tagging with an identifying class name x ac
 * @param {?=} v Object
 * @param {?=} meta Object
 * @param {?=} record Object
 * @param {?=} rowIdx Object
 * @param {?=} colIdx Object
 * @param {?=} store Object
 * @param {?=} view Object
 * @return {void}
 */
Ext.grid.column.IAction.prototype.defaultRenderer = function(v, meta, record, rowIdx, colIdx, store, view) {};

/**
 * [Method] Disables this ActionColumn s action at the specified index
 * @param {?=} index Number/Ext.grid.column.Action
 * @param {boolean=} silent Boolean
 * @return {void}
 */
Ext.grid.column.IAction.prototype.disableAction = function(index, silent) {};

/**
 * [Method] Enables this ActionColumn s action at the specified index
 * @param {?=} index Number/Ext.grid.column.Action
 * @param {boolean=} silent Boolean
 * @return {void}
 */
Ext.grid.column.IAction.prototype.enableAction = function(index, silent) {};

/**
 * [Method] Private override because this cannot function as a Container and it has an items property which is an Array NOT a M
 * @return {void}
 */
Ext.grid.column.IAction.prototype.getRefItems = function() {};
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.grid.IActionColumn = function() {};
 /** @type {string} */
Ext.grid.IActionColumn.prototype.altText;
 /** @type {boolean} */
Ext.grid.IActionColumn.prototype.disabled;
 /** @type {?} */
Ext.grid.IActionColumn.prototype.getClass;
 /** @type {?} */
Ext.grid.IActionColumn.prototype.getTip;
 /** @type {?} */
Ext.grid.IActionColumn.prototype.handler;
 /** @type {string} */
Ext.grid.IActionColumn.prototype.icon;
 /** @type {string} */
Ext.grid.IActionColumn.prototype.iconCls;
 /** @type {!Array<?>} */
Ext.grid.IActionColumn.prototype.items;
 /** @type {string} */
Ext.grid.IActionColumn.prototype.menuText;
 /** @type {?} */
Ext.grid.IActionColumn.prototype.scope;
 /** @type {boolean} */
Ext.grid.IActionColumn.prototype.sortable;
 /** @type {boolean} */
Ext.grid.IActionColumn.prototype.stopSelection;
 /** @type {string} */
Ext.grid.IActionColumn.prototype.tooltip;

/**
 * [Method] Cascades down the component container heirarchy from this component passed in the first call  calling the specified
 * @param {?=} fn Object
 * @param {?=} scope Object
 * @return {!Ext.IContainer} Ext.Container this
 */
Ext.grid.IActionColumn.prototype.cascade = function(fn, scope) {};

/**
 * [Method] Renderer closure iterates through items creating an element for each and tagging with an identifying class name x ac
 * @param {?=} v Object
 * @param {?=} meta Object
 * @param {?=} record Object
 * @param {?=} rowIdx Object
 * @param {?=} colIdx Object
 * @param {?=} store Object
 * @param {?=} view Object
 * @return {void}
 */
Ext.grid.IActionColumn.prototype.defaultRenderer = function(v, meta, record, rowIdx, colIdx, store, view) {};

/**
 * [Method] Disables this ActionColumn s action at the specified index
 * @param {?=} index Number/Ext.grid.column.Action
 * @param {boolean=} silent Boolean
 * @return {void}
 */
Ext.grid.IActionColumn.prototype.disableAction = function(index, silent) {};

/**
 * [Method] Enables this ActionColumn s action at the specified index
 * @param {?=} index Number/Ext.grid.column.Action
 * @param {boolean=} silent Boolean
 * @return {void}
 */
Ext.grid.IActionColumn.prototype.enableAction = function(index, silent) {};

/**
 * [Method] Private override because this cannot function as a Container and it has an items property which is an Array NOT a M
 * @return {void}
 */
Ext.grid.IActionColumn.prototype.getRefItems = function() {};
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.grid.column.IBoolean = function() {};
 /** @type {string} */
Ext.grid.column.IBoolean.prototype.falseText;
 /** @type {string} */
Ext.grid.column.IBoolean.prototype.trueText;
 /** @type {string} */
Ext.grid.column.IBoolean.prototype.undefinedText;
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.grid.IBooleanColumn = function() {};
 /** @type {string} */
Ext.grid.IBooleanColumn.prototype.falseText;
 /** @type {string} */
Ext.grid.IBooleanColumn.prototype.trueText;
 /** @type {string} */
Ext.grid.IBooleanColumn.prototype.undefinedText;
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.grid.column.ICheckColumn = function() {};
 /** @type {boolean} */
Ext.grid.column.ICheckColumn.prototype.stopSelection;
 /** @type {string} */
Ext.grid.column.ICheckColumn.prototype.tdCls;

/**
 * [Method] Disables this CheckColumn
 * @param {boolean=} silent Boolean
 * @return {void}
 */
Ext.grid.column.ICheckColumn.prototype.onDisable = function(silent) {};

/**
 * [Method] Enables this CheckColumn
 * @param {boolean=} silent Boolean
 * @return {void}
 */
Ext.grid.column.ICheckColumn.prototype.onEnable = function(silent) {};
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.ux.ICheckColumn = function() {};
 /** @type {boolean} */
Ext.ux.ICheckColumn.prototype.stopSelection;
 /** @type {string} */
Ext.ux.ICheckColumn.prototype.tdCls;

/**
 * [Method] Disables this CheckColumn
 * @param {boolean=} silent Boolean
 * @return {void}
 */
Ext.ux.ICheckColumn.prototype.onDisable = function(silent) {};

/**
 * [Method] Enables this CheckColumn
 * @param {boolean=} silent Boolean
 * @return {void}
 */
Ext.ux.ICheckColumn.prototype.onEnable = function(silent) {};
/**
 * @extends {Ext.grid.header.IContainer}
 * @record
 * @struct
 */
Ext.grid.column.IColumn = function() {};
 /** @type {string} */
Ext.grid.column.IColumn.prototype.align;
 /** @type {string} */
Ext.grid.column.IColumn.prototype.baseCls;
 /** @type {!Array<?>} */
Ext.grid.column.IColumn.prototype.columns;
 /** @type {?} */
Ext.grid.column.IColumn.prototype.componentLayout;
 /** @type {string} */
Ext.grid.column.IColumn.prototype.dataIndex;
 /** @type {boolean} */
Ext.grid.column.IColumn.prototype.detachOnRemove;
 /** @type {boolean} */
Ext.grid.column.IColumn.prototype.draggable;
 /** @type {?} */
Ext.grid.column.IColumn.prototype.editRenderer;
 /** @type {?} */
Ext.grid.column.IColumn.prototype.editor;
 /** @type {string} */
Ext.grid.column.IColumn.prototype.emptyCellText;
 /** @type {?} */
Ext.grid.column.IColumn.prototype.field;
 /** @type {boolean} */
Ext.grid.column.IColumn.prototype.fixed;
 /** @type {boolean} */
Ext.grid.column.IColumn.prototype.groupable;
 /** @type {string} */
Ext.grid.column.IColumn.prototype.header;
 /** @type {boolean} */
Ext.grid.column.IColumn.prototype.hideable;
 /** @type {boolean} */
Ext.grid.column.IColumn.prototype.lockable;
 /** @type {boolean} */
Ext.grid.column.IColumn.prototype.locked;
 /** @type {boolean} */
Ext.grid.column.IColumn.prototype.menuDisabled;
 /** @type {string} */
Ext.grid.column.IColumn.prototype.menuText;
 /** @type {?} */
Ext.grid.column.IColumn.prototype.renderTpl;
 /** @type {?} */
Ext.grid.column.IColumn.prototype.renderer;
 /** @type {boolean} */
Ext.grid.column.IColumn.prototype.resizable;
 /** @type {?} */
Ext.grid.column.IColumn.prototype.scope;
 /** @type {boolean} */
Ext.grid.column.IColumn.prototype.sortable;
 /** @type {string} */
Ext.grid.column.IColumn.prototype.stateId;
 /** @type {string} */
Ext.grid.column.IColumn.prototype.tdCls;
 /** @type {string} */
Ext.grid.column.IColumn.prototype.text;
 /** @type {string} */
Ext.grid.column.IColumn.prototype.tooltip;
 /** @type {string} */
Ext.grid.column.IColumn.prototype.tooltipType;
 /** @type {boolean} */
Ext.grid.column.IColumn.prototype.isColumn;
 /** @type {boolean} */
Ext.grid.column.IColumn.prototype.isHeader;
 /** @type {!Ext.IElement} */
Ext.grid.column.IColumn.prototype.textEl;
 /** @type {!Ext.IElement} */
Ext.grid.column.IColumn.prototype.triggerEl;

/**
 * [Method] private Inform the header container about the resize
 * @param {?=} width Object
 * @param {?=} height Object
 * @param {?=} oldWidth Object
 * @param {?=} oldHeight Object
 * @return {void}
 */
Ext.grid.column.IColumn.prototype.afterComponentLayout = function(width, height, oldWidth, oldHeight) {};

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.grid.column.IColumn.prototype.afterRender = function() {};

/**
 * [Method] Sizes this Column to fit the max content width
 * @param {?=} The Ext.grid.column.Column/Number header (or index of header) to auto size.
 * @return {void}
 */
Ext.grid.column.IColumn.prototype.autoSize = function(The) {};

/**
 * [Method] When defined this will take precedence over the renderer config
 * @return {void}
 */
Ext.grid.column.IColumn.prototype.defaultRenderer = function() {};

/**
 * [Method] Retrieves the editing field for editing associated with this header
 * @param {?=} record Object The Model instance being edited.
 * @param {?=} defaultField Object An object representing a default field to be created
 * @return {?} any field
 */
Ext.grid.column.IColumn.prototype.getEditor = function(record, defaultField) {};

/**
 * [Method] Returns the index of this column only if this column is a base level Column
 * @return {number} Number
 */
Ext.grid.column.IColumn.prototype.getIndex = function() {};

/**
 * [Method] Returns the parameter to sort upon when sorting this header
 * @return {string} String
 */
Ext.grid.column.IColumn.prototype.getSortParam = function() {};

/**
 * [Method] Returns the index of this column in the list of visible columns only if this column is a base level Column
 * @return {number} Number
 */
Ext.grid.column.IColumn.prototype.getVisibleIndex = function() {};

/**
 * [Method] Hides this Component setting it to invisible using the configured hideMode
 * @param {?=} fromOwner Object
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.grid.column.IColumn.prototype.hide = function(fromOwner) {};

/**
 * [Method] Initialized the renderData to be used when rendering the renderTpl
 * @return {?} Object Object with keys and values that are going to be applied to the renderTpl
 */
Ext.grid.column.IColumn.prototype.initRenderData = function() {};

/**
 * [Method] Determines whether the UI should be allowed to offer an option to hide this column
 * @return {void}
 */
Ext.grid.column.IColumn.prototype.isHideable = function() {};

/**
 * [Method] Determines whether the UI should be allowed to offer an option to lock or unlock this column
 * @return {void}
 */
Ext.grid.column.IColumn.prototype.isLockable = function() {};

/**
 * [Method] Invalidate column cache on add We cannot refresh the View on every add because this method is called when the HeaderD
 * @param {?=} child Object
 * @return {void}
 */
Ext.grid.column.IColumn.prototype.onAdd = function(child) {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.grid.column.IColumn.prototype.onDestroy = function() {};

/**
 * [Method] Invalidate column cache on remove We cannot refresh the View on every remove because this method is called when the H
 * @param {?=} child Object
 * @return {void}
 */
Ext.grid.column.IColumn.prototype.onRemove = function(child) {};

/**
 * [Method] Sets the form field to be used for editing
 * @param {?=} field Object An object representing a field to be created. If no xtype is specified a 'textfield' is assumed.
 * @return {void}
 */
Ext.grid.column.IColumn.prototype.setEditor = function(field) {};

/**
 * [Method] Sets the header text for this Column
 * @param {string=} text String The header to display on this Column.
 * @return {void}
 */
Ext.grid.column.IColumn.prototype.setText = function(text) {};

/**
 * [Method] Shows this Component rendering it first if autoRender or floating are true
 * @param {?=} fromOwner Object
 * @param {?=} fromChild Object
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.grid.column.IColumn.prototype.show = function(fromOwner, fromChild) {};
/**
 * @extends {Ext.grid.header.IContainer}
 * @record
 * @struct
 */
Ext.grid.IColumn = function() {};
 /** @type {string} */
Ext.grid.IColumn.prototype.align;
 /** @type {string} */
Ext.grid.IColumn.prototype.baseCls;
 /** @type {!Array<?>} */
Ext.grid.IColumn.prototype.columns;
 /** @type {?} */
Ext.grid.IColumn.prototype.componentLayout;
 /** @type {string} */
Ext.grid.IColumn.prototype.dataIndex;
 /** @type {boolean} */
Ext.grid.IColumn.prototype.detachOnRemove;
 /** @type {boolean} */
Ext.grid.IColumn.prototype.draggable;
 /** @type {?} */
Ext.grid.IColumn.prototype.editRenderer;
 /** @type {?} */
Ext.grid.IColumn.prototype.editor;
 /** @type {string} */
Ext.grid.IColumn.prototype.emptyCellText;
 /** @type {?} */
Ext.grid.IColumn.prototype.field;
 /** @type {boolean} */
Ext.grid.IColumn.prototype.fixed;
 /** @type {boolean} */
Ext.grid.IColumn.prototype.groupable;
 /** @type {string} */
Ext.grid.IColumn.prototype.header;
 /** @type {boolean} */
Ext.grid.IColumn.prototype.hideable;
 /** @type {boolean} */
Ext.grid.IColumn.prototype.lockable;
 /** @type {boolean} */
Ext.grid.IColumn.prototype.locked;
 /** @type {boolean} */
Ext.grid.IColumn.prototype.menuDisabled;
 /** @type {string} */
Ext.grid.IColumn.prototype.menuText;
 /** @type {?} */
Ext.grid.IColumn.prototype.renderTpl;
 /** @type {?} */
Ext.grid.IColumn.prototype.renderer;
 /** @type {boolean} */
Ext.grid.IColumn.prototype.resizable;
 /** @type {?} */
Ext.grid.IColumn.prototype.scope;
 /** @type {boolean} */
Ext.grid.IColumn.prototype.sortable;
 /** @type {string} */
Ext.grid.IColumn.prototype.stateId;
 /** @type {string} */
Ext.grid.IColumn.prototype.tdCls;
 /** @type {string} */
Ext.grid.IColumn.prototype.text;
 /** @type {string} */
Ext.grid.IColumn.prototype.tooltip;
 /** @type {string} */
Ext.grid.IColumn.prototype.tooltipType;
 /** @type {boolean} */
Ext.grid.IColumn.prototype.isColumn;
 /** @type {boolean} */
Ext.grid.IColumn.prototype.isHeader;
 /** @type {!Ext.IElement} */
Ext.grid.IColumn.prototype.textEl;
 /** @type {!Ext.IElement} */
Ext.grid.IColumn.prototype.triggerEl;

/**
 * [Method] private Inform the header container about the resize
 * @param {?=} width Object
 * @param {?=} height Object
 * @param {?=} oldWidth Object
 * @param {?=} oldHeight Object
 * @return {void}
 */
Ext.grid.IColumn.prototype.afterComponentLayout = function(width, height, oldWidth, oldHeight) {};

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.grid.IColumn.prototype.afterRender = function() {};

/**
 * [Method] Sizes this Column to fit the max content width
 * @param {?=} The Ext.grid.column.Column/Number header (or index of header) to auto size.
 * @return {void}
 */
Ext.grid.IColumn.prototype.autoSize = function(The) {};

/**
 * [Method] When defined this will take precedence over the renderer config
 * @return {void}
 */
Ext.grid.IColumn.prototype.defaultRenderer = function() {};

/**
 * [Method] Retrieves the editing field for editing associated with this header
 * @param {?=} record Object The Model instance being edited.
 * @param {?=} defaultField Object An object representing a default field to be created
 * @return {?} any field
 */
Ext.grid.IColumn.prototype.getEditor = function(record, defaultField) {};

/**
 * [Method] Returns the index of this column only if this column is a base level Column
 * @return {number} Number
 */
Ext.grid.IColumn.prototype.getIndex = function() {};

/**
 * [Method] Returns the parameter to sort upon when sorting this header
 * @return {string} String
 */
Ext.grid.IColumn.prototype.getSortParam = function() {};

/**
 * [Method] Returns the index of this column in the list of visible columns only if this column is a base level Column
 * @return {number} Number
 */
Ext.grid.IColumn.prototype.getVisibleIndex = function() {};

/**
 * [Method] Hides this Component setting it to invisible using the configured hideMode
 * @param {?=} fromOwner Object
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.grid.IColumn.prototype.hide = function(fromOwner) {};

/**
 * [Method] Initialized the renderData to be used when rendering the renderTpl
 * @return {?} Object Object with keys and values that are going to be applied to the renderTpl
 */
Ext.grid.IColumn.prototype.initRenderData = function() {};

/**
 * [Method] Determines whether the UI should be allowed to offer an option to hide this column
 * @return {void}
 */
Ext.grid.IColumn.prototype.isHideable = function() {};

/**
 * [Method] Determines whether the UI should be allowed to offer an option to lock or unlock this column
 * @return {void}
 */
Ext.grid.IColumn.prototype.isLockable = function() {};

/**
 * [Method] Invalidate column cache on add We cannot refresh the View on every add because this method is called when the HeaderD
 * @param {?=} child Object
 * @return {void}
 */
Ext.grid.IColumn.prototype.onAdd = function(child) {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.grid.IColumn.prototype.onDestroy = function() {};

/**
 * [Method] Invalidate column cache on remove We cannot refresh the View on every remove because this method is called when the H
 * @param {?=} child Object
 * @return {void}
 */
Ext.grid.IColumn.prototype.onRemove = function(child) {};

/**
 * [Method] Sets the form field to be used for editing
 * @param {?=} field Object An object representing a field to be created. If no xtype is specified a 'textfield' is assumed.
 * @return {void}
 */
Ext.grid.IColumn.prototype.setEditor = function(field) {};

/**
 * [Method] Sets the header text for this Column
 * @param {string=} text String The header to display on this Column.
 * @return {void}
 */
Ext.grid.IColumn.prototype.setText = function(text) {};

/**
 * [Method] Shows this Component rendering it first if autoRender or floating are true
 * @param {?=} fromOwner Object
 * @param {?=} fromChild Object
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.grid.IColumn.prototype.show = function(fromOwner, fromChild) {};
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.grid.column.IDate = function() {};
 /** @type {string} */
Ext.grid.column.IDate.prototype.format;

/**
 * [Method] When defined this will take precedence over the renderer config
 * @param {?=} value Object
 * @return {void}
 */
Ext.grid.column.IDate.prototype.defaultRenderer = function(value) {};
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.grid.IDateColumn = function() {};
 /** @type {string} */
Ext.grid.IDateColumn.prototype.format;

/**
 * [Method] When defined this will take precedence over the renderer config
 * @param {?=} value Object
 * @return {void}
 */
Ext.grid.IDateColumn.prototype.defaultRenderer = function(value) {};
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.grid.column.INumber = function() {};
 /** @type {string} */
Ext.grid.column.INumber.prototype.format;
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.grid.INumberColumn = function() {};
 /** @type {string} */
Ext.grid.INumberColumn.prototype.format;
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.grid.column.IRowNumberer = function() {};
 /** @type {string} */
Ext.grid.column.IRowNumberer.prototype.align;
 /** @type {string} */
Ext.grid.column.IRowNumberer.prototype.cls;
 /** @type {string} */
Ext.grid.column.IRowNumberer.prototype.dataIndex;
 /** @type {boolean} */
Ext.grid.column.IRowNumberer.prototype.draggable;
 /** @type {boolean} */
Ext.grid.column.IRowNumberer.prototype.hideable;
 /** @type {boolean} */
Ext.grid.column.IRowNumberer.prototype.lockable;
 /** @type {boolean} */
Ext.grid.column.IRowNumberer.prototype.menuDisabled;
 /** @type {boolean} */
Ext.grid.column.IRowNumberer.prototype.resizable;
 /** @type {string} */
Ext.grid.column.IRowNumberer.prototype.tdCls;
 /** @type {string} */
Ext.grid.column.IRowNumberer.prototype.text;
 /** @type {number} */
Ext.grid.column.IRowNumberer.prototype.width;
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.grid.IRowNumberer = function() {};
 /** @type {string} */
Ext.grid.IRowNumberer.prototype.align;
 /** @type {string} */
Ext.grid.IRowNumberer.prototype.cls;
 /** @type {string} */
Ext.grid.IRowNumberer.prototype.dataIndex;
 /** @type {boolean} */
Ext.grid.IRowNumberer.prototype.draggable;
 /** @type {boolean} */
Ext.grid.IRowNumberer.prototype.hideable;
 /** @type {boolean} */
Ext.grid.IRowNumberer.prototype.lockable;
 /** @type {boolean} */
Ext.grid.IRowNumberer.prototype.menuDisabled;
 /** @type {boolean} */
Ext.grid.IRowNumberer.prototype.resizable;
 /** @type {string} */
Ext.grid.IRowNumberer.prototype.tdCls;
 /** @type {string} */
Ext.grid.IRowNumberer.prototype.text;
 /** @type {number} */
Ext.grid.IRowNumberer.prototype.width;
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.grid.column.ITemplate = function() {};
 /** @type {?} */
Ext.grid.column.ITemplate.prototype.tpl;

/**
 * [Method] When defined this will take precedence over the renderer config
 * @param {?=} value Object
 * @param {?=} meta Object
 * @param {?=} record Object
 * @return {void}
 */
Ext.grid.column.ITemplate.prototype.defaultRenderer = function(value, meta, record) {};
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.grid.ITemplateColumn = function() {};
 /** @type {?} */
Ext.grid.ITemplateColumn.prototype.tpl;

/**
 * [Method] When defined this will take precedence over the renderer config
 * @param {?=} value Object
 * @param {?=} meta Object
 * @param {?=} record Object
 * @return {void}
 */
Ext.grid.ITemplateColumn.prototype.defaultRenderer = function(value, meta, record) {};
/**
 * @extends {Ext.layout.component.IAuto}
 * @record
 * @struct
 */
Ext.grid.IColumnComponentLayout = function() {};
 /** @type {boolean} */
Ext.grid.IColumnComponentLayout.prototype.setWidthInDom;

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.grid.IColumnComponentLayout.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.grid.IColumnComponentLayout.prototype.beginLayoutCycle = function(ownerContext) {};
/**
 * @extends {Ext.layout.container.IHBox}
 * @record
 * @struct
 */
Ext.grid.IColumnLayout = function() {};

/**
 * [Method] Collect the height of the table of data upon layout begin
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.grid.IColumnLayout.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.grid.IColumnLayout.prototype.calculate = function(ownerContext) {};

/**
 * [Method] This method if implemented is called at the end of the cycle in which this layout completes by not setting done to
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.grid.IColumnLayout.prototype.completeLayout = function(ownerContext) {};

/**
 * [Method] A one time initialization method called just before rendering
 * @return {void}
 */
Ext.grid.IColumnLayout.prototype.initLayout = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.grid.IColumnManager = function() {};

/**
 * [Method] Get a leaf level header by index regardless of what the nesting structure is
 * @param {number=} index Number The column index for which to retrieve the column.
 * @return {!Ext.grid.column.IColumn} Ext.grid.column.Column The header. null if it doesn't exist.
 */
Ext.grid.IColumnManager.prototype.getHeaderAtIndex = function(index) {};

/**
 * [Method] Get a leaf level header by index regardless of what the nesting structure is
 * @param {string=} id String The id
 * @return {!Ext.grid.column.IColumn} Ext.grid.column.Column The header. null if it doesn't exist.
 */
Ext.grid.IColumnManager.prototype.getHeaderById = function(id) {};

/**
 * [Method] Returns the index of a leaf level header regardless of what the nesting structure is
 * @param {!Ext.grid.column.IColumn=} header Ext.grid.column.Column The header to find the index of
 * @return {number} Number The index of the specified column header
 */
Ext.grid.IColumnManager.prototype.getHeaderIndex = function(header) {};

/**
 * [Method] When passed a column index returns the closet visible column to that
 * @param {number=} index Number Position at which to find the closest visible column.
 * @return {void}
 */
Ext.grid.IColumnManager.prototype.getVisibleHeaderClosestToIndex = function(index) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.grid.IColumnModel = function() {};

/**
 * [Method] Get a leaf level header by index regardless of what the nesting structure is
 * @param {number=} index Number The column index for which to retrieve the column.
 * @return {!Ext.grid.column.IColumn} Ext.grid.column.Column The header. null if it doesn't exist.
 */
Ext.grid.IColumnModel.prototype.getHeaderAtIndex = function(index) {};

/**
 * [Method] Get a leaf level header by index regardless of what the nesting structure is
 * @param {string=} id String The id
 * @return {!Ext.grid.column.IColumn} Ext.grid.column.Column The header. null if it doesn't exist.
 */
Ext.grid.IColumnModel.prototype.getHeaderById = function(id) {};

/**
 * [Method] Returns the index of a leaf level header regardless of what the nesting structure is
 * @param {!Ext.grid.column.IColumn=} header Ext.grid.column.Column The header to find the index of
 * @return {number} Number The index of the specified column header
 */
Ext.grid.IColumnModel.prototype.getHeaderIndex = function(header) {};

/**
 * [Method] When passed a column index returns the closet visible column to that
 * @param {number=} index Number Position at which to find the closest visible column.
 * @return {void}
 */
Ext.grid.IColumnModel.prototype.getVisibleHeaderClosestToIndex = function(index) {};
/** @const */
Ext.grid.feature = {};
/**
 * @extends {Ext.grid.feature.IFeature}
 * @record
 * @struct
 */
Ext.grid.feature.IAbstractSummary = function() {};
 /** @type {string} */
Ext.grid.feature.IAbstractSummary.prototype.remoteRoot;
 /** @type {boolean} */
Ext.grid.feature.IAbstractSummary.prototype.showSummaryRow;

/**
 * [Method] Toggle whether or not to show the summary row
 * @param {boolean=} visible Boolean True to show the summary row
 * @return {void}
 */
Ext.grid.feature.IAbstractSummary.prototype.toggleSummaryRow = function(visible) {};
/**
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.grid.feature.IFeature = function() {};
 /** @type {boolean} */
Ext.grid.feature.IFeature.prototype.disabled;
 /** @type {string} */
Ext.grid.feature.IFeature.prototype.eventPrefix;
 /** @type {string} */
Ext.grid.feature.IFeature.prototype.eventSelector;
 /** @type {!Ext.grid.IPanel} */
Ext.grid.feature.IFeature.prototype.grid;
 /** @type {boolean} */
Ext.grid.feature.IFeature.prototype.hasFeatureEvent;
 /** @type {!Ext.view.ITable} */
Ext.grid.feature.IFeature.prototype.view;

/**
 * [Method] Disables the feature
 * @return {void}
 */
Ext.grid.feature.IFeature.prototype.disable = function() {};

/**
 * [Method] Enables the feature
 * @return {void}
 */
Ext.grid.feature.IFeature.prototype.enable = function() {};

/**
 * [Method] Abstract method to be overriden when a feature should add additional arguments to its event signature
 * @param {?=} eventName Object
 * @param {?=} view Object
 * @param {?=} featureTarget Object
 * @param {?=} e Object
 * @return {void}
 */
Ext.grid.feature.IFeature.prototype.getFireEventArgs = function(eventName, view, featureTarget, e) {};
/**
 * @extends {Ext.grid.feature.IFeature}
 * @extends {Ext.grid.feature.IAbstractSummary}
 * @record
 * @struct
 */
Ext.grid.feature.IGrouping = function() {};
 /** @type {boolean} */
Ext.grid.feature.IGrouping.prototype.collapsible;
 /** @type {number} */
Ext.grid.feature.IGrouping.prototype.depthToIndent;
 /** @type {boolean} */
Ext.grid.feature.IGrouping.prototype.enableGroupingMenu;
 /** @type {boolean} */
Ext.grid.feature.IGrouping.prototype.enableNoGroups;
 /** @type {string} */
Ext.grid.feature.IGrouping.prototype.groupByText;
 /** @type {?} */
Ext.grid.feature.IGrouping.prototype.groupHeaderTpl;
 /** @type {boolean} */
Ext.grid.feature.IGrouping.prototype.hideGroupedHeader;
 /** @type {string} */
Ext.grid.feature.IGrouping.prototype.showGroupsText;
 /** @type {boolean} */
Ext.grid.feature.IGrouping.prototype.showSummaryRow;
 /** @type {boolean} */
Ext.grid.feature.IGrouping.prototype.startCollapsed;
 /** @type {string} */
Ext.grid.feature.IGrouping.prototype.eventPrefix;
 /** @type {string} */
Ext.grid.feature.IGrouping.prototype.eventSelector;

/**
 * [Method] Collapse a group
 * @param {string=} groupName String The group name
 * @param {boolean=} focus Boolean Pass true to focus the group after expand.
 * @return {void}
 */
Ext.grid.feature.IGrouping.prototype.collapse = function(groupName, focus) {};

/**
 * [Method] Collapse all groups
 * @return {void}
 */
Ext.grid.feature.IGrouping.prototype.collapseAll = function() {};

/**
 * [Method] Disables the feature
 * @return {void}
 */
Ext.grid.feature.IGrouping.prototype.disable = function() {};

/**
 * [Method] Enables the feature
 * @return {void}
 */
Ext.grid.feature.IGrouping.prototype.enable = function() {};

/**
 * [Method] Expand a group
 * @param {string=} groupName String The group name
 * @param {boolean=} focus Boolean Pass true to focus the group after expand.
 * @return {void}
 */
Ext.grid.feature.IGrouping.prototype.expand = function(groupName, focus) {};

/**
 * [Method] Expand all groups
 * @return {void}
 */
Ext.grid.feature.IGrouping.prototype.expandAll = function() {};

/**
 * [Method] Abstract method to be overriden when a feature should add additional arguments to its event signature
 * @param {?=} type Object
 * @param {?=} view Object
 * @param {?=} targetEl Object
 * @param {?=} e Object
 * @return {void}
 */
Ext.grid.feature.IGrouping.prototype.getFireEventArgs = function(type, view, targetEl, e) {};

/**
 * [Method] Returns the group data object for the group to which the passed record belongs if the Store is grouped
 * @param {!Ext.data.IModel=} record Ext.data.Model The record for which to return group information.
 * @return {?} Object A single group data block as returned from Store.getGroups. Returns undefined if the Store is not grouped.
 */
Ext.grid.feature.IGrouping.prototype.getRecordGroup = function(record) {};

/**
 * [Method] Returns true if the named group is expanded
 * @param {string=} groupName String The group name as returned from getGroupString. This is usually the value of the groupField.
 * @return {boolean} Boolean true if the group defined by that value is expanded.
 */
Ext.grid.feature.IGrouping.prototype.isExpanded = function(groupName) {};

/**
 * [Method] Toggle whether or not to show the summary row
 * @param {boolean=} visible Boolean True to show the summary row
 * @return {void}
 */
Ext.grid.feature.IGrouping.prototype.toggleSummaryRow = function(visible) {};
/**
 * @extends {Ext.grid.feature.IGrouping}
 * @record
 * @struct
 */
Ext.grid.feature.IGroupingSummary = function() {};
 /** @type {boolean} */
Ext.grid.feature.IGroupingSummary.prototype.showSummaryRow;
/**
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.grid.feature.IGroupStore = function() {};

/**
 * [Method] Get the index within the entire dataset
 * @param {!Ext.data.IModel=} record Ext.data.Model The Ext.data.Model object to find.
 * @return {number} Number The index of the passed Record. Returns -1 if not found.
 */
Ext.grid.feature.IGroupStore.prototype.indexOfTotal = function(record) {};
/**
 * @extends {Ext.grid.feature.IFeature}
 * @record
 * @struct
 */
Ext.grid.feature.IRowBody = function() {};
 /** @type {string} */
Ext.grid.feature.IRowBody.prototype.eventPrefix;
 /** @type {string} */
Ext.grid.feature.IRowBody.prototype.eventSelector;

/**
 * [Method] Provides additional data to the prepareData call within the grid view
 * @param {?=} data Object The data for this particular record.
 * @param {number=} idx Number The row index for this record.
 * @param {!Ext.data.IModel=} record Ext.data.Model The record instance
 * @param {?=} orig Object The original result from the prepareData call to massage.
 * @return {void}
 */
Ext.grid.feature.IRowBody.prototype.getAdditionalData = function(data, idx, record, orig) {};
/**
 * @extends {Ext.grid.feature.IFeature}
 * @record
 * @struct
 */
Ext.grid.feature.IRowWrap = function() {};
 /** @type {boolean} */
Ext.grid.feature.IRowWrap.prototype.hasFeatureEvent;
/**
 * @extends {Ext.grid.feature.IAbstractSummary}
 * @record
 * @struct
 */
Ext.grid.feature.ISummary = function() {};
 /** @type {string} */
Ext.grid.feature.ISummary.prototype.dock;
/** @const */
Ext.grid.header = {};
/**
 * @extends {Ext.container.IContainer}
 * @record
 * @struct
 */
Ext.grid.header.IContainer = function() {};
 /** @type {string} */
Ext.grid.header.IContainer.prototype.baseCls;
 /** @type {?} */
Ext.grid.header.IContainer.prototype.border;
 /** @type {string} */
Ext.grid.header.IContainer.prototype.defaultType;
 /** @type {number} */
Ext.grid.header.IContainer.prototype.defaultWidth;
 /** @type {boolean} */
Ext.grid.header.IContainer.prototype.detachOnRemove;
 /** @type {boolean} */
Ext.grid.header.IContainer.prototype.enableColumnHide;
 /** @type {boolean} */
Ext.grid.header.IContainer.prototype.sealed;
 /** @type {boolean} */
Ext.grid.header.IContainer.prototype.sortable;
 /** @type {number} */
Ext.grid.header.IContainer.prototype.weight;
 /** @type {boolean} */
Ext.grid.header.IContainer.prototype.isGroupHeader;

/**
 * [Method] Returns the number of grid columns descended from this HeaderContainer
 * @return {void}
 */
Ext.grid.header.IContainer.prototype.getColumnCount = function() {};

/**
 * [Method] Returns an array of menu CheckItems corresponding to all immediate children of the passed Container which have been c
 * @param {?=} headerContainer Object
 * @return {void}
 */
Ext.grid.header.IContainer.prototype.getColumnMenu = function(headerContainer) {};

/**
 * [Method] Gets the full width of all columns that are visible
 * @return {void}
 */
Ext.grid.header.IContainer.prototype.getFullWidth = function() {};

/**
 * [Method] Returns an array of all columns which appear in the grid s View
 * @param {?=} inResult Object
 * @param {?=} hiddenAncestor Object
 * @return {!Array<?>} Array
 */
Ext.grid.header.IContainer.prototype.getGridColumns = function(inResult, hiddenAncestor) {};

/**
 * [Method] Get a leaf level header by index regardless of what the nesting structure is
 * @param {number=} index Number The column index for which to retrieve the column.
 * @return {void}
 */
Ext.grid.header.IContainer.prototype.getHeaderAtIndex = function(index) {};

/**
 * [Method] Returns the index of a leaf level header regardless of what the nesting structure is
 * @param {!Ext.grid.column.IColumn=} header Ext.grid.column.Column The header to find the index of
 * @return {number} Number The index of the specified column header
 */
Ext.grid.header.IContainer.prototype.getHeaderIndex = function(header) {};

/**
 * [Method] Returns an array of menu items to be placed into the shared menu across all headers in this header container
 * @return {!Array<?>} Array menuItems
 */
Ext.grid.header.IContainer.prototype.getMenuItems = function() {};

/**
 * [Method] Returns an array of the visible columns in the grid
 * @return {!Array<?>} Array
 */
Ext.grid.header.IContainer.prototype.getVisibleGridColumns = function() {};

/**
 * [Method] When passed a column index returns the closet visible column to that
 * @param {number=} index Number Position at which to find the closest visible column.
 * @return {void}
 */
Ext.grid.header.IContainer.prototype.getVisibleHeaderClosestToIndex = function(index) {};

/**
 * [Method] Determines whether this Component is the root of a layout
 * @return {void}
 */
Ext.grid.header.IContainer.prototype.isLayoutRoot = function() {};

/**
 * [Method] Invalidate column cache on add We cannot refresh the View on every add because this method is called when the HeaderD
 * @param {?=} c Object
 * @return {void}
 */
Ext.grid.header.IContainer.prototype.onAdd = function(c) {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.grid.header.IContainer.prototype.onDestroy = function() {};

/**
 * [Method] Invalidate column cache on remove We cannot refresh the View on every remove because this method is called when the H
 * @param {?=} c Object
 * @return {void}
 */
Ext.grid.header.IContainer.prototype.onRemove = function(c) {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.grid.header.IContainer.prototype.onShow = function() {};
/**
 * @extends {Ext.dd.IDragZone}
 * @record
 * @struct
 */
Ext.grid.header.IDragZone = function() {};

/**
 * [Method] Called when a mousedown occurs in this container
 * @param {?=} e Object
 * @return {?} Object The dragData
 */
Ext.grid.header.IDragZone.prototype.getDragData = function(e) {};

/**
 * [Method] Called before a repair of an invalid drop to get the XY to animate to
 * @return {!Array<number>} Number[] The xy location (e.g. [100, 200])
 */
Ext.grid.header.IDragZone.prototype.getRepairXY = function() {};

/**
 * [Method] An empty function by default but provided so that you can perform a custom action before the initial drag event begi
 * @return {boolean} Boolean isValid True if the drag event is valid, else false to cancel
 */
Ext.grid.header.IDragZone.prototype.onBeforeDrag = function() {};

/**
 * [Method] Called once drag threshold has been reached to initialize the proxy element
 * @return {boolean} Boolean true to continue the drag, false to cancel
 */
Ext.grid.header.IDragZone.prototype.onInitDrag = function() {};
/**
 * @extends {Ext.dd.IDropZone}
 * @record
 * @struct
 */
Ext.grid.header.IDropZone = function() {};

/**
 * [Method] Returns a custom data object associated with the DOM node that is the target of the event
 * @param {?=} e Object
 * @return {?} Object data The custom data
 */
Ext.grid.header.IDropZone.prototype.getTargetFromEvent = function(e) {};

/**
 * [Method] Called when the DropZone determines that a Ext dd DragSource has been dropped onto the drop node
 * @param {?=} node Object
 * @param {?=} dragZone Object
 * @param {?=} e Object
 * @param {?=} data Object
 * @return {boolean} Boolean True if the drop was valid, else false
 */
Ext.grid.header.IDropZone.prototype.onNodeDrop = function(node, dragZone, e, data) {};

/**
 * [Method] Called when the DropZone determines that a Ext dd DragSource has been dragged out of the drop node without dropping
 * @return {void}
 */
Ext.grid.header.IDropZone.prototype.onNodeOut = function() {};

/**
 * [Method] Called while the DropZone determines that a Ext dd DragSource is over a drop node that has either been registered or
 * @param {?=} node Object
 * @param {?=} dragZone Object
 * @param {?=} e Object
 * @param {?=} data Object
 * @return {string} String status The CSS class that communicates the drop status back to the source so that the underlying Ext.dd.StatusProxy can be updated
 */
Ext.grid.header.IDropZone.prototype.onNodeOver = function(node, dragZone, e, data) {};
/** @const */
Ext.grid.locking = {};
/**
 * @extends {Ext.grid.header.IContainer}
 * @record
 * @struct
 */
Ext.grid.locking.IHeaderContainer = function() {};

/**
 * [Method] This is the function which all other column access methods are based upon Return the full column set for the whole Lo
 * @return {!Array<?>} Array
 */
Ext.grid.locking.IHeaderContainer.prototype.getGridColumns = function() {};

/**
 * [Method] Used by ComponentQuery child and down to retrieve all of the items which can potentially be considered a child of th
 * @return {void}
 */
Ext.grid.locking.IHeaderContainer.prototype.getRefItems = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.grid.locking.ILockable = function() {};
 /** @type {?} */
Ext.grid.locking.ILockable.prototype.lockedGridConfig;
 /** @type {?} */
Ext.grid.locking.ILockable.prototype.lockedViewConfig;
 /** @type {?} */
Ext.grid.locking.ILockable.prototype.normalGridConfig;
 /** @type {?} */
Ext.grid.locking.ILockable.prototype.normalViewConfig;
 /** @type {number} */
Ext.grid.locking.ILockable.prototype.scrollDelta;
 /** @type {string} */
Ext.grid.locking.ILockable.prototype.subGridXType;
 /** @type {boolean} */
Ext.grid.locking.ILockable.prototype.syncRowHeight;

/**
 * [Method] Synchronizes the row heights between the locked and non locked portion of the grid for each row
 * @return {void}
 */
Ext.grid.locking.ILockable.prototype.syncRowHeights = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.grid.ILockable = function() {};
 /** @type {?} */
Ext.grid.ILockable.prototype.lockedGridConfig;
 /** @type {?} */
Ext.grid.ILockable.prototype.lockedViewConfig;
 /** @type {?} */
Ext.grid.ILockable.prototype.normalGridConfig;
 /** @type {?} */
Ext.grid.ILockable.prototype.normalViewConfig;
 /** @type {number} */
Ext.grid.ILockable.prototype.scrollDelta;
 /** @type {string} */
Ext.grid.ILockable.prototype.subGridXType;
 /** @type {boolean} */
Ext.grid.ILockable.prototype.syncRowHeight;

/**
 * [Method] Synchronizes the row heights between the locked and non locked portion of the grid for each row
 * @return {void}
 */
Ext.grid.ILockable.prototype.syncRowHeights = function() {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.grid.locking.IView = function() {};
 /** @type {boolean} */
Ext.grid.locking.IView.prototype.isLockingView;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.grid.locking.IView.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.grid.locking.IView.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.grid.locking.IView.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.grid.locking.IView.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.grid.locking.IView.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.grid.locking.IView.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.grid.locking.IView.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.grid.locking.IView.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.grid.locking.IView.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.grid.locking.IView.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.grid.locking.IView.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.grid.locking.IView.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.grid.locking.IView.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.grid.locking.IView.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.grid.locking.IView.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.grid.locking.IView.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.grid.locking.IView.prototype.resumeEvents = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.grid.locking.IView.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.grid.locking.IView.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.grid.locking.IView.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.grid.ILockingView = function() {};
 /** @type {boolean} */
Ext.grid.ILockingView.prototype.isLockingView;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.grid.ILockingView.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.grid.ILockingView.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.grid.ILockingView.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.grid.ILockingView.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.grid.ILockingView.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.grid.ILockingView.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.grid.ILockingView.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.grid.ILockingView.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.grid.ILockingView.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.grid.ILockingView.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.grid.ILockingView.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.grid.ILockingView.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.grid.ILockingView.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.grid.ILockingView.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.grid.ILockingView.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.grid.ILockingView.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.grid.ILockingView.prototype.resumeEvents = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.grid.ILockingView.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.grid.ILockingView.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.grid.ILockingView.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.panel.ITable}
 * @record
 * @struct
 */
Ext.grid.IPanel = function() {};
 /** @type {?} */
Ext.grid.IPanel.prototype.columns;
 /** @type {boolean} */
Ext.grid.IPanel.prototype.rowLines;
 /** @type {string} */
Ext.grid.IPanel.prototype.viewType;

/**
 * [Method] Reconfigures the grid with a new store columns
 * @param {!Ext.data.IStore=} store Ext.data.Store The new store.
 * @param {!Array<?>=} columns Object[] An array of column configs
 * @return {void}
 */
Ext.grid.IPanel.prototype.reconfigure = function(store, columns) {};
/** @const */
Ext.list = {};
/**
 * @extends {Ext.panel.ITable}
 * @record
 * @struct
 */
Ext.list.IListView = function() {};
 /** @type {?} */
Ext.list.IListView.prototype.columns;
 /** @type {boolean} */
Ext.list.IListView.prototype.rowLines;
 /** @type {string} */
Ext.list.IListView.prototype.viewType;

/**
 * [Method] Reconfigures the grid with a new store columns
 * @param {!Ext.data.IStore=} store Ext.data.Store The new store.
 * @param {!Array<?>=} columns Object[] An array of column configs
 * @return {void}
 */
Ext.list.IListView.prototype.reconfigure = function(store, columns) {};
/**
 * @extends {Ext.panel.ITable}
 * @record
 * @struct
 */
Ext.IListView = function() {};
 /** @type {?} */
Ext.IListView.prototype.columns;
 /** @type {boolean} */
Ext.IListView.prototype.rowLines;
 /** @type {string} */
Ext.IListView.prototype.viewType;

/**
 * [Method] Reconfigures the grid with a new store columns
 * @param {!Ext.data.IStore=} store Ext.data.Store The new store.
 * @param {!Array<?>=} columns Object[] An array of column configs
 * @return {void}
 */
Ext.IListView.prototype.reconfigure = function(store, columns) {};
/**
 * @extends {Ext.panel.ITable}
 * @record
 * @struct
 */
Ext.grid.IGridPanel = function() {};
 /** @type {?} */
Ext.grid.IGridPanel.prototype.columns;
 /** @type {boolean} */
Ext.grid.IGridPanel.prototype.rowLines;
 /** @type {string} */
Ext.grid.IGridPanel.prototype.viewType;

/**
 * [Method] Reconfigures the grid with a new store columns
 * @param {!Ext.data.IStore=} store Ext.data.Store The new store.
 * @param {!Array<?>=} columns Object[] An array of column configs
 * @return {void}
 */
Ext.grid.IGridPanel.prototype.reconfigure = function(store, columns) {};
/** @const */
Ext.grid.plugin = {};
/**
 * @extends {Ext.IAbstractPlugin}
 * @record
 * @struct
 */
Ext.grid.plugin.IBufferedRenderer = function() {};
 /** @type {number} */
Ext.grid.plugin.IBufferedRenderer.prototype.leadingBufferZone;
 /** @type {number} */
Ext.grid.plugin.IBufferedRenderer.prototype.numFromEdge;
 /** @type {number} */
Ext.grid.plugin.IBufferedRenderer.prototype.percentageFromEdge;
 /** @type {number} */
Ext.grid.plugin.IBufferedRenderer.prototype.scrollToLoadBuffer;
 /** @type {boolean} */
Ext.grid.plugin.IBufferedRenderer.prototype.synchronousRender;
 /** @type {number} */
Ext.grid.plugin.IBufferedRenderer.prototype.trailingBufferZone;
 /** @type {boolean} */
Ext.grid.plugin.IBufferedRenderer.prototype.variableRowHeight;
 /** @type {number} */
Ext.grid.plugin.IBufferedRenderer.prototype.position;

/**
 * [Method] The destroy method is invoked by the owning Component at the time the Component is being destroyed
 * @return {void}
 */
Ext.grid.plugin.IBufferedRenderer.prototype.destroy = function() {};

/**
 * [Method] Initialize this as a plugin
 * @param {?=} grid Object
 * @return {void}
 */
Ext.grid.plugin.IBufferedRenderer.prototype.init = function(grid) {};

/**
 * [Method] Scrolls to and optionlly selects the specified row index in the total dataset
 * @param {number=} recordIdx Number The zero-based position in the dataset to scroll to.
 * @param {boolean=} doSelect Boolean Pass as true to select the specified row.
 * @param {?=} callback Function A function to call when the row has been scrolled to.
 * @param {?=} scope Object The scope (this reference) in which to execute the callback. Defaults to this BufferedRenderer.
 * @return {void}
 */
Ext.grid.plugin.IBufferedRenderer.prototype.scrollTo = function(recordIdx, doSelect, callback, scope) {};
/**
 * @extends {Ext.grid.plugin.IEditing}
 * @record
 * @struct
 */
Ext.grid.plugin.ICellEditing = function() {};

/**
 * [Method] Cancels any active editing
 * @return {void}
 */
Ext.grid.plugin.ICellEditing.prototype.cancelEdit = function() {};

/**
 * [Method] Completes the edit if there is an active edit in progress
 * @return {void}
 */
Ext.grid.plugin.ICellEditing.prototype.completeEdit = function() {};

/**
 * [Method] Starts editing the specified record using the specified Column definition to define which field is being edited
 * @param {?=} record Ext.data.Model/Number The Store data record which backs the row to be edited, or index of the record.
 * @param {?=} columnHeader Ext.grid.column.Column/Number The Column object defining the column to be edited, or index of the column.
 * @return {boolean} Boolean true if editing was started, false otherwise.
 */
Ext.grid.plugin.ICellEditing.prototype.startEdit = function(record, columnHeader) {};

/**
 * [Method] Starts editing by position row column
 * @param {?=} position Object A position with keys of row and column.
 * @return {void}
 */
Ext.grid.plugin.ICellEditing.prototype.startEditByPosition = function(position) {};
/**
 * @extends {Ext.IAbstractPlugin}
 * @record
 * @struct
 */
Ext.grid.plugin.IDragDrop = function() {};
 /** @type {?} */
Ext.grid.plugin.IDragDrop.prototype.containerScroll;
 /** @type {string} */
Ext.grid.plugin.IDragDrop.prototype.ddGroup;
 /** @type {string} */
Ext.grid.plugin.IDragDrop.prototype.dragGroup;
 /** @type {string} */
Ext.grid.plugin.IDragDrop.prototype.dragText;
 /** @type {string} */
Ext.grid.plugin.IDragDrop.prototype.dropGroup;
 /** @type {boolean} */
Ext.grid.plugin.IDragDrop.prototype.enableDrag;
 /** @type {boolean} */
Ext.grid.plugin.IDragDrop.prototype.enableDrop;

/**
 * [Method] The base implementation just sets the plugin s disabled flag to true Plugin subclasses which need more complex proce
 * @return {void}
 */
Ext.grid.plugin.IDragDrop.prototype.disable = function() {};

/**
 * [Method] The base implementation just sets the plugin s disabled flag to false Plugin subclasses which need more complex proc
 * @return {void}
 */
Ext.grid.plugin.IDragDrop.prototype.enable = function() {};

/**
 * [Method] The init method is invoked after initComponent method has been run for the client Component
 * @param {?=} view Object
 * @return {void}
 */
Ext.grid.plugin.IDragDrop.prototype.init = function(view) {};
/**
 * @extends {Ext.IAbstractPlugin}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.grid.plugin.IEditing = function() {};
 /** @type {number} */
Ext.grid.plugin.IEditing.prototype.clicksToEdit;
 /** @type {string} */
Ext.grid.plugin.IEditing.prototype.triggerEvent;
 /** @type {boolean} */
Ext.grid.plugin.IEditing.prototype.editing;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.grid.plugin.IEditing.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.grid.plugin.IEditing.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Cancels any active edit that is in progress
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.cancelEdit = function() {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.clearManagedListeners = function() {};

/**
 * [Method] Completes the edit if there is an active edit in progress
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.completeEdit = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.grid.plugin.IEditing.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.grid.plugin.IEditing.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.grid.plugin.IEditing.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.grid.plugin.IEditing.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.grid.plugin.IEditing.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.grid.plugin.IEditing.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.resumeEvents = function() {};

/**
 * [Method] Starts editing the specified record using the specified Column definition to define which field is being edited
 * @param {?=} record Ext.data.Model/Number The Store data record which backs the row to be edited, or index of the record in Store.
 * @param {?=} columnHeader Ext.grid.column.Column/Number The Column object defining the column to be edited, or index of the column.
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.startEdit = function(record, columnHeader) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.grid.plugin.IEditing.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.IAbstractPlugin}
 * @record
 * @struct
 */
Ext.grid.plugin.IHeaderReorderer = function() {};

/**
 * [Method] The base implementation just sets the plugin s disabled flag to true Plugin subclasses which need more complex proce
 * @return {void}
 */
Ext.grid.plugin.IHeaderReorderer.prototype.disable = function() {};

/**
 * [Method] The base implementation just sets the plugin s disabled flag to false Plugin subclasses which need more complex proc
 * @return {void}
 */
Ext.grid.plugin.IHeaderReorderer.prototype.enable = function() {};

/**
 * [Method] The init method is invoked after initComponent method has been run for the client Component
 * @param {?=} headerCt Object
 * @return {void}
 */
Ext.grid.plugin.IHeaderReorderer.prototype.init = function(headerCt) {};
/**
 * @extends {Ext.IAbstractPlugin}
 * @record
 * @struct
 */
Ext.grid.plugin.IHeaderResizer = function() {};
 /** @type {boolean} */
Ext.grid.plugin.IHeaderResizer.prototype.dynamic;

/**
 * [Method] The base implementation just sets the plugin s disabled flag to true Plugin subclasses which need more complex proce
 * @return {void}
 */
Ext.grid.plugin.IHeaderResizer.prototype.disable = function() {};

/**
 * [Method] The base implementation just sets the plugin s disabled flag to false Plugin subclasses which need more complex proc
 * @return {void}
 */
Ext.grid.plugin.IHeaderResizer.prototype.enable = function() {};

/**
 * [Method] Returns the value of dynamic
 * @return {boolean} Boolean
 */
Ext.grid.plugin.IHeaderResizer.prototype.getDynamic = function() {};

/**
 * [Method] not using w and e resize bc we are only ever resizing one column wResizeCursor Ext isWebKit w resize  col resi
 * @param {?=} headerCt Object
 * @return {void}
 */
Ext.grid.plugin.IHeaderResizer.prototype.init = function(headerCt) {};

/**
 * [Method] Sets the value of dynamic
 * @param {boolean=} dynamic Boolean
 * @return {void}
 */
Ext.grid.plugin.IHeaderResizer.prototype.setDynamic = function(dynamic) {};
/**
 * @extends {Ext.grid.plugin.IEditing}
 * @record
 * @struct
 */
Ext.grid.plugin.IRowEditing = function() {};
 /** @type {boolean} */
Ext.grid.plugin.IRowEditing.prototype.autoCancel;
 /** @type {number} */
Ext.grid.plugin.IRowEditing.prototype.clicksToMoveEditor;
 /** @type {boolean} */
Ext.grid.plugin.IRowEditing.prototype.errorSummary;

/**
 * [Method] Starts editing the specified record using the specified Column definition to define which field is being edited
 * @param {!Ext.data.IModel=} record Ext.data.Model The Store data record which backs the row to be edited.
 * @param {!Ext.data.IModel=} columnHeader Ext.data.Model The Column object defining the column to be edited.
 * @return {boolean} Boolean true if editing was started, false otherwise.
 */
Ext.grid.plugin.IRowEditing.prototype.startEdit = function(record, columnHeader) {};
/**
 * @extends {Ext.IAbstractPlugin}
 * @record
 * @struct
 */
Ext.grid.plugin.IRowExpander = function() {};
 /** @type {boolean} */
Ext.grid.plugin.IRowExpander.prototype.expandOnDblClick;
 /** @type {boolean} */
Ext.grid.plugin.IRowExpander.prototype.expandOnEnter;
 /** @type {boolean} */
Ext.grid.plugin.IRowExpander.prototype.selectRowOnExpand;

/**
 * [Method] The init method is invoked after initComponent method has been run for the client Component
 * @param {?=} grid Object
 * @return {void}
 */
Ext.grid.plugin.IRowExpander.prototype.init = function(grid) {};
/** @const */
Ext.grid.property = {};
/**
 * @extends {Ext.grid.IPanel}
 * @record
 * @struct
 */
Ext.grid.property.IGrid = function() {};
 /** @type {boolean} */
Ext.grid.property.IGrid.prototype.columnLines;
 /** @type {?} */
Ext.grid.property.IGrid.prototype.customEditors;
 /** @type {?} */
Ext.grid.property.IGrid.prototype.customRenderers;
 /** @type {boolean} */
Ext.grid.property.IGrid.prototype.enableColumnMove;
 /** @type {boolean} */
Ext.grid.property.IGrid.prototype.inferTypes;
 /** @type {?} */
Ext.grid.property.IGrid.prototype.nameColumnWidth;
 /** @type {string} */
Ext.grid.property.IGrid.prototype.nameField;
 /** @type {?} */
Ext.grid.property.IGrid.prototype.propertyNames;
 /** @type {?} */
Ext.grid.property.IGrid.prototype.source;
 /** @type {?} */
Ext.grid.property.IGrid.prototype.sourceConfig;
 /** @type {string} */
Ext.grid.property.IGrid.prototype.valueField;

/**
 * [Method] Gets the source data object containing the property data
 * @return {?} Object The data object.
 */
Ext.grid.property.IGrid.prototype.getSource = function() {};

/**
 * [Method] Removes a property from the grid
 * @param {string=} prop String The name of the property to remove.
 * @return {void}
 */
Ext.grid.property.IGrid.prototype.removeProperty = function(prop) {};

/**
 * [Method] Sets the value of a property
 * @param {string=} prop String The name of the property to set.
 * @param {?=} value Object The value to test.
 * @param {boolean=} create Boolean true to create the property if it doesn't already exist.
 * @return {void}
 */
Ext.grid.property.IGrid.prototype.setProperty = function(prop, value, create) {};

/**
 * [Method] Sets the source data object containing the property data
 * @param {?=} source Object The data object.
 * @param {?=} sourceConfig Object A new object. If this argument is not passed the current configuration will be re-used. To reset the config, pass null or an empty object literal.
 * @return {void}
 */
Ext.grid.property.IGrid.prototype.setSource = function(source, sourceConfig) {};
/**
 * @extends {Ext.grid.IPanel}
 * @record
 * @struct
 */
Ext.grid.IPropertyGrid = function() {};
 /** @type {boolean} */
Ext.grid.IPropertyGrid.prototype.columnLines;
 /** @type {?} */
Ext.grid.IPropertyGrid.prototype.customEditors;
 /** @type {?} */
Ext.grid.IPropertyGrid.prototype.customRenderers;
 /** @type {boolean} */
Ext.grid.IPropertyGrid.prototype.enableColumnMove;
 /** @type {boolean} */
Ext.grid.IPropertyGrid.prototype.inferTypes;
 /** @type {?} */
Ext.grid.IPropertyGrid.prototype.nameColumnWidth;
 /** @type {string} */
Ext.grid.IPropertyGrid.prototype.nameField;
 /** @type {?} */
Ext.grid.IPropertyGrid.prototype.propertyNames;
 /** @type {?} */
Ext.grid.IPropertyGrid.prototype.source;
 /** @type {?} */
Ext.grid.IPropertyGrid.prototype.sourceConfig;
 /** @type {string} */
Ext.grid.IPropertyGrid.prototype.valueField;

/**
 * [Method] Gets the source data object containing the property data
 * @return {?} Object The data object.
 */
Ext.grid.IPropertyGrid.prototype.getSource = function() {};

/**
 * [Method] Removes a property from the grid
 * @param {string=} prop String The name of the property to remove.
 * @return {void}
 */
Ext.grid.IPropertyGrid.prototype.removeProperty = function(prop) {};

/**
 * [Method] Sets the value of a property
 * @param {string=} prop String The name of the property to set.
 * @param {?=} value Object The value to test.
 * @param {boolean=} create Boolean true to create the property if it doesn't already exist.
 * @return {void}
 */
Ext.grid.IPropertyGrid.prototype.setProperty = function(prop, value, create) {};

/**
 * [Method] Sets the source data object containing the property data
 * @param {?=} source Object The data object.
 * @param {?=} sourceConfig Object A new object. If this argument is not passed the current configuration will be re-used. To reset the config, pass null or an empty object literal.
 * @return {void}
 */
Ext.grid.IPropertyGrid.prototype.setSource = function(source, sourceConfig) {};
/**
 * @extends {Ext.grid.header.IContainer}
 * @record
 * @struct
 */
Ext.grid.property.IHeaderContainer = function() {};
/**
 * @extends {Ext.grid.header.IContainer}
 * @record
 * @struct
 */
Ext.grid.IPropertyColumnModel = function() {};
/**
 * @extends {Ext.data.IModel}
 * @record
 * @struct
 */
Ext.grid.property.IProperty = function() {};
 /** @type {?} */
Ext.grid.property.IProperty.prototype.idProperty;
 /** @type {!Ext.util.IMixedCollection} */
Ext.grid.property.IProperty.prototype.fields;
/**
 * @extends {Ext.data.IModel}
 * @record
 * @struct
 */
Ext.IPropGridProperty = function() {};
 /** @type {?} */
Ext.IPropGridProperty.prototype.idProperty;
 /** @type {!Ext.util.IMixedCollection} */
Ext.IPropGridProperty.prototype.fields;
/**
 * @extends {Ext.data.IStore}
 * @record
 * @struct
 */
Ext.grid.property.IStore = function() {};
 /** @type {boolean} */
Ext.grid.property.IStore.prototype.sortOnLoad;

/**
 * [Method] Return a singleton customized Proxy object which configures itself with a custom Reader
 * @return {!Ext.data.proxy.IProxy} Ext.data.proxy.Proxy The Proxy instance
 */
Ext.grid.property.IStore.prototype.getProxy = function() {};
/**
 * @extends {Ext.data.IStore}
 * @record
 * @struct
 */
Ext.grid.IPropertyStore = function() {};
 /** @type {boolean} */
Ext.grid.IPropertyStore.prototype.sortOnLoad;

/**
 * [Method] Return a singleton customized Proxy object which configures itself with a custom Reader
 * @return {!Ext.data.proxy.IProxy} Ext.data.proxy.Proxy The Proxy instance
 */
Ext.grid.IPropertyStore.prototype.getProxy = function() {};
/**
 * @extends {Ext.form.IPanel}
 * @record
 * @struct
 */
Ext.grid.IRowEditor = function() {};
 /** @type {?} */
Ext.grid.IRowEditor.prototype.border;
 /** @type {string} */
Ext.grid.IRowEditor.prototype.hideMode;

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.grid.IRowEditor.prototype.afterRender = function() {};

/**
 * [Method] Lie to the CQ system about our nesting structure
 * @return {void}
 */
Ext.grid.IRowEditor.prototype.getRefItems = function() {};

/**
 * [Method] Convenience function to check if the form has any dirty fields
 * @return {boolean} Boolean
 */
Ext.grid.IRowEditor.prototype.isDirty = function() {};

/**
 * [Method] Loads an Ext data Model into this form internally just calls Ext form Basic loadRecord See also trackResetOnLoad
 * @param {?=} record Object
 * @return {!Ext.form.IBasic} Ext.form.Basic The Ext.form.Basic attached to this FormPanel
 */
Ext.grid.IRowEditor.prototype.loadRecord = function(record) {};

/**
 * [Method] Possibly animates down to a target element
 * @return {void}
 */
Ext.grid.IRowEditor.prototype.onHide = function() {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.grid.IRowEditor.prototype.onShow = function() {};

/**
 * [Method] Start editing the specified grid at the specified position
 * @param {!Ext.data.IModel=} record Ext.data.Model The Store data record which backs the row to be edited.
 * @param {!Ext.data.IModel=} columnHeader Ext.data.Model The Column object defining the column to be edited.
 * @return {void}
 */
Ext.grid.IRowEditor.prototype.startEdit = function(record, columnHeader) {};
/**
 * @extends {Ext.container.IContainer}
 * @record
 * @struct
 */
Ext.grid.IRowEditorButtons = function() {};
 /** @type {boolean} */
Ext.grid.IRowEditorButtons.prototype.frame;
 /** @type {?} */
Ext.grid.IRowEditorButtons.prototype.shrinkWrap;
/**
 * @extends {Ext.view.ITable}
 * @record
 * @struct
 */
Ext.grid.IView = function() {};
 /** @type {boolean} */
Ext.grid.IView.prototype.autoScroll;
 /** @type {boolean} */
Ext.grid.IView.prototype.stripeRows;
/**
 * @extends {Ext.view.IDropZone}
 * @record
 * @struct
 */
Ext.grid.IViewDropZone = function() {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.IImg = function() {};
 /** @type {string} */
Ext.IImg.prototype.alt;
 /** @type {?} */
Ext.IImg.prototype.autoEl;
 /** @type {string} */
Ext.IImg.prototype.baseCls;
 /** @type {?} */
Ext.IImg.prototype.glyph;
 /** @type {string} */
Ext.IImg.prototype.imgCls;
 /** @type {string} */
Ext.IImg.prototype.src;
 /** @type {string} */
Ext.IImg.prototype.title;

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.IImg.prototype.onDestroy = function() {};

/**
 * [Method] Template method called when this Component s DOM structure is created
 * @return {void}
 */
Ext.IImg.prototype.onRender = function() {};

/**
 * [Method] Updates the src of the image
 * @param {string=} src String
 * @return {void}
 */
Ext.IImg.prototype.setSrc = function(src) {};
/**
 * @record
 * @struct
 */
Ext.IIs = function() {};
/**
 * @constructor
 * @struct
 */
Ext.Is = function() {};
 /** @type {boolean} */
Ext.Is.Android;
 /** @type {boolean} */
Ext.Is.Blackberry;
 /** @type {boolean} */
Ext.Is.Desktop;
 /** @type {boolean} */
Ext.Is.Linux;
 /** @type {boolean} */
Ext.Is.Mac;
 /** @type {boolean} */
Ext.Is.Phone;
 /** @type {boolean} */
Ext.Is.Standalone;
 /** @type {?} */
Ext.Is.Tablet;
 /** @type {boolean} */
Ext.Is.Windows;
 /** @type {boolean} */
Ext.Is.iOS;
 /** @type {boolean} */
Ext.Is.iPad;
 /** @type {boolean} */
Ext.Is.iPhone;
 /** @type {boolean} */
Ext.Is.iPod;
 /** @type {string} */
Ext.BLANK_IMAGE_URL;
 /** @type {string} */
Ext.SSL_SECURE_URL;
 /** @type {boolean} */
Ext.USE_NATIVE_JSON;
 /** @type {number} */
Ext.chromeVersion;
 /** @type {?} */
Ext.emptyFn;
 /** @type {?} */
Ext.emptyString;
 /** @type {boolean} */
Ext.enableFx;
 /** @type {boolean} */
Ext.enableGarbageCollector;
 /** @type {boolean} */
Ext.enableListenerCollection;
 /** @type {boolean} */
Ext.enableNestedListenerRemoval;
 /** @type {!Array<string>} */
Ext.enumerables;
 /** @type {number} */
Ext.firefoxVersion;
 /** @type {!Ext.util.IObservable} */
Ext.globalEvents;
 /** @type {number} */
Ext.ieVersion;
 /** @type {boolean} */
Ext.isChrome;
 /** @type {boolean} */
Ext.isFF10;
 /** @type {boolean} */
Ext.isFF3_0;
 /** @type {boolean} */
Ext.isFF3_5;
 /** @type {boolean} */
Ext.isFF3_6;
 /** @type {boolean} */
Ext.isFF4;
 /** @type {boolean} */
Ext.isFF5;
 /** @type {boolean} */
Ext.isGecko;
 /** @type {boolean} */
Ext.isGecko10;
 /** @type {boolean} */
Ext.isGecko3;
 /** @type {boolean} */
Ext.isGecko4;
 /** @type {boolean} */
Ext.isGecko5;
 /** @type {boolean} */
Ext.isIE;
 /** @type {boolean} */
Ext.isIE10;
 /** @type {boolean} */
Ext.isIE10m;
 /** @type {boolean} */
Ext.isIE10p;
 /** @type {boolean} */
Ext.isIE6;
 /** @type {boolean} */
Ext.isIE7;
 /** @type {boolean} */
Ext.isIE7m;
 /** @type {boolean} */
Ext.isIE7p;
 /** @type {boolean} */
Ext.isIE8;
 /** @type {boolean} */
Ext.isIE8m;
 /** @type {boolean} */
Ext.isIE8p;
 /** @type {boolean} */
Ext.isIE9;
 /** @type {boolean} */
Ext.isIE9m;
 /** @type {boolean} */
Ext.isIE9p;
 /** @type {boolean} */
Ext.isLinux;
 /** @type {boolean} */
Ext.isMac;
 /** @type {boolean} */
Ext.isOpera;
 /** @type {boolean} */
Ext.isOpera10_5;
 /** @type {boolean} */
Ext.isReady;
 /** @type {boolean} */
Ext.isSafari;
 /** @type {boolean} */
Ext.isSafari2;
 /** @type {boolean} */
Ext.isSafari3;
 /** @type {boolean} */
Ext.isSafari4;
 /** @type {boolean} */
Ext.isSafari5;
 /** @type {boolean} */
Ext.isSafari5_0;
 /** @type {boolean} */
Ext.isSecure;
 /** @type {boolean} */
Ext.isWebKit;
 /** @type {boolean} */
Ext.isWindows;
 /** @type {string} */
Ext.name;
 /** @type {number} */
Ext.operaVersion;
 /** @type {number} */
Ext.safariVersion;
 /** @type {boolean} */
Ext.useShims;
 /** @type {number} */
Ext.webKitVersion;

/**
 * [Method] Applies event listeners to elements by selectors when the document is ready
 * @param {?=} obj Object The list of behaviors to apply
 * @return {void}
 */
Ext.addBehaviors = function(obj) {};

/**
 * [Method] Adds namespace s to known list
 * @param {?=} namespace String/String[]
 * @return {void}
 */
Ext.addNamespaces = function(namespace) {};

/**
 * [Method] Loads Ext app Application class and starts it up with given configuration after the page is ready
 * @param {?=} config Object/String Application config object or name of a class derived from Ext.app.Application.
 * @return {void}
 */
Ext.application = function(config) {};

/**
 * [Method] Copies all the properties of config to the specified object
 * @param {?=} object Object The receiver of the properties
 * @param {?=} config Object The source of the properties
 * @param {?=} defaults Object A different object that will also be applied for default values
 * @return {?} Object returns obj
 */
Ext.apply = function(object, config, defaults) {};

/**
 * [Method] Copies all the properties of config to object if they don t already exist
 * @param {?=} object Object The receiver of the properties
 * @param {?=} config Object The source of the properties
 * @return {?} Object returns obj
 */
Ext.applyIf = function(object, config) {};

/**
 * [Method] Utility wrapper that suspends layouts of all components for the duration of a given function
 * @param {?=} fn Function The function to execute.
 * @param {?=} scope Object The scope (this reference) in which the specified function is executed.
 * @return {void}
 */
Ext.batchLayouts = function(fn, scope) {};

/**
 * [Method] Create a new function from the provided fn change this to the provided scope optionally overrides arguments for the
 * @param {?=} fn Function The function to delegate.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. If omitted, defaults to the default global environment object (usually the browser window).
 * @param {!Array<?>=} args Array Overrides arguments for the call. (Defaults to the arguments passed by the caller)
 * @param {?=} appendArgs Boolean/Number if True args are appended to call args instead of overriding, if a number the args are inserted at the specified position
 * @return {?} Function The new function
 */
Ext.bind = function(fn, scope, args, appendArgs) {};

/**
 * [Method] Execute a callback function in a particular scope
 * @param {?=} callback Function The callback to execute
 * @param {?=} scope Object The scope to execute in
 * @param {!Array<?>=} args Array The arguments to pass to the function
 * @param {number=} delay Number Pass a number to delay the call by a number of milliseconds.
 * @return {?} Object The value returned by the callback or undefined (if there is a delay or if the callback is not a function).
 */
Ext.callback = function(callback, scope, args, delay) {};

/**
 * [Method] Old alias to Ext Array clean
 * @param {!Array<?>=} array Array
 * @return {!Array<?>} Array results
 */
Ext.clean = function(array) {};

/**
 * [Method] Clone simple variables including array  like objects DOM nodes and Date without keeping the old reference
 * @param {?=} item Object The variable to clone
 * @return {?} Object clone
 */
Ext.clone = function(item) {};

/**
 * [Method] Coerces the first value if possible so that it is comparable to the second value
 * @param {?=} from Mixed The value to coerce
 * @param {?=} to Mixed The value it must be compared against
 * @return {?} Object The coerced value.
 */
Ext.coerce = function(from, to) {};

/**
 * [Method] Copies a set of named properties fom the source object to the destination object
 * @param {?=} dest Object The destination object.
 * @param {?=} source Object The source object.
 * @param {?=} names String/String[] Either an Array of property names, or a comma-delimited list of property names to copy.
 * @param {boolean=} usePrototypeKeys Boolean Defaults to false. Pass true to copy keys off of the prototype as well as the instance.
 * @return {?} Object The modified object.
 */
Ext.copyTo = function(dest, source, names, usePrototypeKeys) {};

/**
 * [Method] Instantiate a class by either full name alias or alternate name
 * @param {string} name String The class name or alias. Can be specified as xclass property if only one object parameter is specified.
 * @param {...?} args Object... Additional arguments after the name will be passed to the class' constructor.
 * @return {?} Object instance
 */
Ext.create = function(name, args) {};

/**
 * [Method] Instantiate a class by its alias
 * @param {string} alias String
 * @param {...?} args Object... Additional arguments after the alias will be passed to the class constructor.
 * @return {?} Object instance
 */
Ext.createByAlias = function(alias, args) {};

/**
 * [Method] Old name for widget
 * @return {void}
 */
Ext.createWidget = function() {};

/**
 * [Method] Shorthand for Ext JSON decode
 * @param {string=} json String The JSON string
 * @param {boolean=} safe Boolean True to return null, false to throw an exception if the JSON is invalid.
 * @return {?} Object The resulting object
 */
Ext.decode = function(json, safe) {};

/**
 * [Method] Calls this function after the number of millseconds specified optionally in a specific scope
 * @param {?=} fn Function The function to defer.
 * @param {number=} millis Number The number of milliseconds for the setTimeout call (if less than or equal to 0 the function is executed immediately)
 * @param {?=} scope Object The scope (this reference) in which the function is executed. If omitted, defaults to the browser window.
 * @param {!Array<?>=} args Array Overrides arguments for the call. (Defaults to the arguments passed by the caller)
 * @param {?=} appendArgs Boolean/Number if True args are appended to call args instead of overriding, if a number the args are inserted at the specified position
 * @return {number} Number The timeout id that can be used with clearTimeout
 */
Ext.defer = function(fn, millis, scope, args, appendArgs) {};

/**
 * [Method] Defines a class or override
 * @param {string=} className String The class name to create in string dot-namespaced format, for example: 'My.very.awesome.Class', 'FeedViewer.plugin.CoolPager' It is highly recommended to follow this simple convention: - The root and the class name are 'CamelCased' - Everything else is lower-cased Pass null to create an anonymous class.
 * @param {?=} data Object The key - value pairs of properties to apply to this class. Property names can be of any valid strings, except those in the reserved listed below: - mixins - statics - config - alias - self - singleton - alternateClassName - override
 * @param {?=} createdFn Function Optional callback to execute after the class is created, the execution scope of which (this) will be the newly created class itself.
 * @return {!Ext.IBase} Ext.Base
 */
Ext.define = function(className, data, createdFn) {};

/**
 * [Method] Create a closure for deprecated code
 * @param {string=} packageName String The package name
 * @param {string=} since String The last version before it's deprecated
 * @param {?=} closure Function The callback function to be executed with the specified version is less than the current version
 * @param {?=} scope Object The execution scope (this) if the closure
 * @return {void}
 */
Ext.deprecate = function(packageName, since, closure, scope) {};

/**
 * [Method] Attempts to destroy any objects passed to it by removing all event listeners removing them from the DOM if applicab
 * @param {?=} args Ext.dom.Element/Ext.util.Observable/Ext.dom.Element[]/Ext.util.Observable[]... Any number of elements or components, or an Array of either of these to destroy.
 * @return {void}
 */
Ext.destroy = function(args) {};

/**
 * [Method] Attempts to destroy and then remove a set of named properties of the passed object
 * @param {?} o Object The object (most likely a Component) who's properties you wish to destroy.
 * @param {...?} args String... One or more names of the properties to destroy and remove from the object.
 * @return {void}
 */
Ext.destroyMembers = function(o, args) {};

/**
 * [Method] Iterates an array or an iterable value and invoke the given callback function for each item
 * @param {?=} iterable Array/NodeList/Object The value to be iterated. If this argument is not iterable, the callback function is called once.
 * @param {?=} fn Function The callback function. If it returns false, the iteration stops and this method returns the current index.
 * @param {?=} scope Object The scope (this reference) in which the specified function is executed.
 * @param {boolean=} reverse Boolean Reverse the iteration order (loop from the end to the beginning) Defaults false
 * @return {boolean} Boolean See description for the fn parameter.
 */
Ext.each = function(iterable, fn, scope, reverse) {};

/**
 * [Method] Shorthand for Ext JSON encode
 * @param {?=} o Object The variable to encode
 * @return {string} String The JSON string
 */
Ext.encode = function(o) {};

/**
 * [Method] Escapes the passed string for use in a regular expression
 * @param {string=} str String
 * @return {string} String
 */
Ext.escapeRe = function(str) {};

/**
 * [Method] Convenient shortcut to Ext Loader exclude
 * @param {!Array<?>=} excludes Array
 * @return {?} Object object contains require method for chaining
 */
Ext.exclude = function(excludes) {};

/**
 * [Method] This method deprecated
 * @param {?=} superclass Function
 * @param {?=} overrides Object
 * @return {?} Function The subclass constructor from the overrides parameter, or a generated one if not provided.
 */
Ext.extend = function(superclass, overrides) {};

/**
 * [Method] Old alias to Ext Array flatten
 * @param {!Array<?>=} array Array The array to flatten
 * @return {!Array<?>} Array The 1-d array.
 */
Ext.flatten = function(array) {};

/**
 * [Method] Gets the singleton flyweight element with the passed node as the active element
 * @param {?=} dom String/HTMLElement The dom node or id
 * @param {string=} named String Allows for creation of named reusable flyweights to prevent conflicts (e.g. internally Ext uses "_global")
 * @return {!Ext.dom.element.IFly} Ext.dom.Element.Fly The singleton flyweight object (or null if no matching element was found)
 */
Ext.fly = function(dom, named) {};

/**
 * [Method] Retrieves Ext dom Element objects
 * @param {?=} el String/HTMLElement/Ext.Element The id of the node, a DOM Node or an existing Element.
 * @return {!Ext.dom.IElement} Ext.dom.Element The Element object (or null if no matching element was found)
 */
Ext.get = function(el) {};

/**
 * [Method] Returns the current document body as an Ext Element
 * @return {!Ext.IElement} Ext.Element The document body
 */
Ext.getBody = function() {};

/**
 * [Method] Get the class of the provided object returns null if it s not an instance of any class created with Ext define
 * @param {?=} object Object
 * @return {!Ext.IClass} Ext.Class class
 */
Ext.getClass = function(object) {};

/**
 * [Method] Get the name of the class by its reference or its instance  Ext ClassManager getName is usually invoked by the short
 * @param {?=} object Ext.Class/Object
 * @return {string} String className
 */
Ext.getClassName = function(object) {};

/**
 * [Method] This is shorthand reference to Ext ComponentManager get
 * @param {string=} id String The component id
 * @return {?} Object Ext.Component The Component, undefined if not found, or null if a Class was found.
 */
Ext.getCmp = function(id) {};

/**
 * [Method] Returns the current HTML document object as an Ext Element
 * @return {!Ext.IElement} Ext.Element The document
 */
Ext.getDoc = function() {};

/**
 * [Method] Returns the dom node for the passed String id  dom node or Ext Element
 * @param {?=} el String/HTMLElement/Ext.Element
 * @return {?} Object HTMLElement
 */
Ext.getDom = function(el) {};

/**
 * [Method] Returns the current document head as an Ext Element
 * @return {!Ext.IElement} Ext.Element The document head
 */
Ext.getHead = function() {};

/**
 * [Method] Get namespace prefix for a class name
 * @param {string=} className String
 * @return {string} String Namespace prefix if it's known, otherwise undefined
 */
Ext.getNamespace = function(className) {};

/**
 * [Method] Returns the current orientation of the mobile device
 * @return {string} String Either 'portrait' or 'landscape'
 */
Ext.getOrientation = function() {};

/**
 * [Method] Utility method for getting the width of the browser s vertical scrollbar
 * @param {boolean=} force Boolean true to force a recalculation of the value.
 * @return {number} Number The width of a vertical scrollbar.
 */
Ext.getScrollBarWidth = function(force) {};

/**
 * [Method] Returns the size of the browser scrollbars
 * @param {boolean=} force Boolean true to force a recalculation of the value.
 * @return {?} Object An object containing scrollbar sizes.
 */
Ext.getScrollbarSize = function(force) {};

/**
 * [Method] Shortcut to Ext data StoreManager lookup
 * @param {?=} store String/Object The id of the Store, or a Store instance, or a store configuration
 * @return {!Ext.data.IStore} Ext.data.Store
 */
Ext.getStore = function(store) {};

/**
 * [Method] Get the version number of the supplied package name will return the last registered version last Ext setVersion cal
 * @param {string=} packageName String The package name, for example: 'core', 'touch', 'extjs'
 * @return {!Ext.IVersion} Ext.Version The version
 */
Ext.getVersion = function(packageName) {};

/**
 * [Method] Old alias to Ext String htmlDecode
 * @param {string=} value String The string to decode.
 * @return {string} String The decoded text.
 */
Ext.htmlDecode = function(value) {};

/**
 * [Method] Old alias to Ext String htmlEncode
 * @param {string=} value String The string to encode.
 * @return {string} String The encoded text.
 */
Ext.htmlEncode = function(value) {};

/**
 * [Method] Generates unique ids
 * @param {?=} el HTMLElement/Ext.Element The element to generate an id for
 * @param {string=} prefix String Id prefix (defaults "ext-gen")
 * @return {string} String The generated Id.
 */
Ext.id = function(el, prefix) {};

/**
 * [Method] A reusable identity function
 * @param {?=} o Object
 * @return {void}
 */
Ext.identityFn = function(o) {};

/**
 * [Method] Invokes a method on each item in an Array
 * @param {?} arr Array/NodeList The Array of items to invoke the method on.
 * @param {string} methodName String The method name to invoke.
 * @param {...?} args Object... Arguments to send into the method invocation.
 * @return {!Array<?>} Array The results of invoking the method on each item in the array.
 */
Ext.invoke = function(arr, methodName, args) {};

/**
 * [Method] Returns true if the passed value is a JavaScript Array false otherwise
 * @param {?=} target Object The target to test
 * @return {boolean} Boolean
 */
Ext.isArray = function(target) {};

/**
 * [Method] Returns true if the passed value is a boolean
 * @param {?=} value Object The value to test
 * @return {boolean} Boolean
 */
Ext.isBoolean = function(value) {};

/**
 * [Method] Returns true if the passed value is a JavaScript Date object false otherwise
 * @param {?=} object Object The object to test
 * @return {boolean} Boolean
 */
Ext.isDate = function(object) {};

/**
 * [Method] Returns true if the passed value is defined
 * @param {?=} value Object The value to test
 * @return {boolean} Boolean
 */
Ext.isDefined = function(value) {};

/**
 * [Method] Returns true if the passed value is an HTMLElement
 * @param {?=} value Object The value to test
 * @return {boolean} Boolean
 */
Ext.isElement = function(value) {};

/**
 * [Method] Returns true if the passed value is empty false otherwise
 * @param {?=} value Object The value to test
 * @param {boolean=} allowEmptyString Boolean true to allow empty strings (defaults to false)
 * @return {boolean} Boolean
 */
Ext.isEmpty = function(value, allowEmptyString) {};

/**
 * [Method] Returns true if the passed value is a JavaScript Function false otherwise
 * @param {?=} value Object The value to test
 * @return {boolean} Boolean
 */
Ext.isFunction = function(value) {};

/**
 * [Method] Returns true if the passed value is iterable that is if elements of it are addressable using array notation with nu
 * @param {?=} value Object The value to test
 * @return {boolean} Boolean
 */
Ext.isIterable = function(value) {};

/**
 * [Method] Returns true if the passed value is a number
 * @param {?=} value Object The value to test
 * @return {boolean} Boolean
 */
Ext.isNumber = function(value) {};

/**
 * [Method] Validates that a value is numeric
 * @param {?=} value Object Examples: 1, '1', '2.34'
 * @return {boolean} Boolean True if numeric, false otherwise
 */
Ext.isNumeric = function(value) {};

/**
 * [Method] Returns true if the passed value is a JavaScript Object false otherwise
 * @param {?=} value Object The value to test
 * @return {boolean} Boolean
 */
Ext.isObject = function(value) {};

/**
 * [Method] Returns true if the passed value is a JavaScript primitive  a string number or boolean
 * @param {?=} value Object The value to test
 * @return {boolean} Boolean
 */
Ext.isPrimitive = function(value) {};

/**
 * [Method] Returns true if the passed value is a string
 * @param {?=} value Object The value to test
 * @return {boolean} Boolean
 */
Ext.isString = function(value) {};

/**
 * [Method] Returns true if the passed value is a TextNode
 * @param {?=} value Object The value to test
 * @return {boolean} Boolean
 */
Ext.isTextNode = function(value) {};

/**
 * [Method] Iterates either an array or an object
 * @param {?=} object Object/Array The object or array to be iterated.
 * @param {?=} fn Function The function to be called for each iteration. See and Ext.Array.each and Ext.Object.each for detailed lists of arguments passed to this function depending on the given object type that is being iterated.
 * @param {?=} scope Object The scope (this reference) in which the specified function is executed. Defaults to the object being iterated itself.
 * @return {void}
 */
Ext.iterate = function(object, fn, scope) {};

/**
 * [Method] Logs a message
 * @param {?} options String/Object The message to log or an options object with any of the following properties:  msg: The message to log (required). level: One of: "error", "warn", "info" or "log" (the default is "log"). dump: An object to dump to the log as part of the message. stack: True to include a stack trace in the log. indent: Cause subsequent log statements to be indented one step. outdent: Cause this and following statements to be one step less indented.
 * @param {...?} message String... The message to log (required unless specified in options object).
 * @return {void}
 */
Ext.log = function(options, message) {};

/**
 * [Method] Old alias to Ext Array max
 * @param {?=} array Array/NodeList The Array from which to select the maximum value.
 * @param {?=} comparisonFn Function a function to perform the comparision which determines maximization. If omitted the ">" operator will be used. Note: gt = 1; eq = 0; lt = -1
 * @return {?} Object maxValue The maximum value
 */
Ext.max = function(array, comparisonFn) {};

/**
 * [Method] Old alias to Ext Array mean
 * @param {!Array<?>=} array Array The Array to calculate the mean value of.
 * @return {number} Number The mean.
 */
Ext.mean = function(array) {};

/**
 * [Method] A convenient alias method for Ext Object merge
 * @param {?} destination Object The object into which all subsequent objects are merged.
 * @param {...?} object Object... Any number of objects to merge into the destination.
 * @return {?} Object merged The destination object with all passed objects merged in.
 */
Ext.merge = function(destination, object) {};

/**
 * [Method] Old alias to Ext Array min
 * @param {?=} array Array/NodeList The Array from which to select the minimum value.
 * @param {?=} comparisonFn Function a function to perform the comparision which determines minimization. If omitted the "&lt;" operator will be used. Note: gt = 1; eq = 0; lt = -1
 * @return {?} Object minValue The minimum value
 */
Ext.min = function(array, comparisonFn) {};

/**
 * [Method] Creates namespaces to be used for scoping variables and classes so that they are not global
 * @param {...?} namespaces String...
 * @return {?} Object The namespace object. (If multiple arguments are passed, this will be the last namespace created)
 */
Ext.namespace = function(namespaces) {};

/**
 * [Method] Convenient alias for Ext namespace
 * @param {...?} namespaces String...
 * @return {?} Object The namespace object. (If multiple arguments are passed, this will be the last namespace created)
 */
Ext.ns = function(namespaces) {};

/**
 * [Method] Validate that a value is numeric and convert it to a number if necessary
 * @param {?=} value Object
 * @param {number=} defaultValue Number The value to return if the original value is non-numeric
 * @return {number} Number value, if numeric, defaultValue otherwise
 */
Ext.num = function(value, defaultValue) {};

/**
 * [Method] Shorthand for the Ext util Observable addListener method of the globalEvents Observable instance
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds a listener to be notified when the document is ready before onload and before images are loaded
 * @param {?=} fn Function The method the event invokes.
 * @param {?=} scope Object The scope (this reference) in which the handler function executes. Defaults to the browser window.
 * @param {?=} options Object Options object as passed to Ext.Element.addListener.
 * @return {void}
 */
Ext.onDocumentReady = function(fn, scope, options) {};

/**
 * [Method] Adds a function to be called when the DOM is ready and all required classes have been loaded
 * @param {?=} fn Function The function callback to be executed
 * @param {?=} scope Object The execution scope (this reference) of the callback function
 * @param {?=} options Object The options to modify the listener as passed to addListener.
 * @return {void}
 */
Ext.onReady = function(fn, scope, options) {};

/**
 * [Method] Overrides members of the specified target with the given values
 * @param {?=} target Object The target to override.
 * @param {?=} overrides Object The properties to add or replace on target.
 * @return {void}
 */
Ext.override = function(target, overrides) {};

/**
 * [Method] Partitions the set into two sets a true set and a false set
 * @param {?=} arr Array/NodeList The array to partition
 * @param {?=} truth Function a function to determine truth. If this is omitted the element itself must be able to be evaluated for its truthfulness.
 * @return {!Array<?>} Array [array of truish values, array of falsy values]
 */
Ext.partition = function(arr, truth) {};

/**
 * [Method] Create a new function from the provided fn the arguments of which are pre set to args
 * @param {?=} fn Function The original function
 * @param {!Array<?>=} args Array The arguments to pass to new callback
 * @param {?=} scope Object The scope (this reference) in which the function is executed.
 * @return {?} Function The new callback function
 */
Ext.pass = function(fn, args, scope) {};

/**
 * [Method] Old alias to Ext Array pluck
 * @param {?=} array Array/NodeList The Array of items to pluck the value from.
 * @param {string=} propertyName String The property name to pluck from each element.
 * @return {!Array<?>} Array The value from each item in the Array.
 */
Ext.pluck = function(array, propertyName) {};

/**
 * [Method] Shorthand for Ext PluginManager registerType
 * @param {string=} ptype String The ptype mnemonic string by which the Plugin class may be looked up.
 * @param {?=} cls Function The new Plugin class.
 * @return {void}
 */
Ext.preg = function(ptype, cls) {};

/**
 * [Method] Shorthand of Ext dom Query select
 * @param {string=} path String The selector/xpath query
 * @param {!HTMLElement=} root HTMLElement The start of the query.
 * @param {string=} type String Either "select" or "simple" for a simple selector match (only valid when used when the call is deferred to the jsSelect method)
 * @param {boolean=} single Boolean Pass true to select only the first matching node using document.querySelector (where available)
 * @return {!Array<!HTMLElement>} HTMLElement[] An array of DOM elements (not a NodeList as returned by querySelectorAll).
 */
Ext.query = function(path, root, type, single) {};

/**
 * [Method] Old way for creating Model classes
 * @param {string=} name String Name of the Model class.
 * @param {?=} config Object A configuration object for the Model you wish to create.
 * @return {!Ext.data.IModel} Ext.data.Model The newly registered Model
 */
Ext.regModel = function(name, config) {};

/**
 * [Method] Creates a new store for the given id and config then registers it with the Store Manager
 * @param {string=} id String The id to set on the new store
 * @param {?=} config Object The store config
 * @return {void}
 */
Ext.regStore = function(id, config) {};

/**
 * [Method] Removes a DOM node from the document
 * @param {!HTMLElement=} node HTMLElement The node to remove
 * @return {void}
 */
Ext.removeNode = function(node) {};

/**
 * [Method] Loads all classes by the given names and all their direct dependencies optionally executes the given callback functi
 * @param {?=} expressions String/Array Can either be a string or an array of string
 * @param {?=} fn Function The callback function
 * @param {?=} scope Object The execution scope (this) of the callback function
 * @param {?=} excludes String/Array Classes to be excluded, useful when being used with expressions
 * @return {void}
 */
Ext.require = function(expressions, fn, scope, excludes) {};

/**
 * [Method]
 * @param {?=} flush Object
 * @return {void}
 */
Ext.resumeLayouts = function(flush) {};

/**
 * [Method] Shorthand of Ext Element select
 * @param {string=} selector String The CSS selector
 * @param {boolean=} unique Boolean True to create a unique Ext.Element for each element. Defaults to a shared flyweight object.
 * @return {!Ext.ICompositeElement} Ext.CompositeElement The composite element
 */
Ext.select = function(selector, unique) {};

/**
 * [Method] Sets the default font family to use for components that support a glyph config
 * @param {string=} fontFamily String The name of the font-family
 * @return {void}
 */
Ext.setGlyphFontFamily = function(fontFamily) {};

/**
 * [Method] Set version number for the given package name
 * @param {string=} packageName String The package name, for example: 'core', 'touch', 'extjs'
 * @param {?=} version String/Ext.Version The version, for example: '1.2.3alpha', '2.4.0-dev'
 * @return {?} any
 */
Ext.setVersion = function(packageName, version) {};

/**
 * [Method] Old alias to Ext Array sum
 * @param {!Array<?>=} array Array The Array to calculate the sum value of.
 * @return {number} Number The sum.
 */
Ext.sum = function(array) {};

/**
 * [Method]
 * @return {void}
 */
Ext.suspendLayouts = function() {};

/**
 * [Method] Synchronously loads all classes by the given names and all their direct dependencies optionally executes the given c
 * @param {?=} expressions String/Array Can either be a string or an array of string
 * @param {?=} fn Function The callback function
 * @param {?=} scope Object The execution scope (this) of the callback function
 * @param {?=} excludes String/Array Classes to be excluded, useful when being used with expressions
 * @return {void}
 */
Ext.syncRequire = function(expressions, fn, scope, excludes) {};

/**
 * [Method] Converts any iterable numeric indices and a length property into a true array
 * @param {?=} iterable Object the iterable object to be turned into a true Array.
 * @param {number=} start Number a zero-based index that specifies the start of extraction. Defaults to 0
 * @param {number=} end Number a 1-based index that specifies the end of extraction. Defaults to the last index of the iterable value
 * @return {!Array<?>} Array array
 */
Ext.toArray = function(iterable, start, end) {};

/**
 * [Method] Turns an array into a sentence joined by a specified connector  e g Ext toSentence  Adama Tigh Roslin
 * @param {!Array<string>=} items String[] The array to create a sentence from
 * @param {string=} connector String The string to use to connect the last two words. Usually 'and' or 'or' - defaults to 'and'.
 * @return {string} String The sentence string
 */
Ext.toSentence = function(items, connector) {};

/**
 * [Method] Old alias to typeOf
 * @param {?=} value Object
 * @return {string} String
 */
Ext.type = function(value) {};

/**
 * [Method] Returns the type of the given variable in string format
 * @param {?=} value Object
 * @return {string} String
 */
Ext.typeOf = function(value) {};

/**
 * [Method] Shorthand for the Ext util Observable removeListener method of the globalEvents Observable instance
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.un = function(eventName, fn, scope) {};

/**
 * [Method] Old alias to Ext Array unique
 * @param {!Array<?>=} array Array
 * @return {!Array<?>} Array results
 */
Ext.unique = function(array) {};

/**
 * [Method] Old alias to Ext String urlAppend
 * @param {string=} url String The URL to append to.
 * @param {string=} string String The content to append to the URL.
 * @return {string} String The resulting URL
 */
Ext.urlAppend = function(url, string) {};

/**
 * [Method] Alias for Ext Object fromQueryString
 * @param {string=} queryString String The query string to decode
 * @param {boolean=} recursive Boolean Whether or not to recursively decode the string. This format is supported by PHP / Ruby on Rails servers and similar.
 * @return {?} Object
 */
Ext.urlDecode = function(queryString, recursive) {};

/**
 * [Method] Takes an object and converts it to an encoded query string
 * @param {?=} object Object The object to encode
 * @param {boolean=} recursive Boolean Whether or not to interpret the object in recursive format. (PHP / Ruby on Rails servers and similar).
 * @return {string} String queryString
 */
Ext.urlEncode = function(object, recursive) {};

/**
 * [Method] Utility method for returning a default value if the passed value is empty
 * @param {?=} value Object The value to test
 * @param {?=} defaultValue Object The value to return if the original value is empty
 * @param {boolean=} allowBlank Boolean true to allow zero length strings to qualify as non-empty.
 * @return {?} Object value, if non-empty, else defaultValue
 */
Ext.value = function(value, defaultValue, allowBlank) {};

/**
 * [Method] Returns the given value itself if it s not empty as described in isEmpty returns the default value second argument
 * @param {?=} value Object The value to test
 * @param {?=} defaultValue Object The value to return if the original value is empty
 * @param {boolean=} allowBlank Boolean true to allow zero length strings to qualify as non-empty (defaults to false)
 * @return {?} Object value, if non-empty, else defaultValue
 */
Ext.valueFrom = function(value, defaultValue, allowBlank) {};

/**
 * [Method] Convenient shorthand to create a widget by its xtype or a config object
 * @param {string=} name String The xtype of the widget to create.
 * @param {?=} config Object The configuration object for the widget constructor.
 * @return {?} Object The widget instance
 */
Ext.widget = function(name, config) {};

/**
 * [Method] Zips N sets together
 * @param {?=} arr Array/NodeList... This argument may be repeated. Array(s) to contribute values.
 * @param {?=} zipper Function The last item in the argument list. This will drive how the items are zipped together.
 * @return {!Array<?>} Array The zipped set.
 */
Ext.zip = function(arr, zipper) {};
/**
 * @record
 * @struct
 */
Ext.IJSON = function() {};
/**
 * @constructor
 * @struct
 */
Ext.JSON = function() {};

/**
 * [Method] Decodes parses a JSON string to an object
 * @param {string=} json String The JSON string
 * @param {boolean=} safe Boolean True to return null, false to throw an exception if the JSON is invalid.
 * @return {?} Object The resulting object
 */
Ext.JSON.decode = function(json, safe) {};

/**
 * [Method] Encodes an Object Array or other value
 * @param {?=} o Object The variable to encode
 * @return {string} String The JSON string
 */
Ext.JSON.encode = function(o) {};

/**
 * [Method] Encodes a Date
 * @param {?=} d Date The Date to encode
 * @return {string} String The string literal to use in a JSON string.
 */
Ext.JSON.encodeDate = function(d) {};

/**
 * [Method] Encodes a String
 * @param {string=} s String The String to encode
 * @return {string} String The string literal to use in a JSON string.
 */
Ext.JSON.encodeString = function(s) {};

/**
 * [Method] The function which encode uses to encode all javascript values to their JSON representations when Ext USE_NATIVE_JSON
 * @param {?=} o Object Any javascript value to be converted to its JSON representation
 * @return {string} String The JSON representation of the passed value.
 */
Ext.JSON.encodeValue = function(o) {};
/** @const */
Ext.layout = {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.layout.IClassList = function() {};

/**
 * [Method] Adds a single class to the class list
 * @param {?=} cls Object
 * @return {void}
 */
Ext.layout.IClassList.prototype.add = function(cls) {};

/**
 * [Method] Adds one or more classes in an array or space delimited string to the class list
 * @param {?=} classes Object
 * @return {void}
 */
Ext.layout.IClassList.prototype.addMany = function(classes) {};

/**
 * [Method] Removes a single class from the class list
 * @param {?=} cls Object
 * @return {void}
 */
Ext.layout.IClassList.prototype.remove = function(cls) {};

/**
 * [Method] Removes one or more classes in an array or space delimited string from the class list
 * @param {?=} classes Object
 * @return {void}
 */
Ext.layout.IClassList.prototype.removeMany = function(classes) {};
/** @const */
Ext.layout.component = {};
/**
 * @extends {Ext.layout.component.IComponent}
 * @record
 * @struct
 */
Ext.layout.component.IAuto = function() {};
 /** @type {boolean} */
Ext.layout.component.IAuto.prototype.setHeightInDom;
 /** @type {boolean} */
Ext.layout.component.IAuto.prototype.setWidthInDom;

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @param {?=} firstCycle Object
 * @return {void}
 */
Ext.layout.component.IAuto.prototype.beginLayoutCycle = function(ownerContext, firstCycle) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IAuto.prototype.calculate = function(ownerContext) {};
/**
 * @extends {Ext.layout.component.IAuto}
 * @record
 * @struct
 */
Ext.layout.component.IBody = function() {};

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IBody.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @param {?=} firstCycle Object
 * @return {void}
 */
Ext.layout.component.IBody.prototype.beginLayoutCycle = function(ownerContext, firstCycle) {};
/**
 * @extends {Ext.layout.component.IAuto}
 * @record
 * @struct
 */
Ext.layout.component.IBoundList = function() {};

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IBoundList.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IBoundList.prototype.beginLayoutCycle = function(ownerContext) {};

/**
 * [Method] This method is called after all layouts are complete and their calculations flushed to the DOM
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IBoundList.prototype.finishedLayout = function(ownerContext) {};

/**
 * [Method] Returns the set of items to layout empty by default
 * @return {void}
 */
Ext.layout.component.IBoundList.prototype.getLayoutItems = function() {};

/**
 * [Method] Validates item is in the proper place in the dom
 * @return {void}
 */
Ext.layout.component.IBoundList.prototype.isValidParent = function() {};
/**
 * @extends {Ext.layout.component.IAuto}
 * @record
 * @struct
 */
Ext.layout.component.IButton = function() {};

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IButton.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IButton.prototype.beginLayoutCycle = function(ownerContext) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IButton.prototype.calculate = function(ownerContext) {};
/**
 * @extends {Ext.layout.ILayout}
 * @record
 * @struct
 */
Ext.layout.component.IComponent = function() {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @param {?=} firstCycle Object
 * @return {void}
 */
Ext.layout.component.IComponent.prototype.beginLayoutCycle = function(ownerContext, firstCycle) {};

/**
 * [Method] This method is called after all layouts are complete and their calculations flushed to the DOM
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IComponent.prototype.finishedLayout = function(ownerContext) {};

/**
 * [Method] Returns the element into which rendering must take place
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.component.IComponent.prototype.getRenderTarget = function() {};

/**
 * [Method] Returns the owner component s resize element
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.component.IComponent.prototype.getTarget = function() {};

/**
 * [Method] This method if implemented is called after all layouts are finished and all have a lastComponentSize cached
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IComponent.prototype.notifyOwner = function(ownerContext) {};
/**
 * @extends {Ext.layout.component.IComponent}
 * @record
 * @struct
 */
Ext.layout.component.IDock = function() {};

/**
 * [Method] Removes layout s itemCls and owning Container s itemCls
 * @param {?=} item Object
 * @return {void}
 */
Ext.layout.component.IDock.prototype.afterRemove = function(item) {};

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IDock.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IDock.prototype.beginLayoutCycle = function(ownerContext) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IDock.prototype.calculate = function(ownerContext) {};

/**
 * [Method] We are overriding the Ext layout Layout configureItem method to also add a class that indicates the position of the d
 * @param {!Ext.IComponent=} item Ext.Component The item we are configuring
 * @return {void}
 */
Ext.layout.component.IDock.prototype.configureItem = function(item) {};

/**
 * [Method] This method is called after all layouts are complete and their calculations flushed to the DOM
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IDock.prototype.finishedLayout = function(ownerContext) {};

/**
 * [Method] Retrieve an ordered and or filtered array of all docked Components
 * @param {string=} order String The desired ordering of the items ('render' or 'visual').
 * @param {boolean=} beforeBody Boolean An optional flag to limit the set of items to only those before the body (true) or after the body (false). All components are returned by default.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] An array of components.
 */
Ext.layout.component.IDock.prototype.getDockedItems = function(order, beforeBody) {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @param {?=} ownerSizeModel Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.component.IDock.prototype.getItemSizePolicy = function(item, ownerSizeModel) {};

/**
 * [Method] Returns an array containing all the visible docked items inside this layout s owner Panel
 * @return {!Array<?>} Array An array containing all the visible docked items of the Panel
 */
Ext.layout.component.IDock.prototype.getLayoutItems = function() {};

/**
 * [Method] The default weighting of docked items produces this arrangement
 * @param {?=} ownerContext Object
 * @param {?=} horz Object
 * @param {?=} vert Object
 * @return {void}
 */
Ext.layout.component.IDock.prototype.invalidateAxes = function(ownerContext, horz, vert) {};

/**
 * [Method] Render the top and left docked items before any existing DOM nodes in our render target and then render the right an
 * @param {?=} items Object
 * @param {?=} target Object
 * @return {void}
 */
Ext.layout.component.IDock.prototype.renderItems = function(items, target) {};
/**
 * @extends {Ext.layout.component.IComponent}
 * @record
 * @struct
 */
Ext.layout.component.IAbstractDock = function() {};

/**
 * [Method] Removes layout s itemCls and owning Container s itemCls
 * @param {?=} item Object
 * @return {void}
 */
Ext.layout.component.IAbstractDock.prototype.afterRemove = function(item) {};

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IAbstractDock.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IAbstractDock.prototype.beginLayoutCycle = function(ownerContext) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IAbstractDock.prototype.calculate = function(ownerContext) {};

/**
 * [Method] We are overriding the Ext layout Layout configureItem method to also add a class that indicates the position of the d
 * @param {!Ext.IComponent=} item Ext.Component The item we are configuring
 * @return {void}
 */
Ext.layout.component.IAbstractDock.prototype.configureItem = function(item) {};

/**
 * [Method] This method is called after all layouts are complete and their calculations flushed to the DOM
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IAbstractDock.prototype.finishedLayout = function(ownerContext) {};

/**
 * [Method] Retrieve an ordered and or filtered array of all docked Components
 * @param {string=} order String The desired ordering of the items ('render' or 'visual').
 * @param {boolean=} beforeBody Boolean An optional flag to limit the set of items to only those before the body (true) or after the body (false). All components are returned by default.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] An array of components.
 */
Ext.layout.component.IAbstractDock.prototype.getDockedItems = function(order, beforeBody) {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @param {?=} ownerSizeModel Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.component.IAbstractDock.prototype.getItemSizePolicy = function(item, ownerSizeModel) {};

/**
 * [Method] Returns an array containing all the visible docked items inside this layout s owner Panel
 * @return {!Array<?>} Array An array containing all the visible docked items of the Panel
 */
Ext.layout.component.IAbstractDock.prototype.getLayoutItems = function() {};

/**
 * [Method] The default weighting of docked items produces this arrangement
 * @param {?=} ownerContext Object
 * @param {?=} horz Object
 * @param {?=} vert Object
 * @return {void}
 */
Ext.layout.component.IAbstractDock.prototype.invalidateAxes = function(ownerContext, horz, vert) {};

/**
 * [Method] Render the top and left docked items before any existing DOM nodes in our render target and then render the right an
 * @param {?=} items Object
 * @param {?=} target Object
 * @return {void}
 */
Ext.layout.component.IAbstractDock.prototype.renderItems = function(items, target) {};
/**
 * @extends {Ext.layout.component.IAuto}
 * @record
 * @struct
 */
Ext.layout.component.IDraw = function() {};
 /** @type {boolean} */
Ext.layout.component.IDraw.prototype.setHeightInDom;
 /** @type {boolean} */
Ext.layout.component.IDraw.prototype.setWidthInDom;

/**
 * [Method] This method is called after all layouts are complete and their calculations flushed to the DOM
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IDraw.prototype.finishedLayout = function(ownerContext) {};
/** @const */
Ext.layout.component.field = {};
/**
 * @extends {Ext.layout.component.field.ITrigger}
 * @record
 * @struct
 */
Ext.layout.component.field.IComboBox = function() {};
/**
 * @extends {Ext.layout.component.IAuto}
 * @record
 * @struct
 */
Ext.layout.component.field.IField = function() {};
 /** @type {?} */
Ext.layout.component.field.IField.prototype.elementId;
 /** @type {?} */
Ext.layout.component.field.IField.prototype.errorStrategies;
 /** @type {?} */
Ext.layout.component.field.IField.prototype.labelStrategies;
 /** @type {?} */
Ext.layout.component.field.IField.prototype.left;
 /** @type {?} */
Ext.layout.component.field.IField.prototype.qtip;
 /** @type {?} */
Ext.layout.component.field.IField.prototype.right;
 /** @type {?} */
Ext.layout.component.field.IField.prototype.side;
 /** @type {?} */
Ext.layout.component.field.IField.prototype.title;
 /** @type {?} */
Ext.layout.component.field.IField.prototype.top;
 /** @type {?} */
Ext.layout.component.field.IField.prototype.under;

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.field.IField.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.field.IField.prototype.beginLayoutCycle = function(ownerContext) {};

/**
 * [Method] This method is called after all layouts are complete and their calculations flushed to the DOM
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.field.IField.prototype.finishedLayout = function(ownerContext) {};

/**
 * [Method] Return the set of strategy functions from the errorStrategies collection that is appropriate for the field s msgTarge
 * @return {void}
 */
Ext.layout.component.field.IField.prototype.getErrorStrategy = function() {};

/**
 * [Method] Return the set of strategy functions from the labelStrategies collection that is appropriate for the field s labelAli
 * @return {void}
 */
Ext.layout.component.field.IField.prototype.getLabelStrategy = function() {};
/**
 * @constructor
 * @struct
 */
Ext.layout.component.field.Field = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.layout.component.field.Field.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.layout.component.field.Field.addStatics = function(members) {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.layout.component.field.Field.createAlias = function(alias, origin) {};

/**
 * [Method] Destroy the error tip instance
 * @return {void}
 */
Ext.layout.component.field.Field.destroyTip = function() {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.layout.component.field.Field.getName = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.layout.component.field.Field.implement = function() {};

/**
 * [Method] Use a custom QuickTip instance separate from the main QuickTips singleton so that we can give it a custom frame style
 * @return {void}
 */
Ext.layout.component.field.Field.initTip = function() {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.layout.component.field.Field.override = function(members) {};
/**
 * @extends {Ext.layout.component.field.IField}
 * @record
 * @struct
 */
Ext.layout.component.field.IFieldContainer = function() {};

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.field.IFieldContainer.prototype.beginLayout = function(ownerContext) {};
/**
 * @extends {Ext.layout.component.field.IFieldContainer}
 * @record
 * @struct
 */
Ext.layout.component.field.IHtmlEditor = function() {};

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.field.IHtmlEditor.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.field.IHtmlEditor.prototype.beginLayoutCycle = function(ownerContext) {};

/**
 * [Method] This method is called after all layouts are complete and their calculations flushed to the DOM
 * @return {void}
 */
Ext.layout.component.field.IHtmlEditor.prototype.finishedLayout = function() {};
/**
 * @extends {Ext.layout.component.field.IField}
 * @record
 * @struct
 */
Ext.layout.component.field.ISlider = function() {};

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.field.ISlider.prototype.beginLayout = function(ownerContext) {};
/**
 * @extends {Ext.layout.component.field.IField}
 * @record
 * @struct
 */
Ext.layout.component.field.IText = function() {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.field.IText.prototype.beginLayoutCycle = function(ownerContext) {};
/**
 * @extends {Ext.layout.component.field.IText}
 * @record
 * @struct
 */
Ext.layout.component.field.ITextArea = function() {};

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.field.ITextArea.prototype.beginLayout = function(ownerContext) {};
/**
 * @extends {Ext.layout.component.field.IField}
 * @record
 * @struct
 */
Ext.layout.component.field.ITrigger = function() {};

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.field.ITrigger.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.field.ITrigger.prototype.beginLayoutCycle = function(ownerContext) {};
/**
 * @extends {Ext.layout.component.IBody}
 * @record
 * @struct
 */
Ext.layout.component.IFieldSet = function() {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IFieldSet.prototype.beginLayoutCycle = function(ownerContext) {};

/**
 * [Method] This method is called after all layouts are complete and their calculations flushed to the DOM
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IFieldSet.prototype.finishedLayout = function(ownerContext) {};

/**
 * [Method] Returns the set of items to layout empty by default
 * @return {void}
 */
Ext.layout.component.IFieldSet.prototype.getLayoutItems = function() {};
/**
 * @extends {Ext.layout.component.IAuto}
 * @record
 * @struct
 */
Ext.layout.component.IProgressBar = function() {};

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IProgressBar.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.component.IProgressBar.prototype.calculate = function(ownerContext) {};
/** @const */
Ext.layout.container = {};
/**
 * @extends {Ext.layout.container.IAnchor}
 * @record
 * @struct
 */
Ext.layout.container.IAbsolute = function() {};
 /** @type {boolean} */
Ext.layout.container.IAbsolute.prototype.ignoreOnContentChange;
 /** @type {string} */
Ext.layout.container.IAbsolute.prototype.itemCls;

/**
 * [Method] In addition to work done by our base classes containers benefit from some extra cached data
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IAbsolute.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] This method is called when a child item changes in some way
 * @return {boolean} Boolean True if this layout has handled the content change.
 */
Ext.layout.container.IAbsolute.prototype.onContentChange = function() {};
/**
 * @extends {Ext.layout.container.IAnchor}
 * @record
 * @struct
 */
Ext.layout.IAbsoluteLayout = function() {};
 /** @type {boolean} */
Ext.layout.IAbsoluteLayout.prototype.ignoreOnContentChange;
 /** @type {string} */
Ext.layout.IAbsoluteLayout.prototype.itemCls;

/**
 * [Method] In addition to work done by our base classes containers benefit from some extra cached data
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.IAbsoluteLayout.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] This method is called when a child item changes in some way
 * @return {boolean} Boolean True if this layout has handled the content change.
 */
Ext.layout.IAbsoluteLayout.prototype.onContentChange = function() {};
/**
 * @extends {Ext.layout.container.IVBox}
 * @record
 * @struct
 */
Ext.layout.container.IAccordion = function() {};
 /** @type {boolean} */
Ext.layout.container.IAccordion.prototype.activeOnTop;
 /** @type {string} */
Ext.layout.container.IAccordion.prototype.align;
 /** @type {boolean} */
Ext.layout.container.IAccordion.prototype.animate;
 /** @type {boolean} */
Ext.layout.container.IAccordion.prototype.autoWidth;
 /** @type {boolean} */
Ext.layout.container.IAccordion.prototype.collapseFirst;
 /** @type {boolean} */
Ext.layout.container.IAccordion.prototype.fill;
 /** @type {boolean} */
Ext.layout.container.IAccordion.prototype.hideCollapseTool;
 /** @type {string} */
Ext.layout.container.IAccordion.prototype.itemCls;
 /** @type {boolean} */
Ext.layout.container.IAccordion.prototype.multi;
 /** @type {boolean} */
Ext.layout.container.IAccordion.prototype.titleCollapse;

/**
 * [Method] In addition to work done by our base classes containers benefit from some extra cached data
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IAccordion.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Adds layout s itemCls and owning Container s itemCls
 * @param {?=} item Object
 * @return {void}
 */
Ext.layout.container.IAccordion.prototype.configureItem = function(item) {};

/**
 * [Method] Iterates over all passed items ensuring they are rendered
 * @param {?=} items Object
 * @param {?=} target Object
 * @return {void}
 */
Ext.layout.container.IAccordion.prototype.renderItems = function(items, target) {};
/**
 * @extends {Ext.layout.container.IVBox}
 * @record
 * @struct
 */
Ext.layout.IAccordionLayout = function() {};
 /** @type {boolean} */
Ext.layout.IAccordionLayout.prototype.activeOnTop;
 /** @type {string} */
Ext.layout.IAccordionLayout.prototype.align;
 /** @type {boolean} */
Ext.layout.IAccordionLayout.prototype.animate;
 /** @type {boolean} */
Ext.layout.IAccordionLayout.prototype.autoWidth;
 /** @type {boolean} */
Ext.layout.IAccordionLayout.prototype.collapseFirst;
 /** @type {boolean} */
Ext.layout.IAccordionLayout.prototype.fill;
 /** @type {boolean} */
Ext.layout.IAccordionLayout.prototype.hideCollapseTool;
 /** @type {string} */
Ext.layout.IAccordionLayout.prototype.itemCls;
 /** @type {boolean} */
Ext.layout.IAccordionLayout.prototype.multi;
 /** @type {boolean} */
Ext.layout.IAccordionLayout.prototype.titleCollapse;

/**
 * [Method] In addition to work done by our base classes containers benefit from some extra cached data
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.IAccordionLayout.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Adds layout s itemCls and owning Container s itemCls
 * @param {?=} item Object
 * @return {void}
 */
Ext.layout.IAccordionLayout.prototype.configureItem = function(item) {};

/**
 * [Method] Iterates over all passed items ensuring they are rendered
 * @param {?=} items Object
 * @param {?=} target Object
 * @return {void}
 */
Ext.layout.IAccordionLayout.prototype.renderItems = function(items, target) {};
/**
 * @extends {Ext.layout.container.IAuto}
 * @record
 * @struct
 */
Ext.layout.container.IAnchor = function() {};
 /** @type {string} */
Ext.layout.container.IAnchor.prototype.anchor;
 /** @type {string} */
Ext.layout.container.IAnchor.prototype.defaultAnchor;
 /** @type {boolean} */
Ext.layout.container.IAnchor.prototype.manageOverflow;

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IAnchor.prototype.beginLayoutCycle = function(ownerContext) {};

/**
 * [Method] Adds layout s itemCls and owning Container s itemCls
 * @param {?=} item Object
 * @return {void}
 */
Ext.layout.container.IAnchor.prototype.configureItem = function(item) {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.container.IAnchor.prototype.getItemSizePolicy = function(item) {};
/**
 * @extends {Ext.layout.container.IAuto}
 * @record
 * @struct
 */
Ext.layout.IAnchorLayout = function() {};
 /** @type {string} */
Ext.layout.IAnchorLayout.prototype.anchor;
 /** @type {string} */
Ext.layout.IAnchorLayout.prototype.defaultAnchor;
 /** @type {boolean} */
Ext.layout.IAnchorLayout.prototype.manageOverflow;

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.IAnchorLayout.prototype.beginLayoutCycle = function(ownerContext) {};

/**
 * [Method] Adds layout s itemCls and owning Container s itemCls
 * @param {?=} item Object
 * @return {void}
 */
Ext.layout.IAnchorLayout.prototype.configureItem = function(item) {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.IAnchorLayout.prototype.getItemSizePolicy = function(item) {};
/**
 * @extends {Ext.layout.container.IContainer}
 * @record
 * @struct
 */
Ext.layout.container.IAuto = function() {};
 /** @type {boolean} */
Ext.layout.container.IAuto.prototype.reserveScrollbar;
 /** @type {boolean} */
Ext.layout.container.IAuto.prototype.manageOverflow;
 /** @type {boolean} */
Ext.layout.container.IAuto.prototype.managePadding;

/**
 * [Method] In addition to work done by our base classes containers benefit from some extra cached data
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IAuto.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IAuto.prototype.beginLayoutCycle = function(ownerContext) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IAuto.prototype.calculate = function(ownerContext) {};

/**
 * [Method] Handles overflow processing for a container
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem
 * @return {void}
 */
Ext.layout.container.IAuto.prototype.calculateOverflow = function(ownerContext) {};

/**
 * [Method] This method if implemented is called at the end of the cycle in which this layout completes by not setting done to
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IAuto.prototype.completeLayout = function(ownerContext) {};

/**
 * [Method] This method is called after all layouts are complete and their calculations flushed to the DOM
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IAuto.prototype.finishedLayout = function(ownerContext) {};

/**
 * [Method] Returns the container size that of the target
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem The owner's context item.
 * @param {boolean=} inDom Boolean True if the container size must be in the DOM.
 * @return {?} Object The size
 */
Ext.layout.container.IAuto.prototype.getContainerSize = function(ownerContext, inDom) {};

/**
 * [Method] Overridden method from Ext layout container Container
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.container.IAuto.prototype.getElementTarget = function() {};

/**
 * [Method] Returns the overflow x style of the render target
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem
 * @return {string} String
 */
Ext.layout.container.IAuto.prototype.getOverflowXStyle = function(ownerContext) {};

/**
 * [Method] Returns the overflow y style of the render target
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem
 * @return {string} String
 */
Ext.layout.container.IAuto.prototype.getOverflowYStyle = function(ownerContext) {};

/**
 * [Method] Overridden method from Ext layout container Container
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.container.IAuto.prototype.getRenderTarget = function() {};

/**
 * [Method] A one time initialization method called just before rendering
 * @return {void}
 */
Ext.layout.container.IAuto.prototype.initLayout = function() {};

/**
 * [Method] This method sets the height and or width of the outerCt innerCt to adjust for the following browser specific issues
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem
 * @param {?=} containerSize Object
 * @return {void}
 */
Ext.layout.container.IAuto.prototype.setCtSizeIfNeeded = function(ownerContext, containerSize) {};
/**
 * @extends {Ext.layout.container.IContainer}
 * @record
 * @struct
 */
Ext.layout.container.IBorder = function() {};
 /** @type {string} */
Ext.layout.container.IBorder.prototype.itemCls;
 /** @type {?} */
Ext.layout.container.IBorder.prototype.padding;
 /** @type {?} */
Ext.layout.container.IBorder.prototype.regionWeights;
 /** @type {boolean} */
Ext.layout.container.IBorder.prototype.split;
 /** @type {boolean} */
Ext.layout.container.IBorder.prototype.splitterResize;

/**
 * [Method] In addition to work done by our base classes containers benefit from some extra cached data
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IBorder.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IBorder.prototype.calculate = function(ownerContext) {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.container.IBorder.prototype.getItemSizePolicy = function(item) {};

/**
 * [Method] Returns an array of child components either for a render phase Performed in the beforeLayout method of the layout s
 * @return {!Array<!Ext.IComponent>} Ext.Component[] of child components
 */
Ext.layout.container.IBorder.prototype.getLayoutItems = function() {};
/**
 * @extends {Ext.layout.container.IContainer}
 * @record
 * @struct
 */
Ext.layout.IBorderLayout = function() {};
 /** @type {string} */
Ext.layout.IBorderLayout.prototype.itemCls;
 /** @type {?} */
Ext.layout.IBorderLayout.prototype.padding;
 /** @type {?} */
Ext.layout.IBorderLayout.prototype.regionWeights;
 /** @type {boolean} */
Ext.layout.IBorderLayout.prototype.split;
 /** @type {boolean} */
Ext.layout.IBorderLayout.prototype.splitterResize;

/**
 * [Method] In addition to work done by our base classes containers benefit from some extra cached data
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.IBorderLayout.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.IBorderLayout.prototype.calculate = function(ownerContext) {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.IBorderLayout.prototype.getItemSizePolicy = function(item) {};

/**
 * [Method] Returns an array of child components either for a render phase Performed in the beforeLayout method of the layout s
 * @return {!Array<!Ext.IComponent>} Ext.Component[] of child components
 */
Ext.layout.IBorderLayout.prototype.getLayoutItems = function() {};
/**
 * @extends {Ext.layout.container.IContainer}
 * @record
 * @struct
 */
Ext.layout.container.IBox = function() {};
 /** @type {?} */
Ext.layout.container.IBox.prototype.defaultMargins;
 /** @type {number} */
Ext.layout.container.IBox.prototype.flex;
 /** @type {string} */
Ext.layout.container.IBox.prototype.itemCls;
 /** @type {string} */
Ext.layout.container.IBox.prototype.pack;
 /** @type {string} */
Ext.layout.container.IBox.prototype.padding;
 /** @type {?} */
Ext.layout.container.IBox.prototype.stretchMaxPartner;

/**
 * [Method] In addition to work done by our base classes containers benefit from some extra cached data
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IBox.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @param {?=} firstCycle Object
 * @return {void}
 */
Ext.layout.container.IBox.prototype.beginLayoutCycle = function(ownerContext, firstCycle) {};

/**
 * [Method] This method is called to re cache our understanding of flexes
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IBox.prototype.cacheFlexes = function(ownerContext) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IBox.prototype.calculate = function(ownerContext) {};

/**
 * [Method] This method if implemented is called at the end of the cycle in which this layout completes by not setting done to
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IBox.prototype.completeLayout = function(ownerContext) {};

/**
 * [Method] This method is called after all layouts are complete and their calculations flushed to the DOM
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IBox.prototype.finishedLayout = function(ownerContext) {};

/**
 * [Method] Overridden method from Ext layout container Container
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.container.IBox.prototype.getElementTarget = function() {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @param {?=} ownerSizeModel Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.container.IBox.prototype.getItemSizePolicy = function(item, ownerSizeModel) {};

/**
 * [Method] Overridden method from Ext layout container Container
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.container.IBox.prototype.getRenderTarget = function() {};
/**
 * @extends {Ext.layout.container.IContainer}
 * @record
 * @struct
 */
Ext.layout.IBoxLayout = function() {};
 /** @type {?} */
Ext.layout.IBoxLayout.prototype.defaultMargins;
 /** @type {number} */
Ext.layout.IBoxLayout.prototype.flex;
 /** @type {string} */
Ext.layout.IBoxLayout.prototype.itemCls;
 /** @type {string} */
Ext.layout.IBoxLayout.prototype.pack;
 /** @type {string} */
Ext.layout.IBoxLayout.prototype.padding;
 /** @type {?} */
Ext.layout.IBoxLayout.prototype.stretchMaxPartner;

/**
 * [Method] In addition to work done by our base classes containers benefit from some extra cached data
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.IBoxLayout.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @param {?=} firstCycle Object
 * @return {void}
 */
Ext.layout.IBoxLayout.prototype.beginLayoutCycle = function(ownerContext, firstCycle) {};

/**
 * [Method] This method is called to re cache our understanding of flexes
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.IBoxLayout.prototype.cacheFlexes = function(ownerContext) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.IBoxLayout.prototype.calculate = function(ownerContext) {};

/**
 * [Method] This method if implemented is called at the end of the cycle in which this layout completes by not setting done to
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.IBoxLayout.prototype.completeLayout = function(ownerContext) {};

/**
 * [Method] This method is called after all layouts are complete and their calculations flushed to the DOM
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.IBoxLayout.prototype.finishedLayout = function(ownerContext) {};

/**
 * [Method] Overridden method from Ext layout container Container
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.IBoxLayout.prototype.getElementTarget = function() {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @param {?=} ownerSizeModel Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.IBoxLayout.prototype.getItemSizePolicy = function(item, ownerSizeModel) {};

/**
 * [Method] Overridden method from Ext layout container Container
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.IBoxLayout.prototype.getRenderTarget = function() {};
/** @const */
Ext.layout.container.boxoverflow = {};
/**
 * @extends {Ext.layout.container.boxoverflow.INone}
 * @record
 * @struct
 */
Ext.layout.container.boxoverflow.IMenu = function() {};
 /** @type {string} */
Ext.layout.container.boxoverflow.IMenu.prototype.triggerButtonCls;
 /** @type {!Array<?>} */
Ext.layout.container.boxoverflow.IMenu.prototype.menuItems;
 /** @type {string} */
Ext.layout.container.boxoverflow.IMenu.prototype.noItemsMenuText;
/** @const */
Ext.layout.boxoverflow = {};
/**
 * @extends {Ext.layout.container.boxoverflow.INone}
 * @record
 * @struct
 */
Ext.layout.boxoverflow.IMenu = function() {};
 /** @type {string} */
Ext.layout.boxoverflow.IMenu.prototype.triggerButtonCls;
 /** @type {!Array<?>} */
Ext.layout.boxoverflow.IMenu.prototype.menuItems;
 /** @type {string} */
Ext.layout.boxoverflow.IMenu.prototype.noItemsMenuText;
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.layout.container.boxoverflow.INone = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.layout.boxoverflow.INone = function() {};
/**
 * @extends {Ext.layout.container.boxoverflow.INone}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.layout.container.boxoverflow.IScroller = function() {};
 /** @type {string} */
Ext.layout.container.boxoverflow.IScroller.prototype.afterCtCls;
 /** @type {string} */
Ext.layout.container.boxoverflow.IScroller.prototype.afterScrollerCls;
 /** @type {boolean} */
Ext.layout.container.boxoverflow.IScroller.prototype.animateScroll;
 /** @type {string} */
Ext.layout.container.boxoverflow.IScroller.prototype.beforeCtCls;
 /** @type {string} */
Ext.layout.container.boxoverflow.IScroller.prototype.beforeScrollerCls;
 /** @type {number} */
Ext.layout.container.boxoverflow.IScroller.prototype.scrollDuration;
 /** @type {number} */
Ext.layout.container.boxoverflow.IScroller.prototype.scrollIncrement;
 /** @type {number} */
Ext.layout.container.boxoverflow.IScroller.prototype.scrollRepeatInterval;
 /** @type {string} */
Ext.layout.container.boxoverflow.IScroller.prototype.scrollerCls;
 /** @type {number} */
Ext.layout.container.boxoverflow.IScroller.prototype.wheelIncrement;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.layout.container.boxoverflow.IScroller.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.layout.container.boxoverflow.IScroller.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.layout.container.boxoverflow.IScroller.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.layout.container.boxoverflow.IScroller.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.layout.container.boxoverflow.IScroller.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.layout.container.boxoverflow.IScroller.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.layout.container.boxoverflow.IScroller.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.layout.container.boxoverflow.IScroller.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the current scroll position of the innerCt element
 * @return {number} Number The current scroll position
 */
Ext.layout.container.boxoverflow.IScroller.prototype.getScrollPosition = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.layout.container.boxoverflow.IScroller.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.layout.container.boxoverflow.IScroller.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.layout.container.boxoverflow.IScroller.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.layout.container.boxoverflow.IScroller.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.layout.container.boxoverflow.IScroller.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.layout.container.boxoverflow.IScroller.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.layout.container.boxoverflow.IScroller.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.layout.container.boxoverflow.IScroller.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.layout.container.boxoverflow.IScroller.prototype.resumeEvents = function() {};

/**
 * [Method] Scrolls to the given component
 * @param {?=} item String/Number/Ext.Component The item to scroll to. Can be a numerical index, component id or a reference to the component itself.
 * @param {boolean=} animate Boolean True to animate the scrolling
 * @return {void}
 */
Ext.layout.container.boxoverflow.IScroller.prototype.scrollToItem = function(item, animate) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.layout.container.boxoverflow.IScroller.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.layout.container.boxoverflow.IScroller.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.layout.container.boxoverflow.IScroller.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.layout.container.boxoverflow.INone}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.layout.boxoverflow.IScroller = function() {};
 /** @type {string} */
Ext.layout.boxoverflow.IScroller.prototype.afterCtCls;
 /** @type {string} */
Ext.layout.boxoverflow.IScroller.prototype.afterScrollerCls;
 /** @type {boolean} */
Ext.layout.boxoverflow.IScroller.prototype.animateScroll;
 /** @type {string} */
Ext.layout.boxoverflow.IScroller.prototype.beforeCtCls;
 /** @type {string} */
Ext.layout.boxoverflow.IScroller.prototype.beforeScrollerCls;
 /** @type {number} */
Ext.layout.boxoverflow.IScroller.prototype.scrollDuration;
 /** @type {number} */
Ext.layout.boxoverflow.IScroller.prototype.scrollIncrement;
 /** @type {number} */
Ext.layout.boxoverflow.IScroller.prototype.scrollRepeatInterval;
 /** @type {string} */
Ext.layout.boxoverflow.IScroller.prototype.scrollerCls;
 /** @type {number} */
Ext.layout.boxoverflow.IScroller.prototype.wheelIncrement;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.layout.boxoverflow.IScroller.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.layout.boxoverflow.IScroller.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.layout.boxoverflow.IScroller.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.layout.boxoverflow.IScroller.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.layout.boxoverflow.IScroller.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.layout.boxoverflow.IScroller.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.layout.boxoverflow.IScroller.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.layout.boxoverflow.IScroller.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the current scroll position of the innerCt element
 * @return {number} Number The current scroll position
 */
Ext.layout.boxoverflow.IScroller.prototype.getScrollPosition = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.layout.boxoverflow.IScroller.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.layout.boxoverflow.IScroller.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.layout.boxoverflow.IScroller.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.layout.boxoverflow.IScroller.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.layout.boxoverflow.IScroller.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.layout.boxoverflow.IScroller.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.layout.boxoverflow.IScroller.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.layout.boxoverflow.IScroller.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.layout.boxoverflow.IScroller.prototype.resumeEvents = function() {};

/**
 * [Method] Scrolls to the given component
 * @param {?=} item String/Number/Ext.Component The item to scroll to. Can be a numerical index, component id or a reference to the component itself.
 * @param {boolean=} animate Boolean True to animate the scrolling
 * @return {void}
 */
Ext.layout.boxoverflow.IScroller.prototype.scrollToItem = function(item, animate) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.layout.boxoverflow.IScroller.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.layout.boxoverflow.IScroller.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.layout.boxoverflow.IScroller.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.layout.container.IFit}
 * @record
 * @struct
 */
Ext.layout.container.ICard = function() {};
 /** @type {boolean} */
Ext.layout.container.ICard.prototype.deferredRender;

/**
 * [Method] Return the active visible component in the layout
 * @return {!Ext.IComponent} Ext.Component
 */
Ext.layout.container.ICard.prototype.getActiveItem = function() {};

/**
 * [Method] Return the active visible component in the layout to the next card
 * @return {!Ext.IComponent} Ext.Component The next component or false.
 */
Ext.layout.container.ICard.prototype.getNext = function() {};

/**
 * [Method] Return the active visible component in the layout to the previous card
 * @return {!Ext.IComponent} Ext.Component The previous component or false.
 */
Ext.layout.container.ICard.prototype.getPrev = function() {};

/**
 * [Method] Validates item is in the proper place in the dom
 * @param {?=} item Object
 * @param {?=} target Object
 * @param {?=} position Object
 * @return {void}
 */
Ext.layout.container.ICard.prototype.isValidParent = function(item, target, position) {};

/**
 * [Method] Sets the active visible component in the layout to the next card
 * @return {!Ext.IComponent} Ext.Component the activated component or false when nothing activated.
 */
Ext.layout.container.ICard.prototype.next = function() {};

/**
 * [Method] Sets the active visible component in the layout to the previous card
 * @return {!Ext.IComponent} Ext.Component the activated component or false when nothing activated.
 */
Ext.layout.container.ICard.prototype.prev = function() {};

/**
 * [Method] Makes the given card active
 * @param {?=} newCard Ext.Component/Number/String The component, component id, itemId, or index of component.
 * @return {!Ext.IComponent} Ext.Component the activated component or false when nothing activated. False is returned also when trying to activate an already active card.
 */
Ext.layout.container.ICard.prototype.setActiveItem = function(newCard) {};
/**
 * @extends {Ext.layout.container.IFit}
 * @record
 * @struct
 */
Ext.layout.ICardLayout = function() {};
 /** @type {boolean} */
Ext.layout.ICardLayout.prototype.deferredRender;

/**
 * [Method] Return the active visible component in the layout
 * @return {!Ext.IComponent} Ext.Component
 */
Ext.layout.ICardLayout.prototype.getActiveItem = function() {};

/**
 * [Method] Return the active visible component in the layout to the next card
 * @return {!Ext.IComponent} Ext.Component The next component or false.
 */
Ext.layout.ICardLayout.prototype.getNext = function() {};

/**
 * [Method] Return the active visible component in the layout to the previous card
 * @return {!Ext.IComponent} Ext.Component The previous component or false.
 */
Ext.layout.ICardLayout.prototype.getPrev = function() {};

/**
 * [Method] Validates item is in the proper place in the dom
 * @param {?=} item Object
 * @param {?=} target Object
 * @param {?=} position Object
 * @return {void}
 */
Ext.layout.ICardLayout.prototype.isValidParent = function(item, target, position) {};

/**
 * [Method] Sets the active visible component in the layout to the next card
 * @return {!Ext.IComponent} Ext.Component the activated component or false when nothing activated.
 */
Ext.layout.ICardLayout.prototype.next = function() {};

/**
 * [Method] Sets the active visible component in the layout to the previous card
 * @return {!Ext.IComponent} Ext.Component the activated component or false when nothing activated.
 */
Ext.layout.ICardLayout.prototype.prev = function() {};

/**
 * [Method] Makes the given card active
 * @param {?=} newCard Ext.Component/Number/String The component, component id, itemId, or index of component.
 * @return {!Ext.IComponent} Ext.Component the activated component or false when nothing activated. False is returned also when trying to activate an already active card.
 */
Ext.layout.ICardLayout.prototype.setActiveItem = function(newCard) {};
/**
 * @extends {Ext.layout.container.IContainer}
 * @record
 * @struct
 */
Ext.layout.container.ICheckboxGroup = function() {};
 /** @type {boolean} */
Ext.layout.container.ICheckboxGroup.prototype.autoFlex;

/**
 * [Method] In addition to work done by our base classes containers benefit from some extra cached data
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.ICheckboxGroup.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Just wait for the child items to all lay themselves out in the width we are configured to make available to them
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.ICheckboxGroup.prototype.calculate = function(ownerContext) {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.container.ICheckboxGroup.prototype.getItemSizePolicy = function(item) {};

/**
 * [Method] A one time initialization method called just before rendering
 * @return {void}
 */
Ext.layout.container.ICheckboxGroup.prototype.initLayout = function() {};

/**
 * [Method] Always valid
 * @return {void}
 */
Ext.layout.container.ICheckboxGroup.prototype.isValidParent = function() {};

/**
 * [Method] Iterates over all passed items ensuring they are rendered
 * @param {?=} items Object
 * @return {void}
 */
Ext.layout.container.ICheckboxGroup.prototype.renderItems = function(items) {};
/**
 * @extends {Ext.layout.container.IAuto}
 * @record
 * @struct
 */
Ext.layout.container.IColumn = function() {};
 /** @type {string} */
Ext.layout.container.IColumn.prototype.itemCls;
 /** @type {boolean} */
Ext.layout.container.IColumn.prototype.manageOverflow;

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @param {?=} ownerSizeModel Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.container.IColumn.prototype.getItemSizePolicy = function(item, ownerSizeModel) {};

/**
 * [Method] This method sets the height and or width of the outerCt innerCt to adjust for the following browser specific issues
 * @param {?=} ownerContext Object
 * @param {?=} containerSize Object
 * @return {void}
 */
Ext.layout.container.IColumn.prototype.setCtSizeIfNeeded = function(ownerContext, containerSize) {};
/**
 * @extends {Ext.layout.container.IAuto}
 * @record
 * @struct
 */
Ext.layout.IColumnLayout = function() {};
 /** @type {string} */
Ext.layout.IColumnLayout.prototype.itemCls;
 /** @type {boolean} */
Ext.layout.IColumnLayout.prototype.manageOverflow;

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @param {?=} ownerSizeModel Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.IColumnLayout.prototype.getItemSizePolicy = function(item, ownerSizeModel) {};

/**
 * [Method] This method sets the height and or width of the outerCt innerCt to adjust for the following browser specific issues
 * @param {?=} ownerContext Object
 * @param {?=} containerSize Object
 * @return {void}
 */
Ext.layout.IColumnLayout.prototype.setCtSizeIfNeeded = function(ownerContext, containerSize) {};
/**
 * @extends {Ext.layout.ILayout}
 * @extends {Ext.util.IElementContainer}
 * @record
 * @struct
 */
Ext.layout.container.IContainer = function() {};
 /** @type {string} */
Ext.layout.container.IContainer.prototype.itemCls;
 /** @type {!Ext.IElement} */
Ext.layout.container.IContainer.prototype.overflowPadderEl;

/**
 * [Method] Adds each argument passed to this method to the childEls array
 * @return {void}
 */
Ext.layout.container.IContainer.prototype.addChildEls = function() {};

/**
 * [Method] In addition to work done by our base classes containers benefit from some extra cached data
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IContainer.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @param {?=} firstCycle Object
 * @return {void}
 */
Ext.layout.container.IContainer.prototype.beginLayoutCycle = function(ownerContext, firstCycle) {};

/**
 * [Method] Adds layout s itemCls and owning Container s itemCls
 * @param {?=} item Object
 * @return {void}
 */
Ext.layout.container.IContainer.prototype.configureItem = function(item) {};

/**
 * [Method] Returns the container size that of the target
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem The owner's context item.
 * @param {boolean=} inDom Boolean True if the container size must be in the DOM.
 * @return {?} Object The size
 */
Ext.layout.container.IContainer.prototype.getContainerSize = function(ownerContext, inDom) {};

/**
 * [Method] Returns the element into which extra functional DOM elements can be inserted
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.container.IContainer.prototype.getElementTarget = function() {};

/**
 * [Method] Returns an array of child components either for a render phase Performed in the beforeLayout method of the layout s
 * @return {!Array<!Ext.IComponent>} Ext.Component[] of child components
 */
Ext.layout.container.IContainer.prototype.getLayoutItems = function() {};

/**
 * [Method] Returns the element into which rendering must take place
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.container.IContainer.prototype.getRenderTarget = function() {};

/**
 * [Method] Returns all items that are rendered
 * @return {!Array<?>} Array All matching items
 */
Ext.layout.container.IContainer.prototype.getRenderedItems = function() {};

/**
 * [Method] Returns the owner component s resize element
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.container.IContainer.prototype.getTarget = function() {};

/**
 * [Method] Returns all items that are both rendered and visible
 * @return {!Array<?>} Array All matching items
 */
Ext.layout.container.IContainer.prototype.getVisibleItems = function() {};

/**
 * [Method] Removes items in the childEls array based on the return value of a supplied test function
 * @param {?=} testFn Function The test function.
 * @return {void}
 */
Ext.layout.container.IContainer.prototype.removeChildEls = function(testFn) {};
/**
 * @extends {Ext.layout.ILayout}
 * @extends {Ext.util.IElementContainer}
 * @record
 * @struct
 */
Ext.layout.IContainerLayout = function() {};
 /** @type {string} */
Ext.layout.IContainerLayout.prototype.itemCls;
 /** @type {!Ext.IElement} */
Ext.layout.IContainerLayout.prototype.overflowPadderEl;

/**
 * [Method] Adds each argument passed to this method to the childEls array
 * @return {void}
 */
Ext.layout.IContainerLayout.prototype.addChildEls = function() {};

/**
 * [Method] In addition to work done by our base classes containers benefit from some extra cached data
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.IContainerLayout.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @param {?=} firstCycle Object
 * @return {void}
 */
Ext.layout.IContainerLayout.prototype.beginLayoutCycle = function(ownerContext, firstCycle) {};

/**
 * [Method] Adds layout s itemCls and owning Container s itemCls
 * @param {?=} item Object
 * @return {void}
 */
Ext.layout.IContainerLayout.prototype.configureItem = function(item) {};

/**
 * [Method] Returns the container size that of the target
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem The owner's context item.
 * @param {boolean=} inDom Boolean True if the container size must be in the DOM.
 * @return {?} Object The size
 */
Ext.layout.IContainerLayout.prototype.getContainerSize = function(ownerContext, inDom) {};

/**
 * [Method] Returns the element into which extra functional DOM elements can be inserted
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.IContainerLayout.prototype.getElementTarget = function() {};

/**
 * [Method] Returns an array of child components either for a render phase Performed in the beforeLayout method of the layout s
 * @return {!Array<!Ext.IComponent>} Ext.Component[] of child components
 */
Ext.layout.IContainerLayout.prototype.getLayoutItems = function() {};

/**
 * [Method] Returns the element into which rendering must take place
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.IContainerLayout.prototype.getRenderTarget = function() {};

/**
 * [Method] Returns all items that are rendered
 * @return {!Array<?>} Array All matching items
 */
Ext.layout.IContainerLayout.prototype.getRenderedItems = function() {};

/**
 * [Method] Returns the owner component s resize element
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.IContainerLayout.prototype.getTarget = function() {};

/**
 * [Method] Returns all items that are both rendered and visible
 * @return {!Array<?>} Array All matching items
 */
Ext.layout.IContainerLayout.prototype.getVisibleItems = function() {};

/**
 * [Method] Removes items in the childEls array based on the return value of a supplied test function
 * @param {?=} testFn Function The test function.
 * @return {void}
 */
Ext.layout.IContainerLayout.prototype.removeChildEls = function(testFn) {};
/**
 * @extends {Ext.layout.container.IContainer}
 * @record
 * @struct
 */
Ext.layout.container.IEditor = function() {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IEditor.prototype.calculate = function(ownerContext) {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.container.IEditor.prototype.getItemSizePolicy = function(item) {};
/**
 * @extends {Ext.layout.container.IContainer}
 * @record
 * @struct
 */
Ext.layout.container.IFit = function() {};
 /** @type {?} */
Ext.layout.container.IFit.prototype.defaultMargins;
 /** @type {string} */
Ext.layout.container.IFit.prototype.itemCls;

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @param {?=} firstCycle Object
 * @return {void}
 */
Ext.layout.container.IFit.prototype.beginLayoutCycle = function(ownerContext, firstCycle) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IFit.prototype.calculate = function(ownerContext) {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @param {?=} ownerSizeModel Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.container.IFit.prototype.getItemSizePolicy = function(item, ownerSizeModel) {};
/**
 * @extends {Ext.layout.container.IContainer}
 * @record
 * @struct
 */
Ext.layout.IFitLayout = function() {};
 /** @type {?} */
Ext.layout.IFitLayout.prototype.defaultMargins;
 /** @type {string} */
Ext.layout.IFitLayout.prototype.itemCls;

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {?=} ownerContext Object
 * @param {?=} firstCycle Object
 * @return {void}
 */
Ext.layout.IFitLayout.prototype.beginLayoutCycle = function(ownerContext, firstCycle) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.IFitLayout.prototype.calculate = function(ownerContext) {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @param {?=} ownerSizeModel Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.IFitLayout.prototype.getItemSizePolicy = function(item, ownerSizeModel) {};
/**
 * @extends {Ext.layout.container.IContainer}
 * @record
 * @struct
 */
Ext.layout.container.IForm = function() {};
 /** @type {?} */
Ext.layout.container.IForm.prototype.getScrollRangeFlags;

/**
 * [Method] All of the below methods are old methods moved here from Container layout TODO remove these methods once Form layout
 * @param {?=} ownerContext Object
 * @param {?=} firstCycle Object
 * @return {void}
 */
Ext.layout.container.IForm.prototype.beginLayoutCycle = function(ownerContext, firstCycle) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IForm.prototype.calculate = function(ownerContext) {};

/**
 * [Method] Handles overflow processing for a container
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem
 * @param {?=} containerSize Object
 * @param {number=} dimensions Number A bit mask for the overflow managed dimensions. The 0-bit is for width and the 1-bit is for height. In other words, a value of 1 would be only width, 2 would be only height and 3 would be both.
 * @return {void}
 */
Ext.layout.container.IForm.prototype.calculateOverflow = function(ownerContext, containerSize, dimensions) {};

/**
 * [Method] This method if implemented is called at the end of the cycle in which this layout completes by not setting done to
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.IForm.prototype.completeLayout = function(ownerContext) {};

/**
 * [Method] Creates an element that makes bottom right body padding consistent across browsers
 * @param {?=} out Object
 * @param {?=} renderData Object
 * @return {void}
 */
Ext.layout.container.IForm.prototype.doRenderPadder = function(out, renderData) {};

/**
 * [Method] Returns the container size that of the target
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem The owner's context item.
 * @param {boolean=} inDom Boolean True if the container size must be in the DOM.
 * @param {boolean=} ignoreOverflow Boolean if true scrollbar size will not be subtracted from container size.
 * @return {?} Object The size
 */
Ext.layout.container.IForm.prototype.getContainerSize = function(ownerContext, inDom, ignoreOverflow) {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.container.IForm.prototype.getItemSizePolicy = function(item) {};

/**
 * [Method] returns the overflow x style of the render target
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem
 * @return {string} String
 */
Ext.layout.container.IForm.prototype.getOverflowXStyle = function(ownerContext) {};

/**
 * [Method] returns the overflow y style of the render target
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem
 * @return {string} String
 */
Ext.layout.container.IForm.prototype.getOverflowYStyle = function(ownerContext) {};

/**
 * [Method] Returns the element into which rendering must take place
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.container.IForm.prototype.getRenderTarget = function() {};

/**
 * [Method] A one time initialization method called just before rendering
 * @return {void}
 */
Ext.layout.container.IForm.prototype.initLayout = function() {};

/**
 * [Method] Validates item is in the proper place in the dom
 * @param {?=} item Object
 * @param {?=} target Object
 * @param {?=} position Object
 * @return {void}
 */
Ext.layout.container.IForm.prototype.isValidParent = function(item, target, position) {};
/**
 * @extends {Ext.layout.container.IContainer}
 * @record
 * @struct
 */
Ext.layout.IFormLayout = function() {};
 /** @type {?} */
Ext.layout.IFormLayout.prototype.getScrollRangeFlags;

/**
 * [Method] All of the below methods are old methods moved here from Container layout TODO remove these methods once Form layout
 * @param {?=} ownerContext Object
 * @param {?=} firstCycle Object
 * @return {void}
 */
Ext.layout.IFormLayout.prototype.beginLayoutCycle = function(ownerContext, firstCycle) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.IFormLayout.prototype.calculate = function(ownerContext) {};

/**
 * [Method] Handles overflow processing for a container
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem
 * @param {?=} containerSize Object
 * @param {number=} dimensions Number A bit mask for the overflow managed dimensions. The 0-bit is for width and the 1-bit is for height. In other words, a value of 1 would be only width, 2 would be only height and 3 would be both.
 * @return {void}
 */
Ext.layout.IFormLayout.prototype.calculateOverflow = function(ownerContext, containerSize, dimensions) {};

/**
 * [Method] This method if implemented is called at the end of the cycle in which this layout completes by not setting done to
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.IFormLayout.prototype.completeLayout = function(ownerContext) {};

/**
 * [Method] Creates an element that makes bottom right body padding consistent across browsers
 * @param {?=} out Object
 * @param {?=} renderData Object
 * @return {void}
 */
Ext.layout.IFormLayout.prototype.doRenderPadder = function(out, renderData) {};

/**
 * [Method] Returns the container size that of the target
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem The owner's context item.
 * @param {boolean=} inDom Boolean True if the container size must be in the DOM.
 * @param {boolean=} ignoreOverflow Boolean if true scrollbar size will not be subtracted from container size.
 * @return {?} Object The size
 */
Ext.layout.IFormLayout.prototype.getContainerSize = function(ownerContext, inDom, ignoreOverflow) {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {?=} item Object
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.IFormLayout.prototype.getItemSizePolicy = function(item) {};

/**
 * [Method] returns the overflow x style of the render target
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem
 * @return {string} String
 */
Ext.layout.IFormLayout.prototype.getOverflowXStyle = function(ownerContext) {};

/**
 * [Method] returns the overflow y style of the render target
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem
 * @return {string} String
 */
Ext.layout.IFormLayout.prototype.getOverflowYStyle = function(ownerContext) {};

/**
 * [Method] Returns the element into which rendering must take place
 * @return {!Ext.IElement} Ext.Element
 */
Ext.layout.IFormLayout.prototype.getRenderTarget = function() {};

/**
 * [Method] A one time initialization method called just before rendering
 * @return {void}
 */
Ext.layout.IFormLayout.prototype.initLayout = function() {};

/**
 * [Method] Validates item is in the proper place in the dom
 * @param {?=} item Object
 * @param {?=} target Object
 * @param {?=} position Object
 * @return {void}
 */
Ext.layout.IFormLayout.prototype.isValidParent = function(item, target, position) {};
/**
 * @extends {Ext.layout.container.IBox}
 * @record
 * @struct
 */
Ext.layout.container.IHBox = function() {};
 /** @type {string} */
Ext.layout.container.IHBox.prototype.align;
 /** @type {?} */
Ext.layout.container.IHBox.prototype.alignRoundingMethod;
 /** @type {boolean} */
Ext.layout.container.IHBox.prototype.constrainAlign;
/**
 * @extends {Ext.layout.container.IBox}
 * @record
 * @struct
 */
Ext.layout.IHBoxLayout = function() {};
 /** @type {string} */
Ext.layout.IHBoxLayout.prototype.align;
 /** @type {?} */
Ext.layout.IHBoxLayout.prototype.alignRoundingMethod;
 /** @type {boolean} */
Ext.layout.IHBoxLayout.prototype.constrainAlign;
/**
 * @extends {Ext.layout.container.IContainer}
 * @record
 * @struct
 */
Ext.layout.container.ITable = function() {};
 /** @type {number} */
Ext.layout.container.ITable.prototype.columns;
 /** @type {?} */
Ext.layout.container.ITable.prototype.tableAttrs;
 /** @type {?} */
Ext.layout.container.ITable.prototype.tdAttrs;
 /** @type {?} */
Ext.layout.container.ITable.prototype.trAttrs;

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.container.ITable.prototype.calculate = function(ownerContext) {};

/**
 * [Method] This method if implemented is called after all layouts have completed
 * @return {void}
 */
Ext.layout.container.ITable.prototype.finalizeLayout = function() {};

/**
 * [Method] Returns an array of child components either for a render phase Performed in the beforeLayout method of the layout s
 * @return {!Array<!Ext.IComponent>} Ext.Component[] of child components
 */
Ext.layout.container.ITable.prototype.getLayoutItems = function() {};

/**
 * [Method] Validates item is in the proper place in the dom
 * @param {?=} item Object
 * @param {?=} target Object
 * @param {?=} rowIdx Object
 * @param {?=} cellIdx Object
 * @return {void}
 */
Ext.layout.container.ITable.prototype.isValidParent = function(item, target, rowIdx, cellIdx) {};
/**
 * @extends {Ext.layout.container.IContainer}
 * @record
 * @struct
 */
Ext.layout.ITableLayout = function() {};
 /** @type {number} */
Ext.layout.ITableLayout.prototype.columns;
 /** @type {?} */
Ext.layout.ITableLayout.prototype.tableAttrs;
 /** @type {?} */
Ext.layout.ITableLayout.prototype.tdAttrs;
 /** @type {?} */
Ext.layout.ITableLayout.prototype.trAttrs;

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.layout.ITableLayout.prototype.calculate = function(ownerContext) {};

/**
 * [Method] This method if implemented is called after all layouts have completed
 * @return {void}
 */
Ext.layout.ITableLayout.prototype.finalizeLayout = function() {};

/**
 * [Method] Returns an array of child components either for a render phase Performed in the beforeLayout method of the layout s
 * @return {!Array<!Ext.IComponent>} Ext.Component[] of child components
 */
Ext.layout.ITableLayout.prototype.getLayoutItems = function() {};

/**
 * [Method] Validates item is in the proper place in the dom
 * @param {?=} item Object
 * @param {?=} target Object
 * @param {?=} rowIdx Object
 * @param {?=} cellIdx Object
 * @return {void}
 */
Ext.layout.ITableLayout.prototype.isValidParent = function(item, target, rowIdx, cellIdx) {};
/**
 * @extends {Ext.layout.container.IBox}
 * @record
 * @struct
 */
Ext.layout.container.IVBox = function() {};
 /** @type {string} */
Ext.layout.container.IVBox.prototype.align;
 /** @type {?} */
Ext.layout.container.IVBox.prototype.alignRoundingMethod;
 /** @type {boolean} */
Ext.layout.container.IVBox.prototype.constrainAlign;
/**
 * @extends {Ext.layout.container.IBox}
 * @record
 * @struct
 */
Ext.layout.IVBoxLayout = function() {};
 /** @type {string} */
Ext.layout.IVBoxLayout.prototype.align;
 /** @type {?} */
Ext.layout.IVBoxLayout.prototype.alignRoundingMethod;
 /** @type {boolean} */
Ext.layout.IVBoxLayout.prototype.constrainAlign;
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.layout.IContext = function() {};
 /** @type {!Ext.util.IQueue} */
Ext.layout.IContext.prototype.layoutQueue;
 /** @type {number} */
Ext.layout.IContext.prototype.state;

/**
 * [Method] Flushes any pending writes to the DOM by calling each ContextItem in the flushQueue
 * @return {void}
 */
Ext.layout.IContext.prototype.flush = function() {};

/**
 * [Method] Returns the ContextItem for a component
 * @param {!Ext.IComponent=} cmp Ext.Component
 * @return {void}
 */
Ext.layout.IContext.prototype.getCmp = function(cmp) {};

/**
 * [Method] Returns the ContextItem for an element
 * @param {!Ext.layout.IContextItem=} parent Ext.layout.ContextItem
 * @param {!Ext.dom.IElement=} el Ext.dom.Element
 * @return {void}
 */
Ext.layout.IContext.prototype.getEl = function(parent, el) {};

/**
 * [Method] Invalidates one or more components layouts component and container
 * @param {?=} components Ext.Component/Array An array of Components or a single Component.
 * @param {boolean=} full Boolean True if all properties should be invalidated, otherwise only those calculated by the component should be invalidated.
 * @return {void}
 */
Ext.layout.IContext.prototype.invalidate = function(components, full) {};

/**
 * [Method] Removes the ContextItem for an element from the cache and from the parent s children array
 * @param {!Ext.layout.IContextItem=} parent Ext.layout.ContextItem
 * @param {!Ext.dom.IElement=} el Ext.dom.Element
 * @return {void}
 */
Ext.layout.IContext.prototype.removeEl = function(parent, el) {};

/**
 * [Method] Resets the given layout object
 * @param {?=} layout Object
 * @param {?=} ownerContext Object
 * @param {?=} firstTime Object
 * @return {void}
 */
Ext.layout.IContext.prototype.resetLayout = function(layout, ownerContext, firstTime) {};

/**
 * [Method] Runs the layout calculations
 * @return {boolean} Boolean True if all layouts were completed, false if not.
 */
Ext.layout.IContext.prototype.run = function() {};

/**
 * [Method] Performs one layout cycle by calling each layout in the layout queue
 * @return {boolean} Boolean True if some progress was made, false if not.
 */
Ext.layout.IContext.prototype.runCycle = function() {};

/**
 * [Method] Set the size of a component element or composite or an array of components or elements
 * @param {?=} items Ext.Component/Ext.Component[]/Ext.dom.Element/Ext.dom.Element[]/Ext.dom.CompositeElement The item(s) to size.
 * @param {number=} width Number The new width to set (ignored if undefined or NaN).
 * @param {number=} height Number The new height to set (ignored if undefined or NaN).
 * @return {void}
 */
Ext.layout.IContext.prototype.setItemSize = function(items, width, height) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.layout.IContextItem = function() {};
 /** @type {?} */
Ext.layout.IContextItem.prototype.state;
 /** @type {boolean} */
Ext.layout.IContextItem.prototype.wrapsComponent;

/**
 * [Method] Queue the addition of a class name or array of class names to this ContextItem s target when next flushed
 * @param {?=} newCls Object
 * @return {void}
 */
Ext.layout.IContextItem.prototype.addCls = function(newCls) {};

/**
 * [Method] Registers a layout in the block list for the given property
 * @param {!Ext.layout.ILayout=} layout Ext.layout.Layout
 * @param {string=} propName String The property name that blocked the layout (e.g., 'width').
 * @return {void}
 */
Ext.layout.IContextItem.prototype.block = function(layout, propName) {};

/**
 * [Method] clears the margin cache so that marginInfo get re read from the dom on the next call to getMarginInfo  This is neede
 * @return {void}
 */
Ext.layout.IContextItem.prototype.clearMarginCache = function() {};

/**
 * [Method] Registers a layout in the DOM block list for the given property
 * @param {!Ext.layout.ILayout=} layout Ext.layout.Layout
 * @param {string=} propName String The property name that blocked the layout (e.g., 'width').
 * @return {void}
 */
Ext.layout.IContextItem.prototype.domBlock = function(layout, propName) {};

/**
 * [Method] Flushes any updates in the dirty collection to the DOM
 * @return {void}
 */
Ext.layout.IContextItem.prototype.flush = function() {};

/**
 * [Method] Gets the border information for the element as an object with left top right and bottom properties holding border s
 * @return {?} Object
 */
Ext.layout.IContextItem.prototype.getBorderInfo = function() {};

/**
 * [Method] Returns a ClassList like object to buffer access to this item s element s classes
 * @return {void}
 */
Ext.layout.IContextItem.prototype.getClassList = function() {};

/**
 * [Method] Gets a property of this object if it is correct in the DOM
 * @param {string=} propName String The property name (e.g., 'width').
 * @return {?} Object The property value or undefined if not yet set or is dirty.
 */
Ext.layout.IContextItem.prototype.getDomProp = function(propName) {};

/**
 * [Method] Returns the context item for an owned element
 * @param {?=} nameOrEl String/Ext.dom.Element The element or the name of an owned element
 * @param {?=} owner Ext.layout.container.Container/Ext.Component The owner of the named element if the passed "nameOrEl" parameter is a String. Defaults to this ContextItem's "target" property. For more details on owned elements see childEls and renderSelectors
 * @return {!Ext.layout.IContextItem} Ext.layout.ContextItem
 */
Ext.layout.IContextItem.prototype.getEl = function(nameOrEl, owner) {};

/**
 * [Method] Gets the frame information for the element as an object with left top right and bottom properties holding border
 * @return {?} Object
 */
Ext.layout.IContextItem.prototype.getFrameInfo = function() {};

/**
 * [Method] Gets the margin information for the element as an object with left top right and bottom properties holding margin s
 * @return {?} Object
 */
Ext.layout.IContextItem.prototype.getMarginInfo = function() {};

/**
 * [Method] Gets the padding information for the element as an object with left top right and bottom properties holding padding
 * @return {?} Object
 */
Ext.layout.IContextItem.prototype.getPaddingInfo = function() {};

/**
 * [Method] Gets a property of this object
 * @param {string=} propName String The property name that blocked the layout (e.g., 'width').
 * @return {?} Object The property value or undefined if not yet set.
 */
Ext.layout.IContextItem.prototype.getProp = function(propName) {};

/**
 * [Method] Returns a style for this item
 * @param {string=} styleName String The CSS style name.
 * @return {?} Object The value of the DOM style (parsed as necessary).
 */
Ext.layout.IContextItem.prototype.getStyle = function(styleName) {};

/**
 * [Method] Returns styles for this item
 * @param {!Array<string>=} styleNames String[] The CSS style names.
 * @param {!Array<string>=} altNames String[] The alternate names for the returned styles. If given, these names must correspond one-for-one to the styleNames.
 * @return {?} Object The values of the DOM styles (parsed as necessary).
 */
Ext.layout.IContextItem.prototype.getStyles = function(styleNames, altNames) {};

/**
 * [Method] Returns true if the given property is correct in the DOM
 * @param {string=} propName String The property name (e.g., 'width').
 * @return {boolean} Boolean
 */
Ext.layout.IContextItem.prototype.hasDomProp = function(propName) {};

/**
 * [Method] Returns true if the given property has been set
 * @param {string=} propName String The property name (e.g., 'width').
 * @return {boolean} Boolean
 */
Ext.layout.IContextItem.prototype.hasProp = function(propName) {};

/**
 * [Method] Invalidates the component associated with this item
 * @param {?=} options Object An object describing how to handle the invalidation.
 * @return {void}
 */
Ext.layout.IContextItem.prototype.invalidate = function(options) {};

/**
 * [Method] Recovers a property value from the last computation and restores its value and dirty state
 * @param {string=} propName String The name of the property to recover.
 * @param {?=} oldProps Object The old "props" object from which to recover values.
 * @param {?=} oldDirty Object The old "dirty" object from which to recover state.
 * @return {void}
 */
Ext.layout.IContextItem.prototype.recoverProp = function(propName, oldProps, oldDirty) {};

/**
 * [Method] Queue the removal of a class name or array of class names from this ContextItem s target when next flushed
 * @param {?=} removeCls Object
 * @return {void}
 */
Ext.layout.IContextItem.prototype.removeCls = function(removeCls) {};

/**
 * [Method] Removes a cached ContextItem that was created using getEl
 * @param {?=} nameOrEl String/Ext.dom.Element The element or the name of an owned element
 * @param {?=} owner Ext.layout.container.Container/Ext.Component The owner of the named element if the passed "nameOrEl" parameter is a String. Defaults to this ContextItem's "target" property.
 * @return {void}
 */
Ext.layout.IContextItem.prototype.removeEl = function(nameOrEl, owner) {};

/**
 * [Method] Queue the setting of a DOM attribute on this ContextItem s target when next flushed
 * @param {?=} name Object
 * @param {?=} value Object
 * @return {void}
 */
Ext.layout.IContextItem.prototype.setAttribute = function(name, value) {};

/**
 * [Method] Sets the contentHeight property
 * @param {?=} height Object
 * @param {?=} measured Object
 * @return {void}
 */
Ext.layout.IContextItem.prototype.setContentHeight = function(height, measured) {};

/**
 * [Method] Sets the contentWidth and contentHeight properties
 * @param {?=} width Object
 * @param {?=} height Object
 * @param {?=} measured Object
 * @return {void}
 */
Ext.layout.IContextItem.prototype.setContentSize = function(width, height, measured) {};

/**
 * [Method] Sets the contentWidth property
 * @param {?=} width Object
 * @param {?=} measured Object
 * @return {void}
 */
Ext.layout.IContextItem.prototype.setContentWidth = function(width, measured) {};

/**
 * [Method] Sets the height and constrains the height to min maxHeight range
 * @param {number=} height Number The height.
 * @param {boolean=} dirty Boolean Specifies if the value is currently in the DOM. A value of false indicates that the value is already in the DOM.
 * @return {number} Number The actual height after constraining.
 */
Ext.layout.IContextItem.prototype.setHeight = function(height, dirty) {};

/**
 * [Method] Sets a property value
 * @param {string=} propName String The property name (e.g., 'width').
 * @param {?=} value Object The new value of the property.
 * @param {boolean=} dirty Boolean Optionally specifies if the value is currently in the DOM (default is true which indicates the value is not in the DOM and must be flushed at some point).
 * @return {number} Number 1 if this call specified the property value, 0 if not.
 */
Ext.layout.IContextItem.prototype.setProp = function(propName, value, dirty) {};

/**
 * [Method] Sets the height and constrains the width to min maxWidth range
 * @param {number=} width Number The width.
 * @param {boolean=} dirty Boolean Specifies if the value is currently in the DOM. A value of false indicates that the value is already in the DOM.
 * @return {number} Number The actual width after constraining.
 */
Ext.layout.IContextItem.prototype.setWidth = function(width, dirty) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.layout.ILayout = function() {};
 /** @type {boolean} */
Ext.layout.ILayout.prototype.done;
 /** @type {boolean} */
Ext.layout.ILayout.prototype.isLayout;

/**
 * [Method] Removes layout s itemCls and owning Container s itemCls
 * @param {?=} item Object
 * @return {void}
 */
Ext.layout.ILayout.prototype.afterRemove = function(item) {};

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem The context item for the layout's owner component.
 * @return {void}
 */
Ext.layout.ILayout.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called before any calculation cycles to reset DOM values and prepare for calculation
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem The context item for the layout's owner component.
 * @return {void}
 */
Ext.layout.ILayout.prototype.beginLayoutCycle = function(ownerContext) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem The context item for the layout's owner component.
 * @return {void}
 */
Ext.layout.ILayout.prototype.calculate = function(ownerContext) {};

/**
 * [Method] This method if implemented is called at the end of the cycle in which this layout completes by not setting done to
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem The context item for the layout's owner component.
 * @return {void}
 */
Ext.layout.ILayout.prototype.completeLayout = function(ownerContext) {};

/**
 * [Method] Called before an item is rendered to allow the layout to configure the item
 * @param {!Ext.IComponent=} item Ext.Component The item to be configured
 * @return {void}
 */
Ext.layout.ILayout.prototype.configureItem = function(item) {};

/**
 * [Method] Destroys this layout
 * @return {void}
 */
Ext.layout.ILayout.prototype.destroy = function() {};

/**
 * [Method] This method if implemented is called after all layouts have completed
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem The context item for the layout's owner component.
 * @return {void}
 */
Ext.layout.ILayout.prototype.finalizeLayout = function(ownerContext) {};

/**
 * [Method] This method is called after all layouts are complete and their calculations flushed to the DOM
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem The context item for the layout's owner component.
 * @return {void}
 */
Ext.layout.ILayout.prototype.finishedLayout = function(ownerContext) {};

/**
 * [Method] Returns an object describing how this layout manages the size of the given component
 * @param {!Ext.IComponent=} item Ext.Component
 * @return {!Ext.layout.ISizePolicy} Ext.layout.SizePolicy An object describing the sizing done by the layout for this item.
 */
Ext.layout.ILayout.prototype.getItemSizePolicy = function(item) {};

/**
 * [Method] Returns the set of items to layout empty by default
 * @return {void}
 */
Ext.layout.ILayout.prototype.getLayoutItems = function() {};

/**
 * [Method] A one time initialization method called just before rendering
 * @return {void}
 */
Ext.layout.ILayout.prototype.initLayout = function() {};

/**
 * [Method] Validates item is in the proper place in the dom
 * @param {?=} item Object
 * @param {?=} target Object
 * @param {?=} position Object
 * @return {void}
 */
Ext.layout.ILayout.prototype.isValidParent = function(item, target, position) {};

/**
 * [Method] This method if implemented is called after all layouts are finished and all have a lastComponentSize cached
 * @param {!Ext.layout.IContextItem=} ownerContext Ext.layout.ContextItem The context item for the layout's owner component.
 * @return {void}
 */
Ext.layout.ILayout.prototype.notifyOwner = function(ownerContext) {};

/**
 * [Method] This method is called when a child item changes in some way
 * @param {!Ext.IComponent=} child Ext.Component The child item that has changed.
 * @return {boolean} Boolean True if this layout has handled the content change.
 */
Ext.layout.ILayout.prototype.onContentChange = function(child) {};

/**
 * [Method] Iterates over all passed items ensuring they are rendered
 * @param {?=} items Object
 * @param {?=} target Object
 * @return {void}
 */
Ext.layout.ILayout.prototype.renderItems = function(items, target) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.layout.ISizeModel = function() {};
 /** @type {boolean} */
Ext.layout.ISizeModel.prototype.auto;
 /** @type {boolean} */
Ext.layout.ISizeModel.prototype.calculated;
 /** @type {boolean} */
Ext.layout.ISizeModel.prototype.calculatedFromConfigured;
 /** @type {boolean} */
Ext.layout.ISizeModel.prototype.calculatedFromNatural;
 /** @type {boolean} */
Ext.layout.ISizeModel.prototype.calculatedFromShrinkWrap;
 /** @type {boolean} */
Ext.layout.ISizeModel.prototype.configured;
 /** @type {boolean} */
Ext.layout.ISizeModel.prototype.constrainedMax;
 /** @type {boolean} */
Ext.layout.ISizeModel.prototype.constrainedMin;
 /** @type {boolean} */
Ext.layout.ISizeModel.prototype.fixed;
 /** @type {string} */
Ext.layout.ISizeModel.prototype.name;
 /** @type {?} */
Ext.layout.ISizeModel.prototype.names;
 /** @type {boolean} */
Ext.layout.ISizeModel.prototype.natural;
 /** @type {number} */
Ext.layout.ISizeModel.prototype.ordinal;
 /** @type {!Array<?>} */
Ext.layout.ISizeModel.prototype.pairsByHeightOrdinal;
 /** @type {boolean} */
Ext.layout.ISizeModel.prototype.shrinkWrap;
/**
 * @record
 * @struct
 */
Ext.layout.ISizePolicy = function() {};
 /** @type {boolean} */
Ext.layout.ISizePolicy.prototype.readsHeight;
 /** @type {boolean} */
Ext.layout.ISizePolicy.prototype.readsWidth;
 /** @type {boolean} */
Ext.layout.ISizePolicy.prototype.setsHeight;
 /** @type {boolean} */
Ext.layout.ISizePolicy.prototype.setsWidth;
/**
 * @record
 * @struct
 */
Ext.ILoader = function() {};
/**
 * @constructor
 * @struct
 */
Ext.Loader = function() {};
 /** @type {boolean} */
Ext.Loader.disableCaching;
 /** @type {string} */
Ext.Loader.disableCachingParam;
 /** @type {boolean} */
Ext.Loader.enabled;
 /** @type {boolean} */
Ext.Loader.garbageCollect;
 /** @type {?} */
Ext.Loader.paths;
 /** @type {boolean} */
Ext.Loader.preserveScripts;
 /** @type {boolean} */
Ext.Loader.scriptChainDelay;
 /** @type {string} */
Ext.Loader.scriptCharset;
 /** @type {!Array<?>} */
Ext.Loader.history;

/**
 * [Method] Sets a batch of path entries
 * @param {!Ext.Object=} paths Object a set of className: path mappings
 * @return {!Ext.ILoader} Ext.Loader this
 */
Ext.Loader.addClassPathMappings = function(paths) {};

/**
 * [Method] Explicitly exclude files from being loaded
 * @param {!Array<?>=} excludes Array
 * @return {?} Object object contains require method for chaining
 */
Ext.Loader.exclude = function(excludes) {};

/**
 * [Method] Get the config value corresponding to the specified name
 * @param {string=} name String The config property name
 * @return {?} Object
 */
Ext.Loader.getConfig = function(name) {};

/**
 * [Method] Translates a className to a file path by adding the the proper prefix and converting the  s to  s
 * @param {string=} className String
 * @return {string} String path
 */
Ext.Loader.getPath = function(className) {};

/**
 * [Method] Loads the specified script URL and calls the supplied callbacks
 * @param {?=} options Object/String The options object or simply the URL to load.
 * @return {void}
 */
Ext.Loader.loadScript = function(options) {};

/**
 * [Method] Add a new listener to be executed when all required scripts are fully loaded
 * @param {?=} fn Function The function callback to be executed
 * @param {?=} scope Object The execution scope (this) of the callback function
 * @param {boolean=} withDomReady Boolean Whether or not to wait for document dom ready as well
 * @return {void}
 */
Ext.Loader.onReady = function(fn, scope, withDomReady) {};

/**
 * [Method] Loads all classes by the given names and all their direct dependencies optionally executes the given callback functi
 * @param {?=} expressions String/Array Can either be a string or an array of string
 * @param {?=} fn Function The callback function
 * @param {?=} scope Object The execution scope (this) of the callback function
 * @param {?=} excludes String/Array Classes to be excluded, useful when being used with expressions
 * @return {void}
 */
Ext.Loader.require = function(expressions, fn, scope, excludes) {};

/**
 * [Method] Set the configuration for the loader
 * @param {?=} config Object The config object to override the default values
 * @return {!Ext.ILoader} Ext.Loader this
 */
Ext.Loader.setConfig = function(config) {};

/**
 * [Method] Sets the path of a namespace
 * @param {?=} name String/Object See flexSetter
 * @param {string=} path String See flexSetter
 * @return {!Ext.ILoader} Ext.Loader this
 */
Ext.Loader.setPath = function(name, path) {};

/**
 * [Method] Synchronously loads all classes by the given names and all their direct dependencies optionally executes the given c
 * @param {?=} expressions String/Array Can either be a string or an array of string
 * @param {?=} fn Function The callback function
 * @param {?=} scope Object The execution scope (this) of the callback function
 * @param {?=} excludes String/Array Classes to be excluded, useful when being used with expressions
 * @return {void}
 */
Ext.Loader.syncRequire = function(expressions, fn, scope, excludes) {};
/**
 * @extends {Ext.IComponent}
 * @extends {Ext.util.IFloating}
 * @extends {Ext.util.IBindable}
 * @record
 * @struct
 */
Ext.ILoadMask = function() {};
 /** @type {string} */
Ext.ILoadMask.prototype.baseCls;
 /** @type {string} */
Ext.ILoadMask.prototype.maskCls;
 /** @type {string} */
Ext.ILoadMask.prototype.msg;
 /** @type {string} */
Ext.ILoadMask.prototype.msgCls;
 /** @type {?} */
Ext.ILoadMask.prototype.renderTpl;
 /** @type {!Ext.data.IStore} */
Ext.ILoadMask.prototype.store;
 /** @type {!Ext.IComponent} */
Ext.ILoadMask.prototype.target;
 /** @type {boolean} */
Ext.ILoadMask.prototype.useMsg;
 /** @type {boolean} */
Ext.ILoadMask.prototype.useTargetEl;

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.ILoadMask.prototype.afterRender = function() {};

/**
 * [Method] Invoked after the Component is shown after onShow is called
 * @return {void}
 */
Ext.ILoadMask.prototype.afterShow = function() {};

/**
 * [Method] Changes the data store bound to this LoadMask
 * @param {!Ext.data.IStore=} store Ext.data.Store The store to bind to this LoadMask
 * @return {void}
 */
Ext.ILoadMask.prototype.bindStore = function(store) {};

/**
 * [Method] Binds listeners for this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to bind to
 * @return {void}
 */
Ext.ILoadMask.prototype.bindStoreListeners = function(store) {};

/**
 * [Method] Center this Component in its container
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.ILoadMask.prototype.center = function() {};

/**
 * [Method] Moves this floating Component into a constrain region
 * @param {?=} constrainTo String/HTMLElement/Ext.Element/Ext.util.Region The Element or Region into which this Component is to be constrained. Defaults to the element into which this floating Component was rendered.
 * @return {void}
 */
Ext.ILoadMask.prototype.doConstrain = function(constrainTo) {};

/**
 * [Method] Gets the current store instance
 * @return {!Ext.data.IAbstractStore} Ext.data.AbstractStore The store, null if one does not exist.
 */
Ext.ILoadMask.prototype.getStore = function() {};

/**
 * [Method] Gets the listeners to bind to a new store
 * @param {?=} store Object
 * @return {?} Object The listeners to be bound to the store in object literal form. The scope may be omitted, it is assumed to be the current instance.
 */
Ext.ILoadMask.prototype.getStoreListeners = function(store) {};

/**
 * [Method] Hides this Component setting it to invisible using the configured hideMode
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.ILoadMask.prototype.hide = function() {};

/**
 * [Method] Template method it is called when a new store is bound to the current instance
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store being bound
 * @param {boolean=} initial Boolean True if this store is being bound as initialization of the instance.
 * @return {void}
 */
Ext.ILoadMask.prototype.onBindStore = function(store, initial) {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.ILoadMask.prototype.onDestroy = function() {};

/**
 * [Method] Allows addition of behavior to the disable operation
 * @return {void}
 */
Ext.ILoadMask.prototype.onDisable = function() {};

/**
 * [Method] Possibly animates down to a target element
 * @return {void}
 */
Ext.ILoadMask.prototype.onHide = function() {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.ILoadMask.prototype.onShow = function() {};

/**
 * [Method] Template method it is called when an existing store is unbound from the current instance
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store being unbound
 * @param {boolean=} initial Boolean True if this store is being bound as initialization of the instance.
 * @return {void}
 */
Ext.ILoadMask.prototype.onUnbindStore = function(store, initial) {};

/**
 * [Method] This method is called internally by Ext ZIndexManager to signal that a floating Component has either been moved to th
 * @param {boolean=} active Boolean True to activate the Component, false to deactivate it.
 * @param {!Ext.IComponent=} newActive Ext.Component The newly active Component which is taking over topmost zIndex position.
 * @return {void}
 */
Ext.ILoadMask.prototype.setActive = function(active, newActive) {};

/**
 * [Method] Shows this Component rendering it first if autoRender or floating are true
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.ILoadMask.prototype.show = function() {};

/**
 * [Method] Sends this Component to the back of lower z index than any other visible windows
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.ILoadMask.prototype.toBack = function() {};

/**
 * [Method] Brings this floating Component to the front of any other visible floating Components managed by the same ZIndexManag
 * @param {boolean=} preventFocus Boolean Specify true to prevent the Component from being focused.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.ILoadMask.prototype.toFront = function(preventFocus) {};

/**
 * [Method] Unbinds listeners from this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to unbind from
 * @return {void}
 */
Ext.ILoadMask.prototype.unbindStoreListeners = function(store) {};
/** @const */
Ext.menu = {};
/**
 * @extends {Ext.menu.IItem}
 * @record
 * @struct
 */
Ext.menu.ICheckItem = function() {};
 /** @type {boolean} */
Ext.menu.ICheckItem.prototype.checkChangeDisabled;
 /** @type {?} */
Ext.menu.ICheckItem.prototype.checkHandler;
 /** @type {boolean} */
Ext.menu.ICheckItem.prototype.checked;
 /** @type {string} */
Ext.menu.ICheckItem.prototype.checkedCls;
 /** @type {string} */
Ext.menu.ICheckItem.prototype.group;
 /** @type {string} */
Ext.menu.ICheckItem.prototype.groupCls;
 /** @type {boolean} */
Ext.menu.ICheckItem.prototype.hideOnClick;
 /** @type {?} */
Ext.menu.ICheckItem.prototype.renderTpl;
 /** @type {?} */
Ext.menu.ICheckItem.prototype.scope;
 /** @type {string} */
Ext.menu.ICheckItem.prototype.uncheckedCls;

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.menu.ICheckItem.prototype.afterRender = function() {};

/**
 * [Method] Disables just the checkbox functionality of this menu Item
 * @return {void}
 */
Ext.menu.ICheckItem.prototype.disableCheckChange = function() {};

/**
 * [Method] Reenables the checkbox functionality of this menu item after having been disabled by disableCheckChange
 * @return {void}
 */
Ext.menu.ICheckItem.prototype.enableCheckChange = function() {};

/**
 * [Method] The initComponent template method is an important initialization step for a Component
 * @return {void}
 */
Ext.menu.ICheckItem.prototype.initComponent = function() {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.menu.ICheckItem.prototype.onDestroy = function() {};

/**
 * [Method] Sets the checked state of the item
 * @param {boolean=} checked Boolean True to check, false to uncheck
 * @param {boolean=} suppressEvents Boolean True to prevent firing the checkchange events.
 * @return {void}
 */
Ext.menu.ICheckItem.prototype.setChecked = function(checked, suppressEvents) {};
/**
 * @extends {Ext.menu.IMenu}
 * @record
 * @struct
 */
Ext.menu.IColorPicker = function() {};
 /** @type {boolean} */
Ext.menu.IColorPicker.prototype.hideOnClick;
 /** @type {string} */
Ext.menu.IColorPicker.prototype.pickerId;
 /** @type {!Ext.picker.IColor} */
Ext.menu.IColorPicker.prototype.picker;
/**
 * @extends {Ext.menu.IMenu}
 * @record
 * @struct
 */
Ext.menu.IDatePicker = function() {};
 /** @type {boolean} */
Ext.menu.IDatePicker.prototype.hideOnClick;
 /** @type {string} */
Ext.menu.IDatePicker.prototype.pickerId;
 /** @type {!Ext.picker.IDate} */
Ext.menu.IDatePicker.prototype.picker;
/**
 * @extends {Ext.IComponent}
 * @extends {Ext.IQueryable}
 * @record
 * @struct
 */
Ext.menu.IItem = function() {};
 /** @type {string} */
Ext.menu.IItem.prototype.activeCls;
 /** @type {boolean} */
Ext.menu.IItem.prototype.canActivate;
 /** @type {number} */
Ext.menu.IItem.prototype.clickHideDelay;
 /** @type {boolean} */
Ext.menu.IItem.prototype.destroyMenu;
 /** @type {string} */
Ext.menu.IItem.prototype.disabledCls;
 /** @type {?} */
Ext.menu.IItem.prototype.glyph;
 /** @type {?} */
Ext.menu.IItem.prototype.handler;
 /** @type {boolean} */
Ext.menu.IItem.prototype.hideOnClick;
 /** @type {string} */
Ext.menu.IItem.prototype.href;
 /** @type {string} */
Ext.menu.IItem.prototype.hrefTarget;
 /** @type {string} */
Ext.menu.IItem.prototype.icon;
 /** @type {string} */
Ext.menu.IItem.prototype.iconCls;
 /** @type {?} */
Ext.menu.IItem.prototype.menu;
 /** @type {string} */
Ext.menu.IItem.prototype.menuAlign;
 /** @type {number} */
Ext.menu.IItem.prototype.menuExpandDelay;
 /** @type {number} */
Ext.menu.IItem.prototype.menuHideDelay;
 /** @type {boolean} */
Ext.menu.IItem.prototype.plain;
 /** @type {?} */
Ext.menu.IItem.prototype.renderTpl;
 /** @type {string} */
Ext.menu.IItem.prototype.text;
 /** @type {?} */
Ext.menu.IItem.prototype.tooltip;
 /** @type {string} */
Ext.menu.IItem.prototype.tooltipType;
 /** @type {boolean} */
Ext.menu.IItem.prototype.activated;
 /** @type {boolean} */
Ext.menu.IItem.prototype.maskOnDisable;
 /** @type {!Ext.menu.IMenu} */
Ext.menu.IItem.prototype.parentMenu;

/**
 * [Method] Retrieves the first direct child of this container which matches the passed selector or component
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching child Ext.Component (or null if no match was found).
 */
Ext.menu.IItem.prototype.child = function(selector) {};

/**
 * [Method] Retrieves the first descendant of this container which matches the passed selector
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector or Ext.Component. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching descendant Ext.Component (or null if no match was found).
 */
Ext.menu.IItem.prototype.down = function(selector) {};

/**
 * [Method] The initComponent template method is an important initialization step for a Component
 * @return {void}
 */
Ext.menu.IItem.prototype.initComponent = function() {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.menu.IItem.prototype.onDestroy = function() {};

/**
 * [Method] Method to manage awareness of when components are removed from their respective Container firing a removed event
 * @return {void}
 */
Ext.menu.IItem.prototype.onRemoved = function() {};

/**
 * [Method] Template method called when this Component s DOM structure is created
 * @return {void}
 */
Ext.menu.IItem.prototype.onRender = function() {};

/**
 * [Method] Retrieves all descendant components which match the passed selector
 * @param {string=} selector String Selector complying to an Ext.ComponentQuery selector. If no selector is specified all items will be returned.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components which matched the selector
 */
Ext.menu.IItem.prototype.query = function(selector) {};

/**
 * [Method] Retrieves all descendant components which match the passed function
 * @param {?=} fn Function The matcher function. It will be called with a single argument, the component being tested.
 * @param {?=} scope Object The scope in which to run the function. If not specified, it will default to the active component.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components matched by the passed function
 */
Ext.menu.IItem.prototype.queryBy = function(fn, scope) {};

/**
 * [Method] Finds a component at any level under this container matching the id itemId
 * @param {string=} id String The id to find
 * @return {!Ext.IComponent} Ext.Component The matching id, null if not found
 */
Ext.menu.IItem.prototype.queryById = function(id) {};

/**
 * [Method] Sets the click handler of this item
 * @param {?=} fn Function The handler function
 * @param {?=} scope Object The scope of the handler function
 * @return {void}
 */
Ext.menu.IItem.prototype.setHandler = function(fn, scope) {};

/**
 * [Method] Sets the icon on this item
 * @param {string=} icon String The new icon
 * @return {void}
 */
Ext.menu.IItem.prototype.setIcon = function(icon) {};

/**
 * [Method] Sets the iconCls of this item
 * @param {string=} iconCls String The CSS class to set to iconCls
 * @return {void}
 */
Ext.menu.IItem.prototype.setIconCls = function(iconCls) {};

/**
 * [Method] Set a child menu for this item
 * @param {?=} menu Ext.menu.Menu/Object A menu, or menu configuration. null may be passed to remove the menu.
 * @param {boolean=} destroyMenu Boolean True to destroy any existing menu. False to prevent destruction. If not specified, the destroyMenu configuration will be used.
 * @return {void}
 */
Ext.menu.IItem.prototype.setMenu = function(menu, destroyMenu) {};

/**
 * [Method] Sets the text of this item
 * @param {string=} text String The text
 * @return {void}
 */
Ext.menu.IItem.prototype.setText = function(text) {};

/**
 * [Method] Sets the tooltip for this menu item
 * @param {?=} tooltip String/Object This may be:  String : A string to be used as innerHTML (html tags are accepted) to show in a tooltip Object : A configuration object for Ext.tip.QuickTipManager.register.
 * @return {!Ext.menu.IItem} Ext.menu.Item this
 */
Ext.menu.IItem.prototype.setTooltip = function(tooltip) {};
/**
 * @extends {Ext.IComponent}
 * @extends {Ext.IQueryable}
 * @record
 * @struct
 */
Ext.menu.ITextItem = function() {};
 /** @type {string} */
Ext.menu.ITextItem.prototype.activeCls;
 /** @type {boolean} */
Ext.menu.ITextItem.prototype.canActivate;
 /** @type {number} */
Ext.menu.ITextItem.prototype.clickHideDelay;
 /** @type {boolean} */
Ext.menu.ITextItem.prototype.destroyMenu;
 /** @type {string} */
Ext.menu.ITextItem.prototype.disabledCls;
 /** @type {?} */
Ext.menu.ITextItem.prototype.glyph;
 /** @type {?} */
Ext.menu.ITextItem.prototype.handler;
 /** @type {boolean} */
Ext.menu.ITextItem.prototype.hideOnClick;
 /** @type {string} */
Ext.menu.ITextItem.prototype.href;
 /** @type {string} */
Ext.menu.ITextItem.prototype.hrefTarget;
 /** @type {string} */
Ext.menu.ITextItem.prototype.icon;
 /** @type {string} */
Ext.menu.ITextItem.prototype.iconCls;
 /** @type {?} */
Ext.menu.ITextItem.prototype.menu;
 /** @type {string} */
Ext.menu.ITextItem.prototype.menuAlign;
 /** @type {number} */
Ext.menu.ITextItem.prototype.menuExpandDelay;
 /** @type {number} */
Ext.menu.ITextItem.prototype.menuHideDelay;
 /** @type {boolean} */
Ext.menu.ITextItem.prototype.plain;
 /** @type {?} */
Ext.menu.ITextItem.prototype.renderTpl;
 /** @type {string} */
Ext.menu.ITextItem.prototype.text;
 /** @type {?} */
Ext.menu.ITextItem.prototype.tooltip;
 /** @type {string} */
Ext.menu.ITextItem.prototype.tooltipType;
 /** @type {boolean} */
Ext.menu.ITextItem.prototype.activated;
 /** @type {boolean} */
Ext.menu.ITextItem.prototype.maskOnDisable;
 /** @type {!Ext.menu.IMenu} */
Ext.menu.ITextItem.prototype.parentMenu;

/**
 * [Method] Retrieves the first direct child of this container which matches the passed selector or component
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching child Ext.Component (or null if no match was found).
 */
Ext.menu.ITextItem.prototype.child = function(selector) {};

/**
 * [Method] Retrieves the first descendant of this container which matches the passed selector
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector or Ext.Component. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching descendant Ext.Component (or null if no match was found).
 */
Ext.menu.ITextItem.prototype.down = function(selector) {};

/**
 * [Method] The initComponent template method is an important initialization step for a Component
 * @return {void}
 */
Ext.menu.ITextItem.prototype.initComponent = function() {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.menu.ITextItem.prototype.onDestroy = function() {};

/**
 * [Method] Method to manage awareness of when components are removed from their respective Container firing a removed event
 * @return {void}
 */
Ext.menu.ITextItem.prototype.onRemoved = function() {};

/**
 * [Method] Template method called when this Component s DOM structure is created
 * @return {void}
 */
Ext.menu.ITextItem.prototype.onRender = function() {};

/**
 * [Method] Retrieves all descendant components which match the passed selector
 * @param {string=} selector String Selector complying to an Ext.ComponentQuery selector. If no selector is specified all items will be returned.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components which matched the selector
 */
Ext.menu.ITextItem.prototype.query = function(selector) {};

/**
 * [Method] Retrieves all descendant components which match the passed function
 * @param {?=} fn Function The matcher function. It will be called with a single argument, the component being tested.
 * @param {?=} scope Object The scope in which to run the function. If not specified, it will default to the active component.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components matched by the passed function
 */
Ext.menu.ITextItem.prototype.queryBy = function(fn, scope) {};

/**
 * [Method] Finds a component at any level under this container matching the id itemId
 * @param {string=} id String The id to find
 * @return {!Ext.IComponent} Ext.Component The matching id, null if not found
 */
Ext.menu.ITextItem.prototype.queryById = function(id) {};

/**
 * [Method] Sets the click handler of this item
 * @param {?=} fn Function The handler function
 * @param {?=} scope Object The scope of the handler function
 * @return {void}
 */
Ext.menu.ITextItem.prototype.setHandler = function(fn, scope) {};

/**
 * [Method] Sets the icon on this item
 * @param {string=} icon String The new icon
 * @return {void}
 */
Ext.menu.ITextItem.prototype.setIcon = function(icon) {};

/**
 * [Method] Sets the iconCls of this item
 * @param {string=} iconCls String The CSS class to set to iconCls
 * @return {void}
 */
Ext.menu.ITextItem.prototype.setIconCls = function(iconCls) {};

/**
 * [Method] Set a child menu for this item
 * @param {?=} menu Ext.menu.Menu/Object A menu, or menu configuration. null may be passed to remove the menu.
 * @param {boolean=} destroyMenu Boolean True to destroy any existing menu. False to prevent destruction. If not specified, the destroyMenu configuration will be used.
 * @return {void}
 */
Ext.menu.ITextItem.prototype.setMenu = function(menu, destroyMenu) {};

/**
 * [Method] Sets the text of this item
 * @param {string=} text String The text
 * @return {void}
 */
Ext.menu.ITextItem.prototype.setText = function(text) {};

/**
 * [Method] Sets the tooltip for this menu item
 * @param {?=} tooltip String/Object This may be:  String : A string to be used as innerHTML (html tags are accepted) to show in a tooltip Object : A configuration object for Ext.tip.QuickTipManager.register.
 * @return {!Ext.menu.IItem} Ext.menu.Item this
 */
Ext.menu.ITextItem.prototype.setTooltip = function(tooltip) {};
/**
 * @extends {Ext.util.IKeyNav}
 * @record
 * @struct
 */
Ext.menu.IKeyNav = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.menu.IManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.menu.Manager = function() {};
 /** @type {!Ext.IClass} */
Ext.menu.Manager.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.menu.Manager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.menu.Manager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.menu.Manager.callSuper = function(args) {};

/**
 * [Method] Returns a Ext menu Menu object
 * @param {?=} menu String/Object The string menu id, an existing menu object reference, or a Menu config that will be used to generate and return a new Menu this.
 * @return {!Ext.menu.IMenu} Ext.menu.Menu The specified menu, or null if none are found
 */
Ext.menu.Manager.get = function(menu) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.menu.Manager.getInitialConfig = function(name) {};

/**
 * [Method] Hides all menus that are currently visible
 * @return {boolean} Boolean success True if any active menus were hidden.
 */
Ext.menu.Manager.hideAll = function() {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.menu.Manager.initConfig = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.menu.Manager.statics = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.menu.IMenuMgr = function() {};
/**
 * @constructor
 * @struct
 */
Ext.menu.MenuMgr = function() {};
 /** @type {!Ext.IClass} */
Ext.menu.MenuMgr.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.menu.MenuMgr.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.menu.MenuMgr.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.menu.MenuMgr.callSuper = function(args) {};

/**
 * [Method] Returns a Ext menu Menu object
 * @param {?=} menu String/Object The string menu id, an existing menu object reference, or a Menu config that will be used to generate and return a new Menu this.
 * @return {!Ext.menu.IMenu} Ext.menu.Menu The specified menu, or null if none are found
 */
Ext.menu.MenuMgr.get = function(menu) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.menu.MenuMgr.getInitialConfig = function(name) {};

/**
 * [Method] Hides all menus that are currently visible
 * @return {boolean} Boolean success True if any active menus were hidden.
 */
Ext.menu.MenuMgr.hideAll = function() {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.menu.MenuMgr.initConfig = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.menu.MenuMgr.statics = function() {};
/**
 * @extends {Ext.panel.IPanel}
 * @record
 * @struct
 */
Ext.menu.IMenu = function() {};
 /** @type {boolean} */
Ext.menu.IMenu.prototype.allowOtherMenus;
 /** @type {boolean} */
Ext.menu.IMenu.prototype.enableKeyNav;
 /** @type {boolean} */
Ext.menu.IMenu.prototype.floating;
 /** @type {boolean} */
Ext.menu.IMenu.prototype.hidden;
 /** @type {string} */
Ext.menu.IMenu.prototype.hideMode;
 /** @type {boolean} */
Ext.menu.IMenu.prototype.ignoreParentClicks;
 /** @type {number} */
Ext.menu.IMenu.prototype.minWidth;
 /** @type {boolean} */
Ext.menu.IMenu.prototype.plain;
 /** @type {boolean} */
Ext.menu.IMenu.prototype.showSeparator;
 /** @type {boolean} */
Ext.menu.IMenu.prototype.isMenu;
 /** @type {!Ext.menu.IMenu} */
Ext.menu.IMenu.prototype.parentMenu;

/**
 * [Method] Invoked after the Component is shown after onShow is called
 * @return {void}
 */
Ext.menu.IMenu.prototype.afterShow = function() {};

/**
 * [Method] Invoked before the Component is shown
 * @return {void}
 */
Ext.menu.IMenu.prototype.beforeShow = function() {};

/**
 * [Method] Returns whether a menu item can be activated or not
 * @param {?=} item Object
 * @return {boolean} Boolean
 */
Ext.menu.IMenu.prototype.canActivateItem = function(item) {};

/**
 * [Method] Deactivates the current active item on the menu if one exists
 * @param {?=} andBlurFocusedItem Object
 * @return {void}
 */
Ext.menu.IMenu.prototype.deactivateActiveItem = function(andBlurFocusedItem) {};

/**
 * [Method] Hides this Component setting it to invisible using the configured hideMode
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.menu.IMenu.prototype.hide = function() {};

/**
 * [Method] Menus are never contained and must not ascertain their visibility from the ancestor hierarchy
 * @return {boolean} Boolean true if this component is visible, false otherwise.
 */
Ext.menu.IMenu.prototype.isVisible = function() {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.menu.IMenu.prototype.onDestroy = function() {};

/**
 * [Method] Shows this component by the specified Component or Element
 * @param {?=} cmp Object
 * @param {?=} pos Object
 * @param {?=} off Object
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.menu.IMenu.prototype.showBy = function(cmp, pos, off) {};
/**
 * @extends {Ext.menu.IItem}
 * @record
 * @struct
 */
Ext.menu.ISeparator = function() {};
 /** @type {string} */
Ext.menu.ISeparator.prototype.separatorCls;
/**
 * @extends {Ext.window.IMessageBox}
 * @record
 * @struct
 */
Ext.IMessageBox = function() {};
/**
 * @constructor
 * @struct
 */
Ext.MessageBox = function() {};
 /** @type {number} */
Ext.MessageBox.CANCEL;
 /** @type {string} */
Ext.MessageBox.ERROR;
 /** @type {string} */
Ext.MessageBox.INFO;
 /** @type {number} */
Ext.MessageBox.NO;
 /** @type {number} */
Ext.MessageBox.OK;
 /** @type {number} */
Ext.MessageBox.OKCANCEL;
 /** @type {string} */
Ext.MessageBox.QUESTION;
 /** @type {string} */
Ext.MessageBox.WARNING;
 /** @type {number} */
Ext.MessageBox.YES;
 /** @type {number} */
Ext.MessageBox.YESNO;
 /** @type {number} */
Ext.MessageBox.YESNOCANCEL;
 /** @type {boolean} */
Ext.MessageBox._isLayoutRoot;
 /** @type {!Ext.dom.IElement} */
Ext.MessageBox.body;
 /** @type {?} */
Ext.MessageBox.buttonText;
 /** @type {string} */
Ext.MessageBox.contentPaddingProperty;
 /** @type {!Ext.util.IComponentDragger} */
Ext.MessageBox.dd;
 /** @type {number} */
Ext.MessageBox.defaultTextHeight;
 /** @type {boolean} */
Ext.MessageBox.draggable;
 /** @type {!Ext.IContainer} */
Ext.MessageBox.floatParent;
 /** @type {?} */
Ext.MessageBox.frameSize;
 /** @type {?} */
Ext.MessageBox.hasListeners;
 /** @type {boolean} */
Ext.MessageBox.isComponent;
 /** @type {boolean} */
Ext.MessageBox.isObservable;
 /** @type {boolean} */
Ext.MessageBox.isPanel;
 /** @type {boolean} */
Ext.MessageBox.isWindow;
 /** @type {!Ext.util.IAbstractMixedCollection} */
Ext.MessageBox.items;
 /** @type {boolean} */
Ext.MessageBox.maskOnDisable;
 /** @type {number} */
Ext.MessageBox.minProgressWidth;
 /** @type {number} */
Ext.MessageBox.minPromptWidth;
 /** @type {!Ext.IContainer} */
Ext.MessageBox.ownerCt;
 /** @type {boolean} */
Ext.MessageBox.rendered;
 /** @type {?} */
Ext.MessageBox.scrollFlags;
 /** @type {!Ext.IClass} */
Ext.MessageBox.self;
 /** @type {!Ext.IZIndexManager} */
Ext.MessageBox.zIndexManager;
 /** @type {!Ext.IContainer} */
Ext.MessageBox.zIndexParent;

/**
 * [Method] Adds Component s to this Container
 * @param {?=} component Ext.Component[]|Object[]/Ext.Component.../Object... Either one or more Components to add or an Array of Components to add. See items for additional information.
 * @return {?} Ext.Component[]/Ext.Component The Components that were added.
 */
Ext.MessageBox.add = function(component) {};

/**
 * [Method] Adds a CSS class to the body element
 * @param {string=} cls String The class to add
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.MessageBox.addBodyCls = function(cls) {};

/**
 * [Method] Adds each argument passed to this method to the childEls array
 * @return {void}
 */
Ext.MessageBox.addChildEls = function() {};

/**
 * [Method] Adds a CSS class to the top level element representing this component
 * @param {?=} cls String/String[] The CSS class name to add.
 * @return {!Ext.IComponent} Ext.Component Returns the Component to allow method chaining.
 */
Ext.MessageBox.addClass = function(cls) {};

/**
 * [Method] Adds a CSS class to the top level element representing this component
 * @param {?=} cls String/String[] The CSS class name to add.
 * @return {!Ext.IComponent} Ext.Component Returns the Component to allow method chaining.
 */
Ext.MessageBox.addCls = function(cls) {};

/**
 * [Method] Adds a cls to the uiCls array which will also call addUIClsToElement and adds to all elements of this component
 * @param {?=} classes String/String[] A string or an array of strings to add to the uiCls.
 * @param {?=} skip Object (Boolean) skip true to skip adding it to the class and do it later (via the return).
 * @return {void}
 */
Ext.MessageBox.addClsWithUI = function(classes, skip) {};

/**
 * [Method] Adds docked item s to the container
 * @param {?=} component Object/Object[] The Component or array of components to add. The components must include a 'dock' parameter on each component to indicate where it should be docked ('top', 'right', 'bottom', 'left').
 * @param {number=} pos Number The index at which the Component will be added
 * @return {!Array<!Ext.IComponent>} Ext.Component[] The added components.
 */
Ext.MessageBox.addDocked = function(component, pos) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.MessageBox.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} element Object
 * @param {?=} listeners Object
 * @param {?=} scope Object
 * @param {?=} options Object
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.MessageBox.addListener = function(element, listeners, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.MessageBox.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Save a property to the given state object if it is not its default or configured value
 * @param {?=} state Object The state object.
 * @param {string=} propName String The name of the property on this object to save.
 * @param {string=} value String The value of the state property (defaults to this[propName]).
 * @return {boolean} Boolean The state object or a new object if state was null and the property was saved.
 */
Ext.MessageBox.addPropertyToState = function(state, propName, value) {};

/**
 * [Method] Add events that will trigger the state to be saved
 * @param {?=} events String/String[] The event name or an array of event names.
 * @return {void}
 */
Ext.MessageBox.addStateEvents = function(events) {};

/**
 * [Method] Add tools to this panel
 * @param {?=} tools Object[]/Ext.panel.Tool[] The tools to add
 * @return {void}
 */
Ext.MessageBox.addTool = function(tools) {};

/**
 * [Method] inherit docs
 * @param {?=} cls Object
 * @return {void}
 */
Ext.MessageBox.addUIClsToElement = function(cls) {};

/**
 * [Method] Invoked after the Panel is Collapsed
 * @return {void}
 */
Ext.MessageBox.afterCollapse = function() {};

/**
 * [Method] Called by the layout system after the Component has been laid out
 * @return {void}
 */
Ext.MessageBox.afterComponentLayout = function() {};

/**
 * [Method] Invoked after the Panel is Expanded
 * @return {void}
 */
Ext.MessageBox.afterExpand = function() {};

/**
 * [Method] Invoked after the Container has laid out and rendered if necessary its child Components
 * @param {!Ext.layout.container.IContainer=} layout Ext.layout.container.Container
 * @return {void}
 */
Ext.MessageBox.afterLayout = function(layout) {};

/**
 * [Method] Template method called after a Component has been positioned
 * @param {?=} ax Object
 * @param {?=} ay Object
 * @return {void}
 */
Ext.MessageBox.afterSetPosition = function(ax, ay) {};

/**
 * [Method] Invoked after the Component is shown after onShow is called
 * @param {?=} animateTarget String/Ext.Element
 * @param {?=} callback Function
 * @param {?=} scope Object
 * @return {void}
 */
Ext.MessageBox.afterShow = function(animateTarget, callback, scope) {};

/**
 * [Method] Displays a standard read only message box with an OK button comparable to the basic JavaScript alert prompt
 * @param {string=} title String The title bar text
 * @param {string=} msg String The message box body text
 * @param {?=} fn Function The callback function invoked after the message box is closed. See show method for details.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed.
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.MessageBox.alert = function(title, msg, fn, scope) {};

/**
 * [Method] Aligns the element with another element relative to the specified anchor points
 * @param {?=} element Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or id of the element to align to.
 * @param {string=} position String The position to align to
 * @param {!Array<number>=} offsets Number[] Offset the positioning by [x, y]
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.MessageBox.alignTo = function(element, position, offsets, animate) {};

/**
 * [Method] Anchors an element to another element and realigns it when the window is resized
 * @param {?=} element Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or id of the element to align to.
 * @param {string=} position String The position to align to
 * @param {!Array<number>=} offsets Number[] Offset the positioning by [x, y]
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @param {?=} monitorScroll Boolean/Number True to monitor body scroll and reposition. If this parameter is a number, it is used as the buffer delay in milliseconds.
 * @param {?=} callback Function The function to call after the animation finishes
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.MessageBox.anchorTo = function(element, position, offsets, animate, monitorScroll, callback) {};

/**
 * [Method] Performs custom animation on this object
 * @param {?=} animObj Object
 * @return {?} Object this
 */
Ext.MessageBox.animate = function(animObj) {};

/**
 * [Method] Applies the state to the object
 * @param {?=} state Object
 * @return {void}
 */
Ext.MessageBox.applyState = function(state) {};

/**
 * [Method] Template method to do any pre blur processing
 * @param {!Ext.IEventObject=} e Ext.EventObject The event object
 * @return {void}
 */
Ext.MessageBox.beforeBlur = function(e) {};

/**
 * [Method] Occurs before componentLayout is run
 * @param {number=} adjWidth Number The box-adjusted width that was set.
 * @param {number=} adjHeight Number The box-adjusted height that was set.
 * @return {void}
 */
Ext.MessageBox.beforeComponentLayout = function(adjWidth, adjHeight) {};

/**
 * [Method] Template method to do any pre focus processing
 * @param {!Ext.IEventObject=} e Ext.EventObject The event object
 * @return {void}
 */
Ext.MessageBox.beforeFocus = function(e) {};

/**
 * [Method] Occurs before componentLayout is run
 * @return {void}
 */
Ext.MessageBox.beforeLayout = function() {};

/**
 * [Method] Invoked before the Component is shown
 * @return {void}
 */
Ext.MessageBox.beforeShow = function() {};

/**
 * [Method] Bubbles up the component container heirarchy calling the specified function with each component
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope of the function. Defaults to current node.
 * @param {!Array<?>=} args Array The args to call the function with. Defaults to passing the current component.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.bubble = function(fn, scope, args) {};

/**
 * [Method] Calculates the new x y position to move this Positionable into a constrain region
 * @param {?=} constrainTo String/HTMLElement/Ext.Element/Ext.util.Region The Element or Region into which this Component is to be constrained. Defaults to the element into which this Positionable was rendered, or this Component's {\@link Ext.Component.constrainTo.
 * @param {!Array<number>=} proposedPosition Number[] A proposed [X, Y] position to test for validity and to coerce into constraints instead of using this Positionable's current position.
 * @param {boolean=} local Boolean The proposedPosition is local (relative to floatParent if a floating Component)
 * @param {!Array<number>=} proposedSize Number[] A proposed [width, height] size to use when calculating constraints instead of using this Positionable's current size.
 * @return {!Array<number>} Number[] If the element needs to be translated, the new [X, Y] position within constraints if possible, giving priority to keeping the top and left edge in the constrain region. Otherwise, false.
 */
Ext.MessageBox.calculateConstrainedPosition = function(constrainTo, proposedPosition, local, proposedSize) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.MessageBox.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.MessageBox.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.MessageBox.callSuper = function(args) {};

/**
 * [Method] Cancel any deferred focus on this component
 * @return {void}
 */
Ext.MessageBox.cancelFocus = function() {};

/**
 * [Method] Cascades down the component container heirarchy from this component passed in the first call  calling the specified
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope of the function (defaults to current component)
 * @param {!Array<?>=} args Array The args to call the function with. The current component always passed as the last argument.
 * @return {!Ext.IContainer} Ext.Container this
 */
Ext.MessageBox.cascade = function(fn, scope, args) {};

/**
 * [Method] Center this Component in its container
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.center = function() {};

/**
 * [Method] Retrieves the first direct child of this container which matches the passed selector or component
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching child Ext.Component (or null if no match was found).
 */
Ext.MessageBox.child = function(selector) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.MessageBox.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.MessageBox.clearManagedListeners = function() {};

/**
 * [Method] Clone the current component using the original config values passed into this instance by default
 * @param {?=} overrides Object A new config containing any properties to override in the cloned version. An id property can be passed on this object, otherwise one will be generated to avoid duplicates.
 * @return {!Ext.IComponent} Ext.Component clone The cloned copy of this component
 */
Ext.MessageBox.cloneConfig = function(overrides) {};

/**
 * [Method] Closes the Panel
 * @return {void}
 */
Ext.MessageBox.close = function() {};

/**
 * [Method] Collapses the panel body so that the body becomes hidden
 * @param {string=} direction String The direction to collapse towards. Must be one of  Ext.Component.DIRECTION_TOP Ext.Component.DIRECTION_RIGHT Ext.Component.DIRECTION_BOTTOM Ext.Component.DIRECTION_LEFT Defaults to collapseDirection.
 * @param {boolean=} animate Boolean True to animate the transition, else false (defaults to the value of the animCollapse panel config). May also be specified as the animation duration in milliseconds.
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.MessageBox.collapse = function(direction, animate) {};

/**
 * [Method] Displays a confirmation message box with Yes and No buttons comparable to JavaScript s confirm
 * @param {string=} title String The title bar text
 * @param {string=} msg String The message box body text
 * @param {?=} fn Function The callback function invoked after the message box is closed. See show method for details.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed.
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.MessageBox.confirm = function(title, msg, fn, scope) {};

/**
 * [Method] Determines whether the passed Component is either an immediate child of this Container or whether it is a descendant
 * @param {!Ext.IComponent=} comp Ext.Component The Component to test.
 * @param {boolean=} deep Boolean Pass true to test for the Component being a descendant at any level.
 * @return {boolean} Boolean true if the passed Component is contained at the specified level.
 */
Ext.MessageBox.contains = function(comp, deep) {};

/**
 * [Method] converts a collapsdDir into an anchor argument for Element slideIn overridden in rtl mode to switch l and r
 * @param {?=} collapseDir Object
 * @return {void}
 */
Ext.MessageBox.convertCollapseDir = function(collapseDir) {};

/**
 * [Method] Inherit docs Disable all immediate children that was previously disabled Override disable because onDisable only gets
 * @return {!Ext.container.IAbstractContainer} Ext.container.AbstractContainer this
 */
Ext.MessageBox.disable = function() {};

/**
 * [Method] Handles autoRender
 * @return {void}
 */
Ext.MessageBox.doAutoRender = function() {};

/**
 * [Method] This method needs to be called whenever you change something on this component that requires the Component s layout t
 * @return {!Ext.container.IContainer} Ext.container.Container this
 */
Ext.MessageBox.doComponentLayout = function() {};

/**
 * [Method] Moves this floating Component into a constrain region
 * @param {?=} constrainTo String/HTMLElement/Ext.Element/Ext.util.Region The Element or Region into which this Component is to be constrained. Defaults to the element into which this floating Component was rendered.
 * @return {void}
 */
Ext.MessageBox.doConstrain = function(constrainTo) {};

/**
 * [Method] Manually force this container s layout to be recalculated
 * @return {!Ext.container.IContainer} Ext.container.Container this
 */
Ext.MessageBox.doLayout = function() {};

/**
 * [Method] Retrieves the first descendant of this container which matches the passed selector
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector or Ext.Component. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching descendant Ext.Component (or null if no match was found).
 */
Ext.MessageBox.down = function(selector) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.MessageBox.enableBubble = function(eventNames) {};

/**
 * [Method] Ensures that this component is attached to document body
 * @param {boolean=} runLayout Boolean True to run the component's layout.
 * @return {void}
 */
Ext.MessageBox.ensureAttachedToBody = function(runLayout) {};

/**
 * [Method] Expands the panel body so that it becomes visible
 * @param {boolean=} animate Boolean True to animate the transition, else false (defaults to the value of the animCollapse panel config). May also be specified as the animation duration in milliseconds.
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.MessageBox.expand = function(animate) {};

/**
 * [Method] Find a container above this component at any level by a custom function
 * @param {?=} fn Function The custom function to call with the arguments (container, this component).
 * @return {!Ext.container.IContainer} Ext.container.Container The first Container for which the custom function returns true
 */
Ext.MessageBox.findParentBy = function(fn) {};

/**
 * [Method] Find a container above this component at any level by xtype or class See also the up method
 * @param {?=} xtype String/Ext.Class The xtype string for a component, or the class of the component directly
 * @return {!Ext.container.IContainer} Ext.container.Container The first Container which matches the given xtype or class
 */
Ext.MessageBox.findParentByType = function(xtype) {};

/**
 * [Method] Retrieves plugin from this component s collection by its ptype
 * @param {string=} ptype String The Plugin's ptype as specified by the class's alias configuration.
 * @return {!Ext.IAbstractPlugin} Ext.AbstractPlugin plugin instance.
 */
Ext.MessageBox.findPlugin = function(ptype) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.MessageBox.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.MessageBox.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Try to focus this component
 * @param {boolean=} selectText Boolean If applicable, true to also select the text in this component
 * @param {?=} delay Boolean/Number Delay the focus this number of milliseconds (true for 10 milliseconds).
 * @param {?=} callback Function Only needed if the delay parameter is used. A function to call upon focus.
 * @param {?=} scope Function Only needed if the delay parameter is used. The scope (this reference) in which to execute the callback.
 * @return {!Ext.IComponent} Ext.Component The focused Component. Usually this Component. Some Containers may delegate focus to a descendant Component (Windows can do this through their defaultFocus config option.
 */
Ext.MessageBox.focus = function(selectText, delay, callback, scope) {};

/**
 * [Method] Forces this component to redo its componentLayout
 * @return {void}
 */
Ext.MessageBox.forceComponentLayout = function() {};

/**
 * [Method] Returns the current animation if this object has any effects actively running or queued else returns false
 * @return {?} Ext.fx.Anim/Boolean Anim if element has active effects, else false
 */
Ext.MessageBox.getActiveAnimation = function() {};

/**
 * [Method] Gets the x y coordinates to align this element with another element
 * @param {?=} element Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or id of the element to align to.
 * @param {string=} position String The position to align to
 * @param {!Array<number>=} offsets Number[] Offset the positioning by [x, y]
 * @return {!Array<number>} Number[] [x, y]
 */
Ext.MessageBox.getAlignToXY = function(element, position, offsets) {};

/**
 * [Method] Gets the x y coordinates specified by the anchor position on the element
 * @param {string=} anchor String The specified anchor position. See alignTo for details on supported anchor positions.
 * @param {boolean=} local Boolean True to get the local (element top/left-relative) anchor position instead of page coordinates
 * @param {?=} size Object An object containing the size to use for calculating anchor position {width: (target width), height: (target height)} (defaults to the element's current size)
 * @return {!Array<number>} Number[] [x, y] An array containing the element's x and y coordinates
 */
Ext.MessageBox.getAnchorXY = function(anchor, local, size) {};

/**
 * [Method] Return an object defining the area of this Element which can be passed to setBox to set another Element s size locati
 * @param {boolean=} contentBox Boolean If true a box for the content of the element is returned.
 * @param {boolean=} local Boolean If true the element's left and top relative to its offsetParent are returned instead of page x/y.
 * @return {?} Object box An object in the format: {  x: &lt;Element's X position&gt;,  y: &lt;Element's Y position&gt;,  left: &lt;Element's X position (an alias for x)&gt;,  top: &lt;Element's Y position (an alias for y)&gt;,  width: &lt;Element's width&gt;,  height: &lt;Element's height&gt;,  bottom: &lt;Element's lower bound&gt;,  right: &lt;Element's rightmost bound&gt; }  The returned object may also be addressed as an Array where index 0 contains the X position and index 1 contains the Y position. The result may also be used for setXY
 */
Ext.MessageBox.getBox = function(contentBox, local) {};

/**
 * [Method] Implements an upward event bubbling policy
 * @return {void}
 */
Ext.MessageBox.getBubbleTarget = function() {};

/**
 * [Method] Return the immediate child Component in which the passed element is located
 * @param {?=} el Ext.Element/HTMLElement/String The element to test (or ID of element).
 * @param {boolean=} deep Boolean If true, returns the deepest descendant Component which contains the passed element.
 * @return {!Ext.IComponent} Ext.Component The child item which contains the passed element.
 */
Ext.MessageBox.getChildByElement = function(el, deep) {};

/**
 * [Method] Returns the current collapsed state of the panel
 * @return {?} Boolean/String False when not collapsed, otherwise the value of collapseDirection.
 */
Ext.MessageBox.getCollapsed = function() {};

/**
 * [Method] Attempts a default component lookup see Ext container Container getComponent
 * @param {?=} comp String/Number The component id, itemId or position to find
 * @return {!Ext.IComponent} Ext.Component The component (if found)
 */
Ext.MessageBox.getComponent = function(comp) {};

/**
 * [Method] Returns the X Y vector by which this Positionable s element must be translated to make a best attempt to constrain
 * @param {?=} constrainTo Ext.util.Positionable/HTMLElement/String/Ext.util.Region The Positionable, HTMLElement, element id, or Region into which the element is to be constrained.
 * @param {!Array<number>=} proposedPosition Number[] A proposed [X, Y] position to test for validity and to produce a vector for instead of using the element's current position
 * @param {!Array<number>=} proposedSize Number[] A proposed [width, height] size to constrain instead of using the element's current size
 * @return {?} Number[]/Boolean If the element needs to be translated, an [X, Y] vector by which this element must be translated. Otherwise, false.
 */
Ext.MessageBox.getConstrainVector = function(constrainTo, proposedPosition, proposedSize) {};

/**
 * [Method] Gets the configured default focus item
 * @return {void}
 */
Ext.MessageBox.getDefaultFocus = function() {};

/**
 * [Method] Finds a docked component by id itemId or position
 * @param {?=} comp String/Number The id, itemId or position of the docked component (see getComponent for details)
 * @return {!Ext.IComponent} Ext.Component The docked component (if found)
 */
Ext.MessageBox.getDockedComponent = function(comp) {};

/**
 * [Method] Retrieves an array of all currently docked Components
 * @param {string=} selector String A ComponentQuery selector string to filter the returned items.
 * @param {boolean=} beforeBody Boolean An optional flag to limit the set of items to only those before the body (true) or after the body (false). All components are returned by default.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] The array of docked components meeting the specified criteria.
 */
Ext.MessageBox.getDockedItems = function(selector, beforeBody) {};

/**
 * [Method] Retrieves the top level element representing this component
 * @return {!Ext.dom.IElement} Ext.dom.Element
 */
Ext.MessageBox.getEl = function() {};

/**
 * [Method] Gets the Header for this panel
 * @return {void}
 */
Ext.MessageBox.getHeader = function() {};

/**
 * [Method] Gets the current height of the component s underlying element
 * @return {number} Number
 */
Ext.MessageBox.getHeight = function() {};

/**
 * [Method] Retrieves the id of this component
 * @return {string} String
 */
Ext.MessageBox.getId = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.MessageBox.getInitialConfig = function(name) {};

/**
 * [Method] This function takes the position argument passed to onRender and returns a DOM element that you can use in the insert
 * @param {?=} position String/Number/Ext.dom.Element/HTMLElement Index, element id or element you want to put this component before.
 * @return {!HTMLElement} HTMLElement DOM element that you can use in the insertBefore
 */
Ext.MessageBox.getInsertPosition = function(position) {};

/**
 * [Method] Returns the value of itemId assigned to this component or when that is not set returns the value of id
 * @return {string} String
 */
Ext.MessageBox.getItemId = function() {};

/**
 * [Method] Returns the layout instance currently associated with this Container
 * @return {!Ext.layout.container.IContainer} Ext.layout.container.Container The layout
 */
Ext.MessageBox.getLayout = function() {};

/**
 * [Method] Gets the Ext ComponentLoader for this Component
 * @return {!Ext.IComponentLoader} Ext.ComponentLoader The loader instance, null if it doesn't exist.
 */
Ext.MessageBox.getLoader = function() {};

/**
 * [Method] Overridden in Ext rtl AbstractComponent
 * @return {number} Number The local x coordinate
 */
Ext.MessageBox.getLocalX = function() {};

/**
 * [Method] Overridden in Ext rtl AbstractComponent
 * @return {!Array<number>} Number[] The local XY position of the element
 */
Ext.MessageBox.getLocalXY = function() {};

/**
 * [Method] Returns the y coordinate of this element reletive to its offsetParent
 * @return {number} Number The local y coordinate
 */
Ext.MessageBox.getLocalY = function() {};

/**
 * [Method] Returns the offsets of this element from the passed element
 * @param {?=} offsetsTo Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or element id to get get the offsets from.
 * @return {!Array<number>} Number[] The XY page offsets (e.g. [100, -200])
 */
Ext.MessageBox.getOffsetsTo = function(offsetsTo) {};

/**
 * [Method] Retrieves a plugin from this component s collection by its pluginId
 * @param {string=} pluginId String
 * @return {!Ext.IAbstractPlugin} Ext.AbstractPlugin plugin instance.
 */
Ext.MessageBox.getPlugin = function(pluginId) {};

/**
 * [Method] Gets the current XY position of the component s underlying element
 * @param {boolean=} local Boolean If true the element's left and top are returned instead of page XY.
 * @return {!Array<number>} Number[] The XY position of the element (e.g., [100, 200])
 */
Ext.MessageBox.getPosition = function(local) {};

/**
 * [Method] Used by ComponentQuery child and down to retrieve all of the items which can potentially be considered a child of th
 * @param {?=} deep Object
 * @return {void}
 */
Ext.MessageBox.getRefItems = function(deep) {};

/**
 * [Method] Returns a region object that defines the area of this element
 * @return {!Ext.util.IRegion} Ext.util.Region A Region containing "top, left, bottom, right" properties.
 */
Ext.MessageBox.getRegion = function() {};

/**
 * [Method] Gets the current size of the component s underlying element
 * @return {?} Object An object containing the element's size {width: (element width), height: (element height)}
 */
Ext.MessageBox.getSize = function() {};

/**
 * [Method] Returns an object that describes how this component s width and height are managed
 * @param {?=} ownerCtSizeModel Object
 * @return {?} Object The size model for this component.
 */
Ext.MessageBox.getSizeModel = function(ownerCtSizeModel) {};

/**
 * [Method] Returns the content region of this element
 * @return {!Ext.util.IRegion} Ext.util.Region A Region containing "top, left, bottom, right" member data.
 */
Ext.MessageBox.getViewRegion = function() {};

/**
 * [Method] Gets the current width of the component s underlying element
 * @return {number} Number
 */
Ext.MessageBox.getWidth = function() {};

/**
 * [Method] Gets the current X position of the DOM element based on page coordinates
 * @return {number} Number The X position of the element
 */
Ext.MessageBox.getX = function() {};

/**
 * [Method] Gets the xtype for this component as registered with Ext ComponentManager
 * @return {string} String The xtype
 */
Ext.MessageBox.getXType = function() {};

/**
 * [Method] Returns this Component s xtype hierarchy as a slash delimited string
 * @return {string} String The xtype hierarchy string
 */
Ext.MessageBox.getXTypes = function() {};

/**
 * [Method] Gets the current position of the DOM element based on page coordinates
 * @return {!Array<number>} Number[] The XY position of the element
 */
Ext.MessageBox.getXY = function() {};

/**
 * [Method] Gets the current Y position of the DOM element based on page coordinates
 * @return {number} Number The Y position of the element
 */
Ext.MessageBox.getY = function() {};

/**
 * [Method] Returns the current animation if this object has any effects actively running or queued else returns false
 * @return {?} Ext.fx.Anim/Boolean Anim if element has active effects, else false
 */
Ext.MessageBox.hasActiveFx = function() {};

/**
 * [Method] Checks if the specified CSS class exists on this element s DOM node
 * @param {string=} className String The CSS class to check for.
 * @return {boolean} Boolean true if the class exists, else false.
 */
Ext.MessageBox.hasCls = function(className) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.MessageBox.hasListener = function(eventName) {};

/**
 * [Method] Checks if there is currently a specified uiCls
 * @param {string=} cls String The cls to check.
 * @return {void}
 */
Ext.MessageBox.hasUICls = function(cls) {};

/**
 * [Method] Hides this Component setting it to invisible using the configured hideMode
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.hide = function() {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.MessageBox.initConfig = function(config) {};

/**
 * [Method] Initialize any events on this component
 * @return {void}
 */
Ext.MessageBox.initEvents = function() {};

/**
 * [Method] Inserts a Component into this Container at a specified index
 * @param {number=} index Number The index at which the Component will be inserted into the Container's items collection
 * @param {?=} component Ext.Component/Object The child Component to insert. Ext uses lazy rendering, and will only render the inserted Component should it become necessary. A Component config object may be passed in order to avoid the overhead of constructing a real Component object if lazy rendering might mean that the inserted Component will not be rendered immediately. To take advantage of this 'lazy instantiation', set the Ext.Component.xtype config property to the registered type of the Component wanted. For a list of all available xtypes, see Ext.enums.Widget.
 * @return {!Ext.IComponent} Ext.Component component The Component (or config object) that was inserted with the Container's default config values applied.
 */
Ext.MessageBox.insert = function(index, component) {};

/**
 * [Method] Inserts docked item s to the panel at the indicated position
 * @param {number=} pos Number The index at which the Component will be inserted
 * @param {?=} component Object/Object[] The Component or array of components to add. The components must include a 'dock' paramater on each component to indicate where it should be docked ('top', 'right', 'bottom', 'left').
 * @return {void}
 */
Ext.MessageBox.insertDocked = function(pos, component) {};

/**
 * [Method] Tests whether this Component matches the selector string
 * @param {string=} selector String The selector string to test against.
 * @return {boolean} Boolean true if this Component matches the selector.
 */
Ext.MessageBox.is = function(selector) {};

/**
 * [Method] Determines whether this Container is an ancestor of the passed Component
 * @param {!Ext.IComponent=} possibleDescendant Ext.Component The Component to test for presence within this Container's subtree.
 * @return {void}
 */
Ext.MessageBox.isAncestor = function(possibleDescendant) {};

/**
 * [Method] Determines whether this component is the descendant of a particular container
 * @param {!Ext.IContainer=} container Ext.Container
 * @return {boolean} Boolean true if the component is the descendant of a particular container, otherwise false.
 */
Ext.MessageBox.isDescendantOf = function(container) {};

/**
 * [Method] Method to determine whether this Component is currently disabled
 * @return {boolean} Boolean the disabled state of this Component.
 */
Ext.MessageBox.isDisabled = function() {};

/**
 * [Method] Method to determine whether this Component is draggable
 * @return {boolean} Boolean the draggable state of this component.
 */
Ext.MessageBox.isDraggable = function() {};

/**
 * [Method] Method to determine whether this Component is droppable
 * @return {boolean} Boolean the droppable state of this component.
 */
Ext.MessageBox.isDroppable = function() {};

/**
 * [Method] Method to determine whether this Component is floating
 * @return {boolean} Boolean the floating state of this component.
 */
Ext.MessageBox.isFloating = function() {};

/**
 * [Method] Method to determine whether this Component is currently set to hidden
 * @return {boolean} Boolean the hidden state of this Component.
 */
Ext.MessageBox.isHidden = function() {};

/**
 * [Method] Determines whether this Component is the root of a layout
 * @return {void}
 */
Ext.MessageBox.isLayoutRoot = function() {};

/**
 * [Method] Returns true if layout is suspended for this component
 * @return {boolean} Boolean true layout of this component is suspended.
 */
Ext.MessageBox.isLayoutSuspended = function() {};

/**
 * [Method] Returns true if this component is visible
 * @param {?=} deep Object
 * @return {boolean} Boolean true if this component is visible, false otherwise.
 */
Ext.MessageBox.isVisible = function(deep) {};

/**
 * [Method] Tests whether or not this Component is of a specific xtype
 * @param {string=} xtype String The xtype to check for this Component
 * @param {boolean=} shallow Boolean true to check whether this Component is directly of the specified xtype, false to check whether this Component is descended from the xtype.
 * @return {boolean} Boolean true if this component descends from the specified xtype, false otherwise.
 */
Ext.MessageBox.isXType = function(xtype, shallow) {};

/**
 * [Method] Fits the window within its current container and automatically replaces the maximize tool button with the restore
 * @param {boolean=} animate Boolean true to animate this Window to full size.
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.MessageBox.maximize = function(animate) {};

/**
 * [Method] Placeholder method for minimizing the window
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.MessageBox.minimize = function() {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.MessageBox.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Moves a Component within the Container
 * @param {?=} fromIdx Number/Ext.Component The index/component to move.
 * @param {number=} toIdx Number The new index for the Component.
 * @return {!Ext.IComponent} Ext.Component component The Component that was moved.
 */
Ext.MessageBox.move = function(fromIdx, toIdx) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.MessageBox.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Returns the next node in the Component tree in tree traversal order
 * @param {string=} selector String A ComponentQuery selector to filter the following nodes.
 * @return {!Ext.IComponent} Ext.Component The next node (or the next node which matches the selector). Returns null if there is no matching node.
 */
Ext.MessageBox.nextNode = function(selector) {};

/**
 * [Method] Returns the next sibling of this Component
 * @param {string=} selector String A ComponentQuery selector to filter the following items.
 * @return {!Ext.IComponent} Ext.Component The next sibling (or the next sibling which matches the selector). Returns null if there is no matching sibling.
 */
Ext.MessageBox.nextSibling = function(selector) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.MessageBox.on = function(eventName, fn, scope, options) {};

/**
 * [Method] This method is invoked after a new Component has been added
 * @param {!Ext.IComponent=} component Ext.Component
 * @param {number=} position Number
 * @return {void}
 */
Ext.MessageBox.onAdd = function(component, position) {};

/**
 * [Method] Method to manage awareness of when components are added to their respective Container firing an added event
 * @return {void}
 */
Ext.MessageBox.onAdded = function() {};

/**
 * [Method] This method is invoked before adding a new child Component
 * @param {!Ext.IComponent=} item Ext.Component
 * @return {void}
 */
Ext.MessageBox.onBeforeAdd = function(item) {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.MessageBox.onDestroy = function() {};

/**
 * [Method] Allows addition of behavior to the disable operation
 * @return {void}
 */
Ext.MessageBox.onDisable = function() {};

/**
 * [Method] Invoked after a docked item is added to the Panel
 * @param {!Ext.IComponent=} component Ext.Component
 * @return {void}
 */
Ext.MessageBox.onDockedAdd = function(component) {};

/**
 * [Method] Invoked after a docked item is removed from the Panel
 * @param {!Ext.IComponent=} component Ext.Component
 * @return {void}
 */
Ext.MessageBox.onDockedRemove = function(component) {};

/**
 * [Method] Allows addition of behavior to the enable operation
 * @return {void}
 */
Ext.MessageBox.onEnable = function() {};

/**
 * [Method] Possibly animates down to a target element
 * @return {void}
 */
Ext.MessageBox.onHide = function() {};

/**
 * [Method] Called after the component is moved this method is empty by default but can be implemented by any subclass that need
 * @return {void}
 */
Ext.MessageBox.onPosition = function() {};

/**
 * [Method] This method is invoked after a new Component has been removed
 * @param {!Ext.IComponent=} component Ext.Component
 * @param {boolean=} autoDestroy Boolean
 * @return {void}
 */
Ext.MessageBox.onRemove = function(component, autoDestroy) {};

/**
 * [Method] Method to manage awareness of when components are removed from their respective Container firing a removed event
 * @param {?=} destroying Object
 * @return {void}
 */
Ext.MessageBox.onRemoved = function(destroying) {};

/**
 * [Method] Allows addition of behavior to the resize operation
 * @return {void}
 */
Ext.MessageBox.onResize = function() {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.MessageBox.onShow = function() {};

/**
 * [Method] Invoked after the afterShow method is complete
 * @param {?=} callback Function
 * @param {?=} scope Object
 * @return {void}
 */
Ext.MessageBox.onShowComplete = function(callback, scope) {};

/**
 * [Method] Template method to do any post blur processing
 * @param {!Ext.IEventObject=} e Ext.EventObject The event object
 * @return {void}
 */
Ext.MessageBox.postBlur = function(e) {};

/**
 * [Method] Returns the previous node in the Component tree in tree traversal order
 * @param {string=} selector String A ComponentQuery selector to filter the preceding nodes.
 * @return {!Ext.IComponent} Ext.Component The previous node (or the previous node which matches the selector). Returns null if there is no matching node.
 */
Ext.MessageBox.previousNode = function(selector) {};

/**
 * [Method] Returns the previous sibling of this Component
 * @param {string=} selector String A ComponentQuery selector to filter the preceding items.
 * @return {!Ext.IComponent} Ext.Component The previous sibling (or the previous sibling which matches the selector). Returns null if there is no matching sibling.
 */
Ext.MessageBox.previousSibling = function(selector) {};

/**
 * [Method] Displays a message box with a progress bar
 * @param {string=} title String The title bar text
 * @param {string=} msg String The message box body text
 * @param {string=} progressText String The text to display inside the progress bar
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.MessageBox.progress = function(title, msg, progressText) {};

/**
 * [Method] Displays a message box with OK and Cancel buttons prompting the user to enter some text comparable to JavaScript s p
 * @param {string=} title String The title bar text
 * @param {string=} msg String The message box body text
 * @param {?=} fn Function The callback function invoked after the message box is closed. See show method for details.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed.
 * @param {?=} multiline Boolean/Number True to create a multiline textbox using the defaultTextHeight property, or the height in pixels to create the textbox/
 * @param {string=} value String Default value of the text input element
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.MessageBox.prompt = function(title, msg, fn, scope, multiline, value) {};

/**
 * [Method] Retrieves all descendant components which match the passed selector
 * @param {string=} selector String Selector complying to an Ext.ComponentQuery selector. If no selector is specified all items will be returned.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components which matched the selector
 */
Ext.MessageBox.query = function(selector) {};

/**
 * [Method] Retrieves all descendant components which match the passed function
 * @param {?=} fn Function The matcher function. It will be called with a single argument, the component being tested.
 * @param {?=} scope Object The scope in which to run the function. If not specified, it will default to the active component.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components matched by the passed function
 */
Ext.MessageBox.queryBy = function(fn, scope) {};

/**
 * [Method] Finds a component at any level under this container matching the id itemId
 * @param {string=} id String The id to find
 * @return {!Ext.IComponent} Ext.Component The matching id, null if not found
 */
Ext.MessageBox.queryById = function(id) {};

/**
 * [Method] Called by Component doAutoRender Register a Container configured floating true with this Component s ZIndexManager
 * @param {?=} cmp Object
 * @return {void}
 */
Ext.MessageBox.registerFloatingItem = function(cmp) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.MessageBox.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes a component from this container
 * @param {?=} component Ext.Component/String The component reference or id to remove.
 * @param {boolean=} autoDestroy Boolean True to automatically invoke the removed Component's Ext.Component.destroy function. Defaults to the value of this Container's autoDestroy config.
 * @return {!Ext.IComponent} Ext.Component component The Component that was removed.
 */
Ext.MessageBox.remove = function(component, autoDestroy) {};

/**
 * [Method] Removes all components from this container
 * @param {boolean=} autoDestroy Boolean True to automatically invoke the removed Component's Ext.Component.destroy function. Defaults to the value of this Container's autoDestroy config.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Array of the removed components
 */
Ext.MessageBox.removeAll = function(autoDestroy) {};

/**
 * [Method] Remove any anchor to this element
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.MessageBox.removeAnchor = function() {};

/**
 * [Method] Removes a CSS class from the body element
 * @param {string=} cls String The class to remove
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.MessageBox.removeBodyCls = function(cls) {};

/**
 * [Method] Removes items in the childEls array based on the return value of a supplied test function
 * @param {?=} testFn Function The test function.
 * @return {void}
 */
Ext.MessageBox.removeChildEls = function(testFn) {};

/**
 * [Method] Removes a CSS class from the top level element representing this component
 * @param {?=} cls String/String[] The CSS class name to remove.
 * @return {!Ext.IComponent} Ext.Component Returns the Component to allow method chaining.
 */
Ext.MessageBox.removeCls = function(cls) {};

/**
 * [Method] Removes a cls to the uiCls array which will also call removeUIClsFromElement and removes it from all elements of thi
 * @param {?=} cls String/String[] A string or an array of strings to remove to the uiCls.
 * @return {void}
 */
Ext.MessageBox.removeClsWithUI = function(cls) {};

/**
 * [Method] Removes the docked item from the panel
 * @param {!Ext.IComponent=} item Ext.Component The Component to remove.
 * @param {boolean=} autoDestroy Boolean Destroy the component after removal.
 * @return {void}
 */
Ext.MessageBox.removeDocked = function(item, autoDestroy) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.MessageBox.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.MessageBox.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] inherit docs
 * @param {?=} cls Object
 * @return {void}
 */
Ext.MessageBox.removeUIClsFromElement = function(cls) {};

/**
 * [Method] Renders the Component into the passed HTML element
 * @param {?=} container Ext.Element/HTMLElement/String The element this Component should be rendered into. If it is being created from existing markup, this should be omitted.
 * @param {?=} position String/Number The element ID or DOM node index within the container before which this component will be inserted (defaults to appending to the end of the container)
 * @return {void}
 */
Ext.MessageBox.render = function(container, position) {};

/**
 * [Method] Restores a maximized window back to its original size and position prior to being maximized and also replaces the re
 * @param {?=} animate Object
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.MessageBox.restore = function(animate) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.MessageBox.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.MessageBox.resumeEvents = function() {};

/**
 * [Method] Conditionally saves a single property from this object to the given state object
 * @param {string=} propName String The name of the property to save.
 * @param {?=} state Object The state object in to which to save the property.
 * @param {string=} stateName String The name to use for the property in state.
 * @return {boolean} Boolean True if the property was saved, false if not.
 */
Ext.MessageBox.savePropToState = function(propName, state, stateName) {};

/**
 * [Method] Gathers additional named properties of the instance and adds their current values to the passed state object
 * @param {?=} propNames String/String[] The name (or array of names) of the property to save.
 * @param {?=} state Object The state object in to which to save the property values.
 * @return {?} Object state
 */
Ext.MessageBox.savePropsToState = function(propNames, state) {};

/**
 * [Method] Saves the state of the object to the persistence store
 * @return {void}
 */
Ext.MessageBox.saveState = function() {};

/**
 * [Method] Scrolls this Component s target element by the passed delta values optionally animating
 * @param {?=} deltaX Number/Number[]/Object Either the x delta, an Array specifying x and y deltas or an object with "x" and "y" properties.
 * @param {?=} deltaY Number/Boolean/Object Either the y delta, or an animate flag or config object.
 * @param {?=} animate Boolean/Object Animate flag/config object if the delta values were passed separately.
 * @return {void}
 */
Ext.MessageBox.scrollBy = function(deltaX, deltaY, animate) {};

/**
 * [Method] Ensures that all effects queued after sequenceFx is called on this object are run in sequence
 * @return {?} Object this
 */
Ext.MessageBox.sequenceFx = function() {};

/**
 * [Method] This method is called internally by Ext ZIndexManager to signal that a floating Component has either been moved to th
 * @param {boolean=} active Boolean True to activate the Component, false to deactivate it.
 * @param {!Ext.IComponent=} newActive Ext.Component The newly active Component which is taking over topmost zIndex position.
 * @return {void}
 */
Ext.MessageBox.setActive = function(active, newActive) {};

/**
 * [Method] Sets the overflow on the content element of the component
 * @param {boolean=} scroll Boolean True to allow the Component to auto scroll.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.setAutoScroll = function(scroll) {};

/**
 * [Method] Sets the body style according to the passed parameters
 * @param {?=} style Mixed A full style specification string, or object, or the name of a style property to set.
 * @param {string=} value String If the first param was a style property name, the style property value.
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.MessageBox.setBodyStyle = function(style, value) {};

/**
 * [Method]
 * @param {?=} border Object
 * @param {?=} targetEl Object
 * @return {void}
 */
Ext.MessageBox.setBorder = function(border, targetEl) {};

/**
 * [Method] This method changes the region config property for this border region
 * @param {string=} region String The new region value ("north", "south", "east" or "west").
 * @return {string} String The previous value of the region property.
 */
Ext.MessageBox.setBorderRegion = function(region) {};

/**
 * [Method] Sets the element s box
 * @param {?=} box Object The box to fill {x, y, width, height}
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.MessageBox.setBox = function(box, animate) {};

/**
 * [Method] Enable or disable the component
 * @param {boolean=} disabled Boolean true to disable.
 * @return {void}
 */
Ext.MessageBox.setDisabled = function(disabled) {};

/**
 * [Method] Sets the dock position of this component in its parent panel
 * @param {?=} dock Object The dock position.
 * @param {boolean=} layoutParent Boolean true to re-layout parent.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.setDocked = function(dock, layoutParent) {};

/**
 * [Method] Set the glyph for the panel s header
 * @param {?=} newGlyph Number/String The new glyph This parameter expects a format consistent with that of glyph
 * @return {void}
 */
Ext.MessageBox.setGlyph = function(newGlyph) {};

/**
 * [Method] Sets the height of the component
 * @param {number=} height Number The new height to set. This may be one of:  A Number specifying the new height in the Element's Ext.Element.defaultUnits (by default, pixels). A String used to set the CSS height style. undefined to leave the height unchanged.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.setHeight = function(height) {};

/**
 * [Method] Adds the specified icon to the dialog
 * @param {string=} icon String A CSS classname specifying the icon's background image url, or empty string to clear the icon
 * @param {number=} width Number The width of the icon. If not specified, the default is used
 * @param {number=} height Number The height of the icon. If not specified, the default is used
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.MessageBox.setIcon = function(icon, width, height) {};

/**
 * [Method] Set the iconCls for the panel s header
 * @param {string=} newIconCls String The new CSS class name
 * @return {void}
 */
Ext.MessageBox.setIconCls = function(newIconCls) {};

/**
 * [Method] This method allows you to show or hide a LoadMask on top of this component
 * @param {?=} load Boolean/Object/String True to show the default LoadMask, a config object that will be passed to the LoadMask constructor, or a message String to show. False to hide the current LoadMask.
 * @param {boolean=} targetEl Boolean True to mask the targetEl of this Component instead of the this.el. For example, setting this to true on a Panel will cause only the body to be masked.
 * @return {!Ext.ILoadMask} Ext.LoadMask The LoadMask instance that has just been shown.
 */
Ext.MessageBox.setLoading = function(load, targetEl) {};

/**
 * [Method] Overridden in Ext rtl AbstractComponent
 * @param {?=} x Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.MessageBox.setLocalX = function(x) {};

/**
 * [Method] Overridden in Ext rtl AbstractComponent
 * @param {?=} x Object
 * @param {?=} y Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.MessageBox.setLocalXY = function(x, y) {};

/**
 * [Method] Sets the local y coordinate of this element using CSS style
 * @param {?=} y Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.MessageBox.setLocalY = function(y) {};

/**
 * [Method] Sets the margin on the target element
 * @param {?=} margin Number/String The margin to set. See the margin config.
 * @return {void}
 */
Ext.MessageBox.setMargin = function(margin) {};

/**
 * [Method] Sets the overflow x y on the content element of the component
 * @param {string=} overflowX String The overflow-x value.
 * @param {string=} overflowY String The overflow-y value.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.setOverflowXY = function(overflowX, overflowY) {};

/**
 * [Method] Sets the page XY position of the component
 * @param {?=} x Number/Number[] The new x position or an array of [x,y].
 * @param {number=} y Number The new y position.
 * @param {?=} animate Boolean/Object True to animate the Component into its new position. You may also pass an animation configuration.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.setPagePosition = function(x, y, animate) {};

/**
 * [Method] Sets the left and top of the component
 * @param {?=} x Number/Number[]/Object The new left, an array of [x,y], or animation config object containing x and y properties.
 * @param {number=} y Number The new top.
 * @param {?=} animate Boolean/Object If true, the Component is animated into its new position. You may also pass an animation configuration.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.setPosition = function(x, y, animate) {};

/**
 * [Method] Sets the element s position and size to the specified region
 * @param {!Ext.util.IRegion=} region Ext.util.Region The region to fill
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.MessageBox.setRegion = function(region, animate) {};

/**
 * [Method] Sets the weight config property for this component
 * @param {number=} weight Number The new weight value.
 * @return {number} Number The previous value of the weight property.
 */
Ext.MessageBox.setRegionWeight = function(weight) {};

/**
 * [Method] Sets the width and height of this Component
 * @param {?=} width Number/String/Object The new width to set. This may be one of:  A Number specifying the new width in the Element's Ext.Element.defaultUnits (by default, pixels). A String used to set the CSS width style. A size object in the format {width: widthValue, height: heightValue}. undefined to leave the width unchanged.
 * @param {?=} height Number/String The new height to set (not required if a size object is passed as the first arg). This may be one of:  A Number specifying the new height in the Element's Ext.Element.defaultUnits (by default, pixels). A String used to set the CSS height style. Animation may not be used. undefined to leave the height unchanged.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.setSize = function(width, height) {};

/**
 * [Method] Set a title for the panel s header
 * @param {string=} newTitle String
 * @return {void}
 */
Ext.MessageBox.setTitle = function(newTitle) {};

/**
 * [Method] Sets the UI for the component
 * @param {?=} ui Object
 * @return {void}
 */
Ext.MessageBox.setUI = function(ui) {};

/**
 * [Method] Convenience function to hide or show this component by Boolean
 * @param {boolean=} visible Boolean true to show, false to hide.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.setVisible = function(visible) {};

/**
 * [Method] Sets the width of the component
 * @param {number=} width Number The new width to setThis may be one of:  A Number specifying the new width in the Element's Ext.Element.defaultUnits (by default, pixels). A String used to set the CSS width style.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.setWidth = function(width) {};

/**
 * [Method] Sets the X position of the DOM element based on page coordinates
 * @param {?=} x Object
 * @param {?=} animate Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.MessageBox.setX = function(x, animate) {};

/**
 * [Method] Sets the position of the DOM element in page coordinates
 * @param {?=} xy Object
 * @param {?=} animate Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.MessageBox.setXY = function(xy, animate) {};

/**
 * [Method] Sets the Y position of the DOM element based on page coordinates
 * @param {?=} y Object
 * @param {?=} animate Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.MessageBox.setY = function(y, animate) {};

/**
 * [Method] Displays a new message box or reinitializes an existing message box based on the config options passed in
 * @param {?=} config Object The following config options are supported:
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.MessageBox.show = function(config) {};

/**
 * [Method] Displays component at specific xy position
 * @param {?=} x Number/Number[] The new x position or array of [x,y].
 * @param {number=} y Number The new y position
 * @param {?=} animate Boolean/Object True to animate the Component into its new position. You may also pass an animation configuration.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.showAt = function(x, y, animate) {};

/**
 * [Method] Shows this component by the specified Component or Element
 * @param {?=} component Ext.Component/Ext.dom.Element The Ext.Component or Ext.Element to show the component by.
 * @param {string=} position String Alignment position as used by Ext.util.Positionable.getAlignToXY. Defaults to defaultAlign.
 * @param {!Array<number>=} offsets Number[] Alignment offsets as used by Ext.util.Positionable.getAlignToXY.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.showBy = function(component, position, offsets) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.MessageBox.statics = function() {};

/**
 * [Method] Stops any running effects and clears this object s internal effects queue if it contains any additional effects that
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.MessageBox.stopAnimation = function() {};

/**
 * [Method] Stops any running effects and clears this object s internal effects queue if it contains any additional effects that
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.MessageBox.stopFx = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.MessageBox.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.MessageBox.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Ensures that all effects queued after syncFx is called on this object are run concurrently
 * @return {?} Object this
 */
Ext.MessageBox.syncFx = function() {};

/**
 * [Method] Sends this Component to the back of lower z index than any other visible windows
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.toBack = function() {};

/**
 * [Method] Brings this floating Component to the front of any other visible floating Components managed by the same ZIndexManag
 * @param {boolean=} preventFocus Boolean Specify true to prevent the Component from being focused.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.toFront = function(preventFocus) {};

/**
 * [Method] Shortcut for performing an expand or collapse based on the current state of the panel
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.MessageBox.toggleCollapse = function() {};

/**
 * [Method] A shortcut method for toggling between maximize and restore based on the current maximized state of the window
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.MessageBox.toggleMaximize = function() {};

/**
 * [Method] Translates the passed page coordinates into left top css values for the element
 * @param {?=} x Number/Array The page x or an array containing [x, y]
 * @param {number=} y Number The page y, required if x is not an array
 * @return {?} Object An object with left and top properties. e.g. {left: (value), top: (value)}
 */
Ext.MessageBox.translatePoints = function(x, y) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.MessageBox.un = function(eventName, fn, scope) {};

/**
 * [Method] Navigates up the ownership hierarchy searching for an ancestor Container which matches any passed simple selector or
 * @param {?=} selector String/Ext.Component The simple selector component or actual component to test. If not passed the immediate owner/activater is returned.
 * @param {?=} limit String/Number/Ext.Component This may be a selector upon which to stop the upward scan, or a limit of teh number of steps, or Component reference to stop on.
 * @return {!Ext.container.IContainer} Ext.container.Container The matching ancestor Container (or undefined if no match was found).
 */
Ext.MessageBox.up = function(selector, limit) {};

/**
 * [Method] Update the content area of a component
 * @param {?=} htmlOrData String/Object If this component has been configured with a template via the tpl config then it will use this argument as data to populate the template. If this component was not configured with a template, the components content area will be updated via Ext.Element update.
 * @param {boolean=} loadScripts Boolean Only legitimate when using the html configuration.
 * @param {?=} callback Function Only legitimate when using the html configuration. Callback to execute when scripts have finished loading.
 * @return {void}
 */
Ext.MessageBox.update = function(htmlOrData, loadScripts, callback) {};

/**
 * [Method] Sets the current box measurements of the component s underlying element
 * @param {?=} box Object An object in the format {x, y, width, height}
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.MessageBox.updateBox = function(box) {};

/**
 * [Method] Updates this component s layout
 * @param {?=} options Object An object with layout options.
 * @return {void}
 */
Ext.MessageBox.updateLayout = function(options) {};

/**
 * [Method] Updates a progress style message box s text and progress bar
 * @param {number=} value Number Any number between 0 and 1 (e.g., .5)
 * @param {string=} progressText String The progress text to display inside the progress bar.
 * @param {string=} msg String The message box's body text is replaced with the specified string (defaults to undefined so that any existing body text will not get overwritten by default unless a new value is passed in)
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.MessageBox.updateProgress = function(value, progressText, msg) {};

/**
 * [Method] Displays a message box with an infinitely auto updating progress bar
 * @param {string=} msg String The message box body text
 * @param {string=} title String The title bar text
 * @param {?=} config Object A Ext.ProgressBar.wait config object
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.MessageBox.wait = function(msg, title, config) {};
/**
 * @extends {Ext.window.IMessageBox}
 * @record
 * @struct
 */
Ext.IMsg = function() {};
/**
 * @constructor
 * @struct
 */
Ext.Msg = function() {};
 /** @type {number} */
Ext.Msg.CANCEL;
 /** @type {string} */
Ext.Msg.ERROR;
 /** @type {string} */
Ext.Msg.INFO;
 /** @type {number} */
Ext.Msg.NO;
 /** @type {number} */
Ext.Msg.OK;
 /** @type {number} */
Ext.Msg.OKCANCEL;
 /** @type {string} */
Ext.Msg.QUESTION;
 /** @type {string} */
Ext.Msg.WARNING;
 /** @type {number} */
Ext.Msg.YES;
 /** @type {number} */
Ext.Msg.YESNO;
 /** @type {number} */
Ext.Msg.YESNOCANCEL;
 /** @type {boolean} */
Ext.Msg._isLayoutRoot;
 /** @type {!Ext.dom.IElement} */
Ext.Msg.body;
 /** @type {?} */
Ext.Msg.buttonText;
 /** @type {string} */
Ext.Msg.contentPaddingProperty;
 /** @type {!Ext.util.IComponentDragger} */
Ext.Msg.dd;
 /** @type {number} */
Ext.Msg.defaultTextHeight;
 /** @type {boolean} */
Ext.Msg.draggable;
 /** @type {!Ext.IContainer} */
Ext.Msg.floatParent;
 /** @type {?} */
Ext.Msg.frameSize;
 /** @type {?} */
Ext.Msg.hasListeners;
 /** @type {boolean} */
Ext.Msg.isComponent;
 /** @type {boolean} */
Ext.Msg.isObservable;
 /** @type {boolean} */
Ext.Msg.isPanel;
 /** @type {boolean} */
Ext.Msg.isWindow;
 /** @type {!Ext.util.IAbstractMixedCollection} */
Ext.Msg.items;
 /** @type {boolean} */
Ext.Msg.maskOnDisable;
 /** @type {number} */
Ext.Msg.minProgressWidth;
 /** @type {number} */
Ext.Msg.minPromptWidth;
 /** @type {!Ext.IContainer} */
Ext.Msg.ownerCt;
 /** @type {boolean} */
Ext.Msg.rendered;
 /** @type {?} */
Ext.Msg.scrollFlags;
 /** @type {!Ext.IClass} */
Ext.Msg.self;
 /** @type {!Ext.IZIndexManager} */
Ext.Msg.zIndexManager;
 /** @type {!Ext.IContainer} */
Ext.Msg.zIndexParent;

/**
 * [Method] Adds Component s to this Container
 * @param {?=} component Ext.Component[]|Object[]/Ext.Component.../Object... Either one or more Components to add or an Array of Components to add. See items for additional information.
 * @return {?} Ext.Component[]/Ext.Component The Components that were added.
 */
Ext.Msg.add = function(component) {};

/**
 * [Method] Adds a CSS class to the body element
 * @param {string=} cls String The class to add
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.Msg.addBodyCls = function(cls) {};

/**
 * [Method] Adds each argument passed to this method to the childEls array
 * @return {void}
 */
Ext.Msg.addChildEls = function() {};

/**
 * [Method] Adds a CSS class to the top level element representing this component
 * @param {?=} cls String/String[] The CSS class name to add.
 * @return {!Ext.IComponent} Ext.Component Returns the Component to allow method chaining.
 */
Ext.Msg.addClass = function(cls) {};

/**
 * [Method] Adds a CSS class to the top level element representing this component
 * @param {?=} cls String/String[] The CSS class name to add.
 * @return {!Ext.IComponent} Ext.Component Returns the Component to allow method chaining.
 */
Ext.Msg.addCls = function(cls) {};

/**
 * [Method] Adds a cls to the uiCls array which will also call addUIClsToElement and adds to all elements of this component
 * @param {?=} classes String/String[] A string or an array of strings to add to the uiCls.
 * @param {?=} skip Object (Boolean) skip true to skip adding it to the class and do it later (via the return).
 * @return {void}
 */
Ext.Msg.addClsWithUI = function(classes, skip) {};

/**
 * [Method] Adds docked item s to the container
 * @param {?=} component Object/Object[] The Component or array of components to add. The components must include a 'dock' parameter on each component to indicate where it should be docked ('top', 'right', 'bottom', 'left').
 * @param {number=} pos Number The index at which the Component will be added
 * @return {!Array<!Ext.IComponent>} Ext.Component[] The added components.
 */
Ext.Msg.addDocked = function(component, pos) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.Msg.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} element Object
 * @param {?=} listeners Object
 * @param {?=} scope Object
 * @param {?=} options Object
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.Msg.addListener = function(element, listeners, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.Msg.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Save a property to the given state object if it is not its default or configured value
 * @param {?=} state Object The state object.
 * @param {string=} propName String The name of the property on this object to save.
 * @param {string=} value String The value of the state property (defaults to this[propName]).
 * @return {boolean} Boolean The state object or a new object if state was null and the property was saved.
 */
Ext.Msg.addPropertyToState = function(state, propName, value) {};

/**
 * [Method] Add events that will trigger the state to be saved
 * @param {?=} events String/String[] The event name or an array of event names.
 * @return {void}
 */
Ext.Msg.addStateEvents = function(events) {};

/**
 * [Method] Add tools to this panel
 * @param {?=} tools Object[]/Ext.panel.Tool[] The tools to add
 * @return {void}
 */
Ext.Msg.addTool = function(tools) {};

/**
 * [Method] inherit docs
 * @param {?=} cls Object
 * @return {void}
 */
Ext.Msg.addUIClsToElement = function(cls) {};

/**
 * [Method] Invoked after the Panel is Collapsed
 * @return {void}
 */
Ext.Msg.afterCollapse = function() {};

/**
 * [Method] Called by the layout system after the Component has been laid out
 * @return {void}
 */
Ext.Msg.afterComponentLayout = function() {};

/**
 * [Method] Invoked after the Panel is Expanded
 * @return {void}
 */
Ext.Msg.afterExpand = function() {};

/**
 * [Method] Invoked after the Container has laid out and rendered if necessary its child Components
 * @param {!Ext.layout.container.IContainer=} layout Ext.layout.container.Container
 * @return {void}
 */
Ext.Msg.afterLayout = function(layout) {};

/**
 * [Method] Template method called after a Component has been positioned
 * @param {?=} ax Object
 * @param {?=} ay Object
 * @return {void}
 */
Ext.Msg.afterSetPosition = function(ax, ay) {};

/**
 * [Method] Invoked after the Component is shown after onShow is called
 * @param {?=} animateTarget String/Ext.Element
 * @param {?=} callback Function
 * @param {?=} scope Object
 * @return {void}
 */
Ext.Msg.afterShow = function(animateTarget, callback, scope) {};

/**
 * [Method] Displays a standard read only message box with an OK button comparable to the basic JavaScript alert prompt
 * @param {string=} title String The title bar text
 * @param {string=} msg String The message box body text
 * @param {?=} fn Function The callback function invoked after the message box is closed. See show method for details.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed.
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.Msg.alert = function(title, msg, fn, scope) {};

/**
 * [Method] Aligns the element with another element relative to the specified anchor points
 * @param {?=} element Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or id of the element to align to.
 * @param {string=} position String The position to align to
 * @param {!Array<number>=} offsets Number[] Offset the positioning by [x, y]
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.Msg.alignTo = function(element, position, offsets, animate) {};

/**
 * [Method] Anchors an element to another element and realigns it when the window is resized
 * @param {?=} element Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or id of the element to align to.
 * @param {string=} position String The position to align to
 * @param {!Array<number>=} offsets Number[] Offset the positioning by [x, y]
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @param {?=} monitorScroll Boolean/Number True to monitor body scroll and reposition. If this parameter is a number, it is used as the buffer delay in milliseconds.
 * @param {?=} callback Function The function to call after the animation finishes
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.Msg.anchorTo = function(element, position, offsets, animate, monitorScroll, callback) {};

/**
 * [Method] Performs custom animation on this object
 * @param {?=} animObj Object
 * @return {?} Object this
 */
Ext.Msg.animate = function(animObj) {};

/**
 * [Method] Applies the state to the object
 * @param {?=} state Object
 * @return {void}
 */
Ext.Msg.applyState = function(state) {};

/**
 * [Method] Template method to do any pre blur processing
 * @param {!Ext.IEventObject=} e Ext.EventObject The event object
 * @return {void}
 */
Ext.Msg.beforeBlur = function(e) {};

/**
 * [Method] Occurs before componentLayout is run
 * @param {number=} adjWidth Number The box-adjusted width that was set.
 * @param {number=} adjHeight Number The box-adjusted height that was set.
 * @return {void}
 */
Ext.Msg.beforeComponentLayout = function(adjWidth, adjHeight) {};

/**
 * [Method] Template method to do any pre focus processing
 * @param {!Ext.IEventObject=} e Ext.EventObject The event object
 * @return {void}
 */
Ext.Msg.beforeFocus = function(e) {};

/**
 * [Method] Occurs before componentLayout is run
 * @return {void}
 */
Ext.Msg.beforeLayout = function() {};

/**
 * [Method] Invoked before the Component is shown
 * @return {void}
 */
Ext.Msg.beforeShow = function() {};

/**
 * [Method] Bubbles up the component container heirarchy calling the specified function with each component
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope of the function. Defaults to current node.
 * @param {!Array<?>=} args Array The args to call the function with. Defaults to passing the current component.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.bubble = function(fn, scope, args) {};

/**
 * [Method] Calculates the new x y position to move this Positionable into a constrain region
 * @param {?=} constrainTo String/HTMLElement/Ext.Element/Ext.util.Region The Element or Region into which this Component is to be constrained. Defaults to the element into which this Positionable was rendered, or this Component's {\@link Ext.Component.constrainTo.
 * @param {!Array<number>=} proposedPosition Number[] A proposed [X, Y] position to test for validity and to coerce into constraints instead of using this Positionable's current position.
 * @param {boolean=} local Boolean The proposedPosition is local (relative to floatParent if a floating Component)
 * @param {!Array<number>=} proposedSize Number[] A proposed [width, height] size to use when calculating constraints instead of using this Positionable's current size.
 * @return {!Array<number>} Number[] If the element needs to be translated, the new [X, Y] position within constraints if possible, giving priority to keeping the top and left edge in the constrain region. Otherwise, false.
 */
Ext.Msg.calculateConstrainedPosition = function(constrainTo, proposedPosition, local, proposedSize) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.Msg.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.Msg.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.Msg.callSuper = function(args) {};

/**
 * [Method] Cancel any deferred focus on this component
 * @return {void}
 */
Ext.Msg.cancelFocus = function() {};

/**
 * [Method] Cascades down the component container heirarchy from this component passed in the first call  calling the specified
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope of the function (defaults to current component)
 * @param {!Array<?>=} args Array The args to call the function with. The current component always passed as the last argument.
 * @return {!Ext.IContainer} Ext.Container this
 */
Ext.Msg.cascade = function(fn, scope, args) {};

/**
 * [Method] Center this Component in its container
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.center = function() {};

/**
 * [Method] Retrieves the first direct child of this container which matches the passed selector or component
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching child Ext.Component (or null if no match was found).
 */
Ext.Msg.child = function(selector) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.Msg.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.Msg.clearManagedListeners = function() {};

/**
 * [Method] Clone the current component using the original config values passed into this instance by default
 * @param {?=} overrides Object A new config containing any properties to override in the cloned version. An id property can be passed on this object, otherwise one will be generated to avoid duplicates.
 * @return {!Ext.IComponent} Ext.Component clone The cloned copy of this component
 */
Ext.Msg.cloneConfig = function(overrides) {};

/**
 * [Method] Closes the Panel
 * @return {void}
 */
Ext.Msg.close = function() {};

/**
 * [Method] Collapses the panel body so that the body becomes hidden
 * @param {string=} direction String The direction to collapse towards. Must be one of  Ext.Component.DIRECTION_TOP Ext.Component.DIRECTION_RIGHT Ext.Component.DIRECTION_BOTTOM Ext.Component.DIRECTION_LEFT Defaults to collapseDirection.
 * @param {boolean=} animate Boolean True to animate the transition, else false (defaults to the value of the animCollapse panel config). May also be specified as the animation duration in milliseconds.
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.Msg.collapse = function(direction, animate) {};

/**
 * [Method] Displays a confirmation message box with Yes and No buttons comparable to JavaScript s confirm
 * @param {string=} title String The title bar text
 * @param {string=} msg String The message box body text
 * @param {?=} fn Function The callback function invoked after the message box is closed. See show method for details.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed.
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.Msg.confirm = function(title, msg, fn, scope) {};

/**
 * [Method] Determines whether the passed Component is either an immediate child of this Container or whether it is a descendant
 * @param {!Ext.IComponent=} comp Ext.Component The Component to test.
 * @param {boolean=} deep Boolean Pass true to test for the Component being a descendant at any level.
 * @return {boolean} Boolean true if the passed Component is contained at the specified level.
 */
Ext.Msg.contains = function(comp, deep) {};

/**
 * [Method] converts a collapsdDir into an anchor argument for Element slideIn overridden in rtl mode to switch l and r
 * @param {?=} collapseDir Object
 * @return {void}
 */
Ext.Msg.convertCollapseDir = function(collapseDir) {};

/**
 * [Method] Inherit docs Disable all immediate children that was previously disabled Override disable because onDisable only gets
 * @return {!Ext.container.IAbstractContainer} Ext.container.AbstractContainer this
 */
Ext.Msg.disable = function() {};

/**
 * [Method] Handles autoRender
 * @return {void}
 */
Ext.Msg.doAutoRender = function() {};

/**
 * [Method] This method needs to be called whenever you change something on this component that requires the Component s layout t
 * @return {!Ext.container.IContainer} Ext.container.Container this
 */
Ext.Msg.doComponentLayout = function() {};

/**
 * [Method] Moves this floating Component into a constrain region
 * @param {?=} constrainTo String/HTMLElement/Ext.Element/Ext.util.Region The Element or Region into which this Component is to be constrained. Defaults to the element into which this floating Component was rendered.
 * @return {void}
 */
Ext.Msg.doConstrain = function(constrainTo) {};

/**
 * [Method] Manually force this container s layout to be recalculated
 * @return {!Ext.container.IContainer} Ext.container.Container this
 */
Ext.Msg.doLayout = function() {};

/**
 * [Method] Retrieves the first descendant of this container which matches the passed selector
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector or Ext.Component. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching descendant Ext.Component (or null if no match was found).
 */
Ext.Msg.down = function(selector) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.Msg.enableBubble = function(eventNames) {};

/**
 * [Method] Ensures that this component is attached to document body
 * @param {boolean=} runLayout Boolean True to run the component's layout.
 * @return {void}
 */
Ext.Msg.ensureAttachedToBody = function(runLayout) {};

/**
 * [Method] Expands the panel body so that it becomes visible
 * @param {boolean=} animate Boolean True to animate the transition, else false (defaults to the value of the animCollapse panel config). May also be specified as the animation duration in milliseconds.
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.Msg.expand = function(animate) {};

/**
 * [Method] Find a container above this component at any level by a custom function
 * @param {?=} fn Function The custom function to call with the arguments (container, this component).
 * @return {!Ext.container.IContainer} Ext.container.Container The first Container for which the custom function returns true
 */
Ext.Msg.findParentBy = function(fn) {};

/**
 * [Method] Find a container above this component at any level by xtype or class See also the up method
 * @param {?=} xtype String/Ext.Class The xtype string for a component, or the class of the component directly
 * @return {!Ext.container.IContainer} Ext.container.Container The first Container which matches the given xtype or class
 */
Ext.Msg.findParentByType = function(xtype) {};

/**
 * [Method] Retrieves plugin from this component s collection by its ptype
 * @param {string=} ptype String The Plugin's ptype as specified by the class's alias configuration.
 * @return {!Ext.IAbstractPlugin} Ext.AbstractPlugin plugin instance.
 */
Ext.Msg.findPlugin = function(ptype) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.Msg.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.Msg.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Try to focus this component
 * @param {boolean=} selectText Boolean If applicable, true to also select the text in this component
 * @param {?=} delay Boolean/Number Delay the focus this number of milliseconds (true for 10 milliseconds).
 * @param {?=} callback Function Only needed if the delay parameter is used. A function to call upon focus.
 * @param {?=} scope Function Only needed if the delay parameter is used. The scope (this reference) in which to execute the callback.
 * @return {!Ext.IComponent} Ext.Component The focused Component. Usually this Component. Some Containers may delegate focus to a descendant Component (Windows can do this through their defaultFocus config option.
 */
Ext.Msg.focus = function(selectText, delay, callback, scope) {};

/**
 * [Method] Forces this component to redo its componentLayout
 * @return {void}
 */
Ext.Msg.forceComponentLayout = function() {};

/**
 * [Method] Returns the current animation if this object has any effects actively running or queued else returns false
 * @return {?} Ext.fx.Anim/Boolean Anim if element has active effects, else false
 */
Ext.Msg.getActiveAnimation = function() {};

/**
 * [Method] Gets the x y coordinates to align this element with another element
 * @param {?=} element Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or id of the element to align to.
 * @param {string=} position String The position to align to
 * @param {!Array<number>=} offsets Number[] Offset the positioning by [x, y]
 * @return {!Array<number>} Number[] [x, y]
 */
Ext.Msg.getAlignToXY = function(element, position, offsets) {};

/**
 * [Method] Gets the x y coordinates specified by the anchor position on the element
 * @param {string=} anchor String The specified anchor position. See alignTo for details on supported anchor positions.
 * @param {boolean=} local Boolean True to get the local (element top/left-relative) anchor position instead of page coordinates
 * @param {?=} size Object An object containing the size to use for calculating anchor position {width: (target width), height: (target height)} (defaults to the element's current size)
 * @return {!Array<number>} Number[] [x, y] An array containing the element's x and y coordinates
 */
Ext.Msg.getAnchorXY = function(anchor, local, size) {};

/**
 * [Method] Return an object defining the area of this Element which can be passed to setBox to set another Element s size locati
 * @param {boolean=} contentBox Boolean If true a box for the content of the element is returned.
 * @param {boolean=} local Boolean If true the element's left and top relative to its offsetParent are returned instead of page x/y.
 * @return {?} Object box An object in the format: {  x: &lt;Element's X position&gt;,  y: &lt;Element's Y position&gt;,  left: &lt;Element's X position (an alias for x)&gt;,  top: &lt;Element's Y position (an alias for y)&gt;,  width: &lt;Element's width&gt;,  height: &lt;Element's height&gt;,  bottom: &lt;Element's lower bound&gt;,  right: &lt;Element's rightmost bound&gt; }  The returned object may also be addressed as an Array where index 0 contains the X position and index 1 contains the Y position. The result may also be used for setXY
 */
Ext.Msg.getBox = function(contentBox, local) {};

/**
 * [Method] Implements an upward event bubbling policy
 * @return {void}
 */
Ext.Msg.getBubbleTarget = function() {};

/**
 * [Method] Return the immediate child Component in which the passed element is located
 * @param {?=} el Ext.Element/HTMLElement/String The element to test (or ID of element).
 * @param {boolean=} deep Boolean If true, returns the deepest descendant Component which contains the passed element.
 * @return {!Ext.IComponent} Ext.Component The child item which contains the passed element.
 */
Ext.Msg.getChildByElement = function(el, deep) {};

/**
 * [Method] Returns the current collapsed state of the panel
 * @return {?} Boolean/String False when not collapsed, otherwise the value of collapseDirection.
 */
Ext.Msg.getCollapsed = function() {};

/**
 * [Method] Attempts a default component lookup see Ext container Container getComponent
 * @param {?=} comp String/Number The component id, itemId or position to find
 * @return {!Ext.IComponent} Ext.Component The component (if found)
 */
Ext.Msg.getComponent = function(comp) {};

/**
 * [Method] Returns the X Y vector by which this Positionable s element must be translated to make a best attempt to constrain
 * @param {?=} constrainTo Ext.util.Positionable/HTMLElement/String/Ext.util.Region The Positionable, HTMLElement, element id, or Region into which the element is to be constrained.
 * @param {!Array<number>=} proposedPosition Number[] A proposed [X, Y] position to test for validity and to produce a vector for instead of using the element's current position
 * @param {!Array<number>=} proposedSize Number[] A proposed [width, height] size to constrain instead of using the element's current size
 * @return {?} Number[]/Boolean If the element needs to be translated, an [X, Y] vector by which this element must be translated. Otherwise, false.
 */
Ext.Msg.getConstrainVector = function(constrainTo, proposedPosition, proposedSize) {};

/**
 * [Method] Gets the configured default focus item
 * @return {void}
 */
Ext.Msg.getDefaultFocus = function() {};

/**
 * [Method] Finds a docked component by id itemId or position
 * @param {?=} comp String/Number The id, itemId or position of the docked component (see getComponent for details)
 * @return {!Ext.IComponent} Ext.Component The docked component (if found)
 */
Ext.Msg.getDockedComponent = function(comp) {};

/**
 * [Method] Retrieves an array of all currently docked Components
 * @param {string=} selector String A ComponentQuery selector string to filter the returned items.
 * @param {boolean=} beforeBody Boolean An optional flag to limit the set of items to only those before the body (true) or after the body (false). All components are returned by default.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] The array of docked components meeting the specified criteria.
 */
Ext.Msg.getDockedItems = function(selector, beforeBody) {};

/**
 * [Method] Retrieves the top level element representing this component
 * @return {!Ext.dom.IElement} Ext.dom.Element
 */
Ext.Msg.getEl = function() {};

/**
 * [Method] Gets the Header for this panel
 * @return {void}
 */
Ext.Msg.getHeader = function() {};

/**
 * [Method] Gets the current height of the component s underlying element
 * @return {number} Number
 */
Ext.Msg.getHeight = function() {};

/**
 * [Method] Retrieves the id of this component
 * @return {string} String
 */
Ext.Msg.getId = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.Msg.getInitialConfig = function(name) {};

/**
 * [Method] This function takes the position argument passed to onRender and returns a DOM element that you can use in the insert
 * @param {?=} position String/Number/Ext.dom.Element/HTMLElement Index, element id or element you want to put this component before.
 * @return {!HTMLElement} HTMLElement DOM element that you can use in the insertBefore
 */
Ext.Msg.getInsertPosition = function(position) {};

/**
 * [Method] Returns the value of itemId assigned to this component or when that is not set returns the value of id
 * @return {string} String
 */
Ext.Msg.getItemId = function() {};

/**
 * [Method] Returns the layout instance currently associated with this Container
 * @return {!Ext.layout.container.IContainer} Ext.layout.container.Container The layout
 */
Ext.Msg.getLayout = function() {};

/**
 * [Method] Gets the Ext ComponentLoader for this Component
 * @return {!Ext.IComponentLoader} Ext.ComponentLoader The loader instance, null if it doesn't exist.
 */
Ext.Msg.getLoader = function() {};

/**
 * [Method] Overridden in Ext rtl AbstractComponent
 * @return {number} Number The local x coordinate
 */
Ext.Msg.getLocalX = function() {};

/**
 * [Method] Overridden in Ext rtl AbstractComponent
 * @return {!Array<number>} Number[] The local XY position of the element
 */
Ext.Msg.getLocalXY = function() {};

/**
 * [Method] Returns the y coordinate of this element reletive to its offsetParent
 * @return {number} Number The local y coordinate
 */
Ext.Msg.getLocalY = function() {};

/**
 * [Method] Returns the offsets of this element from the passed element
 * @param {?=} offsetsTo Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or element id to get get the offsets from.
 * @return {!Array<number>} Number[] The XY page offsets (e.g. [100, -200])
 */
Ext.Msg.getOffsetsTo = function(offsetsTo) {};

/**
 * [Method] Retrieves a plugin from this component s collection by its pluginId
 * @param {string=} pluginId String
 * @return {!Ext.IAbstractPlugin} Ext.AbstractPlugin plugin instance.
 */
Ext.Msg.getPlugin = function(pluginId) {};

/**
 * [Method] Gets the current XY position of the component s underlying element
 * @param {boolean=} local Boolean If true the element's left and top are returned instead of page XY.
 * @return {!Array<number>} Number[] The XY position of the element (e.g., [100, 200])
 */
Ext.Msg.getPosition = function(local) {};

/**
 * [Method] Used by ComponentQuery child and down to retrieve all of the items which can potentially be considered a child of th
 * @param {?=} deep Object
 * @return {void}
 */
Ext.Msg.getRefItems = function(deep) {};

/**
 * [Method] Returns a region object that defines the area of this element
 * @return {!Ext.util.IRegion} Ext.util.Region A Region containing "top, left, bottom, right" properties.
 */
Ext.Msg.getRegion = function() {};

/**
 * [Method] Gets the current size of the component s underlying element
 * @return {?} Object An object containing the element's size {width: (element width), height: (element height)}
 */
Ext.Msg.getSize = function() {};

/**
 * [Method] Returns an object that describes how this component s width and height are managed
 * @param {?=} ownerCtSizeModel Object
 * @return {?} Object The size model for this component.
 */
Ext.Msg.getSizeModel = function(ownerCtSizeModel) {};

/**
 * [Method] Returns the content region of this element
 * @return {!Ext.util.IRegion} Ext.util.Region A Region containing "top, left, bottom, right" member data.
 */
Ext.Msg.getViewRegion = function() {};

/**
 * [Method] Gets the current width of the component s underlying element
 * @return {number} Number
 */
Ext.Msg.getWidth = function() {};

/**
 * [Method] Gets the current X position of the DOM element based on page coordinates
 * @return {number} Number The X position of the element
 */
Ext.Msg.getX = function() {};

/**
 * [Method] Gets the xtype for this component as registered with Ext ComponentManager
 * @return {string} String The xtype
 */
Ext.Msg.getXType = function() {};

/**
 * [Method] Returns this Component s xtype hierarchy as a slash delimited string
 * @return {string} String The xtype hierarchy string
 */
Ext.Msg.getXTypes = function() {};

/**
 * [Method] Gets the current position of the DOM element based on page coordinates
 * @return {!Array<number>} Number[] The XY position of the element
 */
Ext.Msg.getXY = function() {};

/**
 * [Method] Gets the current Y position of the DOM element based on page coordinates
 * @return {number} Number The Y position of the element
 */
Ext.Msg.getY = function() {};

/**
 * [Method] Returns the current animation if this object has any effects actively running or queued else returns false
 * @return {?} Ext.fx.Anim/Boolean Anim if element has active effects, else false
 */
Ext.Msg.hasActiveFx = function() {};

/**
 * [Method] Checks if the specified CSS class exists on this element s DOM node
 * @param {string=} className String The CSS class to check for.
 * @return {boolean} Boolean true if the class exists, else false.
 */
Ext.Msg.hasCls = function(className) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.Msg.hasListener = function(eventName) {};

/**
 * [Method] Checks if there is currently a specified uiCls
 * @param {string=} cls String The cls to check.
 * @return {void}
 */
Ext.Msg.hasUICls = function(cls) {};

/**
 * [Method] Hides this Component setting it to invisible using the configured hideMode
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.hide = function() {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.Msg.initConfig = function(config) {};

/**
 * [Method] Initialize any events on this component
 * @return {void}
 */
Ext.Msg.initEvents = function() {};

/**
 * [Method] Inserts a Component into this Container at a specified index
 * @param {number=} index Number The index at which the Component will be inserted into the Container's items collection
 * @param {?=} component Ext.Component/Object The child Component to insert. Ext uses lazy rendering, and will only render the inserted Component should it become necessary. A Component config object may be passed in order to avoid the overhead of constructing a real Component object if lazy rendering might mean that the inserted Component will not be rendered immediately. To take advantage of this 'lazy instantiation', set the Ext.Component.xtype config property to the registered type of the Component wanted. For a list of all available xtypes, see Ext.enums.Widget.
 * @return {!Ext.IComponent} Ext.Component component The Component (or config object) that was inserted with the Container's default config values applied.
 */
Ext.Msg.insert = function(index, component) {};

/**
 * [Method] Inserts docked item s to the panel at the indicated position
 * @param {number=} pos Number The index at which the Component will be inserted
 * @param {?=} component Object/Object[] The Component or array of components to add. The components must include a 'dock' paramater on each component to indicate where it should be docked ('top', 'right', 'bottom', 'left').
 * @return {void}
 */
Ext.Msg.insertDocked = function(pos, component) {};

/**
 * [Method] Tests whether this Component matches the selector string
 * @param {string=} selector String The selector string to test against.
 * @return {boolean} Boolean true if this Component matches the selector.
 */
Ext.Msg.is = function(selector) {};

/**
 * [Method] Determines whether this Container is an ancestor of the passed Component
 * @param {!Ext.IComponent=} possibleDescendant Ext.Component The Component to test for presence within this Container's subtree.
 * @return {void}
 */
Ext.Msg.isAncestor = function(possibleDescendant) {};

/**
 * [Method] Determines whether this component is the descendant of a particular container
 * @param {!Ext.IContainer=} container Ext.Container
 * @return {boolean} Boolean true if the component is the descendant of a particular container, otherwise false.
 */
Ext.Msg.isDescendantOf = function(container) {};

/**
 * [Method] Method to determine whether this Component is currently disabled
 * @return {boolean} Boolean the disabled state of this Component.
 */
Ext.Msg.isDisabled = function() {};

/**
 * [Method] Method to determine whether this Component is draggable
 * @return {boolean} Boolean the draggable state of this component.
 */
Ext.Msg.isDraggable = function() {};

/**
 * [Method] Method to determine whether this Component is droppable
 * @return {boolean} Boolean the droppable state of this component.
 */
Ext.Msg.isDroppable = function() {};

/**
 * [Method] Method to determine whether this Component is floating
 * @return {boolean} Boolean the floating state of this component.
 */
Ext.Msg.isFloating = function() {};

/**
 * [Method] Method to determine whether this Component is currently set to hidden
 * @return {boolean} Boolean the hidden state of this Component.
 */
Ext.Msg.isHidden = function() {};

/**
 * [Method] Determines whether this Component is the root of a layout
 * @return {void}
 */
Ext.Msg.isLayoutRoot = function() {};

/**
 * [Method] Returns true if layout is suspended for this component
 * @return {boolean} Boolean true layout of this component is suspended.
 */
Ext.Msg.isLayoutSuspended = function() {};

/**
 * [Method] Returns true if this component is visible
 * @param {?=} deep Object
 * @return {boolean} Boolean true if this component is visible, false otherwise.
 */
Ext.Msg.isVisible = function(deep) {};

/**
 * [Method] Tests whether or not this Component is of a specific xtype
 * @param {string=} xtype String The xtype to check for this Component
 * @param {boolean=} shallow Boolean true to check whether this Component is directly of the specified xtype, false to check whether this Component is descended from the xtype.
 * @return {boolean} Boolean true if this component descends from the specified xtype, false otherwise.
 */
Ext.Msg.isXType = function(xtype, shallow) {};

/**
 * [Method] Fits the window within its current container and automatically replaces the maximize tool button with the restore
 * @param {boolean=} animate Boolean true to animate this Window to full size.
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.Msg.maximize = function(animate) {};

/**
 * [Method] Placeholder method for minimizing the window
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.Msg.minimize = function() {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.Msg.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Moves a Component within the Container
 * @param {?=} fromIdx Number/Ext.Component The index/component to move.
 * @param {number=} toIdx Number The new index for the Component.
 * @return {!Ext.IComponent} Ext.Component component The Component that was moved.
 */
Ext.Msg.move = function(fromIdx, toIdx) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.Msg.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Returns the next node in the Component tree in tree traversal order
 * @param {string=} selector String A ComponentQuery selector to filter the following nodes.
 * @return {!Ext.IComponent} Ext.Component The next node (or the next node which matches the selector). Returns null if there is no matching node.
 */
Ext.Msg.nextNode = function(selector) {};

/**
 * [Method] Returns the next sibling of this Component
 * @param {string=} selector String A ComponentQuery selector to filter the following items.
 * @return {!Ext.IComponent} Ext.Component The next sibling (or the next sibling which matches the selector). Returns null if there is no matching sibling.
 */
Ext.Msg.nextSibling = function(selector) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.Msg.on = function(eventName, fn, scope, options) {};

/**
 * [Method] This method is invoked after a new Component has been added
 * @param {!Ext.IComponent=} component Ext.Component
 * @param {number=} position Number
 * @return {void}
 */
Ext.Msg.onAdd = function(component, position) {};

/**
 * [Method] Method to manage awareness of when components are added to their respective Container firing an added event
 * @return {void}
 */
Ext.Msg.onAdded = function() {};

/**
 * [Method] This method is invoked before adding a new child Component
 * @param {!Ext.IComponent=} item Ext.Component
 * @return {void}
 */
Ext.Msg.onBeforeAdd = function(item) {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.Msg.onDestroy = function() {};

/**
 * [Method] Allows addition of behavior to the disable operation
 * @return {void}
 */
Ext.Msg.onDisable = function() {};

/**
 * [Method] Invoked after a docked item is added to the Panel
 * @param {!Ext.IComponent=} component Ext.Component
 * @return {void}
 */
Ext.Msg.onDockedAdd = function(component) {};

/**
 * [Method] Invoked after a docked item is removed from the Panel
 * @param {!Ext.IComponent=} component Ext.Component
 * @return {void}
 */
Ext.Msg.onDockedRemove = function(component) {};

/**
 * [Method] Allows addition of behavior to the enable operation
 * @return {void}
 */
Ext.Msg.onEnable = function() {};

/**
 * [Method] Possibly animates down to a target element
 * @return {void}
 */
Ext.Msg.onHide = function() {};

/**
 * [Method] Called after the component is moved this method is empty by default but can be implemented by any subclass that need
 * @return {void}
 */
Ext.Msg.onPosition = function() {};

/**
 * [Method] This method is invoked after a new Component has been removed
 * @param {!Ext.IComponent=} component Ext.Component
 * @param {boolean=} autoDestroy Boolean
 * @return {void}
 */
Ext.Msg.onRemove = function(component, autoDestroy) {};

/**
 * [Method] Method to manage awareness of when components are removed from their respective Container firing a removed event
 * @param {?=} destroying Object
 * @return {void}
 */
Ext.Msg.onRemoved = function(destroying) {};

/**
 * [Method] Allows addition of behavior to the resize operation
 * @return {void}
 */
Ext.Msg.onResize = function() {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.Msg.onShow = function() {};

/**
 * [Method] Invoked after the afterShow method is complete
 * @param {?=} callback Function
 * @param {?=} scope Object
 * @return {void}
 */
Ext.Msg.onShowComplete = function(callback, scope) {};

/**
 * [Method] Template method to do any post blur processing
 * @param {!Ext.IEventObject=} e Ext.EventObject The event object
 * @return {void}
 */
Ext.Msg.postBlur = function(e) {};

/**
 * [Method] Returns the previous node in the Component tree in tree traversal order
 * @param {string=} selector String A ComponentQuery selector to filter the preceding nodes.
 * @return {!Ext.IComponent} Ext.Component The previous node (or the previous node which matches the selector). Returns null if there is no matching node.
 */
Ext.Msg.previousNode = function(selector) {};

/**
 * [Method] Returns the previous sibling of this Component
 * @param {string=} selector String A ComponentQuery selector to filter the preceding items.
 * @return {!Ext.IComponent} Ext.Component The previous sibling (or the previous sibling which matches the selector). Returns null if there is no matching sibling.
 */
Ext.Msg.previousSibling = function(selector) {};

/**
 * [Method] Displays a message box with a progress bar
 * @param {string=} title String The title bar text
 * @param {string=} msg String The message box body text
 * @param {string=} progressText String The text to display inside the progress bar
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.Msg.progress = function(title, msg, progressText) {};

/**
 * [Method] Displays a message box with OK and Cancel buttons prompting the user to enter some text comparable to JavaScript s p
 * @param {string=} title String The title bar text
 * @param {string=} msg String The message box body text
 * @param {?=} fn Function The callback function invoked after the message box is closed. See show method for details.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed.
 * @param {?=} multiline Boolean/Number True to create a multiline textbox using the defaultTextHeight property, or the height in pixels to create the textbox/
 * @param {string=} value String Default value of the text input element
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.Msg.prompt = function(title, msg, fn, scope, multiline, value) {};

/**
 * [Method] Retrieves all descendant components which match the passed selector
 * @param {string=} selector String Selector complying to an Ext.ComponentQuery selector. If no selector is specified all items will be returned.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components which matched the selector
 */
Ext.Msg.query = function(selector) {};

/**
 * [Method] Retrieves all descendant components which match the passed function
 * @param {?=} fn Function The matcher function. It will be called with a single argument, the component being tested.
 * @param {?=} scope Object The scope in which to run the function. If not specified, it will default to the active component.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components matched by the passed function
 */
Ext.Msg.queryBy = function(fn, scope) {};

/**
 * [Method] Finds a component at any level under this container matching the id itemId
 * @param {string=} id String The id to find
 * @return {!Ext.IComponent} Ext.Component The matching id, null if not found
 */
Ext.Msg.queryById = function(id) {};

/**
 * [Method] Called by Component doAutoRender Register a Container configured floating true with this Component s ZIndexManager
 * @param {?=} cmp Object
 * @return {void}
 */
Ext.Msg.registerFloatingItem = function(cmp) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.Msg.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes a component from this container
 * @param {?=} component Ext.Component/String The component reference or id to remove.
 * @param {boolean=} autoDestroy Boolean True to automatically invoke the removed Component's Ext.Component.destroy function. Defaults to the value of this Container's autoDestroy config.
 * @return {!Ext.IComponent} Ext.Component component The Component that was removed.
 */
Ext.Msg.remove = function(component, autoDestroy) {};

/**
 * [Method] Removes all components from this container
 * @param {boolean=} autoDestroy Boolean True to automatically invoke the removed Component's Ext.Component.destroy function. Defaults to the value of this Container's autoDestroy config.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Array of the removed components
 */
Ext.Msg.removeAll = function(autoDestroy) {};

/**
 * [Method] Remove any anchor to this element
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.Msg.removeAnchor = function() {};

/**
 * [Method] Removes a CSS class from the body element
 * @param {string=} cls String The class to remove
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.Msg.removeBodyCls = function(cls) {};

/**
 * [Method] Removes items in the childEls array based on the return value of a supplied test function
 * @param {?=} testFn Function The test function.
 * @return {void}
 */
Ext.Msg.removeChildEls = function(testFn) {};

/**
 * [Method] Removes a CSS class from the top level element representing this component
 * @param {?=} cls String/String[] The CSS class name to remove.
 * @return {!Ext.IComponent} Ext.Component Returns the Component to allow method chaining.
 */
Ext.Msg.removeCls = function(cls) {};

/**
 * [Method] Removes a cls to the uiCls array which will also call removeUIClsFromElement and removes it from all elements of thi
 * @param {?=} cls String/String[] A string or an array of strings to remove to the uiCls.
 * @return {void}
 */
Ext.Msg.removeClsWithUI = function(cls) {};

/**
 * [Method] Removes the docked item from the panel
 * @param {!Ext.IComponent=} item Ext.Component The Component to remove.
 * @param {boolean=} autoDestroy Boolean Destroy the component after removal.
 * @return {void}
 */
Ext.Msg.removeDocked = function(item, autoDestroy) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.Msg.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.Msg.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] inherit docs
 * @param {?=} cls Object
 * @return {void}
 */
Ext.Msg.removeUIClsFromElement = function(cls) {};

/**
 * [Method] Renders the Component into the passed HTML element
 * @param {?=} container Ext.Element/HTMLElement/String The element this Component should be rendered into. If it is being created from existing markup, this should be omitted.
 * @param {?=} position String/Number The element ID or DOM node index within the container before which this component will be inserted (defaults to appending to the end of the container)
 * @return {void}
 */
Ext.Msg.render = function(container, position) {};

/**
 * [Method] Restores a maximized window back to its original size and position prior to being maximized and also replaces the re
 * @param {?=} animate Object
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.Msg.restore = function(animate) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.Msg.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.Msg.resumeEvents = function() {};

/**
 * [Method] Conditionally saves a single property from this object to the given state object
 * @param {string=} propName String The name of the property to save.
 * @param {?=} state Object The state object in to which to save the property.
 * @param {string=} stateName String The name to use for the property in state.
 * @return {boolean} Boolean True if the property was saved, false if not.
 */
Ext.Msg.savePropToState = function(propName, state, stateName) {};

/**
 * [Method] Gathers additional named properties of the instance and adds their current values to the passed state object
 * @param {?=} propNames String/String[] The name (or array of names) of the property to save.
 * @param {?=} state Object The state object in to which to save the property values.
 * @return {?} Object state
 */
Ext.Msg.savePropsToState = function(propNames, state) {};

/**
 * [Method] Saves the state of the object to the persistence store
 * @return {void}
 */
Ext.Msg.saveState = function() {};

/**
 * [Method] Scrolls this Component s target element by the passed delta values optionally animating
 * @param {?=} deltaX Number/Number[]/Object Either the x delta, an Array specifying x and y deltas or an object with "x" and "y" properties.
 * @param {?=} deltaY Number/Boolean/Object Either the y delta, or an animate flag or config object.
 * @param {?=} animate Boolean/Object Animate flag/config object if the delta values were passed separately.
 * @return {void}
 */
Ext.Msg.scrollBy = function(deltaX, deltaY, animate) {};

/**
 * [Method] Ensures that all effects queued after sequenceFx is called on this object are run in sequence
 * @return {?} Object this
 */
Ext.Msg.sequenceFx = function() {};

/**
 * [Method] This method is called internally by Ext ZIndexManager to signal that a floating Component has either been moved to th
 * @param {boolean=} active Boolean True to activate the Component, false to deactivate it.
 * @param {!Ext.IComponent=} newActive Ext.Component The newly active Component which is taking over topmost zIndex position.
 * @return {void}
 */
Ext.Msg.setActive = function(active, newActive) {};

/**
 * [Method] Sets the overflow on the content element of the component
 * @param {boolean=} scroll Boolean True to allow the Component to auto scroll.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.setAutoScroll = function(scroll) {};

/**
 * [Method] Sets the body style according to the passed parameters
 * @param {?=} style Mixed A full style specification string, or object, or the name of a style property to set.
 * @param {string=} value String If the first param was a style property name, the style property value.
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.Msg.setBodyStyle = function(style, value) {};

/**
 * [Method]
 * @param {?=} border Object
 * @param {?=} targetEl Object
 * @return {void}
 */
Ext.Msg.setBorder = function(border, targetEl) {};

/**
 * [Method] This method changes the region config property for this border region
 * @param {string=} region String The new region value ("north", "south", "east" or "west").
 * @return {string} String The previous value of the region property.
 */
Ext.Msg.setBorderRegion = function(region) {};

/**
 * [Method] Sets the element s box
 * @param {?=} box Object The box to fill {x, y, width, height}
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.Msg.setBox = function(box, animate) {};

/**
 * [Method] Enable or disable the component
 * @param {boolean=} disabled Boolean true to disable.
 * @return {void}
 */
Ext.Msg.setDisabled = function(disabled) {};

/**
 * [Method] Sets the dock position of this component in its parent panel
 * @param {?=} dock Object The dock position.
 * @param {boolean=} layoutParent Boolean true to re-layout parent.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.setDocked = function(dock, layoutParent) {};

/**
 * [Method] Set the glyph for the panel s header
 * @param {?=} newGlyph Number/String The new glyph This parameter expects a format consistent with that of glyph
 * @return {void}
 */
Ext.Msg.setGlyph = function(newGlyph) {};

/**
 * [Method] Sets the height of the component
 * @param {number=} height Number The new height to set. This may be one of:  A Number specifying the new height in the Element's Ext.Element.defaultUnits (by default, pixels). A String used to set the CSS height style. undefined to leave the height unchanged.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.setHeight = function(height) {};

/**
 * [Method] Adds the specified icon to the dialog
 * @param {string=} icon String A CSS classname specifying the icon's background image url, or empty string to clear the icon
 * @param {number=} width Number The width of the icon. If not specified, the default is used
 * @param {number=} height Number The height of the icon. If not specified, the default is used
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.Msg.setIcon = function(icon, width, height) {};

/**
 * [Method] Set the iconCls for the panel s header
 * @param {string=} newIconCls String The new CSS class name
 * @return {void}
 */
Ext.Msg.setIconCls = function(newIconCls) {};

/**
 * [Method] This method allows you to show or hide a LoadMask on top of this component
 * @param {?=} load Boolean/Object/String True to show the default LoadMask, a config object that will be passed to the LoadMask constructor, or a message String to show. False to hide the current LoadMask.
 * @param {boolean=} targetEl Boolean True to mask the targetEl of this Component instead of the this.el. For example, setting this to true on a Panel will cause only the body to be masked.
 * @return {!Ext.ILoadMask} Ext.LoadMask The LoadMask instance that has just been shown.
 */
Ext.Msg.setLoading = function(load, targetEl) {};

/**
 * [Method] Overridden in Ext rtl AbstractComponent
 * @param {?=} x Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.Msg.setLocalX = function(x) {};

/**
 * [Method] Overridden in Ext rtl AbstractComponent
 * @param {?=} x Object
 * @param {?=} y Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.Msg.setLocalXY = function(x, y) {};

/**
 * [Method] Sets the local y coordinate of this element using CSS style
 * @param {?=} y Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.Msg.setLocalY = function(y) {};

/**
 * [Method] Sets the margin on the target element
 * @param {?=} margin Number/String The margin to set. See the margin config.
 * @return {void}
 */
Ext.Msg.setMargin = function(margin) {};

/**
 * [Method] Sets the overflow x y on the content element of the component
 * @param {string=} overflowX String The overflow-x value.
 * @param {string=} overflowY String The overflow-y value.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.setOverflowXY = function(overflowX, overflowY) {};

/**
 * [Method] Sets the page XY position of the component
 * @param {?=} x Number/Number[] The new x position or an array of [x,y].
 * @param {number=} y Number The new y position.
 * @param {?=} animate Boolean/Object True to animate the Component into its new position. You may also pass an animation configuration.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.setPagePosition = function(x, y, animate) {};

/**
 * [Method] Sets the left and top of the component
 * @param {?=} x Number/Number[]/Object The new left, an array of [x,y], or animation config object containing x and y properties.
 * @param {number=} y Number The new top.
 * @param {?=} animate Boolean/Object If true, the Component is animated into its new position. You may also pass an animation configuration.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.setPosition = function(x, y, animate) {};

/**
 * [Method] Sets the element s position and size to the specified region
 * @param {!Ext.util.IRegion=} region Ext.util.Region The region to fill
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.Msg.setRegion = function(region, animate) {};

/**
 * [Method] Sets the weight config property for this component
 * @param {number=} weight Number The new weight value.
 * @return {number} Number The previous value of the weight property.
 */
Ext.Msg.setRegionWeight = function(weight) {};

/**
 * [Method] Sets the width and height of this Component
 * @param {?=} width Number/String/Object The new width to set. This may be one of:  A Number specifying the new width in the Element's Ext.Element.defaultUnits (by default, pixels). A String used to set the CSS width style. A size object in the format {width: widthValue, height: heightValue}. undefined to leave the width unchanged.
 * @param {?=} height Number/String The new height to set (not required if a size object is passed as the first arg). This may be one of:  A Number specifying the new height in the Element's Ext.Element.defaultUnits (by default, pixels). A String used to set the CSS height style. Animation may not be used. undefined to leave the height unchanged.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.setSize = function(width, height) {};

/**
 * [Method] Set a title for the panel s header
 * @param {string=} newTitle String
 * @return {void}
 */
Ext.Msg.setTitle = function(newTitle) {};

/**
 * [Method] Sets the UI for the component
 * @param {?=} ui Object
 * @return {void}
 */
Ext.Msg.setUI = function(ui) {};

/**
 * [Method] Convenience function to hide or show this component by Boolean
 * @param {boolean=} visible Boolean true to show, false to hide.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.setVisible = function(visible) {};

/**
 * [Method] Sets the width of the component
 * @param {number=} width Number The new width to setThis may be one of:  A Number specifying the new width in the Element's Ext.Element.defaultUnits (by default, pixels). A String used to set the CSS width style.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.setWidth = function(width) {};

/**
 * [Method] Sets the X position of the DOM element based on page coordinates
 * @param {?=} x Object
 * @param {?=} animate Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.Msg.setX = function(x, animate) {};

/**
 * [Method] Sets the position of the DOM element in page coordinates
 * @param {?=} xy Object
 * @param {?=} animate Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.Msg.setXY = function(xy, animate) {};

/**
 * [Method] Sets the Y position of the DOM element based on page coordinates
 * @param {?=} y Object
 * @param {?=} animate Object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.Msg.setY = function(y, animate) {};

/**
 * [Method] Displays a new message box or reinitializes an existing message box based on the config options passed in
 * @param {?=} config Object The following config options are supported:
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.Msg.show = function(config) {};

/**
 * [Method] Displays component at specific xy position
 * @param {?=} x Number/Number[] The new x position or array of [x,y].
 * @param {number=} y Number The new y position
 * @param {?=} animate Boolean/Object True to animate the Component into its new position. You may also pass an animation configuration.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.showAt = function(x, y, animate) {};

/**
 * [Method] Shows this component by the specified Component or Element
 * @param {?=} component Ext.Component/Ext.dom.Element The Ext.Component or Ext.Element to show the component by.
 * @param {string=} position String Alignment position as used by Ext.util.Positionable.getAlignToXY. Defaults to defaultAlign.
 * @param {!Array<number>=} offsets Number[] Alignment offsets as used by Ext.util.Positionable.getAlignToXY.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.showBy = function(component, position, offsets) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.Msg.statics = function() {};

/**
 * [Method] Stops any running effects and clears this object s internal effects queue if it contains any additional effects that
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.Msg.stopAnimation = function() {};

/**
 * [Method] Stops any running effects and clears this object s internal effects queue if it contains any additional effects that
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.Msg.stopFx = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.Msg.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.Msg.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Ensures that all effects queued after syncFx is called on this object are run concurrently
 * @return {?} Object this
 */
Ext.Msg.syncFx = function() {};

/**
 * [Method] Sends this Component to the back of lower z index than any other visible windows
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.toBack = function() {};

/**
 * [Method] Brings this floating Component to the front of any other visible floating Components managed by the same ZIndexManag
 * @param {boolean=} preventFocus Boolean Specify true to prevent the Component from being focused.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.toFront = function(preventFocus) {};

/**
 * [Method] Shortcut for performing an expand or collapse based on the current state of the panel
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.Msg.toggleCollapse = function() {};

/**
 * [Method] A shortcut method for toggling between maximize and restore based on the current maximized state of the window
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.Msg.toggleMaximize = function() {};

/**
 * [Method] Translates the passed page coordinates into left top css values for the element
 * @param {?=} x Number/Array The page x or an array containing [x, y]
 * @param {number=} y Number The page y, required if x is not an array
 * @return {?} Object An object with left and top properties. e.g. {left: (value), top: (value)}
 */
Ext.Msg.translatePoints = function(x, y) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.Msg.un = function(eventName, fn, scope) {};

/**
 * [Method] Navigates up the ownership hierarchy searching for an ancestor Container which matches any passed simple selector or
 * @param {?=} selector String/Ext.Component The simple selector component or actual component to test. If not passed the immediate owner/activater is returned.
 * @param {?=} limit String/Number/Ext.Component This may be a selector upon which to stop the upward scan, or a limit of teh number of steps, or Component reference to stop on.
 * @return {!Ext.container.IContainer} Ext.container.Container The matching ancestor Container (or undefined if no match was found).
 */
Ext.Msg.up = function(selector, limit) {};

/**
 * [Method] Update the content area of a component
 * @param {?=} htmlOrData String/Object If this component has been configured with a template via the tpl config then it will use this argument as data to populate the template. If this component was not configured with a template, the components content area will be updated via Ext.Element update.
 * @param {boolean=} loadScripts Boolean Only legitimate when using the html configuration.
 * @param {?=} callback Function Only legitimate when using the html configuration. Callback to execute when scripts have finished loading.
 * @return {void}
 */
Ext.Msg.update = function(htmlOrData, loadScripts, callback) {};

/**
 * [Method] Sets the current box measurements of the component s underlying element
 * @param {?=} box Object An object in the format {x, y, width, height}
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.Msg.updateBox = function(box) {};

/**
 * [Method] Updates this component s layout
 * @param {?=} options Object An object with layout options.
 * @return {void}
 */
Ext.Msg.updateLayout = function(options) {};

/**
 * [Method] Updates a progress style message box s text and progress bar
 * @param {number=} value Number Any number between 0 and 1 (e.g., .5)
 * @param {string=} progressText String The progress text to display inside the progress bar.
 * @param {string=} msg String The message box's body text is replaced with the specified string (defaults to undefined so that any existing body text will not get overwritten by default unless a new value is passed in)
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.Msg.updateProgress = function(value, progressText, msg) {};

/**
 * [Method] Displays a message box with an infinitely auto updating progress bar
 * @param {string=} msg String The message box body text
 * @param {string=} title String The title bar text
 * @param {?=} config Object A Ext.ProgressBar.wait config object
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.Msg.wait = function(msg, title, config) {};
/**
 * @extends {Ext.IAbstractManager}
 * @record
 * @struct
 */
Ext.IModelManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.ModelManager = function() {};
 /** @type {!Ext.util.IHashMap} */
Ext.ModelManager.all;
 /** @type {!Array<!Ext.data.association.IAssociation>} */
Ext.ModelManager.associationStack;
 /** @type {!Ext.IClass} */
Ext.ModelManager.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.ModelManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.ModelManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.ModelManager.callSuper = function(args) {};

/**
 * [Method] Creates a new instance of a Model using the given data
 * @param {?=} data Object Data to initialize the Model's fields with
 * @param {string=} name String The name of the model to create
 * @param {number=} id Number unique id of the Model instance (see Ext.data.Model)
 * @return {void}
 */
Ext.ModelManager.create = function(data, name, id) {};

/**
 * [Method] Executes the specified function once for each item in the collection
 * @param {?=} fn Function The function to execute.
 * @param {?=} scope Object The scope to execute in. Defaults to this.
 * @return {void}
 */
Ext.ModelManager.each = function(fn, scope) {};

/**
 * [Method] Returns an item by id
 * @param {string=} id String The id of the item
 * @return {?} Object The item, undefined if not found.
 */
Ext.ModelManager.get = function(id) {};

/**
 * [Method] Gets the number of items in the collection
 * @return {number} Number The number of items in the collection.
 */
Ext.ModelManager.getCount = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.ModelManager.getInitialConfig = function(name) {};

/**
 * [Method] Returns the Ext data Model class for a given model name
 * @param {?=} id String/Object The classname of the model or the model class itself.
 * @return {!Ext.data.IModel} Ext.data.Model a model class.
 */
Ext.ModelManager.getModel = function(id) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.ModelManager.initConfig = function(config) {};

/**
 * [Method] Checks if an item type is registered
 * @param {string=} type String The mnemonic string by which the class may be looked up
 * @return {boolean} Boolean Whether the type is registered.
 */
Ext.ModelManager.isRegistered = function(type) {};

/**
 * [Method] Registers a function that will be called when an item with the specified id is added to the manager
 * @param {string=} id String The item id
 * @param {?=} fn Function The callback function. Called with a single parameter, the item.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed. Defaults to the item.
 * @return {void}
 */
Ext.ModelManager.onAvailable = function(id, fn, scope) {};

/**
 * [Method] Registers an item to be managed
 * @param {?=} item Object The item to register
 * @return {void}
 */
Ext.ModelManager.register = function(item) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.ModelManager.statics = function() {};

/**
 * [Method] Unregisters an item by removing it from this manager
 * @param {?=} item Object The item to unregister
 * @return {void}
 */
Ext.ModelManager.unregister = function(item) {};
/**
 * @extends {Ext.IAbstractManager}
 * @record
 * @struct
 */
Ext.IModelMgr = function() {};
/**
 * @constructor
 * @struct
 */
Ext.ModelMgr = function() {};
 /** @type {!Ext.util.IHashMap} */
Ext.ModelMgr.all;
 /** @type {!Array<!Ext.data.association.IAssociation>} */
Ext.ModelMgr.associationStack;
 /** @type {!Ext.IClass} */
Ext.ModelMgr.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.ModelMgr.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.ModelMgr.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.ModelMgr.callSuper = function(args) {};

/**
 * [Method] Creates a new instance of a Model using the given data
 * @param {?=} data Object Data to initialize the Model's fields with
 * @param {string=} name String The name of the model to create
 * @param {number=} id Number unique id of the Model instance (see Ext.data.Model)
 * @return {void}
 */
Ext.ModelMgr.create = function(data, name, id) {};

/**
 * [Method] Executes the specified function once for each item in the collection
 * @param {?=} fn Function The function to execute.
 * @param {?=} scope Object The scope to execute in. Defaults to this.
 * @return {void}
 */
Ext.ModelMgr.each = function(fn, scope) {};

/**
 * [Method] Returns an item by id
 * @param {string=} id String The id of the item
 * @return {?} Object The item, undefined if not found.
 */
Ext.ModelMgr.get = function(id) {};

/**
 * [Method] Gets the number of items in the collection
 * @return {number} Number The number of items in the collection.
 */
Ext.ModelMgr.getCount = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.ModelMgr.getInitialConfig = function(name) {};

/**
 * [Method] Returns the Ext data Model class for a given model name
 * @param {?=} id String/Object The classname of the model or the model class itself.
 * @return {!Ext.data.IModel} Ext.data.Model a model class.
 */
Ext.ModelMgr.getModel = function(id) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.ModelMgr.initConfig = function(config) {};

/**
 * [Method] Checks if an item type is registered
 * @param {string=} type String The mnemonic string by which the class may be looked up
 * @return {boolean} Boolean Whether the type is registered.
 */
Ext.ModelMgr.isRegistered = function(type) {};

/**
 * [Method] Registers a function that will be called when an item with the specified id is added to the manager
 * @param {string=} id String The item id
 * @param {?=} fn Function The callback function. Called with a single parameter, the item.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed. Defaults to the item.
 * @return {void}
 */
Ext.ModelMgr.onAvailable = function(id, fn, scope) {};

/**
 * [Method] Registers an item to be managed
 * @param {?=} item Object The item to register
 * @return {void}
 */
Ext.ModelMgr.register = function(item) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.ModelMgr.statics = function() {};

/**
 * [Method] Unregisters an item by removing it from this manager
 * @param {?=} item Object The item to unregister
 * @return {void}
 */
Ext.ModelMgr.unregister = function(item) {};
/**
 * @record
 * @struct
 */
Ext.INumber = function() {};
/**
 * @constructor
 * @struct
 */
Ext.Number = function() {};

/**
 * [Method] Checks whether or not the passed number is within a desired range
 * @param {number=} number Number The number to check
 * @param {number=} min Number The minimum number in the range
 * @param {number=} max Number The maximum number in the range
 * @return {number} Number The constrained value if outside the range, otherwise the current value
 */
Ext.Number.constrain = function(number, min, max) {};

/**
 * [Method] Corrects floating point numbers that overflow to a non precise value because of their floating nature for example 0
 * @param {number=} The Number number
 * @return {number} Number The correctly rounded number
 */
Ext.Number.correctFloat = function(The) {};

/**
 * [Method] Validate that a value is numeric and convert it to a number if necessary
 * @param {?=} value Object
 * @param {number=} defaultValue Number The value to return if the original value is non-numeric
 * @return {number} Number value, if numeric, defaultValue otherwise
 */
Ext.Number.from = function(value, defaultValue) {};

/**
 * [Method] Returns a random integer between the specified range inclusive
 * @param {number=} from Number Lowest value to return.
 * @param {number=} to Number Highst value to return.
 * @return {number} Number A random integer within the specified range.
 */
Ext.Number.randomInt = function(from, to) {};

/**
 * [Method] Snaps the passed number between stopping points based upon a passed increment value
 * @param {number=} value Number The unsnapped value.
 * @param {number=} increment Number The increment by which the value must move.
 * @param {number=} minValue Number The minimum value to which the returned value must be constrained. Overrides the increment.
 * @param {number=} maxValue Number The maximum value to which the returned value must be constrained. Overrides the increment.
 * @return {number} Number The value of the nearest snap target.
 */
Ext.Number.snap = function(value, increment, minValue, maxValue) {};

/**
 * [Method] Snaps the passed number between stopping points based upon a passed increment value
 * @param {number=} value Number The unsnapped value.
 * @param {number=} increment Number The increment by which the value must move.
 * @param {number=} minValue Number The minimum value to which the returned value must be constrained.
 * @param {number=} maxValue Number The maximum value to which the returned value must be constrained.
 * @return {number} Number The value of the nearest snap target.
 */
Ext.Number.snapInRange = function(value, increment, minValue, maxValue) {};

/**
 * [Method] Formats a number using fixed point notation
 * @param {number=} value Number The number to format
 * @param {number=} precision Number The number of digits to show after the decimal point
 * @return {void}
 */
Ext.Number.toFixed = function(value, precision) {};
/**
 * @record
 * @struct
 */
Ext.IObject = function() {};
/**
 * @constructor
 * @struct
 */
Ext.Object = function() {};

/**
 * [Method] Returns a new object with the given object as the prototype chain
 * @param {?=} object Object The prototype chain for the new object.
 * @return {void}
 */
Ext.Object.chain = function(object) {};

/**
 * [Method] Iterates through an object and invokes the given callback function for each iteration
 * @param {?=} object Object The object to iterate
 * @param {?=} fn Function The callback function.
 * @param {?=} scope Object The execution scope (this) of the callback function
 * @return {void}
 */
Ext.Object.each = function(object, fn, scope) {};

/**
 * [Method] Shallow compares the contents of 2 objects using strict equality
 * @param {?=} object1 Object
 * @param {?=} object2 Object
 * @return {boolean} Boolean true if the objects are equal.
 */
Ext.Object.equals = function(object1, object2) {};

/**
 * [Method] Converts a query string back into an object
 * @param {string=} queryString String The query string to decode
 * @param {boolean=} recursive Boolean Whether or not to recursively decode the string. This format is supported by PHP / Ruby on Rails servers and similar.
 * @return {?} Object
 */
Ext.Object.fromQueryString = function(queryString, recursive) {};

/**
 * [Method] Returns the first matching key corresponding to the given value
 * @param {?=} object Object
 * @param {?=} value Object The value to find
 * @return {void}
 */
Ext.Object.getKey = function(object, value) {};

/**
 * [Method] Gets all keys of the given object as an array
 * @param {?=} object Object
 * @return {!Array<string>} String[] An array of keys from the object
 */
Ext.Object.getKeys = function(object) {};

/**
 * [Method] Gets the total number of this object s own properties var size  Ext Object getSize  name  Jacky  loves
 * @param {?=} object Object
 * @return {number} Number size
 */
Ext.Object.getSize = function(object) {};

/**
 * [Method] Gets all values of the given object as an array
 * @param {?=} object Object
 * @return {!Array<?>} Array An array of values from the object
 */
Ext.Object.getValues = function(object) {};

/**
 * [Method] Checks if there are any properties on this object
 * @param {?=} object Object
 * @return {boolean} Boolean true if there no properties on the object.
 */
Ext.Object.isEmpty = function(object) {};

/**
 * [Method] Merges any number of objects recursively without referencing them or their children
 * @param {?} destination Object The object into which all subsequent objects are merged.
 * @param {...?} object Object... Any number of objects to merge into the destination.
 * @return {?} Object merged The destination object with all passed objects merged in.
 */
Ext.Object.merge = function(destination, object) {};

/**
 * [Method] Converts a name  value pair to an array of objects with support for nested structures
 * @param {string=} name String
 * @param {?=} value Object/Array
 * @param {boolean=} recursive Boolean True to traverse object recursively
 * @return {!Array<?>} Array
 */
Ext.Object.toQueryObjects = function(name, value, recursive) {};

/**
 * [Method] Takes an object and converts it to an encoded query string
 * @param {?=} object Object The object to encode
 * @param {boolean=} recursive Boolean Whether or not to interpret the object in recursive format. (PHP / Ruby on Rails servers and similar).
 * @return {string} String queryString
 */
Ext.Object.toQueryString = function(object, recursive) {};
/** @const */
Ext.panel = {};
/**
 * @extends {Ext.container.IContainer}
 * @extends {Ext.container.IDockingContainer}
 * @record
 * @struct
 */
Ext.panel.IAbstractPanel = function() {};
 /** @type {string} */
Ext.panel.IAbstractPanel.prototype.baseCls;
 /** @type {boolean} */
Ext.panel.IAbstractPanel.prototype.bodyBorder;
 /** @type {?} */
Ext.panel.IAbstractPanel.prototype.bodyCls;
 /** @type {?} */
Ext.panel.IAbstractPanel.prototype.bodyPadding;
 /** @type {?} */
Ext.panel.IAbstractPanel.prototype.bodyStyle;
 /** @type {?} */
Ext.panel.IAbstractPanel.prototype.border;
 /** @type {?} */
Ext.panel.IAbstractPanel.prototype.componentLayout;
 /** @type {?} */
Ext.panel.IAbstractPanel.prototype.dockedItems;
 /** @type {?} */
Ext.panel.IAbstractPanel.prototype.renderTpl;
 /** @type {?} */
Ext.panel.IAbstractPanel.prototype.shrinkWrapDock;
 /** @type {!Ext.dom.IElement} */
Ext.panel.IAbstractPanel.prototype.body;
 /** @type {string} */
Ext.panel.IAbstractPanel.prototype.contentPaddingProperty;
 /** @type {boolean} */
Ext.panel.IAbstractPanel.prototype.isPanel;

/**
 * [Method] Adds a CSS class to the body element
 * @param {string=} cls String The class to add
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.panel.IAbstractPanel.prototype.addBodyCls = function(cls) {};

/**
 * [Method] Adds docked item s to the container
 * @param {?=} component Object/Object[] The Component or array of components to add. The components must include a 'dock' parameter on each component to indicate where it should be docked ('top', 'right', 'bottom', 'left').
 * @param {number=} pos Number The index at which the Component will be added
 * @return {!Array<!Ext.IComponent>} Ext.Component[] The added components.
 */
Ext.panel.IAbstractPanel.prototype.addDocked = function(component, pos) {};

/**
 * [Method] inherit docs
 * @param {?=} cls Object
 * @return {void}
 */
Ext.panel.IAbstractPanel.prototype.addUIClsToElement = function(cls) {};

/**
 * [Method] Attempts a default component lookup see Ext container Container getComponent
 * @param {?=} comp String/Number The component id, itemId or position to find
 * @return {!Ext.IComponent} Ext.Component The component (if found)
 */
Ext.panel.IAbstractPanel.prototype.getComponent = function(comp) {};

/**
 * [Method] Finds a docked component by id itemId or position
 * @param {?=} comp String/Number The id, itemId or position of the docked component (see getComponent for details)
 * @return {!Ext.IComponent} Ext.Component The docked component (if found)
 */
Ext.panel.IAbstractPanel.prototype.getDockedComponent = function(comp) {};

/**
 * [Method] Retrieves an array of all currently docked Components
 * @param {string=} selector String A ComponentQuery selector string to filter the returned items.
 * @param {boolean=} beforeBody Boolean An optional flag to limit the set of items to only those before the body (true) or after the body (false). All components are returned by default.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] The array of docked components meeting the specified criteria.
 */
Ext.panel.IAbstractPanel.prototype.getDockedItems = function(selector, beforeBody) {};

/**
 * [Method] Used by ComponentQuery child and down to retrieve all of the items which can potentially be considered a child of th
 * @param {?=} deep Object
 * @return {void}
 */
Ext.panel.IAbstractPanel.prototype.getRefItems = function(deep) {};

/**
 * [Method] Inserts docked item s to the panel at the indicated position
 * @param {number=} pos Number The index at which the Component will be inserted
 * @param {?=} component Object/Object[] The Component or array of components to add. The components must include a 'dock' paramater on each component to indicate where it should be docked ('top', 'right', 'bottom', 'left').
 * @return {void}
 */
Ext.panel.IAbstractPanel.prototype.insertDocked = function(pos, component) {};

/**
 * [Method] Invoked after a docked item is added to the Panel
 * @param {!Ext.IComponent=} component Ext.Component
 * @return {void}
 */
Ext.panel.IAbstractPanel.prototype.onDockedAdd = function(component) {};

/**
 * [Method] Invoked after a docked item is removed from the Panel
 * @param {!Ext.IComponent=} component Ext.Component
 * @return {void}
 */
Ext.panel.IAbstractPanel.prototype.onDockedRemove = function(component) {};

/**
 * [Method] Removes a CSS class from the body element
 * @param {string=} cls String The class to remove
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.panel.IAbstractPanel.prototype.removeBodyCls = function(cls) {};

/**
 * [Method] Removes the docked item from the panel
 * @param {!Ext.IComponent=} item Ext.Component The Component to remove.
 * @param {boolean=} autoDestroy Boolean Destroy the component after removal.
 * @return {void}
 */
Ext.panel.IAbstractPanel.prototype.removeDocked = function(item, autoDestroy) {};

/**
 * [Method] inherit docs
 * @param {?=} cls Object
 * @return {void}
 */
Ext.panel.IAbstractPanel.prototype.removeUIClsFromElement = function(cls) {};

/**
 * [Method] Sets the body style according to the passed parameters
 * @param {?=} style Mixed A full style specification string, or object, or the name of a style property to set.
 * @param {string=} value String If the first param was a style property name, the style property value.
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.panel.IAbstractPanel.prototype.setBodyStyle = function(style, value) {};
/**
 * @extends {Ext.dd.IDragSource}
 * @record
 * @struct
 */
Ext.panel.IDD = function() {};

/**
 * [Method] An empty function by default but provided so that you can perform a custom action after an invalid drop has occurred
 * @param {!Event=} e Event The event object
 * @param {string=} id String The id of the dropped element
 * @return {void}
 */
Ext.panel.IDD.prototype.afterInvalidDrop = function(e, id) {};

/**
 * [Method] overrides Ext dd DragDrop
 * @param {?=} e Object
 * @return {void}
 */
Ext.panel.IDD.prototype.b4MouseDown = function(e) {};

/**
 * [Method] Creates the proxy element if it does not yet exist
 * @return {void}
 */
Ext.panel.IDD.prototype.createFrame = function() {};

/**
 * [Method] Returns a reference to the actual element to drag
 * @param {?=} e Object
 * @return {!HTMLElement} HTMLElement the html element
 */
Ext.panel.IDD.prototype.getDragEl = function(e) {};
/**
 * @extends {Ext.container.IContainer}
 * @record
 * @struct
 */
Ext.panel.IHeader = function() {};
 /** @type {?} */
Ext.panel.IHeader.prototype.componentLayout;
 /** @type {string} */
Ext.panel.IHeader.prototype.defaultType;
 /** @type {?} */
Ext.panel.IHeader.prototype.glyph;
 /** @type {string} */
Ext.panel.IHeader.prototype.icon;
 /** @type {string} */
Ext.panel.IHeader.prototype.iconCls;
 /** @type {?} */
Ext.panel.IHeader.prototype.renderTpl;
 /** @type {?} */
Ext.panel.IHeader.prototype.shrinkWrap;
 /** @type {string} */
Ext.panel.IHeader.prototype.title;
 /** @type {string} */
Ext.panel.IHeader.prototype.titleAlign;
 /** @type {number} */
Ext.panel.IHeader.prototype.titlePosition;
 /** @type {boolean} */
Ext.panel.IHeader.prototype.isHeader;

/**
 * [Method] Add a tool to the header
 * @param {?=} tool Object
 * @return {void}
 */
Ext.panel.IHeader.prototype.addTool = function(tool) {};

/**
 * [Method] inherit docs
 * @param {?=} cls Object
 * @return {void}
 */
Ext.panel.IHeader.prototype.addUIClsToElement = function(cls) {};

/**
 * [Method] Invoked after the Container has laid out and rendered if necessary its child Components
 * @return {void}
 */
Ext.panel.IHeader.prototype.afterLayout = function() {};

/**
 * [Method] Occurs before componentLayout is run
 * @return {void}
 */
Ext.panel.IHeader.prototype.beforeLayout = function() {};

/**
 * [Method] Gets the tools for this header
 * @return {!Array<!Ext.panel.ITool>} Ext.panel.Tool[] The tools
 */
Ext.panel.IHeader.prototype.getTools = function() {};

/**
 * [Method] Set up the tools lt tool type gt link in the owning Panel
 * @param {?=} component Object
 * @param {?=} index Object
 * @return {void}
 */
Ext.panel.IHeader.prototype.onAdd = function(component, index) {};

/**
 * [Method] inherit docs
 * @param {?=} cls Object
 * @return {void}
 */
Ext.panel.IHeader.prototype.removeUIClsFromElement = function(cls) {};

/**
 * [Method] Sets glyph that provides the icon image for this header
 * @param {?=} glyph Number/String the numeric charCode or string charCode/font-family. This parameter expects a format consistent with that of glyph
 * @return {void}
 */
Ext.panel.IHeader.prototype.setGlyph = function(glyph) {};

/**
 * [Method] Sets the image path that provides the icon image for this header
 * @param {string=} icon String The new icon path
 * @return {void}
 */
Ext.panel.IHeader.prototype.setIcon = function(icon) {};

/**
 * [Method] Sets the CSS class that provides the icon image for this header
 * @param {string=} cls String The new CSS class name
 * @return {void}
 */
Ext.panel.IHeader.prototype.setIconCls = function(cls) {};

/**
 * [Method] Sets the title of the header
 * @param {string=} title String The title to be set
 * @return {void}
 */
Ext.panel.IHeader.prototype.setTitle = function(title) {};
/**
 * @extends {Ext.panel.IAbstractPanel}
 * @record
 * @struct
 */
Ext.panel.IPanel = function() {};
 /** @type {boolean} */
Ext.panel.IPanel.prototype.animCollapse;
 /** @type {?} */
Ext.panel.IPanel.prototype.bbar;
 /** @type {string} */
Ext.panel.IPanel.prototype.buttonAlign;
 /** @type {?} */
Ext.panel.IPanel.prototype.buttons;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.closable;
 /** @type {string} */
Ext.panel.IPanel.prototype.closeAction;
 /** @type {string} */
Ext.panel.IPanel.prototype.collapseDirection;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.collapseFirst;
 /** @type {string} */
Ext.panel.IPanel.prototype.collapseMode;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.collapsed;
 /** @type {string} */
Ext.panel.IPanel.prototype.collapsedCls;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.collapsible;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.constrain;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.constrainHeader;
 /** @type {?} */
Ext.panel.IPanel.prototype.dockedItems;
 /** @type {?} */
Ext.panel.IPanel.prototype.fbar;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.floatable;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.frame;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.frameHeader;
 /** @type {?} */
Ext.panel.IPanel.prototype.glyph;
 /** @type {?} */
Ext.panel.IPanel.prototype.header;
 /** @type {string} */
Ext.panel.IPanel.prototype.headerOverCls;
 /** @type {string} */
Ext.panel.IPanel.prototype.headerPosition;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.hideCollapseTool;
 /** @type {string} */
Ext.panel.IPanel.prototype.icon;
 /** @type {string} */
Ext.panel.IPanel.prototype.iconCls;
 /** @type {?} */
Ext.panel.IPanel.prototype.lbar;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.manageHeight;
 /** @type {number} */
Ext.panel.IPanel.prototype.minButtonWidth;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.overlapHeader;
 /** @type {?} */
Ext.panel.IPanel.prototype.placeholder;
 /** @type {number} */
Ext.panel.IPanel.prototype.placeholderCollapseHideMode;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.preventHeader;
 /** @type {?} */
Ext.panel.IPanel.prototype.rbar;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.simpleDrag;
 /** @type {?} */
Ext.panel.IPanel.prototype.tbar;
 /** @type {string} */
Ext.panel.IPanel.prototype.title;
 /** @type {string} */
Ext.panel.IPanel.prototype.titleAlign;
 /** @type {boolean} */
Ext.panel.IPanel.prototype.titleCollapse;
 /** @type {?} */
Ext.panel.IPanel.prototype.tools;
 /** @type {?} */
Ext.panel.IPanel.prototype.dd;

/**
 * [Method] Add tools to this panel
 * @param {?=} tools Object[]/Ext.panel.Tool[] The tools to add
 * @return {void}
 */
Ext.panel.IPanel.prototype.addTool = function(tools) {};

/**
 * [Method] Invoked after the Panel is Collapsed
 * @param {boolean=} animated Boolean
 * @return {void}
 */
Ext.panel.IPanel.prototype.afterCollapse = function(animated) {};

/**
 * [Method] Invoked after the Panel is Expanded
 * @param {boolean=} animated Boolean
 * @return {void}
 */
Ext.panel.IPanel.prototype.afterExpand = function(animated) {};

/**
 * [Method] Closes the Panel
 * @return {void}
 */
Ext.panel.IPanel.prototype.close = function() {};

/**
 * [Method] Collapses the panel body so that the body becomes hidden
 * @param {string=} direction String The direction to collapse towards. Must be one of  Ext.Component.DIRECTION_TOP Ext.Component.DIRECTION_RIGHT Ext.Component.DIRECTION_BOTTOM Ext.Component.DIRECTION_LEFT Defaults to collapseDirection.
 * @param {boolean=} animate Boolean True to animate the transition, else false (defaults to the value of the animCollapse panel config). May also be specified as the animation duration in milliseconds.
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.panel.IPanel.prototype.collapse = function(direction, animate) {};

/**
 * [Method] converts a collapsdDir into an anchor argument for Element slideIn overridden in rtl mode to switch l and r
 * @param {?=} collapseDir Object
 * @return {void}
 */
Ext.panel.IPanel.prototype.convertCollapseDir = function(collapseDir) {};

/**
 * [Method] Expands the panel body so that it becomes visible
 * @param {boolean=} animate Boolean True to animate the transition, else false (defaults to the value of the animCollapse panel config). May also be specified as the animation duration in milliseconds.
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.panel.IPanel.prototype.expand = function(animate) {};

/**
 * [Method] Returns the current collapsed state of the panel
 * @return {?} Boolean/String False when not collapsed, otherwise the value of collapseDirection.
 */
Ext.panel.IPanel.prototype.getCollapsed = function() {};

/**
 * [Method] Gets the Header for this panel
 * @return {void}
 */
Ext.panel.IPanel.prototype.getHeader = function() {};

/**
 * [Method] The supplied default state gathering method for the AbstractComponent class
 * @return {?} Object
 */
Ext.panel.IPanel.prototype.getState = function() {};

/**
 * [Method] Determines whether this Component is the root of a layout
 * @return {void}
 */
Ext.panel.IPanel.prototype.isLayoutRoot = function() {};

/**
 * [Method] Returns true if this component is visible
 * @param {?=} deep Object
 * @return {boolean} Boolean true if this component is visible, false otherwise.
 */
Ext.panel.IPanel.prototype.isVisible = function(deep) {};

/**
 * [Method] Possibly animates down to a target element
 * @return {void}
 */
Ext.panel.IPanel.prototype.onHide = function() {};

/**
 * [Method] Method to manage awareness of when components are removed from their respective Container firing a removed event
 * @param {?=} destroying Object
 * @return {void}
 */
Ext.panel.IPanel.prototype.onRemoved = function(destroying) {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.panel.IPanel.prototype.onShow = function() {};

/**
 * [Method]
 * @param {?=} border Object
 * @param {?=} targetEl Object
 * @return {void}
 */
Ext.panel.IPanel.prototype.setBorder = function(border, targetEl) {};

/**
 * [Method] Set the glyph for the panel s header
 * @param {?=} newGlyph Number/String The new glyph This parameter expects a format consistent with that of glyph
 * @return {void}
 */
Ext.panel.IPanel.prototype.setGlyph = function(newGlyph) {};

/**
 * [Method] Set the icon for the panel s header
 * @param {string=} newIcon String The new icon path
 * @return {void}
 */
Ext.panel.IPanel.prototype.setIcon = function(newIcon) {};

/**
 * [Method] Set the iconCls for the panel s header
 * @param {string=} newIconCls String The new CSS class name
 * @return {void}
 */
Ext.panel.IPanel.prototype.setIconCls = function(newIconCls) {};

/**
 * [Method] Set a title for the panel s header
 * @param {string=} newTitle String
 * @return {void}
 */
Ext.panel.IPanel.prototype.setTitle = function(newTitle) {};

/**
 * [Method] Sets the UI for the component
 * @param {?=} ui Object
 * @return {void}
 */
Ext.panel.IPanel.prototype.setUI = function(ui) {};

/**
 * [Method] Shortcut for performing an expand or collapse based on the current state of the panel
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.panel.IPanel.prototype.toggleCollapse = function() {};
/**
 * @extends {Ext.panel.IAbstractPanel}
 * @record
 * @struct
 */
Ext.IPanel = function() {};
 /** @type {boolean} */
Ext.IPanel.prototype.animCollapse;
 /** @type {?} */
Ext.IPanel.prototype.bbar;
 /** @type {string} */
Ext.IPanel.prototype.buttonAlign;
 /** @type {?} */
Ext.IPanel.prototype.buttons;
 /** @type {boolean} */
Ext.IPanel.prototype.closable;
 /** @type {string} */
Ext.IPanel.prototype.closeAction;
 /** @type {string} */
Ext.IPanel.prototype.collapseDirection;
 /** @type {boolean} */
Ext.IPanel.prototype.collapseFirst;
 /** @type {string} */
Ext.IPanel.prototype.collapseMode;
 /** @type {boolean} */
Ext.IPanel.prototype.collapsed;
 /** @type {string} */
Ext.IPanel.prototype.collapsedCls;
 /** @type {boolean} */
Ext.IPanel.prototype.collapsible;
 /** @type {boolean} */
Ext.IPanel.prototype.constrain;
 /** @type {boolean} */
Ext.IPanel.prototype.constrainHeader;
 /** @type {?} */
Ext.IPanel.prototype.dockedItems;
 /** @type {?} */
Ext.IPanel.prototype.fbar;
 /** @type {boolean} */
Ext.IPanel.prototype.floatable;
 /** @type {boolean} */
Ext.IPanel.prototype.frame;
 /** @type {boolean} */
Ext.IPanel.prototype.frameHeader;
 /** @type {?} */
Ext.IPanel.prototype.glyph;
 /** @type {?} */
Ext.IPanel.prototype.header;
 /** @type {string} */
Ext.IPanel.prototype.headerOverCls;
 /** @type {string} */
Ext.IPanel.prototype.headerPosition;
 /** @type {boolean} */
Ext.IPanel.prototype.hideCollapseTool;
 /** @type {string} */
Ext.IPanel.prototype.icon;
 /** @type {string} */
Ext.IPanel.prototype.iconCls;
 /** @type {?} */
Ext.IPanel.prototype.lbar;
 /** @type {boolean} */
Ext.IPanel.prototype.manageHeight;
 /** @type {number} */
Ext.IPanel.prototype.minButtonWidth;
 /** @type {boolean} */
Ext.IPanel.prototype.overlapHeader;
 /** @type {?} */
Ext.IPanel.prototype.placeholder;
 /** @type {number} */
Ext.IPanel.prototype.placeholderCollapseHideMode;
 /** @type {boolean} */
Ext.IPanel.prototype.preventHeader;
 /** @type {?} */
Ext.IPanel.prototype.rbar;
 /** @type {boolean} */
Ext.IPanel.prototype.simpleDrag;
 /** @type {?} */
Ext.IPanel.prototype.tbar;
 /** @type {string} */
Ext.IPanel.prototype.title;
 /** @type {string} */
Ext.IPanel.prototype.titleAlign;
 /** @type {boolean} */
Ext.IPanel.prototype.titleCollapse;
 /** @type {?} */
Ext.IPanel.prototype.tools;
 /** @type {?} */
Ext.IPanel.prototype.dd;

/**
 * [Method] Add tools to this panel
 * @param {?=} tools Object[]/Ext.panel.Tool[] The tools to add
 * @return {void}
 */
Ext.IPanel.prototype.addTool = function(tools) {};

/**
 * [Method] Invoked after the Panel is Collapsed
 * @param {boolean=} animated Boolean
 * @return {void}
 */
Ext.IPanel.prototype.afterCollapse = function(animated) {};

/**
 * [Method] Invoked after the Panel is Expanded
 * @param {boolean=} animated Boolean
 * @return {void}
 */
Ext.IPanel.prototype.afterExpand = function(animated) {};

/**
 * [Method] Closes the Panel
 * @return {void}
 */
Ext.IPanel.prototype.close = function() {};

/**
 * [Method] Collapses the panel body so that the body becomes hidden
 * @param {string=} direction String The direction to collapse towards. Must be one of  Ext.Component.DIRECTION_TOP Ext.Component.DIRECTION_RIGHT Ext.Component.DIRECTION_BOTTOM Ext.Component.DIRECTION_LEFT Defaults to collapseDirection.
 * @param {boolean=} animate Boolean True to animate the transition, else false (defaults to the value of the animCollapse panel config). May also be specified as the animation duration in milliseconds.
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.IPanel.prototype.collapse = function(direction, animate) {};

/**
 * [Method] converts a collapsdDir into an anchor argument for Element slideIn overridden in rtl mode to switch l and r
 * @param {?=} collapseDir Object
 * @return {void}
 */
Ext.IPanel.prototype.convertCollapseDir = function(collapseDir) {};

/**
 * [Method] Expands the panel body so that it becomes visible
 * @param {boolean=} animate Boolean True to animate the transition, else false (defaults to the value of the animCollapse panel config). May also be specified as the animation duration in milliseconds.
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.IPanel.prototype.expand = function(animate) {};

/**
 * [Method] Returns the current collapsed state of the panel
 * @return {?} Boolean/String False when not collapsed, otherwise the value of collapseDirection.
 */
Ext.IPanel.prototype.getCollapsed = function() {};

/**
 * [Method] Gets the Header for this panel
 * @return {void}
 */
Ext.IPanel.prototype.getHeader = function() {};

/**
 * [Method] The supplied default state gathering method for the AbstractComponent class
 * @return {?} Object
 */
Ext.IPanel.prototype.getState = function() {};

/**
 * [Method] Determines whether this Component is the root of a layout
 * @return {void}
 */
Ext.IPanel.prototype.isLayoutRoot = function() {};

/**
 * [Method] Returns true if this component is visible
 * @param {?=} deep Object
 * @return {boolean} Boolean true if this component is visible, false otherwise.
 */
Ext.IPanel.prototype.isVisible = function(deep) {};

/**
 * [Method] Possibly animates down to a target element
 * @return {void}
 */
Ext.IPanel.prototype.onHide = function() {};

/**
 * [Method] Method to manage awareness of when components are removed from their respective Container firing a removed event
 * @param {?=} destroying Object
 * @return {void}
 */
Ext.IPanel.prototype.onRemoved = function(destroying) {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.IPanel.prototype.onShow = function() {};

/**
 * [Method]
 * @param {?=} border Object
 * @param {?=} targetEl Object
 * @return {void}
 */
Ext.IPanel.prototype.setBorder = function(border, targetEl) {};

/**
 * [Method] Set the glyph for the panel s header
 * @param {?=} newGlyph Number/String The new glyph This parameter expects a format consistent with that of glyph
 * @return {void}
 */
Ext.IPanel.prototype.setGlyph = function(newGlyph) {};

/**
 * [Method] Set the icon for the panel s header
 * @param {string=} newIcon String The new icon path
 * @return {void}
 */
Ext.IPanel.prototype.setIcon = function(newIcon) {};

/**
 * [Method] Set the iconCls for the panel s header
 * @param {string=} newIconCls String The new CSS class name
 * @return {void}
 */
Ext.IPanel.prototype.setIconCls = function(newIconCls) {};

/**
 * [Method] Set a title for the panel s header
 * @param {string=} newTitle String
 * @return {void}
 */
Ext.IPanel.prototype.setTitle = function(newTitle) {};

/**
 * [Method] Sets the UI for the component
 * @param {?=} ui Object
 * @return {void}
 */
Ext.IPanel.prototype.setUI = function(ui) {};

/**
 * [Method] Shortcut for performing an expand or collapse based on the current state of the panel
 * @return {!Ext.panel.IPanel} Ext.panel.Panel this
 */
Ext.IPanel.prototype.toggleCollapse = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.panel.IProxy = function() {};
 /** @type {boolean} */
Ext.panel.IProxy.prototype.insertProxy;
 /** @type {boolean} */
Ext.panel.IProxy.prototype.moveOnDrag;
 /** @type {!Ext.panel.IPanel} */
Ext.panel.IProxy.prototype.panel;

/**
 * [Method] Gets the proxy s element
 * @return {!Ext.IElement} Ext.Element The proxy's element
 */
Ext.panel.IProxy.prototype.getEl = function() {};

/**
 * [Method] Gets the proxy s ghost Panel
 * @return {!Ext.panel.IPanel} Ext.panel.Panel The proxy's ghost Panel
 */
Ext.panel.IProxy.prototype.getGhost = function() {};

/**
 * [Method] Gets the proxy element
 * @return {!Ext.IElement} Ext.Element The proxy's element
 */
Ext.panel.IProxy.prototype.getProxy = function() {};

/**
 * [Method] Hides the proxy
 * @return {void}
 */
Ext.panel.IProxy.prototype.hide = function() {};

/**
 * [Method] Moves the proxy to a different position in the DOM
 * @param {!HTMLElement=} parentNode HTMLElement The proxy's parent DOM node
 * @param {!HTMLElement=} before HTMLElement The sibling node before which the proxy should be inserted. Defaults to the parent's last child if not specified.
 * @return {void}
 */
Ext.panel.IProxy.prototype.moveProxy = function(parentNode, before) {};

/**
 * [Method] Shows the proxy
 * @return {void}
 */
Ext.panel.IProxy.prototype.show = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.dd.IPanelProxy = function() {};
 /** @type {boolean} */
Ext.dd.IPanelProxy.prototype.insertProxy;
 /** @type {boolean} */
Ext.dd.IPanelProxy.prototype.moveOnDrag;
 /** @type {!Ext.panel.IPanel} */
Ext.dd.IPanelProxy.prototype.panel;

/**
 * [Method] Gets the proxy s element
 * @return {!Ext.IElement} Ext.Element The proxy's element
 */
Ext.dd.IPanelProxy.prototype.getEl = function() {};

/**
 * [Method] Gets the proxy s ghost Panel
 * @return {!Ext.panel.IPanel} Ext.panel.Panel The proxy's ghost Panel
 */
Ext.dd.IPanelProxy.prototype.getGhost = function() {};

/**
 * [Method] Gets the proxy element
 * @return {!Ext.IElement} Ext.Element The proxy's element
 */
Ext.dd.IPanelProxy.prototype.getProxy = function() {};

/**
 * [Method] Hides the proxy
 * @return {void}
 */
Ext.dd.IPanelProxy.prototype.hide = function() {};

/**
 * [Method] Moves the proxy to a different position in the DOM
 * @param {!HTMLElement=} parentNode HTMLElement The proxy's parent DOM node
 * @param {!HTMLElement=} before HTMLElement The sibling node before which the proxy should be inserted. Defaults to the parent's last child if not specified.
 * @return {void}
 */
Ext.dd.IPanelProxy.prototype.moveProxy = function(parentNode, before) {};

/**
 * [Method] Shows the proxy
 * @return {void}
 */
Ext.dd.IPanelProxy.prototype.show = function() {};
/**
 * @extends {Ext.panel.IPanel}
 * @extends {Ext.grid.locking.ILockable}
 * @record
 * @struct
 */
Ext.panel.ITable = function() {};
 /** @type {boolean} */
Ext.panel.ITable.prototype.allowDeselect;
 /** @type {boolean} */
Ext.panel.ITable.prototype.columnLines;
 /** @type {?} */
Ext.panel.ITable.prototype.columns;
 /** @type {boolean} */
Ext.panel.ITable.prototype.deferRowRender;
 /** @type {boolean} */
Ext.panel.ITable.prototype.disableSelection;
 /** @type {string} */
Ext.panel.ITable.prototype.emptyText;
 /** @type {boolean} */
Ext.panel.ITable.prototype.enableColumnHide;
 /** @type {boolean} */
Ext.panel.ITable.prototype.enableColumnMove;
 /** @type {boolean} */
Ext.panel.ITable.prototype.enableColumnResize;
 /** @type {boolean} */
Ext.panel.ITable.prototype.enableLocking;
 /** @type {?} */
Ext.panel.ITable.prototype.features;
 /** @type {boolean} */
Ext.panel.ITable.prototype.forceFit;
 /** @type {boolean} */
Ext.panel.ITable.prototype.hideHeaders;
 /** @type {?} */
Ext.panel.ITable.prototype.layout;
 /** @type {boolean} */
Ext.panel.ITable.prototype.multiSelect;
 /** @type {boolean} */
Ext.panel.ITable.prototype.rowLines;
 /** @type {?} */
Ext.panel.ITable.prototype.scroll;
 /** @type {boolean} */
Ext.panel.ITable.prototype.sealedColumns;
 /** @type {?} */
Ext.panel.ITable.prototype.selModel;
 /** @type {string} */
Ext.panel.ITable.prototype.selType;
 /** @type {boolean} */
Ext.panel.ITable.prototype.simpleSelect;
 /** @type {boolean} */
Ext.panel.ITable.prototype.sortableColumns;
 /** @type {!Ext.data.IStore} */
Ext.panel.ITable.prototype.store;
 /** @type {?} */
Ext.panel.ITable.prototype.verticalScroller;
 /** @type {!Ext.view.ITable} */
Ext.panel.ITable.prototype.view;
 /** @type {?} */
Ext.panel.ITable.prototype.viewConfig;
 /** @type {string} */
Ext.panel.ITable.prototype.viewType;
 /** @type {boolean} */
Ext.panel.ITable.prototype.hasView;
 /** @type {boolean} */
Ext.panel.ITable.prototype.optimizedColumnMove;

/**
 * [Method] Invoked after the Panel is Collapsed
 * @return {void}
 */
Ext.panel.ITable.prototype.afterCollapse = function() {};

/**
 * [Method] Invoked after the Panel is Expanded
 * @return {void}
 */
Ext.panel.ITable.prototype.afterExpand = function() {};

/**
 * [Method] Applies the state to the object
 * @param {?=} state Object
 * @return {void}
 */
Ext.panel.ITable.prototype.applyState = function(state) {};

/**
 * [Method] This method is obsolete in 4 1
 * @return {void}
 */
Ext.panel.ITable.prototype.determineScrollbars = function() {};

/**
 * [Method] Returns the selection model being used and creates it via the configuration if it has not been created already
 * @return {!Ext.selection.IModel} Ext.selection.Model selModel
 */
Ext.panel.ITable.prototype.getSelectionModel = function() {};

/**
 * [Method] The supplied default state gathering method for the AbstractComponent class
 * @return {?} Object
 */
Ext.panel.ITable.prototype.getState = function() {};

/**
 * [Method] Returns the store associated with this Panel
 * @return {!Ext.data.IStore} Ext.data.Store The store
 */
Ext.panel.ITable.prototype.getStore = function() {};

/**
 * [Method] Gets the view for this panel
 * @return {!Ext.view.ITable} Ext.view.Table
 */
Ext.panel.ITable.prototype.getView = function() {};

/**
 * [Method] This method is obsolete in 4 1
 * @return {void}
 */
Ext.panel.ITable.prototype.invalidateScroller = function() {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.panel.ITable.prototype.onDestroy = function() {};

/**
 * [Method] Synchronizes the row heights between the locked and non locked portion of the grid for each row
 * @return {void}
 */
Ext.panel.ITable.prototype.syncRowHeights = function() {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.panel.ITool = function() {};
 /** @type {string} */
Ext.panel.ITool.prototype.baseCls;
 /** @type {?} */
Ext.panel.ITool.prototype.callback;
 /** @type {string} */
Ext.panel.ITool.prototype.disabledCls;
 /** @type {?} */
Ext.panel.ITool.prototype.handler;
 /** @type {number} */
Ext.panel.ITool.prototype.height;
 /** @type {?} */
Ext.panel.ITool.prototype.renderTpl;
 /** @type {?} */
Ext.panel.ITool.prototype.scope;
 /** @type {boolean} */
Ext.panel.ITool.prototype.stopEvent;
 /** @type {!Ext.IComponent} */
Ext.panel.ITool.prototype.toolOwner;
 /** @type {?} */
Ext.panel.ITool.prototype.tooltip;
 /** @type {string} */
Ext.panel.ITool.prototype.tooltipType;
 /** @type {string} */
Ext.panel.ITool.prototype.type;
 /** @type {number} */
Ext.panel.ITool.prototype.width;
 /** @type {boolean} */
Ext.panel.ITool.prototype.isTool;

/**
 * [Method] inherit docs
 * @return {void}
 */
Ext.panel.ITool.prototype.afterRender = function() {};

/**
 * [Method]
 * @return {void}
 */
Ext.panel.ITool.prototype.initComponent = function() {};

/**
 * [Method] inherit docs
 * @return {void}
 */
Ext.panel.ITool.prototype.onDestroy = function() {};

/**
 * [Method] Sets the type of the tool
 * @param {string=} type String The new type. See the type config.
 * @return {!Ext.panel.ITool} Ext.panel.Tool this
 */
Ext.panel.ITool.prototype.setType = function(type) {};
/** @const */
Ext.perf = {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.perf.IAccumulator = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.perf.IMonitor = function() {};
/**
 * @constructor
 * @struct
 */
Ext.perf.Monitor = function() {};
 /** @type {!Ext.IClass} */
Ext.perf.Monitor.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.perf.Monitor.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.perf.Monitor.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.perf.Monitor.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.perf.Monitor.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.perf.Monitor.initConfig = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.perf.Monitor.statics = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IPerf = function() {};
/**
 * @constructor
 * @struct
 */
Ext.Perf = function() {};
 /** @type {!Ext.IClass} */
Ext.Perf.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.Perf.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.Perf.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.Perf.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.Perf.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.Perf.initConfig = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.Perf.statics = function() {};
/** @const */
Ext.picker = {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.picker.IColor = function() {};
 /** @type {boolean} */
Ext.picker.IColor.prototype.allowReselect;
 /** @type {string} */
Ext.picker.IColor.prototype.clickEvent;
 /** @type {string} */
Ext.picker.IColor.prototype.componentCls;
 /** @type {?} */
Ext.picker.IColor.prototype.handler;
 /** @type {string} */
Ext.picker.IColor.prototype.itemCls;
 /** @type {?} */
Ext.picker.IColor.prototype.renderTpl;
 /** @type {?} */
Ext.picker.IColor.prototype.scope;
 /** @type {string} */
Ext.picker.IColor.prototype.selectedCls;
 /** @type {string} */
Ext.picker.IColor.prototype.value;
 /** @type {!Array<string>} */
Ext.picker.IColor.prototype.colors;

/**
 * [Method] Clears any selection and sets the value to null
 * @return {void}
 */
Ext.picker.IColor.prototype.clear = function() {};

/**
 * [Method] Get the currently selected color value
 * @return {string} String value The selected value. Null if nothing is selected.
 */
Ext.picker.IColor.prototype.getValue = function() {};

/**
 * [Method] Template method called when this Component s DOM structure is created
 * @return {void}
 */
Ext.picker.IColor.prototype.onRender = function() {};

/**
 * [Method] Selects the specified color in the picker fires the select event
 * @param {string=} color String A valid 6-digit color hex code (# will be stripped if included)
 * @param {boolean=} suppressEvent Boolean True to stop the select event from firing.
 * @return {void}
 */
Ext.picker.IColor.prototype.select = function(color, suppressEvent) {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.IColorPalette = function() {};
 /** @type {boolean} */
Ext.IColorPalette.prototype.allowReselect;
 /** @type {string} */
Ext.IColorPalette.prototype.clickEvent;
 /** @type {string} */
Ext.IColorPalette.prototype.componentCls;
 /** @type {?} */
Ext.IColorPalette.prototype.handler;
 /** @type {string} */
Ext.IColorPalette.prototype.itemCls;
 /** @type {?} */
Ext.IColorPalette.prototype.renderTpl;
 /** @type {?} */
Ext.IColorPalette.prototype.scope;
 /** @type {string} */
Ext.IColorPalette.prototype.selectedCls;
 /** @type {string} */
Ext.IColorPalette.prototype.value;
 /** @type {!Array<string>} */
Ext.IColorPalette.prototype.colors;

/**
 * [Method] Clears any selection and sets the value to null
 * @return {void}
 */
Ext.IColorPalette.prototype.clear = function() {};

/**
 * [Method] Get the currently selected color value
 * @return {string} String value The selected value. Null if nothing is selected.
 */
Ext.IColorPalette.prototype.getValue = function() {};

/**
 * [Method] Template method called when this Component s DOM structure is created
 * @return {void}
 */
Ext.IColorPalette.prototype.onRender = function() {};

/**
 * [Method] Selects the specified color in the picker fires the select event
 * @param {string=} color String A valid 6-digit color hex code (# will be stripped if included)
 * @param {boolean=} suppressEvent Boolean True to stop the select event from firing.
 * @return {void}
 */
Ext.IColorPalette.prototype.select = function(color, suppressEvent) {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.picker.IDate = function() {};
 /** @type {string} */
Ext.picker.IDate.prototype.ariaTitle;
 /** @type {string} */
Ext.picker.IDate.prototype.ariaTitleDateFormat;
 /** @type {string} */
Ext.picker.IDate.prototype.baseCls;
 /** @type {?} */
Ext.picker.IDate.prototype.border;
 /** @type {!Array<string>} */
Ext.picker.IDate.prototype.dayNames;
 /** @type {boolean} */
Ext.picker.IDate.prototype.disableAnim;
 /** @type {string} */
Ext.picker.IDate.prototype.disabledCellCls;
 /** @type {!Array<string>} */
Ext.picker.IDate.prototype.disabledDates;
 /** @type {!RegExp} */
Ext.picker.IDate.prototype.disabledDatesRE;
 /** @type {string} */
Ext.picker.IDate.prototype.disabledDatesText;
 /** @type {!Array<number>} */
Ext.picker.IDate.prototype.disabledDays;
 /** @type {string} */
Ext.picker.IDate.prototype.disabledDaysText;
 /** @type {boolean} */
Ext.picker.IDate.prototype.focusOnShow;
 /** @type {string} */
Ext.picker.IDate.prototype.format;
 /** @type {?} */
Ext.picker.IDate.prototype.handler;
 /** @type {?} */
Ext.picker.IDate.prototype.keyNavConfig;
 /** @type {string} */
Ext.picker.IDate.prototype.longDayFormat;
 /** @type {?} */
Ext.picker.IDate.prototype.maxDate;
 /** @type {string} */
Ext.picker.IDate.prototype.maxText;
 /** @type {?} */
Ext.picker.IDate.prototype.minDate;
 /** @type {string} */
Ext.picker.IDate.prototype.minText;
 /** @type {!Array<string>} */
Ext.picker.IDate.prototype.monthNames;
 /** @type {string} */
Ext.picker.IDate.prototype.monthYearFormat;
 /** @type {string} */
Ext.picker.IDate.prototype.monthYearText;
 /** @type {string} */
Ext.picker.IDate.prototype.nextText;
 /** @type {string} */
Ext.picker.IDate.prototype.prevText;
 /** @type {?} */
Ext.picker.IDate.prototype.renderTpl;
 /** @type {?} */
Ext.picker.IDate.prototype.scope;
 /** @type {string} */
Ext.picker.IDate.prototype.selectedCls;
 /** @type {boolean} */
Ext.picker.IDate.prototype.showToday;
 /** @type {number} */
Ext.picker.IDate.prototype.startDay;
 /** @type {string} */
Ext.picker.IDate.prototype.todayText;
 /** @type {string} */
Ext.picker.IDate.prototype.todayTip;

/**
 * [Method] Gets a single character to represent the day of the week
 * @param {?=} value Object
 * @return {string} String The character
 */
Ext.picker.IDate.prototype.getDayInitial = function(value) {};

/**
 * [Method] Gets the current selected value of the date field
 * @return {?} Date The selected date
 */
Ext.picker.IDate.prototype.getValue = function() {};

/**
 * [Method] Hides the month picker if it s visible
 * @param {boolean=} animate Boolean Indicates whether to animate this action. If the animate parameter is not specified, the behavior will use disableAnim to determine whether to animate or not.
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.picker.IDate.prototype.hideMonthPicker = function(animate) {};

/**
 * [Method] private inherit docs
 * @return {void}
 */
Ext.picker.IDate.prototype.initComponent = function() {};

/**
 * [Method] Sets the current value to today
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.picker.IDate.prototype.selectToday = function() {};

/**
 * [Method] Replaces any existing disabled dates with new values and refreshes the DatePicker
 * @param {?=} disabledDates String[]/RegExp An array of date strings (see the disabledDates config for details on supported values), or a JavaScript regular expression used to disable a pattern of dates.
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.picker.IDate.prototype.setDisabledDates = function(disabledDates) {};

/**
 * [Method] Replaces any existing disabled days by index 0 6 with new values and refreshes the DatePicker
 * @param {!Array<number>=} disabledDays Number[] An array of disabled day indexes. See the disabledDays config for details on supported values.
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.picker.IDate.prototype.setDisabledDays = function(disabledDays) {};

/**
 * [Method] Replaces any existing maxDate with the new value and refreshes the DatePicker
 * @param {?=} value Date The maximum date that can be selected
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.picker.IDate.prototype.setMaxDate = function(value) {};

/**
 * [Method] Replaces any existing minDate with the new value and refreshes the DatePicker
 * @param {?=} value Date The minimum date that can be selected
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.picker.IDate.prototype.setMinDate = function(value) {};

/**
 * [Method] Sets the value of the date field
 * @param {?=} value Date The date to set
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.picker.IDate.prototype.setValue = function(value) {};

/**
 * [Method] Show the month picker
 * @param {boolean=} animate Boolean Indicates whether to animate this action. If the animate parameter is not specified, the behavior will use disableAnim to determine whether to animate or not.
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.picker.IDate.prototype.showMonthPicker = function(animate) {};

/**
 * [Method] Show the next month
 * @param {?=} e Object
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.picker.IDate.prototype.showNextMonth = function(e) {};

/**
 * [Method] Show the next year
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.picker.IDate.prototype.showNextYear = function() {};

/**
 * [Method] Show the previous month
 * @param {?=} e Object
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.picker.IDate.prototype.showPrevMonth = function(e) {};

/**
 * [Method] Show the previous year
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.picker.IDate.prototype.showPrevYear = function() {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.IDatePicker = function() {};
 /** @type {string} */
Ext.IDatePicker.prototype.ariaTitle;
 /** @type {string} */
Ext.IDatePicker.prototype.ariaTitleDateFormat;
 /** @type {string} */
Ext.IDatePicker.prototype.baseCls;
 /** @type {?} */
Ext.IDatePicker.prototype.border;
 /** @type {!Array<string>} */
Ext.IDatePicker.prototype.dayNames;
 /** @type {boolean} */
Ext.IDatePicker.prototype.disableAnim;
 /** @type {string} */
Ext.IDatePicker.prototype.disabledCellCls;
 /** @type {!Array<string>} */
Ext.IDatePicker.prototype.disabledDates;
 /** @type {!RegExp} */
Ext.IDatePicker.prototype.disabledDatesRE;
 /** @type {string} */
Ext.IDatePicker.prototype.disabledDatesText;
 /** @type {!Array<number>} */
Ext.IDatePicker.prototype.disabledDays;
 /** @type {string} */
Ext.IDatePicker.prototype.disabledDaysText;
 /** @type {boolean} */
Ext.IDatePicker.prototype.focusOnShow;
 /** @type {string} */
Ext.IDatePicker.prototype.format;
 /** @type {?} */
Ext.IDatePicker.prototype.handler;
 /** @type {?} */
Ext.IDatePicker.prototype.keyNavConfig;
 /** @type {string} */
Ext.IDatePicker.prototype.longDayFormat;
 /** @type {?} */
Ext.IDatePicker.prototype.maxDate;
 /** @type {string} */
Ext.IDatePicker.prototype.maxText;
 /** @type {?} */
Ext.IDatePicker.prototype.minDate;
 /** @type {string} */
Ext.IDatePicker.prototype.minText;
 /** @type {!Array<string>} */
Ext.IDatePicker.prototype.monthNames;
 /** @type {string} */
Ext.IDatePicker.prototype.monthYearFormat;
 /** @type {string} */
Ext.IDatePicker.prototype.monthYearText;
 /** @type {string} */
Ext.IDatePicker.prototype.nextText;
 /** @type {string} */
Ext.IDatePicker.prototype.prevText;
 /** @type {?} */
Ext.IDatePicker.prototype.renderTpl;
 /** @type {?} */
Ext.IDatePicker.prototype.scope;
 /** @type {string} */
Ext.IDatePicker.prototype.selectedCls;
 /** @type {boolean} */
Ext.IDatePicker.prototype.showToday;
 /** @type {number} */
Ext.IDatePicker.prototype.startDay;
 /** @type {string} */
Ext.IDatePicker.prototype.todayText;
 /** @type {string} */
Ext.IDatePicker.prototype.todayTip;

/**
 * [Method] Gets a single character to represent the day of the week
 * @param {?=} value Object
 * @return {string} String The character
 */
Ext.IDatePicker.prototype.getDayInitial = function(value) {};

/**
 * [Method] Gets the current selected value of the date field
 * @return {?} Date The selected date
 */
Ext.IDatePicker.prototype.getValue = function() {};

/**
 * [Method] Hides the month picker if it s visible
 * @param {boolean=} animate Boolean Indicates whether to animate this action. If the animate parameter is not specified, the behavior will use disableAnim to determine whether to animate or not.
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.IDatePicker.prototype.hideMonthPicker = function(animate) {};

/**
 * [Method] private inherit docs
 * @return {void}
 */
Ext.IDatePicker.prototype.initComponent = function() {};

/**
 * [Method] Sets the current value to today
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.IDatePicker.prototype.selectToday = function() {};

/**
 * [Method] Replaces any existing disabled dates with new values and refreshes the DatePicker
 * @param {?=} disabledDates String[]/RegExp An array of date strings (see the disabledDates config for details on supported values), or a JavaScript regular expression used to disable a pattern of dates.
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.IDatePicker.prototype.setDisabledDates = function(disabledDates) {};

/**
 * [Method] Replaces any existing disabled days by index 0 6 with new values and refreshes the DatePicker
 * @param {!Array<number>=} disabledDays Number[] An array of disabled day indexes. See the disabledDays config for details on supported values.
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.IDatePicker.prototype.setDisabledDays = function(disabledDays) {};

/**
 * [Method] Replaces any existing maxDate with the new value and refreshes the DatePicker
 * @param {?=} value Date The maximum date that can be selected
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.IDatePicker.prototype.setMaxDate = function(value) {};

/**
 * [Method] Replaces any existing minDate with the new value and refreshes the DatePicker
 * @param {?=} value Date The minimum date that can be selected
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.IDatePicker.prototype.setMinDate = function(value) {};

/**
 * [Method] Sets the value of the date field
 * @param {?=} value Date The date to set
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.IDatePicker.prototype.setValue = function(value) {};

/**
 * [Method] Show the month picker
 * @param {boolean=} animate Boolean Indicates whether to animate this action. If the animate parameter is not specified, the behavior will use disableAnim to determine whether to animate or not.
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.IDatePicker.prototype.showMonthPicker = function(animate) {};

/**
 * [Method] Show the next month
 * @param {?=} e Object
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.IDatePicker.prototype.showNextMonth = function(e) {};

/**
 * [Method] Show the next year
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.IDatePicker.prototype.showNextYear = function() {};

/**
 * [Method] Show the previous month
 * @param {?=} e Object
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.IDatePicker.prototype.showPrevMonth = function(e) {};

/**
 * [Method] Show the previous year
 * @return {!Ext.picker.IDate} Ext.picker.Date this
 */
Ext.IDatePicker.prototype.showPrevYear = function() {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.picker.IMonth = function() {};
 /** @type {string} */
Ext.picker.IMonth.prototype.baseCls;
 /** @type {string} */
Ext.picker.IMonth.prototype.cancelText;
 /** @type {string} */
Ext.picker.IMonth.prototype.okText;
 /** @type {?} */
Ext.picker.IMonth.prototype.renderTpl;
 /** @type {string} */
Ext.picker.IMonth.prototype.selectedCls;
 /** @type {boolean} */
Ext.picker.IMonth.prototype.showButtons;
 /** @type {?} */
Ext.picker.IMonth.prototype.value;

/**
 * [Method] Modify the year display by passing an offset
 * @param {number=} offset Number The offset to move by.
 * @return {void}
 */
Ext.picker.IMonth.prototype.adjustYear = function(offset) {};

/**
 * [Method] Gets the selected value
 * @return {!Array<number>} Number[] The selected value
 */
Ext.picker.IMonth.prototype.getValue = function() {};

/**
 * [Method] Checks whether the picker has a selection
 * @return {boolean} Boolean Returns true if both a month and year have been selected
 */
Ext.picker.IMonth.prototype.hasSelection = function() {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.picker.IMonth.prototype.onDestroy = function() {};

/**
 * [Method] Set the value for the picker
 * @param {?=} value Date/Number[] The value to set. It can be a Date object, where the month/year will be extracted, or it can be an array, with the month as the first index and the year as the second.
 * @return {!Ext.picker.IMonth} Ext.picker.Month this
 */
Ext.picker.IMonth.prototype.setValue = function(value) {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.IMonthPicker = function() {};
 /** @type {string} */
Ext.IMonthPicker.prototype.baseCls;
 /** @type {string} */
Ext.IMonthPicker.prototype.cancelText;
 /** @type {string} */
Ext.IMonthPicker.prototype.okText;
 /** @type {?} */
Ext.IMonthPicker.prototype.renderTpl;
 /** @type {string} */
Ext.IMonthPicker.prototype.selectedCls;
 /** @type {boolean} */
Ext.IMonthPicker.prototype.showButtons;
 /** @type {?} */
Ext.IMonthPicker.prototype.value;

/**
 * [Method] Modify the year display by passing an offset
 * @param {number=} offset Number The offset to move by.
 * @return {void}
 */
Ext.IMonthPicker.prototype.adjustYear = function(offset) {};

/**
 * [Method] Gets the selected value
 * @return {!Array<number>} Number[] The selected value
 */
Ext.IMonthPicker.prototype.getValue = function() {};

/**
 * [Method] Checks whether the picker has a selection
 * @return {boolean} Boolean Returns true if both a month and year have been selected
 */
Ext.IMonthPicker.prototype.hasSelection = function() {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.IMonthPicker.prototype.onDestroy = function() {};

/**
 * [Method] Set the value for the picker
 * @param {?=} value Date/Number[] The value to set. It can be a Date object, where the month/year will be extracted, or it can be an array, with the month as the first index and the year as the second.
 * @return {!Ext.picker.IMonth} Ext.picker.Month this
 */
Ext.IMonthPicker.prototype.setValue = function(value) {};
/**
 * @extends {Ext.view.IBoundList}
 * @record
 * @struct
 */
Ext.picker.ITime = function() {};
 /** @type {string} */
Ext.picker.ITime.prototype.componentCls;
 /** @type {string} */
Ext.picker.ITime.prototype.format;
 /** @type {number} */
Ext.picker.ITime.prototype.increment;
 /** @type {?} */
Ext.picker.ITime.prototype.maxValue;
 /** @type {?} */
Ext.picker.ITime.prototype.minValue;

/**
 * [Method] Focuses a node in the view
 * @param {?=} rec Object
 * @return {void}
 */
Ext.picker.ITime.prototype.focusNode = function(rec) {};

/**
 * [Method] private
 * @return {void}
 */
Ext.picker.ITime.prototype.initComponent = function() {};

/**
 * [Method] Set the maxValue and update the list of available times
 * @param {?=} value Date
 * @return {void}
 */
Ext.picker.ITime.prototype.setMaxValue = function(value) {};

/**
 * [Method] Set the minValue and update the list of available times
 * @param {?=} value Date
 * @return {void}
 */
Ext.picker.ITime.prototype.setMinValue = function(value) {};

/**
 * [Method] Update the list of available times in the list to be constrained within the minValue and maxValue
 * @return {void}
 */
Ext.picker.ITime.prototype.updateList = function() {};
/**
 * @extends {Ext.IAbstractManager}
 * @record
 * @struct
 */
Ext.IPluginManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.PluginManager = function() {};
 /** @type {!Ext.util.IHashMap} */
Ext.PluginManager.all;
 /** @type {!Ext.IClass} */
Ext.PluginManager.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.PluginManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.PluginManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.PluginManager.callSuper = function(args) {};

/**
 * [Method] Creates a new Plugin from the specified config object using the config object s ptype to determine the class to insta
 * @param {?=} config Object A configuration object for the Plugin you wish to create.
 * @param {?=} defaultType Function The constructor to provide the default Plugin type if the config object does not contain a ptype. (Optional if the config contains a ptype).
 * @return {!Ext.IComponent} Ext.Component The newly instantiated Plugin.
 */
Ext.PluginManager.create = function(config, defaultType) {};

/**
 * [Method] Executes the specified function once for each item in the collection
 * @param {?=} fn Function The function to execute.
 * @param {?=} scope Object The scope to execute in. Defaults to this.
 * @return {void}
 */
Ext.PluginManager.each = function(fn, scope) {};

/**
 * [Method] Returns all plugins registered with the given type
 * @param {string=} type String The type to search for
 * @param {boolean=} defaultsOnly Boolean True to only return plugins of this type where the plugin's isDefault property is truthy
 * @return {!Array<!Ext.IAbstractPlugin>} Ext.AbstractPlugin[] All matching plugins
 */
Ext.PluginManager.findByType = function(type, defaultsOnly) {};

/**
 * [Method] Returns an item by id
 * @param {string=} id String The id of the item
 * @return {?} Object The item, undefined if not found.
 */
Ext.PluginManager.get = function(id) {};

/**
 * [Method] Gets the number of items in the collection
 * @return {number} Number The number of items in the collection.
 */
Ext.PluginManager.getCount = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.PluginManager.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.PluginManager.initConfig = function(config) {};

/**
 * [Method] Checks if an item type is registered
 * @param {string=} type String The mnemonic string by which the class may be looked up
 * @return {boolean} Boolean Whether the type is registered.
 */
Ext.PluginManager.isRegistered = function(type) {};

/**
 * [Method] Registers a function that will be called when an item with the specified id is added to the manager
 * @param {string=} id String The item id
 * @param {?=} fn Function The callback function. Called with a single parameter, the item.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed. Defaults to the item.
 * @return {void}
 */
Ext.PluginManager.onAvailable = function(id, fn, scope) {};

/**
 * [Method] Registers an item to be managed
 * @param {?=} item Object The item to register
 * @return {void}
 */
Ext.PluginManager.register = function(item) {};

/**
 * [Method] Registers a new item constructor keyed by a type key
 * @param {string=} type String The mnemonic string by which the class may be looked up.
 * @param {?=} cls Function The new instance class.
 * @return {void}
 */
Ext.PluginManager.registerType = function(type, cls) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.PluginManager.statics = function() {};

/**
 * [Method] Unregisters an item by removing it from this manager
 * @param {?=} item Object The item to unregister
 * @return {void}
 */
Ext.PluginManager.unregister = function(item) {};
/**
 * @extends {Ext.IAbstractManager}
 * @record
 * @struct
 */
Ext.IPluginMgr = function() {};
/**
 * @constructor
 * @struct
 */
Ext.PluginMgr = function() {};
 /** @type {!Ext.util.IHashMap} */
Ext.PluginMgr.all;
 /** @type {!Ext.IClass} */
Ext.PluginMgr.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.PluginMgr.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.PluginMgr.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.PluginMgr.callSuper = function(args) {};

/**
 * [Method] Creates a new Plugin from the specified config object using the config object s ptype to determine the class to insta
 * @param {?=} config Object A configuration object for the Plugin you wish to create.
 * @param {?=} defaultType Function The constructor to provide the default Plugin type if the config object does not contain a ptype. (Optional if the config contains a ptype).
 * @return {!Ext.IComponent} Ext.Component The newly instantiated Plugin.
 */
Ext.PluginMgr.create = function(config, defaultType) {};

/**
 * [Method] Executes the specified function once for each item in the collection
 * @param {?=} fn Function The function to execute.
 * @param {?=} scope Object The scope to execute in. Defaults to this.
 * @return {void}
 */
Ext.PluginMgr.each = function(fn, scope) {};

/**
 * [Method] Returns all plugins registered with the given type
 * @param {string=} type String The type to search for
 * @param {boolean=} defaultsOnly Boolean True to only return plugins of this type where the plugin's isDefault property is truthy
 * @return {!Array<!Ext.IAbstractPlugin>} Ext.AbstractPlugin[] All matching plugins
 */
Ext.PluginMgr.findByType = function(type, defaultsOnly) {};

/**
 * [Method] Returns an item by id
 * @param {string=} id String The id of the item
 * @return {?} Object The item, undefined if not found.
 */
Ext.PluginMgr.get = function(id) {};

/**
 * [Method] Gets the number of items in the collection
 * @return {number} Number The number of items in the collection.
 */
Ext.PluginMgr.getCount = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.PluginMgr.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.PluginMgr.initConfig = function(config) {};

/**
 * [Method] Checks if an item type is registered
 * @param {string=} type String The mnemonic string by which the class may be looked up
 * @return {boolean} Boolean Whether the type is registered.
 */
Ext.PluginMgr.isRegistered = function(type) {};

/**
 * [Method] Registers a function that will be called when an item with the specified id is added to the manager
 * @param {string=} id String The item id
 * @param {?=} fn Function The callback function. Called with a single parameter, the item.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed. Defaults to the item.
 * @return {void}
 */
Ext.PluginMgr.onAvailable = function(id, fn, scope) {};

/**
 * [Method] Registers an item to be managed
 * @param {?=} item Object The item to register
 * @return {void}
 */
Ext.PluginMgr.register = function(item) {};

/**
 * [Method] Registers a new item constructor keyed by a type key
 * @param {string=} type String The mnemonic string by which the class may be looked up.
 * @param {?=} cls Function The new instance class.
 * @return {void}
 */
Ext.PluginMgr.registerType = function(type, cls) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.PluginMgr.statics = function() {};

/**
 * [Method] Unregisters an item by removing it from this manager
 * @param {?=} item Object The item to unregister
 * @return {void}
 */
Ext.PluginMgr.unregister = function(item) {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.IProgressBar = function() {};
 /** @type {?} */
Ext.IProgressBar.prototype.animate;
 /** @type {string} */
Ext.IProgressBar.prototype.baseCls;
 /** @type {?} */
Ext.IProgressBar.prototype.componentLayout;
 /** @type {string} */
Ext.IProgressBar.prototype.id;
 /** @type {?} */
Ext.IProgressBar.prototype.renderTpl;
 /** @type {string} */
Ext.IProgressBar.prototype.text;
 /** @type {?} */
Ext.IProgressBar.prototype.textEl;
 /** @type {number} */
Ext.IProgressBar.prototype.value;

/**
 * [Method] private
 * @return {void}
 */
Ext.IProgressBar.prototype.initComponent = function() {};

/**
 * [Method] Initialized the renderData to be used when rendering the renderTpl
 * @return {?} Object Object with keys and values that are going to be applied to the renderTpl
 */
Ext.IProgressBar.prototype.initRenderData = function() {};

/**
 * [Method] Returns true if the progress bar is currently in a wait operation
 * @return {boolean} Boolean True if waiting, else false
 */
Ext.IProgressBar.prototype.isWaiting = function() {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.IProgressBar.prototype.onDestroy = function() {};

/**
 * [Method] Template method called when this Component s DOM structure is created
 * @return {void}
 */
Ext.IProgressBar.prototype.onRender = function() {};

/**
 * [Method] Resets the progress bar value to 0 and text to empty string
 * @param {boolean=} hide Boolean True to hide the progress bar.
 * @return {!Ext.IProgressBar} Ext.ProgressBar this
 */
Ext.IProgressBar.prototype.reset = function(hide) {};

/**
 * [Method] Updates the progress bar value and optionally its text
 * @param {number=} value Number A floating point value between 0 and 1 (e.g., .5)
 * @param {string=} text String The string to display in the progress text element
 * @param {boolean=} animate Boolean Whether to animate the transition of the progress bar. If this value is not specified, the default for the class is used
 * @return {!Ext.IProgressBar} Ext.ProgressBar this
 */
Ext.IProgressBar.prototype.updateProgress = function(value, text, animate) {};

/**
 * [Method] Updates the progress bar text
 * @param {string=} text String The string to display in the progress text element
 * @return {!Ext.IProgressBar} Ext.ProgressBar this
 */
Ext.IProgressBar.prototype.updateText = function(text) {};

/**
 * [Method] Initiates an auto updating progress bar
 * @param {?=} config Object Configuration options
 * @return {!Ext.IProgressBar} Ext.ProgressBar this
 */
Ext.IProgressBar.prototype.wait = function(config) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IQueryable = function() {};

/**
 * [Method] Retrieves the first direct child of this container which matches the passed selector or component
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching child Ext.Component (or null if no match was found).
 */
Ext.IQueryable.prototype.child = function(selector) {};

/**
 * [Method] Retrieves the first descendant of this container which matches the passed selector
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector or Ext.Component. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching descendant Ext.Component (or null if no match was found).
 */
Ext.IQueryable.prototype.down = function(selector) {};

/**
 * [Method] Retrieves all descendant components which match the passed selector
 * @param {string=} selector String Selector complying to an Ext.ComponentQuery selector. If no selector is specified all items will be returned.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components which matched the selector
 */
Ext.IQueryable.prototype.query = function(selector) {};

/**
 * [Method] Retrieves all descendant components which match the passed function
 * @param {?=} fn Function The matcher function. It will be called with a single argument, the component being tested.
 * @param {?=} scope Object The scope in which to run the function. If not specified, it will default to the active component.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components matched by the passed function
 */
Ext.IQueryable.prototype.queryBy = function(fn, scope) {};

/**
 * [Method] Finds a component at any level under this container matching the id itemId
 * @param {string=} id String The id to find
 * @return {!Ext.IComponent} Ext.Component The matching id, null if not found
 */
Ext.IQueryable.prototype.queryById = function(id) {};
/** @const */
Ext.resizer = {};
/**
 * @extends {Ext.resizer.ISplitter}
 * @record
 * @struct
 */
Ext.resizer.IBorderSplitter = function() {};
 /** @type {?} */
Ext.resizer.IBorderSplitter.prototype.collapseTarget;

/**
 * [Method] Returns the config object with an xclass property for the splitter tracker
 * @return {void}
 */
Ext.resizer.IBorderSplitter.prototype.getTrackerConfig = function() {};
/**
 * @extends {Ext.resizer.ISplitterTracker}
 * @record
 * @struct
 */
Ext.resizer.IBorderSplitterTracker = function() {};

/**
 * [Method] ensure the tracker is enabled store boxes of previous and next components and calculate the constrain region
 * @param {?=} e Object
 * @return {void}
 */
Ext.resizer.IBorderSplitterTracker.prototype.onBeforeStart = function(e) {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.resizer.IHandle = function() {};
 /** @type {?} */
Ext.resizer.IHandle.prototype.region;
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.resizer.IResizer = function() {};
 /** @type {?} */
Ext.resizer.IResizer.prototype.constrainTo;
 /** @type {boolean} */
Ext.resizer.IResizer.prototype.dynamic;
 /** @type {string} */
Ext.resizer.IResizer.prototype.handles;
 /** @type {number} */
Ext.resizer.IResizer.prototype.height;
 /** @type {number} */
Ext.resizer.IResizer.prototype.heightIncrement;
 /** @type {number} */
Ext.resizer.IResizer.prototype.maxHeight;
 /** @type {number} */
Ext.resizer.IResizer.prototype.maxWidth;
 /** @type {number} */
Ext.resizer.IResizer.prototype.minHeight;
 /** @type {number} */
Ext.resizer.IResizer.prototype.minWidth;
 /** @type {boolean} */
Ext.resizer.IResizer.prototype.pinned;
 /** @type {boolean} */
Ext.resizer.IResizer.prototype.preserveRatio;
 /** @type {?} */
Ext.resizer.IResizer.prototype.target;
 /** @type {boolean} */
Ext.resizer.IResizer.prototype.transparent;
 /** @type {number} */
Ext.resizer.IResizer.prototype.width;
 /** @type {number} */
Ext.resizer.IResizer.prototype.widthIncrement;
 /** @type {!Ext.IElement} */
Ext.resizer.IResizer.prototype.el;
 /** @type {?} */
Ext.resizer.IResizer.prototype.originalTarget;
 /** @type {!Ext.resizer.IResizeTracker} */
Ext.resizer.IResizer.prototype.resizeTracker;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.resizer.IResizer.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.resizer.IResizer.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.resizer.IResizer.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.resizer.IResizer.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.resizer.IResizer.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.resizer.IResizer.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.resizer.IResizer.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.resizer.IResizer.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the element that was configured with the el or target config property
 * @return {!Ext.IElement} Ext.Element element
 */
Ext.resizer.IResizer.prototype.getEl = function() {};

/**
 * [Method] Returns the element or component that was configured with the target config property
 * @return {?} Ext.Element/Ext.Component
 */
Ext.resizer.IResizer.prototype.getTarget = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.resizer.IResizer.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.resizer.IResizer.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.resizer.IResizer.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.resizer.IResizer.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.resizer.IResizer.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.resizer.IResizer.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.resizer.IResizer.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Perform a manual resize and fires the resize event
 * @param {number=} width Number
 * @param {number=} height Number
 * @return {void}
 */
Ext.resizer.IResizer.prototype.resizeTo = function(width, height) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.resizer.IResizer.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.resizer.IResizer.prototype.resumeEvents = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.resizer.IResizer.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.resizer.IResizer.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.resizer.IResizer.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.IResizable = function() {};
 /** @type {?} */
Ext.IResizable.prototype.constrainTo;
 /** @type {boolean} */
Ext.IResizable.prototype.dynamic;
 /** @type {string} */
Ext.IResizable.prototype.handles;
 /** @type {number} */
Ext.IResizable.prototype.height;
 /** @type {number} */
Ext.IResizable.prototype.heightIncrement;
 /** @type {number} */
Ext.IResizable.prototype.maxHeight;
 /** @type {number} */
Ext.IResizable.prototype.maxWidth;
 /** @type {number} */
Ext.IResizable.prototype.minHeight;
 /** @type {number} */
Ext.IResizable.prototype.minWidth;
 /** @type {boolean} */
Ext.IResizable.prototype.pinned;
 /** @type {boolean} */
Ext.IResizable.prototype.preserveRatio;
 /** @type {?} */
Ext.IResizable.prototype.target;
 /** @type {boolean} */
Ext.IResizable.prototype.transparent;
 /** @type {number} */
Ext.IResizable.prototype.width;
 /** @type {number} */
Ext.IResizable.prototype.widthIncrement;
 /** @type {!Ext.IElement} */
Ext.IResizable.prototype.el;
 /** @type {?} */
Ext.IResizable.prototype.originalTarget;
 /** @type {!Ext.resizer.IResizeTracker} */
Ext.IResizable.prototype.resizeTracker;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.IResizable.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.IResizable.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.IResizable.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.IResizable.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.IResizable.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.IResizable.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.IResizable.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.IResizable.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the element that was configured with the el or target config property
 * @return {!Ext.IElement} Ext.Element element
 */
Ext.IResizable.prototype.getEl = function() {};

/**
 * [Method] Returns the element or component that was configured with the target config property
 * @return {?} Ext.Element/Ext.Component
 */
Ext.IResizable.prototype.getTarget = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.IResizable.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.IResizable.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.IResizable.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.IResizable.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.IResizable.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.IResizable.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.IResizable.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Perform a manual resize and fires the resize event
 * @param {number=} width Number
 * @param {number=} height Number
 * @return {void}
 */
Ext.IResizable.prototype.resizeTo = function(width, height) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.IResizable.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.IResizable.prototype.resumeEvents = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.IResizable.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.IResizable.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.IResizable.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.dd.IDragTracker}
 * @record
 * @struct
 */
Ext.resizer.IResizeTracker = function() {};
 /** @type {?} */
Ext.resizer.IResizeTracker.prototype.constrainTo;

/**
 * [Method] Create a proxy for this resizer
 * @param {?=} target Ext.Component/Ext.Element The target
 * @return {!Ext.IElement} Ext.Element A proxy element
 */
Ext.resizer.IResizeTracker.prototype.createProxy = function(target) {};

/**
 * [Method] Template method which should be overridden by each DragTracker instance
 * @param {?=} e Object
 * @return {void}
 */
Ext.resizer.IResizeTracker.prototype.onBeforeStart = function(e) {};

/**
 * [Method] Template method which should be overridden by each DragTracker instance
 * @param {?=} e Object
 * @return {void}
 */
Ext.resizer.IResizeTracker.prototype.onDrag = function(e) {};

/**
 * [Method] Template method which should be overridden by each DragTracker instance
 * @param {?=} e Object
 * @return {void}
 */
Ext.resizer.IResizeTracker.prototype.onEnd = function(e) {};

/**
 * [Method] Template method which should be overridden by each DragTracker instance
 * @param {?=} e Object
 * @return {void}
 */
Ext.resizer.IResizeTracker.prototype.onStart = function(e) {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.resizer.ISplitter = function() {};
 /** @type {string} */
Ext.resizer.ISplitter.prototype.baseCls;
 /** @type {boolean} */
Ext.resizer.ISplitter.prototype.collapseOnDblClick;
 /** @type {?} */
Ext.resizer.ISplitter.prototype.collapseTarget;
 /** @type {string} */
Ext.resizer.ISplitter.prototype.collapsedCls;
 /** @type {boolean} */
Ext.resizer.ISplitter.prototype.collapsible;
 /** @type {number} */
Ext.resizer.ISplitter.prototype.defaultSplitMax;
 /** @type {number} */
Ext.resizer.ISplitter.prototype.defaultSplitMin;
 /** @type {boolean} */
Ext.resizer.ISplitter.prototype.performCollapse;
 /** @type {?} */
Ext.resizer.ISplitter.prototype.renderTpl;
 /** @type {number} */
Ext.resizer.ISplitter.prototype.size;
 /** @type {string} */
Ext.resizer.ISplitter.prototype.orientation;

/**
 * [Method] Invoked before the Component is destroyed
 * @return {void}
 */
Ext.resizer.ISplitter.prototype.beforeDestroy = function() {};

/**
 * [Method] Returns the config object with an xclass property for the splitter tracker
 * @return {void}
 */
Ext.resizer.ISplitter.prototype.getTrackerConfig = function() {};

/**
 * [Method] Template method called when this Component s DOM structure is created
 * @return {void}
 */
Ext.resizer.ISplitter.prototype.onRender = function() {};

/**
 * [Method] Work around IE bug
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.resizer.ISplitter.prototype.setSize = function() {};
/**
 * @extends {Ext.dd.IDragTracker}
 * @record
 * @struct
 */
Ext.resizer.ISplitterTracker = function() {};

/**
 * [Method] ensure the tracker is enabled store boxes of previous and next components and calculate the constrain region
 * @param {?=} e Object
 * @return {void}
 */
Ext.resizer.ISplitterTracker.prototype.onBeforeStart = function(e) {};

/**
 * [Method] Track the proxy and set the proper XY coordinates while constraining the drag
 * @param {?=} e Object
 * @return {void}
 */
Ext.resizer.ISplitterTracker.prototype.onDrag = function(e) {};

/**
 * [Method] perform the resize and remove the proxy class from the splitter el
 * @param {?=} e Object
 * @return {void}
 */
Ext.resizer.ISplitterTracker.prototype.onEnd = function(e) {};

/**
 * [Method] We move the splitter el
 * @param {?=} e Object
 * @return {void}
 */
Ext.resizer.ISplitterTracker.prototype.onStart = function(e) {};
/** @const */
Ext.selection = {};
/**
 * @extends {Ext.selection.IModel}
 * @record
 * @struct
 */
Ext.selection.ICellModel = function() {};
 /** @type {boolean} */
Ext.selection.ICellModel.prototype.enableKeyNav;
 /** @type {string} */
Ext.selection.ICellModel.prototype.mode;
 /** @type {boolean} */
Ext.selection.ICellModel.prototype.preventWrap;

/**
 * [Method] Deselects a record instance by record instance or index
 * @param {?=} record Object
 * @param {?=} suppressEvent Object
 * @return {void}
 */
Ext.selection.ICellModel.prototype.deselect = function(record, suppressEvent) {};

/**
 * [Method] Returns the current position in the format row row column column
 * @return {void}
 */
Ext.selection.ICellModel.prototype.getCurrentPosition = function() {};

/**
 * [Method] Selects a record instance by record instance or index
 * @param {?=} pos Object
 * @param {?=} keepExisting Object
 * @param {?=} suppressEvent Object
 * @return {void}
 */
Ext.selection.ICellModel.prototype.select = function(pos, keepExisting, suppressEvent) {};

/**
 * [Method] Sets the current position
 * @param {?=} position Object The position to set.
 * @param {boolean=} suppressEvent Boolean True to suppress selection events
 * @return {void}
 */
Ext.selection.ICellModel.prototype.setCurrentPosition = function(position, suppressEvent) {};
/**
 * @extends {Ext.selection.IRowModel}
 * @record
 * @struct
 */
Ext.selection.ICheckboxModel = function() {};
 /** @type {boolean} */
Ext.selection.ICheckboxModel.prototype.checkOnly;
 /** @type {string} */
Ext.selection.ICheckboxModel.prototype.checkSelector;
 /** @type {?} */
Ext.selection.ICheckboxModel.prototype.injectCheckbox;
 /** @type {?} */
Ext.selection.ICheckboxModel.prototype.mode;
 /** @type {boolean} */
Ext.selection.ICheckboxModel.prototype.showHeaderCheckbox;

/**
 * [Method] Retrieve a configuration to be used in a HeaderContainer
 * @return {void}
 */
Ext.selection.ICheckboxModel.prototype.getHeaderConfig = function() {};

/**
 * [Method] Toggle between selecting all and deselecting all when clicking on a checkbox header
 * @param {?=} headerCt Object
 * @param {?=} header Object
 * @param {?=} e Object
 * @return {void}
 */
Ext.selection.ICheckboxModel.prototype.onHeaderClick = function(headerCt, header, e) {};

/**
 * [Method] Generates the HTML to be rendered in the injected checkbox column for each row
 * @param {?=} value Object
 * @param {?=} metaData Object
 * @param {?=} record Object
 * @param {?=} rowIndex Object
 * @param {?=} colIndex Object
 * @param {?=} store Object
 * @param {?=} view Object
 * @return {void}
 */
Ext.selection.ICheckboxModel.prototype.renderer = function(value, metaData, record, rowIndex, colIndex, store, view) {};
/**
 * @extends {Ext.selection.IModel}
 * @record
 * @struct
 */
Ext.selection.IDataViewModel = function() {};
 /** @type {boolean} */
Ext.selection.IDataViewModel.prototype.enableKeyNav;
/**
 * @extends {Ext.util.IObservable}
 * @extends {Ext.util.IBindable}
 * @record
 * @struct
 */
Ext.selection.IModel = function() {};
 /** @type {boolean} */
Ext.selection.IModel.prototype.allowDeselect;
 /** @type {?} */
Ext.selection.IModel.prototype.mode;
 /** @type {boolean} */
Ext.selection.IModel.prototype.pruneRemoved;
 /** @type {boolean} */
Ext.selection.IModel.prototype.toggleOnClick;
 /** @type {!Ext.util.IMixedCollection} */
Ext.selection.IModel.prototype.selected;

/**
 * [Method] binds the store to the selModel
 * @param {?=} store Object
 * @param {?=} initial Object
 * @return {void}
 */
Ext.selection.IModel.prototype.bindStore = function(store, initial) {};

/**
 * [Method] Binds listeners for this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to bind to
 * @return {void}
 */
Ext.selection.IModel.prototype.bindStoreListeners = function(store) {};

/**
 * [Method] Deselects a record instance by record instance or index
 * @param {?=} records Ext.data.Model[]/Number An array of records or an index
 * @param {boolean=} suppressEvent Boolean True to not fire a deselect event
 * @return {void}
 */
Ext.selection.IModel.prototype.deselect = function(records, suppressEvent) {};

/**
 * [Method] Deselects all records in the view
 * @param {boolean=} suppressEvent Boolean True to suppress any deselect events
 * @return {void}
 */
Ext.selection.IModel.prototype.deselectAll = function(suppressEvent) {};

/**
 * [Method] Deselects a range of rows if the selection model is not locked
 * @param {?=} startRow Ext.data.Model/Number The record or index of the first row in the range
 * @param {?=} endRow Ext.data.Model/Number The record or index of the last row in the range
 * @return {void}
 */
Ext.selection.IModel.prototype.deselectRange = function(startRow, endRow) {};

/**
 * [Method] Returns the count of selected records
 * @return {number} Number The number of selected records
 */
Ext.selection.IModel.prototype.getCount = function() {};

/**
 * [Method]
 * @return {!Ext.data.IModel} Ext.data.Model Returns the last selected record.
 */
Ext.selection.IModel.prototype.getLastSelected = function() {};

/**
 * [Method] Returns an array of the currently selected records
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] The selected records
 */
Ext.selection.IModel.prototype.getSelection = function() {};

/**
 * [Method] Returns the current selectionMode
 * @return {string} String The selectionMode: 'SINGLE', 'MULTI' or 'SIMPLE'.
 */
Ext.selection.IModel.prototype.getSelectionMode = function() {};

/**
 * [Method] Gets the current store instance
 * @return {!Ext.data.IAbstractStore} Ext.data.AbstractStore The store, null if one does not exist.
 */
Ext.selection.IModel.prototype.getStore = function() {};

/**
 * [Method] Gets the listeners to bind to a new store
 * @return {?} Object The listeners to be bound to the store in object literal form. The scope may be omitted, it is assumed to be the current instance.
 */
Ext.selection.IModel.prototype.getStoreListeners = function() {};

/**
 * [Method] Returns true if there are any a selected records
 * @return {boolean} Boolean
 */
Ext.selection.IModel.prototype.hasSelection = function() {};

/**
 * [Method] Determines if this record is currently focused
 * @param {!Ext.data.IModel=} record Ext.data.Model
 * @return {void}
 */
Ext.selection.IModel.prototype.isFocused = function(record) {};

/**
 * [Method] Returns true if the selections are locked
 * @return {boolean} Boolean
 */
Ext.selection.IModel.prototype.isLocked = function() {};

/**
 * [Method] Returns true if the specified row is selected
 * @param {?=} from Ext.data.Model/Number The start of the range to check.
 * @param {?=} to Ext.data.Model/Number The end of the range to check.
 * @return {boolean} Boolean
 */
Ext.selection.IModel.prototype.isRangeSelected = function(from, to) {};

/**
 * [Method] Returns true if the specified row is selected
 * @param {?=} record Ext.data.Model/Number The record or index of the record to check
 * @return {boolean} Boolean
 */
Ext.selection.IModel.prototype.isSelected = function(record) {};

/**
 * [Method] Template method it is called when a new store is bound to the current instance
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store being bound
 * @param {boolean=} initial Boolean True if this store is being bound as initialization of the instance.
 * @return {void}
 */
Ext.selection.IModel.prototype.onBindStore = function(store, initial) {};

/**
 * [Method] Template method it is called when an existing store is unbound from the current instance
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store being unbound
 * @param {boolean=} initial Boolean True if this store is being bound as initialization of the instance.
 * @return {void}
 */
Ext.selection.IModel.prototype.onUnbindStore = function(store, initial) {};

/**
 * [Method] Selects a record instance by record instance or index
 * @param {?=} records Ext.data.Model[]/Number An array of records or an index
 * @param {boolean=} keepExisting Boolean True to retain existing selections
 * @param {boolean=} suppressEvent Boolean True to not fire a select event
 * @return {void}
 */
Ext.selection.IModel.prototype.select = function(records, keepExisting, suppressEvent) {};

/**
 * [Method] Selects all records in the view
 * @param {boolean=} suppressEvent Boolean True to suppress any select events
 * @return {void}
 */
Ext.selection.IModel.prototype.selectAll = function(suppressEvent) {};

/**
 * [Method] Selects a range of rows if the selection model is not locked
 * @param {?=} startRow Ext.data.Model/Number The record or index of the first row in the range
 * @param {?=} endRow Ext.data.Model/Number The record or index of the last row in the range
 * @param {boolean=} keepExisting Boolean True to retain existing selections
 * @return {void}
 */
Ext.selection.IModel.prototype.selectRange = function(startRow, endRow, keepExisting) {};

/**
 * [Method] Sets a record as the last focused record
 * @param {!Ext.data.IModel=} record Ext.data.Model
 * @return {void}
 */
Ext.selection.IModel.prototype.setLastFocused = function(record) {};

/**
 * [Method] Locks the current selection and disables any changes from happening to the selection
 * @param {boolean=} locked Boolean True to lock, false to unlock.
 * @return {void}
 */
Ext.selection.IModel.prototype.setLocked = function(locked) {};

/**
 * [Method] Sets the current selectionMode
 * @param {string=} selMode String 'SINGLE', 'MULTI' or 'SIMPLE'.
 * @return {void}
 */
Ext.selection.IModel.prototype.setSelectionMode = function(selMode) {};

/**
 * [Method] Unbinds listeners from this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to unbind from
 * @return {void}
 */
Ext.selection.IModel.prototype.unbindStoreListeners = function(store) {};
/**
 * @extends {Ext.util.IObservable}
 * @extends {Ext.util.IBindable}
 * @record
 * @struct
 */
Ext.IAbstractSelectionModel = function() {};
 /** @type {boolean} */
Ext.IAbstractSelectionModel.prototype.allowDeselect;
 /** @type {?} */
Ext.IAbstractSelectionModel.prototype.mode;
 /** @type {boolean} */
Ext.IAbstractSelectionModel.prototype.pruneRemoved;
 /** @type {boolean} */
Ext.IAbstractSelectionModel.prototype.toggleOnClick;
 /** @type {!Ext.util.IMixedCollection} */
Ext.IAbstractSelectionModel.prototype.selected;

/**
 * [Method] binds the store to the selModel
 * @param {?=} store Object
 * @param {?=} initial Object
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.bindStore = function(store, initial) {};

/**
 * [Method] Binds listeners for this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to bind to
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.bindStoreListeners = function(store) {};

/**
 * [Method] Deselects a record instance by record instance or index
 * @param {?=} records Ext.data.Model[]/Number An array of records or an index
 * @param {boolean=} suppressEvent Boolean True to not fire a deselect event
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.deselect = function(records, suppressEvent) {};

/**
 * [Method] Deselects all records in the view
 * @param {boolean=} suppressEvent Boolean True to suppress any deselect events
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.deselectAll = function(suppressEvent) {};

/**
 * [Method] Deselects a range of rows if the selection model is not locked
 * @param {?=} startRow Ext.data.Model/Number The record or index of the first row in the range
 * @param {?=} endRow Ext.data.Model/Number The record or index of the last row in the range
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.deselectRange = function(startRow, endRow) {};

/**
 * [Method] Returns the count of selected records
 * @return {number} Number The number of selected records
 */
Ext.IAbstractSelectionModel.prototype.getCount = function() {};

/**
 * [Method]
 * @return {!Ext.data.IModel} Ext.data.Model Returns the last selected record.
 */
Ext.IAbstractSelectionModel.prototype.getLastSelected = function() {};

/**
 * [Method] Returns an array of the currently selected records
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] The selected records
 */
Ext.IAbstractSelectionModel.prototype.getSelection = function() {};

/**
 * [Method] Returns the current selectionMode
 * @return {string} String The selectionMode: 'SINGLE', 'MULTI' or 'SIMPLE'.
 */
Ext.IAbstractSelectionModel.prototype.getSelectionMode = function() {};

/**
 * [Method] Gets the current store instance
 * @return {!Ext.data.IAbstractStore} Ext.data.AbstractStore The store, null if one does not exist.
 */
Ext.IAbstractSelectionModel.prototype.getStore = function() {};

/**
 * [Method] Gets the listeners to bind to a new store
 * @return {?} Object The listeners to be bound to the store in object literal form. The scope may be omitted, it is assumed to be the current instance.
 */
Ext.IAbstractSelectionModel.prototype.getStoreListeners = function() {};

/**
 * [Method] Returns true if there are any a selected records
 * @return {boolean} Boolean
 */
Ext.IAbstractSelectionModel.prototype.hasSelection = function() {};

/**
 * [Method] Determines if this record is currently focused
 * @param {!Ext.data.IModel=} record Ext.data.Model
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.isFocused = function(record) {};

/**
 * [Method] Returns true if the selections are locked
 * @return {boolean} Boolean
 */
Ext.IAbstractSelectionModel.prototype.isLocked = function() {};

/**
 * [Method] Returns true if the specified row is selected
 * @param {?=} from Ext.data.Model/Number The start of the range to check.
 * @param {?=} to Ext.data.Model/Number The end of the range to check.
 * @return {boolean} Boolean
 */
Ext.IAbstractSelectionModel.prototype.isRangeSelected = function(from, to) {};

/**
 * [Method] Returns true if the specified row is selected
 * @param {?=} record Ext.data.Model/Number The record or index of the record to check
 * @return {boolean} Boolean
 */
Ext.IAbstractSelectionModel.prototype.isSelected = function(record) {};

/**
 * [Method] Template method it is called when a new store is bound to the current instance
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store being bound
 * @param {boolean=} initial Boolean True if this store is being bound as initialization of the instance.
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.onBindStore = function(store, initial) {};

/**
 * [Method] Template method it is called when an existing store is unbound from the current instance
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store being unbound
 * @param {boolean=} initial Boolean True if this store is being bound as initialization of the instance.
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.onUnbindStore = function(store, initial) {};

/**
 * [Method] Selects a record instance by record instance or index
 * @param {?=} records Ext.data.Model[]/Number An array of records or an index
 * @param {boolean=} keepExisting Boolean True to retain existing selections
 * @param {boolean=} suppressEvent Boolean True to not fire a select event
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.select = function(records, keepExisting, suppressEvent) {};

/**
 * [Method] Selects all records in the view
 * @param {boolean=} suppressEvent Boolean True to suppress any select events
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.selectAll = function(suppressEvent) {};

/**
 * [Method] Selects a range of rows if the selection model is not locked
 * @param {?=} startRow Ext.data.Model/Number The record or index of the first row in the range
 * @param {?=} endRow Ext.data.Model/Number The record or index of the last row in the range
 * @param {boolean=} keepExisting Boolean True to retain existing selections
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.selectRange = function(startRow, endRow, keepExisting) {};

/**
 * [Method] Sets a record as the last focused record
 * @param {!Ext.data.IModel=} record Ext.data.Model
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.setLastFocused = function(record) {};

/**
 * [Method] Locks the current selection and disables any changes from happening to the selection
 * @param {boolean=} locked Boolean True to lock, false to unlock.
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.setLocked = function(locked) {};

/**
 * [Method] Sets the current selectionMode
 * @param {string=} selMode String 'SINGLE', 'MULTI' or 'SIMPLE'.
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.setSelectionMode = function(selMode) {};

/**
 * [Method] Unbinds listeners from this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to unbind from
 * @return {void}
 */
Ext.IAbstractSelectionModel.prototype.unbindStoreListeners = function(store) {};
/**
 * @extends {Ext.selection.IModel}
 * @record
 * @struct
 */
Ext.selection.IRowModel = function() {};
 /** @type {boolean} */
Ext.selection.IRowModel.prototype.enableKeyNav;
 /** @type {boolean} */
Ext.selection.IRowModel.prototype.ignoreRightMouseSelection;

/**
 * [Method] Returns position of the first selected cell in the selection in the format row row column column
 * @return {void}
 */
Ext.selection.IRowModel.prototype.getCurrentPosition = function() {};

/**
 * [Method] Selects the record immediately following the currently selected record
 * @param {boolean=} keepExisting Boolean True to retain existing selections
 * @param {boolean=} suppressEvent Boolean Set to false to not fire a select event
 * @return {boolean} Boolean true if there is a next record, else false
 */
Ext.selection.IRowModel.prototype.selectNext = function(keepExisting, suppressEvent) {};

/**
 * [Method] Selects the record that precedes the currently selected record
 * @param {boolean=} keepExisting Boolean True to retain existing selections
 * @param {boolean=} suppressEvent Boolean Set to false to not fire a select event
 * @return {boolean} Boolean true if there is a previous record, else false
 */
Ext.selection.IRowModel.prototype.selectPrevious = function(keepExisting, suppressEvent) {};
/**
 * @extends {Ext.selection.IRowModel}
 * @record
 * @struct
 */
Ext.selection.ITreeModel = function() {};

/**
 * [Method] binds the store to the selModel
 * @param {?=} store Object
 * @param {?=} initial Object
 * @return {void}
 */
Ext.selection.ITreeModel.prototype.bindStore = function(store, initial) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IShadow = function() {};
 /** @type {string} */
Ext.IShadow.prototype.mode;
 /** @type {number} */
Ext.IShadow.prototype.offset;

/**
 * [Method] Hides this shadow
 * @return {void}
 */
Ext.IShadow.prototype.hide = function() {};

/**
 * [Method] Returns true if the shadow is visible else false
 * @return {void}
 */
Ext.IShadow.prototype.isVisible = function() {};

/**
 * [Method] Direct alignment when values are already available
 * @param {number=} left Number The target element left position
 * @param {number=} top Number The target element top position
 * @param {number=} width Number The target element width
 * @param {number=} height Number The target element height
 * @return {void}
 */
Ext.IShadow.prototype.realign = function(left, top, width, height) {};

/**
 * [Method] Sets the opacity of the shadow
 * @param {number=} opacity Number The opacity
 * @return {void}
 */
Ext.IShadow.prototype.setOpacity = function(opacity) {};

/**
 * [Method] Adjust the z index of this shadow
 * @param {number=} zindex Number The new z-index
 * @return {void}
 */
Ext.IShadow.prototype.setZIndex = function(zindex) {};

/**
 * [Method] Displays the shadow under the target element
 * @param {?=} targetEl String/HTMLElement/Ext.Element The id or element under which the shadow should display
 * @return {void}
 */
Ext.IShadow.prototype.show = function(targetEl) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IShadowPool = function() {};
/**
 * @constructor
 * @struct
 */
Ext.ShadowPool = function() {};
 /** @type {!Ext.IClass} */
Ext.ShadowPool.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.ShadowPool.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.ShadowPool.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.ShadowPool.callSuper = function(args) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.ShadowPool.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.ShadowPool.initConfig = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.ShadowPool.statics = function() {};
/** @const */
Ext.slider = {};
/**
 * @extends {Ext.form.field.IBase}
 * @record
 * @struct
 */
Ext.slider.IMulti = function() {};
 /** @type {boolean} */
Ext.slider.IMulti.prototype.animate;
 /** @type {boolean} */
Ext.slider.IMulti.prototype.clickToChange;
 /** @type {?} */
Ext.slider.IMulti.prototype.componentLayout;
 /** @type {boolean} */
Ext.slider.IMulti.prototype.constrainThumbs;
 /** @type {?} */
Ext.slider.IMulti.prototype.decimalPrecision;
 /** @type {number} */
Ext.slider.IMulti.prototype.increment;
 /** @type {number} */
Ext.slider.IMulti.prototype.keyIncrement;
 /** @type {number} */
Ext.slider.IMulti.prototype.maxValue;
 /** @type {number} */
Ext.slider.IMulti.prototype.minValue;
 /** @type {?} */
Ext.slider.IMulti.prototype.tipText;
 /** @type {?} */
Ext.slider.IMulti.prototype.useTips;
 /** @type {number} */
Ext.slider.IMulti.prototype.value;
 /** @type {!Array<number>} */
Ext.slider.IMulti.prototype.values;
 /** @type {boolean} */
Ext.slider.IMulti.prototype.vertical;
 /** @type {boolean} */
Ext.slider.IMulti.prototype.zeroBasedSnapping;
 /** @type {boolean} */
Ext.slider.IMulti.prototype.dragging;
 /** @type {!Array<?>} */
Ext.slider.IMulti.prototype.thumbs;

/**
 * [Method] Creates a new thumb and adds it to the slider
 * @param {number=} value Number The initial value to set on the thumb.
 * @return {?} any The thumb
 */
Ext.slider.IMulti.prototype.addThumb = function(value) {};

/**
 * [Method] private
 * @return {void}
 */
Ext.slider.IMulti.prototype.beforeDestroy = function() {};

/**
 * [Method] private override
 * @return {?} any The template data
 */
Ext.slider.IMulti.prototype.getSubTplData = function() {};

/**
 * [Method] Returns the value that would be included in a standard form submit for this field
 * @return {?} any The value to be submitted, or null.
 */
Ext.slider.IMulti.prototype.getSubmitValue = function() {};

/**
 * [Method] Returns the current value of the slider
 * @param {number=} index Number The index of the thumb to return a value for
 * @return {?} any The current value of the slider at the given index, or an array of all thumb values if no index is given.
 */
Ext.slider.IMulti.prototype.getValue = function(index) {};

/**
 * [Method] Returns an array of values  one for the location of each thumb
 * @return {?} any The set of thumb values
 */
Ext.slider.IMulti.prototype.getValues = function() {};

/**
 * [Method] private override
 * @return {void}
 */
Ext.slider.IMulti.prototype.initComponent = function() {};

/**
 * [Method] private override
 * @return {void}
 */
Ext.slider.IMulti.prototype.initValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.slider.IMulti.prototype.onDisable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.slider.IMulti.prototype.onEnable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.slider.IMulti.prototype.onRender = function() {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.slider.IMulti.prototype.reset = function() {};

/**
 * [Method] Sets the maximum value for the slider instance
 * @param {number=} val Number The new maximum value
 * @return {void}
 */
Ext.slider.IMulti.prototype.setMaxValue = function(val) {};

/**
 * [Method] Sets the minimum value for the slider instance
 * @param {number=} val Number The new minimum value
 * @return {void}
 */
Ext.slider.IMulti.prototype.setMinValue = function(val) {};

/**
 * [Method] Sets the read only state of this field
 * @param {?=} readOnly Object
 * @return {void}
 */
Ext.slider.IMulti.prototype.setReadOnly = function(readOnly) {};

/**
 * [Method] Synchronizes thumbs position to the proper proportion of the total component width based on the current slider value
 * @return {void}
 */
Ext.slider.IMulti.prototype.syncThumbs = function() {};
/**
 * @extends {Ext.form.field.IBase}
 * @record
 * @struct
 */
Ext.slider.IMultiSlider = function() {};
 /** @type {boolean} */
Ext.slider.IMultiSlider.prototype.animate;
 /** @type {boolean} */
Ext.slider.IMultiSlider.prototype.clickToChange;
 /** @type {?} */
Ext.slider.IMultiSlider.prototype.componentLayout;
 /** @type {boolean} */
Ext.slider.IMultiSlider.prototype.constrainThumbs;
 /** @type {?} */
Ext.slider.IMultiSlider.prototype.decimalPrecision;
 /** @type {number} */
Ext.slider.IMultiSlider.prototype.increment;
 /** @type {number} */
Ext.slider.IMultiSlider.prototype.keyIncrement;
 /** @type {number} */
Ext.slider.IMultiSlider.prototype.maxValue;
 /** @type {number} */
Ext.slider.IMultiSlider.prototype.minValue;
 /** @type {?} */
Ext.slider.IMultiSlider.prototype.tipText;
 /** @type {?} */
Ext.slider.IMultiSlider.prototype.useTips;
 /** @type {number} */
Ext.slider.IMultiSlider.prototype.value;
 /** @type {!Array<number>} */
Ext.slider.IMultiSlider.prototype.values;
 /** @type {boolean} */
Ext.slider.IMultiSlider.prototype.vertical;
 /** @type {boolean} */
Ext.slider.IMultiSlider.prototype.zeroBasedSnapping;
 /** @type {boolean} */
Ext.slider.IMultiSlider.prototype.dragging;
 /** @type {!Array<?>} */
Ext.slider.IMultiSlider.prototype.thumbs;

/**
 * [Method] Creates a new thumb and adds it to the slider
 * @param {number=} value Number The initial value to set on the thumb.
 * @return {?} any The thumb
 */
Ext.slider.IMultiSlider.prototype.addThumb = function(value) {};

/**
 * [Method] private
 * @return {void}
 */
Ext.slider.IMultiSlider.prototype.beforeDestroy = function() {};

/**
 * [Method] private override
 * @return {?} any The template data
 */
Ext.slider.IMultiSlider.prototype.getSubTplData = function() {};

/**
 * [Method] Returns the value that would be included in a standard form submit for this field
 * @return {?} any The value to be submitted, or null.
 */
Ext.slider.IMultiSlider.prototype.getSubmitValue = function() {};

/**
 * [Method] Returns the current value of the slider
 * @param {number=} index Number The index of the thumb to return a value for
 * @return {?} any The current value of the slider at the given index, or an array of all thumb values if no index is given.
 */
Ext.slider.IMultiSlider.prototype.getValue = function(index) {};

/**
 * [Method] Returns an array of values  one for the location of each thumb
 * @return {?} any The set of thumb values
 */
Ext.slider.IMultiSlider.prototype.getValues = function() {};

/**
 * [Method] private override
 * @return {void}
 */
Ext.slider.IMultiSlider.prototype.initComponent = function() {};

/**
 * [Method] private override
 * @return {void}
 */
Ext.slider.IMultiSlider.prototype.initValue = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.slider.IMultiSlider.prototype.onDisable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.slider.IMultiSlider.prototype.onEnable = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.slider.IMultiSlider.prototype.onRender = function() {};

/**
 * [Method] Resets the current field value to the originally loaded value and clears any validation messages
 * @return {void}
 */
Ext.slider.IMultiSlider.prototype.reset = function() {};

/**
 * [Method] Sets the maximum value for the slider instance
 * @param {number=} val Number The new maximum value
 * @return {void}
 */
Ext.slider.IMultiSlider.prototype.setMaxValue = function(val) {};

/**
 * [Method] Sets the minimum value for the slider instance
 * @param {number=} val Number The new minimum value
 * @return {void}
 */
Ext.slider.IMultiSlider.prototype.setMinValue = function(val) {};

/**
 * [Method] Sets the read only state of this field
 * @param {?=} readOnly Object
 * @return {void}
 */
Ext.slider.IMultiSlider.prototype.setReadOnly = function(readOnly) {};

/**
 * [Method] Synchronizes thumbs position to the proper proportion of the total component width based on the current slider value
 * @return {void}
 */
Ext.slider.IMultiSlider.prototype.syncThumbs = function() {};
/**
 * @extends {Ext.slider.IMulti}
 * @record
 * @struct
 */
Ext.slider.ISingle = function() {};

/**
 * [Method] Returns the current value of the slider
 * @return {?} any The current value of the slider
 */
Ext.slider.ISingle.prototype.getValue = function() {};

/**
 * [Method] Programmatically sets the value of the Slider
 * @param {number=} value Number The value to set the slider to. (This will be constrained within minValue and maxValue)
 * @param {boolean=} animate Boolean Turn on or off animation
 * @return {void}
 */
Ext.slider.ISingle.prototype.setValue = function(value, animate) {};
/**
 * @extends {Ext.slider.IMulti}
 * @record
 * @struct
 */
Ext.ISlider = function() {};

/**
 * [Method] Returns the current value of the slider
 * @return {?} any The current value of the slider
 */
Ext.ISlider.prototype.getValue = function() {};

/**
 * [Method] Programmatically sets the value of the Slider
 * @param {number=} value Number The value to set the slider to. (This will be constrained within minValue and maxValue)
 * @param {boolean=} animate Boolean Turn on or off animation
 * @return {void}
 */
Ext.ISlider.prototype.setValue = function(value, animate) {};
/**
 * @extends {Ext.slider.IMulti}
 * @record
 * @struct
 */
Ext.form.ISliderField = function() {};

/**
 * [Method] Returns the current value of the slider
 * @return {?} any The current value of the slider
 */
Ext.form.ISliderField.prototype.getValue = function() {};

/**
 * [Method] Programmatically sets the value of the Slider
 * @param {number=} value Number The value to set the slider to. (This will be constrained within minValue and maxValue)
 * @param {boolean=} animate Boolean Turn on or off animation
 * @return {void}
 */
Ext.form.ISliderField.prototype.setValue = function(value, animate) {};
/**
 * @extends {Ext.slider.IMulti}
 * @record
 * @struct
 */
Ext.slider.ISingleSlider = function() {};

/**
 * [Method] Returns the current value of the slider
 * @return {?} any The current value of the slider
 */
Ext.slider.ISingleSlider.prototype.getValue = function() {};

/**
 * [Method] Programmatically sets the value of the Slider
 * @param {number=} value Number The value to set the slider to. (This will be constrained within minValue and maxValue)
 * @param {boolean=} animate Boolean Turn on or off animation
 * @return {void}
 */
Ext.slider.ISingleSlider.prototype.setValue = function(value, animate) {};
/**
 * @extends {Ext.slider.IMulti}
 * @record
 * @struct
 */
Ext.slider.ISlider = function() {};

/**
 * [Method] Returns the current value of the slider
 * @return {?} any The current value of the slider
 */
Ext.slider.ISlider.prototype.getValue = function() {};

/**
 * [Method] Programmatically sets the value of the Slider
 * @param {number=} value Number The value to set the slider to. (This will be constrained within minValue and maxValue)
 * @param {boolean=} animate Boolean Turn on or off animation
 * @return {void}
 */
Ext.slider.ISlider.prototype.setValue = function(value, animate) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.slider.IThumb = function() {};
 /** @type {boolean} */
Ext.slider.IThumb.prototype.constrain;
 /** @type {!Ext.slider.IMultiSlider} */
Ext.slider.IThumb.prototype.slider;

/**
 * [Method] Disables the thumb if it is currently enabled
 * @return {void}
 */
Ext.slider.IThumb.prototype.disable = function() {};

/**
 * [Method] Enables the thumb if it is currently disabled
 * @return {void}
 */
Ext.slider.IThumb.prototype.enable = function() {};

/**
 * [Method] Sets up an Ext dd DragTracker for this thumb
 * @return {void}
 */
Ext.slider.IThumb.prototype.initEvents = function() {};

/**
 * [Method] Renders the thumb into a slider
 * @return {void}
 */
Ext.slider.IThumb.prototype.render = function() {};
/**
 * @extends {Ext.tip.ITip}
 * @record
 * @struct
 */
Ext.slider.ITip = function() {};
 /** @type {string} */
Ext.slider.ITip.prototype.align;
 /** @type {number} */
Ext.slider.ITip.prototype.minWidth;
 /** @type {!Array<?>} */
Ext.slider.ITip.prototype.offsets;
 /** @type {string} */
Ext.slider.ITip.prototype.position;

/**
 * [Method] Used to create the text that appears in the Tip s body
 * @param {!Ext.slider.IThumb=} thumb Ext.slider.Thumb The Thumb that the Tip is attached to
 * @return {string} String The text to display in the tip
 */
Ext.slider.ITip.prototype.getText = function(thumb) {};
/** @const */
Ext.state = {};
/**
 * @extends {Ext.state.IProvider}
 * @record
 * @struct
 */
Ext.state.ICookieProvider = function() {};
 /** @type {string} */
Ext.state.ICookieProvider.prototype.domain;
 /** @type {?} */
Ext.state.ICookieProvider.prototype.expires;
 /** @type {string} */
Ext.state.ICookieProvider.prototype.path;
 /** @type {boolean} */
Ext.state.ICookieProvider.prototype.secure;

/**
 * [Method] private
 * @param {?=} name Object
 * @return {void}
 */
Ext.state.ICookieProvider.prototype.clear = function(name) {};

/**
 * [Method] private
 * @param {?=} name Object
 * @param {?=} value Object
 * @return {void}
 */
Ext.state.ICookieProvider.prototype.set = function(name, value) {};
/**
 * @extends {Ext.state.IProvider}
 * @record
 * @struct
 */
Ext.state.ILocalStorageProvider = function() {};

/**
 * [Method] private
 * @param {?=} name Object
 * @return {void}
 */
Ext.state.ILocalStorageProvider.prototype.clear = function(name) {};

/**
 * [Method] Sets the value for a key
 * @param {?=} name Object
 * @param {?=} value Object
 * @return {void}
 */
Ext.state.ILocalStorageProvider.prototype.set = function(name, value) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.state.IManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.state.Manager = function() {};
 /** @type {!Ext.IClass} */
Ext.state.Manager.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.state.Manager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.state.Manager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.state.Manager.callSuper = function(args) {};

/**
 * [Method] Clears a value from the state
 * @param {string=} name String The key name
 * @return {void}
 */
Ext.state.Manager.clear = function(name) {};

/**
 * [Method] Returns the current value for a key
 * @param {string=} name String The key name
 * @param {?=} defaultValue Object The default value to return if the key lookup does not match
 * @return {?} Object The state data
 */
Ext.state.Manager.get = function(name, defaultValue) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.state.Manager.getInitialConfig = function(name) {};

/**
 * [Method] Gets the currently configured state provider
 * @return {!Ext.state.IProvider} Ext.state.Provider The state provider
 */
Ext.state.Manager.getProvider = function() {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.state.Manager.initConfig = function(config) {};

/**
 * [Method] Sets the value for a key
 * @param {string=} name String The key name
 * @param {?=} value Object The state data
 * @return {void}
 */
Ext.state.Manager.set = function(name, value) {};

/**
 * [Method] Configures the default state provider for your application
 * @param {!Ext.state.IProvider=} stateProvider Ext.state.Provider The state provider to set
 * @return {void}
 */
Ext.state.Manager.setProvider = function(stateProvider) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.state.Manager.statics = function() {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.state.IProvider = function() {};
 /** @type {string} */
Ext.state.IProvider.prototype.prefix;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.state.IProvider.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.state.IProvider.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.state.IProvider.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Clears a value from the state
 * @param {string=} name String The key name
 * @return {void}
 */
Ext.state.IProvider.prototype.clear = function(name) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.state.IProvider.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.state.IProvider.prototype.clearManagedListeners = function() {};

/**
 * [Method] Decodes a string previously encoded with encodeValue
 * @param {string=} value String The value to decode
 * @return {?} Object The decoded value
 */
Ext.state.IProvider.prototype.decodeValue = function(value) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.state.IProvider.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Encodes a value including type information
 * @param {?=} value Object The value to encode
 * @return {string} String The encoded value
 */
Ext.state.IProvider.prototype.encodeValue = function(value) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.state.IProvider.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.state.IProvider.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the current value for a key
 * @param {string=} name String The key name
 * @param {?=} defaultValue Object A default value to return if the key's value is not found
 * @return {?} Object The state data
 */
Ext.state.IProvider.prototype.get = function(name, defaultValue) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.state.IProvider.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.state.IProvider.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.state.IProvider.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.state.IProvider.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.state.IProvider.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.state.IProvider.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.state.IProvider.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.state.IProvider.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.state.IProvider.prototype.resumeEvents = function() {};

/**
 * [Method] Sets the value for a key
 * @param {string=} name String The key name
 * @param {?=} value Object The value to set
 * @return {void}
 */
Ext.state.IProvider.prototype.set = function(name, value) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.state.IProvider.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.state.IProvider.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.state.IProvider.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.state.IStateful = function() {};
 /** @type {number} */
Ext.state.IStateful.prototype.saveDelay;
 /** @type {!Array<string>} */
Ext.state.IStateful.prototype.stateEvents;
 /** @type {string} */
Ext.state.IStateful.prototype.stateId;
 /** @type {boolean} */
Ext.state.IStateful.prototype.stateful;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.state.IStateful.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.state.IStateful.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.state.IStateful.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Add events that will trigger the state to be saved
 * @param {?=} events String/String[] The event name or an array of event names.
 * @return {void}
 */
Ext.state.IStateful.prototype.addStateEvents = function(events) {};

/**
 * [Method] Applies the state to the object
 * @param {?=} state Object The state
 * @return {void}
 */
Ext.state.IStateful.prototype.applyState = function(state) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.state.IStateful.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.state.IStateful.prototype.clearManagedListeners = function() {};

/**
 * [Method] Destroys this stateful object
 * @return {void}
 */
Ext.state.IStateful.prototype.destroy = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.state.IStateful.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.state.IStateful.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.state.IStateful.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Gets the current state of the object
 * @return {?} Object The current state
 */
Ext.state.IStateful.prototype.getState = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.state.IStateful.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.state.IStateful.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.state.IStateful.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.state.IStateful.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.state.IStateful.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.state.IStateful.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.state.IStateful.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.state.IStateful.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.state.IStateful.prototype.resumeEvents = function() {};

/**
 * [Method] Conditionally saves a single property from this object to the given state object
 * @param {string=} propName String The name of the property to save.
 * @param {?=} state Object The state object in to which to save the property.
 * @param {string=} stateName String The name to use for the property in state.
 * @return {boolean} Boolean True if the property was saved, false if not.
 */
Ext.state.IStateful.prototype.savePropToState = function(propName, state, stateName) {};

/**
 * [Method] Gathers additional named properties of the instance and adds their current values to the passed state object
 * @param {?=} propNames String/String[] The name (or array of names) of the property to save.
 * @param {?=} state Object The state object in to which to save the property values.
 * @return {?} Object state
 */
Ext.state.IStateful.prototype.savePropsToState = function(propNames, state) {};

/**
 * [Method] Saves the state of the object to the persistence store
 * @return {void}
 */
Ext.state.IStateful.prototype.saveState = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.state.IStateful.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.state.IStateful.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.state.IStateful.prototype.un = function(eventName, fn, scope) {};
/**
 * @record
 * @struct
 */
Ext.IString = function() {};
/**
 * @constructor
 * @struct
 */
Ext.String = function() {};

/**
 * [Method] Adds a set of character entity definitions to the set used by htmlEncode and htmlDecode
 * @param {?=} entities Object The set of character entities to add to the current definitions.
 * @return {void}
 */
Ext.String.addCharacterEntities = function(entities) {};

/**
 * [Method] Capitalize the given string
 * @param {string=} string String
 * @return {string} String
 */
Ext.String.capitalize = function(string) {};

/**
 * [Method] Converts a string of characters into a legal parse able JavaScript var name as long as the passed string contains at
 * @param {string=} s String A string to be converted into a var name.
 * @return {string} String A legal JavaScript var name.
 */
Ext.String.createVarName = function(s) {};

/**
 * [Method] Truncate a string and add an ellipsis  to the end if it exceeds the specified length
 * @param {string=} value String The string to truncate.
 * @param {number=} length Number The maximum length to allow before truncating.
 * @param {boolean=} word Boolean true to try to find a common word break.
 * @return {string} String The converted text.
 */
Ext.String.ellipsis = function(value, length, word) {};

/**
 * [Method] Checks if a string ends with a substring
 * @param {string=} s String The original string
 * @param {string=} start String The substring to check
 * @param {boolean=} ignoreCase Boolean True to ignore the case in the comparison
 * @return {void}
 */
Ext.String.endsWith = function(s, start, ignoreCase) {};

/**
 * [Method] Escapes the passed string for  and
 * @param {string=} string String The string to escape
 * @return {string} String The escaped string
 */
Ext.String.escape = function(string) {};

/**
 * [Method] Escapes the passed string for use in a regular expression
 * @param {string=} string String
 * @return {string} String
 */
Ext.String.escapeRegex = function(string) {};

/**
 * [Method] Allows you to define a tokenized string and pass an arbitrary number of arguments to replace the tokens
 * @param {string} string String The tokenized string to be formatted.
 * @param {...?} values Mixed... The values to replace tokens {0}, {1}, etc in order.
 * @return {string} String The formatted string.
 */
Ext.String.format = function(string, values) {};

/**
 * [Method] Convert certain characters  amp lt  and from their HTML character equivalents
 * @param {string=} value String The string to decode.
 * @return {string} String The decoded text.
 */
Ext.String.htmlDecode = function(value) {};

/**
 * [Method] Convert certain characters  amp lt  and to their HTML character equivalents for literal display in web
 * @param {string=} value String The string to encode.
 * @return {string} String The encoded text.
 */
Ext.String.htmlEncode = function(value) {};

/**
 * [Method] Inserts a substring into a string
 * @param {string=} s String The original string.
 * @param {string=} value String The substring to insert.
 * @param {number=} index Number The index to insert the substring. Negative indexes will insert from the end of the string. Example: Ext.String.insert("abcdefg", "h", -1); // abcdefhg
 * @return {string} String The value with the inserted substring
 */
Ext.String.insert = function(s, value, index) {};

/**
 * [Method] Pads the left side of a string with a specified character
 * @param {string=} string String The original string.
 * @param {number=} size Number The total length of the output string.
 * @param {string=} character String The character with which to pad the original string.
 * @return {string} String The padded string.
 */
Ext.String.leftPad = function(string, size, character) {};

/**
 * [Method] Returns a string with a specified number of repetitions a given string pattern
 * @param {string=} pattern String The pattern to repeat.
 * @param {number=} count Number The number of times to repeat the pattern (may be 0).
 * @param {string=} sep String An option string to separate each pattern.
 * @return {void}
 */
Ext.String.repeat = function(pattern, count, sep) {};

/**
 * [Method] Resets the set of character entity definitions used by htmlEncode and htmlDecode back to the default state
 * @return {void}
 */
Ext.String.resetCharacterEntities = function() {};

/**
 * [Method] Splits a string of space separated words into an array trimming as needed
 * @param {?=} words String/Array
 * @return {void}
 */
Ext.String.splitWords = function(words) {};

/**
 * [Method] Checks if a string starts with a substring
 * @param {string=} s String The original string
 * @param {string=} start String The substring to check
 * @param {boolean=} ignoreCase Boolean True to ignore the case in the comparison
 * @return {void}
 */
Ext.String.startsWith = function(s, start, ignoreCase) {};

/**
 * [Method] Utility function that allows you to easily switch a string between two alternating values
 * @param {string=} string String The current string.
 * @param {string=} value String The value to compare to the current string.
 * @param {string=} other String The new value to use if the string already equals the first value passed in.
 * @return {string} String The new value.
 */
Ext.String.toggle = function(string, value, other) {};

/**
 * [Method] Trims whitespace from either end of a string leaving spaces within the string intact
 * @param {string=} string String The string to trim.
 * @return {string} String The trimmed string.
 */
Ext.String.trim = function(string) {};

/**
 * [Method] Uncapitalize the given string
 * @param {string=} string String
 * @return {string} String
 */
Ext.String.uncapitalize = function(string) {};

/**
 * [Method] Appends content to the query string of a URL handling logic for whether to place a question mark or ampersand
 * @param {string=} url String The URL to append to.
 * @param {string=} string String The content to append to the URL.
 * @return {string} String The resulting URL
 */
Ext.String.urlAppend = function(url, string) {};
/**
 * @record
 * @struct
 */
Ext.ISupports = function() {};
/**
 * @constructor
 * @struct
 */
Ext.Supports = function() {};
 /** @type {boolean} */
Ext.Supports.ArraySort;
 /** @type {boolean} */
Ext.Supports.AudioTag;
 /** @type {boolean} */
Ext.Supports.BoundingClientRect;
 /** @type {boolean} */
Ext.Supports.CSS3BorderRadius;
 /** @type {boolean} */
Ext.Supports.CSS3BoxShadow;
 /** @type {boolean} */
Ext.Supports.CSS3DTransform;
 /** @type {boolean} */
Ext.Supports.CSS3LinearGradient;
 /** @type {boolean} */
Ext.Supports.Canvas;
 /** @type {boolean} */
Ext.Supports.ClassList;
 /** @type {boolean} */
Ext.Supports.ComputedStyle;
 /** @type {boolean} */
Ext.Supports.CreateContextualFragment;
 /** @type {boolean} */
Ext.Supports.DeviceMotion;
 /** @type {boolean} */
Ext.Supports.Direct2DBug;
 /** @type {?} */
Ext.Supports.DisplayChangeInputSelectionBug;
 /** @type {?} */
Ext.Supports.DisplayChangeTextAreaSelectionBug;
 /** @type {boolean} */
Ext.Supports.Float;
 /** @type {boolean} */
Ext.Supports.GeoLocation;
 /** @type {boolean} */
Ext.Supports.GetPositionPercentage;
 /** @type {boolean} */
Ext.Supports.History;
 /** @type {?} */
Ext.Supports.LocalStorage;
 /** @type {boolean} */
Ext.Supports.MouseEnterLeave;
 /** @type {boolean} */
Ext.Supports.MouseWheel;
 /** @type {boolean} */
Ext.Supports.Opacity;
 /** @type {boolean} */
Ext.Supports.OrientationChange;
 /** @type {boolean} */
Ext.Supports.Placeholder;
 /** @type {boolean} */
Ext.Supports.PointerEvents;
 /** @type {boolean} */
Ext.Supports.Range;
 /** @type {boolean} */
Ext.Supports.RightMargin;
 /** @type {boolean} */
Ext.Supports.RotatedBoundingClientRect;
 /** @type {boolean} */
Ext.Supports.ScrollWidthInlinePaddingBug;
 /** @type {boolean} */
Ext.Supports.Svg;
 /** @type {boolean} */
Ext.Supports.TextAreaMaxLength;
 /** @type {boolean} */
Ext.Supports.TimeoutActualLateness;
 /** @type {boolean} */
Ext.Supports.Touch;
 /** @type {boolean} */
Ext.Supports.Transitions;
 /** @type {boolean} */
Ext.Supports.TransparentColor;
 /** @type {boolean} */
Ext.Supports.Vml;
 /** @type {boolean} */
Ext.Supports.WindowOnError;
/** @const */
Ext.tab = {};
/**
 * @extends {Ext.panel.IHeader}
 * @record
 * @struct
 */
Ext.tab.IBar = function() {};
 /** @type {string} */
Ext.tab.IBar.prototype.baseCls;
 /** @type {number} */
Ext.tab.IBar.prototype.maxTabWidth;
 /** @type {number} */
Ext.tab.IBar.prototype.minTabWidth;
 /** @type {boolean} */
Ext.tab.IBar.prototype.plain;
 /** @type {boolean} */
Ext.tab.IBar.prototype.isTabBar;

/**
 * [Method] Called by the layout system after the Component has been laid out
 * @param {?=} width Object
 * @return {void}
 */
Ext.tab.IBar.prototype.afterComponentLayout = function(width) {};

/**
 * [Method] Invoked after the Container has laid out and rendered if necessary its child Components
 * @return {void}
 */
Ext.tab.IBar.prototype.afterLayout = function() {};

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.tab.IBar.prototype.afterRender = function() {};

/**
 * [Method] Returns the layout instance currently associated with this Container
 * @return {!Ext.layout.container.IContainer} Ext.layout.container.Container The layout
 */
Ext.tab.IBar.prototype.getLayout = function() {};

/**
 * [Method] This method is invoked after a new Component has been removed
 * @param {?=} tab Object
 * @return {void}
 */
Ext.tab.IBar.prototype.onRemove = function(tab) {};

/**
 * [Method] Template method called when this Component s DOM structure is created
 * @return {void}
 */
Ext.tab.IBar.prototype.onRender = function() {};
/**
 * @extends {Ext.panel.IPanel}
 * @record
 * @struct
 */
Ext.tab.IPanel = function() {};
 /** @type {?} */
Ext.tab.IPanel.prototype.activeItem;
 /** @type {?} */
Ext.tab.IPanel.prototype.activeTab;
 /** @type {boolean} */
Ext.tab.IPanel.prototype.deferredRender;
 /** @type {string} */
Ext.tab.IPanel.prototype.itemCls;
 /** @type {?} */
Ext.tab.IPanel.prototype.layout;
 /** @type {number} */
Ext.tab.IPanel.prototype.maxTabWidth;
 /** @type {number} */
Ext.tab.IPanel.prototype.minTabWidth;
 /** @type {boolean} */
Ext.tab.IPanel.prototype.plain;
 /** @type {boolean} */
Ext.tab.IPanel.prototype.removePanelHeader;
 /** @type {?} */
Ext.tab.IPanel.prototype.tabBar;
 /** @type {?} */
Ext.tab.IPanel.prototype.tabPosition;

/**
 * [Method] Returns the item that is currently active inside this TabPanel
 * @return {!Ext.IComponent} Ext.Component The currently active item.
 */
Ext.tab.IPanel.prototype.getActiveTab = function() {};

/**
 * [Method] Returns the Ext tab Bar currently used in this TabPanel
 * @return {!Ext.tab.IBar} Ext.tab.Bar The TabBar
 */
Ext.tab.IPanel.prototype.getTabBar = function() {};

/**
 * [Method] Makes sure we have a Tab for each item added to the TabPanel
 * @param {?=} item Object
 * @param {?=} index Object
 * @return {void}
 */
Ext.tab.IPanel.prototype.onAdd = function(item, index) {};

/**
 * [Method] Makes the given card active
 * @param {?=} card String/Number/Ext.Component The card to make active. Either an ID, index or the component itself.
 * @return {!Ext.IComponent} Ext.Component The resulting active child Component. The call may have been vetoed, or otherwise modified by an event listener.
 */
Ext.tab.IPanel.prototype.setActiveTab = function(card) {};
/**
 * @extends {Ext.panel.IPanel}
 * @record
 * @struct
 */
Ext.ITabPanel = function() {};
 /** @type {?} */
Ext.ITabPanel.prototype.activeItem;
 /** @type {?} */
Ext.ITabPanel.prototype.activeTab;
 /** @type {boolean} */
Ext.ITabPanel.prototype.deferredRender;
 /** @type {string} */
Ext.ITabPanel.prototype.itemCls;
 /** @type {?} */
Ext.ITabPanel.prototype.layout;
 /** @type {number} */
Ext.ITabPanel.prototype.maxTabWidth;
 /** @type {number} */
Ext.ITabPanel.prototype.minTabWidth;
 /** @type {boolean} */
Ext.ITabPanel.prototype.plain;
 /** @type {boolean} */
Ext.ITabPanel.prototype.removePanelHeader;
 /** @type {?} */
Ext.ITabPanel.prototype.tabBar;
 /** @type {?} */
Ext.ITabPanel.prototype.tabPosition;

/**
 * [Method] Returns the item that is currently active inside this TabPanel
 * @return {!Ext.IComponent} Ext.Component The currently active item.
 */
Ext.ITabPanel.prototype.getActiveTab = function() {};

/**
 * [Method] Returns the Ext tab Bar currently used in this TabPanel
 * @return {!Ext.tab.IBar} Ext.tab.Bar The TabBar
 */
Ext.ITabPanel.prototype.getTabBar = function() {};

/**
 * [Method] Makes sure we have a Tab for each item added to the TabPanel
 * @param {?=} item Object
 * @param {?=} index Object
 * @return {void}
 */
Ext.ITabPanel.prototype.onAdd = function(item, index) {};

/**
 * [Method] Makes the given card active
 * @param {?=} card String/Number/Ext.Component The card to make active. Either an ID, index or the component itself.
 * @return {!Ext.IComponent} Ext.Component The resulting active child Component. The call may have been vetoed, or otherwise modified by an event listener.
 */
Ext.ITabPanel.prototype.setActiveTab = function(card) {};
/**
 * @extends {Ext.button.IButton}
 * @record
 * @struct
 */
Ext.tab.ITab = function() {};
 /** @type {string} */
Ext.tab.ITab.prototype.activeCls;
 /** @type {string} */
Ext.tab.ITab.prototype.baseCls;
 /** @type {boolean} */
Ext.tab.ITab.prototype.closable;
 /** @type {string} */
Ext.tab.ITab.prototype.closableCls;
 /** @type {string} */
Ext.tab.ITab.prototype.closeText;
 /** @type {string} */
Ext.tab.ITab.prototype.disabledCls;
 /** @type {?} */
Ext.tab.ITab.prototype.scale;
 /** @type {boolean} */
Ext.tab.ITab.prototype.active;
 /** @type {boolean} */
Ext.tab.ITab.prototype.isTab;

/**
 * [Method] inherit docs
 * @param {?=} silent Object
 * @return {void}
 */
Ext.tab.ITab.prototype.disable = function(silent) {};

/**
 * [Method] inherit docs
 * @param {?=} silent Object
 * @return {void}
 */
Ext.tab.ITab.prototype.enable = function(silent) {};

/**
 * [Method] This method returns an object which provides substitution parameters for the XTemplate used to create this Button s D
 * @return {?} Object Substitution data for a Template. The default implementation which provides data for the default template returns an Object containing the following properties:
 */
Ext.tab.ITab.prototype.getTemplateArgs = function() {};

/**
 * [Method] inherit docs
 * @return {void}
 */
Ext.tab.ITab.prototype.initComponent = function() {};

/**
 * [Method] Sets this tab s attached card
 * @param {!Ext.IComponent=} card Ext.Component The card to set
 * @return {void}
 */
Ext.tab.ITab.prototype.setCard = function(card) {};

/**
 * [Method] Sets the tab as either closable or not
 * @param {boolean=} closable Boolean Pass false to make the tab not closable. Otherwise the tab will be made closable (eg a close button will appear on the tab)
 * @return {void}
 */
Ext.tab.ITab.prototype.setClosable = function(closable) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.ITemplate = function() {};
 /** @type {boolean} */
Ext.ITemplate.prototype.compiled;
 /** @type {boolean} */
Ext.ITemplate.prototype.disableFormats;
 /** @type {boolean} */
Ext.ITemplate.prototype.isTemplate;

/**
 * [Method] Applies the supplied values to the template and appends the new node s to the specified el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} values Object/Array The template values. See applyTemplate for details.
 * @param {boolean=} returnElement Boolean true to return an Ext.Element.
 * @return {?} HTMLElement/Ext.Element The new node or Element
 */
Ext.ITemplate.prototype.append = function(el, values, returnElement) {};

/**
 * [Method] Returns an HTML fragment of this template with the specified values applied
 * @param {?=} values Object/Array The template values. Can be an array if your params are numeric:  var tpl = new Ext.Template('Name: {0}, Age: {1}'); tpl.apply(['John', 25]); or an object:  var tpl = new Ext.Template('Name: {name}, Age: {age}'); tpl.apply({name: 'John', age: 25});
 * @return {string} String The HTML fragment
 */
Ext.ITemplate.prototype.apply = function(values) {};

/**
 * [Method] Appends the result of this template to the provided output array
 * @param {?=} values Object/Array The template values. See apply.
 * @param {!Array<?>=} out Array The array to which output is pushed.
 * @return {!Array<?>} Array The given out array.
 */
Ext.ITemplate.prototype.applyOut = function(values, out) {};

/**
 * [Method] Alias for apply
 * @param {?=} values Object/Array The template values. Can be an array if your params are numeric:  var tpl = new Ext.Template('Name: {0}, Age: {1}'); tpl.apply(['John', 25]); or an object:  var tpl = new Ext.Template('Name: {name}, Age: {age}'); tpl.apply({name: 'John', age: 25});
 * @return {string} String The HTML fragment
 */
Ext.ITemplate.prototype.applyTemplate = function(values) {};

/**
 * [Method] Compiles the template into an internal function eliminating the RegEx overhead
 * @return {!Ext.ITemplate} Ext.Template this
 */
Ext.ITemplate.prototype.compile = function() {};

/**
 * [Method] Applies the supplied values to the template and inserts the new node s after el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} values Object/Array The template values. See applyTemplate for details.
 * @param {boolean=} returnElement Boolean true to return a Ext.Element.
 * @return {?} HTMLElement/Ext.Element The new node or Element
 */
Ext.ITemplate.prototype.insertAfter = function(el, values, returnElement) {};

/**
 * [Method] Applies the supplied values to the template and inserts the new node s before el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} values Object/Array The template values. See applyTemplate for details.
 * @param {boolean=} returnElement Boolean true to return a Ext.Element.
 * @return {?} HTMLElement/Ext.Element The new node or Element
 */
Ext.ITemplate.prototype.insertBefore = function(el, values, returnElement) {};

/**
 * [Method] Applies the supplied values to the template and inserts the new node s as the first child of el
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} values Object/Array The template values. See applyTemplate for details.
 * @param {boolean=} returnElement Boolean true to return a Ext.Element.
 * @return {?} HTMLElement/Ext.Element The new node or Element
 */
Ext.ITemplate.prototype.insertFirst = function(el, values, returnElement) {};

/**
 * [Method] Applies the supplied values to the template and overwrites the content of el with the new node s
 * @param {?=} el String/HTMLElement/Ext.Element The context element
 * @param {?=} values Object/Array The template values. See applyTemplate for details.
 * @param {boolean=} returnElement Boolean true to return a Ext.Element.
 * @return {?} HTMLElement/Ext.Element The new node or Element
 */
Ext.ITemplate.prototype.overwrite = function(el, values, returnElement) {};

/**
 * [Method] Sets the HTML used as the template and optionally compiles it
 * @param {string=} html String
 * @param {boolean=} compile Boolean True to compile the template.
 * @return {!Ext.ITemplate} Ext.Template this
 */
Ext.ITemplate.prototype.set = function(html, compile) {};
/**
 * @constructor
 * @struct
 */
Ext.Template = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.Template.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.Template.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.Template.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.Template.createAlias = function(alias, origin) {};

/**
 * [Method] Creates a template from the passed element s value display none textarea preferred or innerHTML
 * @param {?=} el String/HTMLElement A DOM element or its id
 * @param {?=} config Object Config object
 * @return {!Ext.ITemplate} Ext.Template The created template
 */
Ext.Template.from = function(el, config) {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.Template.getName = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.Template.implement = function() {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.Template.override = function(members) {};
/** @const */
Ext.tip = {};
/**
 * @extends {Ext.tip.IToolTip}
 * @record
 * @struct
 */
Ext.tip.IQuickTip = function() {};
 /** @type {boolean} */
Ext.tip.IQuickTip.prototype.interceptTitles;
 /** @type {?} */
Ext.tip.IQuickTip.prototype.target;
 /** @type {string} */
Ext.tip.IQuickTip.prototype.title;

/**
 * [Method] Hides a visible tip or cancels an impending show for a particular element
 * @param {?=} el String/HTMLElement/Ext.Element The element that is the target of the tip or ID of the element.
 * @return {void}
 */
Ext.tip.IQuickTip.prototype.cancelShow = function(el) {};

/**
 * [Method] Configures a new quick tip instance and assigns it to a target element
 * @param {?=} config Object The config object with the following properties:
 * @return {void}
 */
Ext.tip.IQuickTip.prototype.register = function(config) {};

/**
 * [Method] Removes this quick tip from its element and destroys it
 * @param {?=} el String/HTMLElement/Ext.Element The element from which the quick tip is to be removed or ID of the element.
 * @return {void}
 */
Ext.tip.IQuickTip.prototype.unregister = function(el) {};
/**
 * @extends {Ext.tip.IToolTip}
 * @record
 * @struct
 */
Ext.IQuickTip = function() {};
 /** @type {boolean} */
Ext.IQuickTip.prototype.interceptTitles;
 /** @type {?} */
Ext.IQuickTip.prototype.target;
 /** @type {string} */
Ext.IQuickTip.prototype.title;

/**
 * [Method] Hides a visible tip or cancels an impending show for a particular element
 * @param {?=} el String/HTMLElement/Ext.Element The element that is the target of the tip or ID of the element.
 * @return {void}
 */
Ext.IQuickTip.prototype.cancelShow = function(el) {};

/**
 * [Method] Configures a new quick tip instance and assigns it to a target element
 * @param {?=} config Object The config object with the following properties:
 * @return {void}
 */
Ext.IQuickTip.prototype.register = function(config) {};

/**
 * [Method] Removes this quick tip from its element and destroys it
 * @param {?=} el String/HTMLElement/Ext.Element The element from which the quick tip is to be removed or ID of the element.
 * @return {void}
 */
Ext.IQuickTip.prototype.unregister = function(el) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.tip.IQuickTipManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.tip.QuickTipManager = function() {};
 /** @type {!Ext.IClass} */
Ext.tip.QuickTipManager.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.tip.QuickTipManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.tip.QuickTipManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.tip.QuickTipManager.callSuper = function(args) {};

/**
 * [Method] Destroys the QuickTips instance
 * @return {void}
 */
Ext.tip.QuickTipManager.destroy = function() {};

/**
 * [Method] Disables quick tips globally
 * @return {void}
 */
Ext.tip.QuickTipManager.disable = function() {};

/**
 * [Method] Enables quick tips globally
 * @return {void}
 */
Ext.tip.QuickTipManager.enable = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.tip.QuickTipManager.getInitialConfig = function(name) {};

/**
 * [Method] Gets the single QuickTip instance used to show tips from all registered elements
 * @return {!Ext.tip.IQuickTip} Ext.tip.QuickTip
 */
Ext.tip.QuickTipManager.getQuickTip = function() {};

/**
 * [Method] Initializes the global QuickTips instance and prepare any quick tips
 * @param {boolean=} autoRender Boolean True to render the QuickTips container immediately to preload images.
 * @param {?=} config Object config object for the created QuickTip. By default, the QuickTip class is instantiated, but this can be changed by supplying an xtype property or a className property in this object. All other properties on this object are configuration for the created component.
 * @return {void}
 */
Ext.tip.QuickTipManager.init = function(autoRender, config) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.tip.QuickTipManager.initConfig = function(config) {};

/**
 * [Method] Returns true if quick tips are enabled else false
 * @return {boolean} Boolean
 */
Ext.tip.QuickTipManager.isEnabled = function() {};

/**
 * [Method] Configures a new quick tip instance and assigns it to a target element
 * @param {?=} config Object The config object
 * @return {void}
 */
Ext.tip.QuickTipManager.register = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.tip.QuickTipManager.statics = function() {};

/**
 * [Method] Alias of register
 * @param {?=} config Object The config object
 * @return {void}
 */
Ext.tip.QuickTipManager.tips = function(config) {};

/**
 * [Method] Removes any registered quick tip from the target element and destroys it
 * @param {?=} el String/HTMLElement/Ext.Element The element from which the quick tip is to be removed or ID of the element.
 * @return {void}
 */
Ext.tip.QuickTipManager.unregister = function(el) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IQuickTips = function() {};
/**
 * @constructor
 * @struct
 */
Ext.QuickTips = function() {};
 /** @type {!Ext.IClass} */
Ext.QuickTips.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.QuickTips.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.QuickTips.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.QuickTips.callSuper = function(args) {};

/**
 * [Method] Destroys the QuickTips instance
 * @return {void}
 */
Ext.QuickTips.destroy = function() {};

/**
 * [Method] Disables quick tips globally
 * @return {void}
 */
Ext.QuickTips.disable = function() {};

/**
 * [Method] Enables quick tips globally
 * @return {void}
 */
Ext.QuickTips.enable = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.QuickTips.getInitialConfig = function(name) {};

/**
 * [Method] Gets the single QuickTip instance used to show tips from all registered elements
 * @return {!Ext.tip.IQuickTip} Ext.tip.QuickTip
 */
Ext.QuickTips.getQuickTip = function() {};

/**
 * [Method] Initializes the global QuickTips instance and prepare any quick tips
 * @param {boolean=} autoRender Boolean True to render the QuickTips container immediately to preload images.
 * @param {?=} config Object config object for the created QuickTip. By default, the QuickTip class is instantiated, but this can be changed by supplying an xtype property or a className property in this object. All other properties on this object are configuration for the created component.
 * @return {void}
 */
Ext.QuickTips.init = function(autoRender, config) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.QuickTips.initConfig = function(config) {};

/**
 * [Method] Returns true if quick tips are enabled else false
 * @return {boolean} Boolean
 */
Ext.QuickTips.isEnabled = function() {};

/**
 * [Method] Configures a new quick tip instance and assigns it to a target element
 * @param {?=} config Object The config object
 * @return {void}
 */
Ext.QuickTips.register = function(config) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.QuickTips.statics = function() {};

/**
 * [Method] Alias of register
 * @param {?=} config Object The config object
 * @return {void}
 */
Ext.QuickTips.tips = function(config) {};

/**
 * [Method] Removes any registered quick tip from the target element and destroys it
 * @param {?=} el String/HTMLElement/Ext.Element The element from which the quick tip is to be removed or ID of the element.
 * @return {void}
 */
Ext.QuickTips.unregister = function(el) {};
/**
 * @extends {Ext.panel.IPanel}
 * @record
 * @struct
 */
Ext.tip.ITip = function() {};
 /** @type {?} */
Ext.tip.ITip.prototype.autoRender;
 /** @type {string} */
Ext.tip.ITip.prototype.baseCls;
 /** @type {boolean} */
Ext.tip.ITip.prototype.closable;
 /** @type {string} */
Ext.tip.ITip.prototype.closeAction;
 /** @type {boolean} */
Ext.tip.ITip.prototype.constrainPosition;
 /** @type {string} */
Ext.tip.ITip.prototype.defaultAlign;
 /** @type {boolean} */
Ext.tip.ITip.prototype.floating;
 /** @type {boolean} */
Ext.tip.ITip.prototype.focusOnToFront;
 /** @type {boolean} */
Ext.tip.ITip.prototype.frameHeader;
 /** @type {boolean} */
Ext.tip.ITip.prototype.hidden;
 /** @type {number} */
Ext.tip.ITip.prototype.maxWidth;
 /** @type {number} */
Ext.tip.ITip.prototype.minWidth;
 /** @type {?} */
Ext.tip.ITip.prototype.shadow;
 /** @type {number} */
Ext.tip.ITip.prototype.width;
/**
 * @extends {Ext.panel.IPanel}
 * @record
 * @struct
 */
Ext.ITip = function() {};
 /** @type {?} */
Ext.ITip.prototype.autoRender;
 /** @type {string} */
Ext.ITip.prototype.baseCls;
 /** @type {boolean} */
Ext.ITip.prototype.closable;
 /** @type {string} */
Ext.ITip.prototype.closeAction;
 /** @type {boolean} */
Ext.ITip.prototype.constrainPosition;
 /** @type {string} */
Ext.ITip.prototype.defaultAlign;
 /** @type {boolean} */
Ext.ITip.prototype.floating;
 /** @type {boolean} */
Ext.ITip.prototype.focusOnToFront;
 /** @type {boolean} */
Ext.ITip.prototype.frameHeader;
 /** @type {boolean} */
Ext.ITip.prototype.hidden;
 /** @type {number} */
Ext.ITip.prototype.maxWidth;
 /** @type {number} */
Ext.ITip.prototype.minWidth;
 /** @type {?} */
Ext.ITip.prototype.shadow;
 /** @type {number} */
Ext.ITip.prototype.width;
/**
 * @extends {Ext.tip.ITip}
 * @record
 * @struct
 */
Ext.tip.IToolTip = function() {};
 /** @type {string} */
Ext.tip.IToolTip.prototype.anchor;
 /** @type {number} */
Ext.tip.IToolTip.prototype.anchorOffset;
 /** @type {boolean} */
Ext.tip.IToolTip.prototype.anchorToTarget;
 /** @type {boolean} */
Ext.tip.IToolTip.prototype.autoHide;
 /** @type {string} */
Ext.tip.IToolTip.prototype.delegate;
 /** @type {number} */
Ext.tip.IToolTip.prototype.dismissDelay;
 /** @type {number} */
Ext.tip.IToolTip.prototype.hideDelay;
 /** @type {!Array<number>} */
Ext.tip.IToolTip.prototype.mouseOffset;
 /** @type {number} */
Ext.tip.IToolTip.prototype.showDelay;
 /** @type {?} */
Ext.tip.IToolTip.prototype.target;
 /** @type {boolean} */
Ext.tip.IToolTip.prototype.trackMouse;
 /** @type {!HTMLElement} */
Ext.tip.IToolTip.prototype.triggerElement;

/**
 * [Method] Binds this ToolTip to the specified element
 * @param {?=} t String/HTMLElement/Ext.Element The Element, HtmlElement, or ID of an element to bind to
 * @return {void}
 */
Ext.tip.IToolTip.prototype.setTarget = function(t) {};
/**
 * @extends {Ext.tip.ITip}
 * @record
 * @struct
 */
Ext.IToolTip = function() {};
 /** @type {string} */
Ext.IToolTip.prototype.anchor;
 /** @type {number} */
Ext.IToolTip.prototype.anchorOffset;
 /** @type {boolean} */
Ext.IToolTip.prototype.anchorToTarget;
 /** @type {boolean} */
Ext.IToolTip.prototype.autoHide;
 /** @type {string} */
Ext.IToolTip.prototype.delegate;
 /** @type {number} */
Ext.IToolTip.prototype.dismissDelay;
 /** @type {number} */
Ext.IToolTip.prototype.hideDelay;
 /** @type {!Array<number>} */
Ext.IToolTip.prototype.mouseOffset;
 /** @type {number} */
Ext.IToolTip.prototype.showDelay;
 /** @type {?} */
Ext.IToolTip.prototype.target;
 /** @type {boolean} */
Ext.IToolTip.prototype.trackMouse;
 /** @type {!HTMLElement} */
Ext.IToolTip.prototype.triggerElement;

/**
 * [Method] Binds this ToolTip to the specified element
 * @param {?=} t String/HTMLElement/Ext.Element The Element, HtmlElement, or ID of an element to bind to
 * @return {void}
 */
Ext.IToolTip.prototype.setTarget = function(t) {};
/** @const */
Ext.toolbar = {};
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.toolbar.IFill = function() {};
 /** @type {boolean} */
Ext.toolbar.IFill.prototype.isFill;
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.toolbar.IItem = function() {};
 /** @type {string} */
Ext.toolbar.IItem.prototype.overflowText;

/**
 * [Method] Disable the component
 * @return {void}
 */
Ext.toolbar.IItem.prototype.disable = function() {};

/**
 * [Method] Enable the component
 * @return {void}
 */
Ext.toolbar.IItem.prototype.enable = function() {};

/**
 * [Method] Try to focus this component
 * @return {!Ext.IComponent} Ext.Component The focused Component. Usually this Component. Some Containers may delegate focus to a descendant Component (Windows can do this through their defaultFocus config option.
 */
Ext.toolbar.IItem.prototype.focus = function() {};
/**
 * @extends {Ext.toolbar.IToolbar}
 * @extends {Ext.util.IBindable}
 * @record
 * @struct
 */
Ext.toolbar.IPaging = function() {};
 /** @type {string} */
Ext.toolbar.IPaging.prototype.afterPageText;
 /** @type {string} */
Ext.toolbar.IPaging.prototype.beforePageText;
 /** @type {boolean} */
Ext.toolbar.IPaging.prototype.displayInfo;
 /** @type {string} */
Ext.toolbar.IPaging.prototype.displayMsg;
 /** @type {string} */
Ext.toolbar.IPaging.prototype.emptyMsg;
 /** @type {string} */
Ext.toolbar.IPaging.prototype.firstText;
 /** @type {number} */
Ext.toolbar.IPaging.prototype.inputItemWidth;
 /** @type {string} */
Ext.toolbar.IPaging.prototype.lastText;
 /** @type {string} */
Ext.toolbar.IPaging.prototype.nextText;
 /** @type {boolean} */
Ext.toolbar.IPaging.prototype.prependButtons;
 /** @type {string} */
Ext.toolbar.IPaging.prototype.prevText;
 /** @type {string} */
Ext.toolbar.IPaging.prototype.refreshText;
 /** @type {!Ext.data.IStore} */
Ext.toolbar.IPaging.prototype.store;

/**
 * [Method] Binds the paging toolbar to the specified Ext data Store deprecated
 * @param {!Ext.data.IStore=} store Ext.data.Store The data store to bind
 * @return {void}
 */
Ext.toolbar.IPaging.prototype.bind = function(store) {};

/**
 * [Method] Binds a store to this instance
 * @param {?=} store Ext.data.AbstractStore/String The store to bind or ID of the store. When no store given (or when null or undefined passed), unbinds the existing store.
 * @return {void}
 */
Ext.toolbar.IPaging.prototype.bindStore = function(store) {};

/**
 * [Method] Binds listeners for this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to bind to
 * @return {void}
 */
Ext.toolbar.IPaging.prototype.bindStoreListeners = function(store) {};

/**
 * [Method] Refresh the current page has the same effect as clicking the refresh button
 * @return {void}
 */
Ext.toolbar.IPaging.prototype.doRefresh = function() {};

/**
 * [Method] Gets the current store instance
 * @return {!Ext.data.IAbstractStore} Ext.data.AbstractStore The store, null if one does not exist.
 */
Ext.toolbar.IPaging.prototype.getStore = function() {};

/**
 * [Method] Gets the listeners to bind to a new store
 * @return {?} Object The listeners to be bound to the store in object literal form. The scope may be omitted, it is assumed to be the current instance.
 */
Ext.toolbar.IPaging.prototype.getStoreListeners = function() {};

/**
 * [Method] Move to the first page has the same effect as clicking the first button
 * @return {void}
 */
Ext.toolbar.IPaging.prototype.moveFirst = function() {};

/**
 * [Method] Move to the last page has the same effect as clicking the last button
 * @return {void}
 */
Ext.toolbar.IPaging.prototype.moveLast = function() {};

/**
 * [Method] Move to the next page has the same effect as clicking the next button
 * @return {void}
 */
Ext.toolbar.IPaging.prototype.moveNext = function() {};

/**
 * [Method] Move to the previous page has the same effect as clicking the previous button
 * @return {void}
 */
Ext.toolbar.IPaging.prototype.movePrevious = function() {};

/**
 * [Method] Template method it is called when a new store is bound to the current instance
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store being bound
 * @param {boolean=} initial Boolean True if this store is being bound as initialization of the instance.
 * @return {void}
 */
Ext.toolbar.IPaging.prototype.onBindStore = function(store, initial) {};

/**
 * [Method] Template method it is called when an existing store is unbound from the current instance
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store being unbound
 * @param {boolean=} initial Boolean True if this store is being bound as initialization of the instance.
 * @return {void}
 */
Ext.toolbar.IPaging.prototype.onUnbindStore = function(store, initial) {};

/**
 * [Method] Unbinds the paging toolbar from the specified Ext data Store deprecated
 * @param {!Ext.data.IStore=} store Ext.data.Store The data store to unbind
 * @return {void}
 */
Ext.toolbar.IPaging.prototype.unbind = function(store) {};

/**
 * [Method] Unbinds listeners from this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to unbind from
 * @return {void}
 */
Ext.toolbar.IPaging.prototype.unbindStoreListeners = function(store) {};
/**
 * @extends {Ext.toolbar.IToolbar}
 * @extends {Ext.util.IBindable}
 * @record
 * @struct
 */
Ext.IPagingToolbar = function() {};
 /** @type {string} */
Ext.IPagingToolbar.prototype.afterPageText;
 /** @type {string} */
Ext.IPagingToolbar.prototype.beforePageText;
 /** @type {boolean} */
Ext.IPagingToolbar.prototype.displayInfo;
 /** @type {string} */
Ext.IPagingToolbar.prototype.displayMsg;
 /** @type {string} */
Ext.IPagingToolbar.prototype.emptyMsg;
 /** @type {string} */
Ext.IPagingToolbar.prototype.firstText;
 /** @type {number} */
Ext.IPagingToolbar.prototype.inputItemWidth;
 /** @type {string} */
Ext.IPagingToolbar.prototype.lastText;
 /** @type {string} */
Ext.IPagingToolbar.prototype.nextText;
 /** @type {boolean} */
Ext.IPagingToolbar.prototype.prependButtons;
 /** @type {string} */
Ext.IPagingToolbar.prototype.prevText;
 /** @type {string} */
Ext.IPagingToolbar.prototype.refreshText;
 /** @type {!Ext.data.IStore} */
Ext.IPagingToolbar.prototype.store;

/**
 * [Method] Binds the paging toolbar to the specified Ext data Store deprecated
 * @param {!Ext.data.IStore=} store Ext.data.Store The data store to bind
 * @return {void}
 */
Ext.IPagingToolbar.prototype.bind = function(store) {};

/**
 * [Method] Binds a store to this instance
 * @param {?=} store Ext.data.AbstractStore/String The store to bind or ID of the store. When no store given (or when null or undefined passed), unbinds the existing store.
 * @return {void}
 */
Ext.IPagingToolbar.prototype.bindStore = function(store) {};

/**
 * [Method] Binds listeners for this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to bind to
 * @return {void}
 */
Ext.IPagingToolbar.prototype.bindStoreListeners = function(store) {};

/**
 * [Method] Refresh the current page has the same effect as clicking the refresh button
 * @return {void}
 */
Ext.IPagingToolbar.prototype.doRefresh = function() {};

/**
 * [Method] Gets the current store instance
 * @return {!Ext.data.IAbstractStore} Ext.data.AbstractStore The store, null if one does not exist.
 */
Ext.IPagingToolbar.prototype.getStore = function() {};

/**
 * [Method] Gets the listeners to bind to a new store
 * @return {?} Object The listeners to be bound to the store in object literal form. The scope may be omitted, it is assumed to be the current instance.
 */
Ext.IPagingToolbar.prototype.getStoreListeners = function() {};

/**
 * [Method] Move to the first page has the same effect as clicking the first button
 * @return {void}
 */
Ext.IPagingToolbar.prototype.moveFirst = function() {};

/**
 * [Method] Move to the last page has the same effect as clicking the last button
 * @return {void}
 */
Ext.IPagingToolbar.prototype.moveLast = function() {};

/**
 * [Method] Move to the next page has the same effect as clicking the next button
 * @return {void}
 */
Ext.IPagingToolbar.prototype.moveNext = function() {};

/**
 * [Method] Move to the previous page has the same effect as clicking the previous button
 * @return {void}
 */
Ext.IPagingToolbar.prototype.movePrevious = function() {};

/**
 * [Method] Template method it is called when a new store is bound to the current instance
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store being bound
 * @param {boolean=} initial Boolean True if this store is being bound as initialization of the instance.
 * @return {void}
 */
Ext.IPagingToolbar.prototype.onBindStore = function(store, initial) {};

/**
 * [Method] Template method it is called when an existing store is unbound from the current instance
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store being unbound
 * @param {boolean=} initial Boolean True if this store is being bound as initialization of the instance.
 * @return {void}
 */
Ext.IPagingToolbar.prototype.onUnbindStore = function(store, initial) {};

/**
 * [Method] Unbinds the paging toolbar from the specified Ext data Store deprecated
 * @param {!Ext.data.IStore=} store Ext.data.Store The data store to unbind
 * @return {void}
 */
Ext.IPagingToolbar.prototype.unbind = function(store) {};

/**
 * [Method] Unbinds listeners from this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to unbind from
 * @return {void}
 */
Ext.IPagingToolbar.prototype.unbindStoreListeners = function(store) {};
/**
 * @extends {Ext.toolbar.IItem}
 * @record
 * @struct
 */
Ext.toolbar.ISeparator = function() {};
 /** @type {string} */
Ext.toolbar.ISeparator.prototype.baseCls;
/**
 * @extends {Ext.IComponent}
 * @record
 * @struct
 */
Ext.toolbar.ISpacer = function() {};
 /** @type {string} */
Ext.toolbar.ISpacer.prototype.baseCls;
/**
 * @extends {Ext.toolbar.IItem}
 * @record
 * @struct
 */
Ext.toolbar.ITextItem = function() {};
 /** @type {string} */
Ext.toolbar.ITextItem.prototype.baseCls;
 /** @type {?} */
Ext.toolbar.ITextItem.prototype.renderTpl;
 /** @type {string} */
Ext.toolbar.ITextItem.prototype.text;

/**
 * [Method] Updates this item s text setting the text to be used as innerHTML
 * @param {string=} text String The text to display (html accepted).
 * @return {void}
 */
Ext.toolbar.ITextItem.prototype.setText = function(text) {};
/**
 * @extends {Ext.container.IContainer}
 * @record
 * @struct
 */
Ext.toolbar.IToolbar = function() {};
 /** @type {string} */
Ext.toolbar.IToolbar.prototype.baseCls;
 /** @type {string} */
Ext.toolbar.IToolbar.prototype.defaultButtonUI;
 /** @type {string} */
Ext.toolbar.IToolbar.prototype.defaultType;
 /** @type {boolean} */
Ext.toolbar.IToolbar.prototype.enableOverflow;
 /** @type {?} */
Ext.toolbar.IToolbar.prototype.layout;
 /** @type {string} */
Ext.toolbar.IToolbar.prototype.menuTriggerCls;
 /** @type {boolean} */
Ext.toolbar.IToolbar.prototype.vertical;
 /** @type {boolean} */
Ext.toolbar.IToolbar.prototype.isToolbar;

/**
 * [Method] Adds element s to the toolbar this function takes a variable number of arguments of mixed type and adds them to t
 * @param {?=} args Ext.Component.../Object.../String.../HTMLElement... The following types of arguments are all valid:  config: A valid button config object HtmlElement: Any standard HTML element Field: Any form field Item: Any subclass of Ext.toolbar.Item String: Any generic string (gets wrapped in a Ext.toolbar.TextItem). Note that there are a few special strings that are treated differently as explained next:  '-': Creates a separator element ' ': Creates a spacer element '-&gt;': Creates a fill element
 * @return {?} Ext.Component[]/Ext.Component The Components that were added.
 */
Ext.toolbar.IToolbar.prototype.add = function(args) {};

/**
 * [Method] Used by ComponentQuery child and down to retrieve all of the items which can potentially be considered a child of th
 * @param {?=} deep Object
 * @return {void}
 */
Ext.toolbar.IToolbar.prototype.getRefItems = function(deep) {};

/**
 * [Method] Inserts a Component into this Container at a specified index
 * @param {number=} index Number The index at which the Component will be inserted.
 * @param {?=} component Ext.Component/Object/String/HTMLElement See add method for overview of possible values.
 * @return {!Ext.IComponent} Ext.Component The component that was inserted.
 */
Ext.toolbar.IToolbar.prototype.insert = function(index, component) {};
/**
 * @extends {Ext.container.IContainer}
 * @record
 * @struct
 */
Ext.IToolbar = function() {};
 /** @type {string} */
Ext.IToolbar.prototype.baseCls;
 /** @type {string} */
Ext.IToolbar.prototype.defaultButtonUI;
 /** @type {string} */
Ext.IToolbar.prototype.defaultType;
 /** @type {boolean} */
Ext.IToolbar.prototype.enableOverflow;
 /** @type {?} */
Ext.IToolbar.prototype.layout;
 /** @type {string} */
Ext.IToolbar.prototype.menuTriggerCls;
 /** @type {boolean} */
Ext.IToolbar.prototype.vertical;
 /** @type {boolean} */
Ext.IToolbar.prototype.isToolbar;

/**
 * [Method] Adds element s to the toolbar this function takes a variable number of arguments of mixed type and adds them to t
 * @param {?=} args Ext.Component.../Object.../String.../HTMLElement... The following types of arguments are all valid:  config: A valid button config object HtmlElement: Any standard HTML element Field: Any form field Item: Any subclass of Ext.toolbar.Item String: Any generic string (gets wrapped in a Ext.toolbar.TextItem). Note that there are a few special strings that are treated differently as explained next:  '-': Creates a separator element ' ': Creates a spacer element '-&gt;': Creates a fill element
 * @return {?} Ext.Component[]/Ext.Component The Components that were added.
 */
Ext.IToolbar.prototype.add = function(args) {};

/**
 * [Method] Used by ComponentQuery child and down to retrieve all of the items which can potentially be considered a child of th
 * @param {?=} deep Object
 * @return {void}
 */
Ext.IToolbar.prototype.getRefItems = function(deep) {};

/**
 * [Method] Inserts a Component into this Container at a specified index
 * @param {number=} index Number The index at which the Component will be inserted.
 * @param {?=} component Ext.Component/Object/String/HTMLElement See add method for overview of possible values.
 * @return {!Ext.IComponent} Ext.Component The component that was inserted.
 */
Ext.IToolbar.prototype.insert = function(index, component) {};
/** @const */
Ext.tree = {};
/**
 * @extends {Ext.grid.column.IColumn}
 * @record
 * @struct
 */
Ext.tree.IColumn = function() {};
 /** @type {boolean} */
Ext.tree.IColumn.prototype.hideable;
 /** @type {boolean} */
Ext.tree.IColumn.prototype.lockable;
 /** @type {string} */
Ext.tree.IColumn.prototype.tdCls;
 /** @type {boolean} */
Ext.tree.IColumn.prototype.draggable;
/**
 * @extends {Ext.panel.ITable}
 * @record
 * @struct
 */
Ext.tree.IPanel = function() {};
 /** @type {boolean} */
Ext.tree.IPanel.prototype.animate;
 /** @type {boolean} */
Ext.tree.IPanel.prototype.deferRowRender;
 /** @type {string} */
Ext.tree.IPanel.prototype.displayField;
 /** @type {boolean} */
Ext.tree.IPanel.prototype.folderSort;
 /** @type {boolean} */
Ext.tree.IPanel.prototype.hideHeaders;
 /** @type {boolean} */
Ext.tree.IPanel.prototype.lines;
 /** @type {?} */
Ext.tree.IPanel.prototype.root;
 /** @type {boolean} */
Ext.tree.IPanel.prototype.rootVisible;
 /** @type {boolean} */
Ext.tree.IPanel.prototype.rowLines;
 /** @type {string} */
Ext.tree.IPanel.prototype.selType;
 /** @type {boolean} */
Ext.tree.IPanel.prototype.singleExpand;
 /** @type {!Ext.data.ITreeStore} */
Ext.tree.IPanel.prototype.store;
 /** @type {boolean} */
Ext.tree.IPanel.prototype.useArrows;
 /** @type {string} */
Ext.tree.IPanel.prototype.viewType;

/**
 * [Method] Collapse all nodes
 * @param {?=} callback Function A function to execute when the collapse finishes.
 * @param {?=} scope Object The scope of the callback function
 * @return {void}
 */
Ext.tree.IPanel.prototype.collapseAll = function(callback, scope) {};

/**
 * [Method] Collapses a record that is loaded in the tree
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to collapse
 * @param {boolean=} deep Boolean True to collapse nodes all the way up the tree hierarchy.
 * @param {?=} callback Function The function to run after the collapse is completed
 * @param {?=} scope Object The scope of the callback function.
 * @return {void}
 */
Ext.tree.IPanel.prototype.collapseNode = function(record, deep, callback, scope) {};

/**
 * [Method] Expand all nodes
 * @param {?=} callback Function A function to execute when the expand finishes.
 * @param {?=} scope Object The scope of the callback function
 * @return {void}
 */
Ext.tree.IPanel.prototype.expandAll = function(callback, scope) {};

/**
 * [Method] Expands a record that is loaded in the tree
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to expand
 * @param {boolean=} deep Boolean True to expand nodes all the way down the tree hierarchy.
 * @param {?=} callback Function The function to run after the expand is completed
 * @param {?=} scope Object The scope of the callback function.
 * @return {void}
 */
Ext.tree.IPanel.prototype.expandNode = function(record, deep, callback, scope) {};

/**
 * [Method] Expand the tree to the path of a particular node
 * @param {string=} path String The path to expand. The path should include a leading separator.
 * @param {string=} field String The field to get the data from. Defaults to the model idProperty.
 * @param {string=} separator String A separator to use.
 * @param {?=} callback Function A function to execute when the expand finishes. The callback will be called with (success, lastNode) where success is if the expand was successful and lastNode is the last node that was expanded.
 * @param {?=} scope Object The scope of the callback function
 * @return {void}
 */
Ext.tree.IPanel.prototype.expandPath = function(path, field, separator, callback, scope) {};

/**
 * [Method] Retrieve an array of checked records
 * @return {!Array<!Ext.data.INodeInterface>} Ext.data.NodeInterface[] An array containing the checked records
 */
Ext.tree.IPanel.prototype.getChecked = function() {};

/**
 * [Method] Returns the root node for this tree
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface
 */
Ext.tree.IPanel.prototype.getRootNode = function() {};

/**
 * [Method] Expand the tree to the path of a particular node then select it
 * @param {string=} path String The path to select. The path should include a leading separator.
 * @param {string=} field String The field to get the data from. Defaults to the model idProperty.
 * @param {string=} separator String A separator to use.
 * @param {?=} callback Function A function to execute when the select finishes. The callback will be called with (bSuccess, oLastNode) where bSuccess is if the select was successful and oLastNode is the last node that was expanded.
 * @param {?=} scope Object The scope of the callback function
 * @return {void}
 */
Ext.tree.IPanel.prototype.selectPath = function(path, field, separator, callback, scope) {};

/**
 * [Method] Sets root node of this tree
 * @param {?=} root Ext.data.Model/Ext.data.NodeInterface/Object
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface The new root
 */
Ext.tree.IPanel.prototype.setRootNode = function(root) {};
/**
 * @extends {Ext.panel.ITable}
 * @record
 * @struct
 */
Ext.tree.ITreePanel = function() {};
 /** @type {boolean} */
Ext.tree.ITreePanel.prototype.animate;
 /** @type {boolean} */
Ext.tree.ITreePanel.prototype.deferRowRender;
 /** @type {string} */
Ext.tree.ITreePanel.prototype.displayField;
 /** @type {boolean} */
Ext.tree.ITreePanel.prototype.folderSort;
 /** @type {boolean} */
Ext.tree.ITreePanel.prototype.hideHeaders;
 /** @type {boolean} */
Ext.tree.ITreePanel.prototype.lines;
 /** @type {?} */
Ext.tree.ITreePanel.prototype.root;
 /** @type {boolean} */
Ext.tree.ITreePanel.prototype.rootVisible;
 /** @type {boolean} */
Ext.tree.ITreePanel.prototype.rowLines;
 /** @type {string} */
Ext.tree.ITreePanel.prototype.selType;
 /** @type {boolean} */
Ext.tree.ITreePanel.prototype.singleExpand;
 /** @type {!Ext.data.ITreeStore} */
Ext.tree.ITreePanel.prototype.store;
 /** @type {boolean} */
Ext.tree.ITreePanel.prototype.useArrows;
 /** @type {string} */
Ext.tree.ITreePanel.prototype.viewType;

/**
 * [Method] Collapse all nodes
 * @param {?=} callback Function A function to execute when the collapse finishes.
 * @param {?=} scope Object The scope of the callback function
 * @return {void}
 */
Ext.tree.ITreePanel.prototype.collapseAll = function(callback, scope) {};

/**
 * [Method] Collapses a record that is loaded in the tree
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to collapse
 * @param {boolean=} deep Boolean True to collapse nodes all the way up the tree hierarchy.
 * @param {?=} callback Function The function to run after the collapse is completed
 * @param {?=} scope Object The scope of the callback function.
 * @return {void}
 */
Ext.tree.ITreePanel.prototype.collapseNode = function(record, deep, callback, scope) {};

/**
 * [Method] Expand all nodes
 * @param {?=} callback Function A function to execute when the expand finishes.
 * @param {?=} scope Object The scope of the callback function
 * @return {void}
 */
Ext.tree.ITreePanel.prototype.expandAll = function(callback, scope) {};

/**
 * [Method] Expands a record that is loaded in the tree
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to expand
 * @param {boolean=} deep Boolean True to expand nodes all the way down the tree hierarchy.
 * @param {?=} callback Function The function to run after the expand is completed
 * @param {?=} scope Object The scope of the callback function.
 * @return {void}
 */
Ext.tree.ITreePanel.prototype.expandNode = function(record, deep, callback, scope) {};

/**
 * [Method] Expand the tree to the path of a particular node
 * @param {string=} path String The path to expand. The path should include a leading separator.
 * @param {string=} field String The field to get the data from. Defaults to the model idProperty.
 * @param {string=} separator String A separator to use.
 * @param {?=} callback Function A function to execute when the expand finishes. The callback will be called with (success, lastNode) where success is if the expand was successful and lastNode is the last node that was expanded.
 * @param {?=} scope Object The scope of the callback function
 * @return {void}
 */
Ext.tree.ITreePanel.prototype.expandPath = function(path, field, separator, callback, scope) {};

/**
 * [Method] Retrieve an array of checked records
 * @return {!Array<!Ext.data.INodeInterface>} Ext.data.NodeInterface[] An array containing the checked records
 */
Ext.tree.ITreePanel.prototype.getChecked = function() {};

/**
 * [Method] Returns the root node for this tree
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface
 */
Ext.tree.ITreePanel.prototype.getRootNode = function() {};

/**
 * [Method] Expand the tree to the path of a particular node then select it
 * @param {string=} path String The path to select. The path should include a leading separator.
 * @param {string=} field String The field to get the data from. Defaults to the model idProperty.
 * @param {string=} separator String A separator to use.
 * @param {?=} callback Function A function to execute when the select finishes. The callback will be called with (bSuccess, oLastNode) where bSuccess is if the select was successful and oLastNode is the last node that was expanded.
 * @param {?=} scope Object The scope of the callback function
 * @return {void}
 */
Ext.tree.ITreePanel.prototype.selectPath = function(path, field, separator, callback, scope) {};

/**
 * [Method] Sets root node of this tree
 * @param {?=} root Ext.data.Model/Ext.data.NodeInterface/Object
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface The new root
 */
Ext.tree.ITreePanel.prototype.setRootNode = function(root) {};
/**
 * @extends {Ext.panel.ITable}
 * @record
 * @struct
 */
Ext.ITreePanel = function() {};
 /** @type {boolean} */
Ext.ITreePanel.prototype.animate;
 /** @type {boolean} */
Ext.ITreePanel.prototype.deferRowRender;
 /** @type {string} */
Ext.ITreePanel.prototype.displayField;
 /** @type {boolean} */
Ext.ITreePanel.prototype.folderSort;
 /** @type {boolean} */
Ext.ITreePanel.prototype.hideHeaders;
 /** @type {boolean} */
Ext.ITreePanel.prototype.lines;
 /** @type {?} */
Ext.ITreePanel.prototype.root;
 /** @type {boolean} */
Ext.ITreePanel.prototype.rootVisible;
 /** @type {boolean} */
Ext.ITreePanel.prototype.rowLines;
 /** @type {string} */
Ext.ITreePanel.prototype.selType;
 /** @type {boolean} */
Ext.ITreePanel.prototype.singleExpand;
 /** @type {!Ext.data.ITreeStore} */
Ext.ITreePanel.prototype.store;
 /** @type {boolean} */
Ext.ITreePanel.prototype.useArrows;
 /** @type {string} */
Ext.ITreePanel.prototype.viewType;

/**
 * [Method] Collapse all nodes
 * @param {?=} callback Function A function to execute when the collapse finishes.
 * @param {?=} scope Object The scope of the callback function
 * @return {void}
 */
Ext.ITreePanel.prototype.collapseAll = function(callback, scope) {};

/**
 * [Method] Collapses a record that is loaded in the tree
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to collapse
 * @param {boolean=} deep Boolean True to collapse nodes all the way up the tree hierarchy.
 * @param {?=} callback Function The function to run after the collapse is completed
 * @param {?=} scope Object The scope of the callback function.
 * @return {void}
 */
Ext.ITreePanel.prototype.collapseNode = function(record, deep, callback, scope) {};

/**
 * [Method] Expand all nodes
 * @param {?=} callback Function A function to execute when the expand finishes.
 * @param {?=} scope Object The scope of the callback function
 * @return {void}
 */
Ext.ITreePanel.prototype.expandAll = function(callback, scope) {};

/**
 * [Method] Expands a record that is loaded in the tree
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to expand
 * @param {boolean=} deep Boolean True to expand nodes all the way down the tree hierarchy.
 * @param {?=} callback Function The function to run after the expand is completed
 * @param {?=} scope Object The scope of the callback function.
 * @return {void}
 */
Ext.ITreePanel.prototype.expandNode = function(record, deep, callback, scope) {};

/**
 * [Method] Expand the tree to the path of a particular node
 * @param {string=} path String The path to expand. The path should include a leading separator.
 * @param {string=} field String The field to get the data from. Defaults to the model idProperty.
 * @param {string=} separator String A separator to use.
 * @param {?=} callback Function A function to execute when the expand finishes. The callback will be called with (success, lastNode) where success is if the expand was successful and lastNode is the last node that was expanded.
 * @param {?=} scope Object The scope of the callback function
 * @return {void}
 */
Ext.ITreePanel.prototype.expandPath = function(path, field, separator, callback, scope) {};

/**
 * [Method] Retrieve an array of checked records
 * @return {!Array<!Ext.data.INodeInterface>} Ext.data.NodeInterface[] An array containing the checked records
 */
Ext.ITreePanel.prototype.getChecked = function() {};

/**
 * [Method] Returns the root node for this tree
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface
 */
Ext.ITreePanel.prototype.getRootNode = function() {};

/**
 * [Method] Expand the tree to the path of a particular node then select it
 * @param {string=} path String The path to select. The path should include a leading separator.
 * @param {string=} field String The field to get the data from. Defaults to the model idProperty.
 * @param {string=} separator String A separator to use.
 * @param {?=} callback Function A function to execute when the select finishes. The callback will be called with (bSuccess, oLastNode) where bSuccess is if the select was successful and oLastNode is the last node that was expanded.
 * @param {?=} scope Object The scope of the callback function
 * @return {void}
 */
Ext.ITreePanel.prototype.selectPath = function(path, field, separator, callback, scope) {};

/**
 * [Method] Sets root node of this tree
 * @param {?=} root Ext.data.Model/Ext.data.NodeInterface/Object
 * @return {!Ext.data.INodeInterface} Ext.data.NodeInterface The new root
 */
Ext.ITreePanel.prototype.setRootNode = function(root) {};
/** @const */
Ext.tree.plugin = {};
/**
 * @extends {Ext.IAbstractPlugin}
 * @record
 * @struct
 */
Ext.tree.plugin.ITreeViewDragDrop = function() {};
 /** @type {boolean} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.allowContainerDrops;
 /** @type {boolean} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.allowParentInserts;
 /** @type {boolean} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.appendOnly;
 /** @type {?} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.containerScroll;
 /** @type {string} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.ddGroup;
 /** @type {string} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.displayField;
 /** @type {string} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.dragGroup;
 /** @type {string} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.dragText;
 /** @type {string} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.dropGroup;
 /** @type {boolean} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.enableDrag;
 /** @type {boolean} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.enableDrop;
 /** @type {number} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.expandDelay;
 /** @type {string} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.nodeHighlightColor;
 /** @type {boolean} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.nodeHighlightOnDrop;
 /** @type {boolean} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.nodeHighlightOnRepair;
 /** @type {boolean} */
Ext.tree.plugin.ITreeViewDragDrop.prototype.sortOnDrop;

/**
 * [Method] The init method is invoked after initComponent method has been run for the client Component
 * @param {?=} view Object
 * @return {void}
 */
Ext.tree.plugin.ITreeViewDragDrop.prototype.init = function(view) {};
/**
 * @extends {Ext.view.ITable}
 * @record
 * @struct
 */
Ext.tree.IView = function() {};
 /** @type {boolean} */
Ext.tree.IView.prototype.animate;
 /** @type {boolean} */
Ext.tree.IView.prototype.blockRefresh;
 /** @type {boolean} */
Ext.tree.IView.prototype.deferInitialRefresh;
 /** @type {boolean} */
Ext.tree.IView.prototype.loadMask;
 /** @type {string} */
Ext.tree.IView.prototype.loadingCls;
 /** @type {boolean} */
Ext.tree.IView.prototype.rootVisible;
 /** @type {boolean} */
Ext.tree.IView.prototype.stripeRows;
 /** @type {boolean} */
Ext.tree.IView.prototype.isTreeView;

/**
 * [Method] Called by the layout system after the Component has been laid out
 * @return {void}
 */
Ext.tree.IView.prototype.afterComponentLayout = function() {};

/**
 * [Method] Collapses a record that is loaded in the view
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to collapse
 * @param {boolean=} deep Boolean True to collapse nodes all the way up the tree hierarchy.
 * @param {?=} callback Function The function to run after the collapse is completed
 * @param {?=} scope Object The scope of the callback function.
 * @return {void}
 */
Ext.tree.IView.prototype.collapse = function(record, deep, callback, scope) {};

/**
 * [Method] Expands a record that is loaded in the view
 * @param {!Ext.data.IModel=} record Ext.data.Model The record to expand
 * @param {boolean=} deep Boolean True to expand nodes all the way down the tree hierarchy.
 * @param {?=} callback Function The function to run after the expand is completed
 * @param {?=} scope Object The scope of the callback function.
 * @return {void}
 */
Ext.tree.IView.prototype.expand = function(record, deep, callback, scope) {};

/**
 * [Method] Gets the listeners to bind to a new store
 * @return {?} Object The listeners to be bound to the store in object literal form. The scope may be omitted, it is assumed to be the current instance.
 */
Ext.tree.IView.prototype.getStoreListeners = function() {};

/**
 * [Method] Gets the base TreeStore from the bound TreePanel
 * @return {void}
 */
Ext.tree.IView.prototype.getTreeStore = function() {};

/**
 * [Method] private
 * @return {void}
 */
Ext.tree.IView.prototype.initComponent = function() {};

/**
 * [Method] Template method it is called when a new store is bound to the current instance
 * @return {void}
 */
Ext.tree.IView.prototype.onBindStore = function() {};

/**
 * [Method] Template method it is called when an existing store is unbound from the current instance
 * @return {void}
 */
Ext.tree.IView.prototype.onUnbindStore = function() {};

/**
 * [Method] Toggles a record between expanded and collapsed
 * @param {!Ext.data.IModel=} record Ext.data.Model
 * @param {boolean=} deep Boolean True to collapse nodes all the way up the tree hierarchy.
 * @param {?=} callback Function The function to run after the expand/collapse is completed
 * @param {?=} scope Object The scope of the callback function.
 * @return {void}
 */
Ext.tree.IView.prototype.toggle = function(record, deep, callback, scope) {};
/**
 * @extends {Ext.view.IDragZone}
 * @record
 * @struct
 */
Ext.tree.IViewDragZone = function() {};
/**
 * @extends {Ext.view.IDropZone}
 * @record
 * @struct
 */
Ext.tree.IViewDropZone = function() {};
 /** @type {boolean} */
Ext.tree.IViewDropZone.prototype.allowContainerDrop;
 /** @type {boolean} */
Ext.tree.IViewDropZone.prototype.allowParentInserts;
 /** @type {boolean} */
Ext.tree.IViewDropZone.prototype.appendOnly;
 /** @type {number} */
Ext.tree.IViewDropZone.prototype.expandDelay;

/**
 * [Method] Moved out of the DropZone without dropping
 * @return {void}
 */
Ext.tree.IViewDropZone.prototype.notifyOut = function() {};

/**
 * [Method] The mouse is past the end of all nodes or there are no nodes
 * @param {?=} dd Object
 * @param {?=} e Object
 * @param {?=} data Object
 * @return {string} String status The CSS class that communicates the drop status back to the source so that the underlying Ext.dd.StatusProxy can be updated
 */
Ext.tree.IViewDropZone.prototype.onContainerOver = function(dd, e, data) {};

/**
 * [Method] The mouse is no longer over a tree node so dropping is not valid
 * @param {?=} n Object
 * @param {?=} dd Object
 * @param {?=} e Object
 * @param {?=} data Object
 * @return {void}
 */
Ext.tree.IViewDropZone.prototype.onNodeOut = function(n, dd, e, data) {};

/**
 * [Method] The mouse is over a View node
 * @param {?=} node Object
 * @param {?=} dragZone Object
 * @param {?=} e Object
 * @param {?=} data Object
 * @return {string} String status The CSS class that communicates the drop status back to the source so that the underlying Ext.dd.StatusProxy can be updated
 */
Ext.tree.IViewDropZone.prototype.onNodeOver = function(node, dragZone, e, data) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.util.IAbstractMixedCollection = function() {};
 /** @type {boolean} */
Ext.util.IAbstractMixedCollection.prototype.allowFunctions;
 /** @type {boolean} */
Ext.util.IAbstractMixedCollection.prototype.isMixedCollection;

/**
 * [Method] Adds an item to the collection
 * @param {?=} key String/Object The key to associate with the item, or the new item. If a getKey implementation was specified for this MixedCollection, or if the key of the stored items is in a property called id, the MixedCollection will be able to derive the key for the new item. In this case just pass the new item in this parameter.
 * @param {?=} obj Object The item to add.
 * @return {?} Object The item added.
 */
Ext.util.IAbstractMixedCollection.prototype.add = function(key, obj) {};

/**
 * [Method] Adds all elements of an Array or an Object to the collection
 * @param {?=} objs Object/Array An Object containing properties which will be added to the collection, or an Array of values, each of which are added to the collection. Functions references will be added to the collection if allowFunctions has been set to true.
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.addAll = function(objs) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.IAbstractMixedCollection.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.IAbstractMixedCollection.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all items from the collection
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.clear = function() {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.clearManagedListeners = function() {};

/**
 * [Method] Creates a shallow copy of this collection
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection
 */
Ext.util.IAbstractMixedCollection.prototype.clone = function() {};

/**
 * [Method] Collects unique values of a particular property in this MixedCollection
 * @param {string=} property String The property to collect on
 * @param {string=} root String 'root' property to extract the first argument from. This is used mainly when summing fields in records, where the fields are all stored inside the 'data' object
 * @param {boolean=} allowBlank Boolean Pass true to allow null, undefined or empty string values
 * @return {!Array<?>} Array The unique values
 */
Ext.util.IAbstractMixedCollection.prototype.collect = function(property, root, allowBlank) {};

/**
 * [Method] Returns true if the collection contains the passed Object as an item
 * @param {?=} o Object The Object to look for in the collection.
 * @return {boolean} Boolean True if the collection contains the Object as an item.
 */
Ext.util.IAbstractMixedCollection.prototype.contains = function(o) {};

/**
 * [Method] Returns true if the collection contains the passed Object as a key
 * @param {string=} key String The key to look for in the collection.
 * @return {boolean} Boolean True if the collection contains the Object as a key.
 */
Ext.util.IAbstractMixedCollection.prototype.containsKey = function(key) {};

/**
 * [Method] Executes the specified function once for every item in the collection
 * @param {?=} fn Function The function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current item in the iteration.
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.each = function(fn, scope) {};

/**
 * [Method] Executes the specified function once for every key in the collection passing each key and its associated item as th
 * @param {?=} fn Function The function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.eachKey = function(fn, scope) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Filters the objects in this collection by a set of Filters or by a single property value pair with optional paramete
 * @param {?=} property Ext.util.Filter[]/String A property on your objects, or an array of Filter objects
 * @param {?=} value String/RegExp Either string that the property values should start with or a RegExp to test against the property
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection The new filtered collection
 */
Ext.util.IAbstractMixedCollection.prototype.filter = function(property, value, anyMatch, caseSensitive) {};

/**
 * [Method] Filter by a function
 * @param {?=} fn Function The function to be called.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this MixedCollection.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection The new filtered collection
 */
Ext.util.IAbstractMixedCollection.prototype.filterBy = function(fn, scope) {};

/**
 * [Method] Returns the first item in the collection which elicits a true return value from the passed selection function
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.find = function() {};

/**
 * [Method] Returns the first item in the collection which elicits a true return value from the passed selection function
 * @param {?=} fn Function The selection function to execute for each item.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {?} Object The first item in the collection which returned true from the selection function, or null if none was found.
 */
Ext.util.IAbstractMixedCollection.prototype.findBy = function(fn, scope) {};

/**
 * [Method] Finds the index of the first matching object in this collection by a specific property value
 * @param {string=} property String The name of a property on your objects.
 * @param {?=} value String/RegExp A string that the property values should start with or a RegExp to test against the property.
 * @param {number=} start Number The index to start searching at.
 * @param {boolean=} anyMatch Boolean True to match any part of the string, not just the beginning.
 * @param {boolean=} caseSensitive Boolean True for case sensitive comparison.
 * @return {number} Number The matched index or -1
 */
Ext.util.IAbstractMixedCollection.prototype.findIndex = function(property, value, start, anyMatch, caseSensitive) {};

/**
 * [Method] Find the index of the first matching object in this collection by a function
 * @param {?=} fn Function The function to be called.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to this MixedCollection.
 * @param {number=} start Number The index to start searching at.
 * @return {number} Number The matched index or -1
 */
Ext.util.IAbstractMixedCollection.prototype.findIndexBy = function(fn, scope, start) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.util.IAbstractMixedCollection.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.util.IAbstractMixedCollection.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Returns the first item in the collection
 * @return {?} Object the first item in the collection..
 */
Ext.util.IAbstractMixedCollection.prototype.first = function() {};

/**
 * [Method] Returns the item associated with the passed key OR index
 * @param {?=} key String/Number The key or index of the item.
 * @return {?} Object If the item is found, returns the item. If the item was not found, returns undefined. If an item was found, but is a Class, returns null.
 */
Ext.util.IAbstractMixedCollection.prototype.get = function(key) {};

/**
 * [Method] Returns the item at the specified index
 * @param {number=} index Number The index of the item.
 * @return {?} Object The item at the specified index.
 */
Ext.util.IAbstractMixedCollection.prototype.getAt = function(index) {};

/**
 * [Method] Returns the item associated with the passed key
 * @param {?=} key String/Number The key of the item.
 * @return {?} Object The item associated with the passed key.
 */
Ext.util.IAbstractMixedCollection.prototype.getByKey = function(key) {};

/**
 * [Method] Returns the number of items in the collection
 * @return {number} Number the number of items in the collection.
 */
Ext.util.IAbstractMixedCollection.prototype.getCount = function() {};

/**
 * [Method] A function which will be called passing a newly added object when the object is added without a separate id
 * @param {?=} item Object The item for which to find the key.
 * @return {?} Object The key for the passed item.
 */
Ext.util.IAbstractMixedCollection.prototype.getKey = function(item) {};

/**
 * [Method] Returns a range of items in this collection
 * @param {number=} startIndex Number The starting index. Defaults to 0.
 * @param {number=} endIndex Number The ending index. Defaults to the last item.
 * @return {!Array<?>} Array An array of items
 */
Ext.util.IAbstractMixedCollection.prototype.getRange = function(startIndex, endIndex) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.util.IAbstractMixedCollection.prototype.hasListener = function(eventName) {};

/**
 * [Method] Returns index within the collection of the passed Object
 * @param {?=} o Object The item to find the index of.
 * @return {number} Number index of the item. Returns -1 if not found.
 */
Ext.util.IAbstractMixedCollection.prototype.indexOf = function(o) {};

/**
 * [Method] Returns index within the collection of the passed key
 * @param {string=} key String The key to find the index of.
 * @return {number} Number index of the key.
 */
Ext.util.IAbstractMixedCollection.prototype.indexOfKey = function(key) {};

/**
 * [Method] Inserts an item at the specified index in the collection
 * @param {number=} index Number The index to insert the item at.
 * @param {?=} key String/Object/String[]/Object[] The key to associate with the new item, or the item itself. May also be an array of either to insert multiple items at once.
 * @param {?=} o Object/Object[] If the second parameter was a key, the new item. May also be an array to insert multiple items at once.
 * @return {?} Object The item inserted or an array of items inserted.
 */
Ext.util.IAbstractMixedCollection.prototype.insert = function(index, key, o) {};

/**
 * [Method] Returns the last item in the collection
 * @return {?} Object the last item in the collection..
 */
Ext.util.IAbstractMixedCollection.prototype.last = function() {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.IAbstractMixedCollection.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.IAbstractMixedCollection.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.util.IAbstractMixedCollection.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Remove an item from the collection
 * @param {?=} o Object The item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.util.IAbstractMixedCollection.prototype.remove = function(o) {};

/**
 * [Method] Remove all items in the collection
 * @param {!Array<?>=} items Array An array of items to be removed.
 * @return {!Ext.util.IMixedCollection} Ext.util.MixedCollection this object
 */
Ext.util.IAbstractMixedCollection.prototype.removeAll = function(items) {};

/**
 * [Method] Remove an item from a specified index in the collection
 * @param {number=} index Number The index within the collection of the item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.util.IAbstractMixedCollection.prototype.removeAt = function(index) {};

/**
 * [Method] Removes an item associated with the passed key fom the collection
 * @param {string=} key String The key of the item to remove. If null is passed, all objects which yielded no key from the configured getKey function are removed.
 * @return {?} Object Only returned if removing at a specified key. The item removed or false if no item was removed.
 */
Ext.util.IAbstractMixedCollection.prototype.removeAtKey = function(key) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Remove a range of items starting at a specified index in the collection
 * @param {number=} index Number The index within the collection of the item to remove.
 * @param {number=} removeCount Number The nuber of items to remove beginning at the specified index.
 * @return {?} Object The last item removed or false if no item was removed.
 */
Ext.util.IAbstractMixedCollection.prototype.removeRange = function(index, removeCount) {};

/**
 * [Method] Replaces an item in the collection
 * @param {string=} key String The key associated with the item to replace, or the replacement item. If you supplied a getKey implementation for this MixedCollection, or if the key of your stored items is in a property called id, then the MixedCollection will be able to derive the key of the replacement item. If you want to replace an item with one having the same key value, then just pass the replacement item in this parameter.
 * @param {?=} o Object {Object} o (optional) If the first parameter passed was a key, the item to associate with that key.
 * @return {?} Object The new item.
 */
Ext.util.IAbstractMixedCollection.prototype.replace = function(key, o) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.resumeEvents = function() {};

/**
 * [Method] Collects all of the values of the given property and returns their sum
 * @param {string=} property String The property to sum by
 * @param {string=} root String 'root' property to extract the first argument from. This is used mainly when summing fields in records, where the fields are all stored inside the 'data' object
 * @param {number=} start Number The record index to start at
 * @param {number=} end Number The record index to end at
 * @return {number} Number The total
 */
Ext.util.IAbstractMixedCollection.prototype.sum = function(property, root, start, end) {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.un = function(eventName, fn, scope) {};

/**
 * [Method] Change the key for an existing item in the collection
 * @param {?=} oldKey Object The old key
 * @param {?=} newKey Object The new key
 * @return {void}
 */
Ext.util.IAbstractMixedCollection.prototype.updateKey = function(oldKey, newKey) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IAnimate = function() {};
 /** @type {?} */
Ext.util.IAnimate.prototype.animate;

/**
 * [Method] Returns the current animation if this object has any effects actively running or queued else returns false
 * @return {?} Ext.fx.Anim/Boolean Anim if element has active effects, else false
 */
Ext.util.IAnimate.prototype.getActiveAnimation = function() {};

/**
 * [Method] Returns the current animation if this object has any effects actively running or queued else returns false
 * @return {?} Ext.fx.Anim/Boolean Anim if element has active effects, else false
 */
Ext.util.IAnimate.prototype.hasActiveFx = function() {};

/**
 * [Method] Ensures that all effects queued after sequenceFx is called on this object are run in sequence
 * @return {?} Object this
 */
Ext.util.IAnimate.prototype.sequenceFx = function() {};

/**
 * [Method] Stops any running effects and clears this object s internal effects queue if it contains any additional effects that
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.util.IAnimate.prototype.stopAnimation = function() {};

/**
 * [Method] Stops any running effects and clears this object s internal effects queue if it contains any additional effects that
 * @return {!Ext.IElement} Ext.Element The Element
 */
Ext.util.IAnimate.prototype.stopFx = function() {};

/**
 * [Method] Ensures that all effects queued after syncFx is called on this object are run concurrently
 * @return {?} Object this
 */
Ext.util.IAnimate.prototype.syncFx = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IBindable = function() {};

/**
 * [Method] Binds a store to this instance
 * @param {?=} store Ext.data.AbstractStore/String The store to bind or ID of the store. When no store given (or when null or undefined passed), unbinds the existing store.
 * @return {void}
 */
Ext.util.IBindable.prototype.bindStore = function(store) {};

/**
 * [Method] Binds listeners for this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to bind to
 * @return {void}
 */
Ext.util.IBindable.prototype.bindStoreListeners = function(store) {};

/**
 * [Method] Gets the current store instance
 * @return {!Ext.data.IAbstractStore} Ext.data.AbstractStore The store, null if one does not exist.
 */
Ext.util.IBindable.prototype.getStore = function() {};

/**
 * [Method] Gets the listeners to bind to a new store
 * @param {!Ext.data.IStore=} store Ext.data.Store The Store which is being bound to for which a listeners object should be returned.
 * @return {?} Object The listeners to be bound to the store in object literal form. The scope may be omitted, it is assumed to be the current instance.
 */
Ext.util.IBindable.prototype.getStoreListeners = function(store) {};

/**
 * [Method] Template method it is called when a new store is bound to the current instance
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store being bound
 * @param {boolean=} initial Boolean True if this store is being bound as initialization of the instance.
 * @return {void}
 */
Ext.util.IBindable.prototype.onBindStore = function(store, initial) {};

/**
 * [Method] Template method it is called when an existing store is unbound from the current instance
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store being unbound
 * @param {boolean=} initial Boolean True if this store is being bound as initialization of the instance.
 * @return {void}
 */
Ext.util.IBindable.prototype.onUnbindStore = function(store, initial) {};

/**
 * [Method] Unbinds listeners from this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to unbind from
 * @return {void}
 */
Ext.util.IBindable.prototype.unbindStoreListeners = function(store) {};
/**
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.util.IClickRepeater = function() {};
 /** @type {boolean} */
Ext.util.IClickRepeater.prototype.accelerate;
 /** @type {number} */
Ext.util.IClickRepeater.prototype.delay;
 /** @type {?} */
Ext.util.IClickRepeater.prototype.el;
 /** @type {number} */
Ext.util.IClickRepeater.prototype.interval;
 /** @type {string} */
Ext.util.IClickRepeater.prototype.pressedCls;
 /** @type {boolean} */
Ext.util.IClickRepeater.prototype.preventDefault;
 /** @type {boolean} */
Ext.util.IClickRepeater.prototype.stopDefault;

/**
 * [Method] Disables the repeater and stops events from firing
 * @param {?=} force Object
 * @return {void}
 */
Ext.util.IClickRepeater.prototype.disable = function(force) {};

/**
 * [Method] Enables the repeater and allows events to fire
 * @return {void}
 */
Ext.util.IClickRepeater.prototype.enable = function() {};

/**
 * [Method] Convenience function for setting disabled enabled by boolean
 * @param {boolean=} disabled Boolean
 * @return {void}
 */
Ext.util.IClickRepeater.prototype.setDisabled = function(disabled) {};
/**
 * @extends {Ext.dd.IDragTracker}
 * @record
 * @struct
 */
Ext.util.IComponentDragger = function() {};
 /** @type {boolean} */
Ext.util.IComponentDragger.prototype.constrain;
 /** @type {boolean} */
Ext.util.IComponentDragger.prototype.constrainDelegate;

/**
 * [Method] Move either the ghost Component or the target Component to its new position on drag
 * @param {?=} e Object
 * @return {void}
 */
Ext.util.IComponentDragger.prototype.onDrag = function(e) {};

/**
 * [Method] Template method which should be overridden by each DragTracker instance
 * @param {?=} e Object
 * @return {void}
 */
Ext.util.IComponentDragger.prototype.onEnd = function(e) {};

/**
 * [Method] Template method which should be overridden by each DragTracker instance
 * @param {?=} e Object
 * @return {void}
 */
Ext.util.IComponentDragger.prototype.onStart = function(e) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.ICookies = function() {};
/**
 * @constructor
 * @struct
 */
Ext.util.Cookies = function() {};
 /** @type {!Ext.IClass} */
Ext.util.Cookies.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.util.Cookies.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.util.Cookies.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.util.Cookies.callSuper = function(args) {};

/**
 * [Method] Removes a cookie with the provided name from the browser if found by setting its expiration date to sometime in the p
 * @param {string=} name String The name of the cookie to remove
 * @param {string=} path String The path for the cookie. This must be included if you included a path while setting the cookie.
 * @return {void}
 */
Ext.util.Cookies.clear = function(name, path) {};

/**
 * [Method] Retrieves cookies that are accessible by the current page
 * @param {string=} name String The name of the cookie to get
 * @return {?} Object Returns the cookie value for the specified name; null if the cookie name does not exist.
 */
Ext.util.Cookies.get = function(name) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.util.Cookies.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.util.Cookies.initConfig = function(config) {};

/**
 * [Method] Creates a cookie with the specified name and value
 * @param {string=} name String The name of the cookie to set.
 * @param {?=} value Object The value to set for the cookie.
 * @param {?=} expires Object Specify an expiration date the cookie is to persist until. Note that the specified Date object will be converted to Greenwich Mean Time (GMT).
 * @param {string=} path String Setting a path on the cookie restricts access to pages that match that path. Defaults to all pages ('/').
 * @param {string=} domain String Setting a domain restricts access to pages on a given domain (typically used to allow cookie access across subdomains). For example, "sencha.com" will create a cookie that can be accessed from any subdomain of sencha.com, including www.sencha.com, support.sencha.com, etc.
 * @param {boolean=} secure Boolean Specify true to indicate that the cookie should only be accessible via SSL on a page using the HTTPS protocol. Defaults to false. Note that this will only work if the page calling this code uses the HTTPS protocol, otherwise the cookie will be created with default options.
 * @return {void}
 */
Ext.util.Cookies.set = function(name, value, expires, path, domain, secure) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.util.Cookies.statics = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.ICSS = function() {};
/**
 * @constructor
 * @struct
 */
Ext.util.CSS = function() {};
 /** @type {!Ext.IClass} */
Ext.util.CSS.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.util.CSS.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.util.CSS.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.util.CSS.callSuper = function(args) {};

/**
 * [Method] Creates a rule
 * @param {!CSSStyleSheet=} styleSheet CSSStyleSheet The StyleSheet to create the rule in as returned from createStyleSheet.
 * @param {string=} selector String The selector to target the rule.
 * @param {string=} property String The cssText specification eg "color:red;font-weight:bold;text-decoration:underline"
 * @return {!CSSStyleRule} CSSStyleRule The created rule
 */
Ext.util.CSS.createRule = function(styleSheet, selector, property) {};

/**
 * [Method] Creates a stylesheet from a text blob of rules
 * @param {string=} cssText String The text containing the css rules
 * @param {string=} id String An id to add to the stylesheet for later removal
 * @return {!CSSStyleSheet} CSSStyleSheet
 */
Ext.util.CSS.createStyleSheet = function(cssText, id) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.util.CSS.getInitialConfig = function(name) {};

/**
 * [Method] Gets an an individual CSS rule by selector s
 * @param {?=} selector String/String[] The CSS selector or an array of selectors to try. The first selector that is found is returned.
 * @param {boolean=} refreshCache Boolean true to refresh the internal cache if you have recently updated any rules or added styles dynamically
 * @return {!CSSStyleRule} CSSStyleRule The CSS rule or null if one is not found
 */
Ext.util.CSS.getRule = function(selector, refreshCache) {};

/**
 * [Method] Gets all css rules for the document
 * @param {boolean=} refreshCache Boolean true to refresh the internal cache
 * @return {?} Object An object (hash) of rules indexed by selector
 */
Ext.util.CSS.getRules = function(refreshCache) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.util.CSS.initConfig = function(config) {};

/**
 * [Method] Refresh the rule cache if you have dynamically added stylesheets
 * @return {?} Object An object (hash) of rules indexed by selector
 */
Ext.util.CSS.refreshCache = function() {};

/**
 * [Method] Removes a style or link tag by id
 * @param {string=} id String The id of the tag
 * @return {void}
 */
Ext.util.CSS.removeStyleSheet = function(id) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.util.CSS.statics = function() {};

/**
 * [Method] Dynamically swaps an existing stylesheet reference for a new one
 * @param {string=} id String The id of an existing link tag to remove
 * @param {string=} url String The href of the new stylesheet to include
 * @return {void}
 */
Ext.util.CSS.swapStyleSheet = function(id, url) {};

/**
 * [Method] Updates a rule property
 * @param {?=} selector String/String[] If it's an array it tries each selector until it finds one. Stops immediately once one is found.
 * @param {string=} property String The css property or a cssText specification eg "color:red;font-weight:bold;text-decoration:underline"
 * @param {string=} value String The new value for the property
 * @return {boolean} Boolean true If a rule was found and updated
 */
Ext.util.CSS.updateRule = function(selector, property, value) {};
/**
 * @record
 * @struct
 */
Ext.util.IDelayedTask = function() {};
 /** @type {number} */
Ext.util.IDelayedTask.prototype.id;

/**
 * [Method] Cancel the last queued timeout
 * @return {void}
 */
Ext.util.IDelayedTask.prototype.cancel = function() {};

/**
 * [Method] By default cancels any pending timeout and queues a new one
 * @param {number=} newDelay Number The milliseconds to delay
 * @param {?=} newFn Function Overrides function passed to constructor
 * @param {?=} newScope Object Overrides scope passed to constructor. Remember that if no scope is specified, this will refer to the browser window.
 * @param {!Array<?>=} newArgs Array Overrides args passed to constructor
 * @return {void}
 */
Ext.util.IDelayedTask.prototype.delay = function(newDelay, newFn, newScope, newArgs) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IElementContainer = function() {};

/**
 * [Method] Adds each argument passed to this method to the childEls array
 * @return {void}
 */
Ext.util.IElementContainer.prototype.addChildEls = function() {};

/**
 * [Method] Removes items in the childEls array based on the return value of a supplied test function
 * @param {?=} testFn Function The test function.
 * @return {void}
 */
Ext.util.IElementContainer.prototype.removeChildEls = function(testFn) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IEvent = function() {};
 /** @type {boolean} */
Ext.util.IEvent.prototype.isEvent;
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IFilter = function() {};
 /** @type {boolean} */
Ext.util.IFilter.prototype.anyMatch;
 /** @type {boolean} */
Ext.util.IFilter.prototype.caseSensitive;
 /** @type {boolean} */
Ext.util.IFilter.prototype.exactMatch;
 /** @type {?} */
Ext.util.IFilter.prototype.filterFn;
 /** @type {string} */
Ext.util.IFilter.prototype.id;
 /** @type {string} */
Ext.util.IFilter.prototype.operator;
 /** @type {string} */
Ext.util.IFilter.prototype.property;
 /** @type {string} */
Ext.util.IFilter.prototype.root;
 /** @type {?} */
Ext.util.IFilter.prototype.value;
 /** @type {boolean} */
Ext.util.IFilter.prototype.disabled;

/**
 * [Method] Changes the filtering function which this Filter uses to choose items to include
 * @param {?=} filterFn Function A function which returns true or false to either include or exclude the passed object.
 * @return {void}
 */
Ext.util.IFilter.prototype.setFilterFn = function(filterFn) {};

/**
 * [Method] Changes the value that this filter tests its configured  link cfg property with
 * @param {?=} value Mixed The new value to compare the property with.
 * @return {void}
 */
Ext.util.IFilter.prototype.setValue = function(value) {};
/**
 * @constructor
 * @struct
 */
Ext.util.Filter = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.util.Filter.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.util.Filter.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.util.Filter.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.util.Filter.createAlias = function(alias, origin) {};

/**
 * [Method] Creates a single filter function which encapsulates the passed Filter array
 * @param {!Array<!Ext.util.IFilter>=} filters Ext.util.Filter[] The filter set for which to create a filter function
 * @return {?} Function a function, which when passed a candidate object returns true if the candidate passes all the specified Filters.
 */
Ext.util.Filter.createFilterFn = function(filters) {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.util.Filter.getName = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.util.Filter.implement = function() {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.util.Filter.override = function(members) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IFloating = function() {};
 /** @type {boolean} */
Ext.util.IFloating.prototype.constrain;
 /** @type {boolean} */
Ext.util.IFloating.prototype.fixed;
 /** @type {boolean} */
Ext.util.IFloating.prototype.focusOnToFront;
 /** @type {?} */
Ext.util.IFloating.prototype.shadow;
 /** @type {number} */
Ext.util.IFloating.prototype.shadowOffset;

/**
 * [Method] Center this Component in its container
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.util.IFloating.prototype.center = function() {};

/**
 * [Method] Moves this floating Component into a constrain region
 * @param {?=} constrainTo String/HTMLElement/Ext.Element/Ext.util.Region The Element or Region into which this Component is to be constrained. Defaults to the element into which this floating Component was rendered.
 * @return {void}
 */
Ext.util.IFloating.prototype.doConstrain = function(constrainTo) {};

/**
 * [Method] This method is called internally by Ext ZIndexManager to signal that a floating Component has either been moved to th
 * @param {boolean=} active Boolean True to activate the Component, false to deactivate it.
 * @param {!Ext.IComponent=} newActive Ext.Component The newly active Component which is taking over topmost zIndex position.
 * @return {void}
 */
Ext.util.IFloating.prototype.setActive = function(active, newActive) {};

/**
 * [Method] Sends this Component to the back of lower z index than any other visible windows
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.util.IFloating.prototype.toBack = function() {};

/**
 * [Method] Brings this floating Component to the front of any other visible floating Components managed by the same ZIndexManag
 * @param {boolean=} preventFocus Boolean Specify true to prevent the Component from being focused.
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.util.IFloating.prototype.toFront = function(preventFocus) {};
/**
 * @record
 * @struct
 */
Ext.util.IFormat = function() {};
/**
 * @constructor
 * @struct
 */
Ext.util.Format = function() {};
 /** @type {boolean} */
Ext.util.Format.currencyAtEnd;
 /** @type {number} */
Ext.util.Format.currencyPrecision;
 /** @type {string} */
Ext.util.Format.currencySign;
 /** @type {string} */
Ext.util.Format.decimalSeparator;
 /** @type {string} */
Ext.util.Format.thousandSeparator;

/**
 * [Method] Formats an object of name value properties as HTML element attribute values suitable for using when creating textual
 * @param {?=} attributes Object An object containing the HTML attributes as properties eg: {height:40, vAlign:'top'}
 * @return {void}
 */
Ext.util.Format.attributes = function(attributes) {};

/**
 * [Method] Alias for Ext String capitalize
 * @param {string=} string String
 * @return {string} String
 */
Ext.util.Format.capitalize = function(string) {};

/**
 * [Method] Format a number as a currency
 * @param {?=} value Number/String The numeric value to format
 * @param {string=} sign String The currency sign to use (defaults to currencySign)
 * @param {number=} decimals Number The number of decimals to use for the currency (defaults to currencyPrecision)
 * @param {boolean=} end Boolean True if the currency sign should be at the end of the string (defaults to currencyAtEnd)
 * @return {string} String The formatted currency string
 */
Ext.util.Format.currency = function(value, sign, decimals, end) {};

/**
 * [Method] Formats the passed date using the specified format pattern
 * @param {?=} value String/Date The value to format. If a string is passed, it is converted to a Date by the Javascript's built-in Date.parse method.
 * @param {string=} format String Any valid date format string. Defaults to Ext.Date.defaultFormat.
 * @return {string} String The formatted date string.
 */
Ext.util.Format.date = function(value, format) {};

/**
 * [Method] Returns a date rendering function that can be reused to apply a date format multiple times efficiently
 * @param {string=} format String Any valid date format string. Defaults to Ext.Date.defaultFormat.
 * @return {?} Function The date formatting function
 */
Ext.util.Format.dateRenderer = function(format) {};

/**
 * [Method] Checks a reference and converts it to the default value if it s empty
 * @param {?=} value Object Reference to check
 * @param {string=} defaultValue String The value to insert of it's undefined.
 * @return {string} String
 */
Ext.util.Format.defaultValue = function(value, defaultValue) {};

/**
 * [Method] Alias for Ext String ellipsis
 * @param {string=} value String The string to truncate.
 * @param {number=} length Number The maximum length to allow before truncating.
 * @param {boolean=} word Boolean true to try to find a common word break.
 * @return {string} String The converted text.
 */
Ext.util.Format.ellipsis = function(value, length, word) {};

/**
 * [Method] Escapes the passed string for use in a regular expression
 * @param {string=} str String
 * @return {string} String
 */
Ext.util.Format.escapeRegex = function(str) {};

/**
 * [Method] Simple format for a file size xxx bytes xxx KB xxx MB
 * @param {?=} size Number/String The numeric value to format
 * @return {string} String The formatted file size
 */
Ext.util.Format.fileSize = function(size) {};

/**
 * [Method] Alias for Ext String format
 * @param {string} string String The tokenized string to be formatted.
 * @param {...?} values Mixed... The values to replace tokens {0}, {1}, etc in order.
 * @return {string} String The formatted string.
 */
Ext.util.Format.format = function(string, values) {};

/**
 * [Method] Alias for Ext String htmlDecode
 * @param {string=} value String The string to decode.
 * @return {string} String The decoded text.
 */
Ext.util.Format.htmlDecode = function(value) {};

/**
 * [Method] Alias for Ext String htmlEncode
 * @param {string=} value String The string to encode.
 * @return {string} String The encoded text.
 */
Ext.util.Format.htmlEncode = function(value) {};

/**
 * [Method] Alias for Ext String leftPad
 * @param {string=} string String The original string.
 * @param {number=} size Number The total length of the output string.
 * @param {string=} character String The character with which to pad the original string.
 * @return {string} String The padded string.
 */
Ext.util.Format.leftPad = function(string, size, character) {};

/**
 * [Method] Converts a string to all lower case letters
 * @param {string=} value String The text to convert
 * @return {string} String The converted text
 */
Ext.util.Format.lowercase = function(value) {};

/**
 * [Method] It does simple math for use in a template for example  var tpl  new Ext Template  value 10 value math 10
 * @return {?} Function A function that operates on the passed value.
 */
Ext.util.Format.math = function() {};

/**
 * [Method] Converts newline characters to the HTML tag lt br gt
 * @param {string=} v String The string value to format.
 * @return {string} String The string with embedded &lt;br/&gt; tags in place of newlines.
 */
Ext.util.Format.nl2br = function(v) {};

/**
 * [Method] Formats the passed number according to the passed format string
 * @param {number=} v Number The number to format.
 * @param {string=} format String The way you would like to format this text.
 * @return {string} String The formatted number.
 */
Ext.util.Format.number = function(v, format) {};

/**
 * [Method] Returns a number rendering function that can be reused to apply a number format multiple times efficiently
 * @param {string=} format String Any valid number format string for number
 * @return {?} Function The number formatting function
 */
Ext.util.Format.numberRenderer = function(format) {};

/**
 * [Method] Parses a number or string representing margin sizes into an object
 * @param {?=} v Number/String The encoded margins
 * @return {?} Object An object with margin sizes for top, right, bottom and left
 */
Ext.util.Format.parseBox = function(v) {};

/**
 * [Method] Selectively do a plural form of a word based on a numeric value
 * @param {number=} value Number The value to compare against
 * @param {string=} singular String The singular form of the word
 * @param {string=} plural String The plural form of the word (defaults to the singular with an "s")
 * @return {void}
 */
Ext.util.Format.plural = function(value, singular, plural) {};

/**
 * [Method] Rounds the passed number to the required decimal precision
 * @param {?=} value Number/String The numeric value to round.
 * @param {number=} precision Number The number of decimal places to which to round the first parameter's value.
 * @return {number} Number The rounded value.
 */
Ext.util.Format.round = function(value, precision) {};

/**
 * [Method] Strips all script tags
 * @param {?=} value Object The text from which to strip script tags
 * @return {string} String The stripped text
 */
Ext.util.Format.stripScripts = function(value) {};

/**
 * [Method] Strips all HTML tags
 * @param {?=} value Object The text from which to strip tags
 * @return {string} String The stripped text
 */
Ext.util.Format.stripTags = function(value) {};

/**
 * [Method] Returns a substring from within an original string
 * @param {string=} value String The original text
 * @param {number=} start Number The start index of the substring
 * @param {number=} length Number The length of the substring
 * @return {string} String The substring
 */
Ext.util.Format.substr = function(value, start, length) {};

/**
 * [Method] Alias for Ext String trim
 * @param {string=} string String The string to trim.
 * @return {string} String The trimmed string.
 */
Ext.util.Format.trim = function(string) {};

/**
 * [Method] Checks a reference and converts it to empty string if it is undefined
 * @param {?=} value Object Reference to check
 * @return {?} Object Empty string if converted, otherwise the original value
 */
Ext.util.Format.undef = function(value) {};

/**
 * [Method] Converts a string to all upper case letters
 * @param {string=} value String The text to convert
 * @return {string} String The converted text
 */
Ext.util.Format.uppercase = function(value) {};

/**
 * [Method] Format a number as US currency
 * @param {?=} value Number/String The numeric value to format
 * @return {string} String The formatted currency string
 */
Ext.util.Format.usMoney = function(value) {};
/**
 * @extends {Ext.util.ISorter}
 * @record
 * @struct
 */
Ext.util.IGrouper = function() {};

/**
 * [Method] Returns the value for grouping to be used
 * @param {!Ext.data.IModel=} instance Ext.data.Model The Model instance
 * @return {string} String The group string for this model
 */
Ext.util.IGrouper.prototype.getGroupString = function(instance) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.util.IHashMap = function() {};
 /** @type {?} */
Ext.util.IHashMap.prototype.keyFn;

/**
 * [Method] Adds an item to the collection
 * @param {?=} key String/Object The key to associate with the item, or the new item. If a getKey implementation was specified for this HashMap, or if the key of the stored items is in a property called id, the HashMap will be able to derive the key for the new item. In this case just pass the new item in this parameter.
 * @param {?=} o Object The item to add.
 * @return {?} Object The item added.
 */
Ext.util.IHashMap.prototype.add = function(key, o) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.util.IHashMap.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.IHashMap.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.IHashMap.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all items from the hash
 * @param {?=} initial Object
 * @return {!Ext.util.IHashMap} Ext.util.HashMap this
 */
Ext.util.IHashMap.prototype.clear = function(initial) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.util.IHashMap.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.util.IHashMap.prototype.clearManagedListeners = function() {};

/**
 * [Method] Performs a shallow copy on this hash
 * @return {!Ext.util.IHashMap} Ext.util.HashMap The new hash object.
 */
Ext.util.IHashMap.prototype.clone = function() {};

/**
 * [Method] Checks whether a value exists in the hash
 * @param {?=} value Object The value to check for.
 * @return {boolean} Boolean True if the value exists in the dictionary.
 */
Ext.util.IHashMap.prototype.contains = function(value) {};

/**
 * [Method] Checks whether a key exists in the hash
 * @param {string=} key String The key to check for.
 * @return {boolean} Boolean True if they key exists in the hash.
 */
Ext.util.IHashMap.prototype.containsKey = function(key) {};

/**
 * [Method] Executes the specified function once for each item in the hash
 * @param {?=} fn Function The function to execute.
 * @param {?=} scope Object The scope to execute in. Defaults to this.
 * @return {!Ext.util.IHashMap} Ext.util.HashMap this
 */
Ext.util.IHashMap.prototype.each = function(fn, scope) {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.util.IHashMap.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.util.IHashMap.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.util.IHashMap.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Retrieves an item with a particular key
 * @param {string=} key String The key to lookup.
 * @return {?} Object The value at that key. If it doesn't exist, undefined is returned.
 */
Ext.util.IHashMap.prototype.get = function(key) {};

/**
 * [Method] Gets the number of items in the hash
 * @return {number} Number The number of items in the hash.
 */
Ext.util.IHashMap.prototype.getCount = function() {};

/**
 * [Method] Extracts the key from an object
 * @param {?=} o Object The object to get the key from
 * @return {string} String The key to use.
 */
Ext.util.IHashMap.prototype.getKey = function(o) {};

/**
 * [Method] Return all of the keys in the hash
 * @return {!Array<?>} Array An array of keys.
 */
Ext.util.IHashMap.prototype.getKeys = function() {};

/**
 * [Method] Return all of the values in the hash
 * @return {!Array<?>} Array An array of values.
 */
Ext.util.IHashMap.prototype.getValues = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.util.IHashMap.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.IHashMap.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.util.IHashMap.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.IHashMap.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.util.IHashMap.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Remove an item from the hash
 * @param {?=} o Object The value of the item to remove.
 * @return {boolean} Boolean True if the item was successfully removed.
 */
Ext.util.IHashMap.prototype.remove = function(o) {};

/**
 * [Method] Remove an item from the hash
 * @param {string=} key String The key to remove.
 * @return {boolean} Boolean True if the item was successfully removed.
 */
Ext.util.IHashMap.prototype.removeAtKey = function(key) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.util.IHashMap.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.util.IHashMap.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Replaces an item in the hash
 * @param {string=} key String The key of the item.
 * @param {?=} value Object The new value for the item.
 * @return {?} Object The new value of the item.
 */
Ext.util.IHashMap.prototype.replace = function(key, value) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.util.IHashMap.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.util.IHashMap.prototype.resumeEvents = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.util.IHashMap.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.util.IHashMap.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.util.IHashMap.prototype.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.util.IHistory = function() {};
/**
 * @constructor
 * @struct
 */
Ext.util.History = function() {};
 /** @type {string} */
Ext.util.History.fieldId;
 /** @type {?} */
Ext.util.History.hasListeners;
 /** @type {string} */
Ext.util.History.iframeId;
 /** @type {boolean} */
Ext.util.History.isObservable;
 /** @type {!Ext.IClass} */
Ext.util.History.self;
 /** @type {boolean} */
Ext.util.History.useTopWindow;

/**
 * [Method] Add a new token to the history stack
 * @param {string=} token String The value that defines a particular application-specific history state
 * @param {boolean=} preventDuplicates Boolean When true, if the passed token matches the current token it will not save a new history step. Set to false if the same state can be saved more than once at the same history stack location.
 * @return {void}
 */
Ext.util.History.add = function(token, preventDuplicates) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.util.History.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.History.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.History.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Programmatically steps back one step in browser history equivalent to the user pressing the Back button
 * @return {void}
 */
Ext.util.History.back = function() {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.util.History.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.util.History.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.util.History.callSuper = function(args) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.util.History.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.util.History.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.util.History.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.util.History.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.util.History.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Programmatically steps forward one step in browser history equivalent to the user pressing the Forward button
 * @return {void}
 */
Ext.util.History.forward = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.util.History.getInitialConfig = function(name) {};

/**
 * [Method] Retrieves the currently active history token
 * @return {string} String The token
 */
Ext.util.History.getToken = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.util.History.hasListener = function(eventName) {};

/**
 * [Method] Initializes the global History instance
 * @param {?=} onReady Function A callback function that will be called once the history component is fully initialized.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed. Defaults to the browser window.
 * @return {void}
 */
Ext.util.History.init = function(onReady, scope) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.util.History.initConfig = function(config) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.History.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.util.History.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.History.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.util.History.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.util.History.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.util.History.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.util.History.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.util.History.resumeEvents = function() {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.util.History.statics = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.util.History.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.util.History.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.util.History.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.IBase}
 * @extends {Ext.util.IObservable}
 * @record
 * @struct
 */
Ext.IHistory = function() {};
/**
 * @constructor
 * @struct
 */
Ext.History = function() {};
 /** @type {string} */
Ext.History.fieldId;
 /** @type {?} */
Ext.History.hasListeners;
 /** @type {string} */
Ext.History.iframeId;
 /** @type {boolean} */
Ext.History.isObservable;
 /** @type {!Ext.IClass} */
Ext.History.self;
 /** @type {boolean} */
Ext.History.useTopWindow;

/**
 * [Method] Add a new token to the history stack
 * @param {string=} token String The value that defines a particular application-specific history state
 * @param {boolean=} preventDuplicates Boolean When true, if the passed token matches the current token it will not save a new history step. Set to false if the same state can be saved more than once at the same history stack location.
 * @return {void}
 */
Ext.History.add = function(token, preventDuplicates) {};

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.History.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.History.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.History.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Programmatically steps back one step in browser history equivalent to the user pressing the Back button
 * @return {void}
 */
Ext.History.back = function() {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.History.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.History.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.History.callSuper = function(args) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.History.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.History.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.History.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.History.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.History.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Programmatically steps forward one step in browser history equivalent to the user pressing the Forward button
 * @return {void}
 */
Ext.History.forward = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.History.getInitialConfig = function(name) {};

/**
 * [Method] Retrieves the currently active history token
 * @return {string} String The token
 */
Ext.History.getToken = function() {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.History.hasListener = function(eventName) {};

/**
 * [Method] Initializes the global History instance
 * @param {?=} onReady Function A callback function that will be called once the history component is fully initialized.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed. Defaults to the browser window.
 * @return {void}
 */
Ext.History.init = function(onReady, scope) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.History.initConfig = function(config) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.History.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.History.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.History.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.History.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.History.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.History.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.History.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.History.resumeEvents = function() {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.History.statics = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.History.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.History.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.History.un = function(eventName, fn, scope) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IInflector = function() {};
/**
 * @constructor
 * @struct
 */
Ext.util.Inflector = function() {};
 /** @type {!Ext.IClass} */
Ext.util.Inflector.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.util.Inflector.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.util.Inflector.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.util.Inflector.callSuper = function(args) {};

/**
 * [Method] Returns the correct Model name for a given string
 * @param {string=} word String The word to classify
 * @return {string} String The classified version of the word
 */
Ext.util.Inflector.classify = function(word) {};

/**
 * [Method] Removes all registered pluralization rules
 * @return {void}
 */
Ext.util.Inflector.clearPlurals = function() {};

/**
 * [Method] Removes all registered singularization rules
 * @return {void}
 */
Ext.util.Inflector.clearSingulars = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.util.Inflector.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.util.Inflector.initConfig = function(config) {};

/**
 * [Method] Returns true if the given word is transnumeral the word is its own singular and plural form  e g
 * @param {string=} word String The word to test
 * @return {boolean} Boolean True if the word is transnumeral
 */
Ext.util.Inflector.isTransnumeral = function(word) {};

/**
 * [Method] Ordinalizes a given number by adding a prefix such as st nd rd or th based on the last digit of the number
 * @param {number=} number Number The number to ordinalize
 * @return {string} String The ordinalized number
 */
Ext.util.Inflector.ordinalize = function(number) {};

/**
 * [Method] Adds a new pluralization rule to the Inflector
 * @param {!RegExp=} matcher RegExp The matcher regex
 * @param {string=} replacer String The replacement string, which can reference matches from the matcher argument
 * @return {void}
 */
Ext.util.Inflector.plural = function(matcher, replacer) {};

/**
 * [Method] Returns the pluralized form of a word e g
 * @param {string=} word String The word to pluralize
 * @return {string} String The pluralized form of the word
 */
Ext.util.Inflector.pluralize = function(word) {};

/**
 * [Method] Adds a new singularization rule to the Inflector
 * @param {!RegExp=} matcher RegExp The matcher regex
 * @param {string=} replacer String The replacement string, which can reference matches from the matcher argument
 * @return {void}
 */
Ext.util.Inflector.singular = function(matcher, replacer) {};

/**
 * [Method] Returns the singularized form of a word e g
 * @param {string=} word String The word to singularize
 * @return {string} String The singularized form of the word
 */
Ext.util.Inflector.singularize = function(word) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.util.Inflector.statics = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IKeyMap = function() {};
 /** @type {?} */
Ext.util.IKeyMap.prototype.binding;
 /** @type {string} */
Ext.util.IKeyMap.prototype.eventName;
 /** @type {boolean} */
Ext.util.IKeyMap.prototype.ignoreInputFields;
 /** @type {?} */
Ext.util.IKeyMap.prototype.processEvent;
 /** @type {?} */
Ext.util.IKeyMap.prototype.processEventScope;
 /** @type {?} */
Ext.util.IKeyMap.prototype.target;

/**
 * [Method] Add a new binding to this KeyMap
 * @param {?=} binding Object/Object[] A single KeyMap config or an array of configs. The following config object properties are supported:
 * @return {void}
 */
Ext.util.IKeyMap.prototype.addBinding = function(binding) {};

/**
 * [Method] Destroys the KeyMap instance and removes all handlers
 * @param {boolean=} removeTarget Boolean True to also remove the target
 * @return {void}
 */
Ext.util.IKeyMap.prototype.destroy = function(removeTarget) {};

/**
 * [Method] Disable this KeyMap
 * @return {void}
 */
Ext.util.IKeyMap.prototype.disable = function() {};

/**
 * [Method] Enables this KeyMap
 * @return {void}
 */
Ext.util.IKeyMap.prototype.enable = function() {};

/**
 * [Method] Returns true if this KeyMap is enabled
 * @return {boolean} Boolean
 */
Ext.util.IKeyMap.prototype.isEnabled = function() {};

/**
 * [Method] Shorthand for adding a single key listener
 * @param {?=} key Number/Number[]/Object Either the numeric key code, array of key codes or an object with the following options: {key: (number or array), shift: (true/false), ctrl: (true/false), alt: (true/false)}
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {void}
 */
Ext.util.IKeyMap.prototype.on = function(key, fn, scope) {};

/**
 * [Method] Remove a binding from this KeyMap
 * @param {?=} binding Object See for options
 * @return {void}
 */
Ext.util.IKeyMap.prototype.removeBinding = function(binding) {};

/**
 * [Method] Convenience function for setting disabled enabled by boolean
 * @param {boolean=} disabled Boolean
 * @return {void}
 */
Ext.util.IKeyMap.prototype.setDisabled = function(disabled) {};

/**
 * [Method] Shorthand for removing a single key listener
 * @param {?=} key Number/Number[]/Object Either the numeric key code, array of key codes or an object with the following options: {key: (number or array), shift: (true/false), ctrl: (true/false), alt: (true/false)}
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {void}
 */
Ext.util.IKeyMap.prototype.un = function(key, fn, scope) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IKeyMap = function() {};
 /** @type {?} */
Ext.IKeyMap.prototype.binding;
 /** @type {string} */
Ext.IKeyMap.prototype.eventName;
 /** @type {boolean} */
Ext.IKeyMap.prototype.ignoreInputFields;
 /** @type {?} */
Ext.IKeyMap.prototype.processEvent;
 /** @type {?} */
Ext.IKeyMap.prototype.processEventScope;
 /** @type {?} */
Ext.IKeyMap.prototype.target;

/**
 * [Method] Add a new binding to this KeyMap
 * @param {?=} binding Object/Object[] A single KeyMap config or an array of configs. The following config object properties are supported:
 * @return {void}
 */
Ext.IKeyMap.prototype.addBinding = function(binding) {};

/**
 * [Method] Destroys the KeyMap instance and removes all handlers
 * @param {boolean=} removeTarget Boolean True to also remove the target
 * @return {void}
 */
Ext.IKeyMap.prototype.destroy = function(removeTarget) {};

/**
 * [Method] Disable this KeyMap
 * @return {void}
 */
Ext.IKeyMap.prototype.disable = function() {};

/**
 * [Method] Enables this KeyMap
 * @return {void}
 */
Ext.IKeyMap.prototype.enable = function() {};

/**
 * [Method] Returns true if this KeyMap is enabled
 * @return {boolean} Boolean
 */
Ext.IKeyMap.prototype.isEnabled = function() {};

/**
 * [Method] Shorthand for adding a single key listener
 * @param {?=} key Number/Number[]/Object Either the numeric key code, array of key codes or an object with the following options: {key: (number or array), shift: (true/false), ctrl: (true/false), alt: (true/false)}
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {void}
 */
Ext.IKeyMap.prototype.on = function(key, fn, scope) {};

/**
 * [Method] Remove a binding from this KeyMap
 * @param {?=} binding Object See for options
 * @return {void}
 */
Ext.IKeyMap.prototype.removeBinding = function(binding) {};

/**
 * [Method] Convenience function for setting disabled enabled by boolean
 * @param {boolean=} disabled Boolean
 * @return {void}
 */
Ext.IKeyMap.prototype.setDisabled = function(disabled) {};

/**
 * [Method] Shorthand for removing a single key listener
 * @param {?=} key Number/Number[]/Object Either the numeric key code, array of key codes or an object with the following options: {key: (number or array), shift: (true/false), ctrl: (true/false), alt: (true/false)}
 * @param {?=} fn Function The function to call
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the browser window.
 * @return {void}
 */
Ext.IKeyMap.prototype.un = function(key, fn, scope) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IKeyNav = function() {};
 /** @type {string} */
Ext.util.IKeyNav.prototype.defaultEventAction;
 /** @type {boolean} */
Ext.util.IKeyNav.prototype.disabled;
 /** @type {string} */
Ext.util.IKeyNav.prototype.eventName;
 /** @type {boolean} */
Ext.util.IKeyNav.prototype.forceKeyDown;
 /** @type {boolean} */
Ext.util.IKeyNav.prototype.ignoreInputFields;
 /** @type {!Ext.util.IKeyMap} */
Ext.util.IKeyNav.prototype.keyMap;
 /** @type {?} */
Ext.util.IKeyNav.prototype.processEvent;
 /** @type {?} */
Ext.util.IKeyNav.prototype.processEventScope;
 /** @type {?} */
Ext.util.IKeyNav.prototype.target;

/**
 * [Method] Destroy this KeyNav
 * @param {boolean=} removeEl Boolean Pass true to remove the element associated with this KeyNav.
 * @return {void}
 */
Ext.util.IKeyNav.prototype.destroy = function(removeEl) {};

/**
 * [Method] Disables this KeyNav
 * @return {void}
 */
Ext.util.IKeyNav.prototype.disable = function() {};

/**
 * [Method] Enables this KeyNav
 * @return {void}
 */
Ext.util.IKeyNav.prototype.enable = function() {};

/**
 * [Method] Convenience function for setting disabled enabled by boolean
 * @param {boolean=} disabled Boolean
 * @return {void}
 */
Ext.util.IKeyNav.prototype.setDisabled = function(disabled) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IKeyNav = function() {};
 /** @type {string} */
Ext.IKeyNav.prototype.defaultEventAction;
 /** @type {boolean} */
Ext.IKeyNav.prototype.disabled;
 /** @type {string} */
Ext.IKeyNav.prototype.eventName;
 /** @type {boolean} */
Ext.IKeyNav.prototype.forceKeyDown;
 /** @type {boolean} */
Ext.IKeyNav.prototype.ignoreInputFields;
 /** @type {!Ext.util.IKeyMap} */
Ext.IKeyNav.prototype.keyMap;
 /** @type {?} */
Ext.IKeyNav.prototype.processEvent;
 /** @type {?} */
Ext.IKeyNav.prototype.processEventScope;
 /** @type {?} */
Ext.IKeyNav.prototype.target;

/**
 * [Method] Destroy this KeyNav
 * @param {boolean=} removeEl Boolean Pass true to remove the element associated with this KeyNav.
 * @return {void}
 */
Ext.IKeyNav.prototype.destroy = function(removeEl) {};

/**
 * [Method] Disables this KeyNav
 * @return {void}
 */
Ext.IKeyNav.prototype.disable = function() {};

/**
 * [Method] Enables this KeyNav
 * @return {void}
 */
Ext.IKeyNav.prototype.enable = function() {};

/**
 * [Method] Convenience function for setting disabled enabled by boolean
 * @param {boolean=} disabled Boolean
 * @return {void}
 */
Ext.IKeyNav.prototype.setDisabled = function(disabled) {};
/**
 * @extends {Ext.util.IHashMap}
 * @record
 * @struct
 */
Ext.util.ILruCache = function() {};
 /** @type {number} */
Ext.util.ILruCache.prototype.maxSize;

/**
 * [Method] Adds an item to the collection
 * @param {?=} key Object
 * @param {?=} newValue Object
 * @return {?} Object The item added.
 */
Ext.util.ILruCache.prototype.add = function(key, newValue) {};

/**
 * [Method] Removes all items from the hash
 * @param {?=} initial Object
 * @return {!Ext.util.IHashMap} Ext.util.HashMap this
 */
Ext.util.ILruCache.prototype.clear = function(initial) {};

/**
 * [Method] Performs a shallow copy on this haLruCachesh
 * @return {!Ext.util.IHashMap} Ext.util.HashMap The new hash object.
 */
Ext.util.ILruCache.prototype.clone = function() {};

/**
 * [Method] Executes the specified function once for each item in the cache
 * @param {?=} fn Function The function to execute.
 * @param {?=} scope Object The scope (this reference) to execute in. Defaults to this LruCache.
 * @param {boolean=} reverse Boolean Pass true to iterate the list in reverse (most recent first) order.
 * @return {!Ext.util.ILruCache} Ext.util.LruCache this
 */
Ext.util.ILruCache.prototype.each = function(fn, scope, reverse) {};

/**
 * [Method] Retrieves an item with a particular key
 * @param {?=} key Object
 * @return {?} Object The value at that key. If it doesn't exist, undefined is returned.
 */
Ext.util.ILruCache.prototype.get = function(key) {};

/**
 * [Method] Purge the least recently used entries if the maxSize has been exceeded
 * @return {void}
 */
Ext.util.ILruCache.prototype.prune = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IMemento = function() {};
 /** @type {?} */
Ext.util.IMemento.prototype.target;

/**
 * [Method] Captures the specified properties from the target object in this memento
 * @param {?=} props String/String[] The property or array of properties to capture.
 * @param {?=} target Object The object from which to capture properties.
 * @return {void}
 */
Ext.util.IMemento.prototype.capture = function(props, target) {};

/**
 * [Method] Removes the specified properties from this memento
 * @param {?=} props String/String[] The property or array of properties to remove.
 * @return {void}
 */
Ext.util.IMemento.prototype.remove = function(props) {};

/**
 * [Method] Restores the specified properties from this memento to the target object
 * @param {?=} props String/String[] The property or array of properties to restore.
 * @param {boolean=} clear Boolean True to remove the restored properties from this memento or false to keep them (default is true).
 * @param {?=} target Object The object to which to restore properties.
 * @return {void}
 */
Ext.util.IMemento.prototype.restore = function(props, clear, target) {};

/**
 * [Method] Restores all captured properties in this memento to the target object
 * @param {boolean=} clear Boolean True to remove the restored properties from this memento or false to keep them (default is true).
 * @param {?=} target Object The object to which to restore properties.
 * @return {void}
 */
Ext.util.IMemento.prototype.restoreAll = function(clear, target) {};
/**
 * @extends {Ext.util.IAbstractMixedCollection}
 * @extends {Ext.util.ISortable}
 * @record
 * @struct
 */
Ext.util.IMixedCollection = function() {};
 /** @type {boolean} */
Ext.util.IMixedCollection.prototype.allowFunctions;

/**
 * [Method] Calculates the insertion index of the new item based upon the comparison function passed or the current sort order
 * @param {?=} newItem Object The new object to find the insertion position of.
 * @param {?=} sorterFn Function The function to sort by. This is the same as the sorting function passed to sortBy. It accepts 2 items from this MixedCollection, and returns -1 0, or 1 depending on the relative sort positions of the 2 compared items. If omitted, a function generated from the currently defined set of sorters will be used.
 * @return {number} Number The insertion point to add the new item into this MixedCollection at using insert
 */
Ext.util.IMixedCollection.prototype.findInsertionIndex = function(newItem, sorterFn) {};

/**
 * [Method] Returns a comparator function which compares two items and returns 1 0 or 1 depending on the currently defined set
 * @return {void}
 */
Ext.util.IMixedCollection.prototype.generateComparator = function() {};

/**
 * [Method] Gets the first sorter from the sorters collection excluding any groupers that may be in place
 * @return {!Ext.util.ISorter} Ext.util.Sorter The sorter, null if none exist
 */
Ext.util.IMixedCollection.prototype.getFirstSorter = function() {};

/**
 * [Method] Performs initialization of this mixin
 * @return {void}
 */
Ext.util.IMixedCollection.prototype.initSortable = function() {};

/**
 * [Method] Reorders each of the items based on a mapping from old index to new index
 * @param {?=} mapping Object Mapping from old item index to new item index
 * @return {void}
 */
Ext.util.IMixedCollection.prototype.reorder = function(mapping) {};

/**
 * [Method] Sorts the data in the Store by one or more of its properties
 * @param {?=} sorters String/Ext.util.Sorter[] Either a string name of one of the fields in this Store's configured Model, or an array of sorter configurations.
 * @param {string=} direction String The overall direction to sort the data by.
 * @return {!Array<!Ext.util.ISorter>} Ext.util.Sorter[]
 */
Ext.util.IMixedCollection.prototype.sort = function(sorters, direction) {};

/**
 * [Method] Sorts the collection by a single sorter function
 * @param {?=} sorterFn Function The function to sort by
 * @return {void}
 */
Ext.util.IMixedCollection.prototype.sortBy = function(sorterFn) {};

/**
 * [Method] Sorts this collection by keys
 * @param {string=} direction String 'ASC' or 'DESC'. Defaults to 'ASC'.
 * @param {?=} fn Function Comparison function that defines the sort order. Defaults to sorting by case insensitive string.
 * @return {void}
 */
Ext.util.IMixedCollection.prototype.sortByKey = function(direction, fn) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IObservable = function() {};
 /** @type {?} */
Ext.util.IObservable.prototype.listeners;
 /** @type {?} */
Ext.util.IObservable.prototype.hasListeners;
 /** @type {boolean} */
Ext.util.IObservable.prototype.isObservable;

/**
 * [Method] Adds the specified events to the list of events which this Observable may fire
 * @param {?=} eventNames Object/String... Either an object with event names as properties with a value of true. For example: this.addEvents({  storeloaded: true,  storecleared: true });  Or any number of event names as separate parameters. For example: this.addEvents('storeloaded', 'storecleared');
 * @return {void}
 */
Ext.util.IObservable.prototype.addEvents = function(eventNames) {};

/**
 * [Method] Appends an event handler to this object
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.IObservable.prototype.addListener = function(eventName, fn, scope, options) {};

/**
 * [Method] Adds listeners to any Observable object or Ext Element which are automatically removed when this Component is destr
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.IObservable.prototype.addManagedListener = function(item, ename, fn, scope, options) {};

/**
 * [Method] Removes all listeners for this object including the managed listeners
 * @return {void}
 */
Ext.util.IObservable.prototype.clearListeners = function() {};

/**
 * [Method] Removes all managed listeners for this object
 * @return {void}
 */
Ext.util.IObservable.prototype.clearManagedListeners = function() {};

/**
 * [Method] Enables events fired by this Observable to bubble up an owner hierarchy by calling this getBubbleTarget  if present
 * @param {?=} eventNames String/String[] The event name to bubble, or an Array of event names.
 * @return {void}
 */
Ext.util.IObservable.prototype.enableBubble = function(eventNames) {};

/**
 * [Method] Fires the specified event with the passed parameters minus the event name plus the options object passed to addList
 * @param {string} eventName String The name of the event to fire.
 * @param {...?} args Object... Variable number of parameters are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.util.IObservable.prototype.fireEvent = function(eventName, args) {};

/**
 * [Method] Fires the specified event with the passed parameter list
 * @param {string=} eventName String The name of the event to fire.
 * @param {!Array<?>=} args Object[] An array of parameters which are passed to handlers.
 * @return {boolean} Boolean returns false if any of the handlers return false otherwise it returns true.
 */
Ext.util.IObservable.prototype.fireEventArgs = function(eventName, args) {};

/**
 * [Method] Checks to see if this object has any listeners for a specified event or whether the event bubbles
 * @param {string=} eventName String The name of the event to check for
 * @return {boolean} Boolean true if the event is being listened for or bubbles, else false
 */
Ext.util.IObservable.prototype.hasListener = function(eventName) {};

/**
 * [Method] Shorthand for addManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item to which to add a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @param {?=} options Object If the ename parameter was an event name, this is the addListener options.
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.mon({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.IObservable.prototype.mon = function(item, ename, fn, scope, options) {};

/**
 * [Method] Shorthand for removeManagedListener
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.util.IObservable.prototype.mun = function(item, ename, fn, scope) {};

/**
 * [Method] Shorthand for addListener
 * @param {?=} eventName String/Object The name of the event to listen for. May also be an object who's property names are event names.
 * @param {?=} fn Function The method the event invokes, or if scope is specified, the name* of the method within the specified scope. Will be called with arguments given to Ext.util.Observable.fireEvent plus the options parameter described below.
 * @param {?=} scope Object The scope (this reference) in which the handler function is executed. If omitted, defaults to the object which fired the event.
 * @param {?=} options Object An object containing handler configuration.  Note: Unlike in ExtJS 3.x, the options object will also be passed as the last argument to every event handler.  This object may contain any of the following properties:
 * @return {?} Object Only when the destroyable option is specified.  A Destroyable object. An object which implements the destroy method which removes all listeners added in this call. For example:  this.btnListeners = = myButton.on({  destroyable: true  mouseover:  function() { console.log('mouseover'); },  mouseout: function() { console.log('mouseout'); },  click:  function() { console.log('click'); } }); And when those listeners need to be removed:  Ext.destroy(this.btnListeners); or  this.btnListeners.destroy();
 */
Ext.util.IObservable.prototype.on = function(eventName, fn, scope, options) {};

/**
 * [Method] Relays selected events from the specified Observable as if the events were fired by this
 * @param {?=} origin Object The Observable whose events this object is to relay.
 * @param {!Array<string>=} events String[] Array of event names to relay.
 * @param {string=} prefix String A common prefix to prepend to the event names. For example: this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
 * @return {?} Object A Destroyable object. An object which implements the destroy method which, when destroyed, removes all relayers. For example: this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');  Can be undone by calling Ext.destroy(this.storeRelayers);  or this.store.relayers.destroy();
 */
Ext.util.IObservable.prototype.relayEvents = function(origin, events, prefix) {};

/**
 * [Method] Removes an event handler
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.util.IObservable.prototype.removeListener = function(eventName, fn, scope) {};

/**
 * [Method] Removes listeners that were added by the mon method
 * @param {?=} item Ext.util.Observable/Ext.Element The item from which to remove a listener/listeners.
 * @param {?=} ename Object/String The event name, or an object containing event name properties.
 * @param {?=} fn Function If the ename parameter was an event name, this is the handler function.
 * @param {?=} scope Object If the ename parameter was an event name, this is the scope (this reference) in which the handler function is executed.
 * @return {void}
 */
Ext.util.IObservable.prototype.removeManagedListener = function(item, ename, fn, scope) {};

/**
 * [Method] Resumes firing of the named event s
 * @param {...?} eventName String... Multiple event names to resume.
 * @return {void}
 */
Ext.util.IObservable.prototype.resumeEvent = function(eventName) {};

/**
 * [Method] Resumes firing events see suspendEvents
 * @return {void}
 */
Ext.util.IObservable.prototype.resumeEvents = function() {};

/**
 * [Method] Suspends firing of the named event s
 * @param {...?} eventName String... Multiple event names to suspend.
 * @return {void}
 */
Ext.util.IObservable.prototype.suspendEvent = function(eventName) {};

/**
 * [Method] Suspends the firing of all events
 * @param {boolean=} queueSuspended Boolean Pass as true to queue up suspended events to be fired after the resumeEvents call instead of discarding all suspended events.
 * @return {void}
 */
Ext.util.IObservable.prototype.suspendEvents = function(queueSuspended) {};

/**
 * [Method] Shorthand for removeListener
 * @param {string=} eventName String The type of event the handler was associated with.
 * @param {?=} fn Function The handler to remove. This must be a reference to the function passed into the Ext.util.Observable.addListener call.
 * @param {?=} scope Object The scope originally specified for the handler. It must be the same as the scope argument specified in the original call to Ext.util.Observable.addListener or the listener will not be removed.
 * @return {void}
 */
Ext.util.IObservable.prototype.un = function(eventName, fn, scope) {};
/**
 * @constructor
 * @struct
 */
Ext.util.Observable = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.util.Observable.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.util.Observable.addStatics = function(members) {};

/**
 * [Method] Starts capture on the specified Observable
 * @param {!Ext.util.IObservable=} o Ext.util.Observable The Observable to capture events from.
 * @param {?=} fn Function The function to call when an event is fired.
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the Observable firing the event.
 * @return {void}
 */
Ext.util.Observable.capture = function(o, fn, scope) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.util.Observable.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.util.Observable.createAlias = function(alias, origin) {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.util.Observable.getName = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.util.Observable.implement = function() {};

/**
 * [Method] Sets observability on the passed class constructor
 * @param {?=} c Function The class constructor to make observable.
 * @param {?=} listeners Object An object containing a series of listeners to add. See addListener.
 * @return {void}
 */
Ext.util.Observable.observe = function(c, listeners) {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.util.Observable.override = function(members) {};

/**
 * [Method] Removes all added captures from the Observable
 * @param {!Ext.util.IObservable=} o Ext.util.Observable The Observable to release
 * @return {void}
 */
Ext.util.Observable.releaseCapture = function(o) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IOffset = function() {};
/**
 * @extends {Ext.util.IRegion}
 * @record
 * @struct
 */
Ext.util.IPoint = function() {};

/**
 * [Method] Compare this point and another point
 * @param {?=} p Ext.util.Point/Object The point to compare with, either an instance of Ext.util.Point or an object with left and top properties
 * @return {boolean} Boolean Returns whether they are equivalent
 */
Ext.util.IPoint.prototype.equals = function(p) {};

/**
 * [Method] Determins whether this Point contained by the passed Region Component or element
 * @param {?=} region Ext.util.Region/Ext.Component/Ext.dom.Element/HTMLElement The rectangle to check that this Point is within.
 * @return {boolean} Boolean
 */
Ext.util.IPoint.prototype.isContainedBy = function(region) {};

/**
 * [Method] Whether the given point is not away from this point within the given threshold amount
 * @param {?=} p Ext.util.Point/Object The point to check with, either an instance of Ext.util.Point or an object with left and top properties
 * @param {?=} threshold Object/Number Can be either an object with x and y properties or a number
 * @return {boolean} Boolean
 */
Ext.util.IPoint.prototype.isWithin = function(p, threshold) {};

/**
 * [Method] Compare this point with another point when the x and y values of both points are rounded
 * @param {?=} p Ext.util.Point/Object The point to compare with, either an instance of Ext.util.Point or an object with x and y properties
 * @return {boolean} Boolean
 */
Ext.util.IPoint.prototype.roundedEquals = function(p) {};

/**
 * [Method] Returns a human eye friendly string that represents this point useful for debugging
 * @return {string} String
 */
Ext.util.IPoint.prototype.toString = function() {};

/**
 * [Method] Alias for translateBy
 * @param {?=} x Ext.util.Offset/Object Object containing the x and y properties. Or the x value is using the two argument form.
 * @param {number=} y Number The y value unless using an Offset object.
 * @return {!Ext.util.IRegion} Ext.util.Region this This Region
 */
Ext.util.IPoint.prototype.translate = function(x, y) {};
/**
 * @constructor
 * @struct
 */
Ext.util.Point = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.util.Point.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.util.Point.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.util.Point.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.util.Point.createAlias = function(alias, origin) {};

/**
 * [Method] Returns a new instance of Ext util Point base on the pageX  pageY values of the given event
 * @param {?=} e Ext.EventObject/Event The event
 * @return {!Ext.util.IPoint} Ext.util.Point
 */
Ext.util.Point.fromEvent = function(e) {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.util.Point.getName = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.util.Point.implement = function() {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.util.Point.override = function(members) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IPositionable = function() {};

/**
 * [Method] Aligns the element with another element relative to the specified anchor points
 * @param {?=} element Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or id of the element to align to.
 * @param {string=} position String The position to align to
 * @param {!Array<number>=} offsets Number[] Offset the positioning by [x, y]
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.util.IPositionable.prototype.alignTo = function(element, position, offsets, animate) {};

/**
 * [Method] Anchors an element to another element and realigns it when the window is resized
 * @param {?=} element Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or id of the element to align to.
 * @param {string=} position String The position to align to
 * @param {!Array<number>=} offsets Number[] Offset the positioning by [x, y]
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @param {?=} monitorScroll Boolean/Number True to monitor body scroll and reposition. If this parameter is a number, it is used as the buffer delay in milliseconds.
 * @param {?=} callback Function The function to call after the animation finishes
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.util.IPositionable.prototype.anchorTo = function(element, position, offsets, animate, monitorScroll, callback) {};

/**
 * [Method] Calculates the new x y position to move this Positionable into a constrain region
 * @param {?=} constrainTo String/HTMLElement/Ext.Element/Ext.util.Region The Element or Region into which this Component is to be constrained. Defaults to the element into which this Positionable was rendered, or this Component's {\@link Ext.Component.constrainTo.
 * @param {!Array<number>=} proposedPosition Number[] A proposed [X, Y] position to test for validity and to coerce into constraints instead of using this Positionable's current position.
 * @param {boolean=} local Boolean The proposedPosition is local (relative to floatParent if a floating Component)
 * @param {!Array<number>=} proposedSize Number[] A proposed [width, height] size to use when calculating constraints instead of using this Positionable's current size.
 * @return {!Array<number>} Number[] If the element needs to be translated, the new [X, Y] position within constraints if possible, giving priority to keeping the top and left edge in the constrain region. Otherwise, false.
 */
Ext.util.IPositionable.prototype.calculateConstrainedPosition = function(constrainTo, proposedPosition, local, proposedSize) {};

/**
 * [Method] Gets the x y coordinates to align this element with another element
 * @param {?=} element Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or id of the element to align to.
 * @param {string=} position String The position to align to
 * @param {!Array<number>=} offsets Number[] Offset the positioning by [x, y]
 * @return {!Array<number>} Number[] [x, y]
 */
Ext.util.IPositionable.prototype.getAlignToXY = function(element, position, offsets) {};

/**
 * [Method] Gets the x y coordinates specified by the anchor position on the element
 * @param {string=} anchor String The specified anchor position. See alignTo for details on supported anchor positions.
 * @param {boolean=} local Boolean True to get the local (element top/left-relative) anchor position instead of page coordinates
 * @param {?=} size Object An object containing the size to use for calculating anchor position {width: (target width), height: (target height)} (defaults to the element's current size)
 * @return {!Array<number>} Number[] [x, y] An array containing the element's x and y coordinates
 */
Ext.util.IPositionable.prototype.getAnchorXY = function(anchor, local, size) {};

/**
 * [Method] Return an object defining the area of this Element which can be passed to setBox to set another Element s size locati
 * @param {boolean=} contentBox Boolean If true a box for the content of the element is returned.
 * @param {boolean=} local Boolean If true the element's left and top relative to its offsetParent are returned instead of page x/y.
 * @return {?} Object box An object in the format: {  x: &lt;Element's X position&gt;,  y: &lt;Element's Y position&gt;,  left: &lt;Element's X position (an alias for x)&gt;,  top: &lt;Element's Y position (an alias for y)&gt;,  width: &lt;Element's width&gt;,  height: &lt;Element's height&gt;,  bottom: &lt;Element's lower bound&gt;,  right: &lt;Element's rightmost bound&gt; }  The returned object may also be addressed as an Array where index 0 contains the X position and index 1 contains the Y position. The result may also be used for setXY
 */
Ext.util.IPositionable.prototype.getBox = function(contentBox, local) {};

/**
 * [Method] Returns the X Y vector by which this Positionable s element must be translated to make a best attempt to constrain
 * @param {?=} constrainTo Ext.util.Positionable/HTMLElement/String/Ext.util.Region The Positionable, HTMLElement, element id, or Region into which the element is to be constrained.
 * @param {!Array<number>=} proposedPosition Number[] A proposed [X, Y] position to test for validity and to produce a vector for instead of using the element's current position
 * @param {!Array<number>=} proposedSize Number[] A proposed [width, height] size to constrain instead of using the element's current size
 * @return {?} Number[]/Boolean If the element needs to be translated, an [X, Y] vector by which this element must be translated. Otherwise, false.
 */
Ext.util.IPositionable.prototype.getConstrainVector = function(constrainTo, proposedPosition, proposedSize) {};

/**
 * [Method] Returns the x coordinate of this element reletive to its offsetParent
 * @return {number} Number The local x coordinate
 */
Ext.util.IPositionable.prototype.getLocalX = function() {};

/**
 * [Method] Returns the x and y coordinates of this element relative to its offsetParent
 * @return {!Array<number>} Number[] The local XY position of the element
 */
Ext.util.IPositionable.prototype.getLocalXY = function() {};

/**
 * [Method] Returns the y coordinate of this element reletive to its offsetParent
 * @return {number} Number The local y coordinate
 */
Ext.util.IPositionable.prototype.getLocalY = function() {};

/**
 * [Method] Returns the offsets of this element from the passed element
 * @param {?=} offsetsTo Ext.util.Positionable/HTMLElement/String The Positionable, HTMLElement, or element id to get get the offsets from.
 * @return {!Array<number>} Number[] The XY page offsets (e.g. [100, -200])
 */
Ext.util.IPositionable.prototype.getOffsetsTo = function(offsetsTo) {};

/**
 * [Method] Returns a region object that defines the area of this element
 * @return {!Ext.util.IRegion} Ext.util.Region A Region containing "top, left, bottom, right" properties.
 */
Ext.util.IPositionable.prototype.getRegion = function() {};

/**
 * [Method] Returns the content region of this element
 * @return {!Ext.util.IRegion} Ext.util.Region A Region containing "top, left, bottom, right" member data.
 */
Ext.util.IPositionable.prototype.getViewRegion = function() {};

/**
 * [Method] Gets the current X position of the DOM element based on page coordinates
 * @return {number} Number The X position of the element
 */
Ext.util.IPositionable.prototype.getX = function() {};

/**
 * [Method] Gets the current position of the DOM element based on page coordinates
 * @return {!Array<number>} Number[] The XY position of the element
 */
Ext.util.IPositionable.prototype.getXY = function() {};

/**
 * [Method] Gets the current Y position of the DOM element based on page coordinates
 * @return {number} Number The Y position of the element
 */
Ext.util.IPositionable.prototype.getY = function() {};

/**
 * [Method] Move the element relative to its current position
 * @param {string=} direction String Possible values are:  "l" (or "left") "r" (or "right") "t" (or "top", or "up") "b" (or "bottom", or "down")
 * @param {number=} distance Number How far to move the element in pixels
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {void}
 */
Ext.util.IPositionable.prototype.move = function(direction, distance, animate) {};

/**
 * [Method] Remove any anchor to this element
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.util.IPositionable.prototype.removeAnchor = function() {};

/**
 * [Method] Sets the element s box
 * @param {?=} box Object The box to fill {x, y, width, height}
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.util.IPositionable.prototype.setBox = function(box, animate) {};

/**
 * [Method] Sets the local x coordinate of this element using CSS style
 * @param {number=} x Number The x coordinate. A value of null sets the left style to 'auto'.
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.util.IPositionable.prototype.setLocalX = function(x) {};

/**
 * [Method] Sets the local x and y coordinates of this element using CSS style
 * @param {?=} x Number/Array The x coordinate or an array containing [x, y]. A value of null sets the left style to 'auto'
 * @param {number=} y Number The y coordinate, required if x is not an array. A value of null sets the top style to 'auto'
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.util.IPositionable.prototype.setLocalXY = function(x, y) {};

/**
 * [Method] Sets the local y coordinate of this element using CSS style
 * @param {number=} y Number The y coordinate. A value of null sets the top style to 'auto'.
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.util.IPositionable.prototype.setLocalY = function(y) {};

/**
 * [Method] Sets the element s position and size to the specified region
 * @param {!Ext.util.IRegion=} region Ext.util.Region The region to fill
 * @param {?=} animate Boolean/Object true for the default animation or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.util.IPositionable.prototype.setRegion = function(region, animate) {};

/**
 * [Method] Sets the X position of the DOM element based on page coordinates
 * @param {number=} The Number X position
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.util.IPositionable.prototype.setX = function(The, animate) {};

/**
 * [Method] Sets the position of the DOM element in page coordinates
 * @param {!Array<number>=} pos Number[] Contains X &amp; Y [x, y] values for new position (coordinates are page-based)
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.util.IPositionable.prototype.setXY = function(pos, animate) {};

/**
 * [Method] Sets the Y position of the DOM element based on page coordinates
 * @param {number=} The Number Y position
 * @param {?=} animate Boolean/Object True for the default animation, or a standard Element animation config object
 * @return {!Ext.util.IPositionable} Ext.util.Positionable this
 */
Ext.util.IPositionable.prototype.setY = function(The, animate) {};

/**
 * [Method] Translates the passed page coordinates into left top css values for the element
 * @param {?=} x Number/Array The page x or an array containing [x, y]
 * @param {number=} y Number The page y, required if x is not an array
 * @return {?} Object An object with left and top properties. e.g. {left: (value), top: (value)}
 */
Ext.util.IPositionable.prototype.translatePoints = function(x, y) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IProtoElement = function() {};
 /** @type {string} */
Ext.util.IProtoElement.prototype.clsProp;
 /** @type {string} */
Ext.util.IProtoElement.prototype.removedProp;
 /** @type {boolean} */
Ext.util.IProtoElement.prototype.styleIsText;
 /** @type {string} */
Ext.util.IProtoElement.prototype.styleProp;

/**
 * [Method] Adds class to the element
 * @param {string=} cls String One or more classnames separated with spaces.
 * @return {!Ext.util.IProtoElement} Ext.util.ProtoElement this
 */
Ext.util.IProtoElement.prototype.addCls = function(cls) {};

/**
 * [Method] Indicates that the current state of the object has been flushed to the DOM so we need to track any subsequent changes
 * @return {void}
 */
Ext.util.IProtoElement.prototype.flush = function() {};

/**
 * [Method] True if the element has given class
 * @param {string=} cls String
 * @return {boolean} Boolean
 */
Ext.util.IProtoElement.prototype.hasCls = function(cls) {};

/**
 * [Method] Removes class from the element
 * @param {string=} cls String One or more classnames separated with spaces.
 * @return {!Ext.util.IProtoElement} Ext.util.ProtoElement this
 */
Ext.util.IProtoElement.prototype.removeCls = function(cls) {};

/**
 * [Method] Adds styles to the element
 * @param {?=} prop String/Object The style property to be set, or an object of multiple styles.
 * @param {string=} value String The value to apply to the given property.
 * @return {!Ext.util.IProtoElement} Ext.util.ProtoElement this
 */
Ext.util.IProtoElement.prototype.setStyle = function(prop, value) {};

/**
 * [Method] Writes style and class properties to given object
 * @param {?=} to Object
 * @return {?} Object to
 */
Ext.util.IProtoElement.prototype.writeTo = function(to) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IQueue = function() {};

/**
 * [Method] Removes all items from the collection
 * @return {void}
 */
Ext.util.IQueue.prototype.clear = function() {};

/**
 * [Method] Returns the number of items in the collection
 * @return {number} Number the number of items in the collection.
 */
Ext.util.IQueue.prototype.getCount = function() {};

/**
 * [Method] Remove an item from the collection
 * @param {?=} obj Object The item to remove.
 * @return {?} Object The item removed or false if no item was removed.
 */
Ext.util.IQueue.prototype.remove = function(obj) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IRegion = function() {};

/**
 * [Method] Modifies the current region to be adjusted by offsets
 * @param {number=} top Number top offset
 * @param {number=} right Number right offset
 * @param {number=} bottom Number bottom offset
 * @param {number=} left Number left offset
 * @return {!Ext.util.IRegion} Ext.util.Region this
 */
Ext.util.IRegion.prototype.adjust = function(top, right, bottom, left) {};

/**
 * [Method] Modifies the current region to be constrained to the targetRegion
 * @param {!Ext.util.IRegion=} targetRegion Ext.util.Region
 * @return {!Ext.util.IRegion} Ext.util.Region this
 */
Ext.util.IRegion.prototype.constrainTo = function(targetRegion) {};

/**
 * [Method] Checks if this region completely contains the region that is passed in
 * @param {!Ext.util.IRegion=} region Ext.util.Region
 * @return {boolean} Boolean
 */
Ext.util.IRegion.prototype.contains = function(region) {};

/**
 * [Method] Create a copy of this Region
 * @return {!Ext.util.IRegion} Ext.util.Region
 */
Ext.util.IRegion.prototype.copy = function() {};

/**
 * [Method] Copy the values of another Region to this Region
 * @param {!Ext.util.IRegion=} p Ext.util.Region The region to copy from.
 * @return {!Ext.util.IRegion} Ext.util.Region This Region
 */
Ext.util.IRegion.prototype.copyFrom = function(p) {};

/**
 * [Method] Check whether this region is equivalent to the given region
 * @param {!Ext.util.IRegion=} region Ext.util.Region The region to compare with
 * @return {boolean} Boolean
 */
Ext.util.IRegion.prototype.equals = function(region) {};

/**
 * [Method] Get the offset amount of a point outside the region
 * @param {string=} axis String
 * @param {!Ext.util.IPoint=} p Ext.util.Point the point
 * @return {!Ext.util.IOffset} Ext.util.Offset
 */
Ext.util.IRegion.prototype.getOutOfBoundOffset = function(axis, p) {};

/**
 * [Method] Get the offset amount on the x axis
 * @param {number=} p Number the offset
 * @return {number} Number
 */
Ext.util.IRegion.prototype.getOutOfBoundOffsetX = function(p) {};

/**
 * [Method] Get the offset amount on the y axis
 * @param {number=} p Number the offset
 * @return {number} Number
 */
Ext.util.IRegion.prototype.getOutOfBoundOffsetY = function(p) {};

/**
 * [Method] Checks if this region intersects the region passed in
 * @param {!Ext.util.IRegion=} region Ext.util.Region
 * @return {?} Ext.util.Region/Boolean Returns the intersected region or false if there is no intersection.
 */
Ext.util.IRegion.prototype.intersect = function(region) {};

/**
 * [Method] Check whether the point  offset is out of bound
 * @param {string=} axis String
 * @param {?=} p Ext.util.Point/Number the point / offset
 * @return {boolean} Boolean
 */
Ext.util.IRegion.prototype.isOutOfBound = function(axis, p) {};

/**
 * [Method] Check whether the offset is out of bound in the x axis
 * @param {number=} p Number the offset
 * @return {boolean} Boolean
 */
Ext.util.IRegion.prototype.isOutOfBoundX = function(p) {};

/**
 * [Method] Check whether the offset is out of bound in the y axis
 * @param {number=} p Number the offset
 * @return {boolean} Boolean
 */
Ext.util.IRegion.prototype.isOutOfBoundY = function(p) {};

/**
 * [Method] Round all the properties of this region
 * @return {!Ext.util.IRegion} Ext.util.Region this This Region
 */
Ext.util.IRegion.prototype.round = function() {};

/**
 * [Method] Translate this region by the given offset amount
 * @param {?=} x Ext.util.Offset/Object Object containing the x and y properties. Or the x value is using the two argument form.
 * @param {number=} y Number The y value unless using an Offset object.
 * @return {!Ext.util.IRegion} Ext.util.Region this This Region
 */
Ext.util.IRegion.prototype.translateBy = function(x, y) {};

/**
 * [Method] Returns the smallest region that contains the current AND targetRegion
 * @param {!Ext.util.IRegion=} region Ext.util.Region
 * @return {!Ext.util.IRegion} Ext.util.Region a new region
 */
Ext.util.IRegion.prototype.union = function(region) {};
/**
 * @constructor
 * @struct
 */
Ext.util.Region = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.util.Region.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.util.Region.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.util.Region.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.util.Region.createAlias = function(alias, origin) {};

/**
 * [Method] Creates a Region from a box Object which contains four numeric properties top right bottom and left
 * @param {?=} o Object An object with top, right, bottom and left properties.
 * @return {!Ext.util.IRegion} Ext.util.Region region The Region constructed based on the passed object
 */
Ext.util.Region.from = function(o) {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.util.Region.getName = function() {};

/**
 * [Method] Retrieves an Ext util Region for a particular element
 * @param {?=} el String/HTMLElement/Ext.Element An element ID, htmlElement or Ext.Element representing an element in the document.
 * @return {!Ext.util.IRegion} Ext.util.Region region
 */
Ext.util.Region.getRegion = function(el) {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.util.Region.implement = function() {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.util.Region.override = function(members) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.IRenderable = function() {};

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.util.IRenderable.prototype.afterRender = function() {};

/**
 * [Method] Handles autoRender
 * @return {void}
 */
Ext.util.IRenderable.prototype.doAutoRender = function() {};

/**
 * [Method] Ensures that this component is attached to document body
 * @param {boolean=} runLayout Boolean True to run the component's layout.
 * @return {void}
 */
Ext.util.IRenderable.prototype.ensureAttachedToBody = function(runLayout) {};

/**
 * [Method] This function takes the position argument passed to onRender and returns a DOM element that you can use in the insert
 * @param {?=} position String/Number/Ext.dom.Element/HTMLElement Index, element id or element you want to put this component before.
 * @return {!HTMLElement} HTMLElement DOM element that you can use in the insertBefore
 */
Ext.util.IRenderable.prototype.getInsertPosition = function(position) {};

/**
 * [Method] Initialized the renderData to be used when rendering the renderTpl
 * @return {?} Object Object with keys and values that are going to be applied to the renderTpl
 */
Ext.util.IRenderable.prototype.initRenderData = function() {};

/**
 * [Method] Template method called when this Component s DOM structure is created
 * @param {!Ext.core.IElement=} parentNode Ext.core.Element The parent Element in which this Component's encapsulating element is contained.
 * @param {number=} containerIdx Number The index within the parent Container's child collection of this Component.
 * @return {void}
 */
Ext.util.IRenderable.prototype.onRender = function(parentNode, containerIdx) {};

/**
 * [Method] Renders the Component into the passed HTML element
 * @param {?=} container Ext.Element/HTMLElement/String The element this Component should be rendered into. If it is being created from existing markup, this should be omitted.
 * @param {?=} position String/Number The element ID or DOM node index within the container before which this component will be inserted (defaults to appending to the end of the container)
 * @return {void}
 */
Ext.util.IRenderable.prototype.render = function(container, position) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.ISortable = function() {};
 /** @type {string} */
Ext.util.ISortable.prototype.defaultSortDirection;
 /** @type {string} */
Ext.util.ISortable.prototype.sortRoot;
 /** @type {?} */
Ext.util.ISortable.prototype.sorters;
 /** @type {boolean} */
Ext.util.ISortable.prototype.isSortable;

/**
 * [Method] Returns a comparator function which compares two items and returns 1 0 or 1 depending on the currently defined set
 * @return {void}
 */
Ext.util.ISortable.prototype.generateComparator = function() {};

/**
 * [Method] Gets the first sorter from the sorters collection excluding any groupers that may be in place
 * @return {!Ext.util.ISorter} Ext.util.Sorter The sorter, null if none exist
 */
Ext.util.ISortable.prototype.getFirstSorter = function() {};

/**
 * [Method] Performs initialization of this mixin
 * @return {void}
 */
Ext.util.ISortable.prototype.initSortable = function() {};

/**
 * [Method] Sorts the data in the Store by one or more of its properties
 * @param {?=} sorters String/Ext.util.Sorter[] Either a string name of one of the fields in this Store's configured Model, or an array of sorter configurations.
 * @param {string=} direction String The overall direction to sort the data by.
 * @return {!Array<!Ext.util.ISorter>} Ext.util.Sorter[]
 */
Ext.util.ISortable.prototype.sort = function(sorters, direction) {};
/**
 * @constructor
 * @struct
 */
Ext.util.Sortable = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.util.Sortable.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.util.Sortable.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.util.Sortable.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.util.Sortable.createAlias = function(alias, origin) {};

/**
 * [Method] Creates a single comparator function which encapsulates the passed Sorter array
 * @param {!Array<!Ext.util.ISorter>=} sorters Ext.util.Sorter[] The sorter set for which to create a comparator function
 * @return {?} Function a function, which when passed two comparable objects returns the result of the whole sorter comparator functions.
 */
Ext.util.Sortable.createComparator = function(sorters) {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.util.Sortable.getName = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.util.Sortable.implement = function() {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.util.Sortable.override = function(members) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.ISorter = function() {};
 /** @type {string} */
Ext.util.ISorter.prototype.direction;
 /** @type {string} */
Ext.util.ISorter.prototype.property;
 /** @type {string} */
Ext.util.ISorter.prototype.root;
 /** @type {?} */
Ext.util.ISorter.prototype.sorterFn;
 /** @type {?} */
Ext.util.ISorter.prototype.transform;

/**
 * [Method] Set the sorting direction for this sorter
 * @param {string=} direction String The direction to sort in. Should be either 'ASC' or 'DESC'.
 * @return {void}
 */
Ext.util.ISorter.prototype.setDirection = function(direction) {};

/**
 * [Method] Toggles the sorting direction for this sorter
 * @return {void}
 */
Ext.util.ISorter.prototype.toggle = function() {};

/**
 * [Method] Update the sort function for this sorter
 * @param {?=} fn Function A new sorter function for this sorter. If not specified it will use the default sorting function.
 * @return {void}
 */
Ext.util.ISorter.prototype.updateSortFunction = function(fn) {};
/**
 * @extends {Ext.util.ITaskRunner}
 * @record
 * @struct
 */
Ext.util.ITaskManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.util.TaskManager = function() {};
 /** @type {!Ext.IClass} */
Ext.util.TaskManager.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.util.TaskManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.util.TaskManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.util.TaskManager.callSuper = function(args) {};

/**
 * [Method] Destroys this instance stopping all tasks that are currently running
 * @return {void}
 */
Ext.util.TaskManager.destroy = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.util.TaskManager.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.util.TaskManager.initConfig = function(config) {};

/**
 * [Method] Creates a new Task instance
 * @param {?=} config Object The config object. For details on the supported properties, see start.
 * @return {void}
 */
Ext.util.TaskManager.newTask = function(config) {};

/**
 * [Method] Starts a new task
 * @param {?=} task Object A config object that supports the following properties:
 * @return {?} Object The task
 */
Ext.util.TaskManager.start = function(task) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.util.TaskManager.statics = function() {};

/**
 * [Method] Stops an existing running task
 * @param {?=} task Object The task to stop
 * @return {?} Object The task
 */
Ext.util.TaskManager.stop = function(task) {};

/**
 * [Method] Stops all tasks that are currently running
 * @return {void}
 */
Ext.util.TaskManager.stopAll = function() {};
/**
 * @extends {Ext.util.ITaskRunner}
 * @record
 * @struct
 */
Ext.ITaskManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.TaskManager = function() {};
 /** @type {!Ext.IClass} */
Ext.TaskManager.self;

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.TaskManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.TaskManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.TaskManager.callSuper = function(args) {};

/**
 * [Method] Destroys this instance stopping all tasks that are currently running
 * @return {void}
 */
Ext.TaskManager.destroy = function() {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.TaskManager.getInitialConfig = function(name) {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.TaskManager.initConfig = function(config) {};

/**
 * [Method] Creates a new Task instance
 * @param {?=} config Object The config object. For details on the supported properties, see start.
 * @return {void}
 */
Ext.TaskManager.newTask = function(config) {};

/**
 * [Method] Starts a new task
 * @param {?=} task Object A config object that supports the following properties:
 * @return {?} Object The task
 */
Ext.TaskManager.start = function(task) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.TaskManager.statics = function() {};

/**
 * [Method] Stops an existing running task
 * @param {?=} task Object The task to stop
 * @return {?} Object The task
 */
Ext.TaskManager.stop = function(task) {};

/**
 * [Method] Stops all tasks that are currently running
 * @return {void}
 */
Ext.TaskManager.stopAll = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.ITaskRunner = function() {};
 /** @type {boolean} */
Ext.util.ITaskRunner.prototype.fireIdleEvent;
 /** @type {number} */
Ext.util.ITaskRunner.prototype.interval;

/**
 * [Method] Destroys this instance stopping all tasks that are currently running
 * @return {void}
 */
Ext.util.ITaskRunner.prototype.destroy = function() {};

/**
 * [Method] Creates a new Task instance
 * @param {?=} config Object The config object. For details on the supported properties, see start.
 * @return {void}
 */
Ext.util.ITaskRunner.prototype.newTask = function(config) {};

/**
 * [Method] Starts a new task
 * @param {?=} task Object A config object that supports the following properties:
 * @return {?} Object The task
 */
Ext.util.ITaskRunner.prototype.start = function(task) {};

/**
 * [Method] Stops an existing running task
 * @param {?=} task Object The task to stop
 * @return {?} Object The task
 */
Ext.util.ITaskRunner.prototype.stop = function(task) {};

/**
 * [Method] Stops all tasks that are currently running
 * @return {void}
 */
Ext.util.ITaskRunner.prototype.stopAll = function() {};
/** @const */
Ext.util.taskrunner = {};
/**
 * @record
 * @struct
 */
Ext.util.taskrunner.ITask = function() {};
 /** @type {boolean} */
Ext.util.taskrunner.ITask.prototype.fireOnStart;

/**
 * [Method] Destroys this instance stopping this task s execution
 * @return {void}
 */
Ext.util.taskrunner.ITask.prototype.destroy = function() {};

/**
 * [Method] Restarts this task clearing it duration expiration and run count
 * @param {number=} interval Number Optionally reset this task's interval.
 * @return {void}
 */
Ext.util.taskrunner.ITask.prototype.restart = function(interval) {};

/**
 * [Method] Starts this task if it is not already started
 * @param {number=} interval Number Optionally reset this task's interval.
 * @return {void}
 */
Ext.util.taskrunner.ITask.prototype.start = function(interval) {};

/**
 * [Method] Stops this task
 * @return {void}
 */
Ext.util.taskrunner.ITask.prototype.stop = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.util.ITextMetrics = function() {};

/**
 * [Method] Binds this TextMetrics instance to a new element
 * @param {?=} el String/HTMLElement/Ext.Element The element or its ID.
 * @return {void}
 */
Ext.util.ITextMetrics.prototype.bind = function(el) {};

/**
 * [Method] Destroy this instance
 * @return {void}
 */
Ext.util.ITextMetrics.prototype.destroy = function() {};

/**
 * [Method] Returns the measured height of the specified text
 * @param {string=} text String The text to measure
 * @return {number} Number height The height in pixels
 */
Ext.util.ITextMetrics.prototype.getHeight = function(text) {};

/**
 * [Method] Returns the size of the specified text based on the internal element s style and width properties
 * @param {string=} text String The text to measure
 * @return {?} Object An object containing the text's size {width: (width), height: (height)}
 */
Ext.util.ITextMetrics.prototype.getSize = function(text) {};

/**
 * [Method] Returns the measured width of the specified text
 * @param {string=} text String The text to measure
 * @return {number} Number width The width in pixels
 */
Ext.util.ITextMetrics.prototype.getWidth = function(text) {};

/**
 * [Method] Sets a fixed width on the internal measurement element
 * @param {number=} width Number The width to set on the element
 * @return {void}
 */
Ext.util.ITextMetrics.prototype.setFixedWidth = function(width) {};
/**
 * @constructor
 * @struct
 */
Ext.util.TextMetrics = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.util.TextMetrics.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.util.TextMetrics.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.util.TextMetrics.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.util.TextMetrics.createAlias = function(alias, origin) {};

/**
 * [Method] Destroy the TextMetrics instance created by measure
 * @return {void}
 */
Ext.util.TextMetrics.destroy = function() {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.util.TextMetrics.getName = function() {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.util.TextMetrics.implement = function() {};

/**
 * [Method] Measures the size of the specified text
 * @param {?=} el String/HTMLElement The element, dom node or id from which to copy existing CSS styles that can affect the size of the rendered text
 * @param {string=} text String The text to measure
 * @param {number=} fixedWidth Number If the text will be multiline, you have to set a fixed width in order to accurately measure the text height
 * @return {?} Object An object containing the text's size {width: (width), height: (height)}
 */
Ext.util.TextMetrics.measure = function(el, text, fixedWidth) {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.util.TextMetrics.override = function(members) {};
/**
 * @record
 * @struct
 */
Ext.IVersion = function() {};

/**
 * [Method] Returns whether this version equals to the supplied argument
 * @param {?=} target String/Number The version to compare with
 * @return {boolean} Boolean True if this version equals to the target, false otherwise
 */
Ext.IVersion.prototype.equals = function(target) {};

/**
 * [Method] Returns the build component value
 * @return {number} Number build
 */
Ext.IVersion.prototype.getBuild = function() {};

/**
 * [Method] Returns the major component value
 * @return {number} Number major
 */
Ext.IVersion.prototype.getMajor = function() {};

/**
 * [Method] Returns the minor component value
 * @return {number} Number minor
 */
Ext.IVersion.prototype.getMinor = function() {};

/**
 * [Method] Returns the patch component value
 * @return {number} Number patch
 */
Ext.IVersion.prototype.getPatch = function() {};

/**
 * [Method] Returns the release component value
 * @return {number} Number release
 */
Ext.IVersion.prototype.getRelease = function() {};

/**
 * [Method] Returns shortVersion version without dots and release
 * @return {string} String
 */
Ext.IVersion.prototype.getShortVersion = function() {};

/**
 * [Method] Convenient alias to isGreaterThan
 * @param {?=} target String/Number
 * @return {boolean} Boolean
 */
Ext.IVersion.prototype.gt = function(target) {};

/**
 * [Method] Convenient alias to isGreaterThanOrEqual
 * @param {?=} target String/Number
 * @return {boolean} Boolean
 */
Ext.IVersion.prototype.gtEq = function(target) {};

/**
 * [Method] Returns whether this version if greater than the supplied argument
 * @param {?=} target String/Number The version to compare with
 * @return {boolean} Boolean True if this version if greater than the target, false otherwise
 */
Ext.IVersion.prototype.isGreaterThan = function(target) {};

/**
 * [Method] Returns whether this version if greater than or equal to the supplied argument
 * @param {?=} target String/Number The version to compare with
 * @return {boolean} Boolean True if this version if greater than or equal to the target, false otherwise
 */
Ext.IVersion.prototype.isGreaterThanOrEqual = function(target) {};

/**
 * [Method] Returns whether this version if smaller than the supplied argument
 * @param {?=} target String/Number The version to compare with
 * @return {boolean} Boolean True if this version if smaller than the target, false otherwise
 */
Ext.IVersion.prototype.isLessThan = function(target) {};

/**
 * [Method] Returns whether this version if less than or equal to the supplied argument
 * @param {?=} target String/Number The version to compare with
 * @return {boolean} Boolean True if this version if less than or equal to the target, false otherwise
 */
Ext.IVersion.prototype.isLessThanOrEqual = function(target) {};

/**
 * [Method] Convenient alias to isLessThan
 * @param {?=} target String/Number
 * @return {boolean} Boolean
 */
Ext.IVersion.prototype.lt = function(target) {};

/**
 * [Method] Convenient alias to isLessThanOrEqual
 * @param {?=} target String/Number
 * @return {boolean} Boolean
 */
Ext.IVersion.prototype.ltEq = function(target) {};

/**
 * [Method] Returns whether this version matches the supplied argument
 * @param {?=} target String/Number The version to compare with
 * @return {boolean} Boolean True if this version matches the target, false otherwise
 */
Ext.IVersion.prototype.match = function(target) {};

/**
 * [Method] Returns this format  major minor patch build release
 * @return {!Array<number>} Number[]
 */
Ext.IVersion.prototype.toArray = function() {};
/**
 * @constructor
 * @struct
 */
Ext.Version = function() {};

/**
 * [Method] Compare 2 specified versions starting from left to right
 * @param {string=} current String The current version to compare to
 * @param {string=} target String The target version to compare to
 * @return {number} Number Returns -1 if the current version is smaller than the target version, 1 if greater, and 0 if they're equivalent
 */
Ext.Version.compare = function(current, target) {};

/**
 * [Method] Converts a version component to a comparable value
 * @param {?=} value Object The value to convert
 * @return {?} Object
 */
Ext.Version.getComponentValue = function(value) {};
/** @const */
Ext.view = {};
/**
 * @extends {Ext.IComponent}
 * @extends {Ext.util.IBindable}
 * @record
 * @struct
 */
Ext.view.IAbstractView = function() {};
 /** @type {boolean} */
Ext.view.IAbstractView.prototype.blockRefresh;
 /** @type {boolean} */
Ext.view.IAbstractView.prototype.deferEmptyText;
 /** @type {boolean} */
Ext.view.IAbstractView.prototype.deferInitialRefresh;
 /** @type {boolean} */
Ext.view.IAbstractView.prototype.disableSelection;
 /** @type {string} */
Ext.view.IAbstractView.prototype.emptyText;
 /** @type {string} */
Ext.view.IAbstractView.prototype.itemCls;
 /** @type {string} */
Ext.view.IAbstractView.prototype.itemSelector;
 /** @type {?} */
Ext.view.IAbstractView.prototype.itemTpl;
 /** @type {?} */
Ext.view.IAbstractView.prototype.loadMask;
 /** @type {string} */
Ext.view.IAbstractView.prototype.loadingCls;
 /** @type {number} */
Ext.view.IAbstractView.prototype.loadingHeight;
 /** @type {string} */
Ext.view.IAbstractView.prototype.loadingText;
 /** @type {boolean} */
Ext.view.IAbstractView.prototype.multiSelect;
 /** @type {string} */
Ext.view.IAbstractView.prototype.overItemCls;
 /** @type {boolean} */
Ext.view.IAbstractView.prototype.preserveScrollOnRefresh;
 /** @type {string} */
Ext.view.IAbstractView.prototype.selectedItemCls;
 /** @type {boolean} */
Ext.view.IAbstractView.prototype.simpleSelect;
 /** @type {boolean} */
Ext.view.IAbstractView.prototype.singleSelect;
 /** @type {!Ext.data.IStore} */
Ext.view.IAbstractView.prototype.store;
 /** @type {?} */
Ext.view.IAbstractView.prototype.tpl;
 /** @type {boolean} */
Ext.view.IAbstractView.prototype.trackOver;

/**
 * [Method] Allows addition of behavior after rendering is complete
 * @return {void}
 */
Ext.view.IAbstractView.prototype.afterRender = function() {};

/**
 * [Method] Changes the data store bound to this view and refreshes it
 * @param {!Ext.data.IStore=} store Ext.data.Store The store to bind to this view
 * @return {void}
 */
Ext.view.IAbstractView.prototype.bindStore = function(store) {};

/**
 * [Method] Binds listeners for this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to bind to
 * @return {void}
 */
Ext.view.IAbstractView.prototype.bindStoreListeners = function(store) {};

/**
 * [Method] Deselects all selected records
 * @return {void}
 */
Ext.view.IAbstractView.prototype.clearSelections = function() {};

/**
 * [Method] Function which can be overridden which returns the data object passed to this DataView s template to render the whole
 * @param {!Array<!Ext.data.IModel>=} records Ext.data.Model[] An Array of Ext.data.Models to be rendered into the DataView.
 * @param {number=} startIndex Number the index number of the Record being prepared for rendering.
 * @return {!Array<?>} Object[] An Array of data objects to be processed by a repeating XTemplate. May also contain named properties.
 */
Ext.view.IAbstractView.prototype.collectData = function(records, startIndex) {};

/**
 * [Method] Deselects a record instance by record instance or index
 * @param {?=} records Ext.data.Model[]/Number An array of records or an index
 * @param {boolean=} suppressEvent Boolean Set to false to not fire a deselect event
 * @return {void}
 */
Ext.view.IAbstractView.prototype.deselect = function(records, suppressEvent) {};

/**
 * [Method] Returns the template node the passed child belongs to or null if it doesn t belong to one
 * @param {!HTMLElement=} node HTMLElement
 * @return {!HTMLElement} HTMLElement The template node
 */
Ext.view.IAbstractView.prototype.findItemByChild = function(node) {};

/**
 * [Method] Returns the template node by the Ext EventObject or null if it is not found
 * @param {!Ext.IEventObject=} e Ext.EventObject
 * @return {void}
 */
Ext.view.IAbstractView.prototype.findTargetByEvent = function(e) {};

/**
 * [Method] Gets a template node
 * @param {?=} nodeInfo HTMLElement/String/Number/Ext.data.Model An HTMLElement template node, index of a template node, the id of a template node or the record associated with the node.
 * @return {!HTMLElement} HTMLElement The node or null if it wasn't found
 */
Ext.view.IAbstractView.prototype.getNode = function(nodeInfo) {};

/**
 * [Method] Gets a range nodes
 * @param {number=} start Number The index of the first node in the range
 * @param {number=} end Number The index of the last node in the range
 * @return {!Array<!HTMLElement>} HTMLElement[] An array of nodes
 */
Ext.view.IAbstractView.prototype.getNodes = function(start, end) {};

/**
 * [Method] Gets a record from a node
 * @param {?=} node Ext.Element/HTMLElement The node to evaluate
 * @return {!Ext.data.IModel} Ext.data.Model record The Ext.data.Model object
 */
Ext.view.IAbstractView.prototype.getRecord = function(node) {};

/**
 * [Method] Gets an array of the records from an array of nodes
 * @param {!Array<!HTMLElement>=} nodes HTMLElement[] The nodes to evaluate
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] records The Ext.data.Model objects
 */
Ext.view.IAbstractView.prototype.getRecords = function(nodes) {};

/**
 * [Method] Gets the currently selected nodes
 * @return {!Array<!HTMLElement>} HTMLElement[] An array of HTMLElements
 */
Ext.view.IAbstractView.prototype.getSelectedNodes = function() {};

/**
 * [Method] Gets an array of the selected records
 * @return {!Array<!Ext.data.IModel>} Ext.data.Model[] An array of Ext.data.Model objects
 */
Ext.view.IAbstractView.prototype.getSelectedRecords = function() {};

/**
 * [Method] Gets the number of selected nodes
 * @return {number} Number The node count
 */
Ext.view.IAbstractView.prototype.getSelectionCount = function() {};

/**
 * [Method] Gets the selection model for this view
 * @return {!Ext.selection.IModel} Ext.selection.Model The selection model
 */
Ext.view.IAbstractView.prototype.getSelectionModel = function() {};

/**
 * [Method] Returns the store associated with this DataView
 * @return {!Ext.data.IStore} Ext.data.Store The store
 */
Ext.view.IAbstractView.prototype.getStore = function() {};

/**
 * [Method] Gets the listeners to bind to a new store
 * @return {?} Object The listeners to be bound to the store in object literal form. The scope may be omitted, it is assumed to be the current instance.
 */
Ext.view.IAbstractView.prototype.getStoreListeners = function() {};

/**
 * [Method] Finds the index of the passed node
 * @param {?=} nodeInfo HTMLElement/String/Number/Ext.data.Model An HTMLElement template node, index of a template node, the id of a template node or a record associated with a node.
 * @return {number} Number The index of the node or -1
 */
Ext.view.IAbstractView.prototype.indexOf = function(nodeInfo) {};

/**
 * [Method] private
 * @return {void}
 */
Ext.view.IAbstractView.prototype.initComponent = function() {};

/**
 * [Method] Returns true if the passed node is selected else false
 * @param {?=} node HTMLElement/Number/Ext.data.Model The node, node index or record to check
 * @return {boolean} Boolean True if selected, else false
 */
Ext.view.IAbstractView.prototype.isSelected = function(node) {};

/**
 * [Method] Template method it is called when a new store is bound to the current instance
 * @param {?=} store Object
 * @param {?=} initial Object
 * @param {?=} propName Object
 * @return {void}
 */
Ext.view.IAbstractView.prototype.onBindStore = function(store, initial, propName) {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.view.IAbstractView.prototype.onDestroy = function() {};

/**
 * [Method] Template method called when this Component s DOM structure is created
 * @return {void}
 */
Ext.view.IAbstractView.prototype.onRender = function() {};

/**
 * [Method] Template method it is called when an existing store is unbound from the current instance
 * @param {?=} store Object
 * @return {void}
 */
Ext.view.IAbstractView.prototype.onUnbindStore = function(store) {};

/**
 * [Method] Function which can be overridden to provide custom formatting for each Record that is used by this DataView s templat
 * @param {?=} data Object/Object[] The raw data object that was used to create the Record.
 * @param {number=} recordIndex Number the index number of the Record being prepared for rendering.
 * @param {!Ext.data.IModel=} record Ext.data.Model The Record being prepared for rendering.
 * @return {?} Array/Object The formatted data in a format expected by the internal template's overwrite() method. (either an array if your params are numeric (i.e. {0}) or an object (i.e. {foo: 'bar'}))
 */
Ext.view.IAbstractView.prototype.prepareData = function(data, recordIndex, record) {};

/**
 * [Method] Refreshes the view by reloading the data from the store and re rendering the template
 * @return {void}
 */
Ext.view.IAbstractView.prototype.refresh = function() {};

/**
 * [Method] Refreshes an individual node s data from the store
 * @param {number=} index Number The item's data index in the store
 * @return {void}
 */
Ext.view.IAbstractView.prototype.refreshNode = function(index) {};

/**
 * [Method] Selects a record instance by record instance or index
 * @param {?=} records Ext.data.Model[]/Number An array of records or an index
 * @param {boolean=} keepExisting Boolean
 * @param {boolean=} suppressEvent Boolean Set to false to not fire a select event
 * @return {void}
 */
Ext.view.IAbstractView.prototype.select = function(records, keepExisting, suppressEvent) {};

/**
 * [Method] Unbinds listeners from this component to the store
 * @param {!Ext.data.IAbstractStore=} store Ext.data.AbstractStore The store to unbind from
 * @return {void}
 */
Ext.view.IAbstractView.prototype.unbindStoreListeners = function(store) {};
/**
 * @extends {Ext.view.IView}
 * @extends {Ext.IQueryable}
 * @record
 * @struct
 */
Ext.view.IBoundList = function() {};
 /** @type {string} */
Ext.view.IBoundList.prototype.baseCls;
 /** @type {?} */
Ext.view.IBoundList.prototype.componentLayout;
 /** @type {boolean} */
Ext.view.IBoundList.prototype.deferInitialRefresh;
 /** @type {string} */
Ext.view.IBoundList.prototype.displayField;
 /** @type {string} */
Ext.view.IBoundList.prototype.itemCls;
 /** @type {number} */
Ext.view.IBoundList.prototype.pageSize;
 /** @type {?} */
Ext.view.IBoundList.prototype.renderTpl;
 /** @type {?} */
Ext.view.IBoundList.prototype.shadow;
 /** @type {?} */
Ext.view.IBoundList.prototype.tpl;
 /** @type {boolean} */
Ext.view.IBoundList.prototype.trackOver;
 /** @type {!Ext.toolbar.IPaging} */
Ext.view.IBoundList.prototype.pagingToolbar;

/**
 * [Method] Changes the data store bound to this view and refreshes it
 * @param {?=} store Object
 * @param {?=} initial Object
 * @return {void}
 */
Ext.view.IBoundList.prototype.bindStore = function(store, initial) {};

/**
 * [Method] Retrieves the first direct child of this container which matches the passed selector or component
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching child Ext.Component (or null if no match was found).
 */
Ext.view.IBoundList.prototype.child = function(selector) {};

/**
 * [Method] Retrieves the first descendant of this container which matches the passed selector
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector or Ext.Component. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching descendant Ext.Component (or null if no match was found).
 */
Ext.view.IBoundList.prototype.down = function(selector) {};

/**
 * [Method] A method that returns the inner template for displaying items in the list
 * @param {string=} displayField String The displayField for the BoundList.
 * @return {string} String The inner template
 */
Ext.view.IBoundList.prototype.getInnerTpl = function(displayField) {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.view.IBoundList.prototype.onDestroy = function() {};

/**
 * [Method] Retrieves all descendant components which match the passed selector
 * @param {string=} selector String Selector complying to an Ext.ComponentQuery selector. If no selector is specified all items will be returned.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components which matched the selector
 */
Ext.view.IBoundList.prototype.query = function(selector) {};

/**
 * [Method] Retrieves all descendant components which match the passed function
 * @param {?=} fn Function The matcher function. It will be called with a single argument, the component being tested.
 * @param {?=} scope Object The scope in which to run the function. If not specified, it will default to the active component.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components matched by the passed function
 */
Ext.view.IBoundList.prototype.queryBy = function(fn, scope) {};

/**
 * [Method] Finds a component at any level under this container matching the id itemId
 * @param {string=} id String The id to find
 * @return {!Ext.IComponent} Ext.Component The matching id, null if not found
 */
Ext.view.IBoundList.prototype.queryById = function(id) {};

/**
 * [Method] Refreshes the view by reloading the data from the store and re rendering the template
 * @return {void}
 */
Ext.view.IBoundList.prototype.refresh = function() {};
/**
 * @extends {Ext.view.IView}
 * @extends {Ext.IQueryable}
 * @record
 * @struct
 */
Ext.IBoundList = function() {};
 /** @type {string} */
Ext.IBoundList.prototype.baseCls;
 /** @type {?} */
Ext.IBoundList.prototype.componentLayout;
 /** @type {boolean} */
Ext.IBoundList.prototype.deferInitialRefresh;
 /** @type {string} */
Ext.IBoundList.prototype.displayField;
 /** @type {string} */
Ext.IBoundList.prototype.itemCls;
 /** @type {number} */
Ext.IBoundList.prototype.pageSize;
 /** @type {?} */
Ext.IBoundList.prototype.renderTpl;
 /** @type {?} */
Ext.IBoundList.prototype.shadow;
 /** @type {?} */
Ext.IBoundList.prototype.tpl;
 /** @type {boolean} */
Ext.IBoundList.prototype.trackOver;
 /** @type {!Ext.toolbar.IPaging} */
Ext.IBoundList.prototype.pagingToolbar;

/**
 * [Method] Changes the data store bound to this view and refreshes it
 * @param {?=} store Object
 * @param {?=} initial Object
 * @return {void}
 */
Ext.IBoundList.prototype.bindStore = function(store, initial) {};

/**
 * [Method] Retrieves the first direct child of this container which matches the passed selector or component
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching child Ext.Component (or null if no match was found).
 */
Ext.IBoundList.prototype.child = function(selector) {};

/**
 * [Method] Retrieves the first descendant of this container which matches the passed selector
 * @param {?=} selector String/Ext.Component An Ext.ComponentQuery selector or Ext.Component. If no selector is specified, the first child will be returned.
 * @return {?} Object Ext.Component The matching descendant Ext.Component (or null if no match was found).
 */
Ext.IBoundList.prototype.down = function(selector) {};

/**
 * [Method] A method that returns the inner template for displaying items in the list
 * @param {string=} displayField String The displayField for the BoundList.
 * @return {string} String The inner template
 */
Ext.IBoundList.prototype.getInnerTpl = function(displayField) {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.IBoundList.prototype.onDestroy = function() {};

/**
 * [Method] Retrieves all descendant components which match the passed selector
 * @param {string=} selector String Selector complying to an Ext.ComponentQuery selector. If no selector is specified all items will be returned.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components which matched the selector
 */
Ext.IBoundList.prototype.query = function(selector) {};

/**
 * [Method] Retrieves all descendant components which match the passed function
 * @param {?=} fn Function The matcher function. It will be called with a single argument, the component being tested.
 * @param {?=} scope Object The scope in which to run the function. If not specified, it will default to the active component.
 * @return {!Array<!Ext.IComponent>} Ext.Component[] Components matched by the passed function
 */
Ext.IBoundList.prototype.queryBy = function(fn, scope) {};

/**
 * [Method] Finds a component at any level under this container matching the id itemId
 * @param {string=} id String The id to find
 * @return {!Ext.IComponent} Ext.Component The matching id, null if not found
 */
Ext.IBoundList.prototype.queryById = function(id) {};

/**
 * [Method] Refreshes the view by reloading the data from the store and re rendering the template
 * @return {void}
 */
Ext.IBoundList.prototype.refresh = function() {};
/**
 * @extends {Ext.util.IKeyNav}
 * @record
 * @struct
 */
Ext.view.IBoundListKeyNav = function() {};
 /** @type {!Ext.view.IBoundList} */
Ext.view.IBoundListKeyNav.prototype.boundList;

/**
 * [Method] Highlights the item at the given index
 * @param {number=} index Number
 * @return {void}
 */
Ext.view.IBoundListKeyNav.prototype.highlightAt = function(index) {};

/**
 * [Method] Triggers selection of the currently highlighted item according to the behavior of the configured SelectionModel
 * @param {?=} e Object
 * @return {void}
 */
Ext.view.IBoundListKeyNav.prototype.selectHighlighted = function(e) {};
/**
 * @extends {Ext.dd.IDragZone}
 * @record
 * @struct
 */
Ext.view.IDragZone = function() {};
 /** @type {?} */
Ext.view.IDragZone.prototype.containerScroll;

/**
 * [Method] Called when a mousedown occurs in this container
 * @param {?=} e Object
 * @return {?} Object The dragData
 */
Ext.view.IDragZone.prototype.getDragData = function(e) {};

/**
 * [Method] Called before a repair of an invalid drop to get the XY to animate to
 * @param {?=} e Object
 * @param {?=} data Object
 * @return {!Array<number>} Number[] The xy location (e.g. [100, 200])
 */
Ext.view.IDragZone.prototype.getRepairXY = function(e, data) {};

/**
 * [Method] Sets up the DragDrop object
 * @param {?=} id Object
 * @param {?=} sGroup Object
 * @param {?=} config Object
 * @return {void}
 */
Ext.view.IDragZone.prototype.init = function(id, sGroup, config) {};

/**
 * [Method] Called once drag threshold has been reached to initialize the proxy element
 * @param {?=} x Object
 * @param {?=} y Object
 * @return {boolean} Boolean true to continue the drag, false to cancel
 */
Ext.view.IDragZone.prototype.onInitDrag = function(x, y) {};
/**
 * @extends {Ext.dd.IDropZone}
 * @record
 * @struct
 */
Ext.view.IDropZone = function() {};

/**
 * [Method] Destroy this DragDrop instance
 * @return {void}
 */
Ext.view.IDropZone.prototype.destroy = function() {};

/**
 * [Method] Returns a custom data object associated with the DOM node that is the target of the event
 * @param {?=} e Object
 * @return {?} Object data The custom data
 */
Ext.view.IDropZone.prototype.getTargetFromEvent = function(e) {};

/**
 * [Method] Moved out of the DropZone without dropping
 * @param {?=} node Object
 * @param {?=} dragZone Object
 * @param {?=} e Object
 * @param {?=} data Object
 * @return {void}
 */
Ext.view.IDropZone.prototype.notifyOut = function(node, dragZone, e, data) {};

/**
 * [Method] Called when the DropZone determines that a Ext dd DragSource has been dropped on it but not on any of its registered
 * @param {?=} dd Object
 * @param {?=} e Object
 * @param {?=} data Object
 * @return {boolean} Boolean True if the drop was valid, else false
 */
Ext.view.IDropZone.prototype.onContainerDrop = function(dd, e, data) {};

/**
 * [Method] The mouse is past the end of all nodes or there are no nodes
 * @param {?=} dd Object
 * @param {?=} e Object
 * @param {?=} data Object
 * @return {string} String status The CSS class that communicates the drop status back to the source so that the underlying Ext.dd.StatusProxy can be updated
 */
Ext.view.IDropZone.prototype.onContainerOver = function(dd, e, data) {};

/**
 * [Method] Called when the DropZone determines that a Ext dd DragSource has been dropped onto the drop node
 * @param {?=} targetNode Object
 * @param {?=} dragZone Object
 * @param {?=} e Object
 * @param {?=} data Object
 * @return {boolean} Boolean True if the drop was valid, else false
 */
Ext.view.IDropZone.prototype.onNodeDrop = function(targetNode, dragZone, e, data) {};

/**
 * [Method] The mouse is over a View node
 * @param {?=} node Object
 * @param {?=} dragZone Object
 * @param {?=} e Object
 * @param {?=} data Object
 * @return {string} String status The CSS class that communicates the drop status back to the source so that the underlying Ext.dd.StatusProxy can be updated
 */
Ext.view.IDropZone.prototype.onNodeOver = function(node, dragZone, e, data) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.view.INodeCache = function() {};

/**
 * [Method] Removes all elements from this NodeCache
 * @param {boolean=} removeDom Boolean True to also remove the elements from the document.
 * @return {void}
 */
Ext.view.INodeCache.prototype.clear = function(removeDom) {};

/**
 * [Method] Clears this NodeCache and adds the elements passed
 * @param {!Array<!HTMLElement>=} els HTMLElement[] An array of DOM elements from which to fill this NodeCache.
 * @return {!Ext.view.INodeCache} Ext.view.NodeCache this
 */
Ext.view.INodeCache.prototype.fill = function(els) {};

/**
 * [Method] Find the index of the passed element within the composite collection
 * @param {?=} el String/HTMLElement/Ext.Element/Number The id of an element, or an Ext.dom.Element, or an HtmlElement to find within the composite collection.
 * @return {number} Number The index of the passed Ext.dom.Element in the composite collection, or -1 if not found.
 */
Ext.view.INodeCache.prototype.indexOf = function(el) {};

/**
 * [Method] Removes the specified element s
 * @param {?=} el String/HTMLElement/Ext.Element/Number The id of an element, the Element itself, the index of the element in this composite or an array of any of those.
 * @param {boolean=} removeDom Boolean True to also remove the element from the document
 * @return {void}
 */
Ext.view.INodeCache.prototype.removeElement = function(el, removeDom) {};

/**
 * [Method] Replaces the specified element with the passed element
 * @param {?=} el String/HTMLElement/Ext.Element/Number The id of an element, the Element itself, the index of the element in this composite to replace.
 * @param {?=} replacement String/Ext.Element The id of an element or the Element itself.
 * @param {boolean=} domReplace Boolean True to remove and replace the element in the document too.
 * @return {!Ext.view.INodeCache} Ext.view.NodeCache this
 */
Ext.view.INodeCache.prototype.replaceElement = function(el, replacement, domReplace) {};

/**
 * [Method] Appends prepends records depending on direction flag
 * @param {!Array<!Ext.data.IModel>=} newRecords Ext.data.Model[] Items to append/prepend
 * @param {number=} direction Number -1' = scroll up,0` = scroll down.
 * @param {number=} removeCount Number The number of records to remove from the end. if scrolling down, rows are removed from the top and the new rows are added at the bottom.
 * @return {void}
 */
Ext.view.INodeCache.prototype.scroll = function(newRecords, direction, removeCount) {};
/**
 * @extends {Ext.view.IView}
 * @record
 * @struct
 */
Ext.view.ITable = function() {};
 /** @type {string} */
Ext.view.ITable.prototype.baseCls;
 /** @type {?} */
Ext.view.ITable.prototype.componentLayout;
 /** @type {boolean} */
Ext.view.ITable.prototype.enableTextSelection;
 /** @type {string} */
Ext.view.ITable.prototype.firstCls;
 /** @type {string} */
Ext.view.ITable.prototype.itemSelector;
 /** @type {string} */
Ext.view.ITable.prototype.lastCls;
 /** @type {boolean} */
Ext.view.ITable.prototype.markDirty;
 /** @type {string} */
Ext.view.ITable.prototype.overItemCls;
 /** @type {string} */
Ext.view.ITable.prototype.selectedItemCls;
 /** @type {boolean} */
Ext.view.ITable.prototype.stripeRows;
 /** @type {boolean} */
Ext.view.ITable.prototype.trackOver;

/**
 * [Method] Adds a CSS Class to a specific row
 * @param {?=} rowInfo HTMLElement/String/Number/Ext.data.Model An HTMLElement, index or instance of a model representing this row
 * @param {string=} cls String
 * @return {void}
 */
Ext.view.ITable.prototype.addRowCls = function(rowInfo, cls) {};

/**
 * [Method] Sizes the passed header to fit the max content width
 * @param {?=} header Ext.grid.column.Column/Number The header (or index of header) to auto size.
 * @return {void}
 */
Ext.view.ITable.prototype.autoSizeColumn = function(header) {};

/**
 * [Method] Invoked before the Component is destroyed
 * @return {void}
 */
Ext.view.ITable.prototype.beforeDestroy = function() {};

/**
 * [Method] Function which can be overridden which returns the data object passed to this DataView s template to render the whole
 * @param {?=} records Object
 * @param {?=} startIndex Object
 * @return {!Array<?>} Object[] An Array of data objects to be processed by a repeating XTemplate. May also contain named properties.
 */
Ext.view.ITable.prototype.collectData = function(records, startIndex) {};

/**
 * [Method] Expands a particular header to fit the max content width
 * @param {?=} header Object
 * @return {void}
 */
Ext.view.ITable.prototype.expandToFit = function(header) {};

/**
 * [Method] Try to focus this component
 * @param {?=} selectText Object
 * @param {?=} delay Object
 * @return {!Ext.IComponent} Ext.Component The focused Component. Usually this Component. Some Containers may delegate focus to a descendant Component (Windows can do this through their defaultFocus config option.
 */
Ext.view.ITable.prototype.focus = function(selectText, delay) {};

/**
 * [Method] Focuses a particular row and brings it into view
 * @param {?=} row HTMLElement/String/Number/Ext.data.Model An HTMLElement template node, index of a template node, the id of a template node or the
 * @param {?=} delay Boolean/Number Delay the focus this number of milliseconds (true for 10 milliseconds). record associated with the node.
 * @return {void}
 */
Ext.view.ITable.prototype.focusRow = function(row, delay) {};

/**
 * [Method] Returns a CSS selector which selects the outermost element s in this view
 * @return {void}
 */
Ext.view.ITable.prototype.getBodySelector = function() {};

/**
 * [Method] Returns a CSS selector which selects a particular column if the desired header is passed or a general cell selector
 * @param {!Ext.grid.column.IColumn=} header Ext.grid.column.Column The column for which to return the selector. If omitted, the general cell selector which matches ant cell will be returned.
 * @return {void}
 */
Ext.view.ITable.prototype.getCellSelector = function(header) {};

/**
 * [Method] Returns a CSS selector which selects the element s which define the width of a column
 * @param {?=} header Object
 * @return {void}
 */
Ext.view.ITable.prototype.getColumnSizerSelector = function(header) {};

/**
 * [Method] Returns a CSS selector which selects a row which contains cells
 * @return {void}
 */
Ext.view.ITable.prototype.getDataRowSelector = function() {};

/**
 * [Method] Get a reference to a feature
 * @param {string=} id String The id of the feature
 * @return {!Ext.grid.feature.IFeature} Ext.grid.feature.Feature The feature. Undefined if not found
 */
Ext.view.ITable.prototype.getFeature = function(id) {};

/**
 * [Method] Returns a CSS selector which selects items of the view rendered by the rowTpl
 * @return {void}
 */
Ext.view.ITable.prototype.getItemSelector = function() {};

/**
 * [Method] Returns the node given the passed Record or index or node
 * @param {?=} nodeInfo HTMLElement/String/Number/Ext.data.Model The node or record
 * @param {boolean=} dataRow Boolean true to return the data row (not the top level row if wrapped), false to return the top level row.
 * @return {!HTMLElement} HTMLElement The node or null if it wasn't found
 */
Ext.view.ITable.prototype.getNode = function(nodeInfo, dataRow) {};

/**
 * [Method] Returns a CSS selector which selects the element which contains record nodes
 * @return {void}
 */
Ext.view.ITable.prototype.getNodeContainerSelector = function() {};

/**
 * [Method] Gets the current XY position of the component s underlying element
 * @param {?=} record Object
 * @param {?=} header Object
 * @return {!Array<number>} Number[] The XY position of the element (e.g., [100, 200])
 */
Ext.view.ITable.prototype.getPosition = function(record, header) {};

/**
 * [Method] Gets a record from a node
 * @param {?=} node Object
 * @return {!Ext.data.IModel} Ext.data.Model record The Ext.data.Model object
 */
Ext.view.ITable.prototype.getRecord = function(node) {};

/**
 * [Method] Override this function to apply custom CSS classes to rows during rendering
 * @param {!Ext.data.IModel=} record Ext.data.Model The record corresponding to the current row.
 * @param {number=} index Number The row index.
 * @param {?=} rowParams Object DEPRECATED. For row body use the getAdditionalData method of the rowbody feature.
 * @param {!Ext.data.IStore=} store Ext.data.Store The store this grid is bound to
 * @return {string} String a CSS class name to add to the row.
 */
Ext.view.ITable.prototype.getRowClass = function(record, index, rowParams, store) {};

/**
 * [Method] Finds the index of the passed node
 * @param {?=} node Object
 * @return {number} Number The index of the node or -1
 */
Ext.view.ITable.prototype.indexOf = function(node) {};

/**
 * [Method] private
 * @return {void}
 */
Ext.view.ITable.prototype.initComponent = function() {};

/**
 * [Method] Allows addition of behavior to the destroy operation
 * @return {void}
 */
Ext.view.ITable.prototype.onDestroy = function() {};

/**
 * [Method] Refreshes the grid view
 * @return {void}
 */
Ext.view.ITable.prototype.refresh = function() {};

/**
 * [Method] Removes a CSS Class from a specific row
 * @param {?=} rowInfo HTMLElement/String/Number/Ext.data.Model An HTMLElement, index or instance of a model representing this row
 * @param {string=} cls String
 * @return {void}
 */
Ext.view.ITable.prototype.removeRowCls = function(rowInfo, cls) {};

/**
 * [Method] Navigates from the passed record by the passed increment which may be ve or ve Skips hidden records
 * @param {!Ext.data.IModel=} startRec Ext.data.Model The Record to start from.
 * @param {number=} distance Number The distance to move from the record. May be +ve or -ve.
 * @return {void}
 */
Ext.view.ITable.prototype.walkRecs = function(startRec, distance) {};

/**
 * [Method] Increments the passed row index by the passed increment which may be ve or ve Skips hidden rows
 * @param {number=} startRow Number The zero-based row index to start from.
 * @param {number=} distance Number The distance to move the row by. May be +ve or -ve.
 * @return {void}
 */
Ext.view.ITable.prototype.walkRows = function(startRow, distance) {};
/**
 * @extends {Ext.layout.component.IAuto}
 * @record
 * @struct
 */
Ext.view.ITableLayout = function() {};

/**
 * [Method] Called before any calculation cycles to prepare for layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.view.ITableLayout.prototype.beginLayout = function(ownerContext) {};

/**
 * [Method] Called to perform the calculations for this layout
 * @param {?=} ownerContext Object
 * @return {void}
 */
Ext.view.ITableLayout.prototype.calculate = function(ownerContext) {};

/**
 * [Method] This method is called after all layouts are complete and their calculations flushed to the DOM
 * @return {void}
 */
Ext.view.ITableLayout.prototype.finishedLayout = function() {};
/**
 * @extends {Ext.view.IAbstractView}
 * @record
 * @struct
 */
Ext.view.IView = function() {};
 /** @type {number} */
Ext.view.IView.prototype.mouseOverOutBuffer;

/**
 * [Method] Un highlights the currently highlighted item if any
 * @return {void}
 */
Ext.view.IView.prototype.clearHighlight = function() {};

/**
 * [Method] Focuses a node in the view
 * @param {!Ext.data.IModel=} rec Ext.data.Model The record associated to the node that is to be focused.
 * @return {void}
 */
Ext.view.IView.prototype.focusNode = function(rec) {};

/**
 * [Method] Highlights a given item in the View
 * @param {!HTMLElement=} item HTMLElement The item to highlight
 * @return {void}
 */
Ext.view.IView.prototype.highlightItem = function(item) {};

/**
 * [Method] private
 * @return {void}
 */
Ext.view.IView.prototype.initComponent = function() {};

/**
 * [Method] Refreshes the view by reloading the data from the store and re rendering the template
 * @return {void}
 */
Ext.view.IView.prototype.refresh = function() {};
/**
 * @extends {Ext.view.IAbstractView}
 * @record
 * @struct
 */
Ext.IDataView = function() {};
 /** @type {number} */
Ext.IDataView.prototype.mouseOverOutBuffer;

/**
 * [Method] Un highlights the currently highlighted item if any
 * @return {void}
 */
Ext.IDataView.prototype.clearHighlight = function() {};

/**
 * [Method] Focuses a node in the view
 * @param {!Ext.data.IModel=} rec Ext.data.Model The record associated to the node that is to be focused.
 * @return {void}
 */
Ext.IDataView.prototype.focusNode = function(rec) {};

/**
 * [Method] Highlights a given item in the View
 * @param {!HTMLElement=} item HTMLElement The item to highlight
 * @return {void}
 */
Ext.IDataView.prototype.highlightItem = function(item) {};

/**
 * [Method] private
 * @return {void}
 */
Ext.IDataView.prototype.initComponent = function() {};

/**
 * [Method] Refreshes the view by reloading the data from the store and re rendering the template
 * @return {void}
 */
Ext.IDataView.prototype.refresh = function() {};
/** @const */
Ext.window = {};
/**
 * @extends {Ext.window.IWindow}
 * @record
 * @struct
 */
Ext.window.IMessageBox = function() {};
 /** @type {string} */
Ext.window.IMessageBox.prototype.closeAction;
 /** @type {string} */
Ext.window.IMessageBox.prototype.cls;
 /** @type {boolean} */
Ext.window.IMessageBox.prototype.constrain;
 /** @type {string} */
Ext.window.IMessageBox.prototype.hideMode;
 /** @type {?} */
Ext.window.IMessageBox.prototype.layout;
 /** @type {number} */
Ext.window.IMessageBox.prototype.maxHeight;
 /** @type {number} */
Ext.window.IMessageBox.prototype.maxWidth;
 /** @type {number} */
Ext.window.IMessageBox.prototype.minHeight;
 /** @type {number} */
Ext.window.IMessageBox.prototype.minWidth;
 /** @type {?} */
Ext.window.IMessageBox.prototype.resizable;
 /** @type {?} */
Ext.window.IMessageBox.prototype.shrinkWrapDock;
 /** @type {string} */
Ext.window.IMessageBox.prototype.title;
 /** @type {number} */
Ext.window.IMessageBox.prototype.CANCEL;
 /** @type {string} */
Ext.window.IMessageBox.prototype.ERROR;
 /** @type {string} */
Ext.window.IMessageBox.prototype.INFO;
 /** @type {number} */
Ext.window.IMessageBox.prototype.NO;
 /** @type {number} */
Ext.window.IMessageBox.prototype.OK;
 /** @type {number} */
Ext.window.IMessageBox.prototype.OKCANCEL;
 /** @type {string} */
Ext.window.IMessageBox.prototype.QUESTION;
 /** @type {string} */
Ext.window.IMessageBox.prototype.WARNING;
 /** @type {number} */
Ext.window.IMessageBox.prototype.YES;
 /** @type {number} */
Ext.window.IMessageBox.prototype.YESNO;
 /** @type {number} */
Ext.window.IMessageBox.prototype.YESNOCANCEL;
 /** @type {?} */
Ext.window.IMessageBox.prototype.buttonText;
 /** @type {number} */
Ext.window.IMessageBox.prototype.defaultTextHeight;
 /** @type {number} */
Ext.window.IMessageBox.prototype.minProgressWidth;
 /** @type {number} */
Ext.window.IMessageBox.prototype.minPromptWidth;

/**
 * [Method] Displays a standard read only message box with an OK button comparable to the basic JavaScript alert prompt
 * @param {string=} title String The title bar text
 * @param {string=} msg String The message box body text
 * @param {?=} fn Function The callback function invoked after the message box is closed. See show method for details.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed.
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.window.IMessageBox.prototype.alert = function(title, msg, fn, scope) {};

/**
 * [Method] Displays a confirmation message box with Yes and No buttons comparable to JavaScript s confirm
 * @param {string=} title String The title bar text
 * @param {string=} msg String The message box body text
 * @param {?=} fn Function The callback function invoked after the message box is closed. See show method for details.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed.
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.window.IMessageBox.prototype.confirm = function(title, msg, fn, scope) {};

/**
 * [Method] Hides this Component setting it to invisible using the configured hideMode
 * @return {!Ext.IComponent} Ext.Component this
 */
Ext.window.IMessageBox.prototype.hide = function() {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.window.IMessageBox.prototype.onShow = function() {};

/**
 * [Method] Displays a message box with a progress bar
 * @param {string=} title String The title bar text
 * @param {string=} msg String The message box body text
 * @param {string=} progressText String The text to display inside the progress bar
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.window.IMessageBox.prototype.progress = function(title, msg, progressText) {};

/**
 * [Method] Displays a message box with OK and Cancel buttons prompting the user to enter some text comparable to JavaScript s p
 * @param {string=} title String The title bar text
 * @param {string=} msg String The message box body text
 * @param {?=} fn Function The callback function invoked after the message box is closed. See show method for details.
 * @param {?=} scope Object The scope (this reference) in which the callback is executed.
 * @param {?=} multiline Boolean/Number True to create a multiline textbox using the defaultTextHeight property, or the height in pixels to create the textbox/
 * @param {string=} value String Default value of the text input element
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.window.IMessageBox.prototype.prompt = function(title, msg, fn, scope, multiline, value) {};

/**
 * [Method] Adds the specified icon to the dialog
 * @param {string=} icon String A CSS classname specifying the icon's background image url, or empty string to clear the icon
 * @param {number=} width Number The width of the icon. If not specified, the default is used
 * @param {number=} height Number The height of the icon. If not specified, the default is used
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.window.IMessageBox.prototype.setIcon = function(icon, width, height) {};

/**
 * [Method] Displays a new message box or reinitializes an existing message box based on the config options passed in
 * @param {?=} config Object The following config options are supported:
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.window.IMessageBox.prototype.show = function(config) {};

/**
 * [Method] Updates a progress style message box s text and progress bar
 * @param {number=} value Number Any number between 0 and 1 (e.g., .5)
 * @param {string=} progressText String The progress text to display inside the progress bar.
 * @param {string=} msg String The message box's body text is replaced with the specified string (defaults to undefined so that any existing body text will not get overwritten by default unless a new value is passed in)
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.window.IMessageBox.prototype.updateProgress = function(value, progressText, msg) {};

/**
 * [Method] Displays a message box with an infinitely auto updating progress bar
 * @param {string=} msg String The message box body text
 * @param {string=} title String The title bar text
 * @param {?=} config Object A Ext.ProgressBar.wait config object
 * @return {!Ext.window.IMessageBox} Ext.window.MessageBox this
 */
Ext.window.IMessageBox.prototype.wait = function(msg, title, config) {};
/**
 * @extends {Ext.panel.IPanel}
 * @record
 * @struct
 */
Ext.window.IWindow = function() {};
 /** @type {?} */
Ext.window.IWindow.prototype.animateTarget;
 /** @type {boolean} */
Ext.window.IWindow.prototype.autoRender;
 /** @type {string} */
Ext.window.IWindow.prototype.baseCls;
 /** @type {boolean} */
Ext.window.IWindow.prototype.closable;
 /** @type {boolean} */
Ext.window.IWindow.prototype.collapsed;
 /** @type {boolean} */
Ext.window.IWindow.prototype.collapsible;
 /** @type {boolean} */
Ext.window.IWindow.prototype.constrain;
 /** @type {boolean} */
Ext.window.IWindow.prototype.constrainHeader;
 /** @type {?} */
Ext.window.IWindow.prototype.defaultFocus;
 /** @type {boolean} */
Ext.window.IWindow.prototype.draggable;
 /** @type {boolean} */
Ext.window.IWindow.prototype.expandOnShow;
 /** @type {?} */
Ext.window.IWindow.prototype.ghost;
 /** @type {boolean} */
Ext.window.IWindow.prototype.hidden;
 /** @type {string} */
Ext.window.IWindow.prototype.hideMode;
 /** @type {boolean} */
Ext.window.IWindow.prototype.hideShadowOnDeactivate;
 /** @type {boolean} */
Ext.window.IWindow.prototype.maximizable;
 /** @type {boolean} */
Ext.window.IWindow.prototype.maximized;
 /** @type {number} */
Ext.window.IWindow.prototype.minHeight;
 /** @type {number} */
Ext.window.IWindow.prototype.minWidth;
 /** @type {boolean} */
Ext.window.IWindow.prototype.minimizable;
 /** @type {boolean} */
Ext.window.IWindow.prototype.modal;
 /** @type {?} */
Ext.window.IWindow.prototype.onEsc;
 /** @type {boolean} */
Ext.window.IWindow.prototype.overlapHeader;
 /** @type {boolean} */
Ext.window.IWindow.prototype.plain;
 /** @type {?} */
Ext.window.IWindow.prototype.resizable;
 /** @type {number} */
Ext.window.IWindow.prototype.x;
 /** @type {number} */
Ext.window.IWindow.prototype.y;
 /** @type {!Ext.util.IComponentDragger} */
Ext.window.IWindow.prototype.dd;
 /** @type {boolean} */
Ext.window.IWindow.prototype.isWindow;

/**
 * [Method] Invoked after the Panel is Collapsed
 * @return {void}
 */
Ext.window.IWindow.prototype.afterCollapse = function() {};

/**
 * [Method] Invoked after the Panel is Expanded
 * @return {void}
 */
Ext.window.IWindow.prototype.afterExpand = function() {};

/**
 * [Method] Applies the state to the object
 * @param {?=} state Object
 * @return {void}
 */
Ext.window.IWindow.prototype.applyState = function(state) {};

/**
 * [Method] Gets the configured default focus item
 * @return {void}
 */
Ext.window.IWindow.prototype.getDefaultFocus = function() {};

/**
 * [Method] Fits the window within its current container and automatically replaces the maximize tool button with the restore
 * @param {boolean=} animate Boolean true to animate this Window to full size.
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.window.IWindow.prototype.maximize = function(animate) {};

/**
 * [Method] Placeholder method for minimizing the window
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.window.IWindow.prototype.minimize = function() {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.window.IWindow.prototype.onShow = function() {};

/**
 * [Method] Restores a maximized window back to its original size and position prior to being maximized and also replaces the re
 * @param {?=} animate Object
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.window.IWindow.prototype.restore = function(animate) {};

/**
 * [Method] A shortcut method for toggling between maximize and restore based on the current maximized state of the window
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.window.IWindow.prototype.toggleMaximize = function() {};
/**
 * @extends {Ext.panel.IPanel}
 * @record
 * @struct
 */
Ext.IWindow = function() {};
 /** @type {?} */
Ext.IWindow.prototype.animateTarget;
 /** @type {boolean} */
Ext.IWindow.prototype.autoRender;
 /** @type {string} */
Ext.IWindow.prototype.baseCls;
 /** @type {boolean} */
Ext.IWindow.prototype.closable;
 /** @type {boolean} */
Ext.IWindow.prototype.collapsed;
 /** @type {boolean} */
Ext.IWindow.prototype.collapsible;
 /** @type {boolean} */
Ext.IWindow.prototype.constrain;
 /** @type {boolean} */
Ext.IWindow.prototype.constrainHeader;
 /** @type {?} */
Ext.IWindow.prototype.defaultFocus;
 /** @type {boolean} */
Ext.IWindow.prototype.draggable;
 /** @type {boolean} */
Ext.IWindow.prototype.expandOnShow;
 /** @type {?} */
Ext.IWindow.prototype.ghost;
 /** @type {boolean} */
Ext.IWindow.prototype.hidden;
 /** @type {string} */
Ext.IWindow.prototype.hideMode;
 /** @type {boolean} */
Ext.IWindow.prototype.hideShadowOnDeactivate;
 /** @type {boolean} */
Ext.IWindow.prototype.maximizable;
 /** @type {boolean} */
Ext.IWindow.prototype.maximized;
 /** @type {number} */
Ext.IWindow.prototype.minHeight;
 /** @type {number} */
Ext.IWindow.prototype.minWidth;
 /** @type {boolean} */
Ext.IWindow.prototype.minimizable;
 /** @type {boolean} */
Ext.IWindow.prototype.modal;
 /** @type {?} */
Ext.IWindow.prototype.onEsc;
 /** @type {boolean} */
Ext.IWindow.prototype.overlapHeader;
 /** @type {boolean} */
Ext.IWindow.prototype.plain;
 /** @type {?} */
Ext.IWindow.prototype.resizable;
 /** @type {number} */
Ext.IWindow.prototype.x;
 /** @type {number} */
Ext.IWindow.prototype.y;
 /** @type {!Ext.util.IComponentDragger} */
Ext.IWindow.prototype.dd;
 /** @type {boolean} */
Ext.IWindow.prototype.isWindow;

/**
 * [Method] Invoked after the Panel is Collapsed
 * @return {void}
 */
Ext.IWindow.prototype.afterCollapse = function() {};

/**
 * [Method] Invoked after the Panel is Expanded
 * @return {void}
 */
Ext.IWindow.prototype.afterExpand = function() {};

/**
 * [Method] Applies the state to the object
 * @param {?=} state Object
 * @return {void}
 */
Ext.IWindow.prototype.applyState = function(state) {};

/**
 * [Method] Gets the configured default focus item
 * @return {void}
 */
Ext.IWindow.prototype.getDefaultFocus = function() {};

/**
 * [Method] Fits the window within its current container and automatically replaces the maximize tool button with the restore
 * @param {boolean=} animate Boolean true to animate this Window to full size.
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.IWindow.prototype.maximize = function(animate) {};

/**
 * [Method] Placeholder method for minimizing the window
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.IWindow.prototype.minimize = function() {};

/**
 * [Method] Allows addition of behavior to the show operation
 * @return {void}
 */
Ext.IWindow.prototype.onShow = function() {};

/**
 * [Method] Restores a maximized window back to its original size and position prior to being maximized and also replaces the re
 * @param {?=} animate Object
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.IWindow.prototype.restore = function(animate) {};

/**
 * [Method] A shortcut method for toggling between maximize and restore based on the current maximized state of the window
 * @return {!Ext.window.IWindow} Ext.window.Window this
 */
Ext.IWindow.prototype.toggleMaximize = function() {};
/**
 * @extends {Ext.IZIndexManager}
 * @record
 * @struct
 */
Ext.IWindowManager = function() {};
/**
 * @constructor
 * @struct
 */
Ext.WindowManager = function() {};
 /** @type {!Ext.IClass} */
Ext.WindowManager.self;

/**
 * [Method] Brings the specified Component to the front of any other active Components in this ZIndexManager
 * @param {?=} comp String/Object The id of the Component or a Ext.Component instance
 * @return {boolean} Boolean True if the dialog was brought to the front, else false if it was already in front
 */
Ext.WindowManager.bringToFront = function(comp) {};

/**
 * [Method] Call the original method that was previously overridden with override Ext define My Cat  constructor functi
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callOverridden(arguments)
 * @return {?} Object Returns the result of calling the overridden method
 */
Ext.WindowManager.callOverridden = function(args) {};

/**
 * [Method] Call the parent method of the current method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callParent(arguments)
 * @return {?} Object Returns the result of calling the parent method
 */
Ext.WindowManager.callParent = function(args) {};

/**
 * [Method] This method is used by an override to call the superclass method but bypass any overridden method
 * @param {?=} args Array/Arguments The arguments, either an array or the arguments object from the current method, for example: this.callSuper(arguments)
 * @return {?} Object Returns the result of calling the superclass method
 */
Ext.WindowManager.callSuper = function(args) {};

/**
 * [Method] Executes the specified function once for every Component in this ZIndexManager passing each Component as the only pa
 * @param {?=} fn Function The function to execute for each item
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current Component in the iteration.
 * @return {void}
 */
Ext.WindowManager.each = function(fn, scope) {};

/**
 * [Method] Executes the specified function once for every Component in this ZIndexManager passing each Component as the only pa
 * @param {?=} fn Function The function to execute for each item
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current Component in the iteration.
 * @return {void}
 */
Ext.WindowManager.eachBottomUp = function(fn, scope) {};

/**
 * [Method] Executes the specified function once for every Component in this ZIndexManager passing each Component as the only pa
 * @param {?=} fn Function The function to execute for each item
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current Component in the iteration.
 * @return {void}
 */
Ext.WindowManager.eachTopDown = function(fn, scope) {};

/**
 * [Method] Gets a registered Component by id
 * @param {?=} id String/Object The id of the Component or a Ext.Component instance
 * @return {!Ext.IComponent} Ext.Component
 */
Ext.WindowManager.get = function(id) {};

/**
 * [Method] Gets the currently active Component in this ZIndexManager
 * @return {!Ext.IComponent} Ext.Component The active Component
 */
Ext.WindowManager.getActive = function() {};

/**
 * [Method] Returns zero or more Components in this ZIndexManager using the custom search function passed to this method
 * @param {?=} fn Function The search function
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the Component being tested. That gets passed to the function if not specified.
 * @return {!Array<?>} Array An array of zero or more matching windows
 */
Ext.WindowManager.getBy = function(fn, scope) {};

/**
 * [Method] Returns the initial configuration passed to constructor when instantiating this class
 * @param {string=} name String Name of the config option to return.
 * @return {?} Object/Mixed The full config object or a single config value when name parameter specified.
 */
Ext.WindowManager.getInitialConfig = function(name) {};

/**
 * [Method] Hides all Components managed by this ZIndexManager
 * @return {void}
 */
Ext.WindowManager.hideAll = function() {};

/**
 * [Method] Initialize configuration for this class
 * @param {?=} config Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.WindowManager.initConfig = function(config) {};

/**
 * [Method] Registers a floating Ext Component with this ZIndexManager
 * @param {!Ext.IComponent=} comp Ext.Component The Component to register.
 * @return {void}
 */
Ext.WindowManager.register = function(comp) {};

/**
 * [Method] Sends the specified Component to the back of other active Components in this ZIndexManager
 * @param {?=} comp String/Object The id of the Component or a Ext.Component instance
 * @return {!Ext.IComponent} Ext.Component The Component
 */
Ext.WindowManager.sendToBack = function(comp) {};

/**
 * [Method] Get the reference to the class from which this object was instantiated
 * @return {!Ext.IClass} Ext.Class
 */
Ext.WindowManager.statics = function() {};

/**
 * [Method] Unregisters a Ext Component from this ZIndexManager
 * @param {!Ext.IComponent=} comp Ext.Component The Component to unregister.
 * @return {void}
 */
Ext.WindowManager.unregister = function(comp) {};
/**
 * @extends {Ext.ITemplate}
 * @record
 * @struct
 */
Ext.IXTemplate = function() {};
 /** @type {?} */
Ext.IXTemplate.prototype.definitions;

/**
 * [Method] Appends the result of this template to the provided output array
 * @param {?=} values Object
 * @param {?=} out Object
 * @param {?=} parent Object
 * @return {!Array<?>} Array The given out array.
 */
Ext.IXTemplate.prototype.applyOut = function(values, out, parent) {};
/**
 * @constructor
 * @struct
 */
Ext.XTemplate = function() {};

/**
 * [Method] Add methods  properties to the prototype of this class
 * @param {?=} members Object
 * @return {void}
 */
Ext.XTemplate.addMembers = function(members) {};

/**
 * [Method] Add  override static properties of this class
 * @param {?=} members Object
 * @return {!Ext.IBase} Ext.Base this
 */
Ext.XTemplate.addStatics = function(members) {};

/**
 * [Method] Create a new instance of this Class
 * @return {?} Object the created instance.
 */
Ext.XTemplate.create = function() {};

/**
 * [Method] Create aliases for existing prototype methods
 * @param {?=} alias String/Object The new method name, or an object to set multiple aliases. See flexSetter
 * @param {?=} origin String/Object The original method name
 * @return {void}
 */
Ext.XTemplate.createAlias = function(alias, origin) {};

/**
 * [Method] Creates a template from the passed element s value display none textarea preferred or innerHTML
 * @param {?=} el String/HTMLElement A DOM element or its id
 * @param {?=} config Object Config object
 * @return {!Ext.ITemplate} Ext.Template The created template
 */
Ext.XTemplate.from = function(el, config) {};

/**
 * [Method] Get the current class name in string format
 * @return {string} String className
 */
Ext.XTemplate.getName = function() {};

/**
 * [Method] Gets an XTemplate from an object an instance of an Ext define d class
 * @param {?=} instance Object The object from which to get the XTemplate (must be an instance of an Ext.define'd class).
 * @param {string=} name String The name of the property by which to get the XTemplate.
 * @return {!Ext.IXTemplate} Ext.XTemplate The XTemplate instance or null if not found.
 */
Ext.XTemplate.getTpl = function(instance, name) {};

/**
 * [Method] Adds members to class
 * @return {void}
 */
Ext.XTemplate.implement = function() {};

/**
 * [Method] Override members of this class
 * @param {?=} members Object The properties to add to this class. This should be specified as an object literal containing one or more properties.
 * @return {!Ext.IBase} Ext.Base this class
 */
Ext.XTemplate.override = function(members) {};
/**
 * @extends {Ext.IXTemplateParser}
 * @record
 * @struct
 */
Ext.IXTemplateCompiler = function() {};

/**
 * [Method] This method is called to process lt tpl case action gt
 * @param {?=} action Object
 * @return {void}
 */
Ext.IXTemplateCompiler.prototype.doCase = function(action) {};

/**
 * [Method] This method is called to process lt tpl default gt
 * @return {void}
 */
Ext.IXTemplateCompiler.prototype.doDefault = function() {};

/**
 * [Method] This method is called to process lt tpl else gt
 * @return {void}
 */
Ext.IXTemplateCompiler.prototype.doElse = function() {};

/**
 * [Method] This method is called to process lt tpl elseif action gt
 * @param {?=} action Object
 * @param {?=} actions Object
 * @return {void}
 */
Ext.IXTemplateCompiler.prototype.doElseIf = function(action, actions) {};

/**
 * [Method] This method is called to process lt tpl gt
 * @param {?=} type Object
 * @param {?=} actions Object
 * @return {void}
 */
Ext.IXTemplateCompiler.prototype.doEnd = function(type, actions) {};

/**
 * [Method] This method is called to process text
 * @param {?=} text Object
 * @return {void}
 */
Ext.IXTemplateCompiler.prototype.doEval = function(text) {};

/**
 * [Method] This method is called to process lt tpl exec action gt
 * @param {?=} action Object
 * @param {?=} actions Object
 * @return {void}
 */
Ext.IXTemplateCompiler.prototype.doExec = function(action, actions) {};

/**
 * [Method] This method is called to process expressions like  expr
 * @param {?=} expr Object
 * @return {void}
 */
Ext.IXTemplateCompiler.prototype.doExpr = function(expr) {};

/**
 * [Method] This method is called to process lt tpl for action gt
 * @param {?=} action Object
 * @param {?=} actions Object
 * @return {void}
 */
Ext.IXTemplateCompiler.prototype.doFor = function(action, actions) {};

/**
 * [Method] This method is called to process lt tpl foreach action gt
 * @param {?=} action Object
 * @param {?=} actions Object
 * @return {void}
 */
Ext.IXTemplateCompiler.prototype.doForEach = function(action, actions) {};

/**
 * [Method] This method is called to process lt tpl if action gt
 * @param {?=} action Object
 * @param {?=} actions Object
 * @return {void}
 */
Ext.IXTemplateCompiler.prototype.doIf = function(action, actions) {};

/**
 * [Method] This method is called to process lt tpl switch action gt
 * @param {?=} action Object
 * @return {void}
 */
Ext.IXTemplateCompiler.prototype.doSwitch = function(action) {};

/**
 * [Method] This method is called to process simple tags like tag
 * @param {?=} tag Object
 * @return {void}
 */
Ext.IXTemplateCompiler.prototype.doTag = function(tag) {};

/**
 * [Method] XTemplateParser callouts
 * @param {?=} text Object
 * @return {void}
 */
Ext.IXTemplateCompiler.prototype.doText = function(text) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IXTemplateParser = function() {};
 /** @type {number} */
Ext.IXTemplateParser.prototype.level;

/**
 * [Method] This method is called to process lt tpl case action gt
 * @param {string=} action String
 * @param {?=} actions Object Other actions keyed by the attribute name (such as 'exec').
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doCase = function(action, actions) {};

/**
 * [Method] This method is called to process lt tpl default gt
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doDefault = function() {};

/**
 * [Method] This method is called to process lt tpl else gt
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doElse = function() {};

/**
 * [Method] This method is called to process lt tpl elseif action gt
 * @param {string=} action String
 * @param {?=} actions Object Other actions keyed by the attribute name (such as 'exec').
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doElseIf = function(action, actions) {};

/**
 * [Method] This method is called to process lt tpl gt
 * @param {string=} type String The type of action that is being ended.
 * @param {?=} actions Object The other actions keyed by the attribute name (such as 'exec').
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doEnd = function(type, actions) {};

/**
 * [Method] This method is called to process text
 * @param {string=} text String
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doEval = function(text) {};

/**
 * [Method] This method is called to process lt tpl exec action gt
 * @param {string=} action String
 * @param {?=} actions Object Other actions keyed by the attribute name.
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doExec = function(action, actions) {};

/**
 * [Method] This method is called to process expressions like  expr
 * @param {string=} expr String The body of the expression (inside "{[" and "]}").
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doExpr = function(expr) {};

/**
 * [Method] This method is called to process lt tpl for action gt
 * @param {string=} action String
 * @param {?=} actions Object Other actions keyed by the attribute name (such as 'exec').
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doFor = function(action, actions) {};

/**
 * [Method] This method is called to process lt tpl foreach action gt
 * @param {string=} action String
 * @param {?=} actions Object Other actions keyed by the attribute name (such as 'exec').
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doForEach = function(action, actions) {};

/**
 * [Method] This method is called to process lt tpl if action gt
 * @param {string=} action String
 * @param {?=} actions Object Other actions keyed by the attribute name (such as 'exec').
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doIf = function(action, actions) {};

/**
 * [Method] This method is called to process lt tpl switch action gt
 * @param {string=} action String
 * @param {?=} actions Object Other actions keyed by the attribute name (such as 'exec').
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doSwitch = function(action, actions) {};

/**
 * [Method] This method is called to process simple tags like tag
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doTag = function() {};

/**
 * [Method] This method is called to process a piece of raw text from the tpl
 * @param {string=} text String
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doText = function(text) {};

/**
 * [Method] This method is called to process an empty lt tpl gt
 * @return {void}
 */
Ext.IXTemplateParser.prototype.doTpl = function() {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IZIndexManager = function() {};

/**
 * [Method] Brings the specified Component to the front of any other active Components in this ZIndexManager
 * @param {?=} comp String/Object The id of the Component or a Ext.Component instance
 * @return {boolean} Boolean True if the dialog was brought to the front, else false if it was already in front
 */
Ext.IZIndexManager.prototype.bringToFront = function(comp) {};

/**
 * [Method] Executes the specified function once for every Component in this ZIndexManager passing each Component as the only pa
 * @param {?=} fn Function The function to execute for each item
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current Component in the iteration.
 * @return {void}
 */
Ext.IZIndexManager.prototype.each = function(fn, scope) {};

/**
 * [Method] Executes the specified function once for every Component in this ZIndexManager passing each Component as the only pa
 * @param {?=} fn Function The function to execute for each item
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current Component in the iteration.
 * @return {void}
 */
Ext.IZIndexManager.prototype.eachBottomUp = function(fn, scope) {};

/**
 * [Method] Executes the specified function once for every Component in this ZIndexManager passing each Component as the only pa
 * @param {?=} fn Function The function to execute for each item
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current Component in the iteration.
 * @return {void}
 */
Ext.IZIndexManager.prototype.eachTopDown = function(fn, scope) {};

/**
 * [Method] Gets a registered Component by id
 * @param {?=} id String/Object The id of the Component or a Ext.Component instance
 * @return {!Ext.IComponent} Ext.Component
 */
Ext.IZIndexManager.prototype.get = function(id) {};

/**
 * [Method] Gets the currently active Component in this ZIndexManager
 * @return {!Ext.IComponent} Ext.Component The active Component
 */
Ext.IZIndexManager.prototype.getActive = function() {};

/**
 * [Method] Returns zero or more Components in this ZIndexManager using the custom search function passed to this method
 * @param {?=} fn Function The search function
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the Component being tested. That gets passed to the function if not specified.
 * @return {!Array<?>} Array An array of zero or more matching windows
 */
Ext.IZIndexManager.prototype.getBy = function(fn, scope) {};

/**
 * [Method] Hides all Components managed by this ZIndexManager
 * @return {void}
 */
Ext.IZIndexManager.prototype.hideAll = function() {};

/**
 * [Method] Registers a floating Ext Component with this ZIndexManager
 * @param {!Ext.IComponent=} comp Ext.Component The Component to register.
 * @return {void}
 */
Ext.IZIndexManager.prototype.register = function(comp) {};

/**
 * [Method] Sends the specified Component to the back of other active Components in this ZIndexManager
 * @param {?=} comp String/Object The id of the Component or a Ext.Component instance
 * @return {!Ext.IComponent} Ext.Component The Component
 */
Ext.IZIndexManager.prototype.sendToBack = function(comp) {};

/**
 * [Method] Unregisters a Ext Component from this ZIndexManager
 * @param {!Ext.IComponent=} comp Ext.Component The Component to unregister.
 * @return {void}
 */
Ext.IZIndexManager.prototype.unregister = function(comp) {};
/**
 * @extends {Ext.IBase}
 * @record
 * @struct
 */
Ext.IWindowGroup = function() {};

/**
 * [Method] Brings the specified Component to the front of any other active Components in this ZIndexManager
 * @param {?=} comp String/Object The id of the Component or a Ext.Component instance
 * @return {boolean} Boolean True if the dialog was brought to the front, else false if it was already in front
 */
Ext.IWindowGroup.prototype.bringToFront = function(comp) {};

/**
 * [Method] Executes the specified function once for every Component in this ZIndexManager passing each Component as the only pa
 * @param {?=} fn Function The function to execute for each item
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current Component in the iteration.
 * @return {void}
 */
Ext.IWindowGroup.prototype.each = function(fn, scope) {};

/**
 * [Method] Executes the specified function once for every Component in this ZIndexManager passing each Component as the only pa
 * @param {?=} fn Function The function to execute for each item
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current Component in the iteration.
 * @return {void}
 */
Ext.IWindowGroup.prototype.eachBottomUp = function(fn, scope) {};

/**
 * [Method] Executes the specified function once for every Component in this ZIndexManager passing each Component as the only pa
 * @param {?=} fn Function The function to execute for each item
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the current Component in the iteration.
 * @return {void}
 */
Ext.IWindowGroup.prototype.eachTopDown = function(fn, scope) {};

/**
 * [Method] Gets a registered Component by id
 * @param {?=} id String/Object The id of the Component or a Ext.Component instance
 * @return {!Ext.IComponent} Ext.Component
 */
Ext.IWindowGroup.prototype.get = function(id) {};

/**
 * [Method] Gets the currently active Component in this ZIndexManager
 * @return {!Ext.IComponent} Ext.Component The active Component
 */
Ext.IWindowGroup.prototype.getActive = function() {};

/**
 * [Method] Returns zero or more Components in this ZIndexManager using the custom search function passed to this method
 * @param {?=} fn Function The search function
 * @param {?=} scope Object The scope (this reference) in which the function is executed. Defaults to the Component being tested. That gets passed to the function if not specified.
 * @return {!Array<?>} Array An array of zero or more matching windows
 */
Ext.IWindowGroup.prototype.getBy = function(fn, scope) {};

/**
 * [Method] Hides all Components managed by this ZIndexManager
 * @return {void}
 */
Ext.IWindowGroup.prototype.hideAll = function() {};

/**
 * [Method] Registers a floating Ext Component with this ZIndexManager
 * @param {!Ext.IComponent=} comp Ext.Component The Component to register.
 * @return {void}
 */
Ext.IWindowGroup.prototype.register = function(comp) {};

/**
 * [Method] Sends the specified Component to the back of other active Components in this ZIndexManager
 * @param {?=} comp String/Object The id of the Component or a Ext.Component instance
 * @return {!Ext.IComponent} Ext.Component The Component
 */
Ext.IWindowGroup.prototype.sendToBack = function(comp) {};

/**
 * [Method] Unregisters a Ext Component from this ZIndexManager
 * @param {!Ext.IComponent=} comp Ext.Component The Component to unregister.
 * @return {void}
 */
Ext.IWindowGroup.prototype.unregister = function(comp) {};
