/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/winrt-uwp/index.d.ts:
/** @const */
var Windows = {};
/**
 * @record
 * @struct
 */
Windows.WinRTError = function() {};
 /** @type {string} */
Windows.WinRTError.prototype.description;
 /** @type {number} */
Windows.WinRTError.prototype.number;
/**
 * @record
 * @struct
 */
Windows.WinRTEvent = function() {};
 /** @type {!Array<?>} */
Windows.WinRTEvent.prototype.detail;
 /** @type {TSender} */
Windows.WinRTEvent.prototype.target;
 /** @type {string} */
Windows.WinRTEvent.prototype.type;
/**
 * @record
 * @struct
 */
Windows.IInspectable = function() {};
/** @const */
Windows.Foundation = {};
/**
 * @record
 * @struct
 */
Windows.Foundation.IPromise = function() {};

/**
 * @template U
 * @param {function(TResult): !Windows.Foundation.IPromise<U>|function(TResult): U=} success
 * @param {function(?): !Windows.Foundation.IPromise<U>|function(?): U=} error
 * @param {function(?): void=} progress
 * @return {!Windows.Foundation.IPromise<U>}
 */
Windows.Foundation.IPromise.prototype.then = function(success, error, progress) {};

/**
 * @template U
 * @param {function(TResult): ?=} success
 * @param {function(?): ?=} error
 * @param {function(?): void=} progress
 * @return {void}
 */
Windows.Foundation.IPromise.prototype.done = function(success, error, progress) {};

/**
 * @return {void}
 */
Windows.Foundation.IPromise.prototype.cancel = function() {};
/**
 * @extends {Windows.Foundation.IPromise}
 * @record
 * @struct
 */
Windows.Foundation.IPromiseWithOperation = function() {};
 /** @type {TOperation} */
Windows.Foundation.IPromiseWithOperation.prototype.operation;

/** @typedef {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} */
Windows.Foundation.IPromiseWithIAsyncAction;

/** @typedef {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncActionWithProgress<TProgress>>} */
Windows.Foundation.IPromiseWithIAsyncActionWithProgress;

/** @typedef {!Windows.Foundation.IPromiseWithOperation<TResult, !Windows.Foundation.IAsyncOperation<TResult>>} */
Windows.Foundation.IPromiseWithIAsyncOperation;

/** @typedef {!Windows.Foundation.IPromiseWithOperation<TResult, !Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>>} */
Windows.Foundation.IPromiseWithIAsyncOperationWithProgress;
/** @const */
Windows.Foundation.Collections = {};
/**
 * @record
 * @struct
 */
Windows.Foundation.Collections.IVector = function() {};

/**
 * @param {T} value_or_searchElement
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Foundation.Collections.IVector.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};
/**
 * @record
 * @struct
 */
Windows.Foundation.Collections.IVectorView = function() {};

/**
 * @param {T} value_or_searchElement
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Foundation.Collections.IVectorView.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};
/** @const */
Windows.Media = {};
/** @const */
Windows.Media.Core = {};
/**
 * @record
 * @struct
 */
Windows.Media.Core.MseStreamSource = function() {};
/** @const */
Windows.Networking = {};
/** @const */
Windows.Networking.Sockets = {};
/**
 * @record
 * @struct
 */
Windows.Networking.Sockets.IWebSocket = function() {};

/**
 * @return {void}
 */
Windows.Networking.Sockets.IWebSocket.prototype.close = function() {};
/** @const */
Windows.ApplicationModel = {};
/** @const */
Windows.ApplicationModel.Activation = {};

/** @const */
Windows.ApplicationModel.Activation.ActivationKind = {};
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.launch;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.search;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.shareTarget;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.file;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.protocol;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.fileOpenPicker;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.fileSavePicker;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.cachedFileUpdater;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.contactPicker;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.device;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.printTaskSettings;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.cameraSettings;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.restrictedLaunch;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.appointmentsProvider;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.contact;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.lockScreenCall;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.voiceCommand;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.lockScreen;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.pickerReturned;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.walletAction;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.pickFileContinuation;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.pickSaveFileContinuation;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.pickFolderContinuation;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.webAuthenticationBrokerContinuation;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.webAccountProvider;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.componentUI;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.protocolForResults;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.toastNotification;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.print3DWorkflow;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.dialReceiver;
/** @const {number} */
Windows.ApplicationModel.Activation.ActivationKind.devicePairing;

/** @const */
Windows.ApplicationModel.Activation.ApplicationExecutionState = {};
/** @const {number} */
Windows.ApplicationModel.Activation.ApplicationExecutionState.notRunning;
/** @const {number} */
Windows.ApplicationModel.Activation.ApplicationExecutionState.running;
/** @const {number} */
Windows.ApplicationModel.Activation.ApplicationExecutionState.suspended;
/** @const {number} */
Windows.ApplicationModel.Activation.ApplicationExecutionState.terminated;
/** @const {number} */
Windows.ApplicationModel.Activation.ApplicationExecutionState.closedByUser;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs = function() {};
 /** @type {!Windows.ApplicationModel.Appointments.AppointmentsProvider.AddAppointmentOperation} */
Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs.prototype.addAppointmentOperation;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.ApplicationModel.Activation.AppointmentsProviderAddAppointmentActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Appointments.AppointmentsProvider.RemoveAppointmentOperation} */
Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs.prototype.removeAppointmentOperation;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.ApplicationModel.Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Appointments.AppointmentsProvider.ReplaceAppointmentOperation} */
Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs.prototype.replaceAppointmentOperation;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.ApplicationModel.Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs = function() {};
 /** @type {!Date} */
Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.instanceStartDate;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.kind;
 /** @type {string} */
Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.localId;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.previousExecutionState;
 /** @type {string} */
Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.roamingId;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.ApplicationModel.Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs = function() {};
 /** @type {number} */
Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs.prototype.duration;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs.prototype.splashScreen;
 /** @type {!Date} */
Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs.prototype.timeToShow;
 /** @type {string} */
Windows.ApplicationModel.Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs = function() {};
 /** @type {!Windows.Storage.Provider.CachedFileUpdaterUI} */
Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs.prototype.cachedFileUpdaterUI;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs.prototype.splashScreen;
 /** @type {?} */
Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs.prototype.videoDeviceController;
 /** @type {?} */
Windows.ApplicationModel.Activation.CameraSettingsActivatedEventArgs.prototype.videoDeviceExtension;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs = function() {};
 /** @type {!Windows.ApplicationModel.Contacts.Contact} */
Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs.prototype.contact;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs.prototype.previousExecutionState;
 /** @type {string} */
Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs.prototype.serviceId;
 /** @type {string} */
Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs.prototype.serviceUserId;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.ApplicationModel.Activation.ContactCallActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs = function() {};
 /** @type {!Windows.ApplicationModel.Contacts.ContactAddress} */
Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs.prototype.address;
 /** @type {!Windows.ApplicationModel.Contacts.Contact} */
Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs.prototype.contact;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.ApplicationModel.Activation.ContactMapActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs = function() {};
 /** @type {!Windows.ApplicationModel.Contacts.Contact} */
Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs.prototype.contact;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs.prototype.previousExecutionState;
 /** @type {string} */
Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs.prototype.serviceId;
 /** @type {string} */
Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs.prototype.serviceUserId;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.ApplicationModel.Activation.ContactMessageActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.ContactPickerActivatedEventArgs = function() {};
 /** @type {!Windows.ApplicationModel.Contacts.Provider.ContactPickerUI} */
Windows.ApplicationModel.Activation.ContactPickerActivatedEventArgs.prototype.contactPickerUI;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.ContactPickerActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.ContactPickerActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.ContactPickerActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs = function() {};
 /** @type {!Windows.ApplicationModel.Contacts.Contact} */
Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs.prototype.contact;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs.prototype.previousExecutionState;
 /** @type {string} */
Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs.prototype.serviceId;
 /** @type {string} */
Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs.prototype.serviceUserId;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.ApplicationModel.Activation.ContactPostActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs = function() {};
 /** @type {!Windows.ApplicationModel.Contacts.Contact} */
Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs.prototype.contact;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs.prototype.previousExecutionState;
 /** @type {string} */
Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs.prototype.serviceId;
 /** @type {string} */
Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs.prototype.serviceUserId;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.ApplicationModel.Activation.ContactVideoCallActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.DeviceActivatedEventArgs = function() {};
 /** @type {number} */
Windows.ApplicationModel.Activation.DeviceActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {string} */
Windows.ApplicationModel.Activation.DeviceActivatedEventArgs.prototype.deviceInformationId;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.DeviceActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.DeviceActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.DeviceActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.ApplicationModel.Activation.DeviceActivatedEventArgs.prototype.verb;
 /** @type {!Windows.UI.ViewManagement.ActivationViewSwitcher} */
Windows.ApplicationModel.Activation.DeviceActivatedEventArgs.prototype.viewSwitcher;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs = function() {};
 /** @type {?} */
Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs.prototype.deviceInformation;
 /** @type {?} */
Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs.prototype.kind;
 /** @type {?} */
Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs.prototype.previousExecutionState;
 /** @type {?} */
Windows.ApplicationModel.Activation.DevicePairingActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs.prototype.appName;
 /** @type {string} */
Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs.prototype.arguments;
 /** @type {number} */
Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs.prototype.tileId;
 /** @type {!Windows.UI.ViewManagement.ActivationViewSwitcher} */
Windows.ApplicationModel.Activation.DialReceiverActivatedEventArgs.prototype.viewSwitcher;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.FileActivatedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Activation.FileActivatedEventArgs.prototype.callerPackageFamilyName;
 /** @type {number} */
Windows.ApplicationModel.Activation.FileActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Storage.IStorageItem>} */
Windows.ApplicationModel.Activation.FileActivatedEventArgs.prototype.files;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.FileActivatedEventArgs.prototype.kind;
 /** @type {!Windows.Storage.Search.StorageFileQueryResult} */
Windows.ApplicationModel.Activation.FileActivatedEventArgs.prototype.neighboringFilesQuery;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.FileActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.FileActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.ApplicationModel.Activation.FileActivatedEventArgs.prototype.verb;
 /** @type {!Windows.UI.ViewManagement.ActivationViewSwitcher} */
Windows.ApplicationModel.Activation.FileActivatedEventArgs.prototype.viewSwitcher;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs.prototype.callerPackageFamilyName;
 /** @type {!Windows.Storage.Pickers.Provider.FileOpenPickerUI} */
Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs.prototype.fileOpenPickerUI;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs = function() {};
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs.prototype.continuationData;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Storage.StorageFile>} */
Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs.prototype.files;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.FileOpenPickerContinuationEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs.prototype.callerPackageFamilyName;
 /** @type {string} */
Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs.prototype.enterpriseId;
 /** @type {!Windows.Storage.Pickers.Provider.FileSavePickerUI} */
Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs.prototype.fileSavePickerUI;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs = function() {};
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs.prototype.continuationData;
 /** @type {!Windows.Storage.StorageFile} */
Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs.prototype.file;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.FileSavePickerContinuationEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs = function() {};
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs.prototype.continuationData;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs.prototype.folder;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.FolderPickerContinuationEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.LaunchActivatedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Activation.LaunchActivatedEventArgs.prototype.arguments;
 /** @type {number} */
Windows.ApplicationModel.Activation.LaunchActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.LaunchActivatedEventArgs.prototype.kind;
 /** @type {boolean} */
Windows.ApplicationModel.Activation.LaunchActivatedEventArgs.prototype.prelaunchActivated;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.LaunchActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.LaunchActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.ApplicationModel.Activation.LaunchActivatedEventArgs.prototype.tileId;
 /** @type {!Windows.UI.ViewManagement.ActivationViewSwitcher} */
Windows.ApplicationModel.Activation.LaunchActivatedEventArgs.prototype.viewSwitcher;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs = function() {};
 /** @type {?} */
Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs.prototype.info;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.LockScreenActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs.prototype.arguments;
 /** @type {!Windows.ApplicationModel.Calls.LockScreenCallUI} */
Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs.prototype.callUI;
 /** @type {number} */
Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs.prototype.tileId;
 /** @type {!Windows.UI.ViewManagement.ActivationViewSwitcher} */
Windows.ApplicationModel.Activation.LockScreenCallActivatedEventArgs.prototype.viewSwitcher;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.PickerReturnedActivatedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.PickerReturnedActivatedEventArgs.prototype.kind;
 /** @type {string} */
Windows.ApplicationModel.Activation.PickerReturnedActivatedEventArgs.prototype.pickerOperationId;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.PickerReturnedActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.PickerReturnedActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.Print3DWorkflowActivatedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.Print3DWorkflowActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.Print3DWorkflowActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.Print3DWorkflowActivatedEventArgs.prototype.splashScreen;
 /** @type {!Windows.Devices.Printers.Extensions.Print3DWorkflow} */
Windows.ApplicationModel.Activation.Print3DWorkflowActivatedEventArgs.prototype.workflow;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.PrintTaskSettingsActivatedEventArgs = function() {};
 /** @type {!Windows.Devices.Printers.Extensions.PrintTaskConfiguration} */
Windows.ApplicationModel.Activation.PrintTaskSettingsActivatedEventArgs.prototype.configuration;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.PrintTaskSettingsActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.PrintTaskSettingsActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.PrintTaskSettingsActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs.prototype.callerPackageFamilyName;
 /** @type {number} */
Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs.prototype.data;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs.prototype.splashScreen;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs.prototype.uri;
 /** @type {!Windows.UI.ViewManagement.ActivationViewSwitcher} */
Windows.ApplicationModel.Activation.ProtocolActivatedEventArgs.prototype.viewSwitcher;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs.prototype.callerPackageFamilyName;
 /** @type {number} */
Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs.prototype.data;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.System.ProtocolForResultsOperation} */
Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs.prototype.protocolForResultsOperation;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs.prototype.splashScreen;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs.prototype.uri;
 /** @type {!Windows.UI.ViewManagement.ActivationViewSwitcher} */
Windows.ApplicationModel.Activation.ProtocolForResultsActivatedEventArgs.prototype.viewSwitcher;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs.prototype.previousExecutionState;
 /** @type {?} */
Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs.prototype.sharedContext;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.RestrictedLaunchActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.SearchActivatedEventArgs = function() {};
 /** @type {number} */
Windows.ApplicationModel.Activation.SearchActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.SearchActivatedEventArgs.prototype.kind;
 /** @type {string} */
Windows.ApplicationModel.Activation.SearchActivatedEventArgs.prototype.language;
 /** @type {!Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails} */
Windows.ApplicationModel.Activation.SearchActivatedEventArgs.prototype.linguisticDetails;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.SearchActivatedEventArgs.prototype.previousExecutionState;
 /** @type {string} */
Windows.ApplicationModel.Activation.SearchActivatedEventArgs.prototype.queryText;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.SearchActivatedEventArgs.prototype.splashScreen;
 /** @type {!Windows.UI.ViewManagement.ActivationViewSwitcher} */
Windows.ApplicationModel.Activation.SearchActivatedEventArgs.prototype.viewSwitcher;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation} */
Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs.prototype.shareOperation;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.SplashScreen = function() {};
 /** @type {!Windows.Foundation.Rect} */
Windows.ApplicationModel.Activation.SplashScreen.prototype.imageLocation;
 /** @type {function(?): void} */
Windows.ApplicationModel.Activation.SplashScreen.prototype.ondismissed;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Activation.SplashScreen.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Activation.SplashScreen.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs.prototype.argument;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs.prototype.splashScreen;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.ApplicationModel.Activation.ToastNotificationActivatedEventArgs.prototype.userInput;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.Media.SpeechRecognition.SpeechRecognitionResult} */
Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs.prototype.result;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.VoiceCommandActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs.prototype.actionId;
 /** @type {Windows.ApplicationModel.Wallet.WalletActionKind} */
Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs.prototype.actionKind;
 /** @type {string} */
Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs.prototype.itemId;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.WalletActionActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs.prototype.kind;
 /** @type {!Windows.Security.Authentication.Web.Provider.IWebAccountProviderOperation} */
Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs.prototype.operation;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.WebAccountProviderActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs = function() {};
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs.prototype.continuationData;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs.prototype.splashScreen;
 /** @type {!Windows.Security.Authentication.Web.WebAuthenticationResult} */
Windows.ApplicationModel.Activation.WebAuthenticationBrokerContinuationEventArgs.prototype.webAuthenticationResult;
/**
 * @record
 * @struct
 */
Windows.ApplicationModel.Activation.IActivatedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.ApplicationModel.Activation.IActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.ApplicationModel.Activation.IActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.ApplicationModel.Activation.IActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.AppDisplayInfo = function() {};
 /** @type {string} */
Windows.ApplicationModel.AppDisplayInfo.prototype.description;
 /** @type {string} */
Windows.ApplicationModel.AppDisplayInfo.prototype.displayName;

/**
 * Get the application's logo.
 * @param {!Windows.Foundation.Size} size The size of the rectangle in which the logo must fit.
 * @return {!Windows.Storage.Streams.RandomAccessStreamReference} The largest logo in your Package.appxmanifest file that will fit in the specified Size.
 */
Windows.ApplicationModel.AppDisplayInfo.prototype.getLogo = function(size) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.AppInfo = function() {};
 /** @type {string} */
Windows.ApplicationModel.AppInfo.prototype.appUserModelId;
 /** @type {!Windows.ApplicationModel.AppDisplayInfo} */
Windows.ApplicationModel.AppInfo.prototype.displayInfo;
 /** @type {string} */
Windows.ApplicationModel.AppInfo.prototype.id;
 /** @type {string} */
Windows.ApplicationModel.AppInfo.prototype.packageFamilyName;
/** @const */
Windows.ApplicationModel.AppService = {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.AppService.AppServiceCatalog = function() {};
 /** @type {?} */
Windows.ApplicationModel.AppService.AppServiceCatalog.findAppServiceProvidersAsync;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.AppService.AppServiceClosedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.AppService.AppServiceClosedStatus} */
Windows.ApplicationModel.AppService.AppServiceClosedEventArgs.prototype.status;

/** @const */
Windows.ApplicationModel.AppService.AppServiceClosedStatus = {};
/** @const {number} */
Windows.ApplicationModel.AppService.AppServiceClosedStatus.completed;
/** @const {number} */
Windows.ApplicationModel.AppService.AppServiceClosedStatus.canceled;
/** @const {number} */
Windows.ApplicationModel.AppService.AppServiceClosedStatus.resourceLimitsExceeded;
/** @const {number} */
Windows.ApplicationModel.AppService.AppServiceClosedStatus.unknown;

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the AppServiceConnection class.
 */
Windows.ApplicationModel.AppService.AppServiceConnection = function() {};
 /** @type {string} */
Windows.ApplicationModel.AppService.AppServiceConnection.prototype.appServiceName;
 /** @type {function(?): void} */
Windows.ApplicationModel.AppService.AppServiceConnection.prototype.onrequestreceived;
 /** @type {function(?): void} */
Windows.ApplicationModel.AppService.AppServiceConnection.prototype.onserviceclosed;
 /** @type {string} */
Windows.ApplicationModel.AppService.AppServiceConnection.prototype.packageFamilyName;

/**
 * Closes the connection to the app service.
 * @return {void}
 */
Windows.ApplicationModel.AppService.AppServiceConnection.prototype.close = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.AppService.AppServiceConnection.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.AppService.AppServiceConnection.prototype.removeEventListener = function(type, listener) {};

/**
 * Opens a connection to the endpoint for the app service.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.ApplicationModel.AppService.AppServiceConnectionStatus, !Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.AppService.AppServiceConnectionStatus>>} An asynchronous operation to open a connection to the endpoint for the app service.
 */
Windows.ApplicationModel.AppService.AppServiceConnection.prototype.openAsync = function() {};

/**
 * Sends a message to the other endpoint of the app service connection.
 * @param {!Windows.Foundation.Collections.ValueSet} message The message that you want to send.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.AppService.AppServiceResponse, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.AppService.AppServiceResponse>>} An asynchronous operation to send the message that optionally returns a response message when complete.
 */
Windows.ApplicationModel.AppService.AppServiceConnection.prototype.sendMessageAsync = function(message) {};

/** @const */
Windows.ApplicationModel.AppService.AppServiceConnectionStatus = {};
/** @const {number} */
Windows.ApplicationModel.AppService.AppServiceConnectionStatus.success;
/** @const {number} */
Windows.ApplicationModel.AppService.AppServiceConnectionStatus.appNotInstalled;
/** @const {number} */
Windows.ApplicationModel.AppService.AppServiceConnectionStatus.appUnavailable;
/** @const {number} */
Windows.ApplicationModel.AppService.AppServiceConnectionStatus.appServiceUnavailable;
/** @const {number} */
Windows.ApplicationModel.AppService.AppServiceConnectionStatus.unknown;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.AppService.AppServiceDeferral = function() {};

/**
 * Indicates that the content for an asynchronous handler for the AppServiceConnection.RequestReceived event is ready, or that an error occurred.
 * @return {void}
 */
Windows.ApplicationModel.AppService.AppServiceDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.AppService.AppServiceRequest = function() {};
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.ApplicationModel.AppService.AppServiceRequest.prototype.message;

/**
 * Sends a response to a received request.
 * @param {!Windows.Foundation.Collections.ValueSet} message The message that you want to include in the response.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.ApplicationModel.AppService.AppServiceResponseStatus, !Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.AppService.AppServiceResponseStatus>>} An asynchronous operation to send the response.
 */
Windows.ApplicationModel.AppService.AppServiceRequest.prototype.sendResponseAsync = function(message) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.AppService.AppServiceRequestReceivedEventArgs = function() {};
 /** @type {!Windows.ApplicationModel.AppService.AppServiceRequest} */
Windows.ApplicationModel.AppService.AppServiceRequestReceivedEventArgs.prototype.request;

/**
 * Informs the system that the event handler might continue to perform work after the event handler returns.
 * @return {!Windows.ApplicationModel.AppService.AppServiceDeferral} The deferral.
 */
Windows.ApplicationModel.AppService.AppServiceRequestReceivedEventArgs.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.AppService.AppServiceResponse = function() {};
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.ApplicationModel.AppService.AppServiceResponse.prototype.message;
 /** @type {Windows.ApplicationModel.AppService.AppServiceResponseStatus} */
Windows.ApplicationModel.AppService.AppServiceResponse.prototype.status;

/** @const */
Windows.ApplicationModel.AppService.AppServiceResponseStatus = {};
/** @const {number} */
Windows.ApplicationModel.AppService.AppServiceResponseStatus.success;
/** @const {number} */
Windows.ApplicationModel.AppService.AppServiceResponseStatus.failure;
/** @const {number} */
Windows.ApplicationModel.AppService.AppServiceResponseStatus.resourceLimitsExceeded;
/** @const {number} */
Windows.ApplicationModel.AppService.AppServiceResponseStatus.unknown;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.AppService.AppServiceTriggerDetails = function() {};
 /** @type {!Windows.ApplicationModel.AppService.AppServiceConnection} */
Windows.ApplicationModel.AppService.AppServiceTriggerDetails.prototype.appServiceConnection;
 /** @type {string} */
Windows.ApplicationModel.AppService.AppServiceTriggerDetails.prototype.callerPackageFamilyName;
 /** @type {string} */
Windows.ApplicationModel.AppService.AppServiceTriggerDetails.prototype.name;
/** @const */
Windows.ApplicationModel.Appointments = {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the Appointment class.
 */
Windows.ApplicationModel.Appointments.Appointment = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.Appointment.prototype.allDay;
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.Appointment.prototype.allowNewTimeProposal;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentBusyStatus} */
Windows.ApplicationModel.Appointments.Appointment.prototype.busyStatus;
 /** @type {string} */
Windows.ApplicationModel.Appointments.Appointment.prototype.calendarId;
 /** @type {number} */
Windows.ApplicationModel.Appointments.Appointment.prototype.changeNumber;
 /** @type {string} */
Windows.ApplicationModel.Appointments.Appointment.prototype.details;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentDetailsKind} */
Windows.ApplicationModel.Appointments.Appointment.prototype.detailsKind;
 /** @type {number} */
Windows.ApplicationModel.Appointments.Appointment.prototype.duration;
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.Appointment.prototype.hasInvitees;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Appointments.AppointmentInvitee>} */
Windows.ApplicationModel.Appointments.Appointment.prototype.invitees;
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.Appointment.prototype.isCanceledMeeting;
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.Appointment.prototype.isOrganizedByUser;
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.Appointment.prototype.isResponseRequested;
 /** @type {string} */
Windows.ApplicationModel.Appointments.Appointment.prototype.localId;
 /** @type {string} */
Windows.ApplicationModel.Appointments.Appointment.prototype.location;
 /** @type {string} */
Windows.ApplicationModel.Appointments.Appointment.prototype.onlineMeetingLink;
 /** @type {!Windows.ApplicationModel.Appointments.AppointmentOrganizer} */
Windows.ApplicationModel.Appointments.Appointment.prototype.organizer;
 /** @type {!Date} */
Windows.ApplicationModel.Appointments.Appointment.prototype.originalStartTime;
 /** @type {!Windows.ApplicationModel.Appointments.AppointmentRecurrence} */
Windows.ApplicationModel.Appointments.Appointment.prototype.recurrence;
 /** @type {number} */
Windows.ApplicationModel.Appointments.Appointment.prototype.reminder;
 /** @type {number} */
Windows.ApplicationModel.Appointments.Appointment.prototype.remoteChangeNumber;
 /** @type {!Date} */
Windows.ApplicationModel.Appointments.Appointment.prototype.replyTime;
 /** @type {string} */
Windows.ApplicationModel.Appointments.Appointment.prototype.roamingId;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentSensitivity} */
Windows.ApplicationModel.Appointments.Appointment.prototype.sensitivity;
 /** @type {!Date} */
Windows.ApplicationModel.Appointments.Appointment.prototype.startTime;
 /** @type {string} */
Windows.ApplicationModel.Appointments.Appointment.prototype.subject;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.Appointments.Appointment.prototype.uri;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentParticipantResponse} */
Windows.ApplicationModel.Appointments.Appointment.prototype.userResponse;

/** @const */
Windows.ApplicationModel.Appointments.AppointmentBusyStatus = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentBusyStatus.busy;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentBusyStatus.tentative;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentBusyStatus.free;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentBusyStatus.outOfOffice;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentBusyStatus.workingElsewhere;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.canCancelMeetings;
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.canCreateOrUpdateAppointments;
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.canForwardMeetings;
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.canNotifyInvitees;
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.canProposeNewTimeForMeetings;
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.canUpdateMeetingResponses;
 /** @type {!Windows.UI.Color} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.displayColor;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.displayName;
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.isHidden;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.localId;
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.mustNofityInvitees;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentCalendarOtherAppReadAccess} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.otherAppReadAccess;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentCalendarOtherAppWriteAccess} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.otherAppWriteAccess;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.remoteId;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.sourceDisplayName;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentSummaryCardView} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.summaryCardView;
 /** @type {!Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.syncManager;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.userDataAccountId;

/**
 * Asynchronously deletes the appointment with the specified ID.
 * @param {string} localId The LocalId of the appointment to be deleted.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.deleteAppointmentAsync = function(localId) {};

/**
 * Asynchronously deletes the appointment instance with the specified start time of a master appointment with the specified ID.
 * @param {string} localId The LocalId of the master appointment associated with the appointment instance to be deleted.
 * @param {!Date} instanceStartTime The start time of the appointment instance to be deleted.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.deleteAppointmentInstanceAsync = function(localId, instanceStartTime) {};

/**
 * Asynchronously deletes the appointment calendar.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchrounous action.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.deleteAsync = function() {};

/**
 * Asynchronously retrieves a list of appointment instances of the specified master appointment that meet the specified criteria.
 * Asynchronously retrieves a list of appointment instances of the specified master appointment that meet the specified criteria.
 * @param {string} masterLocalId The LocalId of the master appointment for which appointment instances are retrieved.
 * @param {!Date} rangeStart The start time of the time window for which appointment instances are retrieved.
 * @param {number} rangeLength The length of the time window for which appointment instances are retrieved.
 * @param {!Windows.ApplicationModel.Appointments.FindAppointmentsOptions=} pOptions A FindAppointmentsOptions object that is used to specify more options for this operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that returns IVectorView on successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.findAllInstancesAsync = function(masterLocalId, rangeStart, rangeLength, pOptions) {};

/**
 * Asynchronously retrieves a list of appointments belonging to the current AppointmentCalendar that meet the specified criteria.
 * Asynchronously retrieves a list of appointments belonging to the current AppointmentCalendar that meet the specified criteria.
 * @param {!Date} rangeStart The start time of the time window for which appointments are retrieved.
 * @param {number} rangeLength The length of the time window for which appointments are retrieved.
 * @param {!Windows.ApplicationModel.Appointments.FindAppointmentsOptions=} options A FindAppointmentsOptions object that is used to specify more options for this operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that returns IVectorView on successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.findAppointmentsAsync = function(rangeStart, rangeLength, options) {};

/**
 * Asynchronously retrieves a list of appointment instances that are exceptions from the specified master appointment.
 * @param {string} masterLocalId The LocalId of the master appointment for which exceptional appointment instances are retrieved.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that returns IVectorView on successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.findExceptionsFromMasterAsync = function(masterLocalId) {};

/**
 * Asynchronously retrieves a list of appointments that meet the specified criteria.
 * Asynchronously retrieves a list of appointments that meet the specified criteria.
 * @param {!Windows.ApplicationModel.Appointments.FindAppointmentsOptions=} options A FindAppointmentsOptions object that is used to specify more options for this operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that returns IVectorView on successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.findUnexpandedAppointmentsAsync = function(options) {};

/**
 * Asynchronously retrieves the Appointment with the specified ID.
 * (Applies to Windows Phone only) Asynchronously retrieves the Appointment with the specified ID and includes data for the specified properties.
 * @param {string} localId The LocalId of the appointment to be retrieved.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} prefetchProperties A list of names of the properties for which data should be included when the appointment is retrieved.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Appointments.Appointment, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Appointments.Appointment>>} An asynchronous operation that returns Appointment on successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.getAppointmentAsync = function(localId, prefetchProperties) {};

/**
 * Asynchronously retrieves the appointment instance of the specified master appointment that has the specified start time.
 * @param {string} localId The ID of the master appointment to which the retrieved appointment instance belongs.
 * @param {!Date} instanceStartTime The start time of the appointment instance to be retrieved.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Appointments.Appointment, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Appointments.Appointment>>} An asynchronous operation that returns Appointment on successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.getAppointmentInstanceAsync = function(localId, instanceStartTime) {};

/**
 * Asynchronously saves the provided appointment to the calendar.
 * @param {!Windows.ApplicationModel.Appointments.Appointment} pAppointment The appointment to be saved.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.saveAppointmentAsync = function(pAppointment) {};

/**
 * Asynchronously saves changes to the appointment calendar.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.saveAsync = function() {};

/**
 * Asynchronously attempts to cancel a meeting.
 * @param {!Windows.ApplicationModel.Appointments.Appointment} meeting The meeting to cancel.
 * @param {string} subject The subject for the cancellation notification.
 * @param {string} comment The body of the cancellation notification.
 * @param {boolean} notifyInvitees A Boolean value indicating if invitees should be notified.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the operation was successful.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.tryCancelMeetingAsync = function(meeting, subject, comment, notifyInvitees) {};

/**
 * Asynchronously attempts to create or update a meeting.
 * @param {!Windows.ApplicationModel.Appointments.Appointment} appointment The meeting to create or update.
 * @param {boolean} notifyInvitees A Boolean value indicating if invitees should be notified.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the operation was successful.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.tryCreateOrUpdateAppointmentAsync = function(appointment, notifyInvitees) {};

/**
 * Asynchronously attempts to forward a meeting.
 * @param {!Windows.ApplicationModel.Appointments.Appointment} meeting The meeting to forward.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.ApplicationModel.Appointments.AppointmentInvitee>} invitees A list of new invitees to receive the forwarded meeting.
 * @param {string} subject The subject of the meeting invitation.
 * @param {string} forwardHeader A new meeting header that includes the new invitees.
 * @param {string} comment The body of the forwarded meeting invitation.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the operation was successful.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.tryForwardMeetingAsync = function(meeting, invitees, subject, forwardHeader, comment) {};

/**
 * Asynchronously attempts to propose a new meeting time.
 * @param {!Windows.ApplicationModel.Appointments.Appointment} meeting The meeting to update.
 * @param {!Date} newStartTime The proposed new start time.
 * @param {number} newDuration A new duration for the meeting.
 * @param {string} subject The subject of the meeting invitation.
 * @param {string} comment The body of the meeting invitation.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the operation was successful.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.tryProposeNewTimeForMeetingAsync = function(meeting, newStartTime, newDuration, subject, comment) {};

/**
 * Asynchronously attempts to update the response to a meeting invitation.
 * @param {!Windows.ApplicationModel.Appointments.Appointment} meeting The meeting to update.
 * @param {Windows.ApplicationModel.Appointments.AppointmentParticipantResponse} response The response to the meeting invitation, such as accept, tentative or decline.
 * @param {string} subject The subject of the response.
 * @param {string} comment The body of the response.
 * @param {boolean} sendUpdate A Boolean value indicating whether or not to send the response to the meeting organizer.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the operation was successful.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendar.prototype.tryUpdateMeetingResponseAsync = function(meeting, response, subject, comment, sendUpdate) {};

/** @const */
Windows.ApplicationModel.Appointments.AppointmentCalendarOtherAppReadAccess = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentCalendarOtherAppReadAccess.systemOnly;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentCalendarOtherAppReadAccess.limited;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentCalendarOtherAppReadAccess.full;

/** @const */
Windows.ApplicationModel.Appointments.AppointmentCalendarOtherAppWriteAccess = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentCalendarOtherAppWriteAccess.none;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentCalendarOtherAppWriteAccess.systemOnly;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager = function() {};
 /** @type {!Date} */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager.prototype.lastAttemptedSyncTime;
 /** @type {!Date} */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager.prototype.lastSuccessfulSyncTime;
 /** @type {function(?): void} */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager.prototype.onsyncstatuschanged;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentCalendarSyncStatus} */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager.prototype.removeEventListener = function(type, listener) {};

/**
 * Initiates a sync operation on the AppointmentCalendar .
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the sync was successfully initiated.
 */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager.prototype.syncAsync = function() {};

/** @const */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncStatus = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncStatus.idle;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncStatus.syncing;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncStatus.upToDate;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncStatus.authenticationError;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncStatus.policyError;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncStatus.unknownError;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentCalendarSyncStatus.manualAccountRemovalRequired;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentConflictResult = function() {};
 /** @type {!Date} */
Windows.ApplicationModel.Appointments.AppointmentConflictResult.prototype.date;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentConflictType} */
Windows.ApplicationModel.Appointments.AppointmentConflictResult.prototype.type;

/** @const */
Windows.ApplicationModel.Appointments.AppointmentConflictType = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentConflictType.none;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentConflictType.adjacent;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentConflictType.overlap;

/** @const */
Windows.ApplicationModel.Appointments.AppointmentDaysOfWeek = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentDaysOfWeek.none;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentDaysOfWeek.sunday;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentDaysOfWeek.monday;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentDaysOfWeek.tuesday;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentDaysOfWeek.wednesday;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentDaysOfWeek.thursday;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentDaysOfWeek.friday;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentDaysOfWeek.saturday;

/** @const */
Windows.ApplicationModel.Appointments.AppointmentDetailsKind = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentDetailsKind.plainText;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentDetailsKind.html;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentException = function() {};
 /** @type {!Windows.ApplicationModel.Appointments.Appointment} */
Windows.ApplicationModel.Appointments.AppointmentException.prototype.appointment;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.ApplicationModel.Appointments.AppointmentException.prototype.exceptionProperties;
 /** @type {boolean} */
Windows.ApplicationModel.Appointments.AppointmentException.prototype.isDeleted;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the AppointmentInvitee class.
 */
Windows.ApplicationModel.Appointments.AppointmentInvitee = function() {};
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentInvitee.prototype.address;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentInvitee.prototype.displayName;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentParticipantResponse} */
Windows.ApplicationModel.Appointments.AppointmentInvitee.prototype.response;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentParticipantRole} */
Windows.ApplicationModel.Appointments.AppointmentInvitee.prototype.role;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentManager = function() {};

/**
 * Requests the AppointmentStore object associated with the calling application.
 * @param {Windows.ApplicationModel.Appointments.AppointmentStoreAccessType} options An AppointmentStoreAccessType value indicating the level of access the returned appointment store will have.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Appointments.AppointmentStore, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Appointments.AppointmentStore>>} An asynchronous operation that returns an AppointmentStore upon successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentManager.requestStoreAsync = function(options) {};

/**
 * Shows the Appointments provider Add Appointment UI, to enable the user to add an appointment.
 * Shows the Appointments provider Add Appointment UI, to enable the user to add an appointment.
 * @param {!Windows.ApplicationModel.Appointments.Appointment} appointment The object representing the information for the appointment to add.
 * @param {!Windows.Foundation.Rect} selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Add Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Add Appointment UI displays around the button, not overlapping it.
 * @param {Windows.UI.Popups.Placement=} preferredPlacement The Placement that describes the preferred placement of the Add Appointment UI.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} When this method completes, it returns a String object that represents the appointment. This serves as an appointment identifier for future reference when updating or removing. If the appointment identifier returned is an empty string, the appointment was not added to the Appointments provider app.
 */
Windows.ApplicationModel.Appointments.AppointmentManager.showAddAppointmentAsync = function(appointment, selection, preferredPlacement) {};

/**
 * Shows the Appointments provider Appointment Details UI, to enable the user to view the specified appointment.
 * Shows the Appointments provider Appointment Details UI, to enable the user to view the specified appointment.
 * @param {string} appointmentId The LocalId of the appointment to be displayed.
 * @param {!Date=} instanceStartDate A DateTime object with the start time of the appointment instance to be displayed.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Appointments.AppointmentManager.showAppointmentDetailsAsync = function(appointmentId, instanceStartDate) {};

/**
 * Shows the Appointments provider Add Appointment UI including the full edit experience, to enable the user to add an appointment.
 * @param {!Windows.ApplicationModel.Appointments.Appointment} appointment The appointment to be added.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} An asynchronous operation that returns a string containing an appointment ID upon successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentManager.showEditNewAppointmentAsync = function(appointment) {};

/**
 * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
 * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
 * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
 * @param {string} appointmentId The appointment identifier. This is typically obtained from the async return value of a previous ShowAddAppointmentAsync call.
 * @param {!Windows.Foundation.Rect} selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Remove Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Remove Appointment UI displays around the button, not overlapping it.
 * @param {Windows.UI.Popups.Placement=} preferredPlacement The Placement that describes the preferred placement of the Remove Appointment UI.
 * @param {!Date=} instanceStartDate The start date and time of the appointment instance to remove.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} When this method completes, it returns a Boolean value that indicates whether the Appointment provider app removed the appointment.
 */
Windows.ApplicationModel.Appointments.AppointmentManager.showRemoveAppointmentAsync = function(appointmentId, selection, preferredPlacement, instanceStartDate) {};

/**
 * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
 * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
 * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
 * @param {string} appointmentId The appointment identifier of the current appointment. This is typically obtained from the async return value of a previous ShowAddAppointmentAsync or ShowReplaceAppointmentAsync call.
 * @param {!Windows.ApplicationModel.Appointments.Appointment} appointment The object representing the information for the appointment to replace the current appointment.
 * @param {!Windows.Foundation.Rect} selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Replace Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Replace Appointment UI displays around the button, not overlapping it.
 * @param {Windows.UI.Popups.Placement=} preferredPlacement The Placement that describes the preferred placement of the Replace Appointment UI.
 * @param {!Date=} instanceStartDate The start date and time of the appointment instance to replace.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} When this method completes, it returns a String object that represents the appointment. This serves as an appointment identifier for future reference when updating or removing. If the appointment identifier returned is an empty string, the appointment was not replaced in the Appointments provider app.
 */
Windows.ApplicationModel.Appointments.AppointmentManager.showReplaceAppointmentAsync = function(appointmentId, appointment, selection, preferredPlacement, instanceStartDate) {};

/**
 * Shows the Appointments provider app's primary UI. This typically displays a time frame from an appointments calendar.
 * @param {!Date} timeToShow A date and time object that specifies the beginning of the time frame that the Appointments provider app should display.
 * @param {number} duration A timespan that hints to the Appointments provider app how long the time frame shown should be.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} When this method returns, it does not return a result. On completion, the AsyncActionCompletedHandler specified by get_Completed / Completed is invoked.
 */
Windows.ApplicationModel.Appointments.AppointmentManager.showTimeFrameAsync = function(timeToShow, duration) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the AppointmentOrganizer class.
 */
Windows.ApplicationModel.Appointments.AppointmentOrganizer = function() {};
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentOrganizer.prototype.address;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentOrganizer.prototype.displayName;

/** @const */
Windows.ApplicationModel.Appointments.AppointmentParticipantResponse = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentParticipantResponse.none;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentParticipantResponse.tentative;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentParticipantResponse.accepted;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentParticipantResponse.declined;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentParticipantResponse.unknown;

/** @const */
Windows.ApplicationModel.Appointments.AppointmentParticipantRole = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentParticipantRole.requiredAttendee;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentParticipantRole.optionalAttendee;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentParticipantRole.resource;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentProperties = function() {};
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.allDay;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.allowNewTimeProposal;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.busyStatus;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.changeNumber;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.Appointments.AppointmentProperties.defaultProperties;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.details;
 /** @type {?} */
Windows.ApplicationModel.Appointments.AppointmentProperties.detailsKind;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.duration;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.hasInvitees;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.invitees;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.isCanceledMeeting;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.isOrganizedByUser;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.isResponseRequested;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.location;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.onlineMeetingLink;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.organizer;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.originalStartTime;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.recurrence;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.reminder;
 /** @type {?} */
Windows.ApplicationModel.Appointments.AppointmentProperties.remoteChangeNumber;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.replyTime;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.sensitivity;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.startTime;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.subject;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.uri;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentProperties.userResponse;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the AppointmentRecurrence class.
 */
Windows.ApplicationModel.Appointments.AppointmentRecurrence = function() {};
 /** @type {?} */
Windows.ApplicationModel.Appointments.AppointmentRecurrence.prototype.calendarIdentifier;
 /** @type {number} */
Windows.ApplicationModel.Appointments.AppointmentRecurrence.prototype.day;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentDaysOfWeek} */
Windows.ApplicationModel.Appointments.AppointmentRecurrence.prototype.daysOfWeek;
 /** @type {number} */
Windows.ApplicationModel.Appointments.AppointmentRecurrence.prototype.interval;
 /** @type {number} */
Windows.ApplicationModel.Appointments.AppointmentRecurrence.prototype.month;
 /** @type {number} */
Windows.ApplicationModel.Appointments.AppointmentRecurrence.prototype.occurrences;
 /** @type {Windows.ApplicationModel.Appointments.RecurrenceType} */
Windows.ApplicationModel.Appointments.AppointmentRecurrence.prototype.recurrenceType;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentRecurrence.prototype.timeZone;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentRecurrenceUnit} */
Windows.ApplicationModel.Appointments.AppointmentRecurrence.prototype.unit;
 /** @type {!Date} */
Windows.ApplicationModel.Appointments.AppointmentRecurrence.prototype.until;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentWeekOfMonth} */
Windows.ApplicationModel.Appointments.AppointmentRecurrence.prototype.weekOfMonth;

/** @const */
Windows.ApplicationModel.Appointments.AppointmentRecurrenceUnit = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentRecurrenceUnit.daily;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentRecurrenceUnit.weekly;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentRecurrenceUnit.monthly;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentRecurrenceUnit.monthlyOnDay;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentRecurrenceUnit.yearly;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentRecurrenceUnit.yearlyOnDay;

/** @const */
Windows.ApplicationModel.Appointments.AppointmentSensitivity = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentSensitivity.public;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentSensitivity.private;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentStore = function() {};
 /** @type {!Windows.ApplicationModel.Appointments.AppointmentStoreChangeTracker} */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.changeTracker;
 /** @type {function(?): void} */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.onstorechanged;

/**
 * Asynchronously creates a new AppointmentCalendar within the appointment store using the specified parameters.
 * Asynchronously creates a new AppointmentCalendar within the appointment store with the specified name and user data account ID.
 * @param {string} name The name for the new AppointmentCalendar .
 * @param {string=} userDataAccountId The identifier for the user data account used to create the AppointmentCalendar .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Appointments.AppointmentCalendar, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Appointments.AppointmentCalendar>>} An async operation that provides access to the newly created AppointmentCalendar .
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.createAppointmentCalendarAsync = function(name, userDataAccountId) {};

/**
 * Retrieves a list of appointment calendars in the appointment store that meet the criteria specified by the supplied FindAppointmentCalendarsOptions object..
 * Retrieves a list of all of the appointment calendars in the appointment store.
 * @param {Windows.ApplicationModel.Appointments.FindAppointmentCalendarsOptions=} options The object that specifies the criteria that determines which appointment calendars are returned.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that returns an IVectorView upon successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.findAppointmentCalendarsAsync = function(options) {};

/**
 * Retrieves a list of appointments in the appointment calendar that fall within the specified date range.
 * Retrieves a list of appointments in the appointment calendar that fall within the specified date range and meet the criteria specified by the supplied FindAppointmentsOptions object..
 * @param {!Date} rangeStart The start of the date range for which appointments are retrieved.
 * @param {number} rangeLength The length of the date range for which appointments are retrieved.
 * @param {!Windows.ApplicationModel.Appointments.FindAppointmentsOptions=} options The object that specifies the criteria that determines which appointments are returned.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that returns an IVectorView upon successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.findAppointmentsAsync = function(rangeStart, rangeLength, options) {};

/**
 * Returns an AppointmentConflictResult representing a conflict between the specified appointment and an existing appointment instance in the appointment store.
 * Returns an AppointmentConflictResult representing a conflict between the specified appointment and an existing appointment in the appointment store.
 * @param {!Windows.ApplicationModel.Appointments.Appointment} appointment The appointment for which a conflict is sought.
 * @param {!Date=} instanceStartTime The start time of the appointment instance for which a conflict is sought.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Appointments.AppointmentConflictResult, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Appointments.AppointmentConflictResult>>} An asynchronous operation that returns an AppointmentConflictResult upon successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.findConflictAsync = function(appointment, instanceStartTime) {};

/**
 * Returns a list of LocalId values for appointment instances with the specified RoamingId value.
 * @param {string} roamingId The RoamingId value for which local ID values are sought.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that returns an IVectorView upon successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.findLocalIdsFromRoamingIdAsync = function(roamingId) {};

/**
 * Retrieves the Appointment with the specified LocalId .
 * @param {string} localId The LocalId of the appointment to be retrieved.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Appointments.Appointment, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Appointments.Appointment>>} An asynchronous operation that returns an Appointment upon successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.getAppointmentAsync = function(localId) {};

/**
 * Retrieves the AppointmentCalendar with the specified LocalId or RemoteId .
 * @param {string} calendarId The LocalId or RemoteId of the AppointmentCalendar to be retrieved.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Appointments.AppointmentCalendar, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Appointments.AppointmentCalendar>>} An asynchronous operation that returns an AppointmentCalendar upon successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.getAppointmentCalendarAsync = function(calendarId) {};

/**
 * Retrieves the instance of the Appointment with the specified LocalId and the specified start time.
 * @param {string} localId The LocalId of the appointment instance to be retrieved.
 * @param {!Date} instanceStartTime The start time of the appointment instance to be retrieved.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Appointments.Appointment, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Appointments.Appointment>>} An asynchronous operation that returns an Appointment upon successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.getAppointmentInstanceAsync = function(localId, instanceStartTime) {};

/**
 * Moves the specified Appointment object to the specified AppointmentCalendar .
 * @param {!Windows.ApplicationModel.Appointments.Appointment} appointment The appointment to be moved.
 * @param {!Windows.ApplicationModel.Appointments.AppointmentCalendar} destinationCalendar The appointment calendar to which the appointment is moved.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.moveAppointmentAsync = function(appointment, destinationCalendar) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.removeEventListener = function(type, listener) {};

/**
 * Shows the Appointments provider Add Appointment UI, to enable the user to add an appointment.
 * @param {!Windows.ApplicationModel.Appointments.Appointment} appointment The object representing the information for the appointment to add.
 * @param {!Windows.Foundation.Rect} selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Add Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Add Appointment UI displays around the button, not overlapping it.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} When this method completes, it returns a String object that represents the RoamingId of the appointment. If the appointment identifier returned is an empty string, the appointment was not added to the Appointments provider app.
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.showAddAppointmentAsync = function(appointment, selection) {};

/**
 * Shows the Appointments provider Appointment Details UI, to enable the user to view the specified appointment.
 * Shows the Appointments provider Appointment Details UI, to enable the user to view the specified appointment.
 * @param {string} localId The LocalId of the appointment to be displayed.
 * @param {!Date=} instanceStartDate A DateTime object with the start time of the appointment instance to be displayed.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.showAppointmentDetailsAsync = function(localId, instanceStartDate) {};

/**
 * Shows the Appointments provider Add Appointment UI including the full edit experience, to enable the user to add an appointment.
 * @param {!Windows.ApplicationModel.Appointments.Appointment} appointment The appointment to be added.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} When this method completes, it returns a String object that represents the RoamingId of the appointment. If the appointment identifier returned is an empty string, the appointment was not added to the Appointments provider app.
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.showEditNewAppointmentAsync = function(appointment) {};

/**
 * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
 * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
 * @param {string} localId The LocalId of the appointment to be removed.
 * @param {!Windows.Foundation.Rect} selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Remove Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Remove Appointment UI displays around the button, not overlapping it.
 * @param {Windows.UI.Popups.Placement=} preferredPlacement The Placement that describes the preferred placement of the Remove Appointment UI.
 * @param {!Date=} instanceStartDate The start date and time of the appointment instance to remove.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} When this method completes, it returns a Boolean value that indicates whether the Appointment provider app removed the appointment.
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.showRemoveAppointmentAsync = function(localId, selection, preferredPlacement, instanceStartDate) {};

/**
 * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
 * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
 * @param {string} localId The LocalId of the appointment to be replaced.
 * @param {!Windows.ApplicationModel.Appointments.Appointment} appointment The object representing the appointment to replace the existing appointment.
 * @param {!Windows.Foundation.Rect} selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Replace Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Replace Appointment UI displays around the button, not overlapping it.
 * @param {Windows.UI.Popups.Placement=} preferredPlacement The Placement that describes the preferred placement of the Replace Appointment UI.
 * @param {!Date=} instanceStartDate The start date and time of the appointment instance to replace.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} When this method completes, it returns a String object that represents the RoamingId of the appointment that replaced the existing appointment.
 */
Windows.ApplicationModel.Appointments.AppointmentStore.prototype.showReplaceAppointmentAsync = function(localId, appointment, selection, preferredPlacement, instanceStartDate) {};

/** @const */
Windows.ApplicationModel.Appointments.AppointmentStoreAccessType = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentStoreAccessType.appCalendarsReadWrite;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentStoreAccessType.allCalendarsReadOnly;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentStoreAccessType.allCalendarsReadWrite;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentStoreChange = function() {};
 /** @type {!Windows.ApplicationModel.Appointments.Appointment} */
Windows.ApplicationModel.Appointments.AppointmentStoreChange.prototype.appointment;
 /** @type {!Windows.ApplicationModel.Appointments.AppointmentCalendar} */
Windows.ApplicationModel.Appointments.AppointmentStoreChange.prototype.appointmentCalendar;
 /** @type {Windows.ApplicationModel.Appointments.AppointmentStoreChangeType} */
Windows.ApplicationModel.Appointments.AppointmentStoreChange.prototype.changeType;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeReader = function() {};

/**
 * Tells the system that all of the changes to appointments returned by the call to ReadBatchAsync have been addressed by the app.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeReader.prototype.acceptChanges = function() {};

/**
 * Tells the system that all of the changes to appointments returned by the call to ReadBatchAsync , up to the specified AppointmentStoreChange , have been addressed by the app.
 * @param {!Windows.ApplicationModel.Appointments.AppointmentStoreChange} lastChangeToAccept The AppointmentStoreChange object indicating the latest change that has been addressed by the app.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeReader.prototype.acceptChangesThrough = function(lastChangeToAccept) {};

/**
 * Returns a list of the changes that have occurred in the appointment store that have not yet been accepted by the calling app.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that returns an IVectorView upon successful completion.
 */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeReader.prototype.readBatchAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeTracker = function() {};
 /** @type {?} */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeTracker.prototype.enable;
 /** @type {?} */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeTracker.prototype.getChangeReader;
 /** @type {?} */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeTracker.prototype.reset;

/** @const */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeType = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeType.appointmentCreated;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeType.appointmentModified;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeType.appointmentDeleted;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeType.changeTrackingLost;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeType.calendarCreated;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeType.calendarModified;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentStoreChangeType.calendarDeleted;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentStoreChangedDeferral = function() {};

/**
 * Informs the system that an asynchronous operation associated with an AppointmentStore has finished.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentStoreChangedDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentStoreChangedEventArgs = function() {};

/**
 * Gets the deferral object for the StoreChanged event.
 * @return {!Windows.ApplicationModel.Appointments.AppointmentStoreChangedDeferral} The deferral object for the StoreChanged event.
 */
Windows.ApplicationModel.Appointments.AppointmentStoreChangedEventArgs.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentStoreNotificationTriggerDetails = function() {};

/** @const */
Windows.ApplicationModel.Appointments.AppointmentSummaryCardView = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentSummaryCardView.system;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentSummaryCardView.app;

/** @const */
Windows.ApplicationModel.Appointments.AppointmentWeekOfMonth = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentWeekOfMonth.first;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentWeekOfMonth.second;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentWeekOfMonth.third;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentWeekOfMonth.fourth;
/** @const {number} */
Windows.ApplicationModel.Appointments.AppointmentWeekOfMonth.last;
/** @const */
Windows.ApplicationModel.Appointments.AppointmentsProvider = {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.AddAppointmentOperation = function() {};
 /** @type {!Windows.ApplicationModel.Appointments.Appointment} */
Windows.ApplicationModel.Appointments.AppointmentsProvider.AddAppointmentOperation.prototype.appointmentInformation;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentsProvider.AddAppointmentOperation.prototype.sourcePackageFamilyName;

/**
 * Dismisses the UI for the operation that adds a new appointment.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.AddAppointmentOperation.prototype.dismissUI = function() {};

/**
 * Call this method to inform the activating app that the operation was canceled by the user.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.AddAppointmentOperation.prototype.reportCanceled = function() {};

/**
 * Call this method to inform the activating app that the operation was completed successfully. Provide a unique appointment ID as the itemID parameter.
 * @param {string} itemId A unique appointment ID that the activating app can later use to remove this appointment if necessary.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.AddAppointmentOperation.prototype.reportCompleted = function(itemId) {};

/**
 * Informs the activating app that the operation couldn't be completed because of a provider error.
 * @param {string} value A string that contains info about the error.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.AddAppointmentOperation.prototype.reportError = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.AppointmentsProviderLaunchActionVerbs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentsProvider.AppointmentsProviderLaunchActionVerbs.addAppointment;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentsProvider.AppointmentsProviderLaunchActionVerbs.removeAppointment;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentsProvider.AppointmentsProviderLaunchActionVerbs.replaceAppointment;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentsProvider.AppointmentsProviderLaunchActionVerbs.showAppointmentDetails;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentsProvider.AppointmentsProviderLaunchActionVerbs.showTimeFrame;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.RemoveAppointmentOperation = function() {};
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentsProvider.RemoveAppointmentOperation.prototype.appointmentId;
 /** @type {!Date} */
Windows.ApplicationModel.Appointments.AppointmentsProvider.RemoveAppointmentOperation.prototype.instanceStartDate;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentsProvider.RemoveAppointmentOperation.prototype.sourcePackageFamilyName;

/**
 * Dismisses the UI for the operation that removes an appointment.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.RemoveAppointmentOperation.prototype.dismissUI = function() {};

/**
 * Call this method to inform the activating app that the operation was canceled by the user.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.RemoveAppointmentOperation.prototype.reportCanceled = function() {};

/**
 * Informs the activating app that the operation was completed successfully.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.RemoveAppointmentOperation.prototype.reportCompleted = function() {};

/**
 * Informs the activating app that the operation couldn't be completed because of a provider error.
 * @param {string} value A string that contains info about the error.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.RemoveAppointmentOperation.prototype.reportError = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.ReplaceAppointmentOperation = function() {};
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentsProvider.ReplaceAppointmentOperation.prototype.appointmentId;
 /** @type {!Windows.ApplicationModel.Appointments.Appointment} */
Windows.ApplicationModel.Appointments.AppointmentsProvider.ReplaceAppointmentOperation.prototype.appointmentInformation;
 /** @type {!Date} */
Windows.ApplicationModel.Appointments.AppointmentsProvider.ReplaceAppointmentOperation.prototype.instanceStartDate;
 /** @type {string} */
Windows.ApplicationModel.Appointments.AppointmentsProvider.ReplaceAppointmentOperation.prototype.sourcePackageFamilyName;

/**
 * Dismisses the UI for the operation that replaces an appointment.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.ReplaceAppointmentOperation.prototype.dismissUI = function() {};

/**
 * Informs the activating app that the operation was canceled by the user.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.ReplaceAppointmentOperation.prototype.reportCanceled = function() {};

/**
 * Informs the activating app that the operation was completed successfully.
 * @param {string} itemId A unique appointment ID that the activating app can later use to remove this appointment if necessary or to replace it again.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.ReplaceAppointmentOperation.prototype.reportCompleted = function(itemId) {};

/**
 * Informs the activating app that the operation couldn't be completed because of a provider error.
 * @param {string} value A string that contains info about the error.
 * @return {void}
 */
Windows.ApplicationModel.Appointments.AppointmentsProvider.ReplaceAppointmentOperation.prototype.reportError = function(value) {};

/** @const */
Windows.ApplicationModel.Appointments.FindAppointmentCalendarsOptions = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.FindAppointmentCalendarsOptions.none;
/** @const {number} */
Windows.ApplicationModel.Appointments.FindAppointmentCalendarsOptions.includeHidden;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Appointments.FindAppointmentsOptions = function() {};
 /** @type {?} */
Windows.ApplicationModel.Appointments.FindAppointmentsOptions.prototype.calendarIds;
 /** @type {?} */
Windows.ApplicationModel.Appointments.FindAppointmentsOptions.prototype.fetchProperties;
 /** @type {?} */
Windows.ApplicationModel.Appointments.FindAppointmentsOptions.prototype.includeHidden;
 /** @type {?} */
Windows.ApplicationModel.Appointments.FindAppointmentsOptions.prototype.maxCount;

/** @const */
Windows.ApplicationModel.Appointments.RecurrenceType = {};
/** @const {number} */
Windows.ApplicationModel.Appointments.RecurrenceType.master;
/** @const {number} */
Windows.ApplicationModel.Appointments.RecurrenceType.instance;
/** @const {number} */
Windows.ApplicationModel.Appointments.RecurrenceType.exceptionInstance;
/** @const */
Windows.ApplicationModel.Background = {};

/**
 * @constructor
 * @struct
 * Creates an instance of the ActivitySensorTrigger class with an initial MinimumReportInterval .
 * @param {number} reportIntervalInMilliseconds The initial report interval to use for MinimumReportInterval .
 */
Windows.ApplicationModel.Background.ActivitySensorTrigger = function(reportIntervalInMilliseconds) {};
 /** @type {number} */
Windows.ApplicationModel.Background.ActivitySensorTrigger.prototype.minimumReportInterval;
 /** @type {number} */
Windows.ApplicationModel.Background.ActivitySensorTrigger.prototype.reportInterval;
 /** @type {!Windows.Foundation.Collections.IVector<Windows.Devices.Sensors.ActivityType>} */
Windows.ApplicationModel.Background.ActivitySensorTrigger.prototype.subscribedActivities;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Devices.Sensors.ActivityType>} */
Windows.ApplicationModel.Background.ActivitySensorTrigger.prototype.supportedActivities;

/** @const */
Windows.ApplicationModel.Background.AlarmAccessStatus = {};
/** @const {number} */
Windows.ApplicationModel.Background.AlarmAccessStatus.unspecified;
/** @const {number} */
Windows.ApplicationModel.Background.AlarmAccessStatus.allowedWithWakeupCapability;
/** @const {number} */
Windows.ApplicationModel.Background.AlarmAccessStatus.allowedWithoutWakeupCapability;
/** @const {number} */
Windows.ApplicationModel.Background.AlarmAccessStatus.denied;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Background.AlarmApplicationManager = function() {};

/**
 * Retrieves the status of user permission for the app to set alarms.
 * @return {Windows.ApplicationModel.Background.AlarmAccessStatus} Indicates whether the user has granted permission to set alarms.
 */
Windows.ApplicationModel.Background.AlarmApplicationManager.getAccessStatus = function() {};

/**
 * Requests permission from the user to set alarms.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.ApplicationModel.Background.AlarmAccessStatus, !Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Background.AlarmAccessStatus>>} This method returns an AlarmAccessStatus value when it completes.
 */
Windows.ApplicationModel.Background.AlarmApplicationManager.requestAccessAsync = function() {};

/**
 * @constructor
 * @struct
 * Creates a new ApplicationTrigger class
 */
Windows.ApplicationModel.Background.ApplicationTrigger = function() {};

/**
 * This method attempts to set the trigger and start the registered background task with specified arguments.
 * This method attempts to set the trigger and start the registered background task.
 * @param {!Windows.Foundation.Collections.ValueSet=} args
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.ApplicationModel.Background.ApplicationTriggerResult, !Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Background.ApplicationTriggerResult>>} Returns an ApplicationTriggerResult enumeration that indicates whether the user provided the necessary consent for the operation or the system policies didn't reject the request to trigger a background task.
 */
Windows.ApplicationModel.Background.ApplicationTrigger.prototype.requestAsync = function(args) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Background.ApplicationTriggerDetails = function() {};
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.ApplicationModel.Background.ApplicationTriggerDetails.prototype.arguments;

/** @const */
Windows.ApplicationModel.Background.ApplicationTriggerResult = {};
/** @const {number} */
Windows.ApplicationModel.Background.ApplicationTriggerResult.allowed;
/** @const {number} */
Windows.ApplicationModel.Background.ApplicationTriggerResult.currentlyRunning;
/** @const {number} */
Windows.ApplicationModel.Background.ApplicationTriggerResult.disabledByPolicy;
/** @const {number} */
Windows.ApplicationModel.Background.ApplicationTriggerResult.unknownError;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the AppointmentStoreNotificationTrigger class.
 */
Windows.ApplicationModel.Background.AppointmentStoreNotificationTrigger = function() {};

/** @const */
Windows.ApplicationModel.Background.BackgroundAccessStatus = {};
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundAccessStatus.unspecified;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundAccessStatus.allowedWithAlwaysOnRealTimeConnectivity;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundAccessStatus.allowedMayUseActiveRealTimeConnectivity;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundAccessStatus.denied;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Background.BackgroundExecutionManager = function() {};

/**
 * Gets the ability of the calling lock screen app to perform background activity and update its badge.
 * Gets the ability of a specific lock screen app to perform background activity and update its badge.
 * @param {string=} applicationId The Package Relative Application ID (PRAID) of the app whose capabilities are being retrieved. The specified app must be in the same package as the calling app.
 * @return {Windows.ApplicationModel.Background.BackgroundAccessStatus} One of the enumeration values that specify the app's capabilities on the lock screen.
 */
Windows.ApplicationModel.Background.BackgroundExecutionManager.getAccessStatus = function(applicationId) {};

/**
 * Removes a specific app from the lock screen's apps list.
 * Removes the calling app from the lock screen's apps list.
 * @param {string=} applicationId The Package Relative Application ID (PRAID) of the app to be removed from the lock screen. The specified app must be in the same package as the calling app.
 * @return {void}
 */
Windows.ApplicationModel.Background.BackgroundExecutionManager.removeAccess = function(applicationId) {};

/**
 * Requests access for an app to run background tasks.
 * Requests access for an app to run background tasks.
 * @param {string=} applicationId The Package Relative Application ID (PRAID) of the app to be added to the lock screen. The specified app must be in the same package as the calling app.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.ApplicationModel.Background.BackgroundAccessStatus, !Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Background.BackgroundAccessStatus>>} The object, bound to the app specified by applicationId, that is used to request that the app be added to the lock screen's apps list. When the operation completes, it returns a member of the BackgroundAccessStatus enumeration that specifies the outcome. / The object, bound to the calling app, that is used to request that the app be added to the lock screen's apps list. When the operation completes, it returns a member of the BackgroundAccessStatus enumeration that specifies the outcome.
 */
Windows.ApplicationModel.Background.BackgroundExecutionManager.requestAccessAsync = function(applicationId) {};

/**
 * @constructor
 * @struct
 * Creates an instance of the BackgroundTaskBuilder class.
 */
Windows.ApplicationModel.Background.BackgroundTaskBuilder = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Background.BackgroundTaskBuilder.prototype.cancelOnConditionLoss;
 /** @type {boolean} */
Windows.ApplicationModel.Background.BackgroundTaskBuilder.prototype.isNetworkRequested;
 /** @type {string} */
Windows.ApplicationModel.Background.BackgroundTaskBuilder.prototype.name;
 /** @type {string} */
Windows.ApplicationModel.Background.BackgroundTaskBuilder.prototype.taskEntryPoint;

/**
 * Adds a condition to a background task.
 * @param {!Windows.ApplicationModel.Background.IBackgroundCondition} condition An instance of a SystemCondition object.
 * @return {void}
 */
Windows.ApplicationModel.Background.BackgroundTaskBuilder.prototype.addCondition = function(condition) {};

/**
 * Registers a background task with the system.
 * @return {!Windows.ApplicationModel.Background.BackgroundTaskRegistration} An instance of a BackgroundTaskRegistration object.
 */
Windows.ApplicationModel.Background.BackgroundTaskBuilder.prototype.register = function() {};

/**
 * Sets the event trigger for a background task.
 * @param {!Windows.ApplicationModel.Background.IBackgroundTrigger} trigger An instance of an event trigger object such as a SystemTrigger , TimeTrigger , or NetworkOperatorNotificationTrigger .
 * @return {void}
 */
Windows.ApplicationModel.Background.BackgroundTaskBuilder.prototype.setTrigger = function(trigger) {};

/** @const */
Windows.ApplicationModel.Background.BackgroundTaskCancellationReason = {};
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskCancellationReason.abort;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskCancellationReason.terminating;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskCancellationReason.loggingOff;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskCancellationReason.servicingUpdate;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskCancellationReason.idleTask;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskCancellationReason.uninstall;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskCancellationReason.conditionLoss;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskCancellationReason.systemPolicy;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskCancellationReason.quietHoursEntered;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskCancellationReason.executionTimeExceeded;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskCancellationReason.resourceRevocation;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskCancellationReason.energySaver;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Background.BackgroundTaskCompletedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Background.BackgroundTaskCompletedEventArgs.prototype.instanceId;

/**
 * Throws an exception if the background task completed event has reported an error.
 * @return {void}
 */
Windows.ApplicationModel.Background.BackgroundTaskCompletedEventArgs.prototype.checkResult = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Background.BackgroundTaskDeferral = function() {};

/**
 * Informs the system that an asynchronous operation associated with a background task has finished.
 * @return {void}
 */
Windows.ApplicationModel.Background.BackgroundTaskDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Background.BackgroundTaskProgressEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Background.BackgroundTaskProgressEventArgs.prototype.instanceId;
 /** @type {number} */
Windows.ApplicationModel.Background.BackgroundTaskProgressEventArgs.prototype.progress;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Background.BackgroundTaskRegistration = function() {};
 /** @type {!Windows.Foundation.Collections.IMapView<string, !Windows.ApplicationModel.Background.IBackgroundTaskRegistration>} */
Windows.ApplicationModel.Background.BackgroundTaskRegistration.allTasks;
 /** @type {string} */
Windows.ApplicationModel.Background.BackgroundTaskRegistration.prototype.name;
 /** @type {function(?): void} */
Windows.ApplicationModel.Background.BackgroundTaskRegistration.prototype.oncompleted;
 /** @type {function(?): void} */
Windows.ApplicationModel.Background.BackgroundTaskRegistration.prototype.onprogress;
 /** @type {string} */
Windows.ApplicationModel.Background.BackgroundTaskRegistration.prototype.taskId;
 /** @type {!Windows.ApplicationModel.Background.IBackgroundTrigger} */
Windows.ApplicationModel.Background.BackgroundTaskRegistration.prototype.trigger;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Background.BackgroundTaskRegistration.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Background.BackgroundTaskRegistration.prototype.removeEventListener = function(type, listener) {};

/**
 * Cancels the registration of a registered background task.
 * @param {boolean} cancelTask True if currently running instances of this background task should be canceled. If this parameter is false, currently running instances are allowed to finish. Canceled instances receive a Canceled event with a cancellation reason of Abort.
 * @return {void}
 */
Windows.ApplicationModel.Background.BackgroundTaskRegistration.prototype.unregister = function(cancelTask) {};

/** @const */
Windows.ApplicationModel.Background.BackgroundTaskThrottleCounter = {};
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskThrottleCounter.all;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskThrottleCounter.cpu;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundTaskThrottleCounter.network;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Background.BackgroundWorkCost = function() {};
 /** @type {Windows.ApplicationModel.Background.BackgroundWorkCostValue} */
Windows.ApplicationModel.Background.BackgroundWorkCost.currentBackgroundWorkCost;

/** @const */
Windows.ApplicationModel.Background.BackgroundWorkCostValue = {};
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundWorkCostValue.low;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundWorkCostValue.medium;
/** @const {number} */
Windows.ApplicationModel.Background.BackgroundWorkCostValue.high;

/**
 * @constructor
 * @struct
 * Creates a new instance of the BluetoothLEAdvertisementPublisherTrigger class.
 */
Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger = function() {};
 /** @type {!Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement} */
Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger.prototype.advertisement;

/**
 * @constructor
 * @struct
 * Creates a new instance of the BluetoothLEAdvertisementWatcherTrigger class.
 */
Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger = function() {};
 /** @type {!Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFilter} */
Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger.prototype.advertisementFilter;
 /** @type {number} */
Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger.prototype.maxOutOfRangeTimeout;
 /** @type {number} */
Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger.prototype.maxSamplingInterval;
 /** @type {number} */
Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger.prototype.minOutOfRangeTimeout;
 /** @type {number} */
Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger.prototype.minSamplingInterval;
 /** @type {!Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter} */
Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger.prototype.signalStrengthFilter;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the CachedFileUpdaterTrigger class.
 */
Windows.ApplicationModel.Background.CachedFileUpdaterTrigger = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Background.CachedFileUpdaterTriggerDetails = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Background.CachedFileUpdaterTriggerDetails.prototype.canRequestUserInput;
 /** @type {!Windows.Storage.Provider.FileUpdateRequest} */
Windows.ApplicationModel.Background.CachedFileUpdaterTriggerDetails.prototype.updateRequest;
 /** @type {Windows.Storage.Provider.CachedFileTarget} */
Windows.ApplicationModel.Background.CachedFileUpdaterTriggerDetails.prototype.updateTarget;

/**
 * @constructor
 * @struct
 * Represents a trigger that is activated when there is a notification for a text message.
 */
Windows.ApplicationModel.Background.ChatMessageNotificationTrigger = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the ChatMessageReceivedNotificationTrigger class.
 */
Windows.ApplicationModel.Background.ChatMessageReceivedNotificationTrigger = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the ContactStoreNotificationTrigger class.
 */
Windows.ApplicationModel.Background.ContactStoreNotificationTrigger = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the ContentPrefetchTrigger class.
 * Initializes a new instance of the ContentPrefetchTrigger class using a specified time interval.
 * @param {number=} waitInterval Interval before next allowed content prefetch.
 */
Windows.ApplicationModel.Background.ContentPrefetchTrigger = function(waitInterval) {};
 /** @type {number} */
Windows.ApplicationModel.Background.ContentPrefetchTrigger.prototype.waitInterval;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger.prototype.canMaintainConnection;
 /** @type {string} */
Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger.prototype.deviceId;
 /** @type {boolean} */
Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger.prototype.maintainConnection;

/**
 * Begins an asynchronous operation to get the DeviceConnectionChangeTrigger associated with the specified Id.
 * @param {string} deviceId The device Id with which to find the associated trigger.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger>>} The DeviceConnectionChangeTrigger object associated with the specified device Id.
 */
Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger.fromIdAsync = function(deviceId) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the DeviceManufacturerNotificationTrigger class.
 * @param {string} triggerQualifier An app-defined string that qualifies the trigger.
 * @param {boolean} oneShot Whether the trigger is used only once.
 */
Windows.ApplicationModel.Background.DeviceManufacturerNotificationTrigger = function(triggerQualifier, oneShot) {};
 /** @type {boolean} */
Windows.ApplicationModel.Background.DeviceManufacturerNotificationTrigger.prototype.oneShot;
 /** @type {string} */
Windows.ApplicationModel.Background.DeviceManufacturerNotificationTrigger.prototype.triggerQualifier;

/**
 * @constructor
 * @struct
 * Constructor for DeviceServicingTrigger . Takes no parameters.
 */
Windows.ApplicationModel.Background.DeviceServicingTrigger = function() {};

/**
 * Triggers the background task (settings or firmware update) and returns a DeviceTriggerResult indicating success or failure of the trigger request. Takes the DeviceInformation.ID string and an optional estimated time the background task will run. If your app cannot determine an appropriate time estimate, provide zero as the estimated time.
 * Triggers the background task (settings or firmware update) and returns a DeviceTriggerResult indicating success or failure of the trigger request. Takes the DeviceInformation.ID string, an optional estimated time the background task will run, and an optional app-specific string passed to the background task identifying which device operation to perform. If your app cannot determine an appropriate time estimate, provide zero as the estimated time.
 * @param {string} deviceId The DeviceInformation.ID of the device the background task will access.
 * @param {number} expectedDuration Optional value. The expected duration of the background settings update or background firmware update. Set this value to zero if an appropriate time estimate cannot be determined.
 * @param {string=} args
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.ApplicationModel.Background.DeviceTriggerResult, !Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Background.DeviceTriggerResult>>} This method returns a DeviceTriggerResult when it completes asynchronously.
 */
Windows.ApplicationModel.Background.DeviceServicingTrigger.prototype.requestAsync = function(deviceId, expectedDuration, args) {};

/** @const */
Windows.ApplicationModel.Background.DeviceTriggerResult = {};
/** @const {number} */
Windows.ApplicationModel.Background.DeviceTriggerResult.allowed;
/** @const {number} */
Windows.ApplicationModel.Background.DeviceTriggerResult.deniedByUser;
/** @const {number} */
Windows.ApplicationModel.Background.DeviceTriggerResult.deniedBySystem;
/** @const {number} */
Windows.ApplicationModel.Background.DeviceTriggerResult.lowBattery;

/**
 * @constructor
 * @struct
 * Constructor for DeviceUseTrigger . Takes no parameters.
 */
Windows.ApplicationModel.Background.DeviceUseTrigger = function() {};

/**
 * Triggers the background task and returns a DeviceTriggerResult indicating success or failure of the trigger request. Takes the DeviceInformation.ID of the device or sensor that the background task will access, and an optional app-specific string passed to the background task identifying which operation to perform.
 * Triggers the background task and returns a DeviceTriggerResult indicating success or failure of the trigger request. Takes the DeviceInformation.ID of the device or sensor that the background task will access.
 * @param {string} deviceId The DeviceInformation.ID of the device or sensor that the background task will access.
 * @param {string=} args
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.ApplicationModel.Background.DeviceTriggerResult, !Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Background.DeviceTriggerResult>>} This method returns a DeviceTriggerResult when it completes asynchronously.
 */
Windows.ApplicationModel.Background.DeviceUseTrigger.prototype.requestAsync = function(deviceId, args) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Background.DeviceWatcherTrigger = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the EmailStoreNotificationTrigger class.
 */
Windows.ApplicationModel.Background.EmailStoreNotificationTrigger = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the GattCharacteristicNotificationTrigger class.
 * @param {!Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic} characteristic The GATT characteristic for which value change notifications are desired.
 */
Windows.ApplicationModel.Background.GattCharacteristicNotificationTrigger = function(characteristic) {};
 /** @type {!Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic} */
Windows.ApplicationModel.Background.GattCharacteristicNotificationTrigger.prototype.characteristic;

/**
 * @constructor
 * @struct
 * Initializes a new instance of a location event trigger.
 * @param {Windows.ApplicationModel.Background.LocationTriggerType} triggerType The type of location event for this trigger.
 */
Windows.ApplicationModel.Background.LocationTrigger = function(triggerType) {};
 /** @type {Windows.ApplicationModel.Background.LocationTriggerType} */
Windows.ApplicationModel.Background.LocationTrigger.prototype.triggerType;

/** @const */
Windows.ApplicationModel.Background.LocationTriggerType = {};
/** @const {number} */
Windows.ApplicationModel.Background.LocationTriggerType.geofence;

/**
 * @constructor
 * @struct
 * Initializes a new instance of a maintenance trigger.
 * @param {number} freshnessTime The number of minutes to wait before scheduling the background task. The system schedules the task within 15 minutes after freshnessTime elapses.
 * @param {boolean} oneShot True if the maintenance trigger is used once; false if it is used each time the freshnessTime interval elapses.
 */
Windows.ApplicationModel.Background.MaintenanceTrigger = function(freshnessTime, oneShot) {};
 /** @type {number} */
Windows.ApplicationModel.Background.MaintenanceTrigger.prototype.freshnessTime;
 /** @type {boolean} */
Windows.ApplicationModel.Background.MaintenanceTrigger.prototype.oneShot;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the MediaProcessingTrigger class.
 */
Windows.ApplicationModel.Background.MediaProcessingTrigger = function() {};

/**
 * Triggers the background task and returns a MediaProcessingTriggerResult indicating success or failure of the trigger request.
 * Triggers the background task with the provided collection of arguments and returns a MediaProcessingTriggerResult indicating success or failure of the trigger request.
 * @param {!Windows.Foundation.Collections.ValueSet=} args
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.ApplicationModel.Background.MediaProcessingTriggerResult, !Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Background.MediaProcessingTriggerResult>>} An asynchronous operation that returns a MediaProcessingTriggerResult upon completion.
 */
Windows.ApplicationModel.Background.MediaProcessingTrigger.prototype.requestAsync = function(args) {};

/** @const */
Windows.ApplicationModel.Background.MediaProcessingTriggerResult = {};
/** @const {number} */
Windows.ApplicationModel.Background.MediaProcessingTriggerResult.allowed;
/** @const {number} */
Windows.ApplicationModel.Background.MediaProcessingTriggerResult.currentlyRunning;
/** @const {number} */
Windows.ApplicationModel.Background.MediaProcessingTriggerResult.disabledByPolicy;
/** @const {number} */
Windows.ApplicationModel.Background.MediaProcessingTriggerResult.unknownError;

/**
 * @constructor
 * @struct
 * Constructs a MobileBroadbandDeviceServiceNotificationTrigger object.
 */
Windows.ApplicationModel.Background.MobileBroadbandDeviceServiceNotificationTrigger = function() {};

/**
 * @constructor
 * @struct
 * Constructs a MobileBroadbandPinLockStateChangeTrigger object.
 */
Windows.ApplicationModel.Background.MobileBroadbandPinLockStateChangeTrigger = function() {};

/**
 * @constructor
 * @struct
 * Constructs a MobileBroadbandRadioStateChangeTrigger object.
 */
Windows.ApplicationModel.Background.MobileBroadbandRadioStateChangeTrigger = function() {};

/**
 * @constructor
 * @struct
 * Creates a MobileBroadbandRegistrationStateChangeTrigger object.
 */
Windows.ApplicationModel.Background.MobileBroadbandRegistrationStateChangeTrigger = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of a mobile network operator hotspot authentication trigger.
 */
Windows.ApplicationModel.Background.NetworkOperatorHotspotAuthenticationTrigger = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of a mobile network operator notification.
 * @param {string} networkAccountId Specifies the unique identifier of the mobile broadband account.
 */
Windows.ApplicationModel.Background.NetworkOperatorNotificationTrigger = function(networkAccountId) {};
 /** @type {string} */
Windows.ApplicationModel.Background.NetworkOperatorNotificationTrigger.prototype.networkAccountId;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PhoneTrigger class.
 * @param {Windows.ApplicationModel.Calls.Background.PhoneTriggerType} type Specifies the type of phone event.
 * @param {boolean} oneShot Indicates if the trigger is a one-shot notification. If you weren't subscribed when a one-shot notification was sent, you get nothing. If you weren't connected when you fired a one-shot notification, nothing happens.
 */
Windows.ApplicationModel.Background.PhoneTrigger = function(type, oneShot) {};
 /** @type {boolean} */
Windows.ApplicationModel.Background.PhoneTrigger.prototype.oneShot;
 /** @type {Windows.ApplicationModel.Calls.Background.PhoneTriggerType} */
Windows.ApplicationModel.Background.PhoneTrigger.prototype.triggerType;

/**
 * @constructor
 * @struct
 * Invokes a background work item on the app in response to the receipt of a raw notification .
 * Invokes a background work item on a specified app in response to the receipt of a raw notification .
 * @param {string=} applicationId The app's Package Relative Application ID (PRAID). The specified app must be in the same package as the calling app.
 */
Windows.ApplicationModel.Background.PushNotificationTrigger = function(applicationId) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the RcsEndUserMessageAvailableTrigger class.
 */
Windows.ApplicationModel.Background.RcsEndUserMessageAvailableTrigger = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the RfcommConnectionTrigger class.
 */
Windows.ApplicationModel.Background.RfcommConnectionTrigger = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Background.RfcommConnectionTrigger.prototype.allowMultipleConnections;
 /** @type {!Windows.Devices.Bluetooth.Background.RfcommInboundConnectionInformation} */
Windows.ApplicationModel.Background.RfcommConnectionTrigger.prototype.inboundConnection;
 /** @type {!Windows.Devices.Bluetooth.Background.RfcommOutboundConnectionInformation} */
Windows.ApplicationModel.Background.RfcommConnectionTrigger.prototype.outboundConnection;
 /** @type {Windows.Networking.Sockets.SocketProtectionLevel} */
Windows.ApplicationModel.Background.RfcommConnectionTrigger.prototype.protectionLevel;
 /** @type {!Windows.Networking.HostName} */
Windows.ApplicationModel.Background.RfcommConnectionTrigger.prototype.remoteHostName;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the SensorDataThresholdTrigger class.
 * @param {!Windows.Devices.Sensors.ISensorDataThreshold} threshold The threshold for a sensor that indicates when it should be triggered.
 */
Windows.ApplicationModel.Background.SensorDataThresholdTrigger = function(threshold) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of an SMS message received trigger.
 * @param {!Windows.Devices.Sms.SmsFilterRules} filterRules Filter rules to be applied to incoming SMS messages. Only messages that pass through the filter rules raise the trigger.
 */
Windows.ApplicationModel.Background.SmsMessageReceivedTrigger = function(filterRules) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of a socket activity trigger.
 */
Windows.ApplicationModel.Background.SocketActivityTrigger = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Background.StorageLibraryContentChangedTrigger = function() {};

/**
 * Creates a trigger that will fire when a file is changed in the specified library.
 * @param {!Windows.Storage.StorageLibrary} storageLibrary The location that the trigger monitors such as the music library or documents library.
 * @return {!Windows.ApplicationModel.Background.StorageLibraryContentChangedTrigger} A trigger that monitors the specified location.
 */
Windows.ApplicationModel.Background.StorageLibraryContentChangedTrigger.create = function(storageLibrary) {};

/**
 * Creates a trigger that will fire when a file is changed in any of the specified libraries.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Storage.StorageLibrary>} storageLibraries The list of libraries that the trigger will monitor.
 * @return {!Windows.ApplicationModel.Background.StorageLibraryContentChangedTrigger} A trigger that monitors the specified location(s).
 */
Windows.ApplicationModel.Background.StorageLibraryContentChangedTrigger.createFromLibraries = function(storageLibraries) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of a system condition.
 * @param {Windows.ApplicationModel.Background.SystemConditionType} conditionType Specifies the condition type.
 */
Windows.ApplicationModel.Background.SystemCondition = function(conditionType) {};
 /** @type {Windows.ApplicationModel.Background.SystemConditionType} */
Windows.ApplicationModel.Background.SystemCondition.prototype.conditionType;

/** @const */
Windows.ApplicationModel.Background.SystemConditionType = {};
/** @const {number} */
Windows.ApplicationModel.Background.SystemConditionType.invalid;
/** @const {number} */
Windows.ApplicationModel.Background.SystemConditionType.userPresent;
/** @const {number} */
Windows.ApplicationModel.Background.SystemConditionType.userNotPresent;
/** @const {number} */
Windows.ApplicationModel.Background.SystemConditionType.internetAvailable;
/** @const {number} */
Windows.ApplicationModel.Background.SystemConditionType.internetNotAvailable;
/** @const {number} */
Windows.ApplicationModel.Background.SystemConditionType.sessionConnected;
/** @const {number} */
Windows.ApplicationModel.Background.SystemConditionType.sessionDisconnected;
/** @const {number} */
Windows.ApplicationModel.Background.SystemConditionType.freeNetworkAvailable;
/** @const {number} */
Windows.ApplicationModel.Background.SystemConditionType.backgroundWorkCostNotHigh;

/**
 * @constructor
 * @struct
 * Initializes a new instance of a system event trigger.
 * @param {Windows.ApplicationModel.Background.SystemTriggerType} triggerType Specifies the system event type.
 * @param {boolean} oneShot True if the system event trigger will be used once; false if it will be used every time the event occurs.
 */
Windows.ApplicationModel.Background.SystemTrigger = function(triggerType, oneShot) {};
 /** @type {boolean} */
Windows.ApplicationModel.Background.SystemTrigger.prototype.oneShot;
 /** @type {Windows.ApplicationModel.Background.SystemTriggerType} */
Windows.ApplicationModel.Background.SystemTrigger.prototype.triggerType;

/** @const */
Windows.ApplicationModel.Background.SystemTriggerType = {};
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.invalid;
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.smsReceived;
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.userPresent;
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.userAway;
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.networkStateChange;
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.controlChannelReset;
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.internetAvailable;
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.sessionConnected;
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.servicingComplete;
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.lockScreenApplicationAdded;
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.lockScreenApplicationRemoved;
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.timeZoneChange;
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.onlineIdConnectedStateChange;
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.backgroundWorkCostChange;
/** @const {number} */
Windows.ApplicationModel.Background.SystemTriggerType.powerStateChange;

/**
 * @constructor
 * @struct
 * Initializes a new instance of a time event trigger.
 * @param {number} freshnessTime Specifies the number of minutes to wait before scheduling the background task. The system schedules the task within 15 minutes after freshnessTime elapses. If the OneShot property is false, freshnessTime specifies the interval between recurring tasks.
 * @param {boolean} oneShot True if the time event trigger will be used once; false if it will be used each time freshnessTime elapses.
 */
Windows.ApplicationModel.Background.TimeTrigger = function(freshnessTime, oneShot) {};
 /** @type {number} */
Windows.ApplicationModel.Background.TimeTrigger.prototype.freshnessTime;
 /** @type {boolean} */
Windows.ApplicationModel.Background.TimeTrigger.prototype.oneShot;

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the ToastNotificationActionTrigger class.
 * Creates and initializes a new instance of the ToastNotificationActionTrigger class for the app with the specified identifier.
 * @param {string=} applicationId The identifier of the app for which you want to create an instance of the ToastNotificationActionTrigger class.
 */
Windows.ApplicationModel.Background.ToastNotificationActionTrigger = function(applicationId) {};

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the ToastNotificationHistoryChangedTrigger class.
 * Creates and initializes a new instance of the ToastNotificationHistoryChangedTrigger class for the app with the specified identifier.
 * @param {string=} applicationId The identifier of the app for which you want to create an instance of the ToastNotificationHistoryChangedTrigger class.
 */
Windows.ApplicationModel.Background.ToastNotificationHistoryChangedTrigger = function(applicationId) {};
/**
 * @record
 * @struct
 */
Windows.ApplicationModel.Background.IBackgroundCondition = function() {};
/**
 * @record
 * @struct
 */
Windows.ApplicationModel.Background.IBackgroundTrigger = function() {};
/**
 * @record
 * @struct
 */
Windows.ApplicationModel.Background.IBackgroundTaskRegistration = function() {};
 /** @type {string} */
Windows.ApplicationModel.Background.IBackgroundTaskRegistration.prototype.name;
 /** @type {string} */
Windows.ApplicationModel.Background.IBackgroundTaskRegistration.prototype.taskId;
 /** @type {!Windows.ApplicationModel.Background.IBackgroundTrigger} */
Windows.ApplicationModel.Background.IBackgroundTaskRegistration.prototype.trigger;

/**
 * Unregisters a registered background task.
 * @param {boolean} cancelTask True if currently running instances of this background task should be canceled. If this parameter is false, currently running instances of this background task should be allowed to finish. Canceled instances receive a Canceled event with a BackgroundTaskCancellationReason of Abort.
 * @return {void}
 */
Windows.ApplicationModel.Background.IBackgroundTaskRegistration.prototype.unregister = function(cancelTask) {};

/** @typedef {function(?): void} */
Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler;

/** @typedef {function(?): void} */
Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler;

/** @typedef {function(?): void} */
Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler;
/**
 * @record
 * @struct
 */
Windows.ApplicationModel.Background.IBackgroundTaskInstance = function() {};
 /** @type {string} */
Windows.ApplicationModel.Background.IBackgroundTaskInstance.prototype.instanceId;
 /** @type {number} */
Windows.ApplicationModel.Background.IBackgroundTaskInstance.prototype.progress;
 /** @type {number} */
Windows.ApplicationModel.Background.IBackgroundTaskInstance.prototype.suspendedCount;
 /** @type {!Windows.ApplicationModel.Background.BackgroundTaskRegistration} */
Windows.ApplicationModel.Background.IBackgroundTaskInstance.prototype.task;
 /** @type {?} */
Windows.ApplicationModel.Background.IBackgroundTaskInstance.prototype.triggerDetails;

/**
 * Informs the system that the background task might continue to perform work after the IBackgroundTask.Run method returns.
 * @return {!Windows.ApplicationModel.Background.BackgroundTaskDeferral} A background task deferral.
 */
Windows.ApplicationModel.Background.IBackgroundTaskInstance.prototype.getDeferral = function() {};

/**
 * Retrieves the number of times the background task has been suspended for using too many resources.
 * @param {Windows.ApplicationModel.Background.BackgroundTaskThrottleCounter} counter Indicates the type of resource to include in the throttle count: network, CPU, or both.
 * @return {number} This method returns the number of times the background task has been suspended for exceeding its quota of the indicated resource type.
 */
Windows.ApplicationModel.Background.IBackgroundTaskInstance.prototype.getThrottleCount = function(counter) {};
/** @const */
Windows.ApplicationModel.Calls = {};
/** @const */
Windows.ApplicationModel.Calls.Background = {};

/** @const */
Windows.ApplicationModel.Calls.Background.PhoneCallBlockedReason = {};
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneCallBlockedReason.inCallBlockingList;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneCallBlockedReason.privateNumber;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneCallBlockedReason.unknownNumber;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Calls.Background.PhoneCallBlockedTriggerDetails = function() {};
 /** @type {Windows.ApplicationModel.Calls.Background.PhoneCallBlockedReason} */
Windows.ApplicationModel.Calls.Background.PhoneCallBlockedTriggerDetails.prototype.callBlockedReason;
 /** @type {string} */
Windows.ApplicationModel.Calls.Background.PhoneCallBlockedTriggerDetails.prototype.lineId;
 /** @type {string} */
Windows.ApplicationModel.Calls.Background.PhoneCallBlockedTriggerDetails.prototype.phoneNumber;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Calls.Background.PhoneCallOriginDataRequestTriggerDetails = function() {};
 /** @type {string} */
Windows.ApplicationModel.Calls.Background.PhoneCallOriginDataRequestTriggerDetails.prototype.phoneNumber;
 /** @type {string} */
Windows.ApplicationModel.Calls.Background.PhoneCallOriginDataRequestTriggerDetails.prototype.requestId;

/** @const */
Windows.ApplicationModel.Calls.Background.PhoneLineChangeKind = {};
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneLineChangeKind.added;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneLineChangeKind.removed;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneLineChangeKind.propertiesChanged;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Calls.Background.PhoneLineChangedTriggerDetails = function() {};
 /** @type {Windows.ApplicationModel.Calls.Background.PhoneLineChangeKind} */
Windows.ApplicationModel.Calls.Background.PhoneLineChangedTriggerDetails.prototype.changeType;
 /** @type {string} */
Windows.ApplicationModel.Calls.Background.PhoneLineChangedTriggerDetails.prototype.lineId;

/**
 * Checks a phone line against a set of flags to see if any of the specified properties of the phone line have changed.
 * @param {Windows.ApplicationModel.Calls.Background.PhoneLineProperties} lineProperty A set of flags which indicate the phone line properties to query for changes.
 * @return {boolean} Returns true if any of the properties indicated by the lineProperty parameter have changed on the phone line.
 */
Windows.ApplicationModel.Calls.Background.PhoneLineChangedTriggerDetails.prototype.hasLinePropertyChanged = function(lineProperty) {};

/** @const */
Windows.ApplicationModel.Calls.Background.PhoneLineProperties = {};
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneLineProperties.none;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneLineProperties.brandingOptions;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneLineProperties.canDial;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneLineProperties.cellularDetails;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneLineProperties.displayColor;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneLineProperties.displayName;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneLineProperties.networkName;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneLineProperties.networkState;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneLineProperties.transport;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneLineProperties.voicemail;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Calls.Background.PhoneNewVoicemailMessageTriggerDetails = function() {};
 /** @type {string} */
Windows.ApplicationModel.Calls.Background.PhoneNewVoicemailMessageTriggerDetails.prototype.lineId;
 /** @type {string} */
Windows.ApplicationModel.Calls.Background.PhoneNewVoicemailMessageTriggerDetails.prototype.operatorMessage;
 /** @type {number} */
Windows.ApplicationModel.Calls.Background.PhoneNewVoicemailMessageTriggerDetails.prototype.voicemailCount;

/** @const */
Windows.ApplicationModel.Calls.Background.PhoneTriggerType = {};
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneTriggerType.newVoicemailMessage;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneTriggerType.callHistoryChanged;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneTriggerType.lineChanged;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneTriggerType.airplaneModeDisabledForEmergencyCall;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneTriggerType.callOriginDataRequest;
/** @const {number} */
Windows.ApplicationModel.Calls.Background.PhoneTriggerType.callBlocked;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Calls.LockScreenCallEndCallDeferral = function() {};

/**
 * Completes the deferral of the removal of the app from the lock screen, which causes the app to be removed from the lock screen if it hasn't already been removed by other means.
 * @return {void}
 */
Windows.ApplicationModel.Calls.LockScreenCallEndCallDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Calls.LockScreenCallEndRequestedEventArgs = function() {};
 /** @type {!Date} */
Windows.ApplicationModel.Calls.LockScreenCallEndRequestedEventArgs.prototype.deadline;

/**
 * Requests to defer the default behavior of removing the app from the lock screen.
 * @return {!Windows.ApplicationModel.Calls.LockScreenCallEndCallDeferral} When this method completes, it returns a LockScreenCallEndCallDeferral object that signals when the app no longer needs to defer the removal of itself from the lock screen.
 */
Windows.ApplicationModel.Calls.LockScreenCallEndRequestedEventArgs.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Calls.LockScreenCallUI = function() {};
 /** @type {string} */
Windows.ApplicationModel.Calls.LockScreenCallUI.prototype.callTitle;
 /** @type {function(?): void} */
Windows.ApplicationModel.Calls.LockScreenCallUI.prototype.onclosed;
 /** @type {function(?): void} */
Windows.ApplicationModel.Calls.LockScreenCallUI.prototype.onendrequested;

/**
 * Removes the app from the lock screen UI.
 * @return {void}
 */
Windows.ApplicationModel.Calls.LockScreenCallUI.prototype.dismiss = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Calls.LockScreenCallUI.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Calls.LockScreenCallUI.prototype.removeEventListener = function(type, listener) {};

/**
 * @constructor
 * @struct
 * Creates a new PhoneCallHistoryEntry object.
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry = function() {};
 /** @type {!Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.address;
 /** @type {number} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.duration;
 /** @type {string} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.id;
 /** @type {boolean} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.isCallerIdBlocked;
 /** @type {boolean} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.isEmergency;
 /** @type {boolean} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.isIncoming;
 /** @type {boolean} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.isMissed;
 /** @type {boolean} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.isRinging;
 /** @type {boolean} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.isSeen;
 /** @type {boolean} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.isSuppressed;
 /** @type {boolean} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.isVoicemail;
 /** @type {Windows.ApplicationModel.Calls.PhoneCallHistoryEntryMedia} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.media;
 /** @type {Windows.ApplicationModel.Calls.PhoneCallHistoryEntryOtherAppReadAccess} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.otherAppReadAccess;
 /** @type {string} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.remoteId;
 /** @type {string} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.sourceDisplayName;
 /** @type {string} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.sourceId;
 /** @type {Windows.ApplicationModel.Calls.PhoneCallHistorySourceIdKind} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.sourceIdKind;
 /** @type {!Date} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntry.prototype.startTime;

/**
 * @constructor
 * @struct
 * Creates a new empty PhoneCallHistoryEntryAddress object.
 * Creates a new PhoneCallHistoryEntryAddress object with an initial address.
 * @param {string=} rawAddress The address to initiailize to the RawAddress property.
 * @param {Windows.ApplicationModel.Calls.PhoneCallHistoryEntryRawAddressKind=} rawAddressKind The type of address represented by rawAddress.
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress = function(rawAddress, rawAddressKind) {};
 /** @type {string} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress.prototype.contactId;
 /** @type {string} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress.prototype.displayName;
 /** @type {string} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress.prototype.rawAddress;
 /** @type {Windows.ApplicationModel.Calls.PhoneCallHistoryEntryRawAddressKind} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress.prototype.rawAddressKind;

/** @const */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryMedia = {};
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryMedia.audio;
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryMedia.video;

/** @const */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryOtherAppReadAccess = {};
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryOtherAppReadAccess.full;
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryOtherAppReadAccess.systemOnly;

/** @const */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryDesiredMedia = {};
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryDesiredMedia.none;
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryDesiredMedia.audio;
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryDesiredMedia.video;
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryDesiredMedia.all;

/**
 * @constructor
 * @struct
 * Creates a new PhoneCallHistoryEntryQueryOptions object.
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryOptions = function() {};
 /** @type {Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryDesiredMedia} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryOptions.prototype.desiredMedia;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryOptions.prototype.sourceIds;

/** @const */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryRawAddressKind = {};
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryRawAddressKind.phoneNumber;
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryRawAddressKind.custom;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryReader = function() {};

/**
 * Returns a list of the PhoneCallHistoryEntry objects.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that returns an IVectorView upon successful completion.
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryEntryReader.prototype.readBatchAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryManager = function() {};

/**
 * Requests the PhoneCallHistoryStore associated with the calling application.
 * @param {Windows.ApplicationModel.Calls.PhoneCallHistoryStoreAccessType} accessType The type of access requested for the PhoneCallHistoryStore object.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Calls.PhoneCallHistoryStore, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Calls.PhoneCallHistoryStore>>} An asynchronous operation that returns a PhoneCallHistoryStore object on successful completion.
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryManager.requestStoreAsync = function(accessType) {};

/** @const */
Windows.ApplicationModel.Calls.PhoneCallHistorySourceIdKind = {};
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistorySourceIdKind.cellularPhoneLineId;
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistorySourceIdKind.packageFamilyName;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryStore = function() {};

/**
 * Deletes entries in the store.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.ApplicationModel.Calls.PhoneCallHistoryEntry>} callHistoryEntries The entries to delete.
 * @return {?}
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryStore.prototype.deleteEntriesAsync = function(callHistoryEntries) {};

/**
 * Delete an entry from the store.
 * @param {!Windows.ApplicationModel.Calls.PhoneCallHistoryEntry} callHistoryEntry The entry to delete.
 * @return {?}
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryStore.prototype.deleteEntryAsync = function(callHistoryEntry) {};

/**
 * Gets an entry from the store based on the entry id.
 * @param {string} callHistoryEntryId The PhoneCallHistoryEntryt.Id of the relevant entry.
 * @return {?}
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryStore.prototype.getEntryAsync = function(callHistoryEntryId) {};

/**
 * Retrieves an entry reader based on provided filters.
 * Retrieves a default phone call history entry that reads all entries.
 * @param {!Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryOptions=} queryOptions The options used to create a filtered entry reader.
 * @return {!Windows.ApplicationModel.Calls.PhoneCallHistoryEntryReader} A reader that can be used to go through the phone call log entries.
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryStore.prototype.getEntryReader = function(queryOptions) {};

/**
 * Gets the number of unseen log entries for the provided sources.
 * @param {!Windows.Foundation.Collections.IIterable<string>} sourceIds The identifiers that need to match PhoneCallHistoryEntry.SourceId in order for that entry to be considered.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} The total number of unseen entries matching all of the identifiers provided by sourceIds.
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryStore.prototype.getSourcesUnseenCountAsync = function(sourceIds) {};

/**
 * Gets the number of unseen entries.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} The number of unseen entries.
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryStore.prototype.getUnseenCountAsync = function() {};

/**
 * Update all the entries to indicate they have all been seen by the user.
 * @return {?}
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryStore.prototype.markAllAsSeenAsync = function() {};

/**
 * Updates entries to indicate they have been seen by the user.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.ApplicationModel.Calls.PhoneCallHistoryEntry>} callHistoryEntries The entries to mark as seen. This updates the PhoneCallHistoryEntry.IsSeen property.
 * @return {?}
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryStore.prototype.markEntriesAsSeenAsync = function(callHistoryEntries) {};

/**
 * Updates an entry to indicate it has been seen.
 * @param {!Windows.ApplicationModel.Calls.PhoneCallHistoryEntry} callHistoryEntry The entry to update.
 * @return {?}
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryStore.prototype.markEntryAsSeenAsync = function(callHistoryEntry) {};

/**
 * Marks all entries from the specified sources as seen.
 * @param {!Windows.Foundation.Collections.IIterable<string>} sourceIds The list of source identifiers to mark as seen. Only entries that match PhoneCallHistoryEntry.SourceId will be updated.
 * @return {?}
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryStore.prototype.markSourcesAsSeenAsync = function(sourceIds) {};

/**
 * Saves an entry to the store.
 * @param {!Windows.ApplicationModel.Calls.PhoneCallHistoryEntry} callHistoryEntry The entry to save.
 * @return {?}
 */
Windows.ApplicationModel.Calls.PhoneCallHistoryStore.prototype.saveEntryAsync = function(callHistoryEntry) {};

/** @const */
Windows.ApplicationModel.Calls.PhoneCallHistoryStoreAccessType = {};
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistoryStoreAccessType.appEntriesReadWrite;
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistoryStoreAccessType.allEntriesLimitedReadWrite;
/** @const {number} */
Windows.ApplicationModel.Calls.PhoneCallHistoryStoreAccessType.allEntriesReadWrite;
/** @const */
Windows.ApplicationModel.Chat = {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatCapabilities = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatCapabilities.prototype.isChatCapable;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatCapabilities.prototype.isFileTransferCapable;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatCapabilities.prototype.isGeoLocationPushCapable;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatCapabilities.prototype.isIntegratedMessagingCapable;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatCapabilities.prototype.isOnline;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatCapabilitiesManager = function() {};

/**
 * Asynchronously gets the locally cached Rich Communication Services (RCS) chat capabilities for the specified phone number.
 * @param {string} address The phone number for which to get the RCS chat capabilites
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Chat.ChatCapabilities, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Chat.ChatCapabilities>>} The locally cached RCS chat capabilities.
 */
Windows.ApplicationModel.Chat.ChatCapabilitiesManager.getCachedCapabilitiesAsync = function(address) {};

/**
 * Asynchronously gets the Rich Communication Services (RCS) chat capabilities for the specified phone number from the service provider.
 * @param {string} address The phone number for which to get the RCS chat capabilities.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Chat.ChatCapabilities, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Chat.ChatCapabilities>>} The RCS chat capabilities from the service provider.
 */
Windows.ApplicationModel.Chat.ChatCapabilitiesManager.getCapabilitiesFromNetworkAsync = function(address) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatConversation = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatConversation.prototype.canModifyParticipants;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatConversation.prototype.hasUnreadMessages;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatConversation.prototype.id;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatConversation.prototype.isConversationMuted;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatConversation.prototype.mostRecentMessageId;
 /** @type {function(?): void} */
Windows.ApplicationModel.Chat.ChatConversation.prototype.onremoteparticipantcomposingchanged;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.Chat.ChatConversation.prototype.participants;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatConversation.prototype.subject;
 /** @type {!Windows.ApplicationModel.Chat.ChatConversationThreadingInfo} */
Windows.ApplicationModel.Chat.ChatConversation.prototype.threadingInfo;

/**
 * Asynchronously deletes all of the messages in the ChatConversation and the conversation itself.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action that indicates when the delete has completed.
 */
Windows.ApplicationModel.Chat.ChatConversation.prototype.deleteAsync = function() {};

/**
 * Gets the ChatMessageReader for this ChatConversation .
 * @return {!Windows.ApplicationModel.Chat.ChatMessageReader} The ChatMessageReader for this ChatConversation .
 */
Windows.ApplicationModel.Chat.ChatConversation.prototype.getMessageReader = function() {};

/**
 * Asynchronously marks all the messages in the conversation before the specified DateTime as read.
 * Asynchronously marks all the messages in the conversation as read.
 * @param {!Date=} value Mark all messages before this DateTime as read.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Chat.ChatConversation.prototype.markMessagesAsReadAsync = function(value) {};

/**
 * Call this to indicate that the local participant has started or has completed typing.
 * @param {string} transportId Specifies the ChatMessageTransport to use.
 * @param {string} participantAddress The address of the remote participant.
 * @param {boolean} isComposing TRUE if the local participant is typing, otherwise FALSE.
 * @return {void}
 */
Windows.ApplicationModel.Chat.ChatConversation.prototype.notifyLocalParticipantComposing = function(transportId, participantAddress, isComposing) {};

/**
 * Locally triggers the event that indicates that a remote participant is typing.
 * @param {string} transportId Specifies the ChatMessageTransport to use.
 * @param {string} participantAddress The address of the remote participant.
 * @param {boolean} isComposing TRUE if the remote participant is typing, otherwise FALSE.
 * @return {void}
 */
Windows.ApplicationModel.Chat.ChatConversation.prototype.notifyRemoteParticipantComposing = function(transportId, participantAddress, isComposing) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Chat.ChatConversation.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Chat.ChatConversation.prototype.removeEventListener = function(type, listener) {};

/**
 * Asynchronously saves the ChatConversation .
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Chat.ChatConversation.prototype.saveAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatConversationReader = function() {};

/**
 * Asynchronously reads batches of conversations from the ChatMessageStore .
 * Asynchronously reads batches of conversations from the ChatMessageStore .
 * @param {number=} count Specifies the size of the batch to read.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The list of conversations.
 */
Windows.ApplicationModel.Chat.ChatConversationReader.prototype.readBatchAsync = function(count) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the ChatConversationThreadingInfo class.
 */
Windows.ApplicationModel.Chat.ChatConversationThreadingInfo = function() {};
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatConversationThreadingInfo.prototype.contactId;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatConversationThreadingInfo.prototype.conversationId;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatConversationThreadingInfo.prototype.custom;
 /** @type {Windows.ApplicationModel.Chat.ChatConversationThreadingKind} */
Windows.ApplicationModel.Chat.ChatConversationThreadingInfo.prototype.kind;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.Chat.ChatConversationThreadingInfo.prototype.participants;

/** @const */
Windows.ApplicationModel.Chat.ChatConversationThreadingKind = {};
/** @const {number} */
Windows.ApplicationModel.Chat.ChatConversationThreadingKind.participants;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatConversationThreadingKind.contactId;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatConversationThreadingKind.conversationId;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatConversationThreadingKind.custom;

/** @const */
Windows.ApplicationModel.Chat.ChatItemKind = {};
/** @const {number} */
Windows.ApplicationModel.Chat.ChatItemKind.message;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatItemKind.conversation;

/**
 * @constructor
 * @struct
 * Creates a new instance of the ChatMessage class.
 */
Windows.ApplicationModel.Chat.ChatMessage = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Chat.ChatMessageAttachment>} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.attachments;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.body;
 /** @type {number} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.estimatedDownloadSize;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.from;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.id;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.isAutoReply;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.isForwardingDisabled;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.isIncoming;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.isRead;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.isReceivedDuringQuietHours;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.isReplyDisabled;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.isSeen;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.isSimMessage;
 /** @type {!Date} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.localTimestamp;
 /** @type {Windows.ApplicationModel.Chat.ChatMessageKind} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.messageKind;
 /** @type {Windows.ApplicationModel.Chat.ChatMessageOperatorKind} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.messageOperatorKind;
 /** @type {!Date} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.networkTimestamp;
 /** @type {!Windows.Foundation.Collections.IMapView<string, Windows.ApplicationModel.Chat.ChatMessageStatus>} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.recipientSendStatuses;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.recipients;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo>} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.recipientsDeliveryInfos;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.remoteId;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.shouldSuppressNotification;
 /** @type {Windows.ApplicationModel.Chat.ChatMessageStatus} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.status;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.subject;
 /** @type {!Windows.ApplicationModel.Chat.ChatConversationThreadingInfo} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.threadingInfo;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.transportFriendlyName;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatMessage.prototype.transportId;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the ChatMessageAttachment class.
 * @param {string} mimeType The MIME type of the attachment.
 * @param {!Windows.Storage.Streams.IRandomAccessStreamReference} dataStreamReference A stream containing the attachment data.
 */
Windows.ApplicationModel.Chat.ChatMessageAttachment = function(mimeType, dataStreamReference) {};
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Chat.ChatMessageAttachment.prototype.dataStreamReference;
 /** @type {number} */
Windows.ApplicationModel.Chat.ChatMessageAttachment.prototype.groupId;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatMessageAttachment.prototype.mimeType;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatMessageAttachment.prototype.originalFileName;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatMessageAttachment.prototype.text;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Chat.ChatMessageAttachment.prototype.thumbnail;
 /** @type {number} */
Windows.ApplicationModel.Chat.ChatMessageAttachment.prototype.transferProgress;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatMessageBlocking = function() {};

/**
 * Asynchronously marks a message as blocked or unblocked.
 * @param {string} localChatMessageId The ID of the message to block.
 * @param {boolean} blocked TRUE if the message should be blocked, FALSE if it should be unblocked.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Chat.ChatMessageBlocking.markMessageAsBlockedAsync = function(localChatMessageId, blocked) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatMessageChange = function() {};
 /** @type {Windows.ApplicationModel.Chat.ChatMessageChangeType} */
Windows.ApplicationModel.Chat.ChatMessageChange.prototype.changeType;
 /** @type {!Windows.ApplicationModel.Chat.ChatMessage} */
Windows.ApplicationModel.Chat.ChatMessageChange.prototype.message;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatMessageChangeReader = function() {};

/**
 * Accepts all the changes up to and including the latest change to the message.
 * @return {void}
 */
Windows.ApplicationModel.Chat.ChatMessageChangeReader.prototype.acceptChanges = function() {};

/**
 * Accepts all the changes up to a specified change.
 * @param {!Windows.ApplicationModel.Chat.ChatMessageChange} lastChangeToAcknowledge The last change to acknowledge.
 * @return {void}
 */
Windows.ApplicationModel.Chat.ChatMessageChangeReader.prototype.acceptChangesThrough = function(lastChangeToAcknowledge) {};

/**
 * Returns a batch list of chat message change objects from the message stores change tracker.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that returns a list of changes.
 */
Windows.ApplicationModel.Chat.ChatMessageChangeReader.prototype.readBatchAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatMessageChangeTracker = function() {};

/**
 * Enables change tracking for the messages in the message store.
 * @return {void}
 */
Windows.ApplicationModel.Chat.ChatMessageChangeTracker.prototype.enable = function() {};

/**
 * Returns a ChatMessageChangeReader class object which provides a collection of message revisions from the message store.
 * @return {!Windows.ApplicationModel.Chat.ChatMessageChangeReader} The change reader associated with the change tracker.
 */
Windows.ApplicationModel.Chat.ChatMessageChangeTracker.prototype.getChangeReader = function() {};

/**
 * Resets change tracking for the messages in the message store. The first revision begins with the next message change.
 * @return {void}
 */
Windows.ApplicationModel.Chat.ChatMessageChangeTracker.prototype.reset = function() {};

/** @const */
Windows.ApplicationModel.Chat.ChatMessageChangeType = {};
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageChangeType.messageCreated;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageChangeType.messageModified;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageChangeType.messageDeleted;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageChangeType.changeTrackingLost;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatMessageChangedDeferral = function() {};

/**
 * Fires to indicate that the deferred change request has completed.
 * @return {void}
 */
Windows.ApplicationModel.Chat.ChatMessageChangedDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatMessageChangedEventArgs = function() {};

/**
 * The message changed event handler that an application registers with the message store receives a deferral object in the event parameters. The GetDeferral method registers a change deferral and allows an application to take action related to the change before the message store completes the change.
 * @return {!Windows.ApplicationModel.Chat.ChatMessageChangedDeferral} Gets a deferral for the MessageChanged event.
 */
Windows.ApplicationModel.Chat.ChatMessageChangedEventArgs.prototype.getDeferral = function() {};

/** @const */
Windows.ApplicationModel.Chat.ChatMessageKind = {};
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageKind.standard;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageKind.fileTransferRequest;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageKind.transportCustom;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageKind.joinedConversation;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageKind.leftConversation;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageKind.otherParticipantJoinedConversation;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageKind.otherParticipantLeftConversation;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatMessageManager = function() {};

/**
 * Asynchronously gets the ChatMessageTransport .
 * @param {string} transportId The locally unique identifier for the message transport.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Chat.ChatMessageTransport, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Chat.ChatMessageTransport>>} The message transport.
 */
Windows.ApplicationModel.Chat.ChatMessageManager.getTransportAsync = function(transportId) {};

/**
 * Asynchronously gets the chat message transports available on the device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that returns a list of transports on successful completion.
 */
Windows.ApplicationModel.Chat.ChatMessageManager.getTransportsAsync = function() {};

/**
 * Asynchronously registers the app as a ChatMessageTransport in order to post messages to the ChatMessageStore .
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} The transport ID for the newly registered ChatMessageTransport .
 */
Windows.ApplicationModel.Chat.ChatMessageManager.registerTransportAsync = function() {};

/**
 * Returns the SMS messaging store for the phone.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Chat.ChatMessageStore, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Chat.ChatMessageStore>>} An asynchronous operation that returns a ChatMessageStore on successful completion.
 */
Windows.ApplicationModel.Chat.ChatMessageManager.requestStoreAsync = function() {};

/**
 * Shows the compose SMS dialog, pre-populated with data from the supplied ChatMessage object, allowing the user to send an SMS message.
 * @param {!Windows.ApplicationModel.Chat.ChatMessage} message The chat message.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Chat.ChatMessageManager.showComposeSmsMessageAsync = function(message) {};

/**
 * Launches the device's SMS settings app.
 * @return {void}
 */
Windows.ApplicationModel.Chat.ChatMessageManager.showSmsSettings = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails = function() {};
 /** @type {!Windows.ApplicationModel.Chat.ChatMessage} */
Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails.prototype.chatMessage;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails.prototype.shouldDisplayToast;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails.prototype.shouldUpdateActionCenter;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails.prototype.shouldUpdateBadge;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails.prototype.shouldUpdateDetailText;

/** @const */
Windows.ApplicationModel.Chat.ChatMessageOperatorKind = {};
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageOperatorKind.unspecified;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageOperatorKind.sms;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageOperatorKind.mms;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageOperatorKind.rcs;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatMessageReader = function() {};

/**
 * Returns a batch list of chat messages from the message store.
 * Returns a batch list of chat messages from the message store limited to the specified size.
 * @param {number=} count The size of the batch to read.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that returns a list of chat messages upon successful completion.
 */
Windows.ApplicationModel.Chat.ChatMessageReader.prototype.readBatchAsync = function(count) {};

/** @const */
Windows.ApplicationModel.Chat.ChatMessageStatus = {};
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageStatus.draft;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageStatus.sending;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageStatus.sent;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageStatus.sendRetryNeeded;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageStatus.sendFailed;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageStatus.received;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageStatus.receiveDownloadNeeded;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageStatus.receiveDownloadFailed;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageStatus.receiveDownloading;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageStatus.deleted;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageStatus.declined;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageStatus.cancelled;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageStatus.recalled;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageStatus.receiveRetryNeeded;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatMessageStore = function() {};
 /** @type {!Windows.ApplicationModel.Chat.ChatMessageChangeTracker} */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.changeTracker;
 /** @type {function(?): void} */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.onmessagechanged;
 /** @type {function(?): void} */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.onstorechanged;

/**
 * Deletes a message from the chat message store.
 * @param {string} localMessageId The local ID of the message to be deleted.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.deleteMessageAsync = function(localMessageId) {};

/**
 * Downloads a message specified by the identifier to the message store.
 * @param {string} localChatMessageId The local ID of the message to be downloaded.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.downloadMessageAsync = function(localChatMessageId) {};

/**
 * Asynchronously forwards the specified message to new recipients.
 * @param {string} localChatMessageId The ID of the message to forward.
 * @param {!Windows.Foundation.Collections.IIterable<string>} addresses The addresses of the new recipients of the forwarded message.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Chat.ChatMessage, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Chat.ChatMessage>>} A copy of the forwarded message.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.forwardMessageAsync = function(localChatMessageId, addresses) {};

/**
 * Asynchronously gets a ChatConversation by ID using the specified transports.
 * Asynchronously gets a ChatConversation by ID.
 * @param {string} conversationId The ID of the conversation to retrieve.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} transportIds The IDs of the transports to use to retrieve the ChatConversation .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Chat.ChatConversation, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Chat.ChatConversation>>} The ChatConversation specified by the conversationId parameter.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.getConversationAsync = function(conversationId, transportIds) {};

/**
 * Asynchronously gets a conversation based on a threading info object.
 * @param {!Windows.ApplicationModel.Chat.ChatConversationThreadingInfo} threadingInfo The threading info that identifies the conversation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Chat.ChatConversation, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Chat.ChatConversation>>} The conversation identified by the threadingInfo parameter.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.getConversationFromThreadingInfoAsync = function(threadingInfo) {};

/**
 * Gets a new or existing ChatConversationReader for the message store.
 * Gets a new or existing ChatConversationReader for the message store using the specified transports.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} transportIds The IDs for the transports to use to retrieve the ChatConversationReader .
 * @return {!Windows.ApplicationModel.Chat.ChatConversationReader} The new or existing ChatConversationReader .
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.getConversationReader = function(transportIds) {};

/**
 * Retrieves a message specified by an identifier from the message store.
 * @param {string} localChatMessageId The local ID of the chat message to be retrieved.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Chat.ChatMessage, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Chat.ChatMessage>>} An asynchronous operation that returns a chat message upon successful completion.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.getMessageAsync = function(localChatMessageId) {};

/**
 * Gets a message by its remote ID.
 * @param {string} transportId The TransportId to use to get the ChatMessage .
 * @param {string} remoteId The RemoteId of the ChatMessage to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Chat.ChatMessage, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Chat.ChatMessage>>} The message.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.getMessageByRemoteIdAsync = function(transportId, remoteId) {};

/**
 * Gets a ChatMessageReader class object which provides a message collection from the message store.
 * Gets a ChatMessageReader class object which provides a message collection from the message store. The collection of messages is limited to the time span provided.
 * @param {number=} recentTimeLimit The time window for the retrieved reader.
 * @return {!Windows.ApplicationModel.Chat.ChatMessageReader} The chat message reader.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.getMessageReader = function(recentTimeLimit) {};

/**
 * Gets a new or existing ChatSearchReader to be used to search for messages.
 * @param {!Windows.ApplicationModel.Chat.ChatQueryOptions} value The query options that the search reader will use when looking for matching messages.
 * @return {!Windows.ApplicationModel.Chat.ChatSearchReader} The new or existing search reader.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.getSearchReader = function(value) {};

/**
 * Asynchronously gets the number of unread chat messages using the specified transports.
 * Asynchronously gets the number of unread chat messages.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} transportIds The IDs of the chat transports to use to get the unseen messages count.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} The number of unread chat messages.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.getUnseenCountAsync = function(transportIds) {};

/**
 * Asynchronously marks all transport messages as seen.
 * Asynchronously marks all transport messages as seen.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} transportIds The IDs of the transports for which to mark all messages as seen.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has finished.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.markAsSeenAsync = function(transportIds) {};

/**
 * Marks a specified message in the store as already read.
 * @param {string} localChatMessageId The local ID of the message to be marked as read.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.markMessageReadAsync = function(localChatMessageId) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.removeEventListener = function(type, listener) {};

/**
 * Attempts a retry of sending a specified message from the message store.
 * @param {string} localChatMessageId The local ID of the message to be retried.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.retrySendMessageAsync = function(localChatMessageId) {};

/**
 * Asynchronously saves a message to the ChatMessageStore .
 * @param {!Windows.ApplicationModel.Chat.ChatMessage} chatMessage The message to save.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has finished.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.saveMessageAsync = function(chatMessage) {};

/**
 * Attempts to send a chat message. The message is saved to the message store as part of the send operation.
 * @param {!Windows.ApplicationModel.Chat.ChatMessage} chatMessage The chat message to be sent.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.sendMessageAsync = function(chatMessage) {};

/**
 * Asynchronously attempts to cancel downloading the specified message.
 * @param {string} localChatMessageId The ID of the message to stop downloading.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.tryCancelDownloadMessageAsync = function(localChatMessageId) {};

/**
 * Asynchronously attempts to cancel sending the specified message.
 * @param {string} localChatMessageId The ID of the message to stop sending.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.tryCancelSendMessageAsync = function(localChatMessageId) {};

/**
 * Checks if a chat message is valid and returns the validation result.
 * @param {!Windows.ApplicationModel.Chat.ChatMessage} chatMessage The chat message to validate.
 * @return {!Windows.ApplicationModel.Chat.ChatMessageValidationResult} The validation result.
 */
Windows.ApplicationModel.Chat.ChatMessageStore.prototype.validateMessage = function(chatMessage) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatMessageStoreChangedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatMessageStoreChangedEventArgs.prototype.id;
 /** @type {Windows.ApplicationModel.Chat.ChatStoreChangedEventKind} */
Windows.ApplicationModel.Chat.ChatMessageStoreChangedEventArgs.prototype.kind;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatMessageTransport = function() {};
 /** @type {!Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration} */
Windows.ApplicationModel.Chat.ChatMessageTransport.prototype.configuration;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessageTransport.prototype.isActive;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatMessageTransport.prototype.isAppSetAsNotificationProvider;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatMessageTransport.prototype.transportFriendlyName;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatMessageTransport.prototype.transportId;
 /** @type {Windows.ApplicationModel.Chat.ChatMessageTransportKind} */
Windows.ApplicationModel.Chat.ChatMessageTransport.prototype.transportKind;

/**
 * Sets the current application to handle messaging notifications.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Chat.ChatMessageTransport.prototype.requestSetAsNotificationProviderAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration = function() {};
 /** @type {!Windows.Foundation.Collections.IMapView<string, ?>} */
Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration.prototype.extendedProperties;
 /** @type {number} */
Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration.prototype.maxAttachmentCount;
 /** @type {number} */
Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration.prototype.maxMessageSizeInKilobytes;
 /** @type {number} */
Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration.prototype.maxRecipientCount;
 /** @type {!Windows.Media.MediaProperties.MediaEncodingProfile} */
Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration.prototype.supportedVideoFormat;

/** @const */
Windows.ApplicationModel.Chat.ChatMessageTransportKind = {};
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageTransportKind.text;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageTransportKind.untriaged;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageTransportKind.blocked;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageTransportKind.custom;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatMessageValidationResult = function() {};
 /** @type {number} */
Windows.ApplicationModel.Chat.ChatMessageValidationResult.prototype.maxPartCount;
 /** @type {number} */
Windows.ApplicationModel.Chat.ChatMessageValidationResult.prototype.partCount;
 /** @type {number} */
Windows.ApplicationModel.Chat.ChatMessageValidationResult.prototype.remainingCharacterCountInPart;
 /** @type {Windows.ApplicationModel.Chat.ChatMessageValidationStatus} */
Windows.ApplicationModel.Chat.ChatMessageValidationResult.prototype.status;

/** @const */
Windows.ApplicationModel.Chat.ChatMessageValidationStatus = {};
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageValidationStatus.valid;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageValidationStatus.noRecipients;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageValidationStatus.invalidData;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageValidationStatus.messageTooLarge;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageValidationStatus.tooManyRecipients;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageValidationStatus.transportInactive;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageValidationStatus.transportNotFound;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageValidationStatus.tooManyAttachments;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageValidationStatus.invalidRecipients;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageValidationStatus.invalidBody;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatMessageValidationStatus.invalidOther;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the ChatQueryOptions class.
 */
Windows.ApplicationModel.Chat.ChatQueryOptions = function() {};
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatQueryOptions.prototype.searchString;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the ChatRecipientDeliveryInfo class.
 */
Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo = function() {};
 /** @type {!Date} */
Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo.prototype.deliveryTime;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo.prototype.isErrorPermanent;
 /** @type {!Date} */
Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo.prototype.readTime;
 /** @type {Windows.ApplicationModel.Chat.ChatMessageStatus} */
Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo.prototype.status;
 /** @type {string} */
Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo.prototype.transportAddress;
 /** @type {number} */
Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo.prototype.transportErrorCode;
 /** @type {Windows.ApplicationModel.Chat.ChatTransportErrorCodeCategory} */
Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo.prototype.transportErrorCodeCategory;
 /** @type {Windows.ApplicationModel.Chat.ChatTransportInterpretedErrorCode} */
Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo.prototype.transportInterpretedErrorCode;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.ChatSearchReader = function() {};

/**
 * Returns a batch of found items matching the search criteria.
 * Returns a batch of found items matching the search criteria.
 * @param {number=} count The maximum number of items to return.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A list of items matching the search criteria.
 */
Windows.ApplicationModel.Chat.ChatSearchReader.prototype.readBatchAsync = function(count) {};

/** @const */
Windows.ApplicationModel.Chat.ChatStoreChangedEventKind = {};
/** @const {number} */
Windows.ApplicationModel.Chat.ChatStoreChangedEventKind.notificationsMissed;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatStoreChangedEventKind.storeModified;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatStoreChangedEventKind.messageCreated;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatStoreChangedEventKind.messageModified;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatStoreChangedEventKind.messageDeleted;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatStoreChangedEventKind.conversationModified;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatStoreChangedEventKind.conversationDeleted;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatStoreChangedEventKind.conversationTransportDeleted;

/** @const */
Windows.ApplicationModel.Chat.ChatTransportErrorCodeCategory = {};
/** @const {number} */
Windows.ApplicationModel.Chat.ChatTransportErrorCodeCategory.none;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatTransportErrorCodeCategory.http;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatTransportErrorCodeCategory.network;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatTransportErrorCodeCategory.mmsServer;

/** @const */
Windows.ApplicationModel.Chat.ChatTransportInterpretedErrorCode = {};
/** @const {number} */
Windows.ApplicationModel.Chat.ChatTransportInterpretedErrorCode.none;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatTransportInterpretedErrorCode.unknown;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatTransportInterpretedErrorCode.invalidRecipientAddress;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatTransportInterpretedErrorCode.networkConnectivity;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatTransportInterpretedErrorCode.serviceDenied;
/** @const {number} */
Windows.ApplicationModel.Chat.ChatTransportInterpretedErrorCode.timeout;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.RcsEndUserMessage = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Chat.RcsEndUserMessageAction>} */
Windows.ApplicationModel.Chat.RcsEndUserMessage.prototype.actions;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.RcsEndUserMessage.prototype.isPinRequired;
 /** @type {string} */
Windows.ApplicationModel.Chat.RcsEndUserMessage.prototype.text;
 /** @type {string} */
Windows.ApplicationModel.Chat.RcsEndUserMessage.prototype.title;
 /** @type {string} */
Windows.ApplicationModel.Chat.RcsEndUserMessage.prototype.transportId;

/**
 * Asynchronously sends the user's selection back.
 * @param {!Windows.ApplicationModel.Chat.RcsEndUserMessageAction} action Specifies the label of the action.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Chat.RcsEndUserMessage.prototype.sendResponseAsync = function(action) {};

/**
 * Asynchronously sends the user's selection back with the specified PIN.
 * @param {!Windows.ApplicationModel.Chat.RcsEndUserMessageAction} action Specifies the label of the action.
 * @param {string} pin The PIN to send.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Chat.RcsEndUserMessage.prototype.sendResponseWithPinAsync = function(action, pin) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.RcsEndUserMessageAction = function() {};
 /** @type {string} */
Windows.ApplicationModel.Chat.RcsEndUserMessageAction.prototype.label;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableEventArgs = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableEventArgs.prototype.isMessageAvailable;
 /** @type {!Windows.ApplicationModel.Chat.RcsEndUserMessage} */
Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableEventArgs.prototype.message;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableTriggerDetails = function() {};
 /** @type {string} */
Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableTriggerDetails.prototype.text;
 /** @type {string} */
Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableTriggerDetails.prototype.title;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.RcsEndUserMessageManager = function() {};
 /** @type {function(?): void} */
Windows.ApplicationModel.Chat.RcsEndUserMessageManager.prototype.onmessageavailablechanged;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Chat.RcsEndUserMessageManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Chat.RcsEndUserMessageManager.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.RcsManager = function() {};

/**
 * Gets the RcsEndUserMessageManager .
 * @return {!Windows.ApplicationModel.Chat.RcsEndUserMessageManager} The end user message manager.
 */
Windows.ApplicationModel.Chat.RcsManager.getEndUserMessageManager = function() {};

/**
 * Gets an instance of RcsTransport for the specified transport ID.
 * @param {string} transportId The ID of the transport to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Chat.RcsTransport, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Chat.RcsTransport>>} An instance of the transport specified by the transportId parameter.
 */
Windows.ApplicationModel.Chat.RcsManager.getTransportAsync = function(transportId) {};

/**
 * Gets all instances of RcsTransport .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A list of RcsTransport instances.
 */
Windows.ApplicationModel.Chat.RcsManager.getTransportsAsync = function() {};

/**
 * Asynchronously allows a user to leave a particular conversation.
 * @param {!Windows.ApplicationModel.Chat.ChatConversation} conversation The conversation to leave.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Chat.RcsManager.leaveConversationAsync = function(conversation) {};

/** @const */
Windows.ApplicationModel.Chat.RcsServiceKind = {};
/** @const {number} */
Windows.ApplicationModel.Chat.RcsServiceKind.chat;
/** @const {number} */
Windows.ApplicationModel.Chat.RcsServiceKind.groupChat;
/** @const {number} */
Windows.ApplicationModel.Chat.RcsServiceKind.fileTransfer;
/** @const {number} */
Windows.ApplicationModel.Chat.RcsServiceKind.capability;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.RcsServiceKindSupportedChangedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.Chat.RcsServiceKind} */
Windows.ApplicationModel.Chat.RcsServiceKindSupportedChangedEventArgs.prototype.serviceKind;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.RcsTransport = function() {};
 /** @type {!Windows.ApplicationModel.Chat.RcsTransportConfiguration} */
Windows.ApplicationModel.Chat.RcsTransport.prototype.configuration;
 /** @type {!Windows.Foundation.Collections.IMapView<string, ?>} */
Windows.ApplicationModel.Chat.RcsTransport.prototype.extendedProperties;
 /** @type {boolean} */
Windows.ApplicationModel.Chat.RcsTransport.prototype.isActive;
 /** @type {function(?): void} */
Windows.ApplicationModel.Chat.RcsTransport.prototype.onservicekindsupportedchanged;
 /** @type {string} */
Windows.ApplicationModel.Chat.RcsTransport.prototype.transportFriendlyName;
 /** @type {string} */
Windows.ApplicationModel.Chat.RcsTransport.prototype.transportId;

/**
 * Gets a Boolean value indicating if the specified service kind is supported, such as chat, group chat, file transfer, and so on.
 * @param {Windows.ApplicationModel.Chat.RcsServiceKind} serviceKind The service kind to verify.
 * @return {boolean} TRUE if the RcsServiceKind specified in the serviceKind parameter is supported.
 */
Windows.ApplicationModel.Chat.RcsTransport.prototype.isServiceKindSupported = function(serviceKind) {};

/**
 * Gets a Boolean value indicating if the specified service kind supports store and forward functionality.
 * @param {Windows.ApplicationModel.Chat.RcsServiceKind} serviceKind The service kind to check for store and forward functionality.
 * @return {boolean} A Boolean value indicating if the serviceKind supports store and forward.
 */
Windows.ApplicationModel.Chat.RcsTransport.prototype.isStoreAndForwardEnabled = function(serviceKind) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Chat.RcsTransport.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Chat.RcsTransport.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.RcsTransportConfiguration = function() {};
 /** @type {number} */
Windows.ApplicationModel.Chat.RcsTransportConfiguration.prototype.maxAttachmentCount;
 /** @type {number} */
Windows.ApplicationModel.Chat.RcsTransportConfiguration.prototype.maxFileSizeInKilobytes;
 /** @type {number} */
Windows.ApplicationModel.Chat.RcsTransportConfiguration.prototype.maxGroupMessageSizeInKilobytes;
 /** @type {number} */
Windows.ApplicationModel.Chat.RcsTransportConfiguration.prototype.maxMessageSizeInKilobytes;
 /** @type {number} */
Windows.ApplicationModel.Chat.RcsTransportConfiguration.prototype.maxRecipientCount;
 /** @type {number} */
Windows.ApplicationModel.Chat.RcsTransportConfiguration.prototype.warningFileSizeInKilobytes;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Chat.RemoteParticipantComposingChangedEventArgs = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Chat.RemoteParticipantComposingChangedEventArgs.prototype.isComposing;
 /** @type {string} */
Windows.ApplicationModel.Chat.RemoteParticipantComposingChangedEventArgs.prototype.participantAddress;
 /** @type {string} */
Windows.ApplicationModel.Chat.RemoteParticipantComposingChangedEventArgs.prototype.transportId;
/** @const */
Windows.ApplicationModel.Contacts = {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.AggregateContactManager = function() {};

/**
 * Returns the list of individual (raw) contacts from the specified aggregate contact.
 * @param {!Windows.ApplicationModel.Contacts.Contact} contact The aggregate contact from which to extract the list of raw contacts.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The list of individual (raw) contacts from the specified aggregate contact.
 */
Windows.ApplicationModel.Contacts.AggregateContactManager.prototype.findRawContactsAsync = function(contact) {};

/**
 * Asynchronously attempts to link contacts together to make an aggregate contact.
 * @param {!Windows.ApplicationModel.Contacts.Contact} primaryContact The first contact to link.
 * @param {!Windows.ApplicationModel.Contacts.Contact} secondaryContact The second contact to link to the primaryContact.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.Contact, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.Contact>>} The newly created aggregate contact.
 */
Windows.ApplicationModel.Contacts.AggregateContactManager.prototype.tryLinkContactsAsync = function(primaryContact, secondaryContact) {};

/**
 * Chooses which of the raw contacts provides the main display picture for the aggregate.
 * @param {!Windows.ApplicationModel.Contacts.Contact} aggregateContact The aggregate contact on which to set the picture.
 * @param {!Windows.ApplicationModel.Contacts.Contact} rawContact The raw contact that provides the picture for the aggregate.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} True if successful, otherwise false.
 */
Windows.ApplicationModel.Contacts.AggregateContactManager.prototype.trySetPreferredSourceForPictureAsync = function(aggregateContact, rawContact) {};

/**
 * Asynchronously unlinks a raw contact from the parent aggregate contact.
 * @param {!Windows.ApplicationModel.Contacts.Contact} contact The raw contact to remove from the aggregate.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action that indicates the operation is complete.
 */
Windows.ApplicationModel.Contacts.AggregateContactManager.prototype.unlinkRawContactAsync = function(contact) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the Contact class.
 */
Windows.ApplicationModel.Contacts.Contact = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Contacts.ContactAddress>} */
Windows.ApplicationModel.Contacts.Contact.prototype.addresses;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.aggregateId;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Contacts.ContactConnectedServiceAccount>} */
Windows.ApplicationModel.Contacts.Contact.prototype.connectedServiceAccounts;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.contactListId;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.Contacts.Contact.prototype.dataSuppliers;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.displayName;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.displayNameOverride;
 /** @type {!Date} */
Windows.ApplicationModel.Contacts.Contact.prototype.displayPictureUserUpdateTime;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Contacts.ContactEmail>} */
Windows.ApplicationModel.Contacts.Contact.prototype.emails;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Contacts.IContactField>} */
Windows.ApplicationModel.Contacts.Contact.prototype.fields;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.firstName;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.fullName;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.honorificNamePrefix;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.honorificNameSuffix;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.id;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Contacts.ContactDate>} */
Windows.ApplicationModel.Contacts.Contact.prototype.importantDates;
 /** @type {boolean} */
Windows.ApplicationModel.Contacts.Contact.prototype.isAggregate;
 /** @type {boolean} */
Windows.ApplicationModel.Contacts.Contact.prototype.isDisplayPictureManuallySet;
 /** @type {boolean} */
Windows.ApplicationModel.Contacts.Contact.prototype.isMe;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Contacts.ContactJobInfo>} */
Windows.ApplicationModel.Contacts.Contact.prototype.jobInfo;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Contacts.Contact.prototype.largeDisplayPicture;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.lastName;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.middleName;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.name;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.nickname;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.notes;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Contacts.ContactPhone>} */
Windows.ApplicationModel.Contacts.Contact.prototype.phones;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.ApplicationModel.Contacts.Contact.prototype.providerProperties;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.remoteId;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.ringToneToken;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Contacts.ContactSignificantOther>} */
Windows.ApplicationModel.Contacts.Contact.prototype.significantOthers;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Contacts.Contact.prototype.smallDisplayPicture;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.sortName;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Contacts.Contact.prototype.sourceDisplayPicture;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.textToneToken;
 /** @type {?} */
Windows.ApplicationModel.Contacts.Contact.prototype.thumbnail;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Contacts.ContactWebsite>} */
Windows.ApplicationModel.Contacts.Contact.prototype.websites;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.yomiDisplayName;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.yomiFamilyName;
 /** @type {string} */
Windows.ApplicationModel.Contacts.Contact.prototype.yomiGivenName;

/**
 * @constructor
 * @struct
 * Initializes a new instance of a ContactAddress class.
 */
Windows.ApplicationModel.Contacts.ContactAddress = function() {};
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactAddress.prototype.country;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactAddress.prototype.description;
 /** @type {Windows.ApplicationModel.Contacts.ContactAddressKind} */
Windows.ApplicationModel.Contacts.ContactAddress.prototype.kind;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactAddress.prototype.locality;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactAddress.prototype.postalCode;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactAddress.prototype.region;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactAddress.prototype.streetAddress;

/** @const */
Windows.ApplicationModel.Contacts.ContactAddressKind = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactAddressKind.home;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactAddressKind.work;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactAddressKind.other;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the ContactAnnotation class.
 */
Windows.ApplicationModel.Contacts.ContactAnnotation = function() {};
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactAnnotation.prototype.annotationListId;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactAnnotation.prototype.contactId;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactAnnotation.prototype.id;
 /** @type {boolean} */
Windows.ApplicationModel.Contacts.ContactAnnotation.prototype.isDisabled;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.ApplicationModel.Contacts.ContactAnnotation.prototype.providerProperties;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactAnnotation.prototype.remoteId;
 /** @type {Windows.ApplicationModel.Contacts.ContactAnnotationOperations} */
Windows.ApplicationModel.Contacts.ContactAnnotation.prototype.supportedOperations;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactAnnotationList = function() {};
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactAnnotationList.prototype.id;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactAnnotationList.prototype.providerPackageFamilyName;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactAnnotationList.prototype.userDataAccountId;

/**
 * Asynchronously deletes the specified ContactAnnotation from the list.
 * @param {!Windows.ApplicationModel.Contacts.ContactAnnotation} annotation The annotation to delete from the list.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Contacts.ContactAnnotationList.prototype.deleteAnnotationAsync = function(annotation) {};

/**
 * Asynchronously deletes this ContactAnnotationList from the ContactAnnotationStore .
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Contacts.ContactAnnotationList.prototype.deleteAsync = function() {};

/**
 * Asynchronously gets the list of ContactAnnotation objects.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The list of ContactAnnotation objects.
 */
Windows.ApplicationModel.Contacts.ContactAnnotationList.prototype.findAnnotationsAsync = function() {};

/**
 * Gets the list of ContactAnnotation objects containing the specified remote ID property.
 * @param {string} remoteId The remote ID used to find the ContactAnnotation objects.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The list of ContactAnnotation objects containing the specified remote ID property.
 */
Windows.ApplicationModel.Contacts.ContactAnnotationList.prototype.findAnnotationsByRemoteIdAsync = function(remoteId) {};

/**
 * Gets the ContactAnnotation with the specified Id .
 * @param {string} annotationId The ContactAnnotation.Id used to identify the ContactAnnotation .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.ContactAnnotation, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.ContactAnnotation>>} The ContactAnnotation with the specified ID.
 */
Windows.ApplicationModel.Contacts.ContactAnnotationList.prototype.getAnnotationAsync = function(annotationId) {};

/**
 * Asynchronously attempts to save the ContactAnnotation to the ContactAnnotationList .
 * @param {!Windows.ApplicationModel.Contacts.ContactAnnotation} annotation The annotation to save to the list.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} True if the save was successful, otherwise false.
 */
Windows.ApplicationModel.Contacts.ContactAnnotationList.prototype.trySaveAnnotationAsync = function(annotation) {};

/** @const */
Windows.ApplicationModel.Contacts.ContactAnnotationOperations = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactAnnotationOperations.none;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactAnnotationOperations.contactProfile;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactAnnotationOperations.message;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactAnnotationOperations.audioCall;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactAnnotationOperations.videoCall;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactAnnotationOperations.socialFeeds;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactAnnotationStore = function() {};

/**
 * Asynchronously creates a ContactAnnotationList and associates it with the specified user data account ID.
 * Asynchronously creates a ContactAnnotationList .
 * @param {string=} userDataAccountId The ID for the user data account with which to associate the new ContactAnnotationList . The user data account must be owned by this app.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.ContactAnnotationList, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.ContactAnnotationList>>} The newly created ContactAnnotationList .
 */
Windows.ApplicationModel.Contacts.ContactAnnotationStore.prototype.createAnnotationListAsync = function(userDataAccountId) {};

/**
 * Asynchronously disables the specified ContactAnnotation , usually as a result of user input.
 * @param {!Windows.ApplicationModel.Contacts.ContactAnnotation} annotation The annotation to disable.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Contacts.ContactAnnotationStore.prototype.disableAnnotationAsync = function(annotation) {};

/**
 * Asynchronously gets the list of ContactAnnotationList objects for the app.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The list of ContactAnnotationList objects.
 */
Windows.ApplicationModel.Contacts.ContactAnnotationStore.prototype.findAnnotationListsAsync = function() {};

/**
 * Get the annotations for the specified Contact .
 * @param {!Windows.ApplicationModel.Contacts.Contact} contact The Contact for which to retrieve annotations.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The list of ContactAnnotation objects.
 */
Windows.ApplicationModel.Contacts.ContactAnnotationStore.prototype.findAnnotationsForContactAsync = function(contact) {};

/**
 * Gets a list of Id values based on Contact objects with a specified email address.
 * @param {string} emailAddress The email address used to find the contact Id values.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The list of Contact objects containing the specified emailAddress.
 */
Windows.ApplicationModel.Contacts.ContactAnnotationStore.prototype.findContactIdsByEmailAsync = function(emailAddress) {};

/**
 * Gets a list of Id values based on Contact objects with a specified phone number.
 * @param {string} phoneNumber The phone number used to find the contact Id values.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The list of Contact objects containing the specified phoneNumber.
 */
Windows.ApplicationModel.Contacts.ContactAnnotationStore.prototype.findContactIdsByPhoneNumberAsync = function(phoneNumber) {};

/**
 * Asynchronously gets the ContactAnnotationList with the specified ID.
 * @param {string} annotationListId The ID of the ContactAnnotationList to get.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.ContactAnnotationList, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.ContactAnnotationList>>} The ContactAnnotationList with the ID specified in annotationListId.
 */
Windows.ApplicationModel.Contacts.ContactAnnotationStore.prototype.getAnnotationListAsync = function(annotationListId) {};

/** @const */
Windows.ApplicationModel.Contacts.ContactAnnotationStoreAccessType = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactAnnotationStoreAccessType.appAnnotationsReadWrite;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactAnnotationStoreAccessType.allAnnotationsReadWrite;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactBatch = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Contacts.Contact>} */
Windows.ApplicationModel.Contacts.ContactBatch.prototype.contacts;
 /** @type {Windows.ApplicationModel.Contacts.ContactBatchStatus} */
Windows.ApplicationModel.Contacts.ContactBatch.prototype.status;

/** @const */
Windows.ApplicationModel.Contacts.ContactBatchStatus = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactBatchStatus.success;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactBatchStatus.serverSearchSyncManagerError;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactBatchStatus.serverSearchUnknownError;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactCardDelayedDataLoader = function() {};

/**
 * Closes the delayed data loader. This informs the contact card to complete the UI (for example, remove any progress indications, like the progress bar) because no more updates to the contact card UI will be requested. The user then can determine that the contact data shown in the UI is complete.
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactCardDelayedDataLoader.prototype.close = function() {};

/**
 * Updates the contact card with the Contact object and completes the contact card UI.
 * @param {!Windows.ApplicationModel.Contacts.Contact} contact The contact to update the contact card with.
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactCardDelayedDataLoader.prototype.setData = function(contact) {};

/** @const */
Windows.ApplicationModel.Contacts.ContactCardHeaderKind = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactCardHeaderKind.default;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactCardHeaderKind.basic;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactCardHeaderKind.enterprise;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the ContactCardOptions class.
 */
Windows.ApplicationModel.Contacts.ContactCardOptions = function() {};
 /** @type {Windows.ApplicationModel.Contacts.ContactCardHeaderKind} */
Windows.ApplicationModel.Contacts.ContactCardOptions.prototype.headerKind;
 /** @type {Windows.ApplicationModel.Contacts.ContactCardTabKind} */
Windows.ApplicationModel.Contacts.ContactCardOptions.prototype.initialTabKind;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.Contacts.ContactCardOptions.prototype.serverSearchContactListIds;

/** @const */
Windows.ApplicationModel.Contacts.ContactCardTabKind = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactCardTabKind.default;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactCardTabKind.email;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactCardTabKind.messaging;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactCardTabKind.phone;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactCardTabKind.video;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactChange = function() {};
 /** @type {Windows.ApplicationModel.Contacts.ContactChangeType} */
Windows.ApplicationModel.Contacts.ContactChange.prototype.changeType;
 /** @type {!Windows.ApplicationModel.Contacts.Contact} */
Windows.ApplicationModel.Contacts.ContactChange.prototype.contact;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactChangeReader = function() {};

/**
 * Call this method to indicate that you have processed and accepted all changes and you don't want the system to show them to you again.
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactChangeReader.prototype.acceptChanges = function() {};

/**
 * Call this method to indicate that you have processed and accepted up through the specified change.
 * @param {!Windows.ApplicationModel.Contacts.ContactChange} lastChangeToAccept The last change that you want to system to track as accepted by your app.
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactChangeReader.prototype.acceptChangesThrough = function(lastChangeToAccept) {};

/**
 * Asynchronously gets a list of ContactChange objects.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A list of ContactChange objects.
 */
Windows.ApplicationModel.Contacts.ContactChangeReader.prototype.readBatchAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactChangeTracker = function() {};

/**
 * Call this method to enable change tracking.
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactChangeTracker.prototype.enable = function() {};

/**
 * Gets a ContactChangeReader that can be used to process changes.
 * @return {!Windows.ApplicationModel.Contacts.ContactChangeReader} A ContactChangeReader that can be used to process changes.
 */
Windows.ApplicationModel.Contacts.ContactChangeTracker.prototype.getChangeReader = function() {};

/**
 * Call this method to reset the change tracker if your app receives ContactChangeType.ChangeTrackingLost .
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactChangeTracker.prototype.reset = function() {};

/** @const */
Windows.ApplicationModel.Contacts.ContactChangeType = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactChangeType.created;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactChangeType.modified;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactChangeType.deleted;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactChangeType.changeTrackingLost;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactChangedDeferral = function() {};

/**
 * Call this method in order to release the deferral object when all asynchronous processing has finished.
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactChangedDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactChangedEventArgs = function() {};

/**
 * Gets the ContactChangedDeferral object to use for asynchronous operations.
 * @return {!Windows.ApplicationModel.Contacts.ContactChangedDeferral} The deferral object to use for asynchronous operations.
 */
Windows.ApplicationModel.Contacts.ContactChangedEventArgs.prototype.getDeferral = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of a ContactConnectedServiceAccount class.
 */
Windows.ApplicationModel.Contacts.ContactConnectedServiceAccount = function() {};
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactConnectedServiceAccount.prototype.id;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactConnectedServiceAccount.prototype.serviceName;

/**
 * @constructor
 * @struct
 * Initializes a new instance of a ContactDate class.
 */
Windows.ApplicationModel.Contacts.ContactDate = function() {};
 /** @type {number} */
Windows.ApplicationModel.Contacts.ContactDate.prototype.day;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactDate.prototype.description;
 /** @type {Windows.ApplicationModel.Contacts.ContactDateKind} */
Windows.ApplicationModel.Contacts.ContactDate.prototype.kind;
 /** @type {number} */
Windows.ApplicationModel.Contacts.ContactDate.prototype.month;
 /** @type {number} */
Windows.ApplicationModel.Contacts.ContactDate.prototype.year;

/** @const */
Windows.ApplicationModel.Contacts.ContactDateKind = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactDateKind.birthday;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactDateKind.anniversary;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactDateKind.other;

/**
 * @constructor
 * @struct
 * Initializes a new instance of a ContactEmail class.
 */
Windows.ApplicationModel.Contacts.ContactEmail = function() {};
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactEmail.prototype.address;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactEmail.prototype.description;
 /** @type {Windows.ApplicationModel.Contacts.ContactEmailKind} */
Windows.ApplicationModel.Contacts.ContactEmail.prototype.kind;

/** @const */
Windows.ApplicationModel.Contacts.ContactEmailKind = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactEmailKind.personal;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactEmailKind.work;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactEmailKind.other;

/**
 * @constructor
 * @struct
 * Creates a new ContactField object.
 * Creates a new ContactField object.
 * Creates a new ContactField object.
 * @param {string} name_or_value The name of the field. / The value for the contact field. / The value that the field contains.
 * @param {string|Windows.ApplicationModel.Contacts.ContactFieldType} value_or_type The value the field contains. / The type of contact data.
 * @param {Windows.ApplicationModel.Contacts.ContactFieldType|Windows.ApplicationModel.Contacts.ContactFieldCategory=} type_or_category The type of field. / The category that the contact belongs to.
 * @param {Windows.ApplicationModel.Contacts.ContactFieldCategory=} category The category the field belongs to.
 */
Windows.ApplicationModel.Contacts.ContactField = function(name_or_value, value_or_type, type_or_category, category) {};
 /** @type {Windows.ApplicationModel.Contacts.ContactFieldCategory} */
Windows.ApplicationModel.Contacts.ContactField.prototype.category;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactField.prototype.name;
 /** @type {Windows.ApplicationModel.Contacts.ContactFieldType} */
Windows.ApplicationModel.Contacts.ContactField.prototype.type;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactField.prototype.value;

/** @const */
Windows.ApplicationModel.Contacts.ContactFieldCategory = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldCategory.none;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldCategory.home;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldCategory.work;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldCategory.mobile;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldCategory.other;

/**
 * @constructor
 * @struct
 * Creates an instance of the ContactFieldFactory class.
 */
Windows.ApplicationModel.Contacts.ContactFieldFactory = function() {};

/**
 * Creates a field to contain information about a contact.
 * Creates a field to contain information about a contact.
 * Creates a field to contain information about a contact.
 * @param {string} value_or_name The value for the field. / The name of the field.
 * @param {Windows.ApplicationModel.Contacts.ContactFieldType|string} type_or_value The type of field. / The value of the field.
 * @param {Windows.ApplicationModel.Contacts.ContactFieldCategory|Windows.ApplicationModel.Contacts.ContactFieldType=} category_or_type The category the field belongs to. / The type of field.
 * @param {Windows.ApplicationModel.Contacts.ContactFieldCategory=} category The category the field belongs to.
 * @return {!Windows.ApplicationModel.Contacts.ContactField} Contains a field that you can add to a Contact object.
 */
Windows.ApplicationModel.Contacts.ContactFieldFactory.prototype.createField = function(value_or_name, type_or_value, category_or_type, category) {};

/**
 * Creates a field to contain information about a contact's instant messaging account.
 * Creates a field to contain information about a contact's instant messaging account.
 * Creates a field to contain information about a contact's instant messaging account.
 * @param {string} userName The user name for the instant messaging account. / The user name of the instant messaging account.
 * @param {Windows.ApplicationModel.Contacts.ContactFieldCategory=} category The category the field belongs to.
 * @param {string=} service The name of the instant messaging service.
 * @param {string=} displayText The text to display to prompt an instant messaging conversation.
 * @param {!Windows.Foundation.Uri=} verb The URI that starts an instant messaging conversation.
 * @return {!Windows.ApplicationModel.Contacts.ContactInstantMessageField} Contains an instant messaging field that you can add to a Contact object.
 */
Windows.ApplicationModel.Contacts.ContactFieldFactory.prototype.createInstantMessage = function(userName, category, service, displayText, verb) {};

/**
 * Creates a field to contain information about a contact's location.
 * Creates a field to contain information about a contact's location.
 * Creates a field to contain information about a contact's location.
 * @param {string} unstructuredAddress The address of the contact in an unstructured format.
 * @param {Windows.ApplicationModel.Contacts.ContactFieldCategory=} category The category the field belongs to.
 * @param {string=} street The street address for the address.
 * @param {string=} city The name of the city for the address.
 * @param {string=} region The name of the region for the address.
 * @param {string=} country The name of the country for the address.
 * @param {string=} postalCode The postal code for the address.
 * @return {!Windows.ApplicationModel.Contacts.ContactLocationField} Contains a location field that you can add to a Contact object.
 */
Windows.ApplicationModel.Contacts.ContactFieldFactory.prototype.createLocation = function(unstructuredAddress, category, street, city, region, country, postalCode) {};

/** @const */
Windows.ApplicationModel.Contacts.ContactFieldType = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldType.email;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldType.phoneNumber;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldType.location;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldType.instantMessage;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldType.custom;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldType.connectedServiceAccount;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldType.importantDate;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldType.address;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldType.significantOther;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldType.notes;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldType.website;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactFieldType.jobInfo;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactInformation = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Contacts.ContactField>} */
Windows.ApplicationModel.Contacts.ContactInformation.prototype.customFields;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Contacts.ContactField>} */
Windows.ApplicationModel.Contacts.ContactInformation.prototype.emails;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Contacts.ContactInstantMessageField>} */
Windows.ApplicationModel.Contacts.ContactInformation.prototype.instantMessages;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Contacts.ContactLocationField>} */
Windows.ApplicationModel.Contacts.ContactInformation.prototype.locations;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactInformation.prototype.name;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Contacts.ContactField>} */
Windows.ApplicationModel.Contacts.ContactInformation.prototype.phoneNumbers;

/**
 * Gets the thumbnail image for the contact.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType>>} An object that provides access to the thumbnail image.
 */
Windows.ApplicationModel.Contacts.ContactInformation.prototype.getThumbnailAsync = function() {};

/**
 * Enables you to get the value for a custom field that is stored with a contact.
 * @param {string} customName The name of the field.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Contacts.ContactField>} The value of the field.
 */
Windows.ApplicationModel.Contacts.ContactInformation.prototype.queryCustomFields = function(customName) {};

/**
 * @constructor
 * @struct
 * Creates a new ContactInstantMessageField object.
 * Creates a new ContactInstantMessageField object.
 * Creates a new ContactInstantMessageField object.
 * @param {string} userName The user's name.
 * @param {Windows.ApplicationModel.Contacts.ContactFieldCategory=} category The category of contact data. / The category of the contact data.
 * @param {string=} service The name of the instant messaging service.
 * @param {string=} displayText The display text used with the instant messaging URI.
 * @param {!Windows.Foundation.Uri=} verb The URI that starts an instant message.
 */
Windows.ApplicationModel.Contacts.ContactInstantMessageField = function(userName, category, service, displayText, verb) {};
 /** @type {Windows.ApplicationModel.Contacts.ContactFieldCategory} */
Windows.ApplicationModel.Contacts.ContactInstantMessageField.prototype.category;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactInstantMessageField.prototype.displayText;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.Contacts.ContactInstantMessageField.prototype.launchUri;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactInstantMessageField.prototype.name;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactInstantMessageField.prototype.service;
 /** @type {Windows.ApplicationModel.Contacts.ContactFieldType} */
Windows.ApplicationModel.Contacts.ContactInstantMessageField.prototype.type;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactInstantMessageField.prototype.userName;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactInstantMessageField.prototype.value;

/**
 * @constructor
 * @struct
 * Initializes a new instance of a ContactJobInfo class.
 */
Windows.ApplicationModel.Contacts.ContactJobInfo = function() {};
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactJobInfo.prototype.companyAddress;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactJobInfo.prototype.companyName;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactJobInfo.prototype.companyYomiName;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactJobInfo.prototype.department;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactJobInfo.prototype.description;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactJobInfo.prototype.manager;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactJobInfo.prototype.office;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactJobInfo.prototype.title;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactLaunchActionVerbs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactLaunchActionVerbs.call;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactLaunchActionVerbs.map;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactLaunchActionVerbs.message;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactLaunchActionVerbs.post;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactLaunchActionVerbs.videoCall;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactList = function() {};
 /** @type {!Windows.ApplicationModel.Contacts.ContactChangeTracker} */
Windows.ApplicationModel.Contacts.ContactList.prototype.changeTracker;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactList.prototype.displayName;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactList.prototype.id;
 /** @type {boolean} */
Windows.ApplicationModel.Contacts.ContactList.prototype.isHidden;
 /** @type {function(?): void} */
Windows.ApplicationModel.Contacts.ContactList.prototype.oncontactchanged;
 /** @type {Windows.ApplicationModel.Contacts.ContactListOtherAppReadAccess} */
Windows.ApplicationModel.Contacts.ContactList.prototype.otherAppReadAccess;
 /** @type {Windows.ApplicationModel.Contacts.ContactListOtherAppWriteAccess} */
Windows.ApplicationModel.Contacts.ContactList.prototype.otherAppWriteAccess;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactList.prototype.sourceDisplayName;
 /** @type {boolean} */
Windows.ApplicationModel.Contacts.ContactList.prototype.supportsServerSearch;
 /** @type {!Windows.ApplicationModel.Contacts.ContactListSyncManager} */
Windows.ApplicationModel.Contacts.ContactList.prototype.syncManager;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactList.prototype.userDataAccountId;

/**
 * Asynchronously deletes this ContactList , including all Contact objects in the ContactStore .
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the method is complete.
 */
Windows.ApplicationModel.Contacts.ContactList.prototype.deleteAsync = function() {};

/**
 * Asynchronously deletes and individual Contact from this ContactList and the ContactStore .
 * @param {!Windows.ApplicationModel.Contacts.Contact} contact The Contact to delete.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the method is complete.
 */
Windows.ApplicationModel.Contacts.ContactList.prototype.deleteContactAsync = function(contact) {};

/**
 * Asynchronously retrieves the specified Contact object from the ContactList .
 * @param {string} contactId The string that identifies the Contact to return.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.Contact, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.Contact>>} The Contact identified by the contactId parameter.
 */
Windows.ApplicationModel.Contacts.ContactList.prototype.getContactAsync = function(contactId) {};

/**
 * Asynchronously gets the Contact identified by the specified RemoteId .
 * @param {string} remoteId An ID that can be used by a service provider to access the Contact in their remote system.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.Contact, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.Contact>>} The Contact identified by the remoteId parameter.
 */
Windows.ApplicationModel.Contacts.ContactList.prototype.getContactFromRemoteIdAsync = function(remoteId) {};

/**
 * Gets a ContactReader object associated with this ContactList and using the specified ContactQueryOptions .
 * Gets a ContactReader object associated with this ContactList .
 * @param {!Windows.ApplicationModel.Contacts.ContactQueryOptions=} options The ContactQueryOptions to use when creating the ContactReader .
 * @return {!Windows.ApplicationModel.Contacts.ContactReader} A ContactReader object associated with this ContactList .
 */
Windows.ApplicationModel.Contacts.ContactList.prototype.getContactReader = function(options) {};

/**
 * Asynchronously gets the Contact object for the current user.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.Contact, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.Contact>>} The Contact object for the current user.
 */
Windows.ApplicationModel.Contacts.ContactList.prototype.getMeContactAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactList.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactList.prototype.removeEventListener = function(type, listener) {};

/**
 * Asynchronously saves this ContactList .
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the method has completed.
 */
Windows.ApplicationModel.Contacts.ContactList.prototype.saveAsync = function() {};

/**
 * Asynchronously saves the specified Contact to the ContactStore .
 * @param {!Windows.ApplicationModel.Contacts.Contact} contact The contact to save.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the method has completed.
 */
Windows.ApplicationModel.Contacts.ContactList.prototype.saveContactAsync = function(contact) {};

/** @const */
Windows.ApplicationModel.Contacts.ContactListOtherAppReadAccess = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactListOtherAppReadAccess.systemOnly;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactListOtherAppReadAccess.limited;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactListOtherAppReadAccess.full;

/** @const */
Windows.ApplicationModel.Contacts.ContactListOtherAppWriteAccess = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactListOtherAppWriteAccess.none;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactListOtherAppWriteAccess.systemOnly;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactListSyncManager = function() {};
 /** @type {!Date} */
Windows.ApplicationModel.Contacts.ContactListSyncManager.prototype.lastAttemptedSyncTime;
 /** @type {!Date} */
Windows.ApplicationModel.Contacts.ContactListSyncManager.prototype.lastSuccessfulSyncTime;
 /** @type {function(?): void} */
Windows.ApplicationModel.Contacts.ContactListSyncManager.prototype.onsyncstatuschanged;
 /** @type {Windows.ApplicationModel.Contacts.ContactListSyncStatus} */
Windows.ApplicationModel.Contacts.ContactListSyncManager.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactListSyncManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactListSyncManager.prototype.removeEventListener = function(type, listener) {};

/**
 * Asynchronously attempts to sync with the contacts server.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the sync was successful.
 */
Windows.ApplicationModel.Contacts.ContactListSyncManager.prototype.syncAsync = function() {};

/** @const */
Windows.ApplicationModel.Contacts.ContactListSyncStatus = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactListSyncStatus.idle;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactListSyncStatus.syncing;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactListSyncStatus.upToDate;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactListSyncStatus.authenticationError;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactListSyncStatus.policyError;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactListSyncStatus.unknownError;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactListSyncStatus.manualAccountRemovalRequired;

/**
 * @constructor
 * @struct
 * Creates a new ContactLocationField object.
 * Creates a new ContactLocationField object.
 * Creates a new ContactLocationField object.
 * @param {string} unstructuredAddress The address of the contact in an unstructured format.
 * @param {Windows.ApplicationModel.Contacts.ContactFieldCategory=} category The category the field belongs to. / The category for the contact data.
 * @param {string=} street The street address of the contact.
 * @param {string=} city The name of the city for this contact's address.
 * @param {string=} region The name of the region for this contact's address.
 * @param {string=} country The name of the country for this contact's address.
 * @param {string=} postalCode The postal code for this contact's address.
 */
Windows.ApplicationModel.Contacts.ContactLocationField = function(unstructuredAddress, category, street, city, region, country, postalCode) {};
 /** @type {Windows.ApplicationModel.Contacts.ContactFieldCategory} */
Windows.ApplicationModel.Contacts.ContactLocationField.prototype.category;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactLocationField.prototype.city;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactLocationField.prototype.country;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactLocationField.prototype.name;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactLocationField.prototype.postalCode;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactLocationField.prototype.region;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactLocationField.prototype.street;
 /** @type {Windows.ApplicationModel.Contacts.ContactFieldType} */
Windows.ApplicationModel.Contacts.ContactLocationField.prototype.type;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactLocationField.prototype.unstructuredAddress;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactLocationField.prototype.value;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactManager = function() {};
 /** @type {Windows.ApplicationModel.Contacts.ContactNameOrder} */
Windows.ApplicationModel.Contacts.ContactManager.systemDisplayNameOrder;
 /** @type {Windows.ApplicationModel.Contacts.ContactNameOrder} */
Windows.ApplicationModel.Contacts.ContactManager.systemSortOrder;

/**
 * Asynchronously converts a Contact to a vCard.
 * Asynchronously converts a Contact to a vCard.
 * @param {!Windows.ApplicationModel.Contacts.Contact} contact The Contact to convert.
 * @param {number=} maxBytes The maximum size for the vCard in bytes.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.RandomAccessStreamReference, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.RandomAccessStreamReference>>} A stream containing the vCard data.
 */
Windows.ApplicationModel.Contacts.ContactManager.convertContactToVCardAsync = function(contact, maxBytes) {};

/**
 * Asynchronously converts a vCard to a Contact .
 * @param {!Windows.Storage.Streams.IRandomAccessStreamReference} vCard A stream containing the vCard data.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.Contact, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.Contact>>} The converted Contact .
 */
Windows.ApplicationModel.Contacts.ContactManager.convertVCardToContactAsync = function(vCard) {};

/**
 * Gets a Boolean value indicating if the ShowContactCard method is supported on the current platform.
 * @return {boolean} A Boolean value indicating if the ShowContactCard method is supported on the current platform.
 */
Windows.ApplicationModel.Contacts.ContactManager.isShowContactCardSupported = function() {};

/**
 * Gets a Boolean value indicating if the ShowDelayLoadedContactCard method is supported on the current platform.
 * @return {boolean} A Boolean value indicating if the ShowDelayLoadedContactCard method is supported on the current platform.
 */
Windows.ApplicationModel.Contacts.ContactManager.isShowDelayLoadedContactCardSupported = function() {};

/**
 * Asynchronously requests access to the ContactAnnotationStore .
 * @param {Windows.ApplicationModel.Contacts.ContactAnnotationStoreAccessType} accessType Specifies the type of access request, app contact annotations or all annotations.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.ContactAnnotationStore, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.ContactAnnotationStore>>} The requested ContactAnnotationStore .
 */
Windows.ApplicationModel.Contacts.ContactManager.requestAnnotationStoreAsync = function(accessType) {};

/**
 * Retrieves a ContactStore object that enables searching or retrieving contacts on the device.
 * Retrieves a ContactStore object that enables searching or retrieving contacts on the device.
 * @param {Windows.ApplicationModel.Contacts.ContactStoreAccessType=} accessType Specifies the type of read/write access requested.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.ContactStore, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.ContactStore>>} An asynchronous operation that returns a ContactStore object on successful completion.
 */
Windows.ApplicationModel.Contacts.ContactManager.requestStoreAsync = function(accessType) {};

/**
 * Queries the operating system for a users contact and shows the contact data in a contact card.
 * Queries the operating system for a users contact and shows the contact data in a contact card.
 * Shows a contact card with the specified parameters.
 * @param {!Windows.ApplicationModel.Contacts.Contact} contact The object that represents the contact that the app wants to display the contact card for.
 * @param {!Windows.Foundation.Rect} selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the contact card, not within that rectangular area. For example, if an app uses a button to show the contact card, pass the Rect of the button so the contact card displays around the button, not overlapping it.
 * @param {Windows.UI.Popups.Placement=} preferredPlacement The Placement that describes the preferred placement of the contact card.
 * @param {!Windows.ApplicationModel.Contacts.ContactCardOptions=} contactCardOptions Specifies how to display the contact card, such as which tab to start on when displaying a mini contact card.
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactManager.showContactCard = function(contact, selection, preferredPlacement, contactCardOptions) {};

/**
 * Shows a contact card that can be updated later if the contact does not exist in the users contact database.
 * Shows a contact card that can be updated later if the contact does not exist in the users contact database.
 * @param {!Windows.ApplicationModel.Contacts.Contact} contact The object that represents the contact that the app wants to display the contact card for.
 * @param {!Windows.Foundation.Rect} selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the contact card, not within that rectangular area. For example, if an app uses a button to show the contact card, pass the Rect of the button so the contact card displays around the button, not overlapping it.
 * @param {Windows.UI.Popups.Placement} preferredPlacement The Placement that describes the preferred placement of the contact card.
 * @param {!Windows.ApplicationModel.Contacts.ContactCardOptions=} contactCardOptions Specifies how to display the contact card, such as which tab to start on if you are displaying a mini contact card, or what header type to use if you are showing a full contact card.
 * @return {!Windows.ApplicationModel.Contacts.ContactCardDelayedDataLoader} Returns the ContactCardDelayedDataLoader object that can be used to update the contact card.
 */
Windows.ApplicationModel.Contacts.ContactManager.showDelayLoadedContactCard = function(contact, selection, preferredPlacement, contactCardOptions) {};

/**
 * Queries the operating system for a users contact and shows the contact data in a full contact card.
 * @param {!Windows.ApplicationModel.Contacts.Contact} contact The object that represents the contact that the app wants to display the contact card for.
 * @param {!Windows.ApplicationModel.Contacts.FullContactCardOptions} fullContactCardOptions Specifies how to display the full contact card.
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactManager.showFullContactCard = function(contact, fullContactCardOptions) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactMatchReason = function() {};
 /** @type {Windows.ApplicationModel.Contacts.ContactMatchReasonKind} */
Windows.ApplicationModel.Contacts.ContactMatchReason.prototype.field;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Data.Text.TextSegment>} */
Windows.ApplicationModel.Contacts.ContactMatchReason.prototype.segments;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactMatchReason.prototype.text;

/** @const */
Windows.ApplicationModel.Contacts.ContactMatchReasonKind = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactMatchReasonKind.name;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactMatchReasonKind.emailAddress;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactMatchReasonKind.phoneNumber;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactMatchReasonKind.jobInfo;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactMatchReasonKind.yomiName;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactMatchReasonKind.other;

/** @const */
Windows.ApplicationModel.Contacts.ContactNameOrder = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactNameOrder.firstNameLastName;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactNameOrder.lastNameFirstName;

/**
 * @constructor
 * @struct
 * Initializes a new instance of a ContactPhone class.
 */
Windows.ApplicationModel.Contacts.ContactPhone = function() {};
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactPhone.prototype.description;
 /** @type {Windows.ApplicationModel.Contacts.ContactPhoneKind} */
Windows.ApplicationModel.Contacts.ContactPhone.prototype.kind;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactPhone.prototype.number;

/** @const */
Windows.ApplicationModel.Contacts.ContactPhoneKind = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactPhoneKind.home;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactPhoneKind.mobile;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactPhoneKind.work;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactPhoneKind.other;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactPhoneKind.pager;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactPhoneKind.businessFax;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactPhoneKind.homeFax;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactPhoneKind.company;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactPhoneKind.assistant;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactPhoneKind.radio;

/**
 * @constructor
 * @struct
 * Creates a new instance of the ContactPicker class.
 */
Windows.ApplicationModel.Contacts.ContactPicker = function() {};
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactPicker.prototype.commitButtonText;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.Contacts.ContactPicker.prototype.desiredFields;
 /** @type {!Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.ContactFieldType>} */
Windows.ApplicationModel.Contacts.ContactPicker.prototype.desiredFieldsWithContactFieldType;
 /** @type {Windows.ApplicationModel.Contacts.ContactSelectionMode} */
Windows.ApplicationModel.Contacts.ContactPicker.prototype.selectionMode;

/**
 * Launches the Contact Picker to select a single contact.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.Contact, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.Contact>>} The operation that launches the Contact Picker.
 */
Windows.ApplicationModel.Contacts.ContactPicker.prototype.pickContactAsync = function() {};

/**
 * Launches the Contact Picker for selecting multiple contacts.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVector<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVector<?>>>} The operation that launches the contact picker.
 */
Windows.ApplicationModel.Contacts.ContactPicker.prototype.pickContactsAsync = function() {};

/**
 * Launches the Contact Picker for selecting multiple contacts.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The operation that launches the contact picker.
 */
Windows.ApplicationModel.Contacts.ContactPicker.prototype.pickMultipleContactsAsync = function() {};

/**
 * Launches the Contact Picker for selecting a single contact.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.ContactInformation, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.ContactInformation>>} The operation that launches the Contact Picker.
 */
Windows.ApplicationModel.Contacts.ContactPicker.prototype.pickSingleContactAsync = function() {};

/** @const */
Windows.ApplicationModel.Contacts.ContactQueryDesiredFields = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactQueryDesiredFields.none;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactQueryDesiredFields.phoneNumber;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactQueryDesiredFields.emailAddress;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactQueryDesiredFields.postalAddress;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the ContactQueryOptions class.
 * Initializes a new instance of the ContactQueryOptions class.
 * Initializes a new instance of the ContactQueryOptions class.
 * @param {string=} text The text to match in the search operation.
 * @param {Windows.ApplicationModel.Contacts.ContactQuerySearchFields=} fields Specifies which contact fields to search for a match.
 */
Windows.ApplicationModel.Contacts.ContactQueryOptions = function(text, fields) {};
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.Contacts.ContactQueryOptions.prototype.annotationListIds;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.Contacts.ContactQueryOptions.prototype.contactListIds;
 /** @type {Windows.ApplicationModel.Contacts.ContactQueryDesiredFields} */
Windows.ApplicationModel.Contacts.ContactQueryOptions.prototype.desiredFields;
 /** @type {Windows.ApplicationModel.Contacts.ContactAnnotationOperations} */
Windows.ApplicationModel.Contacts.ContactQueryOptions.prototype.desiredOperations;
 /** @type {boolean} */
Windows.ApplicationModel.Contacts.ContactQueryOptions.prototype.includeContactsFromHiddenLists;
 /** @type {!Windows.ApplicationModel.Contacts.ContactQueryTextSearch} */
Windows.ApplicationModel.Contacts.ContactQueryOptions.prototype.textSearch;

/** @const */
Windows.ApplicationModel.Contacts.ContactQuerySearchFields = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactQuerySearchFields.none;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactQuerySearchFields.name;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactQuerySearchFields.email;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactQuerySearchFields.phone;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactQuerySearchFields.all;

/** @const */
Windows.ApplicationModel.Contacts.ContactQuerySearchScope = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactQuerySearchScope.local;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactQuerySearchScope.server;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactQueryTextSearch = function() {};
 /** @type {Windows.ApplicationModel.Contacts.ContactQuerySearchFields} */
Windows.ApplicationModel.Contacts.ContactQueryTextSearch.prototype.fields;
 /** @type {Windows.ApplicationModel.Contacts.ContactQuerySearchScope} */
Windows.ApplicationModel.Contacts.ContactQueryTextSearch.prototype.searchScope;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactQueryTextSearch.prototype.text;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactReader = function() {};

/**
 * Gets the reason a Contact matched the search query. Returns the properties and substrings that match.
 * @param {!Windows.ApplicationModel.Contacts.Contact} contact The Contact for which to get the matching properties.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Contacts.ContactMatchReason>} The list of matching properties and match reasons.
 */
Windows.ApplicationModel.Contacts.ContactReader.prototype.getMatchingPropertiesWithMatchReason = function(contact) {};

/**
 * Asynchronously reads a batch of Contact objects from the ContactStore .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.ContactBatch, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.ContactBatch>>} The batch of contacts read from the ContactStore .
 */
Windows.ApplicationModel.Contacts.ContactReader.prototype.readBatchAsync = function() {};

/** @const */
Windows.ApplicationModel.Contacts.ContactRelationship = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactRelationship.other;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactRelationship.spouse;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactRelationship.partner;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactRelationship.sibling;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactRelationship.parent;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactRelationship.child;

/** @const */
Windows.ApplicationModel.Contacts.ContactSelectionMode = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactSelectionMode.contacts;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactSelectionMode.fields;

/**
 * @constructor
 * @struct
 * Initializes a new instance of a ContactSignificantOther class.
 */
Windows.ApplicationModel.Contacts.ContactSignificantOther = function() {};
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactSignificantOther.prototype.description;
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactSignificantOther.prototype.name;
 /** @type {Windows.ApplicationModel.Contacts.ContactRelationship} */
Windows.ApplicationModel.Contacts.ContactSignificantOther.prototype.relationship;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactStore = function() {};
 /** @type {!Windows.ApplicationModel.Contacts.AggregateContactManager} */
Windows.ApplicationModel.Contacts.ContactStore.prototype.aggregateContactManager;
 /** @type {!Windows.ApplicationModel.Contacts.ContactChangeTracker} */
Windows.ApplicationModel.Contacts.ContactStore.prototype.changeTracker;
 /** @type {function(?): void} */
Windows.ApplicationModel.Contacts.ContactStore.prototype.oncontactchanged;

/**
 * Asynchronously creates a ContactList with the specified display name and user account.
 * Asynchronously creates a ContactList with the specified display name.
 * @param {string} displayName A name for the new ContactList , suitable for displaying in the user interface.
 * @param {string=} userDataAccountId The ID for the UserDataAccount to use when creating the ContactList .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.ContactList, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.ContactList>>} The newly created ContactList .
 */
Windows.ApplicationModel.Contacts.ContactStore.prototype.createContactListAsync = function(displayName, userDataAccountId) {};

/**
 * Asynchronously returns the list of ContactList objects.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The list of ContactList objects.
 */
Windows.ApplicationModel.Contacts.ContactStore.prototype.findContactListsAsync = function() {};

/**
 * Retrieves a list of Contact objects based on the supplied search text.
 * Retrieves the list of all contacts in the contact store.
 * @param {string=} searchText The search string for the operation. The query will attempt to match the name ( Name ), email address ( Emails values), or phone number ( Phones values) of a contact.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Contacts.Contact>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Contacts.Contact>>>} An asynchronous operation that returns a search-filtered list of contacts on successful completion. If you use Asynchronous programming, the result type is a read-only list/vector of Contact items. (You can use APIs of IVectorView<Contact> for C++ or JavaScript, APIs of IReadOnlyList<Contact> for .NET.) / An asynchronous operation that returns a list of all Contact objects in the contact store. If you use Asynchronous programming, the result type is a read-only list/vector of Contact items. (You can use APIs of IVectorView<Contact> for C++ or JavaScript, APIs of IReadOnlyList<Contact> for .NET.)
 */
Windows.ApplicationModel.Contacts.ContactStore.prototype.findContactsAsync = function(searchText) {};

/**
 * Retrieves a Contact object representing the contact with the specified Id value.
 * @param {string} contactId The Id of the contact to be retrieved.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.Contact, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.Contact>>} An asynchronous operation that returns a Contact object on successful completion. If you use Asynchronous programming, the result type is a single Contact object.
 */
Windows.ApplicationModel.Contacts.ContactStore.prototype.getContactAsync = function(contactId) {};

/**
 * Asynchronously gets the ContactList with the specified ID.
 * @param {string} contactListId The ID of the ContactList to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.ContactList, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.ContactList>>} The ContactList with the specified ID or null if the list is not found.
 */
Windows.ApplicationModel.Contacts.ContactStore.prototype.getContactListAsync = function(contactListId) {};

/**
 * Creates and returns a ContactReader for the ContactStore with the specified ContactQueryOptions .
 * Creates and returns a ContactReader for the ContactStore .
 * @param {!Windows.ApplicationModel.Contacts.ContactQueryOptions=} options The query options to use when creating the new ContactReader .
 * @return {!Windows.ApplicationModel.Contacts.ContactReader} The newly created ContactReader for the ContactStore .
 */
Windows.ApplicationModel.Contacts.ContactStore.prototype.getContactReader = function(options) {};

/**
 * Get the Contact object for the current user.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Contacts.Contact, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Contacts.Contact>>} The Contact object for the current user.
 */
Windows.ApplicationModel.Contacts.ContactStore.prototype.getMeContactAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactStore.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Contacts.ContactStore.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.ApplicationModel.Contacts.ContactStoreAccessType = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactStoreAccessType.appContactsReadWrite;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactStoreAccessType.allContactsReadOnly;
/** @const {number} */
Windows.ApplicationModel.Contacts.ContactStoreAccessType.allContactsReadWrite;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.ContactStoreNotificationTriggerDetails = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of a ContactWebsite class.
 */
Windows.ApplicationModel.Contacts.ContactWebsite = function() {};
 /** @type {string} */
Windows.ApplicationModel.Contacts.ContactWebsite.prototype.description;
 /** @type {?} */
Windows.ApplicationModel.Contacts.ContactWebsite.prototype.rawValue;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.Contacts.ContactWebsite.prototype.uri;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the FullContactCardOptions class.
 */
Windows.ApplicationModel.Contacts.FullContactCardOptions = function() {};
 /** @type {Windows.UI.ViewManagement.ViewSizePreference} */
Windows.ApplicationModel.Contacts.FullContactCardOptions.prototype.desiredRemainingView;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.KnownContactField = function() {};
 /** @type {string} */
Windows.ApplicationModel.Contacts.KnownContactField.email;
 /** @type {string} */
Windows.ApplicationModel.Contacts.KnownContactField.instantMessage;
 /** @type {string} */
Windows.ApplicationModel.Contacts.KnownContactField.location;
 /** @type {string} */
Windows.ApplicationModel.Contacts.KnownContactField.phoneNumber;

/**
 * Converts a string representing the name of a field to its corresponding type.
 * @param {string} name The name of the field.
 * @return {Windows.ApplicationModel.Contacts.ContactFieldType} The type of field.
 */
Windows.ApplicationModel.Contacts.KnownContactField.convertNameToType = function(name) {};

/**
 * Converts the type of a field to its corresponding string name.
 * @param {Windows.ApplicationModel.Contacts.ContactFieldType} type The type of field.
 * @return {string} The name of the field.
 */
Windows.ApplicationModel.Contacts.KnownContactField.convertTypeToName = function(type) {};
/** @const */
Windows.ApplicationModel.Contacts.Provider = {};

/** @const */
Windows.ApplicationModel.Contacts.Provider.AddContactResult = {};
/** @const {number} */
Windows.ApplicationModel.Contacts.Provider.AddContactResult.added;
/** @const {number} */
Windows.ApplicationModel.Contacts.Provider.AddContactResult.alreadyAdded;
/** @const {number} */
Windows.ApplicationModel.Contacts.Provider.AddContactResult.unavailable;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.Provider.ContactPickerUI = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.ApplicationModel.Contacts.Provider.ContactPickerUI.prototype.desiredFields;
 /** @type {!Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.ContactFieldType>} */
Windows.ApplicationModel.Contacts.Provider.ContactPickerUI.prototype.desiredFieldsWithContactFieldType;
 /** @type {function(?): void} */
Windows.ApplicationModel.Contacts.Provider.ContactPickerUI.prototype.oncontactremoved;
 /** @type {Windows.ApplicationModel.Contacts.ContactSelectionMode} */
Windows.ApplicationModel.Contacts.Provider.ContactPickerUI.prototype.selectionMode;

/**
 * Adds a Contact .
 * Adds a Contact .
 * @param {string|!Windows.ApplicationModel.Contacts.Contact} id_or_contact The ID for the contact. / An object that contains the contact's information.
 * @param {!Windows.ApplicationModel.Contacts.Contact=} contact An object that contains the contact's information.
 * @return {Windows.ApplicationModel.Contacts.Provider.AddContactResult} An AddContactResult -typed value that indicates whether the contact was added successfully.
 */
Windows.ApplicationModel.Contacts.Provider.ContactPickerUI.prototype.addContact = function(id_or_contact, contact) {};

/**
 * Checks to see whether the contact was already selected by the user.
 * @param {string} id The ID of the contact.
 * @return {boolean} True if the contact has already been selected; otherwise, false.
 */
Windows.ApplicationModel.Contacts.Provider.ContactPickerUI.prototype.containsContact = function(id) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Contacts.Provider.ContactPickerUI.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Contacts.Provider.ContactPickerUI.prototype.removeEventListener = function(type, listener) {};

/**
 * Removes a contact.
 * @param {string} id The ID of the contact to remove.
 * @return {void}
 */
Windows.ApplicationModel.Contacts.Provider.ContactPickerUI.prototype.removeContact = function(id) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs.prototype.id;
/**
 * @record
 * @struct
 */
Windows.ApplicationModel.Contacts.IContactField = function() {};
 /** @type {Windows.ApplicationModel.Contacts.ContactFieldCategory} */
Windows.ApplicationModel.Contacts.IContactField.prototype.category;
 /** @type {string} */
Windows.ApplicationModel.Contacts.IContactField.prototype.name;
 /** @type {Windows.ApplicationModel.Contacts.ContactFieldType} */
Windows.ApplicationModel.Contacts.IContactField.prototype.type;
 /** @type {string} */
Windows.ApplicationModel.Contacts.IContactField.prototype.value;
/** @const */
Windows.ApplicationModel.Core = {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Core.AppListEntry = function() {};
 /** @type {!Windows.ApplicationModel.AppDisplayInfo} */
Windows.ApplicationModel.Core.AppListEntry.prototype.displayInfo;

/**
 * Launches the app associated with this AppListEntry
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} If the launch fails for any reason, the Boolean value is false
 */
Windows.ApplicationModel.Core.AppListEntry.prototype.launchAsync = function() {};
/** @const */
Windows.ApplicationModel.DataTransfer = {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.Clipboard = function() {};
 /** @type {function(?): void} */
Windows.ApplicationModel.DataTransfer.Clipboard.oncontentchanged;

/**
 * Removes all data from the Clipboard.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.Clipboard.clear = function() {};

/**
 * Adds the content to the Clipboard and releases the DataPackage object from the source app. This method allows the content to remain available after the application shuts down.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.Clipboard.flush = function() {};

/**
 * Gets the current content that is stored in the clipboard object.
 * @return {!Windows.ApplicationModel.DataTransfer.DataPackageView} Contains the content of the Clipboard.
 */
Windows.ApplicationModel.DataTransfer.Clipboard.getContent = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.Clipboard.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.Clipboard.removeEventListener = function(type, listener) {};

/**
 * Sets the current content that is stored in the clipboard object.
 * @param {!Windows.ApplicationModel.DataTransfer.DataPackage} content Contains the content of the clipboard. If NULL, the clipboard is emptied.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.Clipboard.setContent = function(content) {};

/**
 * @constructor
 * @struct
 * Constructor that creates a new DataPackage .
 */
Windows.ApplicationModel.DataTransfer.DataPackage = function() {};
 /** @type {function(?): void} */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.ondestroyed;
 /** @type {function(?): void} */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.onoperationcompleted;
 /** @type {!Windows.ApplicationModel.DataTransfer.DataPackagePropertySet} */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.properties;
 /** @type {Windows.ApplicationModel.DataTransfer.DataPackageOperation} */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.requestedOperation;
 /** @type {!Windows.Foundation.Collections.IMap<string, !Windows.Storage.Streams.RandomAccessStreamReference>} */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.resourceMap;

/**
 * Returns a DataPackageView object. This object is a read-only copy of the DataPackage object.
 * @return {!Windows.ApplicationModel.DataTransfer.DataPackageView} The object that is a read-only copy of the DataPackage object.
 */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.getView = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.removeEventListener = function(type, listener) {};

/**
 * Sets the application link that a DataPackage contains.
 * @param {!Windows.Foundation.Uri} value A URI with a scheme that isn't http or https that's handled by the source app.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.setApplicationLink = function(value) {};

/**
 * Sets the bitmap image contained in the DataPackage .
 * @param {!Windows.Storage.Streams.RandomAccessStreamReference} value A stream that contains the bitmap image.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.setBitmap = function(value) {};

/**
 * Sets the data contained in the DataPackage in a RandomAccessStream format.
 * @param {string} formatId Specifies the format of the data. We recommend that you set this value by using the StandardDataFormats class.
 * @param {?} value Specifies the content that the DataPackage contains.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.setData = function(formatId, value) {};

/**
 * Sets a delegate to handle requests from the target app.
 * @param {string} formatId Specifies the format of the data. We recommend that you set this value by using the StandardDataFormats class.
 * @param {function(!Windows.ApplicationModel.DataTransfer.DataProviderRequest): void} delayRenderer A delegate that is responsible for processing requests from a target app.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.setDataProvider = function(formatId, delayRenderer) {};

/**
 * Adds HTML content to the DataPackage .
 * @param {string} value The HTML content.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.setHtmlFormat = function(value) {};

/**
 * Sets the Rich Text Format (RTF) content that is contained in a DataPackage .
 * @param {string} value Specifies the RTF content for the DataPackage .
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.setRtf = function(value) {};

/**
 * Sets the files and folders contained in a DataPackage .
 * Adds files and folders to a DataPackage .
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Storage.IStorageItem>} value The files and folders to be added to the DataPackage .
 * @param {boolean=} readOnly Specify true if the files are read-only; false otherwise.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.setStorageItems = function(value, readOnly) {};

/**
 * Sets the text that a DataPackage contains.
 * @param {string} value The text.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.setText = function(value) {};

/**
 * Sets the Uniform Resource Identifier (URI) that is contained in the DataPackage .
 * @param {!Windows.Foundation.Uri} value The URI that is contained in the DataPackage .
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.setUri = function(value) {};

/**
 * Sets the web link that a DataPackage contains.
 * @param {!Windows.Foundation.Uri} value A URI with an http or https scheme that corresponds to the content being displayed to the user.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackage.prototype.setWebLink = function(value) {};

/** @const */
Windows.ApplicationModel.DataTransfer.DataPackageOperation = {};
/** @const {number} */
Windows.ApplicationModel.DataTransfer.DataPackageOperation.none;
/** @const {number} */
Windows.ApplicationModel.DataTransfer.DataPackageOperation.copy;
/** @const {number} */
Windows.ApplicationModel.DataTransfer.DataPackageOperation.move;
/** @const {number} */
Windows.ApplicationModel.DataTransfer.DataPackageOperation.link;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet = function() {};
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.applicationListingUri;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.applicationName;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.contentSourceApplicationLink;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.contentSourceWebLink;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.description;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.enterpriseId;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.fileTypes;
 /** @type {!Windows.UI.Color} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.logoBackgroundColor;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.packageFamilyName;
 /** @type {number} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.size;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.square30x30Logo;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.thumbnail;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.title;

/**
 * Removes all items from the property set.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.clear = function() {};

/**
 * Returns an iterator to enumerate the items in the property set.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The first item in the DataPackage object.
 */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.first = function() {};

/**
 * Gets an immutable view of the property set.
 * @return {!Windows.Foundation.Collections.IMapView<string, ?>} The immutable view.
 */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.getView = function() {};

/**
 * Indicates whether the DataPackagePropertySet object contains a specific property.
 * @param {string} key The key.
 * @return {boolean} True if the property set has an item with the specified key; otherwise false.
 */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.hasKey = function(key) {};

/**
 * Adds a property to the DataPackagePropertySet object.
 * @param {string} key The key to insert.
 * @param {?} value The value to insert.
 * @return {boolean} True if the method replaced a value that already existed for the key; false if this is a new key.
 */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.insert = function(key, value) {};

/**
 * Retrieves the value of a specific property.
 * @param {string} key The key.
 * @return {?} The value, if an item with the specified key exists. Otherwise, an error code.
 */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.lookup = function(key) {};

/**
 * Removes an item from the property set.
 * @param {string} key The key.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySet.prototype.remove = function(key) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView = function() {};
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.applicationListingUri;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.applicationName;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.contentSourceApplicationLink;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.contentSourceWebLink;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.description;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.enterpriseId;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.fileTypes;
 /** @type {!Windows.UI.Color} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.logoBackgroundColor;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.packageFamilyName;
 /** @type {number} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.size;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.square30x30Logo;
 /** @type {!Windows.Storage.Streams.RandomAccessStreamReference} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.thumbnail;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.title;

/**
 * Returns an iterator to enumerate the items in the property set.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The first item in the DataPackage object.
 */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.first = function() {};

/**
 * Indicates whether the DataPackagePropertySetView object contains a specific property.
 * @param {string} key The key.
 * @return {boolean} True if the property set has an item with the specified key; otherwise false.
 */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.hasKey = function(key) {};

/**
 * Retrieves the value of a specific property.
 * @param {string} key The key.
 * @return {?} The value, if an item with the specified key exists. Otherwise, an error code.
 */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.lookup = function(key) {};

/**
 * Divides the object into two views
 * @return {{first: !Windows.Foundation.Collections.IMapView<string, ?>, second: !Windows.Foundation.Collections.IMapView<string, ?>}}
 */
Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView.prototype.split = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.DataPackageView = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.availableFormats;
 /** @type {!Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView} */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.properties;
 /** @type {Windows.ApplicationModel.DataTransfer.DataPackageOperation} */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.requestedOperation;

/**
 * Checks to see if the DataPackageView contains a specific data format.
 * @param {string} formatId The name of the format.
 * @return {boolean} True if the DataPackageView contains the format; false otherwise.
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.contains = function(formatId) {};

/**
 * Gets the application link in the DataPackageView object.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Uri, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Uri>>} The application link.
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.getApplicationLinkAsync = function() {};

/**
 * Gets the bitmap image contained in the DataPackageView
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.RandomAccessStreamReference, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.RandomAccessStreamReference>>} A stream containing the bitmap image.
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.getBitmapAsync = function() {};

/**
 * Gets the data contained in the DataPackageView .
 * @param {string} formatId Specifies the format of the data. We recommend that you set this value by using the StandardDataFormats class.
 * @return {!Windows.Foundation.IPromiseWithOperation<?, !Windows.Foundation.IAsyncOperation<?>>} The data.
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.getDataAsync = function(formatId) {};

/**
 * Gets the HTML stored in the DataPackageView object.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} The HTML.
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.getHtmlFormatAsync = function() {};

/**
 * Gets the data (such as an image) referenced in HTML content.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IMapView<?, ?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IMapView<?, ?>>>} The data referenced in the HTML content.
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.getResourceMapAsync = function() {};

/**
 * Gets the rich text formatted (RTF) content contained in a DataPackageView .
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} The rich text formatted content for the DataPackage.
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.getRtfAsync = function() {};

/**
 * Gets the files and folders stored in a DataPackageView object.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An array of files and folders stored in a DataPackageView .
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.getStorageItemsAsync = function() {};

/**
 * Gets the text in the DataPackageView object.
 * Gets the text in the DataPackageView object.
 * @param {string=} formatId A string that represents the data format. Usually StandardDataFormats.text .
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} The text.
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.getTextAsync = function(formatId) {};

/**
 * Gets the URI contained in the DataPackageView .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Uri, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Uri>>} The Uri.
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.getUriAsync = function() {};

/**
 * Gets the web link in the DataPackageView object.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Uri, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Uri>>} The web link.
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.getWebLinkAsync = function() {};

/**
 * Informs the system that your app is finished using the DataPackageView object. Primarily used for Clipboard operations.
 * @param {Windows.ApplicationModel.DataTransfer.DataPackageOperation} value An enumeration that states what operation (such as copy or move) was completed. At most one operation flag can be set.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.reportOperationCompleted = function(value) {};

/**
 * Requests permission to unlock and access a data package that is secured with a protection policy.
 * Requests permission to unlock and access a data package that is secured with a protection policy.
 * @param {string=} enterpriseId The enterprise Id.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult, !Windows.Foundation.IAsyncOperation<Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>>} When this method completes, it returns the results of the protection policy evaluation, which indicates whether or not the data is accessible.
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.requestAccessAsync = function(enterpriseId) {};

/**
 * Sets the accepted format Id.
 * @param {string} formatId The format Id.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.setAcceptedFormatId = function(formatId) {};

/**
 * Unlocks a data package and assumes an enterprise identity for it.
 * @return {Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult} When this method completes, it returns the results of the protection policy evaluation.
 */
Windows.ApplicationModel.DataTransfer.DataPackageView.prototype.unlockAndAssumeEnterpriseIdentity = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.DataProviderDeferral = function() {};

/**
 * Informs a DataPackage that it is ready for processing.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataProviderDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.DataProviderRequest = function() {};
 /** @type {!Date} */
Windows.ApplicationModel.DataTransfer.DataProviderRequest.prototype.deadline;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.DataProviderRequest.prototype.formatId;

/**
 * Returns a DataProviderDeferral object.
 * @return {!Windows.ApplicationModel.DataTransfer.DataProviderDeferral} An data provider deferral object.
 */
Windows.ApplicationModel.DataTransfer.DataProviderRequest.prototype.getDeferral = function() {};

/**
 * Sets the content of the DataPackage to be shared with a target app.
 * @param {?} value The object associated with a particular format in the DataPackage .
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataProviderRequest.prototype.setData = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.DataRequest = function() {};
 /** @type {!Windows.ApplicationModel.DataTransfer.DataPackage} */
Windows.ApplicationModel.DataTransfer.DataRequest.prototype.data;
 /** @type {!Date} */
Windows.ApplicationModel.DataTransfer.DataRequest.prototype.deadline;

/**
 * Cancels the sharing operation and supplies an error string to display to the user.
 * @param {string} value The text to display to the user.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataRequest.prototype.failWithDisplayText = function(value) {};

/**
 * Supports asynchronous sharing operations by creating and returning a DataRequestDeferral object.
 * @return {!Windows.ApplicationModel.DataTransfer.DataRequestDeferral} An object that allows you to share or send content asynchronously.
 */
Windows.ApplicationModel.DataTransfer.DataRequest.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.DataRequestDeferral = function() {};

/**
 * Indicates that the content for an asynchronous share is ready for a target app, or that an error in the sharing operation occurred.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataRequestDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs = function() {};
 /** @type {!Windows.ApplicationModel.DataTransfer.DataRequest} */
Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs.prototype.request;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.DataTransferManager = function() {};
 /** @type {function(?): void} */
Windows.ApplicationModel.DataTransfer.DataTransferManager.prototype.ondatarequested;
 /** @type {function(?): void} */
Windows.ApplicationModel.DataTransfer.DataTransferManager.prototype.ontargetapplicationchosen;

/**
 * Returns the DataTransferManager object associated with the current window.
 * @return {!Windows.ApplicationModel.DataTransfer.DataTransferManager} The DataTransferManager object associated with the current window.
 */
Windows.ApplicationModel.DataTransfer.DataTransferManager.getForCurrentView = function() {};

/**
 * Programmatically initiates the user interface for sharing content with another app.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataTransferManager.showShareUI = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataTransferManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.DataTransferManager.prototype.removeEventListener = function(type, listener) {};
/** @const */
Windows.ApplicationModel.DataTransfer.DragDrop = {};
/** @const */
Windows.ApplicationModel.DataTransfer.DragDrop.Core = {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.HtmlFormatHelper = function() {};

/**
 * Takes a string that represents HTML content and adds the necessary headers to ensure it is formatted correctly for share and Clipboard operations.
 * @param {string} htmlFragment A string representing the HTML content.
 * @return {string} A string representing the formatted HTML.
 */
Windows.ApplicationModel.DataTransfer.HtmlFormatHelper.createHtmlFormat = function(htmlFragment) {};

/**
 * Gets a string that represents an HTML fragment.
 * @param {string} htmlFormat The formatted HTML.
 * @return {string} An HTML fragment based on the formatted HTML.
 */
Windows.ApplicationModel.DataTransfer.HtmlFormatHelper.getStaticFragment = function(htmlFormat) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs = function() {};
 /** @type {?} */
Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs.prototype.acceptedFormatId;
 /** @type {Windows.ApplicationModel.DataTransfer.DataPackageOperation} */
Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs.prototype.operation;
/** @const */
Windows.ApplicationModel.DataTransfer.ShareTarget = {};

/**
 * @constructor
 * @struct
 * Creates a new instance of a QuickLink object.
 */
Windows.ApplicationModel.DataTransfer.ShareTarget.QuickLink = function() {};
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.ShareTarget.QuickLink.prototype.id;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.DataTransfer.ShareTarget.QuickLink.prototype.supportedDataFormats;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.DataTransfer.ShareTarget.QuickLink.prototype.supportedFileTypes;
 /** @type {!Windows.Storage.Streams.RandomAccessStreamReference} */
Windows.ApplicationModel.DataTransfer.ShareTarget.QuickLink.prototype.thumbnail;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.ShareTarget.QuickLink.prototype.title;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation = function() {};
 /** @type {!Windows.ApplicationModel.DataTransfer.DataPackageView} */
Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation.prototype.data;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation.prototype.quickLinkId;

/**
 * Closes the share pane.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation.prototype.dismissUI = function() {};

/**
 * Removes the QuickLink from the list of QuickLinks that are available to the user.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation.prototype.removeThisQuickLink = function() {};

/**
 * Specifies that the sharing operation is complete.
 * Specifies that the sharing operation is complete. A QuickLink that the system can save as a shortcut for future sharing operations is included.
 * @param {!Windows.ApplicationModel.DataTransfer.ShareTarget.QuickLink=} quicklink A QuickLink object that the system saves as a shortcut for future sharing operations.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation.prototype.reportCompleted = function(quicklink) {};

/**
 * Specifies that the app has acquired the content that the user wants to share.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation.prototype.reportDataRetrieved = function() {};

/**
 * Specifies that an error occurred during the sharing operation.
 * @param {string} value Specifies the error message. The system displays this message to the user.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation.prototype.reportError = function(value) {};

/**
 * Specifies that the app has started to acquire the content that the user wants to share.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation.prototype.reportStarted = function() {};

/**
 * Specifies that the app has requested that the system allow the sharing operation to run as a background task.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation.prototype.reportSubmittedBackgroundTask = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager = function() {};

/**
 * Gets the sharing token that enables an app to share the specified file with another app.
 * @param {!Windows.Storage.IStorageFile} file The file to share with the target app.
 * @return {string} The sharing token to provide to the target app as part of a Uri activation.
 */
Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager.addFile = function(file) {};

/**
 * Gets a file shared by another app by providing the sharing token received from the source app.
 * @param {string} token The sharing token for the shared file.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} A wrapper object that contains the shared file.
 */
Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager.redeemTokenForFileAsync = function(token) {};

/**
 * Revokes an existing sharing token.
 * @param {string} token The sharing token to revoke.
 * @return {void}
 */
Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager.removeFile = function(token) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.StandardDataFormats = function() {};
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.StandardDataFormats.applicationLink;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.StandardDataFormats.bitmap;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.StandardDataFormats.html;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.StandardDataFormats.rtf;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.StandardDataFormats.storageItems;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.StandardDataFormats.text;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.StandardDataFormats.uri;
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.StandardDataFormats.webLink;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs.prototype.applicationName;

/** @typedef {function(!Windows.ApplicationModel.DataTransfer.DataProviderRequest): void} */
Windows.ApplicationModel.DataTransfer.DataProviderHandler;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.DesignMode = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.DesignMode.designModeEnabled;
/** @const */
Windows.ApplicationModel.Email = {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the EmailAttachment class.
 * Initializes a new instance of the EmailAttachment class with the specified random access stream.
 * Initializes a new instance of the EmailAttachment class.
 * @param {string=} filename_or_fileName The file name to use for the attachment. / The filename of the attachment.
 * @param {!Windows.Storage.Streams.IRandomAccessStreamReference=} data A random access stream containing the data for the attachment. / The stream to use to download the attachment.
 * @param {string=} mimeType The MIME type of the attachment.
 */
Windows.ApplicationModel.Email.EmailAttachment = function(filename_or_fileName, data, mimeType) {};
 /** @type {string} */
Windows.ApplicationModel.Email.EmailAttachment.prototype.contentId;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailAttachment.prototype.contentLocation;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Email.EmailAttachment.prototype.data;
 /** @type {Windows.ApplicationModel.Email.EmailAttachmentDownloadState} */
Windows.ApplicationModel.Email.EmailAttachment.prototype.downloadState;
 /** @type {number} */
Windows.ApplicationModel.Email.EmailAttachment.prototype.estimatedDownloadSizeInBytes;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailAttachment.prototype.fileName;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailAttachment.prototype.id;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailAttachment.prototype.isFromBaseMessage;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailAttachment.prototype.isInline;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailAttachment.prototype.mimeType;

/** @const */
Windows.ApplicationModel.Email.EmailAttachmentDownloadState = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailAttachmentDownloadState.notDownloaded;
/** @const {number} */
Windows.ApplicationModel.Email.EmailAttachmentDownloadState.downloading;
/** @const {number} */
Windows.ApplicationModel.Email.EmailAttachmentDownloadState.downloaded;
/** @const {number} */
Windows.ApplicationModel.Email.EmailAttachmentDownloadState.failed;

/** @const */
Windows.ApplicationModel.Email.EmailBatchStatus = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailBatchStatus.success;
/** @const {number} */
Windows.ApplicationModel.Email.EmailBatchStatus.serverSearchSyncManagerError;
/** @const {number} */
Windows.ApplicationModel.Email.EmailBatchStatus.serverSearchUnknownError;
/** @const */
Windows.ApplicationModel.Email.EmailCertificateValidationStatus = {};
 /** @type {?} */
Windows.ApplicationModel.Email.EmailCertificateValidationStatus.success;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailCertificateValidationStatus.noMatch;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailCertificateValidationStatus.invalidUsage;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailCertificateValidationStatus.invalidCertificate;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailCertificateValidationStatus.revoked;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailCertificateValidationStatus.chainRevoked;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailCertificateValidationStatus.revocationServerFailure;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailCertificateValidationStatus.expired;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailCertificateValidationStatus.untrusted;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailCertificateValidationStatus.serverError;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailCertificateValidationStatus.unknownFailure;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailConversation = function() {};
 /** @type {Windows.ApplicationModel.Email.EmailFlagState} */
Windows.ApplicationModel.Email.EmailConversation.prototype.flagState;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailConversation.prototype.hasAttachment;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailConversation.prototype.id;
 /** @type {Windows.ApplicationModel.Email.EmailImportance} */
Windows.ApplicationModel.Email.EmailConversation.prototype.importance;
 /** @type {Windows.ApplicationModel.Email.EmailMessageResponseKind} */
Windows.ApplicationModel.Email.EmailConversation.prototype.lastEmailResponseKind;
 /** @type {!Windows.ApplicationModel.Email.EmailRecipient} */
Windows.ApplicationModel.Email.EmailConversation.prototype.latestSender;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailConversation.prototype.mailboxId;
 /** @type {number} */
Windows.ApplicationModel.Email.EmailConversation.prototype.messageCount;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailConversation.prototype.mostRecentMessageId;
 /** @type {!Date} */
Windows.ApplicationModel.Email.EmailConversation.prototype.mostRecentMessageTime;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailConversation.prototype.preview;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailConversation.prototype.subject;
 /** @type {number} */
Windows.ApplicationModel.Email.EmailConversation.prototype.unreadMessageCount;

/**
 * Asynchronously gets a batch of messages in the conversation.
 * Asynchronously gets a batch of messages in the conversation.
 * @param {number=} count The size of the batch of messages to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The batch of messages.
 */
Windows.ApplicationModel.Email.EmailConversation.prototype.findMessagesAsync = function(count) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailConversationBatch = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Email.EmailConversation>} */
Windows.ApplicationModel.Email.EmailConversationBatch.prototype.conversations;
 /** @type {Windows.ApplicationModel.Email.EmailBatchStatus} */
Windows.ApplicationModel.Email.EmailConversationBatch.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailConversationReader = function() {};

/**
 * Asynchronously reads a batch of email conversations.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailConversationBatch, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailConversationBatch>>} Returns a batch of email conversations.
 */
Windows.ApplicationModel.Email.EmailConversationReader.prototype.readBatchAsync = function() {};

/** @const */
Windows.ApplicationModel.Email.EmailFlagState = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailFlagState.unflagged;
/** @const {number} */
Windows.ApplicationModel.Email.EmailFlagState.flagged;
/** @const {number} */
Windows.ApplicationModel.Email.EmailFlagState.completed;
/** @const {number} */
Windows.ApplicationModel.Email.EmailFlagState.cleared;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailFolder = function() {};
 /** @type {string} */
Windows.ApplicationModel.Email.EmailFolder.prototype.displayName;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailFolder.prototype.id;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailFolder.prototype.isSyncEnabled;
 /** @type {Windows.ApplicationModel.Email.EmailSpecialFolderKind} */
Windows.ApplicationModel.Email.EmailFolder.prototype.kind;
 /** @type {!Date} */
Windows.ApplicationModel.Email.EmailFolder.prototype.lastSuccessfulSyncTime;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailFolder.prototype.mailboxId;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailFolder.prototype.parentFolderId;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailFolder.prototype.remoteId;

/**
 * Asynchronously creates a new folder.
 * @param {string} name The name for the new folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailFolder, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailFolder>>} Returns the newly created folder.
 */
Windows.ApplicationModel.Email.EmailFolder.prototype.createFolderAsync = function(name) {};

/**
 * Asynchronously deletes this folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Email.EmailFolder.prototype.deleteAsync = function() {};

/**
 * Asynchronously finds the child folders of this folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The list of child folders.
 */
Windows.ApplicationModel.Email.EmailFolder.prototype.findChildFoldersAsync = function() {};

/**
 * Gets an instance of the EmailConversationReader class.
 * Gets an instance of the EmailConversationReader class using the specified query options.
 * @param {!Windows.ApplicationModel.Email.EmailQueryOptions=} options The query options to use when finding the conversation reader.
 * @return {!Windows.ApplicationModel.Email.EmailConversationReader} The conversation reader. / The conversation reader that matches the query options.
 */
Windows.ApplicationModel.Email.EmailFolder.prototype.getConversationReader = function(options) {};

/**
 * Asynchronously gets the specified message from the folder.
 * @param {string} id The ID of the message to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailMessage, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailMessage>>} The message specified in the id parameter.
 */
Windows.ApplicationModel.Email.EmailFolder.prototype.getMessageAsync = function(id) {};

/**
 * Asynchronously gets the counts of email items such as flagged emails, important emails, unread emails, total emails, and so on.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailItemCounts, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailItemCounts>>} An EmailItemCounts object containing the counts of email items such as flagged emails, important emails, unread emails, total emails, and so on.
 */
Windows.ApplicationModel.Email.EmailFolder.prototype.getMessageCountsAsync = function() {};

/**
 * Gets an instance of the EmailMessageReader class.
 * Gets an instance of the EmailMessageReader class using the specified query options.
 * @param {!Windows.ApplicationModel.Email.EmailQueryOptions=} options The query options to use when finding the message reader.
 * @return {!Windows.ApplicationModel.Email.EmailMessageReader} The message reader. / The message reader that matches the query options.
 */
Windows.ApplicationModel.Email.EmailFolder.prototype.getMessageReader = function(options) {};

/**
 * Asynchronously saves the specified email message to the folder.
 * @param {!Windows.ApplicationModel.Email.EmailMessage} message The email message to save.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Email.EmailFolder.prototype.saveMessageAsync = function(message) {};

/**
 * Asynchronously attempts to move this folder to the specified folder.
 * Asynchronously attempts to move this folder to the specified folder and rename it in the process.
 * @param {!Windows.ApplicationModel.Email.EmailFolder} newParentFolder The new location for this folder.
 * @param {string=} newFolderName The name for the folder in the new location.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the move was successful.
 */
Windows.ApplicationModel.Email.EmailFolder.prototype.tryMoveAsync = function(newParentFolder, newFolderName) {};

/**
 * Asynchronously attempts to save changes to the folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the save was successful.
 */
Windows.ApplicationModel.Email.EmailFolder.prototype.trySaveAsync = function() {};

/** @const */
Windows.ApplicationModel.Email.EmailImportance = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailImportance.normal;
/** @const {number} */
Windows.ApplicationModel.Email.EmailImportance.high;
/** @const {number} */
Windows.ApplicationModel.Email.EmailImportance.low;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the EmailIrmInfo class.
 * Initializes a new instance of the EmailIrmInfo class using the specified IRM expiration time and template.
 * @param {!Date=} expiration The time when the information rights management (IRM) permissions expire.
 * @param {!Windows.ApplicationModel.Email.EmailIrmTemplate=} irmTemplate The IRM template to apply to the message.
 */
Windows.ApplicationModel.Email.EmailIrmInfo = function(expiration, irmTemplate) {};
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailIrmInfo.prototype.canEdit;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailIrmInfo.prototype.canExtractData;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailIrmInfo.prototype.canForward;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailIrmInfo.prototype.canModifyRecipientsOnResponse;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailIrmInfo.prototype.canPrintData;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailIrmInfo.prototype.canRemoveIrmOnResponse;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailIrmInfo.prototype.canReply;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailIrmInfo.prototype.canReplyAll;
 /** @type {!Date} */
Windows.ApplicationModel.Email.EmailIrmInfo.prototype.expirationDate;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailIrmInfo.prototype.isIrmOriginator;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailIrmInfo.prototype.isProgramaticAccessAllowed;
 /** @type {!Windows.ApplicationModel.Email.EmailIrmTemplate} */
Windows.ApplicationModel.Email.EmailIrmInfo.prototype.template;

/**
 * @constructor
 * @struct
 * Creates a new instance of the EmailIrmTemplate class with the specified ID, name and description.
 * Creates a new instance of the EmailIrmTemplate class.
 * @param {string=} id The ID for the new template.
 * @param {string=} name The name of the new template.
 * @param {string=} description The description of the new template.
 */
Windows.ApplicationModel.Email.EmailIrmTemplate = function(id, name, description) {};
 /** @type {string} */
Windows.ApplicationModel.Email.EmailIrmTemplate.prototype.description;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailIrmTemplate.prototype.id;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailIrmTemplate.prototype.name;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailItemCounts = function() {};
 /** @type {number} */
Windows.ApplicationModel.Email.EmailItemCounts.prototype.flagged;
 /** @type {number} */
Windows.ApplicationModel.Email.EmailItemCounts.prototype.important;
 /** @type {number} */
Windows.ApplicationModel.Email.EmailItemCounts.prototype.total;
 /** @type {number} */
Windows.ApplicationModel.Email.EmailItemCounts.prototype.unread;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailMailbox = function() {};
 /** @type {!Windows.ApplicationModel.Email.EmailMailboxCapabilities} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.capabilities;
 /** @type {!Windows.ApplicationModel.Email.EmailMailboxChangeTracker} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.changeTracker;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.displayName;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.id;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.isDataEncryptedUnderLock;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.isOwnedByCurrentApp;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.linkedMailboxId;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.mailAddress;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.mailAddressAliases;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.networkAccountId;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.networkId;
 /** @type {function(?): void} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.onmailboxchanged;
 /** @type {Windows.ApplicationModel.Email.EmailMailboxOtherAppReadAccess} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.otherAppReadAccess;
 /** @type {Windows.ApplicationModel.Email.EmailMailboxOtherAppWriteAccess} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.otherAppWriteAccess;
 /** @type {!Windows.ApplicationModel.Email.EmailMailboxPolicies} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.policies;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.sourceDisplayName;
 /** @type {!Windows.ApplicationModel.Email.EmailMailboxSyncManager} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.syncManager;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMailbox.prototype.userDataAccountId;

/**
 * Asynchronously changes the flag state of an email message.
 * @param {string} messageId The ID of the email message to change.
 * @param {Windows.ApplicationModel.Email.EmailFlagState} flagState The new email flag state.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.changeMessageFlagStateAsync = function(messageId, flagState) {};

/**
 * Creates a new response email such as Reply, Reply All, Forward, and so on.
 * @param {string} messageId The ID of the message to which to respond.
 * @param {Windows.ApplicationModel.Email.EmailMessageResponseKind} responseType The type of response such as Reply, Reply All, Forward, and so on.
 * @param {string} subject The subject for the response message.
 * @param {Windows.ApplicationModel.Email.EmailMessageBodyKind} responseHeaderType The format of the email body such as plain text or HTML.
 * @param {string} responseHeader The header for the response message.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailMessage, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailMessage>>} The newly created response email message.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.createResponseMessageAsync = function(messageId, responseType, subject, responseHeaderType, responseHeader) {};

/**
 * Asynchronously deletes the mailbox.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.deleteAsync = function() {};

/**
 * Asynchronously deletes an email message from the mailbox.
 * @param {string} messageId The ID of the email message to delete.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.deleteMessageAsync = function(messageId) {};

/**
 * Asynchronously downloads an email attachment.
 * @param {string} attachmentId The ID of the attachment to download.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.downloadAttachmentAsync = function(attachmentId) {};

/**
 * Asynchronously downloads the specified email message.
 * @param {string} messageId The ID of the message to download.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.downloadMessageAsync = function(messageId) {};

/**
 * Asynchronously gets the specified email conversation.
 * @param {string} id The ID of the email conversation to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailConversation, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailConversation>>} Returns the email conversation specified by the id parameter.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.getConversationAsync = function(id) {};

/**
 * Gets or creates an email conversation reader for this mailbox if one does not already exist.
 * Gets or creates an email conversation reader for this mailbox using the specified query options.
 * @param {!Windows.ApplicationModel.Email.EmailQueryOptions=} options The email query options to use when creating the conversation reader.
 * @return {!Windows.ApplicationModel.Email.EmailConversationReader} The email conversation reader. / The new or existing conversation reader.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.getConversationReader = function(options) {};

/**
 * Asynchronously gets the specified email folder.
 * @param {string} id The ID of the folder to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailFolder, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailFolder>>} The email folder specified in the id parameter.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.getFolderAsync = function(id) {};

/**
 * Asynchronously gets the specified email message.
 * @param {string} id The ID of the message to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailMessage, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailMessage>>} The email message specified in the id parameter.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.getMessageAsync = function(id) {};

/**
 * Gets or creates an email message reader for this mailbox if one does not already exist.
 * Gets or creates an email conversation reader for this mailbox using the specified query options.
 * @param {!Windows.ApplicationModel.Email.EmailQueryOptions=} options The email query options to use when creating the message reader.
 * @return {!Windows.ApplicationModel.Email.EmailMessageReader} The new or existing email message reader.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.getMessageReader = function(options) {};

/**
 * Asynchronously get a special email folder such as Inbox, Outbox, Drafts and so on.
 * @param {Windows.ApplicationModel.Email.EmailSpecialFolderKind} folderType The type of folder to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailFolder, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailFolder>>} The matching special email folder in this mailbox.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.getSpecialFolderAsync = function(folderType) {};

/**
 * Asynchronously marks all the messages in a folder as seen.
 * @param {string} folderId The ID of the folder to mark as seen.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.markFolderAsSeenAsync = function(folderId) {};

/**
 * Asynchronously marks a folder as sync enabled or disabled.
 * @param {string} folderId The ID of the folder to mark.
 * @param {boolean} isSyncEnabled True to enable to syncing with the server, false to disable syncing.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.markFolderSyncEnabledAsync = function(folderId, isSyncEnabled) {};

/**
 * Asynchronously marks an email message as seen.
 * @param {string} messageId The ID of the message to mark as seen.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.markMessageAsSeenAsync = function(messageId) {};

/**
 * Asynchronously marks an email message as read or unread.
 * @param {string} messageId The ID of the message to mark.
 * @param {boolean} isRead True to mark the message as read, false to mark it as unread.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.markMessageReadAsync = function(messageId, isRead) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.removeEventListener = function(type, listener) {};

/**
 * Resolves a list of one or more email addresses.
 * @param {!Windows.Foundation.Collections.IIterable<string>} recipients The list of email addresses.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A list of resolution results. The result list will be in the same order as the input list. See EmailRecipientResolutionResult for more information.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.resolveRecipientsAsync = function(recipients) {};

/**
 * Asynchronously saves the mailbox to the email store.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.saveAsync = function() {};

/**
 * Asynchronously saves a draft email message.
 * @param {!Windows.ApplicationModel.Email.EmailMessage} message The draft email message to save.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.saveDraftAsync = function(message) {};

/**
 * Asynchronously sends the specified email message.
 * Asynchronously sends the specified email message.
 * @param {!Windows.ApplicationModel.Email.EmailMessage} message The email message to send.
 * @param {boolean=} smartSend True to send only the updated text, false to include the full message thread.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.sendMessageAsync = function(message, smartSend) {};

/**
 * Asynchronously attempts to create a new email folder.
 * @param {string} parentFolderId The Id of the parent email folder.
 * @param {string} name The name for the new folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailMailboxCreateFolderResult, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailMailboxCreateFolderResult>>} An async operation with an EmailMailboxCreateFolderResult containing the newly created folder and the status of the create operation.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.tryCreateFolderAsync = function(parentFolderId, name) {};

/**
 * Asynchronously attempts to delete an email folder.
 * @param {string} folderId The Id of the folder to delete.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.ApplicationModel.Email.EmailMailboxDeleteFolderStatus, !Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Email.EmailMailboxDeleteFolderStatus>>} An async operation with an EmailMailboxDeleteFolderStatus value representing the status of the delete operation.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.tryDeleteFolderAsync = function(folderId) {};

/**
 * Asynchronously attempt to delete the contents of an email folder.
 * @param {string} folderId The Id of the folder to empty.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.ApplicationModel.Email.EmailMailboxEmptyFolderStatus, !Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Email.EmailMailboxEmptyFolderStatus>>} An async operation with an EmailMailboxEmptyFolderStatus value representing the status of the delete operation.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.tryEmptyFolderAsync = function(folderId) {};

/**
 * Asynchronously attempts to forward a meeting request.
 * @param {!Windows.ApplicationModel.Email.EmailMessage} meeting The meeting to forward.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.ApplicationModel.Email.EmailRecipient>} recipients The list of new recipients.
 * @param {string} subject The subject of the email.
 * @param {Windows.ApplicationModel.Email.EmailMessageBodyKind} forwardHeaderType The email message format, HTML or plain text.
 * @param {string} forwardHeader The email forward header.
 * @param {string} comment The body of the message.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the meeting was successfully forwarded.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.tryForwardMeetingAsync = function(meeting, recipients, subject, forwardHeaderType, forwardHeader, comment) {};

/**
 * Asynchronously attempts to get the auto-reply settings for the mailbox.
 * @param {Windows.ApplicationModel.Email.EmailMailboxAutoReplyMessageResponseKind} requestedFormat The requested text format of the auto-reply message, HTML or plain text.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings>>} The auto-reply settings.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.tryGetAutoReplySettingsAsync = function(requestedFormat) {};

/**
 * Asynchronously attempts to move the specified email folder.
 * Asynchronously attempts to move the specified email folder and rename it in the process.
 * @param {string} folderId The folder to move.
 * @param {string} newParentFolderId The new parent for the folder specified in the folderId parameter.
 * @param {string=} newFolderName The name for the folder in the new location.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the move was successful.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.tryMoveFolderAsync = function(folderId, newParentFolderId, newFolderName) {};

/**
 * Asynchronously attempts to move the specified email message.
 * @param {string} messageId The ID of the email message to move.
 * @param {string} newParentFolderId The ID of the new folder where the email message should reside.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the move was successful.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.tryMoveMessageAsync = function(messageId, newParentFolderId) {};

/**
 * Asynchronously attempts to send a meeting request proposing a new time.
 * @param {!Windows.ApplicationModel.Email.EmailMessage} meeting The meeting for which to propose a new time.
 * @param {!Date} newStartTime The proposed new time for the meeting to start.
 * @param {number} newDuration The proposed duration of the meeting.
 * @param {string} subject The subject of the meeting email.
 * @param {string} comment The body of the message.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the proposed meeting message was successfully sent.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.tryProposeNewTimeForMeetingAsync = function(meeting, newStartTime, newDuration, subject, comment) {};

/**
 * Asynchronously attempts to set the auto-reply settings for the mailbox.
 * @param {!Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings} autoReplySettings The new auto-reply settings.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the operation was successful.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.trySetAutoReplySettingsAsync = function(autoReplySettings) {};

/**
 * Asynchronously attempts to respond to a meeting request.
 * @param {!Windows.ApplicationModel.Email.EmailMessage} meeting The meeting request.
 * @param {Windows.ApplicationModel.Email.EmailMeetingResponseType} response The response to the meeting request, accept, decline, or tentative.
 * @param {string} subject The subject of the response email message.
 * @param {string} comment The body of the response email message.
 * @param {boolean} sendUpdate A Boolean indicating whether or not to send a response to the meeting originator.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating if the response was sent successfully.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.tryUpdateMeetingResponseAsync = function(meeting, response, subject, comment, sendUpdate) {};

/**
 * Validates the certificate against the sync provider service.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Security.Cryptography.Certificates.Certificate>} certificates The certificate to validate.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The confirmation that the certificate is valid.
 */
Windows.ApplicationModel.Email.EmailMailbox.prototype.validateCertificatesAsync = function(certificates) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailMailboxAction = function() {};
 /** @type {number} */
Windows.ApplicationModel.Email.EmailMailboxAction.prototype.changeNumber;
 /** @type {Windows.ApplicationModel.Email.EmailMailboxActionKind} */
Windows.ApplicationModel.Email.EmailMailboxAction.prototype.kind;

/** @const */
Windows.ApplicationModel.Email.EmailMailboxActionKind = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxActionKind.markMessageAsSeen;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxActionKind.markMessageRead;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxActionKind.changeMessageFlagState;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxActionKind.moveMessage;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxActionKind.saveDraft;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxActionKind.sendMessage;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxActionKind.createResponseReplyMessage;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxActionKind.createResponseReplyAllMessage;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxActionKind.createResponseForwardMessage;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxActionKind.moveFolder;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxActionKind.markFolderForSyncEnabled;

/** @const */
Windows.ApplicationModel.Email.EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation.none;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation.strongAlgorithm;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation.anyAlgorithm;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailMailboxAutoReply = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMailboxAutoReply.prototype.isEnabled;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMailboxAutoReply.prototype.response;

/** @const */
Windows.ApplicationModel.Email.EmailMailboxAutoReplyMessageResponseKind = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxAutoReplyMessageResponseKind.html;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxAutoReplyMessageResponseKind.plainText;

/**
 * @constructor
 * @struct
 * Initializes a new instance of an EmailMailboxAutoReplySettings object.
 */
Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings = function() {};
 /** @type {!Date} */
Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings.prototype.endTime;
 /** @type {!Windows.ApplicationModel.Email.EmailMailboxAutoReply} */
Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings.prototype.internalReply;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings.prototype.isEnabled;
 /** @type {!Windows.ApplicationModel.Email.EmailMailboxAutoReply} */
Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings.prototype.knownExternalReply;
 /** @type {Windows.ApplicationModel.Email.EmailMailboxAutoReplyMessageResponseKind} */
Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings.prototype.responseKind;
 /** @type {!Date} */
Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings.prototype.startTime;
 /** @type {!Windows.ApplicationModel.Email.EmailMailboxAutoReply} */
Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings.prototype.unknownExternalReply;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailMailboxCapabilities = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMailboxCapabilities.prototype.canCreateFolder;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMailboxCapabilities.prototype.canDeleteFolder;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMailboxCapabilities.prototype.canEmptyFolder;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailMailboxCapabilities.prototype.canForwardMeetings;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailMailboxCapabilities.prototype.canGetAndSetExternalAutoReplies;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailMailboxCapabilities.prototype.canGetAndSetInternalAutoReplies;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMailboxCapabilities.prototype.canMoveFolder;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailMailboxCapabilities.prototype.canProposeNewTimeForMeetings;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMailboxCapabilities.prototype.canResolveRecipients;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailMailboxCapabilities.prototype.canServerSearchFolders;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailMailboxCapabilities.prototype.canServerSearchMailbox;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailMailboxCapabilities.prototype.canSmartSend;
 /** @type {?} */
Windows.ApplicationModel.Email.EmailMailboxCapabilities.prototype.canUpdateMeetingResponses;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMailboxCapabilities.prototype.canValidateCertificates;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailMailboxChange = function() {};
 /** @type {Windows.ApplicationModel.Email.EmailMailboxChangeType} */
Windows.ApplicationModel.Email.EmailMailboxChange.prototype.changeType;
 /** @type {!Windows.ApplicationModel.Email.EmailFolder} */
Windows.ApplicationModel.Email.EmailMailboxChange.prototype.folder;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Email.EmailMailboxAction>} */
Windows.ApplicationModel.Email.EmailMailboxChange.prototype.mailboxActions;
 /** @type {!Windows.ApplicationModel.Email.EmailMessage} */
Windows.ApplicationModel.Email.EmailMailboxChange.prototype.message;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailMailboxChangeReader = function() {};

/**
 * Accepts all changes.
 * @return {void}
 */
Windows.ApplicationModel.Email.EmailMailboxChangeReader.prototype.acceptChanges = function() {};

/**
 * Accepts all changes through the current change.
 * @param {!Windows.ApplicationModel.Email.EmailMailboxChange} lastChangeToAcknowledge The current change.
 * @return {void}
 */
Windows.ApplicationModel.Email.EmailMailboxChangeReader.prototype.acceptChangesThrough = function(lastChangeToAcknowledge) {};

/**
 * Reads a collection of changes.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A batch of changes.
 */
Windows.ApplicationModel.Email.EmailMailboxChangeReader.prototype.readBatchAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailMailboxChangeTracker = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMailboxChangeTracker.prototype.isTracking;

/**
 * Enables change tracking on a mailbox.
 * @return {void}
 */
Windows.ApplicationModel.Email.EmailMailboxChangeTracker.prototype.enable = function() {};

/**
 * Gets a reader that will read a batch of changes.
 * @return {!Windows.ApplicationModel.Email.EmailMailboxChangeReader} A reader that will read a batch of changes.
 */
Windows.ApplicationModel.Email.EmailMailboxChangeTracker.prototype.getChangeReader = function() {};

/**
 * Moves the change tracking cursor to now.
 * @return {void}
 */
Windows.ApplicationModel.Email.EmailMailboxChangeTracker.prototype.reset = function() {};

/** @const */
Windows.ApplicationModel.Email.EmailMailboxChangeType = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxChangeType.messageCreated;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxChangeType.messageModified;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxChangeType.messageDeleted;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxChangeType.folderCreated;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxChangeType.folderModified;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxChangeType.folderDeleted;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxChangeType.changeTrackingLost;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailMailboxChangedDeferral = function() {};

/**
 * Indicates to waiting processes that the deferral is complete.
 * @return {void}
 */
Windows.ApplicationModel.Email.EmailMailboxChangedDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailMailboxChangedEventArgs = function() {};

/**
 * Gets the deferral object.
 * @return {!Windows.ApplicationModel.Email.EmailMailboxChangedDeferral} The deferral object.
 */
Windows.ApplicationModel.Email.EmailMailboxChangedEventArgs.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailMailboxCreateFolderResult = function() {};
 /** @type {!Windows.ApplicationModel.Email.EmailFolder} */
Windows.ApplicationModel.Email.EmailMailboxCreateFolderResult.prototype.folder;
 /** @type {Windows.ApplicationModel.Email.EmailMailboxCreateFolderStatus} */
Windows.ApplicationModel.Email.EmailMailboxCreateFolderResult.prototype.status;

/** @const */
Windows.ApplicationModel.Email.EmailMailboxCreateFolderStatus = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxCreateFolderStatus.success;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxCreateFolderStatus.networkError;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxCreateFolderStatus.permissionsError;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxCreateFolderStatus.serverError;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxCreateFolderStatus.unknownFailure;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxCreateFolderStatus.nameCollision;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxCreateFolderStatus.serverRejected;

/** @const */
Windows.ApplicationModel.Email.EmailMailboxDeleteFolderStatus = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxDeleteFolderStatus.success;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxDeleteFolderStatus.networkError;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxDeleteFolderStatus.permissionsError;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxDeleteFolderStatus.serverError;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxDeleteFolderStatus.unknownFailure;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxDeleteFolderStatus.couldNotDeleteEverything;

/** @const */
Windows.ApplicationModel.Email.EmailMailboxEmptyFolderStatus = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxEmptyFolderStatus.success;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxEmptyFolderStatus.networkError;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxEmptyFolderStatus.permissionsError;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxEmptyFolderStatus.serverError;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxEmptyFolderStatus.unknownFailure;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxEmptyFolderStatus.couldNotDeleteEverything;

/** @const */
Windows.ApplicationModel.Email.EmailMailboxOtherAppReadAccess = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxOtherAppReadAccess.systemOnly;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxOtherAppReadAccess.full;

/** @const */
Windows.ApplicationModel.Email.EmailMailboxOtherAppWriteAccess = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxOtherAppWriteAccess.none;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxOtherAppWriteAccess.limited;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailMailboxPolicies = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMailboxPolicies.prototype.allowSmimeSoftCertificates;
 /** @type {Windows.ApplicationModel.Email.EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation} */
Windows.ApplicationModel.Email.EmailMailboxPolicies.prototype.allowedSmimeEncryptionAlgorithmNegotiation;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMailboxPolicies.prototype.mustEncryptSmimeMessages;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMailboxPolicies.prototype.mustSignSmimeMessages;
 /** @type {Windows.ApplicationModel.Email.EmailMailboxSmimeEncryptionAlgorithm} */
Windows.ApplicationModel.Email.EmailMailboxPolicies.prototype.requiredSmimeEncryptionAlgorithm;
 /** @type {Windows.ApplicationModel.Email.EmailMailboxSmimeSigningAlgorithm} */
Windows.ApplicationModel.Email.EmailMailboxPolicies.prototype.requiredSmimeSigningAlgorithm;

/** @const */
Windows.ApplicationModel.Email.EmailMailboxSmimeEncryptionAlgorithm = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSmimeEncryptionAlgorithm.any;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSmimeEncryptionAlgorithm.tripleDes;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSmimeEncryptionAlgorithm.des;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSmimeEncryptionAlgorithm.rc2128Bit;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSmimeEncryptionAlgorithm.rc264Bit;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSmimeEncryptionAlgorithm.rc240Bit;

/** @const */
Windows.ApplicationModel.Email.EmailMailboxSmimeSigningAlgorithm = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSmimeSigningAlgorithm.any;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSmimeSigningAlgorithm.sha1;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSmimeSigningAlgorithm.md5;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailMailboxSyncManager = function() {};
 /** @type {!Date} */
Windows.ApplicationModel.Email.EmailMailboxSyncManager.prototype.lastAttemptedSyncTime;
 /** @type {!Date} */
Windows.ApplicationModel.Email.EmailMailboxSyncManager.prototype.lastSuccessfulSyncTime;
 /** @type {function(?): void} */
Windows.ApplicationModel.Email.EmailMailboxSyncManager.prototype.onsyncstatuschanged;
 /** @type {Windows.ApplicationModel.Email.EmailMailboxSyncStatus} */
Windows.ApplicationModel.Email.EmailMailboxSyncManager.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Email.EmailMailboxSyncManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Email.EmailMailboxSyncManager.prototype.removeEventListener = function(type, listener) {};

/**
 * Initiates a sync of this mailbox.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value indicating success.
 */
Windows.ApplicationModel.Email.EmailMailboxSyncManager.prototype.syncAsync = function() {};

/** @const */
Windows.ApplicationModel.Email.EmailMailboxSyncStatus = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSyncStatus.idle;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSyncStatus.syncing;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSyncStatus.upToDate;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSyncStatus.authenticationError;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSyncStatus.policyError;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSyncStatus.unknownError;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMailboxSyncStatus.manualAccountRemovalRequired;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailManager = function() {};

/**
 * Gets an email store that is within the specified scope.
 * @param {Windows.ApplicationModel.Email.EmailStoreAccessType} accessType The enumerator of scope.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailStore, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailStore>>} The requested email store.
 */
Windows.ApplicationModel.Email.EmailManager.requestStoreAsync = function(accessType) {};

/**
 * Launches the email application with a new message displayed.
 * @param {!Windows.ApplicationModel.Email.EmailMessage} message The email message that is displayed when the email application is launched.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.ApplicationModel.Email.EmailManager.showComposeNewEmailAsync = function(message) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the EmailMeetingInfo class.
 */
Windows.ApplicationModel.Email.EmailMeetingInfo = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMeetingInfo.prototype.allowNewTimeProposal;
 /** @type {!Date} */
Windows.ApplicationModel.Email.EmailMeetingInfo.prototype.appointmentOriginalStartTime;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMeetingInfo.prototype.appointmentRoamingId;
 /** @type {number} */
Windows.ApplicationModel.Email.EmailMeetingInfo.prototype.duration;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMeetingInfo.prototype.isAllDay;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMeetingInfo.prototype.isReportedOutOfDateByServer;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMeetingInfo.prototype.isResponseRequested;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMeetingInfo.prototype.location;
 /** @type {number} */
Windows.ApplicationModel.Email.EmailMeetingInfo.prototype.proposedDuration;
 /** @type {!Date} */
Windows.ApplicationModel.Email.EmailMeetingInfo.prototype.proposedStartTime;
 /** @type {!Windows.ApplicationModel.Appointments.AppointmentRecurrence} */
Windows.ApplicationModel.Email.EmailMeetingInfo.prototype.recurrence;
 /** @type {!Date} */
Windows.ApplicationModel.Email.EmailMeetingInfo.prototype.recurrenceStartTime;
 /** @type {number} */
Windows.ApplicationModel.Email.EmailMeetingInfo.prototype.remoteChangeNumber;
 /** @type {!Date} */
Windows.ApplicationModel.Email.EmailMeetingInfo.prototype.startTime;

/** @const */
Windows.ApplicationModel.Email.EmailMeetingResponseType = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMeetingResponseType.accept;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMeetingResponseType.decline;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMeetingResponseType.tentative;

/**
 * @constructor
 * @struct
 * Creates an instance of the EmailMessage class.
 */
Windows.ApplicationModel.Email.EmailMessage = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMessage.prototype.allowInternetImages;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Email.EmailAttachment>} */
Windows.ApplicationModel.Email.EmailMessage.prototype.attachments;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Email.EmailRecipient>} */
Windows.ApplicationModel.Email.EmailMessage.prototype.bcc;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMessage.prototype.body;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Email.EmailRecipient>} */
Windows.ApplicationModel.Email.EmailMessage.prototype.cc;
 /** @type {number} */
Windows.ApplicationModel.Email.EmailMessage.prototype.changeNumber;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMessage.prototype.conversationId;
 /** @type {Windows.ApplicationModel.Email.EmailMessageDownloadState} */
Windows.ApplicationModel.Email.EmailMessage.prototype.downloadState;
 /** @type {number} */
Windows.ApplicationModel.Email.EmailMessage.prototype.estimatedDownloadSizeInBytes;
 /** @type {Windows.ApplicationModel.Email.EmailFlagState} */
Windows.ApplicationModel.Email.EmailMessage.prototype.flagState;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMessage.prototype.folderId;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMessage.prototype.hasPartialBodies;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMessage.prototype.id;
 /** @type {Windows.ApplicationModel.Email.EmailImportance} */
Windows.ApplicationModel.Email.EmailMessage.prototype.importance;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMessage.prototype.inResponseToMessageId;
 /** @type {!Windows.ApplicationModel.Email.EmailIrmInfo} */
Windows.ApplicationModel.Email.EmailMessage.prototype.irmInfo;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMessage.prototype.isDraftMessage;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMessage.prototype.isRead;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMessage.prototype.isSeen;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMessage.prototype.isServerSearchMessage;
 /** @type {boolean} */
Windows.ApplicationModel.Email.EmailMessage.prototype.isSmartSendable;
 /** @type {Windows.ApplicationModel.Email.EmailMessageResponseKind} */
Windows.ApplicationModel.Email.EmailMessage.prototype.lastResponseKind;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMessage.prototype.mailboxId;
 /** @type {!Windows.ApplicationModel.Email.EmailMeetingInfo} */
Windows.ApplicationModel.Email.EmailMessage.prototype.meetingInfo;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMessage.prototype.messageClass;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMessage.prototype.normalizedSubject;
 /** @type {number} */
Windows.ApplicationModel.Email.EmailMessage.prototype.originalCodePage;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMessage.prototype.preview;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMessage.prototype.remoteId;
 /** @type {!Windows.ApplicationModel.Email.EmailRecipient} */
Windows.ApplicationModel.Email.EmailMessage.prototype.sender;
 /** @type {!Date} */
Windows.ApplicationModel.Email.EmailMessage.prototype.sentTime;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Email.EmailMessage.prototype.smimeData;
 /** @type {Windows.ApplicationModel.Email.EmailMessageSmimeKind} */
Windows.ApplicationModel.Email.EmailMessage.prototype.smimeKind;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailMessage.prototype.subject;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Email.EmailRecipient>} */
Windows.ApplicationModel.Email.EmailMessage.prototype.to;

/**
 * Gets the requested email stream such as plain text or HTML.
 * @param {Windows.ApplicationModel.Email.EmailMessageBodyKind} type The kind of message body; plain text or HTML.
 * @return {!Windows.Storage.Streams.IRandomAccessStreamReference} The selected body stream.
 */
Windows.ApplicationModel.Email.EmailMessage.prototype.getBodyStream = function(type) {};

/**
 * Sets the value of the specified body stream in an email message.
 * @param {Windows.ApplicationModel.Email.EmailMessageBodyKind} type Indicates which body stream, plain text or HTML.
 * @param {!Windows.Storage.Streams.IRandomAccessStreamReference} stream The message for the specified body stream.
 * @return {void}
 */
Windows.ApplicationModel.Email.EmailMessage.prototype.setBodyStream = function(type, stream) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailMessageBatch = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Email.EmailMessage>} */
Windows.ApplicationModel.Email.EmailMessageBatch.prototype.messages;
 /** @type {Windows.ApplicationModel.Email.EmailBatchStatus} */
Windows.ApplicationModel.Email.EmailMessageBatch.prototype.status;

/** @const */
Windows.ApplicationModel.Email.EmailMessageBodyKind = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMessageBodyKind.html;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMessageBodyKind.plainText;

/** @const */
Windows.ApplicationModel.Email.EmailMessageDownloadState = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMessageDownloadState.partiallyDownloaded;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMessageDownloadState.downloading;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMessageDownloadState.downloaded;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMessageDownloadState.failed;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailMessageReader = function() {};

/**
 * Reads a collection of email messages.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailMessageBatch, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailMessageBatch>>} A batch of email messages.
 */
Windows.ApplicationModel.Email.EmailMessageReader.prototype.readBatchAsync = function() {};

/** @const */
Windows.ApplicationModel.Email.EmailMessageResponseKind = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMessageResponseKind.none;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMessageResponseKind.reply;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMessageResponseKind.replyAll;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMessageResponseKind.forward;

/** @const */
Windows.ApplicationModel.Email.EmailMessageSmimeKind = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailMessageSmimeKind.none;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMessageSmimeKind.clearSigned;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMessageSmimeKind.opaqueSigned;
/** @const {number} */
Windows.ApplicationModel.Email.EmailMessageSmimeKind.encrypted;

/** @const */
Windows.ApplicationModel.Email.EmailQueryKind = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailQueryKind.all;
/** @const {number} */
Windows.ApplicationModel.Email.EmailQueryKind.important;
/** @const {number} */
Windows.ApplicationModel.Email.EmailQueryKind.flagged;
/** @const {number} */
Windows.ApplicationModel.Email.EmailQueryKind.unread;
/** @const {number} */
Windows.ApplicationModel.Email.EmailQueryKind.read;
/** @const {number} */
Windows.ApplicationModel.Email.EmailQueryKind.unseen;

/**
 * @constructor
 * @struct
 * Instantiates a new instance of the EmailQueryOptions class.
 * Instantiates a new instance of the EmailQueryOptions class.
 * Instantiates a new instance of the EmailQueryOptions class.
 * @param {string=} text The text for which to search.
 * @param {Windows.ApplicationModel.Email.EmailQuerySearchFields=} fields The fields against which to search.
 */
Windows.ApplicationModel.Email.EmailQueryOptions = function(text, fields) {};
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.Email.EmailQueryOptions.prototype.folderIds;
 /** @type {Windows.ApplicationModel.Email.EmailQueryKind} */
Windows.ApplicationModel.Email.EmailQueryOptions.prototype.kind;
 /** @type {Windows.ApplicationModel.Email.EmailQuerySortDirection} */
Windows.ApplicationModel.Email.EmailQueryOptions.prototype.sortDirection;
 /** @type {Windows.ApplicationModel.Email.EmailQuerySortProperty} */
Windows.ApplicationModel.Email.EmailQueryOptions.prototype.sortProperty;
 /** @type {!Windows.ApplicationModel.Email.EmailQueryTextSearch} */
Windows.ApplicationModel.Email.EmailQueryOptions.prototype.textSearch;

/** @const */
Windows.ApplicationModel.Email.EmailQuerySearchFields = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailQuerySearchFields.none;
/** @const {number} */
Windows.ApplicationModel.Email.EmailQuerySearchFields.subject;
/** @const {number} */
Windows.ApplicationModel.Email.EmailQuerySearchFields.sender;
/** @const {number} */
Windows.ApplicationModel.Email.EmailQuerySearchFields.preview;
/** @const {number} */
Windows.ApplicationModel.Email.EmailQuerySearchFields.recipients;
/** @const {number} */
Windows.ApplicationModel.Email.EmailQuerySearchFields.all;

/** @const */
Windows.ApplicationModel.Email.EmailQuerySearchScope = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailQuerySearchScope.local;
/** @const {number} */
Windows.ApplicationModel.Email.EmailQuerySearchScope.server;

/** @const */
Windows.ApplicationModel.Email.EmailQuerySortDirection = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailQuerySortDirection.descending;
/** @const {number} */
Windows.ApplicationModel.Email.EmailQuerySortDirection.ascending;

/** @const */
Windows.ApplicationModel.Email.EmailQuerySortProperty = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailQuerySortProperty.date;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailQueryTextSearch = function() {};
 /** @type {Windows.ApplicationModel.Email.EmailQuerySearchFields} */
Windows.ApplicationModel.Email.EmailQueryTextSearch.prototype.fields;
 /** @type {Windows.ApplicationModel.Email.EmailQuerySearchScope} */
Windows.ApplicationModel.Email.EmailQueryTextSearch.prototype.searchScope;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailQueryTextSearch.prototype.text;

/**
 * @constructor
 * @struct
 * Initializes an instance of the EmailRecipient class.
 * Initializes an instance of the EmailRecipient class.
 * Initializes an instance of the EmailRecipient class.
 * @param {string=} address The address of the recipient.
 * @param {string=} name The name of the recipient.
 */
Windows.ApplicationModel.Email.EmailRecipient = function(address, name) {};
 /** @type {string} */
Windows.ApplicationModel.Email.EmailRecipient.prototype.address;
 /** @type {string} */
Windows.ApplicationModel.Email.EmailRecipient.prototype.name;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailRecipientResolutionResult = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Cryptography.Certificates.Certificate>} */
Windows.ApplicationModel.Email.EmailRecipientResolutionResult.prototype.publicKeys;
 /** @type {Windows.ApplicationModel.Email.EmailRecipientResolutionStatus} */
Windows.ApplicationModel.Email.EmailRecipientResolutionResult.prototype.status;

/** @const */
Windows.ApplicationModel.Email.EmailRecipientResolutionStatus = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailRecipientResolutionStatus.success;
/** @const {number} */
Windows.ApplicationModel.Email.EmailRecipientResolutionStatus.recipientNotFound;
/** @const {number} */
Windows.ApplicationModel.Email.EmailRecipientResolutionStatus.ambiguousRecipient;
/** @const {number} */
Windows.ApplicationModel.Email.EmailRecipientResolutionStatus.noCertificate;
/** @const {number} */
Windows.ApplicationModel.Email.EmailRecipientResolutionStatus.certificateRequestLimitReached;
/** @const {number} */
Windows.ApplicationModel.Email.EmailRecipientResolutionStatus.cannotResolveDistributionList;
/** @const {number} */
Windows.ApplicationModel.Email.EmailRecipientResolutionStatus.serverError;
/** @const {number} */
Windows.ApplicationModel.Email.EmailRecipientResolutionStatus.unknownFailure;

/** @const */
Windows.ApplicationModel.Email.EmailSpecialFolderKind = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailSpecialFolderKind.none;
/** @const {number} */
Windows.ApplicationModel.Email.EmailSpecialFolderKind.root;
/** @const {number} */
Windows.ApplicationModel.Email.EmailSpecialFolderKind.inbox;
/** @const {number} */
Windows.ApplicationModel.Email.EmailSpecialFolderKind.outbox;
/** @const {number} */
Windows.ApplicationModel.Email.EmailSpecialFolderKind.drafts;
/** @const {number} */
Windows.ApplicationModel.Email.EmailSpecialFolderKind.deletedItems;
/** @const {number} */
Windows.ApplicationModel.Email.EmailSpecialFolderKind.sent;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailStore = function() {};

/**
 * Allows an app to create an email account from an account name and an email address.
 * Allows an app to create an email account from an account name, an email address, and the user data account in which the mailbox will reside.
 * @param {string} accountName The name of the account.
 * @param {string} accountAddress The email address associated with the account.
 * @param {string=} userDataAccountId The user data account identifier associated with this user.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailMailbox, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailMailbox>>} An email mailbox.
 */
Windows.ApplicationModel.Email.EmailStore.prototype.createMailboxAsync = function(accountName, accountAddress, userDataAccountId) {};

/**
 * Gets all mailboxes within the current scope.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A collection of mailboxes.
 */
Windows.ApplicationModel.Email.EmailStore.prototype.findMailboxesAsync = function() {};

/**
 * Gets an email conversation from the provided identifier.
 * @param {string} id The identifier of the conversation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailConversation, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailConversation>>} An email conversation.
 */
Windows.ApplicationModel.Email.EmailStore.prototype.getConversationAsync = function(id) {};

/**
 * Gets a batch of email conversations.
 * Gets a batch of email conversations using the specified email query options.
 * @param {!Windows.ApplicationModel.Email.EmailQueryOptions=} options The email query options.
 * @return {!Windows.ApplicationModel.Email.EmailConversationReader} A batch of email conversations.
 */
Windows.ApplicationModel.Email.EmailStore.prototype.getConversationReader = function(options) {};

/**
 * Gets an email folder from an identifier.
 * @param {string} id The identifier for the email folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailFolder, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailFolder>>} The folder described by the identifier.
 */
Windows.ApplicationModel.Email.EmailStore.prototype.getFolderAsync = function(id) {};

/**
 * Gets a mailbox from an identifier.
 * @param {string} id The identifier for the mailbox.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailMailbox, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailMailbox>>} The mailbox described by the identifier.
 */
Windows.ApplicationModel.Email.EmailStore.prototype.getMailboxAsync = function(id) {};

/**
 * Gets the specified email message.
 * @param {string} id The identifier for the email message.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Email.EmailMessage, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Email.EmailMessage>>} The specified email message.
 */
Windows.ApplicationModel.Email.EmailStore.prototype.getMessageAsync = function(id) {};

/**
 * Gets a message reader.
 * Gets a message reader using the specified query options.
 * @param {!Windows.ApplicationModel.Email.EmailQueryOptions=} options Specified query options.
 * @return {!Windows.ApplicationModel.Email.EmailMessageReader} The email message reader. / An email message reader.
 */
Windows.ApplicationModel.Email.EmailStore.prototype.getMessageReader = function(options) {};

/** @const */
Windows.ApplicationModel.Email.EmailStoreAccessType = {};
/** @const {number} */
Windows.ApplicationModel.Email.EmailStoreAccessType.appMailboxesReadWrite;
/** @const {number} */
Windows.ApplicationModel.Email.EmailStoreAccessType.allMailboxesLimitedReadWrite;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Email.EmailStoreNotificationTriggerDetails = function() {};
/** @const */
Windows.ApplicationModel.ExtendedExecution = {};

/** @const */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionReason = {};
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionReason.unspecified;
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionReason.locationTracking;
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionReason.savingData;

/** @const */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionResult = {};
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionResult.allowed;
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionResult.denied;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionRevokedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionRevokedReason} */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionRevokedEventArgs.prototype.reason;

/** @const */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionRevokedReason = {};
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionRevokedReason.resumed;
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionRevokedReason.systemPolicy;

/**
 * @constructor
 * @struct
 * Creates an ExtendedExecutionSession object.
 */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionSession = function() {};
 /** @type {string} */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionSession.prototype.description;
 /** @type {function(?): void} */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionSession.prototype.onrevoked;
 /** @type {number} */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionSession.prototype.percentProgress;
 /** @type {Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionReason} */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionSession.prototype.reason;

/**
 * Closes the session and removes the application's capability to run in the background.
 * @return {void}
 */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionSession.prototype.close = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionSession.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionSession.prototype.removeEventListener = function(type, listener) {};

/**
 * Requests background execution.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionResult, !Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionResult>>} The result of the request.
 */
Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionSession.prototype.requestExtensionAsync = function() {};
/** @const */
Windows.ApplicationModel.ExtendedExecution.Foreground = {};

/** @const */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundReason = {};
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundReason.unspecified;
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundReason.savingData;
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundReason.backgroundAudio;
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundReason.unconstrained;

/** @const */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundResult = {};
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundResult.allowed;
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundResult.denied;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundRevokedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundRevokedReason} */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundRevokedEventArgs.prototype.reason;

/** @const */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundRevokedReason = {};
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundRevokedReason.resumed;
/** @const {number} */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundRevokedReason.systemPolicy;

/**
 * @constructor
 * @struct
 * Creates an ExtendedExecutionForegroundSession object
 */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundSession = function() {};
 /** @type {string} */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundSession.prototype.description;
 /** @type {function(?): void} */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundSession.prototype.onrevoked;
 /** @type {Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundReason} */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundSession.prototype.reason;

/**
 * Closes the session and removes the application's extended execution capability.
 * @return {void}
 */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundSession.prototype.close = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundSession.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundSession.prototype.removeEventListener = function(type, listener) {};

/**
 * Requests extended execution
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundResult, !Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundResult>>} The result of the request.
 */
Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundSession.prototype.requestExtensionAsync = function() {};
/** @const */
Windows.ApplicationModel.LockScreen = {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.LockScreen.LockApplicationHost = function() {};
 /** @type {function(?): void} */
Windows.ApplicationModel.LockScreen.LockApplicationHost.prototype.onunlocking;

/**
 * Gets a LockApplicationHost object.
 * @return {!Windows.ApplicationModel.LockScreen.LockApplicationHost} A LockApplicationHost object.
 */
Windows.ApplicationModel.LockScreen.LockApplicationHost.getForCurrentView = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.LockScreen.LockApplicationHost.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.LockScreen.LockApplicationHost.prototype.removeEventListener = function(type, listener) {};

/**
 * Requests that the device unlocks.
 * @return {void}
 */
Windows.ApplicationModel.LockScreen.LockApplicationHost.prototype.requestUnlock = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.LockScreen.LockScreenBadge = function() {};
 /** @type {string} */
Windows.ApplicationModel.LockScreen.LockScreenBadge.prototype.automationName;
 /** @type {!Windows.Storage.Streams.IRandomAccessStream} */
Windows.ApplicationModel.LockScreen.LockScreenBadge.prototype.glyph;
 /** @type {!Windows.Storage.Streams.IRandomAccessStream} */
Windows.ApplicationModel.LockScreen.LockScreenBadge.prototype.logo;
 /** @type {number} */
Windows.ApplicationModel.LockScreen.LockScreenBadge.prototype.number;

/**
 * Launches the app corresponding to the badge.
 * @return {void}
 */
Windows.ApplicationModel.LockScreen.LockScreenBadge.prototype.launchApp = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.LockScreen.LockScreenInfo = function() {};
 /** @type {!Windows.Storage.Streams.IRandomAccessStream} */
Windows.ApplicationModel.LockScreen.LockScreenInfo.prototype.alarmIcon;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.LockScreen.LockScreenBadge>} */
Windows.ApplicationModel.LockScreen.LockScreenInfo.prototype.badges;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.ApplicationModel.LockScreen.LockScreenInfo.prototype.detailText;
 /** @type {!Windows.Storage.Streams.IRandomAccessStream} */
Windows.ApplicationModel.LockScreen.LockScreenInfo.prototype.lockScreenImage;
 /** @type {function(?): void} */
Windows.ApplicationModel.LockScreen.LockScreenInfo.prototype.onalarmiconchanged;
 /** @type {function(?): void} */
Windows.ApplicationModel.LockScreen.LockScreenInfo.prototype.onbadgeschanged;
 /** @type {function(?): void} */
Windows.ApplicationModel.LockScreen.LockScreenInfo.prototype.ondetailtextchanged;
 /** @type {function(?): void} */
Windows.ApplicationModel.LockScreen.LockScreenInfo.prototype.onlockscreenimagechanged;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.LockScreen.LockScreenInfo.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.LockScreen.LockScreenInfo.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.LockScreen.LockScreenUnlockingDeferral = function() {};

/**
 * Notifies the system that your deferral is complete. If your deferral takes too long to complete, your lock screen app will be terminated by the system and potentially removed as the users default lock app.
 * @return {void}
 */
Windows.ApplicationModel.LockScreen.LockScreenUnlockingDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.LockScreen.LockScreenUnlockingEventArgs = function() {};
 /** @type {!Date} */
Windows.ApplicationModel.LockScreen.LockScreenUnlockingEventArgs.prototype.deadline;

/**
 * Gets a LockScreenUnlockingDeferral , which defers the unlocking of the device.
 * @return {!Windows.ApplicationModel.LockScreen.LockScreenUnlockingDeferral} An unlock deferral.
 */
Windows.ApplicationModel.LockScreen.LockScreenUnlockingEventArgs.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Package = function() {};
 /** @type {!Windows.ApplicationModel.Package} */
Windows.ApplicationModel.Package.current;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Package>} */
Windows.ApplicationModel.Package.prototype.dependencies;
 /** @type {string} */
Windows.ApplicationModel.Package.prototype.description;
 /** @type {string} */
Windows.ApplicationModel.Package.prototype.displayName;
 /** @type {?} */
Windows.ApplicationModel.Package.prototype.getAppListEntriesAsync;
 /** @type {!Windows.ApplicationModel.PackageId} */
Windows.ApplicationModel.Package.prototype.id;
 /** @type {!Date} */
Windows.ApplicationModel.Package.prototype.installDate;
 /** @type {!Date} */
Windows.ApplicationModel.Package.prototype.installedDate;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.ApplicationModel.Package.prototype.installedLocation;
 /** @type {boolean} */
Windows.ApplicationModel.Package.prototype.isBundle;
 /** @type {boolean} */
Windows.ApplicationModel.Package.prototype.isDevelopmentMode;
 /** @type {boolean} */
Windows.ApplicationModel.Package.prototype.isFramework;
 /** @type {boolean} */
Windows.ApplicationModel.Package.prototype.isResourcePackage;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.Package.prototype.logo;
 /** @type {string} */
Windows.ApplicationModel.Package.prototype.publisherDisplayName;
 /** @type {?} */
Windows.ApplicationModel.Package.prototype.status;

/**
 * Windows Phone only. Returns a token that can be used to retrieve the thumbnail image associated with this application package.
 * @return {string} A token that can be used to retrieve the thumbnail image associated with this application package.
 */
Windows.ApplicationModel.Package.prototype.getThumbnailToken = function() {};

/**
 * Windows Phone only. Launches the specified application.
 * @param {string} parameters The navigation URI that specifies the page to launch and optional parameters. Use an empty string to specify the default page for the app.
 * @return {void}
 */
Windows.ApplicationModel.Package.prototype.launch = function(parameters) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.PackageId = function() {};
 /** @type {Windows.System.ProcessorArchitecture} */
Windows.ApplicationModel.PackageId.prototype.architecture;
 /** @type {string} */
Windows.ApplicationModel.PackageId.prototype.author;
 /** @type {string} */
Windows.ApplicationModel.PackageId.prototype.familyName;
 /** @type {string} */
Windows.ApplicationModel.PackageId.prototype.fullName;
 /** @type {string} */
Windows.ApplicationModel.PackageId.prototype.name;
 /** @type {string} */
Windows.ApplicationModel.PackageId.prototype.productId;
 /** @type {string} */
Windows.ApplicationModel.PackageId.prototype.publisher;
 /** @type {string} */
Windows.ApplicationModel.PackageId.prototype.publisherId;
 /** @type {string} */
Windows.ApplicationModel.PackageId.prototype.resourceId;
 /** @type {!Windows.ApplicationModel.PackageVersion} */
Windows.ApplicationModel.PackageId.prototype.version;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.PackageStatus = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.PackageStatus.prototype.dataOffline;
 /** @type {boolean} */
Windows.ApplicationModel.PackageStatus.prototype.dependencyIssue;
 /** @type {boolean} */
Windows.ApplicationModel.PackageStatus.prototype.deploymentInProgress;
 /** @type {boolean} */
Windows.ApplicationModel.PackageStatus.prototype.disabled;
 /** @type {boolean} */
Windows.ApplicationModel.PackageStatus.prototype.licenseIssue;
 /** @type {boolean} */
Windows.ApplicationModel.PackageStatus.prototype.modified;
 /** @type {boolean} */
Windows.ApplicationModel.PackageStatus.prototype.needsRemediation;
 /** @type {boolean} */
Windows.ApplicationModel.PackageStatus.prototype.notAvailable;
 /** @type {boolean} */
Windows.ApplicationModel.PackageStatus.prototype.packageOffline;
 /** @type {boolean} */
Windows.ApplicationModel.PackageStatus.prototype.servicing;
 /** @type {boolean} */
Windows.ApplicationModel.PackageStatus.prototype.tampered;

/**
 * Indicates whether the package is in good condition and may be used.
 * @return {boolean} TRUE indicates that the package is in good condition; otherwise FALSE.
 */
Windows.ApplicationModel.PackageStatus.prototype.verifyIsOK = function() {};
/** @const */
Windows.ApplicationModel.Resources = {};
/** @const */
Windows.ApplicationModel.Resources.Core = {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Resources.Core.NamedResource = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Resources.Core.ResourceCandidate>} */
Windows.ApplicationModel.Resources.Core.NamedResource.prototype.candidates;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.Resources.Core.NamedResource.prototype.uri;

/**
 * Resolves this NamedResource object against a supplied context and returns the most appropriate candidate.
 * Resolves this NamedResource object against the default context and returns the most appropriate candidate.
 * @param {!Windows.ApplicationModel.Resources.Core.ResourceContext=} resourceContext The context against which the NamedResource should be resolved.
 * @return {!Windows.ApplicationModel.Resources.Core.ResourceCandidate} The most appropriate candidate for the specified context. / The most appropriate candidate for the default context.
 */
Windows.ApplicationModel.Resources.Core.NamedResource.prototype.resolve = function(resourceContext) {};

/**
 * Resolves this NamedResource object against a supplied context and returns a list of all possible candidates in preference order.
 * Resolves this NamedResource object against the default context and returns a list of all possible candidates in preference order.
 * @param {!Windows.ApplicationModel.Resources.Core.ResourceContext=} resourceContext The context against which the NamedResource should be resolved.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Resources.Core.ResourceCandidate>} A list of ResourceCandidate objects, in order of preference. The object in first position in the list is the most appropriate candidate for the corresponding context, and the object in last position is the least appropriate.
 */
Windows.ApplicationModel.Resources.Core.NamedResource.prototype.resolveAll = function(resourceContext) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Resources.Core.ResourceCandidate = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Resources.Core.ResourceCandidate.prototype.isDefault;
 /** @type {boolean} */
Windows.ApplicationModel.Resources.Core.ResourceCandidate.prototype.isMatch;
 /** @type {boolean} */
Windows.ApplicationModel.Resources.Core.ResourceCandidate.prototype.isMatchAsDefault;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Resources.Core.ResourceQualifier>} */
Windows.ApplicationModel.Resources.Core.ResourceCandidate.prototype.qualifiers;
 /** @type {string} */
Windows.ApplicationModel.Resources.Core.ResourceCandidate.prototype.valueAsString;

/**
 * Returns the value of a qualifier, given its name.
 * @param {string} qualifierName The name of the qualifier.
 * @return {string} The value of the qualifier.
 */
Windows.ApplicationModel.Resources.Core.ResourceCandidate.prototype.getQualifierValue = function(qualifierName) {};

/**
 * Asynchronously returns a StorageFile that accesses the value of this ResourceCandidate . This only works on certain types of ResourceCandidates that are files.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} An asynchronous operation to return the requested StorageFile .
 */
Windows.ApplicationModel.Resources.Core.ResourceCandidate.prototype.getValueAsFileAsync = function() {};

/**
 * Asynchronously returns an IRandomAccessStream that accesses the value of this ResourceCandidate .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStream, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStream>>} An asynchronous operation to return the requested IRandomAccessStream .
 */
Windows.ApplicationModel.Resources.Core.ResourceCandidate.prototype.getValueAsStreamAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Resources.Core.ResourceCandidateVectorView = function() {};
 /** @type {number} */
Windows.ApplicationModel.Resources.Core.ResourceCandidateVectorView.prototype.size;

/**
 * Returns an iterator to enumerate the items in the set of ResourceCandidate objects.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.ApplicationModel.Resources.Core.ResourceCandidate>} The iterator. The current position of the iterator is index 0, or the end of the set if the set is empty.
 */
Windows.ApplicationModel.Resources.Core.ResourceCandidateVectorView.prototype.first = function() {};

/**
 * Returns the ResourceCandidate at the specified index in the set.
 * @param {number} index The zero-based index of the ResourceCandidate in the set to return.
 * @return {!Windows.ApplicationModel.Resources.Core.ResourceCandidate} The ResourceCandidate at the specified index.
 */
Windows.ApplicationModel.Resources.Core.ResourceCandidateVectorView.prototype.getAt = function(index) {};

/**
 * Returns the ResourceCandidate objects that start at the specified index in the set.
 * @param {number} startIndex The zero-based index of the start of the ResourceCandidate objects in the set to return.
 * @return {{items: !Windows.ApplicationModel.Resources.Core.ResourceCandidate, returnValue: number}}
 */
Windows.ApplicationModel.Resources.Core.ResourceCandidateVectorView.prototype.getMany = function(startIndex) {};

/**
 * Returns the index of a specified ResourceCandidate in the set.
 * @param {!Windows.ApplicationModel.Resources.Core.ResourceCandidate} value_or_searchElement The ResourceCandidate to find in the set.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.ApplicationModel.Resources.Core.ResourceCandidateVectorView.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};

/**
 * @constructor
 * @struct
 * Creates a cloned ResourceContext object.
 */
Windows.ApplicationModel.Resources.Core.ResourceContext = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.ApplicationModel.Resources.Core.ResourceContext.prototype.languages;
 /** @type {!Windows.Foundation.Collections.IObservableMap<string, string>} */
Windows.ApplicationModel.Resources.Core.ResourceContext.prototype.qualifierValues;

/**
 * Creates a new ResourceContext that matches a supplied set of qualifiers.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.ApplicationModel.Resources.Core.ResourceQualifier>} result The list of qualifiers to be matched.
 * @return {!Windows.ApplicationModel.Resources.Core.ResourceContext} The new ResourceContext .
 */
Windows.ApplicationModel.Resources.Core.ResourceContext.createMatchingContext = function(result) {};

/**
 * Gets a default ResourceContext associated with the current view for the currently running application.
 * @return {!Windows.ApplicationModel.Resources.Core.ResourceContext} The default context associated with the current view.
 */
Windows.ApplicationModel.Resources.Core.ResourceContext.getForCurrentView = function() {};

/**
 * Gets a default ResourceContext not associated with any view.
 * @return {!Windows.ApplicationModel.Resources.Core.ResourceContext} A default ResourceContext not associated with any view.
 */
Windows.ApplicationModel.Resources.Core.ResourceContext.getForViewIndependentUse = function() {};

/**
 * Removes any qualifier overrides from default contexts of all views across the app.
 * Removes qualifier overrides for the specified qualifiers from default contexts of all views across the app.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} qualifierNames The names of the qualifiers to be reset.
 * @return {void}
 */
Windows.ApplicationModel.Resources.Core.ResourceContext.resetGlobalQualifierValues = function(qualifierNames) {};

/**
 * Applies a single qualifier value override to default contexts of all views for the current app.
 * Applies a single qualifier value override to default contexts of all views for the current app, and specifies the persistence of the override.
 * @param {string} key The name of the qualifier to override.
 * @param {string} value The override value to set.
 * @param {Windows.ApplicationModel.Resources.Core.ResourceQualifierPersistence=} persistence The persistence of the override value.
 * @return {void}
 */
Windows.ApplicationModel.Resources.Core.ResourceContext.setGlobalQualifierValue = function(key, value, persistence) {};

/**
 * Creates a clone of this ResourceContext , with identical qualifiers.
 * @return {!Windows.ApplicationModel.Resources.Core.ResourceContext} A new, cloned ResourceContext .
 */
Windows.ApplicationModel.Resources.Core.ResourceContext.prototype.clone = function() {};

/**
 * Overrides the qualifier values supplied by this context to match a specified list of resolved ResourceQualifier s. Typically the resolved ResourceQualifiers are associated with a resource that was looked up earlier.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.ApplicationModel.Resources.Core.ResourceQualifier>} result The ResourceQualifier s to be applied to the context.
 * @return {void}
 */
Windows.ApplicationModel.Resources.Core.ResourceContext.prototype.overrideToMatch = function(result) {};

/**
 * Resets the overridden values for the specified qualifiers on the given ResourceContext instance.
 * Resets the overridden values for all qualifiers on the given ResourceContext instance.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} qualifierNames The names of the qualifiers to be reset.
 * @return {void}
 */
Windows.ApplicationModel.Resources.Core.ResourceContext.prototype.reset = function(qualifierNames) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Resources.Core.ResourceContextLanguagesVectorView = function() {};
 /** @type {number} */
Windows.ApplicationModel.Resources.Core.ResourceContextLanguagesVectorView.prototype.size;

/**
 * Returns an iterator to enumerate the items in the set of ResourceContext language qualifiers.
 * @return {!Windows.Foundation.Collections.IIterator<string>} The iterator. The current position of the iterator is index 0, or the end of the set if the set is empty.
 */
Windows.ApplicationModel.Resources.Core.ResourceContextLanguagesVectorView.prototype.first = function() {};

/**
 * Returns the ResourceContext language qualifier at the specified index in the set.
 * @param {number} index The zero-based index of the ResourceContext language qualifier in the set to return.
 * @return {string} The ResourceContext language qualifier at the specified index.
 */
Windows.ApplicationModel.Resources.Core.ResourceContextLanguagesVectorView.prototype.getAt = function(index) {};

/**
 * Returns the ResourceContext language qualifiers that start at the specified index in the set.
 * @param {number} startIndex The zero-based index of the start of the ResourceContext language qualifiers in the set to return.
 * @return {{items: !Array<string>, returnValue: number}}
 */
Windows.ApplicationModel.Resources.Core.ResourceContextLanguagesVectorView.prototype.getMany = function(startIndex) {};

/**
 * Returns the index of a specified ResourceContext language qualifier in the set.
 * @param {string} value_or_searchElement The ResourceContext language qualifier to find in the set.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.ApplicationModel.Resources.Core.ResourceContextLanguagesVectorView.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Resources.Core.ResourceManager = function() {};
 /** @type {!Windows.ApplicationModel.Resources.Core.ResourceManager} */
Windows.ApplicationModel.Resources.Core.ResourceManager.current;
 /** @type {!Windows.Foundation.Collections.IMapView<string, !Windows.ApplicationModel.Resources.Core.ResourceMap>} */
Windows.ApplicationModel.Resources.Core.ResourceManager.prototype.allResourceMaps;
 /** @type {!Windows.ApplicationModel.Resources.Core.ResourceContext} */
Windows.ApplicationModel.Resources.Core.ResourceManager.prototype.defaultContext;
 /** @type {!Windows.ApplicationModel.Resources.Core.ResourceMap} */
Windows.ApplicationModel.Resources.Core.ResourceManager.prototype.mainResourceMap;

/**
 * Determines whether a supplied string matches the resource reference format (an ms-resource string URI identifier).
 * @param {string} resourceReference The string you want to match.
 * @return {boolean} TRUE if the string matches.
 */
Windows.ApplicationModel.Resources.Core.ResourceManager.isResourceReference = function(resourceReference) {};

/**
 * Gets a list of all named resources for an app package.
 * @param {string} packageName The name of the app package.
 * @param {!Windows.ApplicationModel.Resources.Core.ResourceLayoutInfo} resourceLayoutInfo Specifies the resource version and the named resource count.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Resources.Core.NamedResource>} A list of NamedResource objects.
 */
Windows.ApplicationModel.Resources.Core.ResourceManager.prototype.getAllNamedResourcesForPackage = function(packageName, resourceLayoutInfo) {};

/**
 * Gets a list of all collections of resource subtrees for an app package.
 * @param {string} packageName The name of the app package.
 * @param {!Windows.ApplicationModel.Resources.Core.ResourceLayoutInfo} resourceLayoutInfo Specifies the resource version and the resource subtree count.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Resources.Core.ResourceMap>} A list of resource subtrees ( ResourceMap objects).
 */
Windows.ApplicationModel.Resources.Core.ResourceManager.prototype.getAllSubtreesForPackage = function(packageName, resourceLayoutInfo) {};

/**
 * Loads one or more PRI files and adds their contents to the default resource manager.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Storage.IStorageFile>} files The files you want to add.
 * @return {void}
 */
Windows.ApplicationModel.Resources.Core.ResourceManager.prototype.loadPriFiles = function(files) {};

/**
 * Unloads one or more PRI files.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Storage.IStorageFile>} files The files you want unloaded.
 * @return {void}
 */
Windows.ApplicationModel.Resources.Core.ResourceManager.prototype.unloadPriFiles = function(files) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Resources.Core.ResourceMap = function() {};
 /** @type {number} */
Windows.ApplicationModel.Resources.Core.ResourceMap.prototype.size;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.Resources.Core.ResourceMap.prototype.uri;

/**
 * Returns an iterator to enumerate the items in the map.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The iterator. The current position of the iterator is index 0, or the end of the set if the map is empty.
 */
Windows.ApplicationModel.Resources.Core.ResourceMap.prototype.first = function() {};

/**
 * Returns a ResourceMap that represents a subtree of another ResourceMap, typically used to access a particular resource file within an app package.
 * @param {string} reference A resource map identifier that identifies the root of the new subtree.
 * @return {!Windows.ApplicationModel.Resources.Core.ResourceMap} The subtree ResourceMap .
 */
Windows.ApplicationModel.Resources.Core.ResourceMap.prototype.getSubtree = function(reference) {};

/**
 * Returns the most appropriate candidate for a resource that is specified by a resource identifier for the supplied context.
 * Returns the most appropriate candidate for a resource that is specified by a resource identifier within the default context.
 * @param {string} resource A resource specified as a name or reference. / A resource identifier specified as a name or reference.
 * @param {!Windows.ApplicationModel.Resources.Core.ResourceContext=} context The context for which to select the most appropriate candidate.
 * @return {!Windows.ApplicationModel.Resources.Core.ResourceCandidate} A ResourceCandidate that describes the most appropriate candidate.
 */
Windows.ApplicationModel.Resources.Core.ResourceMap.prototype.getValue = function(resource, context) {};

/**
 * Determines whether the map can retrieve a resource with the specified resource identifier.
 * @param {string} key The resource identifier to locate in the map.
 * @return {boolean} TRUE if the key is found, otherwise FALSE.
 */
Windows.ApplicationModel.Resources.Core.ResourceMap.prototype.hasKey = function(key) {};

/**
 * Returns the NamedResource at the specified resource identifier in the map.
 * @param {string} key The resource identifier to use to locate the resource in the map.
 * @return {!Windows.ApplicationModel.Resources.Core.NamedResource} The NamedResource associated with the specified key.
 */
Windows.ApplicationModel.Resources.Core.ResourceMap.prototype.lookup = function(key) {};

/**
 * Splits the map view into two views.
 * @return {{first: !Windows.Foundation.Collections.IMapView<string, !Windows.ApplicationModel.Resources.Core.NamedResource>, second: !Windows.Foundation.Collections.IMapView<string, !Windows.ApplicationModel.Resources.Core.NamedResource>}}
 */
Windows.ApplicationModel.Resources.Core.ResourceMap.prototype.split = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Resources.Core.ResourceMapIterator = function() {};
 /** @type {!Windows.Foundation.Collections.IKeyValuePair<string, !Windows.ApplicationModel.Resources.Core.NamedResource>} */
Windows.ApplicationModel.Resources.Core.ResourceMapIterator.prototype.current;
 /** @type {boolean} */
Windows.ApplicationModel.Resources.Core.ResourceMapIterator.prototype.hasCurrent;

/**
 * Returns all the items in the ResourceMap .
 * @return {{items: !Windows.Foundation.Collections.IKeyValuePair<?, ?>, returnValue: number}}
 */
Windows.ApplicationModel.Resources.Core.ResourceMapIterator.prototype.getMany = function() {};

/**
 * Moves the iterator forward to the next item and returns HasCurrent .
 * @return {boolean} TRUE if the iterator refers to a valid item that is in the map, and otherwise FALSE.
 */
Windows.ApplicationModel.Resources.Core.ResourceMapIterator.prototype.moveNext = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Resources.Core.ResourceMapMapView = function() {};
 /** @type {number} */
Windows.ApplicationModel.Resources.Core.ResourceMapMapView.prototype.size;

/**
 * Returns an iterator to enumerate the items in the map view.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The iterator. The current position of the iterator is index 0, or the end of the map if the map is empty.
 */
Windows.ApplicationModel.Resources.Core.ResourceMapMapView.prototype.first = function() {};

/**
 * Determines whether the map view contains the specified key.
 * @param {string} key The key to locate in the map view.
 * @return {boolean} TRUE if the key is found, otherwise FALSE if it is not found.
 */
Windows.ApplicationModel.Resources.Core.ResourceMapMapView.prototype.hasKey = function(key) {};

/**
 * Returns the ResourceMap at the specified key in the map view.
 * @param {string} key The key to locate in the map view.
 * @return {!Windows.ApplicationModel.Resources.Core.ResourceMap} The ResourceMap associated with the specified key.
 */
Windows.ApplicationModel.Resources.Core.ResourceMapMapView.prototype.lookup = function(key) {};

/**
 * Splits the map view into two views.
 * @return {{first: !Windows.Foundation.Collections.IMapView<string, !Windows.ApplicationModel.Resources.Core.ResourceMap>, second: !Windows.Foundation.Collections.IMapView<string, !Windows.ApplicationModel.Resources.Core.ResourceMap>}}
 */
Windows.ApplicationModel.Resources.Core.ResourceMapMapView.prototype.split = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Resources.Core.ResourceMapMapViewIterator = function() {};
 /** @type {!Windows.Foundation.Collections.IKeyValuePair<string, !Windows.ApplicationModel.Resources.Core.ResourceMap>} */
Windows.ApplicationModel.Resources.Core.ResourceMapMapViewIterator.prototype.current;
 /** @type {boolean} */
Windows.ApplicationModel.Resources.Core.ResourceMapMapViewIterator.prototype.hasCurrent;

/**
 * Returns all the items in the ResourceMapMapView .
 * @return {{items: !Windows.Foundation.Collections.IKeyValuePair<?, ?>, returnValue: number}}
 */
Windows.ApplicationModel.Resources.Core.ResourceMapMapViewIterator.prototype.getMany = function() {};

/**
 * Moves the iterator forward to the next item and returns HasCurrent .
 * @return {boolean} TRUE if the iterator refers to a valid item that is in the map view, and otherwise FALSE.
 */
Windows.ApplicationModel.Resources.Core.ResourceMapMapViewIterator.prototype.moveNext = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifier = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Resources.Core.ResourceQualifier.prototype.isDefault;
 /** @type {boolean} */
Windows.ApplicationModel.Resources.Core.ResourceQualifier.prototype.isMatch;
 /** @type {string} */
Windows.ApplicationModel.Resources.Core.ResourceQualifier.prototype.qualifierName;
 /** @type {string} */
Windows.ApplicationModel.Resources.Core.ResourceQualifier.prototype.qualifierValue;
 /** @type {number} */
Windows.ApplicationModel.Resources.Core.ResourceQualifier.prototype.score;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierMapView = function() {};
 /** @type {number} */
Windows.ApplicationModel.Resources.Core.ResourceQualifierMapView.prototype.size;

/**
 * Returns an iterator to enumerate the items in the map view.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The iterator. The current position of the iterator is index 0, or the end of the map view if the map view is empty.
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierMapView.prototype.first = function() {};

/**
 * Determines whether the map view contains the specified key.
 * @param {string} key The key to locate in the map view.
 * @return {boolean} TRUE if the key is found, otherwise FALSE if it is not found.
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierMapView.prototype.hasKey = function(key) {};

/**
 * Returns the qualifier name at the specified key in the map view.
 * @param {string} key The key to locate in the map view.
 * @return {string} The qualifier name associated with the specified key.
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierMapView.prototype.lookup = function(key) {};

/**
 * Splits the map view into two views.
 * @return {{first: !Windows.Foundation.Collections.IMapView<string, string>, second: !Windows.Foundation.Collections.IMapView<string, string>}}
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierMapView.prototype.split = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierObservableMap = function() {};
 /** @type {function(?): void} */
Windows.ApplicationModel.Resources.Core.ResourceQualifierObservableMap.prototype.onmapchanged;
 /** @type {number} */
Windows.ApplicationModel.Resources.Core.ResourceQualifierObservableMap.prototype.size;

/**
 * Removes all items from the observable map.
 * @return {void}
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierObservableMap.prototype.clear = function() {};

/**
 * Returns an iterator to enumerate the items in the observable map.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The iterator. The current position of the iterator is index 0, or the end of the observable map if the observable map is empty.
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierObservableMap.prototype.first = function() {};

/**
 * Returns an unchangeable view of the observable map.
 * @return {!Windows.Foundation.Collections.IMapView<string, string>} The view of the map.
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierObservableMap.prototype.getView = function() {};

/**
 * Determines whether the observable map contains the specified key.
 * @param {string} key The key to locate in the observable map.
 * @return {boolean} TRUE if the key is found, otherwise FALSE if it is not found.
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierObservableMap.prototype.hasKey = function(key) {};

/**
 * Inserts or replaces an item in the observable map.
 * @param {string} key The key associated with the item to insert.
 * @param {string} value The item to insert.
 * @return {boolean} TRUE if an item with the specified key is an existing item and was replaced, otherwise FALSE.
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierObservableMap.prototype.insert = function(key, value) {};

/**
 * Returns the qualifier name at the specified key in the observable map.
 * @param {string} key The key to locate in the observable map.
 * @return {string} The qualifier name associated with the specified key.
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierObservableMap.prototype.lookup = function(key) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierObservableMap.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierObservableMap.prototype.removeEventListener = function(type, listener) {};

/**
 * Removes an item from the observable map.
 * @param {string} key The key associated with the item to remove.
 * @return {void}
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierObservableMap.prototype.remove = function(key) {};

/** @const */
Windows.ApplicationModel.Resources.Core.ResourceQualifierPersistence = {};
/** @const {number} */
Windows.ApplicationModel.Resources.Core.ResourceQualifierPersistence.none;
/** @const {number} */
Windows.ApplicationModel.Resources.Core.ResourceQualifierPersistence.localMachine;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierVectorView = function() {};
 /** @type {number} */
Windows.ApplicationModel.Resources.Core.ResourceQualifierVectorView.prototype.size;

/**
 * Returns an iterator to enumerate the items in the view.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.ApplicationModel.Resources.Core.ResourceQualifier>} The iterator. The current position of the iterator is index 0, or the end of the view if the view is empty.
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierVectorView.prototype.first = function() {};

/**
 * Returns the ResourceQualifier at the specified index in the view.
 * @param {number} index The zero-based index of the ResourceQualifier in the view to return.
 * @return {!Windows.ApplicationModel.Resources.Core.ResourceQualifier} The ResourceQualifier at the specified index.
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierVectorView.prototype.getAt = function(index) {};

/**
 * Returns the ResourceQualifier objects that start at the specified index in the view.
 * @param {number} startIndex The zero-based index of the start of the objects in the view to return.
 * @return {{items: !Windows.ApplicationModel.Resources.Core.ResourceQualifier, returnValue: number}}
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierVectorView.prototype.getMany = function(startIndex) {};

/**
 * Returns the index of a specified ResourceQualifier in the view.
 * @param {!Windows.ApplicationModel.Resources.Core.ResourceQualifier} value_or_searchElement The ResourceQualifier to find in the set.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.ApplicationModel.Resources.Core.ResourceQualifierVectorView.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};
/**
 * @record
 * @struct
 */
Windows.ApplicationModel.Resources.Core.ResourceLayoutInfo = function() {};
 /** @type {number} */
Windows.ApplicationModel.Resources.Core.ResourceLayoutInfo.prototype.checksum;
 /** @type {number} */
Windows.ApplicationModel.Resources.Core.ResourceLayoutInfo.prototype.majorVersion;
 /** @type {number} */
Windows.ApplicationModel.Resources.Core.ResourceLayoutInfo.prototype.minorVersion;
 /** @type {number} */
Windows.ApplicationModel.Resources.Core.ResourceLayoutInfo.prototype.namedResourceCount;
 /** @type {number} */
Windows.ApplicationModel.Resources.Core.ResourceLayoutInfo.prototype.resourceSubtreeCount;
/** @const */
Windows.ApplicationModel.Resources.Management = {};

/** @const */
Windows.ApplicationModel.Resources.Management.IndexedResourceType = {};
/** @const {number} */
Windows.ApplicationModel.Resources.Management.IndexedResourceType.string;
/** @const {number} */
Windows.ApplicationModel.Resources.Management.IndexedResourceType.path;
/** @const {number} */
Windows.ApplicationModel.Resources.Management.IndexedResourceType.embeddedData;

/**
 * @constructor
 * @struct
 * Constructs a new ResourceLoader object for the specified ResourceMap .
 * Constructs a new ResourceLoader object for the "Resources" subtree of the currently running app's main ResourceMap .
 * @param {string=} name The resource identifier of the ResourceMap that the new resource loader uses for unqualified resource references. It can then retrieve resources relative to those references.
 */
Windows.ApplicationModel.Resources.ResourceLoader = function(name) {};

/**
 * Gets a ResourceLoader object for the Resources subtree of the currently running app's main ResourceMap . This ResourceLoader uses a default context associated with the current view.
 * Gets a ResourceLoader object for the specified ResourceMap . This ResourceLoader uses a default context associated with the current view.
 * @param {string=} name The resource identifier of the ResourceMap that the new resource loader uses for unqualified resource references. The loader can then retrieve resources relative to those references.
 * @return {!Windows.ApplicationModel.Resources.ResourceLoader} A resource loader for the Resources subtree of the currently running app's main ResourceMap . / A resource loader for the specified ResourceMap .
 */
Windows.ApplicationModel.Resources.ResourceLoader.getForCurrentView = function(name) {};

/**
 * Gets a ResourceLoader object for the specified ResourceMap . This ResourceLoader uses a default context that's not associated with any view.
 * Gets a ResourceLoader object for the Resources subtree of the currently running app's main ResourceMap . This ResourceLoader uses a default context that's not associated with any view.
 * @param {string=} name The resource identifier of the ResourceMap that the new resource loader uses for unqualified resource references. The loader can then retrieve resources relative to those references.
 * @return {!Windows.ApplicationModel.Resources.ResourceLoader} A resource loader for the Resources subtree of the currently running app's main ResourceMap . This ResourceLoader uses a default context that's not associated with any view. You can't use this ResourceLoader to retrieve any resource that has resource candidates qualified for scale.
 */
Windows.ApplicationModel.Resources.ResourceLoader.getForViewIndependentUse = function(name) {};

/**
 * Returns the most appropriate string value of a resource, specified as a Uri for a resource identifier, for the default ResourceContext of the currently running app.
 * @param {!Windows.Foundation.Uri} uri A Uri that represents the resource to be retrieved.
 * @return {string} The most appropriate string value of the specified resource for the default ResourceContext .
 */
Windows.ApplicationModel.Resources.ResourceLoader.getStringForReference = function(uri) {};

/**
 * Returns the most appropriate string value of a resource, specified by resource identifier, for the default ResourceContext of the view in which the ResourceLoader was obtained using ResourceLoader.GetForCurrentView .
 * @param {string} resource The resource identifier of the resource to be resolved.
 * @return {string} The most appropriate string value of the specified resource for the default ResourceContext .
 */
Windows.ApplicationModel.Resources.ResourceLoader.prototype.getString = function(resource) {};

/**
 * Returns the most appropriate string value of a resource, specified by a Uniform Resource Identifier (URI) resource identifier, for the default ResourceContext of the currently running app.
 * @param {!Windows.Foundation.Uri} uri A URI that represents the resource to be retrieved.
 * @return {string} The most appropriate string value of the specified resource for the default ResourceContext .
 */
Windows.ApplicationModel.Resources.ResourceLoader.prototype.getStringForUri = function(uri) {};
/** @const */
Windows.ApplicationModel.Search = {};
/** @const */
Windows.ApplicationModel.Search.Core = {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.Core.RequestingFocusOnKeyboardInputEventArgs = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.Core.SearchSuggestion = function() {};
 /** @type {string} */
Windows.ApplicationModel.Search.Core.SearchSuggestion.prototype.detailText;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Search.Core.SearchSuggestion.prototype.image;
 /** @type {string} */
Windows.ApplicationModel.Search.Core.SearchSuggestion.prototype.imageAlternateText;
 /** @type {Windows.ApplicationModel.Search.Core.SearchSuggestionKind} */
Windows.ApplicationModel.Search.Core.SearchSuggestion.prototype.kind;
 /** @type {string} */
Windows.ApplicationModel.Search.Core.SearchSuggestion.prototype.tag;
 /** @type {string} */
Windows.ApplicationModel.Search.Core.SearchSuggestion.prototype.text;

/** @const */
Windows.ApplicationModel.Search.Core.SearchSuggestionKind = {};
/** @const {number} */
Windows.ApplicationModel.Search.Core.SearchSuggestionKind.query;
/** @const {number} */
Windows.ApplicationModel.Search.Core.SearchSuggestionKind.result;
/** @const {number} */
Windows.ApplicationModel.Search.Core.SearchSuggestionKind.separator;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the SearchSuggestionManager class.
 */
Windows.ApplicationModel.Search.Core.SearchSuggestionManager = function() {};
 /** @type {function(?): void} */
Windows.ApplicationModel.Search.Core.SearchSuggestionManager.prototype.onrequestingfocusonkeyboardinput;
 /** @type {function(?): void} */
Windows.ApplicationModel.Search.Core.SearchSuggestionManager.prototype.onsuggestionsrequested;
 /** @type {string} */
Windows.ApplicationModel.Search.Core.SearchSuggestionManager.prototype.searchHistoryContext;
 /** @type {boolean} */
Windows.ApplicationModel.Search.Core.SearchSuggestionManager.prototype.searchHistoryEnabled;
 /** @type {!Windows.Foundation.Collections.IObservableVector<!Windows.ApplicationModel.Search.Core.SearchSuggestion>} */
Windows.ApplicationModel.Search.Core.SearchSuggestionManager.prototype.suggestions;

/**
 * Stores the specified query and input language in the search history.
 * Stores the specified query in the search history.
 * @param {string} queryText The query.
 * @param {string=} language The input language. The input language ensures that the query string is displayed in the search history for the correct language.
 * @return {void}
 */
Windows.ApplicationModel.Search.Core.SearchSuggestionManager.prototype.addToHistory = function(queryText, language) {};

/**
 * Clears all search history contexts for the current app.
 * @return {void}
 */
Windows.ApplicationModel.Search.Core.SearchSuggestionManager.prototype.clearHistory = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Search.Core.SearchSuggestionManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Search.Core.SearchSuggestionManager.prototype.removeEventListener = function(type, listener) {};

/**
 * Specifies whether suggestions based on local files are added automatically to the Suggestions collection, and defines the criteria that Windows uses to locate and filter these suggestions.
 * @param {!Windows.ApplicationModel.Search.LocalContentSuggestionSettings} settings The new settings for local content suggestions.
 * @return {void}
 */
Windows.ApplicationModel.Search.Core.SearchSuggestionManager.prototype.setLocalContentSuggestionSettings = function(settings) {};

/**
 * Assigns the current search query with the specified input language and Input Method Editor (IME) info.
 * Assigns the current search query.
 * Assigns the current search query with the specified input language.
 * @param {string} queryText The query.
 * @param {string=} language The input language.
 * @param {!Windows.ApplicationModel.Search.SearchQueryLinguisticDetails=} linguisticDetails Info about the query text that the user enters through an IME.
 * @return {void}
 */
Windows.ApplicationModel.Search.Core.SearchSuggestionManager.prototype.setQuery = function(queryText, language, linguisticDetails) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.Core.SearchSuggestionsRequestedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Search.Core.SearchSuggestionsRequestedEventArgs.prototype.language;
 /** @type {!Windows.ApplicationModel.Search.SearchQueryLinguisticDetails} */
Windows.ApplicationModel.Search.Core.SearchSuggestionsRequestedEventArgs.prototype.linguisticDetails;
 /** @type {string} */
Windows.ApplicationModel.Search.Core.SearchSuggestionsRequestedEventArgs.prototype.queryText;
 /** @type {!Windows.ApplicationModel.Search.SearchSuggestionsRequest} */
Windows.ApplicationModel.Search.Core.SearchSuggestionsRequestedEventArgs.prototype.request;

/**
 * @constructor
 * @struct
 * Creates a new instance of the localContentSuggestionSettings class.
 */
Windows.ApplicationModel.Search.LocalContentSuggestionSettings = function() {};
 /** @type {string} */
Windows.ApplicationModel.Search.LocalContentSuggestionSettings.prototype.aqsFilter;
 /** @type {boolean} */
Windows.ApplicationModel.Search.LocalContentSuggestionSettings.prototype.enabled;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Storage.StorageFolder>} */
Windows.ApplicationModel.Search.LocalContentSuggestionSettings.prototype.locations;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.ApplicationModel.Search.LocalContentSuggestionSettings.prototype.propertiesToMatch;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.SearchPane = function() {};
 /** @type {string} */
Windows.ApplicationModel.Search.SearchPane.prototype.language;
 /** @type {function(?): void} */
Windows.ApplicationModel.Search.SearchPane.prototype.onquerychanged;
 /** @type {function(?): void} */
Windows.ApplicationModel.Search.SearchPane.prototype.onquerysubmitted;
 /** @type {function(?): void} */
Windows.ApplicationModel.Search.SearchPane.prototype.onresultsuggestionchosen;
 /** @type {function(?): void} */
Windows.ApplicationModel.Search.SearchPane.prototype.onsuggestionsrequested;
 /** @type {function(?): void} */
Windows.ApplicationModel.Search.SearchPane.prototype.onvisibilitychanged;
 /** @type {string} */
Windows.ApplicationModel.Search.SearchPane.prototype.placeholderText;
 /** @type {string} */
Windows.ApplicationModel.Search.SearchPane.prototype.queryText;
 /** @type {string} */
Windows.ApplicationModel.Search.SearchPane.prototype.searchHistoryContext;
 /** @type {boolean} */
Windows.ApplicationModel.Search.SearchPane.prototype.searchHistoryEnabled;
 /** @type {boolean} */
Windows.ApplicationModel.Search.SearchPane.prototype.showOnKeyboardInput;
 /** @type {boolean} */
Windows.ApplicationModel.Search.SearchPane.prototype.visible;

/**
 * Retrieves an instance of the search pane from which users can search within the app.
 * @return {!Windows.ApplicationModel.Search.SearchPane} An instance of the search pane, which provides a consistent, touch-friendly search box and optional search suggestions for searching within the current application.
 */
Windows.ApplicationModel.Search.SearchPane.getForCurrentView = function() {};

/**
 * Hides the current app's UI.
 * @return {void}
 */
Windows.ApplicationModel.Search.SearchPane.hideThisApplication = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Search.SearchPane.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Search.SearchPane.prototype.removeEventListener = function(type, listener) {};

/**
 * Specifies whether suggestions based on local files are automatically displayed in the search pane, and defines the criteria that Windows uses to locate and filter these suggestions.
 * @param {!Windows.ApplicationModel.Search.LocalContentSuggestionSettings} settings The new settings for local content suggestions.
 * @return {void}
 */
Windows.ApplicationModel.Search.SearchPane.prototype.setLocalContentSuggestionSettings = function(settings) {};

/**
 * Shows the search pane.
 * Shows the search pane with the specified initial query string.
 * @param {string=} query The initial query string.
 * @return {void}
 */
Windows.ApplicationModel.Search.SearchPane.prototype.show = function(query) {};

/**
 * Attempts to set the text in the search box of the search pane.
 * @param {string} query The query text to show in the search pane's search box.
 * @return {boolean} True if the search box text was set successfully. Otherwise, false.
 */
Windows.ApplicationModel.Search.SearchPane.prototype.trySetQueryText = function(query) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs.prototype.language;
 /** @type {!Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails} */
Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs.prototype.linguisticDetails;
 /** @type {string} */
Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs.prototype.queryText;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails.prototype.queryTextAlternatives;
 /** @type {number} */
Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails.prototype.queryTextCompositionLength;
 /** @type {number} */
Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails.prototype.queryTextCompositionStart;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs.prototype.language;
 /** @type {!Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails} */
Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs.prototype.linguisticDetails;
 /** @type {string} */
Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs.prototype.queryText;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs.prototype.tag;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest.prototype.isCanceled;
 /** @type {!Windows.ApplicationModel.Search.SearchSuggestionCollection} */
Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest.prototype.searchSuggestionCollection;

/**
 * Retrieves an object that lets an app respond to a request for suggestions asynchronously.
 * @return {!Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral} An object that lets an app signal when it has fulfilled the request for search suggestions.
 */
Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral = function() {};

/**
 * Signals that the app has finished populating a searchSuggestionCollection object while handling the suggestionsrequested event.
 * @return {void}
 */
Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs = function() {};
 /** @type {string} */
Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs.prototype.language;
 /** @type {!Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails} */
Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs.prototype.linguisticDetails;
 /** @type {string} */
Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs.prototype.queryText;
 /** @type {!Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest} */
Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs.prototype.request;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs.prototype.visible;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the SearchQueryLinguisticDetails class.
 * @param {!Windows.Foundation.Collections.IIterable<string>} queryTextAlternatives A list of the text alternatives for the current query text.
 * @param {number} queryTextCompositionStart The starting location of the text that the user is composing with an IME.
 * @param {number} queryTextCompositionLength The length of the portion of the query text that the user is composing with an IME.
 */
Windows.ApplicationModel.Search.SearchQueryLinguisticDetails = function(queryTextAlternatives, queryTextCompositionStart, queryTextCompositionLength) {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.ApplicationModel.Search.SearchQueryLinguisticDetails.prototype.queryTextAlternatives;
 /** @type {number} */
Windows.ApplicationModel.Search.SearchQueryLinguisticDetails.prototype.queryTextCompositionLength;
 /** @type {number} */
Windows.ApplicationModel.Search.SearchQueryLinguisticDetails.prototype.queryTextCompositionStart;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.SearchSuggestionCollection = function() {};
 /** @type {number} */
Windows.ApplicationModel.Search.SearchSuggestionCollection.prototype.size;

/**
 * Appends a query suggestion to the list of search suggestions for the search pane.
 * @param {string} text The text of the query suggestion.
 * @return {void}
 */
Windows.ApplicationModel.Search.SearchSuggestionCollection.prototype.appendQuerySuggestion = function(text) {};

/**
 * Appends a list of query suggestions to the list of search suggestions for the search pane.
 * @param {!Windows.Foundation.Collections.IIterable<string>} suggestions The list of query suggestions.
 * @return {void}
 */
Windows.ApplicationModel.Search.SearchSuggestionCollection.prototype.appendQuerySuggestions = function(suggestions) {};

/**
 * Appends a suggested search result to the list of suggestions to display in the search pane.
 * @param {string} text The text of the suggested result.
 * @param {string} detailText The detail text for the suggested result.
 * @param {string} tag The unique tag that identifies this suggested result.
 * @param {!Windows.Storage.Streams.IRandomAccessStreamReference} image The image to accompany the results suggestion.
 * @param {string} imageAlternateText The alternate text for the image.
 * @return {void}
 */
Windows.ApplicationModel.Search.SearchSuggestionCollection.prototype.appendResultSuggestion = function(text, detailText, tag, image, imageAlternateText) {};

/**
 * Appends a text label that is used to separate groups of suggestions in the search pane.
 * @param {string} label The text to use as a separator. This text should be descriptive of any suggestions that are appended after it.
 * @return {void}
 */
Windows.ApplicationModel.Search.SearchSuggestionCollection.prototype.appendSearchSeparator = function(label) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.SearchSuggestionsRequest = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.Search.SearchSuggestionsRequest.prototype.isCanceled;
 /** @type {!Windows.ApplicationModel.Search.SearchSuggestionCollection} */
Windows.ApplicationModel.Search.SearchSuggestionsRequest.prototype.searchSuggestionCollection;

/**
 * Gets an object that lets an app respond to a request for suggestions asynchronously.
 * @return {!Windows.ApplicationModel.Search.SearchSuggestionsRequestDeferral} An object that lets an app signal when it has fulfilled the request for search suggestions.
 */
Windows.ApplicationModel.Search.SearchSuggestionsRequest.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Search.SearchSuggestionsRequestDeferral = function() {};

/**
 * Signals that the app has finished populating a SearchSuggestionCollection object while handling the SuggestionsRequested event.
 * @return {void}
 */
Windows.ApplicationModel.Search.SearchSuggestionsRequestDeferral.prototype.complete = function() {};
/** @const */
Windows.ApplicationModel.Store = {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.CurrentApp = function() {};
 /** @type {string} */
Windows.ApplicationModel.Store.CurrentApp.appId;
 /** @type {?} */
Windows.ApplicationModel.Store.CurrentApp.getCustomerCollectionsIdAsync;
 /** @type {?} */
Windows.ApplicationModel.Store.CurrentApp.getCustomerPurchaseIdAsync;
 /** @type {!Windows.ApplicationModel.Store.LicenseInformation} */
Windows.ApplicationModel.Store.CurrentApp.licenseInformation;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.Store.CurrentApp.linkUri;

/**
 * Retrieves the promotion campaign ID for the current app.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} The advertising campaign ID for your app.
 */
Windows.ApplicationModel.Store.CurrentApp.getAppPurchaseCampaignIdAsync = function() {};

/**
 * Requests all receipts for the purchase of the app and any in-app products. For examples of how receipt information can be used, see Using receipts to verify product purchases.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} An XML-formatted string that contains all receipt information for the purchase of the app and any in-app products.
 */
Windows.ApplicationModel.Store.CurrentApp.getAppReceiptAsync = function() {};

/**
 * Requests the receipt for the productId specified. For examples of how receipt information can be used, see Using receipts to verify product purchases.
 * @param {string} productId The unique identifier for the product that you specified this identifier when you submitted the app to the Windows Store
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} An XML-formatted string that contains the receipt for the specified productId.
 */
Windows.ApplicationModel.Store.CurrentApp.getProductReceiptAsync = function(productId) {};

/**
 * Returns a list of purchased consumable in-app products that have not been reported to the Windows Store as fulfilled.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When the operation completes, a list of consumable in-app products not yet reported as fulfilled is returned ( UnfulfilledConsumable objects). Each item of this list provides the product ID, offer ID, and transaction ID associated with a product.
 */
Windows.ApplicationModel.Store.CurrentApp.getUnfulfilledConsumablesAsync = function() {};

/**
 * Loads the app's listing information asynchronously. Implements the IAsyncInfo interface.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Store.ListingInformation, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Store.ListingInformation>>} The apps' listing information. If the method fails, it returns an HRESULT error code.
 */
Windows.ApplicationModel.Store.CurrentApp.loadListingInformationAsync = function() {};

/**
 * Windows Phone only. Loads the app listing information asynchronously, returning features and products in the ProductListings collection that match all supplied keywords. Implements the IAsyncInfo interface.
 * @param {!Windows.Foundation.Collections.IIterable<string>} keywords The list of keywords by which to filter the ProductListings collection that is returned in the ListingInformation object.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Store.ListingInformation, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Store.ListingInformation>>} The app's listing information, with ProductListings collection filtered by keywords. If the method fails, it returns an HRESULT error code. If no products or features are found that match all of the given keywords, the ProductListings collection will be empty.
 */
Windows.ApplicationModel.Store.CurrentApp.loadListingInformationByKeywordsAsync = function(keywords) {};

/**
 * Windows Phone only. Loads the app listing information asynchronously, returning features and products in the ProductListings collection that match any of the given products IDs. Implements the IAsyncInfo interface.
 * @param {!Windows.Foundation.Collections.IIterable<string>} productIds The list of product IDs by which to filter the ProductListings collection.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Store.ListingInformation, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Store.ListingInformation>>} The app's listing information, with ProductListings collection filtered by product IDs. If the method fails, it returns an HRESULT error code. If no products or features are found that match the given product IDs, the ProductListings collection will be empty.
 */
Windows.ApplicationModel.Store.CurrentApp.loadListingInformationByProductIdsAsync = function(productIds) {};

/**
 * Notifies the Windows Store that the purchase of a consumable is fulfilled and that the user has the right to access the content.
 * @param {string} productId Identifies the consumable.
 * @param {string} transactionId Identifies a transaction that includes the purchase of the consumable ( productId).
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.ApplicationModel.Store.FulfillmentResult, !Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Store.FulfillmentResult>>} A value that indicates the status of fulfillment for a consumable in-app product. Possible values are defined by the FulfillmentResult enumeration.
 */
Windows.ApplicationModel.Store.CurrentApp.reportConsumableFulfillmentAsync = function(productId, transactionId) {};

/**
 * Notifies the Windows Store that the application has fulfilled the in-app product. This product cannot be re-purchased until the app has confirmed fulfillment using this method.
 * @param {string} productId The ID of the product that has been delivered to the user.
 * @return {void}
 */
Windows.ApplicationModel.Store.CurrentApp.reportProductFulfillment = function(productId) {};

/**
 * Requests the purchase of a full app license.
 * @param {boolean} includeReceipt Determines if this method should return the receipts for this app.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} If the includeReceipt parameter is set to true, this string contains XML that represents all receipts for the app and any in-app purchases. If includeReceipt is set to false, this string is empty.
 */
Windows.ApplicationModel.Store.CurrentApp.requestAppPurchaseAsync = function(includeReceipt) {};

/**
 * Requests the purchase of an in-app product. Additionally, calling this method displays the UI that is used to complete the transaction via the Windows Store.
 * Requests the purchase of an in-app product. Additionally, calling this method displays the UI that is used to complete the transaction via the Windows Store.
 * Requests the purchase of an in-app product. Additionally, calling this method displays the UI that is used to complete the transaction via the Windows Store.
 * @param {string} productId Specifies the id of the in-app product.
 * @param {string|boolean=} offerId_or_includeReceipt The specific in-app feature or content within the large purchase catalog represented on the Windows Store by the productId. This value correlates with the content your app is responsible for fulfilling. The Windows Store only uses this value to itemize the PurchaseResults . / Determines if the method should return the receipts for the specified productId.
 * @param {!Windows.ApplicationModel.Store.ProductPurchaseDisplayProperties=} displayProperties The name of the app feature or content offer that is displayed to the user at time of purchase.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Store.PurchaseResults, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Store.PurchaseResults>>|!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} The results of the in-app product purchase request. / A string providing in-app transaction details for the provided productId. If includeReceipt is set true, the returned string will include a full receipt xml.
 */
Windows.ApplicationModel.Store.CurrentApp.requestProductPurchaseAsync = function(productId, offerId_or_includeReceipt, displayProperties) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.CurrentAppSimulator = function() {};
 /** @type {string} */
Windows.ApplicationModel.Store.CurrentAppSimulator.appId;
 /** @type {!Windows.ApplicationModel.Store.LicenseInformation} */
Windows.ApplicationModel.Store.CurrentAppSimulator.licenseInformation;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.Store.CurrentAppSimulator.linkUri;

/**
 * Retrieves the promotion campaign ID for the current app.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} The advertising campaign ID for your app.
 */
Windows.ApplicationModel.Store.CurrentAppSimulator.getAppPurchaseCampaignIdAsync = function() {};

/**
 * Creates the async operation that the user can use to simulate requesting all receipts for this app and any in-app product purchases. For examples of how receipt information can be used, see Using receipts to verify product purchases.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} An XML-formatted string that contains all receipts for this app and any in-app product purchases.
 */
Windows.ApplicationModel.Store.CurrentAppSimulator.getAppReceiptAsync = function() {};

/**
 * Creates the async operation that the user can use to simulate requesting the receipt for the specified productId. For examples of how receipt information can be used, see Using receipts to verify product purchases.
 * @param {string} productId The unique identifier for the product. This ID is that was specified when the product was submitted for the app to the Store.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} An XML-formatted string that contains the receipt for the specified productId.
 */
Windows.ApplicationModel.Store.CurrentAppSimulator.getProductReceiptAsync = function(productId) {};

/**
 * Returns a list of purchased consumable in-app products that have not been fulfilled locally.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When the operation completes, a list of unfulfilled consumable in-app products ( UnfulfilledConsumable objects) is returned. Each item in this list provides the product ID, offer ID, and transaction ID associated with a product.
 */
Windows.ApplicationModel.Store.CurrentAppSimulator.getUnfulfilledConsumablesAsync = function() {};

/**
 * Loads the simulated app listing information asynchronously. Implements the IAsyncInfo interface.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Store.ListingInformation, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Store.ListingInformation>>} The app listing information as defined by the simulation. If the method fails, it returns an HRESULT error code.
 */
Windows.ApplicationModel.Store.CurrentAppSimulator.loadListingInformationAsync = function() {};

/**
 * Windows Phone only. Loads the simulated app listing information asynchronously, returning in-app products in the ProductListings collection that match all supplied keywords. Implements the IAsyncInfo interface.
 * @param {!Windows.Foundation.Collections.IIterable<string>} keywords The list of keywords by which to filter the ProductListings collection that is returned in the ListingInformation object.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Store.ListingInformation, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Store.ListingInformation>>} The simulated app listing information, with ProductListings collection filtered by keywords. If the method fails, it returns an HRESULT error code. If no in-app products are found that match all of the given keywords, the ProductListings collection will be empty.
 */
Windows.ApplicationModel.Store.CurrentAppSimulator.loadListingInformationByKeywordsAsync = function(keywords) {};

/**
 * Windows Phone only. Loads the simulated app listing information asynchronously, returning available in-app products in the ProductListings collection that match any of the given products IDs. This method implements the IAsyncInfo interface.
 * @param {!Windows.Foundation.Collections.IIterable<string>} productIds The list of product IDs by which to filter the ProductListings collection.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Store.ListingInformation, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Store.ListingInformation>>} The simulated app listing information, with ProductListings collection filtered by product IDs. If the method fails, it returns an HRESULT error code. If no in-app products are found that match the given product IDs, the ProductListings collection will be empty.
 */
Windows.ApplicationModel.Store.CurrentAppSimulator.loadListingInformationByProductIdsAsync = function(productIds) {};

/**
 * Reloads the simulator using a StorageFile containing the WindowsStoreProxy.xml file.
 * @param {!Windows.Storage.StorageFile} simulatorSettingsFile The WindowsStoreProxy.xml file that the simulator uses. For more information, see CurrentAppSimulator .
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The async operation that reloads the simulator.
 */
Windows.ApplicationModel.Store.CurrentAppSimulator.reloadSimulatorAsync = function(simulatorSettingsFile) {};

/**
 * Simulates notifying the Windows Store that the purchase of a consumable in-app product is fulfilled and that the user has the right to access the content.
 * @param {string} productId Identifies the consumable in-app product.
 * @param {string} transactionId Identifies a simulated transaction that includes the purchase of the consumable in-app product ( productId).
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.ApplicationModel.Store.FulfillmentResult, !Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Store.FulfillmentResult>>} A value that indicates the status of fulfillment for a simulated consumable in-app product purchase.
 */
Windows.ApplicationModel.Store.CurrentAppSimulator.reportConsumableFulfillmentAsync = function(productId, transactionId) {};

/**
 * Creates the async operation that simulates a user request to buy a full license for the current app.
 * @param {boolean} includeReceipt Determines if the method should return the receipts for this app.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} If the includeReceipt parameter is set to true, this string contains XML that represents all receipts for the app and any in-app product purchases. If includeReceipt is set to false, this string is empty.
 */
Windows.ApplicationModel.Store.CurrentAppSimulator.requestAppPurchaseAsync = function(includeReceipt) {};

/**
 * Creates the async operation that displays the UI that is used to simulate the purchase of in-app product from the Windows Store.
 * Creates the async operation that displays the UI that is used to simulate the purchase of an in-app product from the Windows Store.
 * Creates the async operation that displays the UI that is used to simulate the purchase of an in-app product from the Windows Store.
 * @param {string} productId Specifies the id, as defined by the simulation, of the in-app product to buy. / The product ID used for listing in the Windows Store.
 * @param {string|boolean=} offerId_or_includeReceipt The specific in-app product within the large purchase catalog represented on the Windows Store by the productId. This value correlates with the content your app is responsible for fulfilling. The Windows Store only uses this parameter value to itemize the PurchaseResults . / Determines if the method should return the receipts for the specified productId.
 * @param {!Windows.ApplicationModel.Store.ProductPurchaseDisplayProperties=} displayProperties The name of the in-app product that is displayed to the user at time of purchase.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Store.PurchaseResults, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Store.PurchaseResults>>|!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} A PurchaseResults object containing transaction details for the provided productId. / The results of the in-app product purchase. / A string providing in-app product purchase details for the provided productId. If includeReceipt is set true, the returned string will include a full receipt xml.
 */
Windows.ApplicationModel.Store.CurrentAppSimulator.requestProductPurchaseAsync = function(productId, offerId_or_includeReceipt, displayProperties) {};

/** @const */
Windows.ApplicationModel.Store.FulfillmentResult = {};
/** @const {number} */
Windows.ApplicationModel.Store.FulfillmentResult.succeeded;
/** @const {number} */
Windows.ApplicationModel.Store.FulfillmentResult.nothingToFulfill;
/** @const {number} */
Windows.ApplicationModel.Store.FulfillmentResult.purchasePending;
/** @const {number} */
Windows.ApplicationModel.Store.FulfillmentResult.purchaseReverted;
/** @const {number} */
Windows.ApplicationModel.Store.FulfillmentResult.serverError;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.LicenseInformation = function() {};
 /** @type {!Date} */
Windows.ApplicationModel.Store.LicenseInformation.prototype.expirationDate;
 /** @type {boolean} */
Windows.ApplicationModel.Store.LicenseInformation.prototype.isActive;
 /** @type {boolean} */
Windows.ApplicationModel.Store.LicenseInformation.prototype.isTrial;
 /** @type {function(!Windows.WinRTEvent<void>): void} */
Windows.ApplicationModel.Store.LicenseInformation.prototype.onlicensechanged;
 /** @type {!Windows.Foundation.Collections.IMapView<string, !Windows.ApplicationModel.Store.ProductLicense>} */
Windows.ApplicationModel.Store.LicenseInformation.prototype.productLicenses;

/**
 * @param {string} type
 * @param {function(!Windows.WinRTEvent<void>): void|function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Store.LicenseInformation.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(!Windows.WinRTEvent<void>): void|function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Store.LicenseInformation.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.ListingInformation = function() {};
 /** @type {number} */
Windows.ApplicationModel.Store.ListingInformation.prototype.ageRating;
 /** @type {?} */
Windows.ApplicationModel.Store.ListingInformation.prototype.currencyCode;
 /** @type {string} */
Windows.ApplicationModel.Store.ListingInformation.prototype.currentMarket;
 /** @type {string} */
Windows.ApplicationModel.Store.ListingInformation.prototype.description;
 /** @type {?} */
Windows.ApplicationModel.Store.ListingInformation.prototype.formattedBasePrice;
 /** @type {string} */
Windows.ApplicationModel.Store.ListingInformation.prototype.formattedPrice;
 /** @type {?} */
Windows.ApplicationModel.Store.ListingInformation.prototype.isOnSale;
 /** @type {string} */
Windows.ApplicationModel.Store.ListingInformation.prototype.name;
 /** @type {!Windows.Foundation.Collections.IMapView<string, !Windows.ApplicationModel.Store.ProductListing>} */
Windows.ApplicationModel.Store.ListingInformation.prototype.productListings;
 /** @type {?} */
Windows.ApplicationModel.Store.ListingInformation.prototype.saleEndDate;
/** @const */
Windows.ApplicationModel.Store.Preview = {};
/** @const */
Windows.ApplicationModel.Store.Preview.InstallControl = {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem = function() {};
 /** @type {Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallType} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem.prototype.installType;
 /** @type {boolean} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem.prototype.isUserInitiated;
 /** @type {function(?): void} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem.prototype.oncompleted;
 /** @type {function(?): void} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem.prototype.onstatuschanged;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem.prototype.packageFamilyName;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem.prototype.productId;

/**
 * Cancels the installation of the current app.
 * Cancels the installation of the current app, with the option to generate telemetry data.
 * @param {string=} correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return {void}
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem.prototype.cancel = function(correlationVector) {};

/**
 * Gets the installation status of the current app.
 * @return {!Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallStatus} A value that specifies the installation status of the current app.
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem.prototype.getCurrentStatus = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem.prototype.removeEventListener = function(type, listener) {};

/**
 * Pauses the installation of the current app.
 * Pauses the installation of the current app, with the option to generate telemetry data.
 * @param {string=} correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return {void}
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem.prototype.pause = function(correlationVector) {};

/**
 * Restarts the installation of the current app.
 * Restarts the installation of the current app, with the option to generate telemetry data.
 * @param {string=} correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return {void}
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem.prototype.restart = function(correlationVector) {};

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the AppInstallManager class
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager = function() {};
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.acquisitionIdentity;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem>} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.appInstallItems;
 /** @type {Windows.ApplicationModel.Store.Preview.InstallControl.AutoUpdateSetting} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.autoUpdateSetting;
 /** @type {function(?): void} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.onitemcompleted;
 /** @type {function(?): void} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.onitemstatuschanged;

/**
 * Cancels the installation of the specified app.
 * Cancels the installation of the specified app, with the option to generate telemetry data.
 * @param {string} productId The product ID of the app whose installation should be canceled.
 * @param {string=} correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return {void}
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.cancel = function(productId, correlationVector) {};

/**
 * Determines whether the specified app has permission to install on the current computer or device.
 * Determines whether the specified app has permission to install on the current computer or device, with the option to generate telemetry data.
 * @param {string} productId The product ID of the app that this method will check to determine if it has permission to be installed.
 * @param {string=} skuId The SKU ID of the app that this method will check to determine if it has permission to be installed.
 * @param {string=} catalogId The catalog ID of the app that this method will check to determine if it has permission to be installed.
 * @param {string=} correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An asynchronous operation that, on successful completion, returns true if the app has permission to be installed; otherwise false.
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.getIsAppAllowedToInstallAsync = function(productId, skuId, catalogId, correlationVector) {};

/**
 * Determines whether the specified app can be installed on the current computer or device.
 * @param {string} productId The product ID of the app that this method will check to determine if it can be installed.
 * @param {string} skuId The SKU ID of the app that this method will check to determine if it can be installed.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An asynchronous operation that, on successful completion, returns true if the app can be installed; otherwise false.
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.getIsApplicableAsync = function(productId, skuId) {};

/**
 * Determines whether the specified app is blocked by policy on the current computer or device.
 * @param {string} storeClientName The name of the app that this method will check to determine if is blocked by policy.
 * @param {string} storeClientPublisher The publisher name of the app that this method will check to determine if is blocked by policy.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An asynchronous operation that, on successful completion, returns true if the app can be installed; otherwise false.
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.isStoreBlockedByPolicyAsync = function(storeClientName, storeClientPublisher) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.removeEventListener = function(type, listener) {};

/**
 * Pauses the installation of the specified app.
 * Pauses the installation of the specified app, with the option to generate telemetry data.
 * @param {string} productId The product ID of the app whose installation should be paused.
 * @param {string=} correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return {void}
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.pause = function(productId, correlationVector) {};

/**
 * Restarts the installation of the specified app.
 * Restarts the installation of the specified app, with the option to generate telemetry data.
 * @param {string} productId The product ID of the app whose installation should be restarted.
 * @param {string=} correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return {void}
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.restart = function(productId, correlationVector) {};

/**
 * Searches for all available updates to apps installed on the current computer or device.
 * Searches for all available updates to apps installed on the current computer or device, with the option to generate telemetry data.
 * @param {string=} correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that, on successful completion, returns the collection of apps that have available updates. If you use Asynchronous programming, the result type is a read-only list/vector of AppInstallItem items. (You can use APIs of IVectorView<AppInstallItem> for C++ or JavaScript, APIs of IReadOnlyList<AppInstallItem> for .NET.)
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.searchForAllUpdatesAsync = function(correlationVector) {};

/**
 * Searches for updates for the specified app.
 * Searches for updates for the specified app, with the option to generate telemetry data.
 * @param {string} productId The product ID of the app to be queried for updates.
 * @param {string} skuId The SKU to be queried for updates. / The SKU ID of the app to be queried for updates.
 * @param {string=} catalogId The catalog ID of the app to be queried for updates.
 * @param {string=} correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem>>} An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the available update.
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.searchForUpdatesAsync = function(productId, skuId, catalogId, correlationVector) {};

/**
 * Starts the installation of the specified app.
 * Starts the installation of the specified app, with the option to generate telemetry data.
 * @param {string} productId The product ID of the app to install.
 * @param {string} skuId The SKU ID of the app to install.
 * @param {boolean} repair True to attempt to repair the installation of an app that is already installed; otherwise, false.
 * @param {boolean} forceUseOfNonRemovableStorage True to install the app to non-removable storage even if the user has configured apps to install to SD card; false to install the app to non-removable storage or SD card according to the user's settings.
 * @param {string=} catalogId The catalog ID of the app to install.
 * @param {string=} bundleId The bundle ID of the app to install.
 * @param {string=} correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem>>} An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the app that was added to the installation queue.
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.startAppInstallAsync = function(productId, skuId, repair, forceUseOfNonRemovableStorage, catalogId, bundleId, correlationVector) {};

/**
 * Starts the update of an app specified by the package family name.
 * Starts the update of an app specified by the package family name, with the option to generate telemetry data.
 * @param {string} packageFamilyName The package family name of the app to update.
 * @param {string=} correlationVector A correlation vector string that can be used to generate telemetry data.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem>>} An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the app update that was added to the installation queue.
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager.prototype.updateAppByPackageFamilyNameAsync = function(packageFamilyName, correlationVector) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManagerItemEventArgs = function() {};
 /** @type {!Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManagerItemEventArgs.prototype.item;

/** @const */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState = {};
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState.pending;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState.starting;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState.acquiringLicense;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState.downloading;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState.restoringData;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState.installing;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState.completed;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState.canceled;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState.paused;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState.error;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState.pausedLowBattery;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState.pausedWiFiRecommended;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState.pausedWiFiRequired;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState.readyToDownload;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallStatus = function() {};
 /** @type {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallStatus.prototype.bytesDownloaded;
 /** @type {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallStatus.prototype.downloadSizeInBytes;
 /** @type {!Windows.WinRTError} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallStatus.prototype.errorCode;
 /** @type {Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallStatus.prototype.installState;
 /** @type {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallStatus.prototype.percentComplete;

/** @const */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallType = {};
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallType.install;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallType.update;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallType.repair;

/** @const */
Windows.ApplicationModel.Store.Preview.InstallControl.AutoUpdateSetting = {};
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AutoUpdateSetting.disabled;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AutoUpdateSetting.enabled;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AutoUpdateSetting.disabledByPolicy;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.InstallControl.AutoUpdateSetting.enabledByPolicy;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.Preview.StoreConfiguration = function() {};
 /** @type {!Windows.ApplicationModel.Store.Preview.StoreHardwareManufacturerInfo} */
Windows.ApplicationModel.Store.Preview.StoreConfiguration.hardwareManufacturerInfo;
 /** @type {number} */
Windows.ApplicationModel.Store.Preview.StoreConfiguration.purchasePromptingPolicy;

/**
 * Given a list of hardware features, this method returns a modified list that contains only the hardware features that are supported on the current device.
 * @param {!Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Store.Preview.StoreSystemFeature>} systemFeatures A list of StoreSystemFeature objects that represent the hardware features to be queried on the current device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that, on successful completion, returns a list of hardware features that are supported on the current device. If you use Asynchronous programming, the result type is a read-only list/vector of StoreSystemFeature items. (You can use APIs of IVectorView<StoreSystemFeature> for C++ or JavaScript, APIs of IReadOnlyList<StoreSystemFeature> for .NET.)
 */
Windows.ApplicationModel.Store.Preview.StoreConfiguration.filterUnsupportedSystemFeaturesAsync = function(systemFeatures) {};

/**
 * Determines whether a given user ID is also being used to sign in to the Windows Store. Typically, this method is used to determine whether a user ID that is currently signed in to an app is also signed in to the Windows Store.
 * @param {string} webAccountId The user ID (typically obtained from the WebAccount.Id property) to check.
 * @return {boolean} True if the user account specified by webAccountId is the same account that is signed in to the Windows Store; otherwise false.
 */
Windows.ApplicationModel.Store.Preview.StoreConfiguration.isStoreWebAccountId = function(webAccountId) {};

/**
 * Configures mobile operator information for the device.
 * @param {string} mobileOperatorId The mobile operator ID.
 * @param {number} appDownloadLimitInMegabytes The maximum app download size defined by the mobile operator, in MB.
 * @param {number} updateDownloadLimitInMegabytes The maximum OS update download size defined by the mobile operator, in MB.
 * @return {void}
 */
Windows.ApplicationModel.Store.Preview.StoreConfiguration.setMobileOperatorConfiguration = function(mobileOperatorId, appDownloadLimitInMegabytes, updateDownloadLimitInMegabytes) {};

/**
 * Sets the ID of the user account that is signed in to the Windows Store so that other apps can query against this ID.
 * @param {string} webAccountId The user account ID (typically obtained from the WebAccount.Id property) that is signed in to the Windows Store.
 * @return {void}
 */
Windows.ApplicationModel.Store.Preview.StoreConfiguration.setStoreWebAccountId = function(webAccountId) {};

/**
 * Configures miscellaneous system information for the device.
 * @param {string} catalogHardwareManufacturerId The ID of the hardware manufacturer.
 * @param {string} catalogStoreContentModifierId The ID of the Windows Store content modifier.
 * @param {!Date} systemConfigurationExpiration The expiration date for the system configuration.
 * @param {string} catalogHardwareDescriptor A descriptor string that specifies the hardware components supported by the device.
 * @return {void}
 */
Windows.ApplicationModel.Store.Preview.StoreConfiguration.setSystemConfiguration = function(catalogHardwareManufacturerId, catalogStoreContentModifierId, systemConfigurationExpiration, catalogHardwareDescriptor) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.Preview.StoreHardwareManufacturerInfo = function() {};
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StoreHardwareManufacturerInfo.prototype.hardwareManufacturerId;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StoreHardwareManufacturerInfo.prototype.manufacturerName;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StoreHardwareManufacturerInfo.prototype.modelName;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StoreHardwareManufacturerInfo.prototype.storeContentModifierId;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.Preview.StorePreview = function() {};

/**
 * Retrieves the in-app products available for the current app asynchronously, including the available SKUs for each product.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that, on successful completion, returns the collection of in-app products for the current app (including the available SKUs for each product). If you use Asynchronous programming, the result type is a read-only list/vector of StorePreviewProductInfo items. (You can use APIs of IVectorView<StorePreviewProductInfo> for C++ or JavaScript, APIs of IReadOnlyList<StorePreviewProductInfo> for .NET.)
 */
Windows.ApplicationModel.Store.Preview.StorePreview.loadAddOnProductInfosAsync = function() {};

/**
 * Requests the purchase of a SKU for an in-app product that is associated with the current app. Calling this method displays the UI that is used to complete the transaction via the Windows Store.
 * @param {string} productId Specifies the ID of the in-app product. This corresponds to the StorePreviewProductInfo.ProductId value and the StorePreviewSkuInfo.ProductId values for all SKUs of the in-app product.
 * @param {string} skuId Specifies the ID of the SKU for the in-app product. This corresponds to the StorePreviewSkuInfo.SkuId value.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Store.Preview.StorePreviewPurchaseResults, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Store.Preview.StorePreviewPurchaseResults>>} An asynchronous operation that, on successful completion, returns a StorePreviewPurchaseResults that contains the results of the in-app product purchase request.
 */
Windows.ApplicationModel.Store.Preview.StorePreview.requestProductPurchaseByProductIdAndSkuIdAsync = function(productId, skuId) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.Preview.StorePreviewProductInfo = function() {};
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StorePreviewProductInfo.prototype.description;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StorePreviewProductInfo.prototype.productId;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StorePreviewProductInfo.prototype.productType;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Store.Preview.StorePreviewSkuInfo>} */
Windows.ApplicationModel.Store.Preview.StorePreviewProductInfo.prototype.skuInfoList;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StorePreviewProductInfo.prototype.title;

/** @const */
Windows.ApplicationModel.Store.Preview.StorePreviewProductPurchaseStatus = {};
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StorePreviewProductPurchaseStatus.succeeded;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StorePreviewProductPurchaseStatus.alreadyPurchased;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StorePreviewProductPurchaseStatus.notFulfilled;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StorePreviewProductPurchaseStatus.notPurchased;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.Preview.StorePreviewPurchaseResults = function() {};
 /** @type {Windows.ApplicationModel.Store.Preview.StorePreviewProductPurchaseStatus} */
Windows.ApplicationModel.Store.Preview.StorePreviewPurchaseResults.prototype.productPurchaseStatus;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.Preview.StorePreviewSkuInfo = function() {};
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StorePreviewSkuInfo.prototype.currencyCode;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StorePreviewSkuInfo.prototype.customDeveloperData;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StorePreviewSkuInfo.prototype.description;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StorePreviewSkuInfo.prototype.extendedData;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StorePreviewSkuInfo.prototype.formattedListPrice;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StorePreviewSkuInfo.prototype.productId;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StorePreviewSkuInfo.prototype.skuId;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StorePreviewSkuInfo.prototype.skuType;
 /** @type {string} */
Windows.ApplicationModel.Store.Preview.StorePreviewSkuInfo.prototype.title;

/** @const */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature = {};
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.architectureX86;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.architectureX64;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.architectureArm;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.directX9;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.directX10;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.directX11;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.d3D12HardwareFL11;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.d3D12HardwareFL12;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.memory300MB;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.memory750MB;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.memory1GB;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.memory2GB;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.cameraFront;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.cameraRear;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.gyroscope;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.hover;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.magnetometer;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.nfc;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.resolution720P;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.resolutionWvga;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.resolutionWvgaOr720P;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.resolutionWxga;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.resolutionWvgaOrWxga;
/** @const {number} */
Windows.ApplicationModel.Store.Preview.StoreSystemFeature.resolutionWxgaOr720P;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.ProductLicense = function() {};
 /** @type {!Date} */
Windows.ApplicationModel.Store.ProductLicense.prototype.expirationDate;
 /** @type {boolean} */
Windows.ApplicationModel.Store.ProductLicense.prototype.isActive;
 /** @type {boolean} */
Windows.ApplicationModel.Store.ProductLicense.prototype.isConsumable;
 /** @type {string} */
Windows.ApplicationModel.Store.ProductLicense.prototype.productId;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.ProductListing = function() {};
 /** @type {?} */
Windows.ApplicationModel.Store.ProductListing.prototype.currencyCode;
 /** @type {string} */
Windows.ApplicationModel.Store.ProductListing.prototype.description;
 /** @type {?} */
Windows.ApplicationModel.Store.ProductListing.prototype.formattedBasePrice;
 /** @type {string} */
Windows.ApplicationModel.Store.ProductListing.prototype.formattedPrice;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.Store.ProductListing.prototype.imageUri;
 /** @type {?} */
Windows.ApplicationModel.Store.ProductListing.prototype.isOnSale;
 /** @type {!Windows.Foundation.Collections.IIterable<string>} */
Windows.ApplicationModel.Store.ProductListing.prototype.keywords;
 /** @type {string} */
Windows.ApplicationModel.Store.ProductListing.prototype.name;
 /** @type {string} */
Windows.ApplicationModel.Store.ProductListing.prototype.productId;
 /** @type {Windows.ApplicationModel.Store.ProductType} */
Windows.ApplicationModel.Store.ProductListing.prototype.productType;
 /** @type {!Date} */
Windows.ApplicationModel.Store.ProductListing.prototype.saleEndDate;
 /** @type {string} */
Windows.ApplicationModel.Store.ProductListing.prototype.tag;

/**
 * @constructor
 * @struct
 * Creates an instance of ProductPurchaseDisplayProperties .
 * Creates an instance of ProductPurchaseDisplayProperties that includes the specified product name to display to the user.
 * @param {string=} name The product name displayed to the user.
 */
Windows.ApplicationModel.Store.ProductPurchaseDisplayProperties = function(name) {};
 /** @type {string} */
Windows.ApplicationModel.Store.ProductPurchaseDisplayProperties.prototype.description;
 /** @type {!Windows.Foundation.Uri} */
Windows.ApplicationModel.Store.ProductPurchaseDisplayProperties.prototype.image;
 /** @type {string} */
Windows.ApplicationModel.Store.ProductPurchaseDisplayProperties.prototype.name;

/** @const */
Windows.ApplicationModel.Store.ProductPurchaseStatus = {};
/** @const {number} */
Windows.ApplicationModel.Store.ProductPurchaseStatus.succeeded;
/** @const {number} */
Windows.ApplicationModel.Store.ProductPurchaseStatus.alreadyPurchased;
/** @const {number} */
Windows.ApplicationModel.Store.ProductPurchaseStatus.notFulfilled;
/** @const {number} */
Windows.ApplicationModel.Store.ProductPurchaseStatus.notPurchased;

/** @const */
Windows.ApplicationModel.Store.ProductType = {};
/** @const {number} */
Windows.ApplicationModel.Store.ProductType.unknown;
/** @const {number} */
Windows.ApplicationModel.Store.ProductType.durable;
/** @const {number} */
Windows.ApplicationModel.Store.ProductType.consumable;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.PurchaseResults = function() {};
 /** @type {string} */
Windows.ApplicationModel.Store.PurchaseResults.prototype.offerId;
 /** @type {string} */
Windows.ApplicationModel.Store.PurchaseResults.prototype.receiptXml;
 /** @type {Windows.ApplicationModel.Store.ProductPurchaseStatus} */
Windows.ApplicationModel.Store.PurchaseResults.prototype.status;
 /** @type {string} */
Windows.ApplicationModel.Store.PurchaseResults.prototype.transactionId;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Store.UnfulfilledConsumable = function() {};
 /** @type {string} */
Windows.ApplicationModel.Store.UnfulfilledConsumable.prototype.offerId;
 /** @type {string} */
Windows.ApplicationModel.Store.UnfulfilledConsumable.prototype.productId;
 /** @type {string} */
Windows.ApplicationModel.Store.UnfulfilledConsumable.prototype.transactionId;

/** @typedef {function(!Windows.WinRTEvent<void>): void} */
Windows.ApplicationModel.Store.LicenseChangedEventHandler;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.SuspendingDeferral = function() {};

/**
 * Notifies the operating system that the app has saved its data and is ready to be suspended.
 * @return {void}
 */
Windows.ApplicationModel.SuspendingDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.SuspendingEventArgs = function() {};
 /** @type {!Windows.ApplicationModel.SuspendingOperation} */
Windows.ApplicationModel.SuspendingEventArgs.prototype.suspendingOperation;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.SuspendingOperation = function() {};
 /** @type {!Date} */
Windows.ApplicationModel.SuspendingOperation.prototype.deadline;

/**
 * Requests that the app suspending operation be delayed.
 * @return {!Windows.ApplicationModel.SuspendingDeferral} The suspension deferral.
 */
Windows.ApplicationModel.SuspendingOperation.prototype.getDeferral = function() {};
/** @const */
Windows.ApplicationModel.UserDataAccounts = {};
/** @const */
Windows.ApplicationModel.UserDataAccounts.SystemAccess = {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the DeviceAccountConfiguration class.
 */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration = function() {};
 /** @type {string} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.accountName;
 /** @type {boolean} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.calendarSyncEnabled;
 /** @type {boolean} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.contactsSyncEnabled;
 /** @type {string} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.deviceAccountTypeId;
 /** @type {string} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.domain;
 /** @type {string} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.emailAddress;
 /** @type {boolean} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.emailSyncEnabled;
 /** @type {string} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.incomingServerAddress;
 /** @type {number} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.incomingServerPort;
 /** @type {boolean} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.incomingServerRequiresSsl;
 /** @type {string} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.incomingServerUsername;
 /** @type {string} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.outgoingServerAddress;
 /** @type {number} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.outgoingServerPort;
 /** @type {boolean} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.outgoingServerRequiresSsl;
 /** @type {string} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.outgoingServerUsername;
 /** @type {Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountServerType} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration.prototype.serverType;

/** @const */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountServerType = {};
/** @const {number} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountServerType.exchange;
/** @const {number} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountServerType.pop;
/** @const {number} */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountServerType.imap;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.UserDataAccountSystemAccessManager = function() {};

/**
 * Asynchronously displays the system UI to manage the sync relationships for the specified accounts.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration>} accounts The list of accounts to manage in the system UI.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} Returns an updated list of accounts.
 */
Windows.ApplicationModel.UserDataAccounts.SystemAccess.UserDataAccountSystemAccessManager.addAndShowDeviceAccountsAsync = function(accounts) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount = function() {};
 /** @type {string} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount.prototype.deviceAccountTypeId;
 /** @type {string} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount.prototype.enterpriseId;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount.prototype.icon;
 /** @type {string} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount.prototype.id;
 /** @type {boolean} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount.prototype.isProtectedUnderLock;
 /** @type {Windows.ApplicationModel.UserDataAccounts.UserDataAccountOtherAppReadAccess} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount.prototype.otherAppReadAccess;
 /** @type {string} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount.prototype.packageFamilyName;
 /** @type {string} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount.prototype.userDisplayName;

/**
 * Asynchronously deletes all the contact, calendar and email data associated with the account.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating success or failure.
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount.prototype.deleteAsync = function() {};

/**
 * Returns a collection of AppointmentCalendar instances associated with the UserDataAccount .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A collection of AppointmentCalendar instances associated with the UserDataAccount .
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount.prototype.findAppointmentCalendarsAsync = function() {};

/**
 * Returns a collection of ContactAnnotationList instances associated with the UserDataAccount .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A collection of ContactAnnotationList instances associated with the UserDataAccount .
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount.prototype.findContactAnnotationListsAsync = function() {};

/**
 * Returns a collection of ContactList instances associated with the UserDataAccount .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A collection of ContactList instances associated with the UserDataAccount .
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount.prototype.findContactListsAsync = function() {};

/**
 * Returns a collection of EmailMailbox instances associated with the UserDataAccount .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A collection of EmailMailbox instances associated with the UserDataAccount .
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount.prototype.findEmailMailboxesAsync = function() {};

/**
 * Asynchronously persists the UserDataAccount to the database.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Async action that indicates completion of the save operation.
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccount.prototype.saveAsync = function() {};

/** @const */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountContentKinds = {};
/** @const {number} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountContentKinds.email;
/** @const {number} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountContentKinds.contact;
/** @const {number} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountContentKinds.appointment;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountManager = function() {};

/**
 * Asynchronously returns the UserDataAccountStore from the system.
 * @param {Windows.ApplicationModel.UserDataAccounts.UserDataAccountStoreAccessType} storeAccessType Specifies the access type, such as read-only for all accounts or read/write for the calling app's accounts.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.UserDataAccounts.UserDataAccountStore, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.UserDataAccounts.UserDataAccountStore>>} Returns the UserDataAccountStore .
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountManager.requestStoreAsync = function(storeAccessType) {};

/**
 * This method shows the resolve message for an account error.
 * @param {string} id The user data account ID.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating success or failure.
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountManager.showAccountErrorResolverAsync = function(id) {};

/**
 * This method shows the account settings.
 * @param {string} id The user data account ID.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action indicating success or failure.
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountManager.showAccountSettingsAsync = function(id) {};

/**
 * Shows the add account UI.
 * @param {Windows.ApplicationModel.UserDataAccounts.UserDataAccountContentKinds} contentKinds The type of user data content.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} Returns the newly added or already existing account.
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountManager.showAddAccountAsync = function(contentKinds) {};

/** @const */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountOtherAppReadAccess = {};
/** @const {number} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountOtherAppReadAccess.systemOnly;
/** @const {number} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountOtherAppReadAccess.full;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountStore = function() {};

/**
 * Asynchronously creates a user data account.
 * @param {string} userDisplayName A string containing the user name that is suitable for display.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.UserDataAccounts.UserDataAccount, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.UserDataAccounts.UserDataAccount>>} Returns the newly created UserDataAccount .
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountStore.prototype.createAccountAsync = function(userDisplayName) {};

/**
 * Returns a collection of UserDataAccount objects from the store based on the UserDataAccountStoreAccessType value passed into RequestStoreAsync .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} Returns the collection of user data accounts, scoped by access request.
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountStore.prototype.findAccountsAsync = function() {};

/**
 * Asynchronously gets the specified account.
 * @param {string} id The Id string identifying the account.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.UserDataAccounts.UserDataAccount, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.UserDataAccounts.UserDataAccount>>} Returns the UserDataAccount identified by the id parameter.
 */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountStore.prototype.getAccountAsync = function(id) {};

/** @const */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountStoreAccessType = {};
/** @const {number} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountStoreAccessType.allAccountsReadOnly;
/** @const {number} */
Windows.ApplicationModel.UserDataAccounts.UserDataAccountStoreAccessType.appAccountsReadWrite;
/** @const */
Windows.ApplicationModel.VoiceCommands = {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommand = function() {};
 /** @type {string} */
Windows.ApplicationModel.VoiceCommands.VoiceCommand.prototype.commandName;
 /** @type {!Windows.Foundation.Collections.IMapView<string, !Windows.Foundation.Collections.IVectorView<?>>} */
Windows.ApplicationModel.VoiceCommands.VoiceCommand.prototype.properties;
 /** @type {!Windows.Media.SpeechRecognition.SpeechRecognitionResult} */
Windows.ApplicationModel.VoiceCommands.VoiceCommand.prototype.speechRecognitionResult;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletedEventArgs = function() {};
 /** @type {Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletionReason} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletedEventArgs.prototype.reason;

/** @const */
Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletionReason = {};
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletionReason.unknown;
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletionReason.communicationFailed;
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletionReason.resourceLimitsExceeded;
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletionReason.canceled;
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletionReason.timeoutExceeded;
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletionReason.appLaunched;
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletionReason.completed;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandConfirmationResult = function() {};
 /** @type {boolean} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandConfirmationResult.prototype.confirmed;

/**
 * @constructor
 * @struct
 * Creates an instance of the VoiceCommandContentTile class.
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile = function() {};
 /** @type {?} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile.prototype.appContext;
 /** @type {string} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile.prototype.appLaunchArgument;
 /** @type {Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTileType} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile.prototype.contentTileType;
 /** @type {!Windows.Storage.IStorageFile} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile.prototype.image;
 /** @type {string} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile.prototype.textLine1;
 /** @type {string} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile.prototype.textLine2;
 /** @type {string} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile.prototype.textLine3;
 /** @type {string} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile.prototype.title;

/** @const */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTileType = {};
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTileType.titleOnly;
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTileType.titleWithText;
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTileType.titleWith68x68Icon;
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTileType.titleWith68x68IconAndText;
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTileType.titleWith68x92Icon;
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTileType.titleWith68x92IconAndText;
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTileType.titleWith280x140Icon;
/** @const {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTileType.titleWith280x140IconAndText;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandDefinition = function() {};
 /** @type {string} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandDefinition.prototype.language;
 /** @type {string} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandDefinition.prototype.name;

/**
 * Populates a PhraseList element with an array of Item elements.
 * @param {string} phraseListName The string that corresponds to the label attribute of the PhraseList element.
 * @param {!Windows.Foundation.Collections.IIterable<string>} phraseList A string array of values that will be added to the PhraseList element as Item elements.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} A string array of values that will be added to the PhraseList element as Item elements.
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandDefinition.prototype.setPhraseListAsync = function(phraseListName, phraseList) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandDefinitionManager = function() {};
 /** @type {!Windows.Foundation.Collections.IMapView<string, !Windows.ApplicationModel.VoiceCommands.VoiceCommandDefinition>} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandDefinitionManager.installedCommandDefinitions;

/**
 * Installs the CommandSet elements in a Voice Command Definition (VCD) file.
 * @param {!Windows.Storage.StorageFile} file An object representing a VCD file.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous handler called when the operation is complete.
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandDefinitionManager.installCommandDefinitionsFromStorageFileAsync = function(file) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandDisambiguationResult = function() {};
 /** @type {!Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandDisambiguationResult.prototype.selectedItem;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse = function() {};
 /** @type {number} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse.maxSupportedVoiceCommandContentTiles;
 /** @type {string} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse.prototype.appLaunchArgument;
 /** @type {!Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse.prototype.message;
 /** @type {!Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse.prototype.repeatMessage;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile>} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse.prototype.voiceCommandContentTiles;

/**
 * Creates a VoiceCommandResponse object used in calls to ReportProgressAsync , ReportSuccessAsync or ReportFailureAsync .
 * Creates a VoiceCommandResponse object used in calls to ReportProgressAsync , ReportSuccessAsync or ReportFailureAsync .
 * @param {!Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage} message_or_userMessage The message that is spoken by Cortana and shown on the Cortana canvas.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile>=} contentTiles The collection of assets, containing image and text data, shown on the Cortana canvas.
 * @return {!Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse} The response from the background app service for progress, completion, confirmation, or disambiguation screens displayed on the Cortana canvas.
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse.createResponse = function(message_or_userMessage, contentTiles) {};

/**
 * Creates a VoiceCommandResponse object used in calls to RequestConfirmationAsync or RequestDisambiguationAsync .
 * Creates a VoiceCommandResponse object used in calls to RequestConfirmationAsync or RequestDisambiguationAsync .
 * @param {!Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage} message The initial message that is spoken by Cortana and shown on the Cortana canvas.
 * @param {!Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage} repeatMessage The secondary message that is spoken by Cortana and shown on the Cortana canvas, if a response was not understood.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile>=} contentTiles The collection of assets, containing image and text data, shown on the Cortana canvas.
 * @return {!Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse} The response from the background app service for progress, completion, confirmation, or disambiguation screens displayed on the Cortana canvas.
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse.createResponseForPrompt = function(message, repeatMessage, contentTiles) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection = function() {};
 /** @type {!Windows.Globalization.Language} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection.prototype.language;
 /** @type {function(?): void} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection.prototype.onvoicecommandcompleted;

/**
 * Retrieves a VoiceCommandServiceConnection object from the AppServiceTriggerDetails that contains info associated with the background task for the app service.
 * @param {!Windows.ApplicationModel.AppService.AppServiceTriggerDetails} triggerDetails Contains info associated with the background task for the app service.
 * @return {!Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection} The background app service connection to Cortana.
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection.fromAppServiceTriggerDetails = function(triggerDetails) {};

/**
 * Retrieves the voice command that the user submitted to Cortana by voice or text.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.VoiceCommands.VoiceCommand, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.VoiceCommands.VoiceCommand>>} The VoiceCommand .
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection.prototype.getVoiceCommandAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection.prototype.removeEventListener = function(type, listener) {};

/**
 * Sends a response to Cortana indicating the voice command has failed.
 * @param {!Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse} response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous handler called when the operation is complete.
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection.prototype.reportFailureAsync = function(response) {};

/**
 * Sends a response to Cortana indicating voice command is being processed.
 * @param {!Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse} response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous handler called when the operation is complete.
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection.prototype.reportProgressAsync = function(response) {};

/**
 * Sends a response to Cortana indicating the voice command has succeeded.
 * @param {!Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse} response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous handler called when the operation is complete.
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection.prototype.reportSuccessAsync = function(response) {};

/**
 * Sends a response to Cortana indicating the command should be handled by the app in the foreground.
 * @param {!Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse} response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous handler called when the operation is complete.
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection.prototype.requestAppLaunchAsync = function(response) {};

/**
 * Sends a response to Cortana indicating the voice command requires confirmation.
 * @param {!Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse} response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.VoiceCommands.VoiceCommandConfirmationResult, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.VoiceCommands.VoiceCommandConfirmationResult>>} The VoiceCommandConfirmationResult object with the user's response.
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection.prototype.requestConfirmationAsync = function(response) {};

/**
 * Sends a response to Cortana indicating the voice command returned more than one result and requires the user to select one.
 * @param {!Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse} response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.VoiceCommands.VoiceCommandDisambiguationResult, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.VoiceCommands.VoiceCommandDisambiguationResult>>} The VoiceCommandDisambiguationResult object with the user's response.
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection.prototype.requestDisambiguationAsync = function(response) {};

/**
 * @constructor
 * @struct
 * Creates an instance of the VoiceCommandUserMessage class.
 */
Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage = function() {};
 /** @type {string} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage.prototype.displayMessage;
 /** @type {string} */
Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage.prototype.spokenMessage;
/** @const */
Windows.ApplicationModel.Wallet = {};
/** @const */
Windows.ApplicationModel.Wallet.System = {};

/** @const */
Windows.ApplicationModel.Wallet.System.WalletItemAppAssociation = {};
/** @const {number} */
Windows.ApplicationModel.Wallet.System.WalletItemAppAssociation.none;
/** @const {number} */
Windows.ApplicationModel.Wallet.System.WalletItemAppAssociation.appInstalled;
/** @const {number} */
Windows.ApplicationModel.Wallet.System.WalletItemAppAssociation.appNotInstalled;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Wallet.System.WalletItemSystemStore = function() {};
 /** @type {function(?): void} */
Windows.ApplicationModel.Wallet.System.WalletItemSystemStore.prototype.onitemschanged;

/**
 * Asynchronously removes a specific wallet item with the given ID from the wallet system data store.
 * @param {!Windows.ApplicationModel.Wallet.WalletItem} item The ID of the wallet item to remove from the system data store.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action. If you use Asynchronous programming, the result type is void.
 */
Windows.ApplicationModel.Wallet.System.WalletItemSystemStore.prototype.deleteAsync = function(item) {};

/**
 * Gets a WalletItemAppAssociation value indicating if an app is installed for the specified WalletItem .
 * @param {!Windows.ApplicationModel.Wallet.WalletItem} item The item for which to retrieve the status.
 * @return {Windows.ApplicationModel.Wallet.System.WalletItemAppAssociation} The WalletItemAppAssociation value indicating if an app is installed for the specified WalletItem specified by the item parameter.
 */
Windows.ApplicationModel.Wallet.System.WalletItemSystemStore.prototype.getAppStatusForItem = function(item) {};

/**
 * Returns the collection of all system wallet items owned by this app.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that, on successful completion, returns the collection of wallet items accessible by this app. If you use Asynchronous programming, the result type is a read-only list/vector of WalletItem items. (You can use APIs of IVectorView<WalletItem> for C++ or JavaScript, APIs of IReadOnlyList<WalletItem> for .NET.)
 */
Windows.ApplicationModel.Wallet.System.WalletItemSystemStore.prototype.getItemsAsync = function() {};

/**
 * Imports data from a ".mswallet" XML file into the system wallet store.
 * @param {!Windows.Storage.Streams.IRandomAccessStreamReference} stream The ".mswallet" file to import.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Wallet.WalletItem, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Wallet.WalletItem>>} An asynchronous operation that, on successful completion, returns the wallet item that was imported into the wallet. If you use Asynchronous programming, the result type on successful completion is a single WalletItem .
 */
Windows.ApplicationModel.Wallet.System.WalletItemSystemStore.prototype.importItemAsync = function(stream) {};

/**
 * Launches the app that is associated with the given wallet item.
 * @param {!Windows.ApplicationModel.Wallet.WalletItem} item The wallet item to launch an app for.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An async action indicating that the operation has completed.
 */
Windows.ApplicationModel.Wallet.System.WalletItemSystemStore.prototype.launchAppForItemAsync = function(item) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Wallet.System.WalletItemSystemStore.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.ApplicationModel.Wallet.System.WalletItemSystemStore.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Wallet.System.WalletManagerSystem = function() {};

/**
 * Requests an instance of the system wallet store for the app.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Wallet.System.WalletItemSystemStore, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Wallet.System.WalletItemSystemStore>>} An asynchronous operation that, on successful completion, returns an instance of the default wallet store. If you use Asynchronous programming, the result type is a single WalletItemSystemStore object.
 */
Windows.ApplicationModel.Wallet.System.WalletManagerSystem.requestStoreAsync = function() {};

/** @const */
Windows.ApplicationModel.Wallet.WalletActionKind = {};
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletActionKind.openItem;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletActionKind.transaction;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletActionKind.moreTransactions;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletActionKind.message;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletActionKind.verb;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the WalletBarcode class.
 * Initializes a new instance of the WalletBarcode class.
 * @param {!Windows.Storage.Streams.IRandomAccessStreamReference|Windows.ApplicationModel.Wallet.WalletBarcodeSymbology} streamToBarcodeImage_or_symbology A stream representing the bar code image. / The symbology type for this barcode. Use one of the supported symbologies, such as Upca. Don't set to Invalid or Custom.
 * @param {string=} value The message ( Value ) that the barcode represents.
 */
Windows.ApplicationModel.Wallet.WalletBarcode = function(streamToBarcodeImage_or_symbology, value) {};
 /** @type {Windows.ApplicationModel.Wallet.WalletBarcodeSymbology} */
Windows.ApplicationModel.Wallet.WalletBarcode.prototype.symbology;
 /** @type {string} */
Windows.ApplicationModel.Wallet.WalletBarcode.prototype.value;

/**
 * Creates and returns a bitmap image stream for the barcode (or returns the custom image used during instantiation).
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStreamReference, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStreamReference>>} An asynchronous operation. If you use Asynchronous programming, the result type on successful completion is an IRandomAccessStreamReference instance. This can be assigned as the source for an image (with some additional code).
 */
Windows.ApplicationModel.Wallet.WalletBarcode.prototype.getImageAsync = function() {};

/** @const */
Windows.ApplicationModel.Wallet.WalletBarcodeSymbology = {};
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletBarcodeSymbology.invalid;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletBarcodeSymbology.upca;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletBarcodeSymbology.upce;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletBarcodeSymbology.ean13;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletBarcodeSymbology.ean8;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletBarcodeSymbology.itf;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletBarcodeSymbology.code39;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletBarcodeSymbology.code128;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletBarcodeSymbology.qr;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletBarcodeSymbology.pdf417;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletBarcodeSymbology.aztec;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletBarcodeSymbology.custom;

/** @const */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition = {};
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.hidden;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.headerField1;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.headerField2;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.primaryField1;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.primaryField2;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.secondaryField1;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.secondaryField2;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.secondaryField3;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.secondaryField4;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.secondaryField5;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.centerField1;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.footerField1;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.footerField2;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.footerField3;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletDetailViewPosition.footerField4;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the WalletItem class.
 * @param {Windows.ApplicationModel.Wallet.WalletItemKind} kind The type of wallet item.
 * @param {string} displayName The display name of the item.
 */
Windows.ApplicationModel.Wallet.WalletItem = function(kind, displayName) {};
 /** @type {!Windows.ApplicationModel.Wallet.WalletBarcode} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.barcode;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.bodyBackgroundImage;
 /** @type {!Windows.UI.Color} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.bodyColor;
 /** @type {!Windows.UI.Color} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.bodyFontColor;
 /** @type {string} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.displayMessage;
 /** @type {string} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.displayName;
 /** @type {!Windows.Foundation.Collections.IMap<string, !Windows.ApplicationModel.Wallet.WalletItemCustomProperty>} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.displayProperties;
 /** @type {!Date} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.expirationDate;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.headerBackgroundImage;
 /** @type {!Windows.UI.Color} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.headerColor;
 /** @type {!Windows.UI.Color} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.headerFontColor;
 /** @type {string} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.id;
 /** @type {boolean} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.isAcknowledged;
 /** @type {boolean} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.isDisplayMessageLaunchable;
 /** @type {boolean} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.isMoreTransactionHistoryLaunchable;
 /** @type {string} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.issuerDisplayName;
 /** @type {Windows.ApplicationModel.Wallet.WalletItemKind} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.kind;
 /** @type {!Date} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.lastUpdated;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.logo159x159;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.logo336x336;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.logo99x99;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.logoImage;
 /** @type {string} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.logoText;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.promotionalImage;
 /** @type {!Date} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.relevantDate;
 /** @type {string} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.relevantDateDisplayMessage;
 /** @type {!Windows.Foundation.Collections.IMap<string, !Windows.ApplicationModel.Wallet.WalletRelevantLocation>} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.relevantLocations;
 /** @type {!Windows.Foundation.Collections.IMap<string, !Windows.ApplicationModel.Wallet.WalletTransaction>} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.transactionHistory;
 /** @type {!Windows.Foundation.Collections.IMap<string, !Windows.ApplicationModel.Wallet.WalletVerb>} */
Windows.ApplicationModel.Wallet.WalletItem.prototype.verbs;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the WalletItemCustomProperty class.
 * @param {string} name The custom property label. Sets the initial Name value.
 * @param {string} value The value of the property. Sets the initial Value value.
 */
Windows.ApplicationModel.Wallet.WalletItemCustomProperty = function(name, value) {};
 /** @type {boolean} */
Windows.ApplicationModel.Wallet.WalletItemCustomProperty.prototype.autoDetectLinks;
 /** @type {Windows.ApplicationModel.Wallet.WalletDetailViewPosition} */
Windows.ApplicationModel.Wallet.WalletItemCustomProperty.prototype.detailViewPosition;
 /** @type {string} */
Windows.ApplicationModel.Wallet.WalletItemCustomProperty.prototype.name;
 /** @type {Windows.ApplicationModel.Wallet.WalletSummaryViewPosition} */
Windows.ApplicationModel.Wallet.WalletItemCustomProperty.prototype.summaryViewPosition;
 /** @type {string} */
Windows.ApplicationModel.Wallet.WalletItemCustomProperty.prototype.value;

/** @const */
Windows.ApplicationModel.Wallet.WalletItemKind = {};
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletItemKind.invalid;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletItemKind.deal;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletItemKind.general;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletItemKind.paymentInstrument;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletItemKind.ticket;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletItemKind.boardingPass;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletItemKind.membershipCard;
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Wallet.WalletItemStore = function() {};

/**
 * Adds a new wallet item to the wallet.
 * @param {string} id The identifier of the wallet item. This value must be unique. This sets the initial WalletItem.Id value (the identifier is for the WalletItemStore store, and isn't part of the initialization of a WalletItem object.
 * @param {!Windows.ApplicationModel.Wallet.WalletItem} item The wallet item to add to the wallet.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action. If you use Asynchronous programming, the return type is void.
 */
Windows.ApplicationModel.Wallet.WalletItemStore.prototype.addAsync = function(id, item) {};

/**
 * Clears all app-owned wallet items from the wallet data store.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action. If you use Asynchronous programming, the result type is void.
 */
Windows.ApplicationModel.Wallet.WalletItemStore.prototype.clearAsync = function() {};

/**
 * Removes a specific wallet item with the given ID from the wallet data store.
 * @param {string} id The ID of the wallet item to remove from the data store.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action. If you use Asynchronous programming, the result type is void.
 */
Windows.ApplicationModel.Wallet.WalletItemStore.prototype.deleteAsync = function(id) {};

/**
 * Returns the collection of all wallet items owned by this app.
 * Returns the collection of wallet items of the given type that are owned by this app.
 * @param {Windows.ApplicationModel.Wallet.WalletItemKind=} kind The type of wallet item to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Wallet.WalletItem>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.Wallet.WalletItem>>>|!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that, on successful completion, returns the collection of wallet items accessible by this app. If you use Asynchronous programming, the result type is a read-only list/vector of WalletItem items. (You can use APIs of IVectorView<WalletItem> for C++ or JavaScript, APIs of IReadOnlyList<WalletItem> for .NET.) / An asynchronous operation that, on successful completion, returns the collection of wallet items of the specified type that are accessible by this app. If you use Asynchronous programming, the result type is a read-only list/vector of WalletItem items. (You can use APIs of IVectorView<WalletItem> for C++ or JavaScript, APIs of IReadOnlyList<WalletItem> for .NET.)
 */
Windows.ApplicationModel.Wallet.WalletItemStore.prototype.getItemsAsync = function(kind) {};

/**
 * Gets an individual wallet item with the given ID from the wallet database. The item requested must be owned by this app.
 * @param {string} id The ID of the wallet item.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Wallet.WalletItem, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Wallet.WalletItem>>} An asynchronous operation that, on successful completion, returns the wallet item with the specified ID that is owned by this app. If you use Asynchronous programming, the result type is a single WalletItem (or null, see Remarks).
 */
Windows.ApplicationModel.Wallet.WalletItemStore.prototype.getWalletItemAsync = function(id) {};

/**
 * Imports data from a ".mswallet" XML file into the wallet store.
 * @param {!Windows.Storage.Streams.IRandomAccessStreamReference} stream The ".mswallet" file to import.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Wallet.WalletItem, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Wallet.WalletItem>>} An asynchronous operation that, on successful completion, returns the wallet item that was imported into the wallet. If you use Asynchronous programming, the result type on successful completion is a single WalletItem .
 */
Windows.ApplicationModel.Wallet.WalletItemStore.prototype.importItemAsync = function(stream) {};

/**
 * Displays the item with the given ID in the Wallet UI.
 * Displays the Wallet UI.
 * @param {string=} id The ID of the item to display.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action. If you use Asynchronous programming, the result type is void.
 */
Windows.ApplicationModel.Wallet.WalletItemStore.prototype.showAsync = function(id) {};

/**
 * Updates a wallet item in the shared store, based on the changed values in the WalletItem object provided.
 * @param {!Windows.ApplicationModel.Wallet.WalletItem} item The updated data for the wallet item.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action. If you use Asynchronous programming, the result type is void.
 */
Windows.ApplicationModel.Wallet.WalletItemStore.prototype.updateAsync = function(item) {};
/**
 * @constructor
 * @struct
 */
Windows.ApplicationModel.Wallet.WalletManager = function() {};

/**
 * Requests an instance of the default wallet store for the app.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.ApplicationModel.Wallet.WalletItemStore, !Windows.Foundation.IAsyncOperation<!Windows.ApplicationModel.Wallet.WalletItemStore>>} An asynchronous operation that, on successful completion, returns an instance of the default wallet store. If you use Asynchronous programming, the result type is a single WalletItemStore object.
 */
Windows.ApplicationModel.Wallet.WalletManager.requestStoreAsync = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the WalletRelevantLocation class.
 */
Windows.ApplicationModel.Wallet.WalletRelevantLocation = function() {};
 /** @type {string} */
Windows.ApplicationModel.Wallet.WalletRelevantLocation.prototype.displayMessage;
 /** @type {!Windows.Devices.Geolocation.BasicGeoposition} */
Windows.ApplicationModel.Wallet.WalletRelevantLocation.prototype.position;

/** @const */
Windows.ApplicationModel.Wallet.WalletSummaryViewPosition = {};
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletSummaryViewPosition.hidden;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletSummaryViewPosition.field1;
/** @const {number} */
Windows.ApplicationModel.Wallet.WalletSummaryViewPosition.field2;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the WalletTransaction class.
 */
Windows.ApplicationModel.Wallet.WalletTransaction = function() {};
 /** @type {string} */
Windows.ApplicationModel.Wallet.WalletTransaction.prototype.description;
 /** @type {string} */
Windows.ApplicationModel.Wallet.WalletTransaction.prototype.displayAmount;
 /** @type {string} */
Windows.ApplicationModel.Wallet.WalletTransaction.prototype.displayLocation;
 /** @type {boolean} */
Windows.ApplicationModel.Wallet.WalletTransaction.prototype.ignoreTimeOfDay;
 /** @type {boolean} */
Windows.ApplicationModel.Wallet.WalletTransaction.prototype.isLaunchable;
 /** @type {!Date} */
Windows.ApplicationModel.Wallet.WalletTransaction.prototype.transactionDate;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the WalletVerb class.
 * @param {string} name The name of the custom verb. Sets the value of the Name property.
 */
Windows.ApplicationModel.Wallet.WalletVerb = function(name) {};
 /** @type {string} */
Windows.ApplicationModel.Wallet.WalletVerb.prototype.name;
/**
 * @record
 * @struct
 */
Windows.ApplicationModel.PackageVersion = function() {};
 /** @type {number} */
Windows.ApplicationModel.PackageVersion.prototype.build;
 /** @type {number} */
Windows.ApplicationModel.PackageVersion.prototype.major;
 /** @type {number} */
Windows.ApplicationModel.PackageVersion.prototype.minor;
 /** @type {number} */
Windows.ApplicationModel.PackageVersion.prototype.revision;
/**
 * @record
 * @struct
 */
Windows.ApplicationModel.ISuspendingEventArgs = function() {};
 /** @type {!Windows.ApplicationModel.SuspendingOperation} */
Windows.ApplicationModel.ISuspendingEventArgs.prototype.suspendingOperation;
/** @const */
Windows.Data = {};
/** @const */
Windows.Data.Html = {};
/** @const */
Windows.Data.Json = {};
/** @const */
Windows.Data.Pdf = {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Pdf.PdfDocument = function() {};
 /** @type {boolean} */
Windows.Data.Pdf.PdfDocument.prototype.isPasswordProtected;
 /** @type {number} */
Windows.Data.Pdf.PdfDocument.prototype.pageCount;

/**
 * Outputs an asynchronous operation. When the operation completes, a PdfDocument object is returned, which represents a Portable Document Format (PDF) document. Use this method if the PDF document is password-protected.
 * Outputs an asynchronous operation. When the operation completes, a PdfDocument object is returned, which represents a Portable Document Format (PDF) document.
 * @param {!Windows.Storage.IStorageFile} file The file, which represents a PDF document.
 * @param {string=} password The password to open the PDF document, if it requires one.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Data.Pdf.PdfDocument, !Windows.Foundation.IAsyncOperation<!Windows.Data.Pdf.PdfDocument>>} The asynchronous operation.
 */
Windows.Data.Pdf.PdfDocument.loadFromFileAsync = function(file, password) {};

/**
 * Creates a PdfDocument object, representing a Portable Document Format (PDF) document, from a stream of data that represents a PDF document in the file system. Use this method if the PDF document is password-protected.
 * Creates a PdfDocument object, representing a Portable Document Format (PDF) document, from a stream of data that represents a PDF document in the file system.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} inputStream The stream of data, which represents a PDF document.
 * @param {string=} password The password to open the PDF document, if it requires one.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Data.Pdf.PdfDocument, !Windows.Foundation.IAsyncOperation<!Windows.Data.Pdf.PdfDocument>>} The asynchronous operation.
 */
Windows.Data.Pdf.PdfDocument.loadFromStreamAsync = function(inputStream, password) {};

/**
 * Gets a page from a Portable Document Format (PDF) document.
 * @param {number} pageIndex The location of the PDF page relative to its parent document.
 * @return {!Windows.Data.Pdf.PdfPage} The PDF page.
 */
Windows.Data.Pdf.PdfDocument.prototype.getPage = function(pageIndex) {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Pdf.PdfPage = function() {};
 /** @type {!Windows.Data.Pdf.PdfPageDimensions} */
Windows.Data.Pdf.PdfPage.prototype.dimensions;
 /** @type {number} */
Windows.Data.Pdf.PdfPage.prototype.index;
 /** @type {number} */
Windows.Data.Pdf.PdfPage.prototype.preferredZoom;
 /** @type {Windows.Data.Pdf.PdfPageRotation} */
Windows.Data.Pdf.PdfPage.prototype.rotation;
 /** @type {!Windows.Foundation.Size} */
Windows.Data.Pdf.PdfPage.prototype.size;

/**
 * Releases all resources associated with the Portable Document Format (PDF) page.
 * @return {void}
 */
Windows.Data.Pdf.PdfPage.prototype.close = function() {};

/**
 * Begins building the Portable Document Format (PDF) page. After this method finishes, the PDF page is completely built.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Represents the fully-built PDF page.
 */
Windows.Data.Pdf.PdfPage.prototype.preparePageAsync = function() {};

/**
 * Outputs a stream of data, which represents a Portable Document Format (PDF) page's contents, as an asynchronous action. This asynchronous action can be used to create an image of the PDF page.
 * Takes a set of display settings, applies them to the output of a Portable Document Format (PDF) page's contents, and creates a stream with the customized, rendered output as an asynchronous action. This asynchronous action can be used to create a customized display image of the PDF page.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} outputStream The stream of data, which represents a PDF page's content. / The stream of data, which represents a PDF page's contents.
 * @param {!Windows.Data.Pdf.PdfPageRenderOptions=} options The requested set of display settings to apply to the display image that is output based on the PDF page.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The asynchronous action.
 */
Windows.Data.Pdf.PdfPage.prototype.renderToStreamAsync = function(outputStream, options) {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Pdf.PdfPageDimensions = function() {};
 /** @type {!Windows.Foundation.Rect} */
Windows.Data.Pdf.PdfPageDimensions.prototype.artBox;
 /** @type {!Windows.Foundation.Rect} */
Windows.Data.Pdf.PdfPageDimensions.prototype.bleedBox;
 /** @type {!Windows.Foundation.Rect} */
Windows.Data.Pdf.PdfPageDimensions.prototype.cropBox;
 /** @type {!Windows.Foundation.Rect} */
Windows.Data.Pdf.PdfPageDimensions.prototype.mediaBox;
 /** @type {!Windows.Foundation.Rect} */
Windows.Data.Pdf.PdfPageDimensions.prototype.trimBox;

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of display settings for a single page of a Portable Document Format (PDF) document.
 */
Windows.Data.Pdf.PdfPageRenderOptions = function() {};
 /** @type {!Windows.UI.Color} */
Windows.Data.Pdf.PdfPageRenderOptions.prototype.backgroundColor;
 /** @type {string} */
Windows.Data.Pdf.PdfPageRenderOptions.prototype.bitmapEncoderId;
 /** @type {number} */
Windows.Data.Pdf.PdfPageRenderOptions.prototype.destinationHeight;
 /** @type {number} */
Windows.Data.Pdf.PdfPageRenderOptions.prototype.destinationWidth;
 /** @type {boolean} */
Windows.Data.Pdf.PdfPageRenderOptions.prototype.isIgnoringHighContrast;
 /** @type {!Windows.Foundation.Rect} */
Windows.Data.Pdf.PdfPageRenderOptions.prototype.sourceRect;

/** @const */
Windows.Data.Pdf.PdfPageRotation = {};
/** @const {number} */
Windows.Data.Pdf.PdfPageRotation.normal;
/** @const {number} */
Windows.Data.Pdf.PdfPageRotation.rotate90;
/** @const {number} */
Windows.Data.Pdf.PdfPageRotation.rotate180;
/** @const {number} */
Windows.Data.Pdf.PdfPageRotation.rotate270;
/** @const */
Windows.Data.Text = {};

/** @const */
Windows.Data.Text.AlternateNormalizationFormat = {};
/** @const {number} */
Windows.Data.Text.AlternateNormalizationFormat.notNormalized;
/** @const {number} */
Windows.Data.Text.AlternateNormalizationFormat.number;
/** @const {number} */
Windows.Data.Text.AlternateNormalizationFormat.currency;
/** @const {number} */
Windows.Data.Text.AlternateNormalizationFormat.date;
/** @const {number} */
Windows.Data.Text.AlternateNormalizationFormat.time;
/**
 * @constructor
 * @struct
 */
Windows.Data.Text.AlternateWordForm = function() {};
 /** @type {string} */
Windows.Data.Text.AlternateWordForm.prototype.alternateText;
 /** @type {Windows.Data.Text.AlternateNormalizationFormat} */
Windows.Data.Text.AlternateWordForm.prototype.normalizationFormat;
 /** @type {!Windows.Data.Text.TextSegment} */
Windows.Data.Text.AlternateWordForm.prototype.sourceTextSegment;
/**
 * @constructor
 * @struct
 */
Windows.Data.Text.SelectableWordSegment = function() {};
 /** @type {!Windows.Data.Text.TextSegment} */
Windows.Data.Text.SelectableWordSegment.prototype.sourceTextSegment;
 /** @type {string} */
Windows.Data.Text.SelectableWordSegment.prototype.text;

/**
 * @constructor
 * @struct
 * Creates a SelectableWordsSegmenter object. See the introduction in SelectableWordsSegmenter for a description of how the language supplied to this constructor is used.
 * @param {string} language A BCP-47 language tag.
 */
Windows.Data.Text.SelectableWordsSegmenter = function(language) {};
 /** @type {string} */
Windows.Data.Text.SelectableWordsSegmenter.prototype.resolvedLanguage;

/**
 * Determines and returns the selectable word which contains or follows a specified index into the provided text.
 * @param {string} text Provided text in which a word is to be selected.
 * @param {number} startIndex A zero-based index into text. It must be less than the length of text.
 * @return {!Windows.Data.Text.SelectableWordSegment} A SelectableWordSegment that represents the selected word.
 */
Windows.Data.Text.SelectableWordsSegmenter.prototype.getTokenAt = function(text, startIndex) {};

/**
 * Determines and returns all of the selectable words in the provided text.
 * @param {string} text Provided text containing words to be selected.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Data.Text.SelectableWordSegment>} A collection of SelectableWordSegment objects that represent the selectable words.
 */
Windows.Data.Text.SelectableWordsSegmenter.prototype.getTokens = function(text) {};

/**
 * Calls the provided handler with two iterators that iterate through the selectable words prior to and following a given index into the provided text.
 * @param {string} text Provided text containing words to be selected.
 * @param {number} startIndex A zero-based index into text. It must be less than the length of text.
 * @param {function(!Windows.Foundation.Collections.IIterable<!Windows.Data.Text.SelectableWordSegment>, !Windows.Foundation.Collections.IIterable<!Windows.Data.Text.SelectableWordSegment>): void} handler The function that receives the iterators.
 * @return {void}
 */
Windows.Data.Text.SelectableWordsSegmenter.prototype.tokenize = function(text, startIndex, handler) {};

/**
 * @constructor
 * @struct
 * Creates a SemanticTextQuery from an Advanced Query Syntax (AQS) query string and a language tag.
 * Creates a SemanticTextQuery from an Advanced Query Syntax (AQS) query string.
 * @param {string} aqsFilter An AQS string that contains the desired query. Learn more about AQS in Advanced Query Syntax (AQS).
 * @param {string=} filterLanguage The BCP-47 language tag to be employed in the query.
 */
Windows.Data.Text.SemanticTextQuery = function(aqsFilter, filterLanguage) {};

/**
 * Returns segments of a source string that match the SemanticTextQuery object's query.
 * @param {string} content A source string to be queried.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Data.Text.TextSegment>} A collection of TextSegment structures that represent hits from the query.
 */
Windows.Data.Text.SemanticTextQuery.prototype.find = function(content) {};

/**
 * Returns segments of a source string that match the SemanticTextQuery object's query over properties.
 * @param {string} propertyContent A source string to be queried.
 * @param {string} propertyName The name of the property.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Data.Text.TextSegment>} A collection of TextSegment structures that represent hits from the query.
 */
Windows.Data.Text.SemanticTextQuery.prototype.findInProperty = function(propertyContent, propertyName) {};

/**
 * @constructor
 * @struct
 * Constructs a TextConversionGenerator object based on a specific BCP-47 language tag.
 * @param {string} languageTag The BCP-47 language tag of the language in which the words are to be projected. Japanese ("ja") and Simplified Chinese ("zh-Hans") are supported.
 */
Windows.Data.Text.TextConversionGenerator = function(languageTag) {};
 /** @type {boolean} */
Windows.Data.Text.TextConversionGenerator.prototype.languageAvailableButNotInstalled;
 /** @type {string} */
Windows.Data.Text.TextConversionGenerator.prototype.resolvedLanguage;

/**
 * Asynchronously gets a list of candidate words based on the provided phonetic characters.
 * Asynchronously gets a list of candidate words, up to a maximum count, based on the provided phonetic characters.
 * @param {string} input The phonetic characters of the words to be returned.
 * @param {number=} maxCandidates The maximum number of candidate words to return.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation to return an IVectorView of the list of candidate words.
 */
Windows.Data.Text.TextConversionGenerator.prototype.getCandidatesAsync = function(input, maxCandidates) {};

/**
 * @constructor
 * @struct
 * Constructs a TextPredictionGenerator object based on a specific BCP-47 language tag.
 * @param {string} languageTag The BCP-47 language tag of the language in which the words are to be projected. Only Japanese ("ja") is supported.
 */
Windows.Data.Text.TextPredictionGenerator = function(languageTag) {};
 /** @type {boolean} */
Windows.Data.Text.TextPredictionGenerator.prototype.languageAvailableButNotInstalled;
 /** @type {string} */
Windows.Data.Text.TextPredictionGenerator.prototype.resolvedLanguage;

/**
 * Asynchronously gets a list of candidate words based on the provided phonetic characters prefix.
 * Asynchronously gets a list of candidate words, up to a maximum count, based on the provided phonetic characters prefix.
 * @param {string} input The beginning phonetic characters of the words to be returned.
 * @param {number=} maxCandidates The maximum number of predicted words to return.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation to return an IVectorView of the list of predicted words.
 */
Windows.Data.Text.TextPredictionGenerator.prototype.getCandidatesAsync = function(input, maxCandidates) {};

/**
 * @constructor
 * @struct
 * Constructs a TextReverseConversionGenerator object based on a specific BCP-47 language tag.
 * @param {string} languageTag The BCP-47 language tag of the language in which the words are to be reverse-converted. Only Japanese ("ja") is supported.
 */
Windows.Data.Text.TextReverseConversionGenerator = function(languageTag) {};
 /** @type {boolean} */
Windows.Data.Text.TextReverseConversionGenerator.prototype.languageAvailableButNotInstalled;
 /** @type {string} */
Windows.Data.Text.TextReverseConversionGenerator.prototype.resolvedLanguage;

/**
 * Asynchronously reverse-converts a string which contains ideographic characters to a phonetic expression.
 * @param {string} input The string containing ideographic characters to be reverse-converted.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} An asynchronous operation to return the phonetic expression.
 */
Windows.Data.Text.TextReverseConversionGenerator.prototype.convertBackAsync = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Text.UnicodeCharacters = function() {};

/**
 * Returns the supplementary Unicode character for the specified high and low surrogate pair.
 * @param {number} highSurrogate The high surrogate value. This must be in the proper range: 0xD800 <= highSurrogate <= 0xDBFF.
 * @param {number} lowSurrogate The low surrogate value. This must be in the proper range: 0xDC00 <= lowSurrogate <= 0xDFFF.
 * @return {number} The supplementary Unicode character.
 */
Windows.Data.Text.UnicodeCharacters.getCodepointFromSurrogatePair = function(highSurrogate, lowSurrogate) {};

/**
 * Returns the UnicodeGeneralCategory of the specified Unicode character.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {Windows.Data.Text.UnicodeGeneralCategory} The Unicode general category for codepoint.
 */
Windows.Data.Text.UnicodeCharacters.getGeneralCategory = function(codepoint) {};

/**
 * Returns the UnicodeNumericType of the specified Unicode character.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {Windows.Data.Text.UnicodeNumericType} The Unicode numeric type for codepoint.
 */
Windows.Data.Text.UnicodeCharacters.getNumericType = function(codepoint) {};

/**
 * Returns the high and low surrogate pair values for the specified supplementary Unicode character.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {{highSurrogate: string, lowSurrogate: string}}
 */
Windows.Data.Text.UnicodeCharacters.getSurrogatePairFromCodepoint = function(codepoint) {};

/**
 * Determines if a specified Unicode character can be considered alphabetic.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {boolean} TRUE if codepoint is alphabetic; otherwise FALSE.
 */
Windows.Data.Text.UnicodeCharacters.isAlphabetic = function(codepoint) {};

/**
 * Determines if a specified Unicode character can be considered cased (uppercase, lowercase or titlecase).
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {boolean} TRUE if codepoint is cased; otherwise FALSE.
 */
Windows.Data.Text.UnicodeCharacters.isCased = function(codepoint) {};

/**
 * Determines if a specified Unicode character can be considered the beginning of a grapheme.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {boolean} TRUE if codepoint is the beginning of a grapheme; otherwise FALSE.
 */
Windows.Data.Text.UnicodeCharacters.isGraphemeBase = function(codepoint) {};

/**
 * Determines if a specified Unicode character can be considered to continue a previous grapheme.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {boolean} TRUE if codepoint continues the previous grapheme; otherwise FALSE.
 */
Windows.Data.Text.UnicodeCharacters.isGraphemeExtend = function(codepoint) {};

/**
 * Determines if a specified Unicode character is a high surrogate.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {boolean} TRUE if codepoint is a high surrogate; otherwise FALSE.
 */
Windows.Data.Text.UnicodeCharacters.isHighSurrogate = function(codepoint) {};

/**
 * Determines if a specified Unicode character can be considered a continuation character of an identifier in programming.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {boolean} TRUE if codepoint is a continuation character of an identifier in programming; otherwise FALSE.
 */
Windows.Data.Text.UnicodeCharacters.isIdContinue = function(codepoint) {};

/**
 * Determines if a specified Unicode character can be considered the start character of an identifier in programming.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {boolean} TRUE if codepoint is the start character of an identifier in programming; otherwise FALSE.
 */
Windows.Data.Text.UnicodeCharacters.isIdStart = function(codepoint) {};

/**
 * Determines if a specified Unicode character is a low surrogate.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {boolean} TRUE if codepoint is a low surrogate; otherwise FALSE.
 */
Windows.Data.Text.UnicodeCharacters.isLowSurrogate = function(codepoint) {};

/**
 * Determines if a specified Unicode character can be considered a lower case character.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {boolean} TRUE if codepoint is a lower case character; otherwise FALSE.
 */
Windows.Data.Text.UnicodeCharacters.isLowercase = function(codepoint) {};

/**
 * Determines if a specified codepoint is a non-character.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {boolean} TRUE if codepoint is a non-character; otherwise FALSE.
 */
Windows.Data.Text.UnicodeCharacters.isNoncharacter = function(codepoint) {};

/**
 * Determines if a specified Unicode character is a supplementary character.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {boolean} TRUE if codepoint is a supplementary character; otherwise FALSE.
 */
Windows.Data.Text.UnicodeCharacters.isSupplementary = function(codepoint) {};

/**
 * Determines if a specified Unicode character can be considered an upper case character.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {boolean} TRUE if codepoint is an upper case character; otherwise FALSE.
 */
Windows.Data.Text.UnicodeCharacters.isUppercase = function(codepoint) {};

/**
 * Determines if a specified Unicode character can be considered whitespace.
 * @param {number} codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
 * @return {boolean} TRUE if codepoint is whitespace; otherwise FALSE.
 */
Windows.Data.Text.UnicodeCharacters.isWhitespace = function(codepoint) {};

/** @const */
Windows.Data.Text.UnicodeGeneralCategory = {};
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.uppercaseLetter;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.lowercaseLetter;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.titlecaseLetter;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.modifierLetter;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.otherLetter;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.nonspacingMark;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.spacingCombiningMark;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.enclosingMark;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.decimalDigitNumber;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.letterNumber;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.otherNumber;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.spaceSeparator;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.lineSeparator;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.paragraphSeparator;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.control;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.format;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.surrogate;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.privateUse;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.connectorPunctuation;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.dashPunctuation;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.openPunctuation;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.closePunctuation;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.initialQuotePunctuation;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.finalQuotePunctuation;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.otherPunctuation;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.mathSymbol;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.currencySymbol;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.modifierSymbol;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.otherSymbol;
/** @const {number} */
Windows.Data.Text.UnicodeGeneralCategory.notAssigned;

/** @const */
Windows.Data.Text.UnicodeNumericType = {};
/** @const {number} */
Windows.Data.Text.UnicodeNumericType.none;
/** @const {number} */
Windows.Data.Text.UnicodeNumericType.decimal;
/** @const {number} */
Windows.Data.Text.UnicodeNumericType.digit;
/** @const {number} */
Windows.Data.Text.UnicodeNumericType.numeric;
/**
 * @constructor
 * @struct
 */
Windows.Data.Text.WordSegment = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Data.Text.AlternateWordForm>} */
Windows.Data.Text.WordSegment.prototype.alternateForms;
 /** @type {!Windows.Data.Text.TextSegment} */
Windows.Data.Text.WordSegment.prototype.sourceTextSegment;
 /** @type {string} */
Windows.Data.Text.WordSegment.prototype.text;

/**
 * @constructor
 * @struct
 * Creates a WordsSegmenter object. See the introduction in WordsSegmenter for a description of how the language supplied to this constructor is used.
 * @param {string} language A BCP-47 language tag.
 */
Windows.Data.Text.WordsSegmenter = function(language) {};
 /** @type {string} */
Windows.Data.Text.WordsSegmenter.prototype.resolvedLanguage;

/**
 * Determines and returns the word which contains or follows a specified index into the provided text.
 * @param {string} text Provided text from which the word is to be returned.
 * @param {number} startIndex A zero-based index into text. It must be less than the length of text.
 * @return {!Windows.Data.Text.WordSegment} A WordSegment that represents the word.
 */
Windows.Data.Text.WordsSegmenter.prototype.getTokenAt = function(text, startIndex) {};

/**
 * Determines and returns all of the words in the provided text.
 * @param {string} text Provided text containing words to be returned.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Data.Text.WordSegment>} A collection of WordSegment objects that represent the words.
 */
Windows.Data.Text.WordsSegmenter.prototype.getTokens = function(text) {};

/**
 * Calls the provided handler with two iterators that iterate through the words prior to and following a given index into the provided text.
 * @param {string} text Provided text containing words to be returned.
 * @param {number} startIndex A zero-based index into text. It must be less than the length of text.
 * @param {function(!Windows.Foundation.Collections.IIterable<!Windows.Data.Text.WordSegment>, !Windows.Foundation.Collections.IIterable<!Windows.Data.Text.WordSegment>): void} handler The function that receives the iterators.
 * @return {void}
 */
Windows.Data.Text.WordsSegmenter.prototype.tokenize = function(text, startIndex, handler) {};
/**
 * @record
 * @struct
 */
Windows.Data.Text.TextSegment = function() {};
 /** @type {number} */
Windows.Data.Text.TextSegment.prototype.length;
 /** @type {number} */
Windows.Data.Text.TextSegment.prototype.startPosition;

/** @typedef {function(!Windows.Foundation.Collections.IIterable<!Windows.Data.Text.SelectableWordSegment>, !Windows.Foundation.Collections.IIterable<!Windows.Data.Text.SelectableWordSegment>): void} */
Windows.Data.Text.SelectableWordSegmentsTokenizingHandler;

/** @typedef {function(!Windows.Foundation.Collections.IIterable<!Windows.Data.Text.WordSegment>, !Windows.Foundation.Collections.IIterable<!Windows.Data.Text.WordSegment>): void} */
Windows.Data.Text.WordSegmentsTokenizingHandler;
/** @const */
Windows.Data.Xml = {};
/** @const */
Windows.Data.Xml.Dom = {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Xml.Dom.DtdEntity = function() {};
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.DtdEntity.prototype.attributes;
 /** @type {!Windows.Data.Xml.Dom.XmlNodeList} */
Windows.Data.Xml.Dom.DtdEntity.prototype.childNodes;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.DtdEntity.prototype.firstChild;
 /** @type {string} */
Windows.Data.Xml.Dom.DtdEntity.prototype.innerText;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.DtdEntity.prototype.lastChild;
 /** @type {?} */
Windows.Data.Xml.Dom.DtdEntity.prototype.localName;
 /** @type {?} */
Windows.Data.Xml.Dom.DtdEntity.prototype.namespaceUri;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.DtdEntity.prototype.nextSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.DtdEntity.prototype.nodeName;
 /** @type {Windows.Data.Xml.Dom.NodeType} */
Windows.Data.Xml.Dom.DtdEntity.prototype.nodeType;
 /** @type {?} */
Windows.Data.Xml.Dom.DtdEntity.prototype.nodeValue;
 /** @type {?} */
Windows.Data.Xml.Dom.DtdEntity.prototype.notationName;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Data.Xml.Dom.DtdEntity.prototype.ownerDocument;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.DtdEntity.prototype.parentNode;
 /** @type {?} */
Windows.Data.Xml.Dom.DtdEntity.prototype.prefix;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.DtdEntity.prototype.previousSibling;
 /** @type {?} */
Windows.Data.Xml.Dom.DtdEntity.prototype.publicId;
 /** @type {?} */
Windows.Data.Xml.Dom.DtdEntity.prototype.systemId;

/**
 * Appends a new child node as the last child of the node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child node to be appended to the end of the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The new child node successfully appended to the list. If null, no object is created.
 */
Windows.Data.Xml.Dom.DtdEntity.prototype.appendChild = function(newChild) {};

/**
 * Clones a new node.
 * @param {boolean} deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The newly created clone node.
 */
Windows.Data.Xml.Dom.DtdEntity.prototype.cloneNode = function(deep) {};

/**
 * Returns the XML representation of the node and all its descendants.
 * @return {string} The XML representation of the node and all its descendants.
 */
Windows.Data.Xml.Dom.DtdEntity.prototype.getXml = function() {};

/**
 * Determines whether a node has children.
 * @return {boolean} True if this node has children; otherwise false.
 */
Windows.Data.Xml.Dom.DtdEntity.prototype.hasChildNodes = function() {};

/**
 * Inserts a child node to the left of the specified node, or at the end of the child node list.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} On success, the child node that was inserted. If null, no object is created.
 */
Windows.Data.Xml.Dom.DtdEntity.prototype.insertBefore = function(newChild, referenceChild) {};

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 * @return {void}
 */
Windows.Data.Xml.Dom.DtdEntity.prototype.normalize = function() {};

/**
 * Removes the specified child node from the list of children and returns it.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} childNode The child node to be removed from the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The removed child node. If null, the childNode object is not removed.
 */
Windows.Data.Xml.Dom.DtdEntity.prototype.removeChild = function(childNode) {};

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The old child that is to be replaced by the new child.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The old child that is replaced. If null, no object is created.
 */
Windows.Data.Xml.Dom.DtdEntity.prototype.replaceChild = function(newChild, referenceChild) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
Windows.Data.Xml.Dom.DtdEntity.prototype.selectNodes = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
Windows.Data.Xml.Dom.DtdEntity.prototype.selectNodesNS = function(xpath, namespaces) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
Windows.Data.Xml.Dom.DtdEntity.prototype.selectSingleNode = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
Windows.Data.Xml.Dom.DtdEntity.prototype.selectSingleNodeNS = function(xpath, namespaces) {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Xml.Dom.DtdNotation = function() {};
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.DtdNotation.prototype.attributes;
 /** @type {!Windows.Data.Xml.Dom.XmlNodeList} */
Windows.Data.Xml.Dom.DtdNotation.prototype.childNodes;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.DtdNotation.prototype.firstChild;
 /** @type {string} */
Windows.Data.Xml.Dom.DtdNotation.prototype.innerText;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.DtdNotation.prototype.lastChild;
 /** @type {?} */
Windows.Data.Xml.Dom.DtdNotation.prototype.localName;
 /** @type {?} */
Windows.Data.Xml.Dom.DtdNotation.prototype.namespaceUri;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.DtdNotation.prototype.nextSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.DtdNotation.prototype.nodeName;
 /** @type {Windows.Data.Xml.Dom.NodeType} */
Windows.Data.Xml.Dom.DtdNotation.prototype.nodeType;
 /** @type {?} */
Windows.Data.Xml.Dom.DtdNotation.prototype.nodeValue;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Data.Xml.Dom.DtdNotation.prototype.ownerDocument;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.DtdNotation.prototype.parentNode;
 /** @type {?} */
Windows.Data.Xml.Dom.DtdNotation.prototype.prefix;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.DtdNotation.prototype.previousSibling;
 /** @type {?} */
Windows.Data.Xml.Dom.DtdNotation.prototype.publicId;
 /** @type {?} */
Windows.Data.Xml.Dom.DtdNotation.prototype.systemId;

/**
 * Appends a new child node as the last child of the node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child node to be appended to the end of the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The new child node successfully appended to the list. If null, no object is created.
 */
Windows.Data.Xml.Dom.DtdNotation.prototype.appendChild = function(newChild) {};

/**
 * Clones a new node.
 * @param {boolean} deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The newly created clone node.
 */
Windows.Data.Xml.Dom.DtdNotation.prototype.cloneNode = function(deep) {};

/**
 * Returns the XML representation of the node and all its descendants.
 * @return {string} The XML representation of the node and all its descendants.
 */
Windows.Data.Xml.Dom.DtdNotation.prototype.getXml = function() {};

/**
 * Determines whether a node has children.
 * @return {boolean} True if this node has children; otherwise false.
 */
Windows.Data.Xml.Dom.DtdNotation.prototype.hasChildNodes = function() {};

/**
 * Inserts a child node to the left of the specified node, or at the end of the child node list.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} On success, the child node that was inserted. If null, no object is created.
 */
Windows.Data.Xml.Dom.DtdNotation.prototype.insertBefore = function(newChild, referenceChild) {};

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 * @return {void}
 */
Windows.Data.Xml.Dom.DtdNotation.prototype.normalize = function() {};

/**
 * Removes the specified child node from the list of children and returns it.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} childNode The child node to be removed from the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The removed child node. If null, the childNode object is not removed.
 */
Windows.Data.Xml.Dom.DtdNotation.prototype.removeChild = function(childNode) {};

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The old child that is to be replaced by the new child.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The old child that is replaced. If null, no object is created.
 */
Windows.Data.Xml.Dom.DtdNotation.prototype.replaceChild = function(newChild, referenceChild) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
Windows.Data.Xml.Dom.DtdNotation.prototype.selectNodes = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList.
 * @param {string} xpath Specifies an XPath expresssion.
 * @param {?} namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
Windows.Data.Xml.Dom.DtdNotation.prototype.selectNodesNS = function(xpath, namespaces) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
Windows.Data.Xml.Dom.DtdNotation.prototype.selectSingleNode = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
Windows.Data.Xml.Dom.DtdNotation.prototype.selectSingleNodeNS = function(xpath, namespaces) {};

/** @const */
Windows.Data.Xml.Dom.NodeType = {};
/** @const {number} */
Windows.Data.Xml.Dom.NodeType.invalid;
/** @const {number} */
Windows.Data.Xml.Dom.NodeType.elementNode;
/** @const {number} */
Windows.Data.Xml.Dom.NodeType.attributeNode;
/** @const {number} */
Windows.Data.Xml.Dom.NodeType.textNode;
/** @const {number} */
Windows.Data.Xml.Dom.NodeType.dataSectionNode;
/** @const {number} */
Windows.Data.Xml.Dom.NodeType.entityReferenceNode;
/** @const {number} */
Windows.Data.Xml.Dom.NodeType.entityNode;
/** @const {number} */
Windows.Data.Xml.Dom.NodeType.processingInstructionNode;
/** @const {number} */
Windows.Data.Xml.Dom.NodeType.commentNode;
/** @const {number} */
Windows.Data.Xml.Dom.NodeType.documentNode;
/** @const {number} */
Windows.Data.Xml.Dom.NodeType.documentTypeNode;
/** @const {number} */
Windows.Data.Xml.Dom.NodeType.documentFragmentNode;
/** @const {number} */
Windows.Data.Xml.Dom.NodeType.notationNode;
/**
 * @constructor
 * @struct
 */
Windows.Data.Xml.Dom.XmlAttribute = function() {};
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.attributes;
 /** @type {!Windows.Data.Xml.Dom.XmlNodeList} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.childNodes;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.firstChild;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.innerText;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.lastChild;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.localName;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.name;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.namespaceUri;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.nextSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.nodeName;
 /** @type {Windows.Data.Xml.Dom.NodeType} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.nodeType;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.nodeValue;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.ownerDocument;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.parentNode;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.prefix;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.previousSibling;
 /** @type {boolean} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.specified;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlAttribute.prototype.value;

/**
 * This method is not applicable to this class and will throw an exception.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child node to be appended to the end of the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The new child node successfully appended to the list. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlAttribute.prototype.appendChild = function(newChild) {};

/**
 * Clones a new node.
 * @param {boolean} deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The newly created clone node.
 */
Windows.Data.Xml.Dom.XmlAttribute.prototype.cloneNode = function(deep) {};

/**
 * Returns the XML representation of the node and all its descendants.
 * @return {string} The XML representation of the node and all its descendants.
 */
Windows.Data.Xml.Dom.XmlAttribute.prototype.getXml = function() {};

/**
 * Determines whether a node has children.
 * @return {boolean} True if this node has children; otherwise false.
 */
Windows.Data.Xml.Dom.XmlAttribute.prototype.hasChildNodes = function() {};

/**
 * Inserts a child node to the left of the specified node, or at the end of the child node list.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} On success, the child node that was inserted. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlAttribute.prototype.insertBefore = function(newChild, referenceChild) {};

/**
 * This method is not applicable to this class and will throw an exception.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlAttribute.prototype.normalize = function() {};

/**
 * Removes the specified child node from the list of children and returns it.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} childNode The child node to be removed from the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The removed child node. If null, the childNode object is not removed.
 */
Windows.Data.Xml.Dom.XmlAttribute.prototype.removeChild = function(childNode) {};

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The old child that is to be replaced by the new child.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The old child that is replaced. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlAttribute.prototype.replaceChild = function(newChild, referenceChild) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlAttribute.prototype.selectNodes = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expresssion.
 * @param {?} namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlAttribute.prototype.selectNodesNS = function(xpath, namespaces) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
Windows.Data.Xml.Dom.XmlAttribute.prototype.selectSingleNode = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
Windows.Data.Xml.Dom.XmlAttribute.prototype.selectSingleNodeNS = function(xpath, namespaces) {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Xml.Dom.XmlCDataSection = function() {};
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.attributes;
 /** @type {!Windows.Data.Xml.Dom.XmlNodeList} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.childNodes;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.data;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.firstChild;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.innerText;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.lastChild;
 /** @type {number} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.length;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.localName;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.namespaceUri;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.nextSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.nodeName;
 /** @type {Windows.Data.Xml.Dom.NodeType} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.nodeType;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.nodeValue;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.ownerDocument;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.parentNode;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.prefix;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.previousSibling;

/**
 * This method is not applicable to this class. The CDataSection does not have children. This method will throw an exception.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child node to be appended to the end of the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The new child node successfully appended to the list. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.appendChild = function(newChild) {};

/**
 * Appends the supplied string to the existing string data.
 * @param {string} data The data to be appended to the existing string.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.appendData = function(data) {};

/**
 * Clones a new node.
 * @param {boolean} deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The newly created clone node.
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.cloneNode = function(deep) {};

/**
 * Deletes specified data.
 * @param {number} offset The offset, in characters, at which to start deleting the string data.
 * @param {number} count The number of characters to delete.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.deleteData = function(offset, count) {};

/**
 * Returns the XML representation of the node and all its descendants.
 * @return {string} The XML representation of the node and all its descendants.
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.getXml = function() {};

/**
 * Determines whether a node has children. The CDataSection does not have children. This method always returns false.
 * @return {boolean} True if this node has children; otherwise false. This method always returns false.
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.hasChildNodes = function() {};

/**
 * Inserts a child node to the left of the specified node, or at the end of the child node list. This method is not applicable to this class and will throw an exception.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} On success, the child node that was inserted. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.insertBefore = function(newChild, referenceChild) {};

/**
 * Inserts a string at the specified offset.
 * @param {number} offset The offset, in characters, at which to insert the supplied string data.
 * @param {string} data The data to be inserted into the existing string.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.insertData = function(offset, data) {};

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.normalize = function() {};

/**
 * Removes the specified child node from the list of children and returns it. This method is not applicable to this class as the CDataSection does not have children. This method will throw an exception.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} childNode The child node to be removed from the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The removed child node. If null, the childNode object is not removed.
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.removeChild = function(childNode) {};

/**
 * Replaces the specified old child node with the supplied new child node. This method is not applicable to this class as the CDataSection does not have children. This method will throw an exception.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The old child that is to be replaced by the new child.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The old child that is replaced. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.replaceChild = function(newChild, referenceChild) {};

/**
 * Replaces the specified number of characters with the supplied string.
 * @param {number} offset The offset, in characters, at which to start replacing string data.
 * @param {number} count The number of characters to replace.
 * @param {string} data The new data that replaces the old string data.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.replaceData = function(offset, count, data) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList . This method is not applicable to this class and will throw an exception.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.selectNodes = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList . This method is not applicable to this class and will throw an exception.
 * @param {string} xpath Specifies an XPath expresssion.
 * @param {?} namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.selectNodesNS = function(xpath, namespaces) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node. This method is not applicable to this class and will throw an exception.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.selectSingleNode = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node. This method is not applicable to this class and will throw an exception.
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.selectSingleNodeNS = function(xpath, namespaces) {};

/**
 * Splits this text node into two text nodes at the specified offset and inserts the new text node into the tree as a sibling that immediately follows this node.
 * @param {number} offset The number of characters at which to split this text node into two nodes, starting from zero.
 * @return {!Windows.Data.Xml.Dom.IXmlText} The new text node.
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.splitText = function(offset) {};

/**
 * Retrieves a substring of the full string from the specified range.
 * @param {number} offset Specifies the offset, in characters, from the beginning of the string. An offset of zero indicates copying from the start of the data.
 * @param {number} count Specifies the number of characters to retrieve from the specified offset.
 * @return {string} The returned substring.
 */
Windows.Data.Xml.Dom.XmlCDataSection.prototype.substringData = function(offset, count) {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Xml.Dom.XmlComment = function() {};
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.XmlComment.prototype.attributes;
 /** @type {!Windows.Data.Xml.Dom.XmlNodeList} */
Windows.Data.Xml.Dom.XmlComment.prototype.childNodes;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlComment.prototype.data;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlComment.prototype.firstChild;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlComment.prototype.innerText;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlComment.prototype.lastChild;
 /** @type {number} */
Windows.Data.Xml.Dom.XmlComment.prototype.length;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlComment.prototype.localName;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlComment.prototype.namespaceUri;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlComment.prototype.nextSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlComment.prototype.nodeName;
 /** @type {Windows.Data.Xml.Dom.NodeType} */
Windows.Data.Xml.Dom.XmlComment.prototype.nodeType;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlComment.prototype.nodeValue;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Data.Xml.Dom.XmlComment.prototype.ownerDocument;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlComment.prototype.parentNode;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlComment.prototype.prefix;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlComment.prototype.previousSibling;

/**
 * Appends a new child node as the last child of the node. This method is not applicable to this class and it will throw an exception.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child node to be appended to the end of the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The new child node successfully appended to the list. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlComment.prototype.appendChild = function(newChild) {};

/**
 * Appends the supplied string to the existing string data.
 * @param {string} data The data to be appended to the existing string.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlComment.prototype.appendData = function(data) {};

/**
 * Clones a new node.
 * @param {boolean} deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The newly created clone node.
 */
Windows.Data.Xml.Dom.XmlComment.prototype.cloneNode = function(deep) {};

/**
 * Deletes the specified data.
 * @param {number} offset The offset, in characters, at which to start deleting the string data.
 * @param {number} count The number of characters to delete.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlComment.prototype.deleteData = function(offset, count) {};

/**
 * Returns the XML representation of the node and all its descendants.
 * @return {string} The XML representation of the node and all its descendants.
 */
Windows.Data.Xml.Dom.XmlComment.prototype.getXml = function() {};

/**
 * Determines whether a node has children.
 * @return {boolean} True if this node has children; otherwise false.
 */
Windows.Data.Xml.Dom.XmlComment.prototype.hasChildNodes = function() {};

/**
 * Inserts a child node to the left of the specified node, or at the end of the list. This method is not applicable to this class and will throw an exception.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} On success, the child node that was inserted. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlComment.prototype.insertBefore = function(newChild, referenceChild) {};

/**
 * Inserts a string at the specified offset.
 * @param {number} offset The offset, in characters, at which to insert the supplied string data.
 * @param {string} data The data to be inserted into the existing string.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlComment.prototype.insertData = function(offset, data) {};

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlComment.prototype.normalize = function() {};

/**
 * Removes the specified child node from the list of children and returns it. This method is not applicable to this class and will throw an exception.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} childNode The child node to be removed from the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The removed child node. If null, the childNode object is not removed.
 */
Windows.Data.Xml.Dom.XmlComment.prototype.removeChild = function(childNode) {};

/**
 * Replaces the specified old child node with the supplied new child node. This method is not applicable to this class and will throw an exception.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The old child that is to be replaced by the new child.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The old child that is replaced. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlComment.prototype.replaceChild = function(newChild, referenceChild) {};

/**
 * Replaces the specified number of characters with the supplied string.
 * @param {number} offset The offset, in characters, at which to start replacing string data.
 * @param {number} count The number of characters to replace.
 * @param {string} data The new data that replaces the old string data.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlComment.prototype.replaceData = function(offset, count, data) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList . This method is not applicable to this class and will throw an exception.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlComment.prototype.selectNodes = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList . This method is not applicable to this class and will throw an exception.
 * @param {string} xpath Specifies an XPath expresssion.
 * @param {?} namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlComment.prototype.selectNodesNS = function(xpath, namespaces) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node. This method is not applicable to this class and will throw an exception.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
Windows.Data.Xml.Dom.XmlComment.prototype.selectSingleNode = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node. This method is not applicable to this class and will throw an exception.
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
Windows.Data.Xml.Dom.XmlComment.prototype.selectSingleNodeNS = function(xpath, namespaces) {};

/**
 * Retrieves a substring of the full string from the specified range.
 * @param {number} offset Specifies the offset, in characters, from the beginning of the string. An offset of zero indicates copying from the start of the data.
 * @param {number} count Specifies the number of characters to retrieve from the specified offset.
 * @return {string} The returned substring.
 */
Windows.Data.Xml.Dom.XmlComment.prototype.substringData = function(offset, count) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the XmlDocument class.
 */
Windows.Data.Xml.Dom.XmlDocument = function() {};
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.XmlDocument.prototype.attributes;
 /** @type {!Windows.Data.Xml.Dom.XmlNodeList} */
Windows.Data.Xml.Dom.XmlDocument.prototype.childNodes;
 /** @type {!Windows.Data.Xml.Dom.XmlDocumentType} */
Windows.Data.Xml.Dom.XmlDocument.prototype.doctype;
 /** @type {!Windows.Data.Xml.Dom.XmlElement} */
Windows.Data.Xml.Dom.XmlDocument.prototype.documentElement;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlDocument.prototype.documentUri;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocument.prototype.firstChild;
 /** @type {!Windows.Data.Xml.Dom.XmlDomImplementation} */
Windows.Data.Xml.Dom.XmlDocument.prototype.implementation;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlDocument.prototype.innerText;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocument.prototype.lastChild;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlDocument.prototype.localName;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlDocument.prototype.namespaceUri;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocument.prototype.nextSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlDocument.prototype.nodeName;
 /** @type {Windows.Data.Xml.Dom.NodeType} */
Windows.Data.Xml.Dom.XmlDocument.prototype.nodeType;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlDocument.prototype.nodeValue;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Data.Xml.Dom.XmlDocument.prototype.ownerDocument;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocument.prototype.parentNode;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlDocument.prototype.prefix;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocument.prototype.previousSibling;

/**
 * Asynchronously loads an XML document from the specified file. The document is parsed using the provided settings.
 * Asynchronously loads an XML document from the specified file. The document is parsed using the default parser settings.
 * @param {!Windows.Storage.IStorageFile} file The file from which to load the document.
 * @param {!Windows.Data.Xml.Dom.XmlLoadSettings=} loadSettings Settings for customizing parser behavior.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Data.Xml.Dom.XmlDocument, !Windows.Foundation.IAsyncOperation<!Windows.Data.Xml.Dom.XmlDocument>>} The object that must be used to start the operation.
 */
Windows.Data.Xml.Dom.XmlDocument.loadFromFileAsync = function(file, loadSettings) {};

/**
 * Asynchronously loads an XML document from the specified location. The document is parsed using the provided settings.
 * Asynchronously loads an XML document from the specified location. The document is parsed using the default parser settings.
 * @param {!Windows.Foundation.Uri} uri A URL that specifies the location of the XML file.
 * @param {!Windows.Data.Xml.Dom.XmlLoadSettings=} loadSettings Customizes parser behavior.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Data.Xml.Dom.XmlDocument, !Windows.Foundation.IAsyncOperation<!Windows.Data.Xml.Dom.XmlDocument>>} An object that must be used to start the operation. / The object that must be used to start the operation.
 */
Windows.Data.Xml.Dom.XmlDocument.loadFromUriAsync = function(uri, loadSettings) {};

/**
 * Appends a new child node as the last child of the node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child node to be appended to the end of the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The new child node successfully appended to the list. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.appendChild = function(newChild) {};

/**
 * Clones a new node.
 * @param {boolean} deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The newly created clone node.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.cloneNode = function(deep) {};

/**
 * Creates a new attribute with the specified name.
 * @param {string} name The name of the new attribute object. This name is subsequently available as the new node's NodeName property.
 * @return {!Windows.Data.Xml.Dom.XmlAttribute} The newly created attribute.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.createAttribute = function(name) {};

/**
 * Creates a new attribute with the specified namespace and name.
 * @param {?} namespaceUri The name of the desired namespace or a null value if no namespace is desired.
 * @param {string} qualifiedName The name of the new attribute object. This name is subsequently available as the new node's NodeName property.
 * @return {!Windows.Data.Xml.Dom.XmlAttribute} The newly created attribute.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.createAttributeNS = function(namespaceUri, qualifiedName) {};

/**
 * Creates a CDATA section node that contains the supplied data.
 * @param {string} data The value to be supplied to the new CDATA section object's NodeValue property.
 * @return {!Windows.Data.Xml.Dom.XmlCDataSection} The newly created object.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.createCDataSection = function(data) {};

/**
 * Creates a comment node that contains the supplied data.
 * @param {string} data The value to be supplied to the new comment object's NodeValue .
 * @return {!Windows.Data.Xml.Dom.XmlComment} The newly created comment node.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.createComment = function(data) {};

/**
 * Creates an empty XmlDocumentFragment object.
 * @return {!Windows.Data.Xml.Dom.XmlDocumentFragment} The newly created object.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.createDocumentFragment = function() {};

/**
 * Creates an element node using the specified name.
 * @param {string} tagName The name for the new element node. The string is case-sensitive. This name is subsequently available as the element node's NodeName property.
 * @return {!Windows.Data.Xml.Dom.XmlElement} The newly created object.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.createElement = function(tagName) {};

/**
 * Creates an element node using the specified namespace and name.
 * @param {?} namespaceUri The name of the desired namespace or a null value if no namespace is desired.
 * @param {string} qualifiedName The name for the new element node. It is case-sensitive. This name is subsequently available as the element node's NodeName property.
 * @return {!Windows.Data.Xml.Dom.XmlElement} The newly created object.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.createElementNS = function(namespaceUri, qualifiedName) {};

/**
 * Creates a new XmlEntityReference object.
 * @param {string} name The name of the entity referenced. This name is subsequently available as the new object's NodeName property.
 * @return {!Windows.Data.Xml.Dom.XmlEntityReference} The newly created object.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.createEntityReference = function(name) {};

/**
 * Creates a processing instruction node that contains the supplied target and data.
 * @param {string} target The target part of the processing instruction. It supplies the NodeName property of the new object.
 * @param {string} data The remainder of the processing instruction preceding the closing ?> characters. It supplies the NodeValue property for the new object.
 * @return {!Windows.Data.Xml.Dom.XmlProcessingInstruction} The newly created object.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.createProcessingInstruction = function(target, data) {};

/**
 * Creates a text node that contains the supplied data.
 * @param {string} data The value to be supplied to the new text object's NodeValue .
 * @return {!Windows.Data.Xml.Dom.XmlText} The created text node.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.createTextNode = function(data) {};

/**
 * Returns the element that matches the ID attribute.
 * @param {string} elementId The ID to match.
 * @return {!Windows.Data.Xml.Dom.XmlElement} The element that matches the supplied ID. If no elements match, this method returns Null.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.getElementById = function(elementId) {};

/**
 * Returns a collection of elements that have the specified name.
 * @param {string} tagName The element name to find. The value "*" returns all elements in the document.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of elements that match the specified name.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.getElementsByTagName = function(tagName) {};

/**
 * Returns the XML representation of the node and all its descendants.
 * @return {string} The XML representation of the node and all its descendants.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.getXml = function() {};

/**
 * Determines whether a node has children.
 * @return {boolean} True if this node has children; otherwise false.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.hasChildNodes = function() {};

/**
 * Imports a node from another document to this document.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} node The object to be cloned.
 * @param {boolean} deep If true, any children of node will be cloned as well. If false, no children of the node will be cloned.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The imported node.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.importNode = function(node, deep) {};

/**
 * Inserts a child node to the left of the specified node, or at the end of the child node list.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} On success, the child node that was inserted. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.insertBefore = function(newChild, referenceChild) {};

/**
 * Loads an XML document using the supplied string. The document is parsed using the settings provided.
 * Loads an XML document using the supplied string. The document is parsed using the default parser settings.
 * @param {string} xml The XML string to load into this XML document object. This string can contain an entire XML document or a well-formed fragment.
 * @param {!Windows.Data.Xml.Dom.XmlLoadSettings=} loadSettings The settings for parsing the document.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.loadXml = function(xml, loadSettings) {};

/**
 * Loads an XML document using the buffer. The document is parsed using the default parser settings.
 * Loads an XML document using the buffer. The document is parsed using the settings provided.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer to load into this XML document object. This buffer can contain an entire XML document or a well-formed fragment.
 * @param {!Windows.Data.Xml.Dom.XmlLoadSettings=} loadSettings The settings for parsing the document.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.loadXmlFromBuffer = function(buffer, loadSettings) {};

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.normalize = function() {};

/**
 * Removes the specified child node from the list of children and returns it.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} childNode The child node to be removed from the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The removed child node. If null, the childNode object is not removed.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.removeChild = function(childNode) {};

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The old child that is to be replaced by the new child.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The old child that is replaced. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.replaceChild = function(newChild, referenceChild) {};

/**
 * Asynchronously saves an XML document to the specified file.
 * @param {!Windows.Storage.IStorageFile} file The file to save the document to.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object that must be used to start the operation.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.saveToFileAsync = function(file) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.selectNodes = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.selectNodesNS = function(xpath, namespaces) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.selectSingleNode = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
Windows.Data.Xml.Dom.XmlDocument.prototype.selectSingleNodeNS = function(xpath, namespaces) {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Xml.Dom.XmlDocumentFragment = function() {};
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.attributes;
 /** @type {!Windows.Data.Xml.Dom.XmlNodeList} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.childNodes;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.firstChild;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.innerText;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.lastChild;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.localName;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.namespaceUri;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.nextSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.nodeName;
 /** @type {Windows.Data.Xml.Dom.NodeType} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.nodeType;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.nodeValue;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.ownerDocument;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.parentNode;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.prefix;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.previousSibling;

/**
 * Appends a new child node as the last child of the node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child node to be appended to the end of the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The new child node successfully appended to the list. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.appendChild = function(newChild) {};

/**
 * Clones a new node.
 * @param {boolean} deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The newly created clone node.
 */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.cloneNode = function(deep) {};

/**
 * Returns the XML representation of the node and all its descendants.
 * @return {string} The XML representation of the node and all its descendants.
 */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.getXml = function() {};

/**
 * Determines whether a node has children.
 * @return {boolean} True if this node has children; otherwise false.
 */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.hasChildNodes = function() {};

/**
 * Inserts a child node to the left of the specified node, or at the end of the list.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} On success, the child node that was inserted. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.insertBefore = function(newChild, referenceChild) {};

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.normalize = function() {};

/**
 * Removes the specified child node from the list of children and returns it.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} childNode The child node to be removed from the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The removed child node. If null, the childNode object is not removed.
 */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.removeChild = function(childNode) {};

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The old child that is to be replaced by the new child.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The old child that is replaced. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.replaceChild = function(newChild, referenceChild) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.selectNodes = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.selectNodesNS = function(xpath, namespaces) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.selectSingleNode = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
Windows.Data.Xml.Dom.XmlDocumentFragment.prototype.selectSingleNodeNS = function(xpath, namespaces) {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Xml.Dom.XmlDocumentType = function() {};
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.attributes;
 /** @type {!Windows.Data.Xml.Dom.XmlNodeList} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.childNodes;
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.entities;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.firstChild;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.innerText;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.lastChild;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.localName;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.name;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.namespaceUri;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.nextSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.nodeName;
 /** @type {Windows.Data.Xml.Dom.NodeType} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.nodeType;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.nodeValue;
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.notations;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.ownerDocument;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.parentNode;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.prefix;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.previousSibling;

/**
 * Appends a new child node as the last child of the node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child node to be appended to the end of the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The new child node successfully appended to the list. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.appendChild = function(newChild) {};

/**
 * Clones a new node.
 * @param {boolean} deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The newly created clone node.
 */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.cloneNode = function(deep) {};

/**
 * Returns the XML representation of the node and all its descendants.
 * @return {string} The XML representation of the node and all its descendants.
 */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.getXml = function() {};

/**
 * Determines whether a node has children.
 * @return {boolean} True if this node has children; otherwise false.
 */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.hasChildNodes = function() {};

/**
 * Inserts a child node to the left of the specified node, or at the end of the list.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} On success, the child node that was inserted. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.insertBefore = function(newChild, referenceChild) {};

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.normalize = function() {};

/**
 * Removes the specified child node from the list of children and returns it.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} childNode The child node to be removed from the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The removed child node. If null, the childNode object is not removed.
 */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.removeChild = function(childNode) {};

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The old child that is to be replaced by the new child.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The old child that is replaced. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.replaceChild = function(newChild, referenceChild) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.selectNodes = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.selectNodesNS = function(xpath, namespaces) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.selectSingleNode = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
Windows.Data.Xml.Dom.XmlDocumentType.prototype.selectSingleNodeNS = function(xpath, namespaces) {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Xml.Dom.XmlDomImplementation = function() {};

/**
 * Indicates support for the specified feature.
 * @param {string} feature Specifies the feature to test. In Level 1, valid feature values are "XML", "DOM", and "MS-DOM" (case-insensitive).
 * @param {?} version Specifies the version number to test. If NULL, tests for implementation of the feature in any version. In Level 1, "1.0" is the valid version value.
 * @return {boolean} True if the specified feature is implemented; otherwise false.
 */
Windows.Data.Xml.Dom.XmlDomImplementation.prototype.hasFeature = function(feature, version) {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Xml.Dom.XmlElement = function() {};
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.XmlElement.prototype.attributes;
 /** @type {!Windows.Data.Xml.Dom.XmlNodeList} */
Windows.Data.Xml.Dom.XmlElement.prototype.childNodes;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlElement.prototype.firstChild;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlElement.prototype.innerText;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlElement.prototype.lastChild;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlElement.prototype.localName;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlElement.prototype.namespaceUri;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlElement.prototype.nextSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlElement.prototype.nodeName;
 /** @type {Windows.Data.Xml.Dom.NodeType} */
Windows.Data.Xml.Dom.XmlElement.prototype.nodeType;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlElement.prototype.nodeValue;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Data.Xml.Dom.XmlElement.prototype.ownerDocument;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlElement.prototype.parentNode;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlElement.prototype.prefix;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlElement.prototype.previousSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlElement.prototype.tagName;

/**
 * Appends a new child node as the last child of the node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child node to be appended to the end of the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The new child node successfully appended to the list. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.appendChild = function(newChild) {};

/**
 * Clones a new node.
 * @param {boolean} deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The newly created clone node.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.cloneNode = function(deep) {};

/**
 * Returns the value of the attribute.
 * @param {string} attributeName The name of the required attribute.
 * @return {string} The string value of the attribute.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.getAttribute = function(attributeName) {};

/**
 * Returns the value of the attribute.
 * @param {?} namespaceUri The namespace of the attribute to get.
 * @param {string} localName The name of the attribute without the namespace prefix.
 * @return {string} The string value of the attribute.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.getAttributeNS = function(namespaceUri, localName) {};

/**
 * Returns the attribute node.
 * @param {string} attributeName The name of the required attribute.
 * @return {!Windows.Data.Xml.Dom.XmlAttribute} The returned attribute pointer.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.getAttributeNode = function(attributeName) {};

/**
 * Returns the specified attribute from the specified namespace.
 * @param {?} namespaceUri The namespace of the attribute to get.
 * @param {string} localName The name of the attribute without the namespace prefix.
 * @return {!Windows.Data.Xml.Dom.XmlAttribute} The returned attribute pointer.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.getAttributeNodeNS = function(namespaceUri, localName) {};

/**
 * Returns a list of all descendant elements that match the supplied name.
 * @param {string} tagName The tag of the required elements.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The required elements. The list can be empty.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.getElementsByTagName = function(tagName) {};

/**
 * Returns the XML representation of the node and all its descendants.
 * @return {string} The XML representation of the node and all its descendants.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.getXml = function() {};

/**
 * Determines whether a node has children.
 * @return {boolean} True if this node has children; otherwise false.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.hasChildNodes = function() {};

/**
 * Inserts a child node to the left of the specified node, or at the end of the list.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} On success, the child node that was inserted. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.insertBefore = function(newChild, referenceChild) {};

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlElement.prototype.normalize = function() {};

/**
 * Removes or replaces the named attribute.
 * @param {string} attributeName The name of the attribute to be removed.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlElement.prototype.removeAttribute = function(attributeName) {};

/**
 * Removes the specified attribute from this element in the specified namespace.
 * @param {?} namespaceUri The namespace of attribute to be removed.
 * @param {string} localName The name of the attribute without the namespace prefix.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlElement.prototype.removeAttributeNS = function(namespaceUri, localName) {};

/**
 * Removes the specified attribute from this element.
 * @param {!Windows.Data.Xml.Dom.XmlAttribute} attributeNode The attribute to be removed.
 * @return {!Windows.Data.Xml.Dom.XmlAttribute} The removed attribute, if any.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.removeAttributeNode = function(attributeNode) {};

/**
 * Removes the specified child node from the list of children and returns it.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} childNode The child node to be removed from the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The removed child node. If null, the childNode object is not removed.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.removeChild = function(childNode) {};

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The old child that is to be replaced by the new child.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The old child that is replaced. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.replaceChild = function(newChild, referenceChild) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.selectNodes = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.selectNodesNS = function(xpath, namespaces) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.selectSingleNode = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.selectSingleNodeNS = function(xpath, namespaces) {};

/**
 * Sets the value of the named attribute.
 * @param {string} attributeName The name of the required attribute.
 * @param {string} attributeValue The new value for the attribute.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlElement.prototype.setAttribute = function(attributeName, attributeValue) {};

/**
 * Sets the value of the named attribute in the given namespace.
 * @param {?} namespaceUri The namespace of the attribute being set.
 * @param {string} qualifiedName The name of the attribute being set.
 * @param {string} value The new value for the attribute.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlElement.prototype.setAttributeNS = function(namespaceUri, qualifiedName, value) {};

/**
 * Sets or updates the supplied attribute node on this element.
 * @param {!Windows.Data.Xml.Dom.XmlAttribute} newAttribute A pointer to the new attribute.
 * @return {!Windows.Data.Xml.Dom.XmlAttribute} The returned pointer to the previous attribute (if any) with the same name.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.setAttributeNode = function(newAttribute) {};

/**
 * Sets or updates the supplied attribute node on this element. If you are not using any namespaces, then use the SetAttributeNode method.
 * @param {!Windows.Data.Xml.Dom.XmlAttribute} newAttribute The node to add to the collection.
 * @return {!Windows.Data.Xml.Dom.XmlAttribute} The attribute successfully added to the collection. If Null, no object is created.
 */
Windows.Data.Xml.Dom.XmlElement.prototype.setAttributeNodeNS = function(newAttribute) {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Xml.Dom.XmlEntityReference = function() {};
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.attributes;
 /** @type {!Windows.Data.Xml.Dom.XmlNodeList} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.childNodes;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.firstChild;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.innerText;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.lastChild;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.localName;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.namespaceUri;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.nextSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.nodeName;
 /** @type {Windows.Data.Xml.Dom.NodeType} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.nodeType;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.nodeValue;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.ownerDocument;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.parentNode;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.prefix;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.previousSibling;

/**
 * Appends a new child node as the last child of the node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child node to be appended to the end of the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The new child node successfully appended to the list. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.appendChild = function(newChild) {};

/**
 * Clones a new node.
 * @param {boolean} deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The newly created clone node.
 */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.cloneNode = function(deep) {};

/**
 * Returns the XML representation of the node and all its descendants.
 * @return {string} The XML representation of the node and all its descendants.
 */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.getXml = function() {};

/**
 * Determines whether a node has children.
 * @return {boolean} True if this node has children; otherwise false.
 */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.hasChildNodes = function() {};

/**
 * Inserts a child node to the left of the specified node, or at the end of the list.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} On success, the child node that was inserted. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.insertBefore = function(newChild, referenceChild) {};

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.normalize = function() {};

/**
 * Removes the specified child node from the list of children and returns it.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} childNode The child node to be removed from the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The removed child node. If null, the childNode object is not removed.
 */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.removeChild = function(childNode) {};

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The old child that is to be replaced by the new child.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The old child that is replaced. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.replaceChild = function(newChild, referenceChild) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.selectNodes = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.selectNodesNS = function(xpath, namespaces) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.selectSingleNode = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
Windows.Data.Xml.Dom.XmlEntityReference.prototype.selectSingleNodeNS = function(xpath, namespaces) {};

/**
 * @constructor
 * @struct
 * Creates a new XmlLoadSettings object.
 */
Windows.Data.Xml.Dom.XmlLoadSettings = function() {};
 /** @type {boolean} */
Windows.Data.Xml.Dom.XmlLoadSettings.prototype.elementContentWhiteSpace;
 /** @type {number} */
Windows.Data.Xml.Dom.XmlLoadSettings.prototype.maxElementDepth;
 /** @type {boolean} */
Windows.Data.Xml.Dom.XmlLoadSettings.prototype.prohibitDtd;
 /** @type {boolean} */
Windows.Data.Xml.Dom.XmlLoadSettings.prototype.resolveExternals;
 /** @type {boolean} */
Windows.Data.Xml.Dom.XmlLoadSettings.prototype.validateOnParse;
/**
 * @constructor
 * @struct
 */
Windows.Data.Xml.Dom.XmlNamedNodeMap = function() {};
 /** @type {number} */
Windows.Data.Xml.Dom.XmlNamedNodeMap.prototype.length;
 /** @type {number} */
Windows.Data.Xml.Dom.XmlNamedNodeMap.prototype.size;

/**
 * Returns an iterator that iterates over the items in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Data.Xml.Dom.IXmlNode>} The iterator.
 */
Windows.Data.Xml.Dom.XmlNamedNodeMap.prototype.first = function() {};

/**
 * Returns the item at the specified index in the vector view.
 * @param {number} index The zero-based index of the item in the vector view to return.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The item in the vector view at the specified index.
 */
Windows.Data.Xml.Dom.XmlNamedNodeMap.prototype.getAt = function(index) {};

/**
 * Returns the items that start at the specified index of the vector view.
 * @param {number} startIndex The zero-based index of the start of the items in the vector to return.
 * @return {{items: !Windows.Data.Xml.Dom.IXmlNode, returnValue: number}}
 */
Windows.Data.Xml.Dom.XmlNamedNodeMap.prototype.getMany = function(startIndex) {};

/**
 * Retrieves the attribute with the specified name.
 * @param {string} name The name of the attribute.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The returned attribute with the specified name. This method returns Null if the attribute node is not in this collection.
 */
Windows.Data.Xml.Dom.XmlNamedNodeMap.prototype.getNamedItem = function(name) {};

/**
 * Retrieves the attribute with the specified namespace and name.
 * @param {?} namespaceUri The namespace name of the attribute.
 * @param {string} name The name of the attribute.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The attribute with the specified namespace and name. This method returns Null if the attribute node is not in this collection.
 */
Windows.Data.Xml.Dom.XmlNamedNodeMap.prototype.getNamedItemNS = function(namespaceUri, name) {};

/**
 * Returns the index of a specified item in the vector view.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} value_or_searchElement The item to find in the vector view.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Data.Xml.Dom.XmlNamedNodeMap.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};

/**
 * Allows random access to individual nodes within the collection.
 * @param {number} index The index of the item within the collection. The first item is zero.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The object to access. This method returns null if the index is out of range.
 */
Windows.Data.Xml.Dom.XmlNamedNodeMap.prototype.item = function(index) {};

/**
 * Removes the specified item.
 * @param {string} name The name of the attribute to remove from the collection.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The node removed from the collection. This method returns Null if the named node is not an attribute.
 */
Windows.Data.Xml.Dom.XmlNamedNodeMap.prototype.removeNamedItem = function(name) {};

/**
 * Removes an item that is specified by a namespace and local name.
 * @param {?} namespaceUri The namespace name of the attribute.
 * @param {string} name The name of the attribute.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The node removed from the collection. This method returns Null if the named node is not an attribute.
 */
Windows.Data.Xml.Dom.XmlNamedNodeMap.prototype.removeNamedItemNS = function(namespaceUri, name) {};

/**
 * Adds the specified node to the collection.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} node The node to add to the collection.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The attribute successfully added to the collection. If Null, no object is created.
 */
Windows.Data.Xml.Dom.XmlNamedNodeMap.prototype.setNamedItem = function(node) {};

/**
 * Adds the specified node to the collection in the specified namespace. If you are not using any namespaces, then use the SetNamedItem method.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} node The node to add to the collection.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The attribute successfully added to the collection. If Null, no object is created.
 */
Windows.Data.Xml.Dom.XmlNamedNodeMap.prototype.setNamedItemNS = function(node) {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Xml.Dom.XmlNodeList = function() {};
 /** @type {number} */
Windows.Data.Xml.Dom.XmlNodeList.prototype.length;
 /** @type {number} */
Windows.Data.Xml.Dom.XmlNodeList.prototype.size;

/**
 * Returns an iterator that iterates over the items in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Data.Xml.Dom.IXmlNode>} The iterator.
 */
Windows.Data.Xml.Dom.XmlNodeList.prototype.first = function() {};

/**
 * Returns the item at the specified index in the vector view.
 * @param {number} index The zero-based index of the item in the vector view to return.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The item in the vector view at the specified index.
 */
Windows.Data.Xml.Dom.XmlNodeList.prototype.getAt = function(index) {};

/**
 * Returns the items that start at the specified index of the vector view.
 * @param {number} startIndex The zero-based index of the start of the items in the vector to return.
 * @return {{items: !Windows.Data.Xml.Dom.IXmlNode, returnValue: number}}
 */
Windows.Data.Xml.Dom.XmlNodeList.prototype.getMany = function(startIndex) {};

/**
 * Returns the index of a specified item in the vector.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} value_or_searchElement The item to find in the vector.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Data.Xml.Dom.XmlNodeList.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};

/**
 * Returns the item in the list at the specified index.
 * @param {number} index The zero-based index of the requested item.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The requested item. This method returns NULL if the index is not valid.
 */
Windows.Data.Xml.Dom.XmlNodeList.prototype.item = function(index) {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Xml.Dom.XmlProcessingInstruction = function() {};
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.attributes;
 /** @type {!Windows.Data.Xml.Dom.XmlNodeList} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.childNodes;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.data;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.firstChild;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.innerText;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.lastChild;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.localName;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.namespaceUri;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.nextSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.nodeName;
 /** @type {Windows.Data.Xml.Dom.NodeType} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.nodeType;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.nodeValue;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.ownerDocument;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.parentNode;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.prefix;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.previousSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.target;

/**
 * Appends a new child node as the last child of the node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child node to be appended to the end of the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The new child node successfully appended to the list. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.appendChild = function(newChild) {};

/**
 * Clones a new node.
 * @param {boolean} deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The newly created clone node.
 */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.cloneNode = function(deep) {};

/**
 * Returns the XML representation of the node and all its descendants.
 * @return {string} The XML representation of the node and all its descendants.
 */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.getXml = function() {};

/**
 * Determines whether a node has children.
 * @return {boolean} True if this node has children; otherwise false.
 */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.hasChildNodes = function() {};

/**
 * Inserts a child node to the left of the specified node, or at the end of the list.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} On success, the child node that was inserted. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.insertBefore = function(newChild, referenceChild) {};

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.normalize = function() {};

/**
 * Removes the specified child node from the list of children and returns it.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} childNode The child node to be removed from the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The removed child node. If null, the childNode object is not removed.
 */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.removeChild = function(childNode) {};

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The old child that is to be replaced by the new child.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The old child that is replaced. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.replaceChild = function(newChild, referenceChild) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.selectNodes = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.selectNodesNS = function(xpath, namespaces) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.selectSingleNode = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
Windows.Data.Xml.Dom.XmlProcessingInstruction.prototype.selectSingleNodeNS = function(xpath, namespaces) {};
/**
 * @constructor
 * @struct
 */
Windows.Data.Xml.Dom.XmlText = function() {};
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.XmlText.prototype.attributes;
 /** @type {!Windows.Data.Xml.Dom.XmlNodeList} */
Windows.Data.Xml.Dom.XmlText.prototype.childNodes;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlText.prototype.data;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlText.prototype.firstChild;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlText.prototype.innerText;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlText.prototype.lastChild;
 /** @type {number} */
Windows.Data.Xml.Dom.XmlText.prototype.length;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlText.prototype.localName;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlText.prototype.namespaceUri;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlText.prototype.nextSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.XmlText.prototype.nodeName;
 /** @type {Windows.Data.Xml.Dom.NodeType} */
Windows.Data.Xml.Dom.XmlText.prototype.nodeType;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlText.prototype.nodeValue;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Data.Xml.Dom.XmlText.prototype.ownerDocument;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlText.prototype.parentNode;
 /** @type {?} */
Windows.Data.Xml.Dom.XmlText.prototype.prefix;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.XmlText.prototype.previousSibling;

/**
 * Appends a new child node as the last child of the node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child node to be appended to the end of the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The new child node successfully appended to the list. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlText.prototype.appendChild = function(newChild) {};

/**
 * Appends the supplied string to the existing string data.
 * @param {string} data The data to be appended to the existing string.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlText.prototype.appendData = function(data) {};

/**
 * Clones a new node.
 * @param {boolean} deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The newly created clone node.
 */
Windows.Data.Xml.Dom.XmlText.prototype.cloneNode = function(deep) {};

/**
 * Deletes specified data.
 * @param {number} offset The offset, in characters, at which to start deleting the string data.
 * @param {number} count The number of characters to delete.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlText.prototype.deleteData = function(offset, count) {};

/**
 * Returns the XML representation of the node and all its descendants.
 * @return {string} The XML representation of the node and all its descendants.
 */
Windows.Data.Xml.Dom.XmlText.prototype.getXml = function() {};

/**
 * Determines whether a node has children.
 * @return {boolean} True if this node has children; otherwise false.
 */
Windows.Data.Xml.Dom.XmlText.prototype.hasChildNodes = function() {};

/**
 * Inserts a child node to the left of the specified node, or at the end of the list.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} On success, the child node that was inserted. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlText.prototype.insertBefore = function(newChild, referenceChild) {};

/**
 * Inserts a string at the specified offset.
 * @param {number} offset The offset, in characters, at which to insert the supplied string data.
 * @param {string} data The data to be inserted into the existing string.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlText.prototype.insertData = function(offset, data) {};

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlText.prototype.normalize = function() {};

/**
 * Removes the specified child node from the list of children and returns it.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} childNode The child node to be removed from the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The removed child node. If null, the childNode object is not removed.
 */
Windows.Data.Xml.Dom.XmlText.prototype.removeChild = function(childNode) {};

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The old child that is to be replaced by the new child.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The old child that is replaced. If null, no object is created.
 */
Windows.Data.Xml.Dom.XmlText.prototype.replaceChild = function(newChild, referenceChild) {};

/**
 * Replaces the specified number of characters with the supplied string.
 * @param {number} offset The offset, in characters, at which to start replacing string data.
 * @param {number} count The number of characters to replace.
 * @param {string} data The new data that replaces the old string data.
 * @return {void}
 */
Windows.Data.Xml.Dom.XmlText.prototype.replaceData = function(offset, count, data) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlText.prototype.selectNodes = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
Windows.Data.Xml.Dom.XmlText.prototype.selectNodesNS = function(xpath, namespaces) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
Windows.Data.Xml.Dom.XmlText.prototype.selectSingleNode = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
Windows.Data.Xml.Dom.XmlText.prototype.selectSingleNodeNS = function(xpath, namespaces) {};

/**
 * Splits this text node into two text nodes at the specified offset and inserts the new text node into the tree as a sibling that immediately follows this node.
 * @param {number} offset The number of characters at which to split this text node into two nodes, starting from zero.
 * @return {!Windows.Data.Xml.Dom.IXmlText} The new text node.
 */
Windows.Data.Xml.Dom.XmlText.prototype.splitText = function(offset) {};

/**
 * Retrieves a substring of the full string from the specified range.
 * @param {number} offset The offset, in characters, from the beginning of the string. An offset of zero indicates copying from the start of the data.
 * @param {number} count The number of characters to retrieve from the specified offset.
 * @return {string} The returned substring.
 */
Windows.Data.Xml.Dom.XmlText.prototype.substringData = function(offset, count) {};
/**
 * @extends {Windows.Data.Xml.Dom.IXmlNodeSelector}
 * @extends {Windows.Data.Xml.Dom.IXmlNodeSerializer}
 * @record
 * @struct
 */
Windows.Data.Xml.Dom.IXmlNode = function() {};
 /** @type {!Windows.Data.Xml.Dom.XmlNamedNodeMap} */
Windows.Data.Xml.Dom.IXmlNode.prototype.attributes;
 /** @type {!Windows.Data.Xml.Dom.XmlNodeList} */
Windows.Data.Xml.Dom.IXmlNode.prototype.childNodes;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.IXmlNode.prototype.firstChild;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.IXmlNode.prototype.lastChild;
 /** @type {?} */
Windows.Data.Xml.Dom.IXmlNode.prototype.localName;
 /** @type {?} */
Windows.Data.Xml.Dom.IXmlNode.prototype.namespaceUri;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.IXmlNode.prototype.nextSibling;
 /** @type {string} */
Windows.Data.Xml.Dom.IXmlNode.prototype.nodeName;
 /** @type {Windows.Data.Xml.Dom.NodeType} */
Windows.Data.Xml.Dom.IXmlNode.prototype.nodeType;
 /** @type {?} */
Windows.Data.Xml.Dom.IXmlNode.prototype.nodeValue;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Data.Xml.Dom.IXmlNode.prototype.ownerDocument;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.IXmlNode.prototype.parentNode;
 /** @type {?} */
Windows.Data.Xml.Dom.IXmlNode.prototype.prefix;
 /** @type {!Windows.Data.Xml.Dom.IXmlNode} */
Windows.Data.Xml.Dom.IXmlNode.prototype.previousSibling;

/**
 * Appends a new child node as the last child of the node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child node to be appended to the end of the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The new child node successfully appended to the list. If null, no object is created.
 */
Windows.Data.Xml.Dom.IXmlNode.prototype.appendChild = function(newChild) {};

/**
 * Clones a new node.
 * @param {boolean} deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The newly created clone node.
 */
Windows.Data.Xml.Dom.IXmlNode.prototype.cloneNode = function(deep) {};

/**
 * Determines whether a node has children.
 * @return {boolean} True if this node has children; otherwise false.
 */
Windows.Data.Xml.Dom.IXmlNode.prototype.hasChildNodes = function() {};

/**
 * Inserts a child node to the left of the specified node, or at the end of the list.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} On success, the child node that was inserted. If null, no object is created.
 */
Windows.Data.Xml.Dom.IXmlNode.prototype.insertBefore = function(newChild, referenceChild) {};

/**
 * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node.
 * @return {void}
 */
Windows.Data.Xml.Dom.IXmlNode.prototype.normalize = function() {};

/**
 * Removes the specified child node from the list of children and returns it.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} childNode The child node to be removed from the list of children of this node.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The removed child node. If null, the childNode object is not removed.
 */
Windows.Data.Xml.Dom.IXmlNode.prototype.removeChild = function(childNode) {};

/**
 * Replaces the specified old child node with the supplied new child node.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} referenceChild The old child that is to be replaced by the new child.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The old child that is replaced. If null, no object is created.
 */
Windows.Data.Xml.Dom.IXmlNode.prototype.replaceChild = function(newChild, referenceChild) {};
/**
 * @extends {Windows.Data.Xml.Dom.IXmlCharacterData}
 * @extends {Windows.Data.Xml.Dom.IXmlNode}
 * @extends {Windows.Data.Xml.Dom.IXmlNodeSelector}
 * @extends {Windows.Data.Xml.Dom.IXmlNodeSerializer}
 * @record
 * @struct
 */
Windows.Data.Xml.Dom.IXmlText = function() {};

/**
 * Splits this text node into two text nodes at the specified offset and inserts the new text node into the tree as a sibling that immediately follows this node.
 * @param {number} offset The number of characters at which to split this text node into two nodes, starting from zero.
 * @return {!Windows.Data.Xml.Dom.IXmlText} The new text node.
 */
Windows.Data.Xml.Dom.IXmlText.prototype.splitText = function(offset) {};
/**
 * @record
 * @struct
 */
Windows.Data.Xml.Dom.IXmlNodeSelector = function() {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
 */
Windows.Data.Xml.Dom.IXmlNodeSelector.prototype.selectNodes = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList.
 * @param {string} xpath Specifies an XPath expresssion.
 * @param {?} namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.XmlNodeList} The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
 */
Windows.Data.Xml.Dom.IXmlNodeSelector.prototype.selectNodesNS = function(xpath, namespaces) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
 */
Windows.Data.Xml.Dom.IXmlNodeSelector.prototype.selectSingleNode = function(xpath) {};

/**
 * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
 * @param {string} xpath Specifies an XPath expression.
 * @param {?} namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
 * @return {!Windows.Data.Xml.Dom.IXmlNode} The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
 */
Windows.Data.Xml.Dom.IXmlNodeSelector.prototype.selectSingleNodeNS = function(xpath, namespaces) {};
/**
 * @record
 * @struct
 */
Windows.Data.Xml.Dom.IXmlNodeSerializer = function() {};
 /** @type {string} */
Windows.Data.Xml.Dom.IXmlNodeSerializer.prototype.innerText;

/**
 * Returns the XML representation of the node and all its descendants.
 * @return {string} The XML representation of the node and all its descendants.
 */
Windows.Data.Xml.Dom.IXmlNodeSerializer.prototype.getXml = function() {};
/**
 * @extends {Windows.Data.Xml.Dom.IXmlNode}
 * @extends {Windows.Data.Xml.Dom.IXmlNodeSelector}
 * @extends {Windows.Data.Xml.Dom.IXmlNodeSerializer}
 * @record
 * @struct
 */
Windows.Data.Xml.Dom.IXmlCharacterData = function() {};
 /** @type {string} */
Windows.Data.Xml.Dom.IXmlCharacterData.prototype.data;
 /** @type {number} */
Windows.Data.Xml.Dom.IXmlCharacterData.prototype.length;

/**
 * Appends the supplied string to the existing string data.
 * @param {string} data The data to be appended to the existing string.
 * @return {void}
 */
Windows.Data.Xml.Dom.IXmlCharacterData.prototype.appendData = function(data) {};

/**
 * Deletes specified data.
 * @param {number} offset The offset, in characters, at which to start deleting the string data.
 * @param {number} count The number of characters to delete.
 * @return {void}
 */
Windows.Data.Xml.Dom.IXmlCharacterData.prototype.deleteData = function(offset, count) {};

/**
 * Inserts a string at the specified offset.
 * @param {number} offset The offset, in characters, at which to insert the supplied string data.
 * @param {string} data The data to be inserted into the existing string.
 * @return {void}
 */
Windows.Data.Xml.Dom.IXmlCharacterData.prototype.insertData = function(offset, data) {};

/**
 * Replaces the specified number of characters with the supplied string.
 * @param {number} offset The offset, in characters, at which to start replacing string data.
 * @param {number} count The number of characters to replace.
 * @param {string} data The new data that replaces the old string data.
 * @return {void}
 */
Windows.Data.Xml.Dom.IXmlCharacterData.prototype.replaceData = function(offset, count, data) {};

/**
 * Retrieves a substring of the full string from the specified range.
 * @param {number} offset Specifies the offset, in characters, from the beginning of the string. An offset of zero indicates copying from the start of the data.
 * @param {number} count Specifies the number of characters to retrieve from the specified offset.
 * @return {string} The returned substring.
 */
Windows.Data.Xml.Dom.IXmlCharacterData.prototype.substringData = function(offset, count) {};
/** @const */
Windows.Data.Xml.Xsl = {};

/**
 * @constructor
 * @struct
 * Creates a new XsltProcessor object from the document provided.
 * @param {!Windows.Data.Xml.Dom.XmlDocument} document The XSLT to process.
 */
Windows.Data.Xml.Xsl.XsltProcessor = function(document) {};

/**
 * Processes a node and its children and returns the resulting XmlDocument .
 * @param {!Windows.Data.Xml.Dom.IXmlNode} inputNode The node to process.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The resulting transformation.
 */
Windows.Data.Xml.Xsl.XsltProcessor.prototype.transformToDocument = function(inputNode) {};

/**
 * Processes a node and its children and returns the resulting string transformation.
 * @param {!Windows.Data.Xml.Dom.IXmlNode} inputNode The node to process.
 * @return {string} The resulting transformation.
 */
Windows.Data.Xml.Xsl.XsltProcessor.prototype.transformToString = function(inputNode) {};
/** @const */
Windows.Devices = {};
/** @const */
Windows.Devices.Adc = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Adc.AdcChannel = function() {};
 /** @type {!Windows.Devices.Adc.AdcController} */
Windows.Devices.Adc.AdcChannel.prototype.controller;

/**
 * Closes the connection on this channel, making it available to be opened by others.
 * @return {void}
 */
Windows.Devices.Adc.AdcChannel.prototype.close = function() {};

/**
 * Reads the value as a percentage of the max value possible for this controller.
 * @return {number} The value as percentage of the max value.
 */
Windows.Devices.Adc.AdcChannel.prototype.readRatio = function() {};

/**
 * Reads the digital representation of the analog value from the ADC.
 * @return {number} The digital value.
 */
Windows.Devices.Adc.AdcChannel.prototype.readValue = function() {};

/** @const */
Windows.Devices.Adc.AdcChannelMode = {};
/** @const {number} */
Windows.Devices.Adc.AdcChannelMode.singleEnded;
/** @const {number} */
Windows.Devices.Adc.AdcChannelMode.differential;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Adc.AdcController = function() {};
 /** @type {number} */
Windows.Devices.Adc.AdcController.prototype.channelCount;
 /** @type {Windows.Devices.Adc.AdcChannelMode} */
Windows.Devices.Adc.AdcController.prototype.channelMode;
 /** @type {number} */
Windows.Devices.Adc.AdcController.prototype.maxValue;
 /** @type {number} */
Windows.Devices.Adc.AdcController.prototype.minValue;
 /** @type {number} */
Windows.Devices.Adc.AdcController.prototype.resolutionInBits;

/**
 * Gets all the controllers that are connected to the system asynchronously .
 * @param {!Windows.Devices.Adc.Provider.IAdcProvider} provider The ADC provider for the controllers on the system.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When the method completes successfully, it returns a list of values that represent the controllers available on the system.
 */
Windows.Devices.Adc.AdcController.getControllersAsync = function(provider) {};

/**
 * Gets the default ADC controller on the system.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Adc.AdcController, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Adc.AdcController>>} The default ADC controller on the system, or null if the system has no ADC controller.
 */
Windows.Devices.Adc.AdcController.getDefaultAsync = function() {};

/**
 * Verifies that the specified channel mode is supported by the controller.
 * @param {Windows.Devices.Adc.AdcChannelMode} channelMode The channel mode.
 * @return {boolean} True if the specified channel mode is supported, otherwise false.
 */
Windows.Devices.Adc.AdcController.prototype.isChannelModeSupported = function(channelMode) {};

/**
 * Opens a connection to the specified ADC channel.
 * @param {number} channelNumber The channel to connect to.
 * @return {!Windows.Devices.Adc.AdcChannel} The ADC channel.
 */
Windows.Devices.Adc.AdcController.prototype.openChannel = function(channelNumber) {};
/** @const */
Windows.Devices.Adc.Provider = {};

/** @const */
Windows.Devices.Adc.Provider.ProviderAdcChannelMode = {};
/** @const {number} */
Windows.Devices.Adc.Provider.ProviderAdcChannelMode.singleEnded;
/** @const {number} */
Windows.Devices.Adc.Provider.ProviderAdcChannelMode.differential;
/**
 * @record
 * @struct
 */
Windows.Devices.Adc.Provider.IAdcProvider = function() {};

/**
 * Gets the ADC controllers available on the system.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Adc.Provider.IAdcControllerProvider>} When this method completes it returns a list of all the available controllers on the system.
 */
Windows.Devices.Adc.Provider.IAdcProvider.prototype.getControllers = function() {};
/**
 * @record
 * @struct
 */
Windows.Devices.Adc.Provider.IAdcControllerProvider = function() {};
 /** @type {number} */
Windows.Devices.Adc.Provider.IAdcControllerProvider.prototype.channelCount;
 /** @type {Windows.Devices.Adc.Provider.ProviderAdcChannelMode} */
Windows.Devices.Adc.Provider.IAdcControllerProvider.prototype.channelMode;
 /** @type {number} */
Windows.Devices.Adc.Provider.IAdcControllerProvider.prototype.maxValue;
 /** @type {number} */
Windows.Devices.Adc.Provider.IAdcControllerProvider.prototype.minValue;
 /** @type {number} */
Windows.Devices.Adc.Provider.IAdcControllerProvider.prototype.resolutionInBits;

/**
 * Acquires a connection to the specified channel.
 * @param {number} channel Which channel to connect to.
 * @return {void}
 */
Windows.Devices.Adc.Provider.IAdcControllerProvider.prototype.acquireChannel = function(channel) {};

/**
 * Determines if the specified channel mode is supported by the controller.
 * @param {Windows.Devices.Adc.Provider.ProviderAdcChannelMode} channelMode The channel mode in question.
 * @return {boolean} True if the specified channel mode is supported, otherwise false.
 */
Windows.Devices.Adc.Provider.IAdcControllerProvider.prototype.isChannelModeSupported = function(channelMode) {};

/**
 * Gets the digital representation of the analog value on the specified channel.
 * @param {number} channelNumber Which channel to read from.
 * @return {number} The digital representation of the analog value.
 */
Windows.Devices.Adc.Provider.IAdcControllerProvider.prototype.readValue = function(channelNumber) {};

/**
 * Releases the channel connection, opening that channel for others to use.
 * @param {number} channel Which channel to close the connection to.
 * @return {void}
 */
Windows.Devices.Adc.Provider.IAdcControllerProvider.prototype.releaseChannel = function(channel) {};
/** @const */
Windows.Devices.AllJoyn = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.AllJoyn.AllJoynAboutData = function() {};
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutData.prototype.appId;
 /** @type {!Windows.Foundation.Collections.IMap<string, string>} */
Windows.Devices.AllJoyn.AllJoynAboutData.prototype.appNames;
 /** @type {!Date} */
Windows.Devices.AllJoyn.AllJoynAboutData.prototype.dateOfManufacture;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutData.prototype.defaultAppName;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutData.prototype.defaultDescription;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutData.prototype.defaultManufacturer;
 /** @type {!Windows.Foundation.Collections.IMap<string, string>} */
Windows.Devices.AllJoyn.AllJoynAboutData.prototype.descriptions;
 /** @type {boolean} */
Windows.Devices.AllJoyn.AllJoynAboutData.prototype.isEnabled;
 /** @type {!Windows.Foundation.Collections.IMap<string, string>} */
Windows.Devices.AllJoyn.AllJoynAboutData.prototype.manufacturers;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutData.prototype.modelNumber;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutData.prototype.softwareVersion;
 /** @type {!Windows.Foundation.Uri} */
Windows.Devices.AllJoyn.AllJoynAboutData.prototype.supportUrl;
/**
 * @constructor
 * @struct
 */
Windows.Devices.AllJoyn.AllJoynAboutDataView = function() {};
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.ajSoftwareVersion;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.appId;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.appName;
 /** @type {!Date} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.dateOfManufacture;
 /** @type {!Windows.Globalization.Language} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.defaultLanguage;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.description;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.deviceId;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.deviceName;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.hardwareVersion;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.manufacturer;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.modelNumber;
 /** @type {!Windows.Foundation.Collections.IMapView<string, ?>} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.properties;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.softwareVersion;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.status;
 /** @type {!Windows.Foundation.Uri} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.supportUrl;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Globalization.Language>} */
Windows.Devices.AllJoyn.AllJoynAboutDataView.prototype.supportedLanguages;

/**
 * Gets the About data for a session in a particular language.
 * Gets the About data for a session.
 * @param {string} uniqueName The unique name.
 * @param {!Windows.Devices.AllJoyn.AllJoynBusAttachment} busAttachment The bus attachment supporting the session.
 * @param {number} sessionPort The port used to connect to the session.
 * @param {!Windows.Globalization.Language=} language The language to return the descriptive data in.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.AllJoyn.AllJoynAboutDataView, !Windows.Foundation.IAsyncOperation<!Windows.Devices.AllJoyn.AllJoynAboutDataView>>} An object containing About data for the session in the set language. / An object containing About data for the session.
 */
Windows.Devices.AllJoyn.AllJoynAboutDataView.getDataBySessionPortAsync = function(uniqueName, busAttachment, sessionPort, language) {};

/**
 * @constructor
 * @struct
 * Generates an object containing information about the connection being accepted to the session and the method that completes the session join.
 * @param {string} uniqueName The unique bus name.
 * @param {number} sessionPort The session port used for the connection.
 * @param {Windows.Devices.AllJoyn.AllJoynTrafficType} trafficType The type of traffic provided over the connection.
 * @param {number} proximity Indicates network proximity.
 * @param {!Windows.Devices.AllJoyn.IAllJoynAcceptSessionJoiner} acceptSessionJoiner The IAllJoynAcceptSessionJoiner object used to complete the session join.
 */
Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs = function(uniqueName, sessionPort, trafficType, proximity, acceptSessionJoiner) {};
 /** @type {boolean} */
Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs.prototype.sameNetwork;
 /** @type {boolean} */
Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs.prototype.samePhysicalNode;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs.prototype.sessionPort;
 /** @type {Windows.Devices.AllJoyn.AllJoynTrafficType} */
Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs.prototype.trafficType;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs.prototype.uniqueName;

/**
 * Called to accept the session connection.
 * @return {void}
 */
Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs.prototype.accept = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.AllJoyn.AllJoynAuthenticationCompleteEventArgs = function() {};
 /** @type {Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism} */
Windows.Devices.AllJoyn.AllJoynAuthenticationCompleteEventArgs.prototype.authenticationMechanism;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynAuthenticationCompleteEventArgs.prototype.peerUniqueName;
 /** @type {boolean} */
Windows.Devices.AllJoyn.AllJoynAuthenticationCompleteEventArgs.prototype.succeeded;

/** @const */
Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism = {};
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism.none;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism.srpAnonymous;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism.srpLogon;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism.ecdheNull;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism.ecdhePsk;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism.ecdheEcdsa;

/**
 * @constructor
 * @struct
 * Generates an AllJoynBusAttachment object using the default named pipe connection specification.
 * Generates an AllJoynBusAttachment object using the provided connection specification.
 * @param {string=} connectionSpecification Specification used to initiate and maintain connections to a router node (bus). Windows 10 supports the 'npipe:' transport, formatted according to the D-Bus Specification.
 */
Windows.Devices.AllJoyn.AllJoynBusAttachment = function(connectionSpecification) {};
 /** @type {!Windows.Devices.AllJoyn.AllJoynAboutData} */
Windows.Devices.AllJoyn.AllJoynBusAttachment.prototype.aboutData;
 /** @type {!Windows.Foundation.Collections.IVector<Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism>} */
Windows.Devices.AllJoyn.AllJoynBusAttachment.prototype.authenticationMechanisms;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynBusAttachment.prototype.connectionSpecification;
 /** @type {function(?): void} */
Windows.Devices.AllJoyn.AllJoynBusAttachment.prototype.onauthenticationcomplete;
 /** @type {function(?): void} */
Windows.Devices.AllJoyn.AllJoynBusAttachment.prototype.oncredentialsrequested;
 /** @type {function(?): void} */
Windows.Devices.AllJoyn.AllJoynBusAttachment.prototype.oncredentialsverificationrequested;
 /** @type {function(?): void} */
Windows.Devices.AllJoyn.AllJoynBusAttachment.prototype.onstatechanged;
 /** @type {Windows.Devices.AllJoyn.AllJoynBusAttachmentState} */
Windows.Devices.AllJoyn.AllJoynBusAttachment.prototype.state;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynBusAttachment.prototype.uniqueName;

/**
 * Initiates the connection.
 * @return {void}
 */
Windows.Devices.AllJoyn.AllJoynBusAttachment.prototype.connect = function() {};

/**
 * Initiates a disconnect operation from the router node (bus).
 * @return {void}
 */
Windows.Devices.AllJoyn.AllJoynBusAttachment.prototype.disconnect = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.AllJoyn.AllJoynBusAttachment.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.AllJoyn.AllJoynBusAttachment.prototype.removeEventListener = function(type, listener) {};

/**
 * Pings the specified connection asynchronously.
 * @param {string} uniqueName The unique name associated with the connection.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} An AllJoyn status code.
 */
Windows.Devices.AllJoyn.AllJoynBusAttachment.prototype.pingAsync = function(uniqueName) {};

/** @const */
Windows.Devices.AllJoyn.AllJoynBusAttachmentState = {};
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynBusAttachmentState.disconnected;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynBusAttachmentState.connecting;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynBusAttachmentState.connected;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynBusAttachmentState.disconnecting;
/**
 * @constructor
 * @struct
 */
Windows.Devices.AllJoyn.AllJoynBusAttachmentStateChangedEventArgs = function() {};
 /** @type {Windows.Devices.AllJoyn.AllJoynBusAttachmentState} */
Windows.Devices.AllJoyn.AllJoynBusAttachmentStateChangedEventArgs.prototype.state;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynBusAttachmentStateChangedEventArgs.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Devices.AllJoyn.AllJoynCredentials = function() {};
 /** @type {Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism} */
Windows.Devices.AllJoyn.AllJoynCredentials.prototype.authenticationMechanism;
 /** @type {!Windows.Security.Cryptography.Certificates.Certificate} */
Windows.Devices.AllJoyn.AllJoynCredentials.prototype.certificate;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Devices.AllJoyn.AllJoynCredentials.prototype.passwordCredential;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynCredentials.prototype.timeout;
/**
 * @constructor
 * @struct
 */
Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs = function() {};
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs.prototype.attemptCount;
 /** @type {!Windows.Devices.AllJoyn.AllJoynCredentials} */
Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs.prototype.credentials;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs.prototype.peerUniqueName;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs.prototype.requestedUserName;

/**
 * Allows JavaScript Windows Store apps to handle the verification of provided of credentials asynchronously.
 * @return {!Windows.Foundation.Deferral} The credential request deferral.
 */
Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs = function() {};
 /** @type {Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism} */
Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs.prototype.authenticationMechanism;
 /** @type {!Windows.Security.Cryptography.Certificates.Certificate} */
Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs.prototype.peerCertificate;
 /** @type {Windows.Networking.Sockets.SocketSslErrorSeverity} */
Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs.prototype.peerCertificateErrorSeverity;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.ChainValidationResult>} */
Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs.prototype.peerCertificateErrors;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Cryptography.Certificates.Certificate>} */
Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs.prototype.peerIntermediateCertificates;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs.prototype.peerUniqueName;

/**
 * Calling this method indicates that the credentials provided for authentication are valid.
 * @return {void}
 */
Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs.prototype.accept = function() {};

/**
 * Conducts verification of provided of credentials asynchronously.
 * @return {!Windows.Foundation.Deferral} The verification deferral.
 */
Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs.prototype.getDeferral = function() {};

/**
 * @constructor
 * @struct
 * Generates an AllJoynMessageInfo object that contains the unique name of the sender that sent the message being processed.
 * @param {string} senderUniqueName The unique name of the sender.
 */
Windows.Devices.AllJoyn.AllJoynMessageInfo = function(senderUniqueName) {};
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynMessageInfo.prototype.senderUniqueName;

/**
 * @constructor
 * @struct
 * Generates an object containing status information for the stopped Producer app.
 * @param {number} status An AllJoyn status code that indicates why the Producer was stopped.
 */
Windows.Devices.AllJoyn.AllJoynProducerStoppedEventArgs = function(status) {};
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynProducerStoppedEventArgs.prototype.status;

/**
 * @constructor
 * @struct
 * Generates an AllJoynServiceInfo object that represents an advertising app. This object provides the unique bus name, object path and transport information.
 * @param {string} uniqueName The unique bus name.
 * @param {string} objectPath The object path.
 * @param {number} sessionPort The port for this session.
 */
Windows.Devices.AllJoyn.AllJoynServiceInfo = function(uniqueName, objectPath, sessionPort) {};
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynServiceInfo.prototype.objectPath;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynServiceInfo.prototype.sessionPort;
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynServiceInfo.prototype.uniqueName;

/**
 * @constructor
 * @struct
 * Generates an object containing information about an advertising app that is no longer available.
 * @param {string} uniqueName The unique app name.
 */
Windows.Devices.AllJoyn.AllJoynServiceInfoRemovedEventArgs = function(uniqueName) {};
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynServiceInfoRemovedEventArgs.prototype.uniqueName;

/**
 * @constructor
 * @struct
 * Generates an AllJoynSessionLostEventArgs object containing information that identifies the reason for the lost session.
 * @param {Windows.Devices.AllJoyn.AllJoynSessionLostReason} reason The reason the session was lost.
 */
Windows.Devices.AllJoyn.AllJoynSessionLostEventArgs = function(reason) {};
 /** @type {Windows.Devices.AllJoyn.AllJoynSessionLostReason} */
Windows.Devices.AllJoyn.AllJoynSessionLostEventArgs.prototype.reason;

/** @const */
Windows.Devices.AllJoyn.AllJoynSessionLostReason = {};
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynSessionLostReason.none;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynSessionLostReason.producerLeftSession;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynSessionLostReason.producerClosedAbruptly;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynSessionLostReason.removedByProducer;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynSessionLostReason.linkTimeout;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynSessionLostReason.other;

/**
 * @constructor
 * @struct
 * Generates an object that contains information about the remote app added to the session.
 * @param {string} uniqueName The unique Consumer name.
 */
Windows.Devices.AllJoyn.AllJoynSessionMemberAddedEventArgs = function(uniqueName) {};
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynSessionMemberAddedEventArgs.prototype.uniqueName;

/**
 * @constructor
 * @struct
 * Generates an object containing information about a remote app removed from a session.
 * @param {string} uniqueName The unique bus name of the remote app removed from the session.
 */
Windows.Devices.AllJoyn.AllJoynSessionMemberRemovedEventArgs = function(uniqueName) {};
 /** @type {string} */
Windows.Devices.AllJoyn.AllJoynSessionMemberRemovedEventArgs.prototype.uniqueName;
/**
 * @constructor
 * @struct
 */
Windows.Devices.AllJoyn.AllJoynStatus = function() {};
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.authenticationFailed;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.authenticationRejectedByUser;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.connectionRefused;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.fail;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.insufficientSecurity;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.invalidArgument1;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.invalidArgument2;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.invalidArgument3;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.invalidArgument4;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.invalidArgument5;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.invalidArgument6;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.invalidArgument7;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.invalidArgument8;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.ok;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.operationTimedOut;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.otherEndClosed;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.sslConnectFailed;
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynStatus.sslIdentityVerificationFailed;

/** @const */
Windows.Devices.AllJoyn.AllJoynTrafficType = {};
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynTrafficType.unknown;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynTrafficType.messages;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynTrafficType.rawUnreliable;
/** @const {number} */
Windows.Devices.AllJoyn.AllJoynTrafficType.rawReliable;

/**
 * @constructor
 * @struct
 * Generates an AllJoynWatcherStoppedEventArgs object that contains status information that identifies the reason the watcher object was stopped.
 * @param {number} status The AllJoyn status code.
 */
Windows.Devices.AllJoyn.AllJoynWatcherStoppedEventArgs = function(status) {};
 /** @type {number} */
Windows.Devices.AllJoyn.AllJoynWatcherStoppedEventArgs.prototype.status;
/**
 * @record
 * @struct
 */
Windows.Devices.AllJoyn.IAllJoynAcceptSessionJoiner = function() {};

/**
 * Accept an incoming request to join the session.
 * @return {void}
 */
Windows.Devices.AllJoyn.IAllJoynAcceptSessionJoiner.prototype.accept = function() {};
/** @const */
Windows.Devices.Background = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Background.DeviceServicingDetails = function() {};
 /** @type {string} */
Windows.Devices.Background.DeviceServicingDetails.prototype.arguments;
 /** @type {string} */
Windows.Devices.Background.DeviceServicingDetails.prototype.deviceId;
 /** @type {number} */
Windows.Devices.Background.DeviceServicingDetails.prototype.expectedDuration;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Background.DeviceUseDetails = function() {};
 /** @type {string} */
Windows.Devices.Background.DeviceUseDetails.prototype.arguments;
 /** @type {string} */
Windows.Devices.Background.DeviceUseDetails.prototype.deviceId;
/** @const */
Windows.Devices.Bluetooth = {};
/** @const */
Windows.Devices.Bluetooth.Advertisement = {};

/**
 * @constructor
 * @struct
 * Creates a new BluetoothLEAdvertisement object.
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataSection>} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement.prototype.dataSections;
 /** @type {Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFlags} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement.prototype.flags;
 /** @type {string} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement.prototype.localName;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Devices.Bluetooth.Advertisement.BluetoothLEManufacturerData>} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement.prototype.manufacturerData;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement.prototype.serviceUuids;

/**
 * Return a list of all manufacturer data sections in the BluetoothLEAdvertisement payload matching the specified company ID.
 * @param {number} companyId The company identifier code defined by the Bluetooth Special Interest Group (SIG).
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Bluetooth.Advertisement.BluetoothLEManufacturerData>} A vector of BluetoothLEManufacturerData contained within the payload.
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement.prototype.getManufacturerDataByCompanyId = function(companyId) {};

/**
 * Return a list of advertisement data sections that matches a given advertisement section type in a BluetoothLEAdvertisement .
 * @param {number} type The advertisement section type
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataSection>} A vector of all the BluetoothLEAdvertisementDataSection matching the given advertisement type.
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement.prototype.getSectionsByType = function(type) {};

/**
 * @constructor
 * @struct
 * Create a new BluetoothLEAdvertisementBytePattern object.
 * Create a new BluetoothLEAdvertisementBytePattern object with an advertisement data type to match, the advertisement data byte pattern to match, and the offset of the byte pattern from the beginning of the advertisement data section.
 * @param {number=} dataType The Bluetooth LE advertisement data type to match.
 * @param {number=} offset The offset of byte pattern from beginning of advertisement data section.
 * @param {!Windows.Storage.Streams.IBuffer=} data The Bluetooth LE advertisement data byte pattern to match.
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementBytePattern = function(dataType, offset, data) {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementBytePattern.prototype.data;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementBytePattern.prototype.dataType;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementBytePattern.prototype.offset;

/**
 * @constructor
 * @struct
 * Creates a new BluetoothLEAdvertisementDataSection object.
 * Creates a new BluetoothLEAdvertisementDataSection object with the Bluetooth LE advertisement data type and the payload.
 * @param {number=} dataType The Bluetooth LE advertisement data type as defined by the Bluetooth Special Interest Group (SIG).
 * @param {!Windows.Storage.Streams.IBuffer=} data The Bluetooth LE advertisement data payload.
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataSection = function(dataType, data) {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataSection.prototype.data;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataSection.prototype.dataType;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes = function() {};
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.advertisingInterval;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.appearance;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.completeLocalName;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.completeService128BitUuids;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.completeService16BitUuids;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.completeService32BitUuids;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.flags;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.incompleteService128BitUuids;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.incompleteService16BitUuids;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.incompleteService32BitUuids;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.manufacturerSpecificData;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.publicTargetAddress;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.randomTargetAddress;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.serviceData128BitUuids;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.serviceData16BitUuids;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.serviceData32BitUuids;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.serviceSolicitation128BitUuids;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.serviceSolicitation16BitUuids;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.serviceSolicitation32BitUuids;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.shortenedLocalName;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.slaveConnectionIntervalRange;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes.txPowerLevel;

/**
 * @constructor
 * @struct
 * Creates a new BluetoothLEAdvertisementFilter object.
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFilter = function() {};
 /** @type {!Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFilter.prototype.advertisement;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementBytePattern>} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFilter.prototype.bytePatterns;

/** @const */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFlags = {};
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFlags.none;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFlags.limitedDiscoverableMode;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFlags.generalDiscoverableMode;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFlags.classicNotSupported;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFlags.dualModeControllerCapable;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFlags.dualModeHostCapable;

/**
 * @constructor
 * @struct
 * Creates a new BluetoothLEAdvertisementPublisher object.
 * Creates a new BluetoothLEAdvertisementPublisher object with the Bluetooth LE advertisement to publish.
 * @param {!Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement=} advertisement The Bluetooth LE advertisement to publish.
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher = function(advertisement) {};
 /** @type {!Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher.prototype.advertisement;
 /** @type {function(?): void} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher.prototype.onstatuschanged;
 /** @type {Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatus} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher.prototype.removeEventListener = function(type, listener) {};

/**
 * Start advertising a Bluetooth LE advertisement payload.
 * @return {void}
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher.prototype.start = function() {};

/**
 * Stop the publisher and stop advertising a Bluetooth LE advertisement payload.
 * @return {void}
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher.prototype.stop = function() {};

/** @const */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatus = {};
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatus.created;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatus.waiting;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatus.started;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatus.stopping;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatus.stopped;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatus.aborted;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatusChangedEventArgs = function() {};
 /** @type {Windows.Devices.Bluetooth.BluetoothError} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatusChangedEventArgs.prototype.error;
 /** @type {Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatus} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatusChangedEventArgs.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs = function() {};
 /** @type {!Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs.prototype.advertisement;
 /** @type {Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementType} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs.prototype.advertisementType;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs.prototype.bluetoothAddress;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs.prototype.rawSignalStrengthInDBm;
 /** @type {!Date} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs.prototype.timestamp;

/** @const */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementType = {};
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementType.connectableUndirected;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementType.connectableDirected;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementType.scannableUndirected;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementType.nonConnectableUndirected;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementType.scanResponse;

/**
 * @constructor
 * @struct
 * Creates a new BluetoothLEAdvertisementWatcher object with an advertisement filter to initialize the watcher.
 * Creates a new BluetoothLEAdvertisementWatcher object.
 * @param {!Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFilter=} advertisementFilter The advertisement filter to initialize the watcher.
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher = function(advertisementFilter) {};
 /** @type {!Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFilter} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher.prototype.advertisementFilter;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher.prototype.maxOutOfRangeTimeout;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher.prototype.maxSamplingInterval;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher.prototype.minOutOfRangeTimeout;
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher.prototype.minSamplingInterval;
 /** @type {function(?): void} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher.prototype.onreceived;
 /** @type {function(?): void} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher.prototype.onstopped;
 /** @type {Windows.Devices.Bluetooth.Advertisement.BluetoothLEScanningMode} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher.prototype.scanningMode;
 /** @type {!Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher.prototype.signalStrengthFilter;
 /** @type {Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcherStatus} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher.prototype.removeEventListener = function(type, listener) {};

/**
 * Start the BluetoothLEAdvertisementWatcher to scan for Bluetooth LE advertisements.
 * @return {void}
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher.prototype.start = function() {};

/**
 * Stop the BluetoothLEAdvertisementWatcher and disable the scanning for Bluetooth LE advertisements.
 * @return {void}
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher.prototype.stop = function() {};

/** @const */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcherStatus = {};
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcherStatus.created;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcherStatus.started;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcherStatus.stopping;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcherStatus.stopped;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcherStatus.aborted;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcherStoppedEventArgs = function() {};
 /** @type {Windows.Devices.Bluetooth.BluetoothError} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcherStoppedEventArgs.prototype.error;

/**
 * @constructor
 * @struct
 * Creates a new BluetoothLEManufacturerData object.
 * Creates a new BluetoothLEManufacturerData object with a company identifier code and manufacterer-specific section data.
 * @param {number=} companyId The Bluetooth LE company identifier code as defined by the Bluetooth Special Interest Group (SIG).
 * @param {!Windows.Storage.Streams.IBuffer=} data Bluetooth LE manufacturer-specific section data.
 */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEManufacturerData = function(companyId, data) {};
 /** @type {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEManufacturerData.prototype.companyId;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEManufacturerData.prototype.data;

/** @const */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEScanningMode = {};
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEScanningMode.passive;
/** @const {number} */
Windows.Devices.Bluetooth.Advertisement.BluetoothLEScanningMode.active;
/** @const */
Windows.Devices.Bluetooth.Background = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.Background.BluetoothLEAdvertisementPublisherTriggerDetails = function() {};
 /** @type {Windows.Devices.Bluetooth.BluetoothError} */
Windows.Devices.Bluetooth.Background.BluetoothLEAdvertisementPublisherTriggerDetails.prototype.error;
 /** @type {Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatus} */
Windows.Devices.Bluetooth.Background.BluetoothLEAdvertisementPublisherTriggerDetails.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.Background.BluetoothLEAdvertisementWatcherTriggerDetails = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs>} */
Windows.Devices.Bluetooth.Background.BluetoothLEAdvertisementWatcherTriggerDetails.prototype.advertisements;
 /** @type {Windows.Devices.Bluetooth.BluetoothError} */
Windows.Devices.Bluetooth.Background.BluetoothLEAdvertisementWatcherTriggerDetails.prototype.error;
 /** @type {!Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter} */
Windows.Devices.Bluetooth.Background.BluetoothLEAdvertisementWatcherTriggerDetails.prototype.signalStrengthFilter;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.Background.GattCharacteristicNotificationTriggerDetails = function() {};
 /** @type {!Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic} */
Windows.Devices.Bluetooth.Background.GattCharacteristicNotificationTriggerDetails.prototype.characteristic;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Bluetooth.Background.GattCharacteristicNotificationTriggerDetails.prototype.value;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.Background.RfcommConnectionTriggerDetails = function() {};
 /** @type {boolean} */
Windows.Devices.Bluetooth.Background.RfcommConnectionTriggerDetails.prototype.incoming;
 /** @type {!Windows.Devices.Bluetooth.BluetoothDevice} */
Windows.Devices.Bluetooth.Background.RfcommConnectionTriggerDetails.prototype.remoteDevice;
 /** @type {!Windows.Networking.Sockets.StreamSocket} */
Windows.Devices.Bluetooth.Background.RfcommConnectionTriggerDetails.prototype.socket;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.Background.RfcommInboundConnectionInformation = function() {};
 /** @type {!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId} */
Windows.Devices.Bluetooth.Background.RfcommInboundConnectionInformation.prototype.localServiceId;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Bluetooth.Background.RfcommInboundConnectionInformation.prototype.sdpRecord;
 /** @type {Windows.Devices.Bluetooth.BluetoothServiceCapabilities} */
Windows.Devices.Bluetooth.Background.RfcommInboundConnectionInformation.prototype.serviceCapabilities;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.Background.RfcommOutboundConnectionInformation = function() {};
 /** @type {!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId} */
Windows.Devices.Bluetooth.Background.RfcommOutboundConnectionInformation.prototype.remoteServiceId;

/** @const */
Windows.Devices.Bluetooth.BluetoothAddressType = {};
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothAddressType.public;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothAddressType.random;

/** @const */
Windows.Devices.Bluetooth.BluetoothCacheMode = {};
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothCacheMode.cached;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothCacheMode.uncached;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.BluetoothClassOfDevice = function() {};
 /** @type {Windows.Devices.Bluetooth.BluetoothMajorClass} */
Windows.Devices.Bluetooth.BluetoothClassOfDevice.prototype.majorClass;
 /** @type {Windows.Devices.Bluetooth.BluetoothMinorClass} */
Windows.Devices.Bluetooth.BluetoothClassOfDevice.prototype.minorClass;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothClassOfDevice.prototype.rawValue;
 /** @type {Windows.Devices.Bluetooth.BluetoothServiceCapabilities} */
Windows.Devices.Bluetooth.BluetoothClassOfDevice.prototype.serviceCapabilities;

/**
 * Creates a BluetoothClassOfDevice object by supplying values for BluetoothMajorClass , BluetoothMinorClass and BluetoothClassOfDevice.
 * @param {Windows.Devices.Bluetooth.BluetoothMajorClass} majorClass One of the enumeration values that specifies the device's main function.
 * @param {Windows.Devices.Bluetooth.BluetoothMinorClass} minorClass One of the enumeration values that specifies the minor class value to be used.
 * @param {Windows.Devices.Bluetooth.BluetoothServiceCapabilities} serviceCapabilities One of the enumeration values that specifies the service the device supports.
 * @return {!Windows.Devices.Bluetooth.BluetoothClassOfDevice} A BluetoothClassOfDevice object.
 */
Windows.Devices.Bluetooth.BluetoothClassOfDevice.fromParts = function(majorClass, minorClass, serviceCapabilities) {};

/**
 * Creates a BluetoothClassOfDevice object from a raw integer value representing the Major Class, Minor Class and Service Capabilities of the device.
 * @param {number} rawValue The raw integer value from which to create the BluetoothClassOfDevice object.
 * @return {!Windows.Devices.Bluetooth.BluetoothClassOfDevice} A BluetoothClassOfDevice object.
 */
Windows.Devices.Bluetooth.BluetoothClassOfDevice.fromRawValue = function(rawValue) {};

/** @const */
Windows.Devices.Bluetooth.BluetoothConnectionStatus = {};
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothConnectionStatus.disconnected;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothConnectionStatus.connected;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.BluetoothDevice = function() {};
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.bluetoothAddress;
 /** @type {!Windows.Devices.Bluetooth.BluetoothClassOfDevice} */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.classOfDevice;
 /** @type {Windows.Devices.Bluetooth.BluetoothConnectionStatus} */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.connectionStatus;
 /** @type {string} */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.deviceId;
 /** @type {!Windows.Devices.Enumeration.DeviceInformation} */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.deviceInformation;
 /** @type {!Windows.Networking.HostName} */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.hostName;
 /** @type {string} */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.name;
 /** @type {function(?): void} */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.onconnectionstatuschanged;
 /** @type {function(?): void} */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.onnamechanged;
 /** @type {function(?): void} */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.onsdprecordschanged;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService>} */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.rfcommServices;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Storage.Streams.IBuffer>} */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.sdpRecords;

/**
 * Returns a BluetoothDevice object for the given BluetoothAddress .
 * @param {number} address The address of the Bluetooth device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Bluetooth.BluetoothDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Bluetooth.BluetoothDevice>>} After the asynchronous operation completes, returns the BluetoothDevice object with the given BluetoothAddress or null if the address does not resolve to a valid device.
 */
Windows.Devices.Bluetooth.BluetoothDevice.fromBluetoothAddressAsync = function(address) {};

/**
 * Returns a BluetoothDevice object identified by the given HostName .
 * @param {!Windows.Networking.HostName} hostName The HostName that identifies the BluetoothDevice instance.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Bluetooth.BluetoothDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Bluetooth.BluetoothDevice>>} After the asynchronous operation completes, returns the BluetoothDevice object identified by the given HostName .
 */
Windows.Devices.Bluetooth.BluetoothDevice.fromHostNameAsync = function(hostName) {};

/**
 * Returns a BluetoothDevice object identified by the given DeviceId .
 * @param {string} deviceId The DeviceId value that identifies the BluetoothDevice instance.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Bluetooth.BluetoothDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Bluetooth.BluetoothDevice>>} After the asynchronous operation completes, returns the BluetoothDevice object identified by the given DeviceId .
 */
Windows.Devices.Bluetooth.BluetoothDevice.fromIdAsync = function(deviceId) {};

/**
 * Gets an Advanced Query Syntax (AQS) string for identifying instances of this device. This string is passed to the FindAllAsync or CreateWatcher method.
 * @return {string} The device selector for this device.
 */
Windows.Devices.Bluetooth.BluetoothDevice.getDeviceSelector = function() {};

/**
 * Creates an Advanced Query Syntax (AQS) filter string from a 64-bit address that represents a Bluetooth device. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
 * @param {number} bluetoothAddress A 64-bit Bluetooth device address used for constructing the AQS string.
 * @return {string} An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
Windows.Devices.Bluetooth.BluetoothDevice.getDeviceSelectorFromBluetoothAddress = function(bluetoothAddress) {};

/**
 * Creates an Advanced Query Syntax (AQS) filter string from a BluetoothClassOfDevice object. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
 * @param {!Windows.Devices.Bluetooth.BluetoothClassOfDevice} classOfDevice The class of device used for constructing the AQS string.
 * @return {string} An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
Windows.Devices.Bluetooth.BluetoothDevice.getDeviceSelectorFromClassOfDevice = function(classOfDevice) {};

/**
 * Creates an Advanced Query Syntax (AQS) filter string that contains a query for Bluetooth devices with the indicated BluetoothConnectionStatus . The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects with the indicated Bluetooth connection status.
 * @param {Windows.Devices.Bluetooth.BluetoothConnectionStatus} connectionStatus The connection status used for constructing the AQS string.
 * @return {string} An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
Windows.Devices.Bluetooth.BluetoothDevice.getDeviceSelectorFromConnectionStatus = function(connectionStatus) {};

/**
 * Creates an Advanced Query Syntax (AQS) filter string that contains a query for the Bluetooth device name. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects containing the specified Bluetooth device name.
 * @param {string} deviceName The Bluetooth device name used for constructing the AQS string.
 * @return {string} An AQS string that is passed as a parameter to the CreateWatcher method.
 */
Windows.Devices.Bluetooth.BluetoothDevice.getDeviceSelectorFromDeviceName = function(deviceName) {};

/**
 * Creates an Advanced Query Syntax (AQS) filter string that contains a query for Bluetooth devices that are either paired or unpaired. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
 * @param {boolean} pairingState The current pairing state for Bluetooth devices used for constructing the AQS string. Bluetooth devices can be either paired (true) or unpaired (false). The AQS Filter string will request scanning to be performed when the pairingState is false.
 * @return {string} An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
Windows.Devices.Bluetooth.BluetoothDevice.getDeviceSelectorFromPairingState = function(pairingState) {};

/**
 * Closes the Bluetooth device.
 * @return {void}
 */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.close = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Bluetooth.BluetoothDevice.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Devices.Bluetooth.BluetoothError = {};
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothError.success;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothError.radioNotAvailable;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothError.resourceInUse;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothError.deviceNotConnected;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothError.otherError;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothError.disabledByPolicy;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothError.notSupported;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothError.disabledByUser;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.BluetoothLEAppearance = function() {};
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearance.prototype.category;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearance.prototype.rawValue;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearance.prototype.subCategory;

/**
 * Creates a BluetoothLEAppearance object by supplying values for Category (see BluetoothLEAppearanceCategories ) and Subcategory (see BluetoothLEAppearanceSubcategories ) of the Bluetooth LE device.
 * @param {number} appearanceCategory The Bluetooth LE appearance category. See BluetoothLEAppearanceSubcategories .
 * @param {number} appearanceSubCategory The Bluetooth LE appearance subcategory. See BluetoothLEAppearanceSubcategories .
 * @return {!Windows.Devices.Bluetooth.BluetoothLEAppearance} The Bluetooth LE appearance object that was created from the appearance category and subcategory.
 */
Windows.Devices.Bluetooth.BluetoothLEAppearance.fromParts = function(appearanceCategory, appearanceSubCategory) {};

/**
 * Creates a BluetoothLEAppearance object by supplying for raw integer values representing the Category and Subcategory of the Bluetooth LE device.
 * @param {number} rawValue The raw integer value representing the appearance category and subcategory.
 * @return {!Windows.Devices.Bluetooth.BluetoothLEAppearance} The Bluetooth LE appearance object that was created from the appearance category and subcategory.
 */
Windows.Devices.Bluetooth.BluetoothLEAppearance.fromRawValue = function(rawValue) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories = function() {};
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.barcodeScanner;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.bloodPressure;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.clock;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.computer;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.cycling;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.display;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.eyeGlasses;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.glucoseMeter;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.heartRate;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.humanInterfaceDevice;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.keyring;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.mediaPlayer;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.outdoorSportActivity;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.phone;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.pulseOximeter;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.remoteControl;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.runningWalking;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.tag;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.thermometer;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.uncategorized;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.watch;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories.weightScale;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories = function() {};
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.barcodeScanner;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.bloodPressureArm;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.bloodPressureWrist;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.cardReader;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.cyclingCadenceSensor;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.cyclingComputer;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.cyclingPowerSensor;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.cyclingSpeedCadenceSensor;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.cyclingSpeedSensor;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.digitalPen;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.digitizerTablet;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.gamepad;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.generic;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.heartRateBelt;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.joystick;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.keyboard;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.locationDisplay;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.locationNavigationDisplay;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.locationNavigationPod;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.locationPod;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.mouse;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.oximeterFingertip;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.oximeterWristWorn;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.runningWalkingInShoe;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.runningWalkingOnHip;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.runningWalkingOnShoe;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.sportsWatch;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories.thermometerEar;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.BluetoothLEDevice = function() {};
 /** @type {!Windows.Devices.Bluetooth.BluetoothLEAppearance} */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.appearance;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.bluetoothAddress;
 /** @type {Windows.Devices.Bluetooth.BluetoothAddressType} */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.bluetoothAddressType;
 /** @type {Windows.Devices.Bluetooth.BluetoothConnectionStatus} */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.connectionStatus;
 /** @type {string} */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.deviceId;
 /** @type {!Windows.Devices.Enumeration.DeviceInformation} */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.deviceInformation;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService>} */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.gattServices;
 /** @type {string} */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.name;
 /** @type {function(?): void} */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.onconnectionstatuschanged;
 /** @type {function(?): void} */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.ongattserviceschanged;
 /** @type {function(?): void} */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.onnamechanged;

/**
 * Returns a BluetoothLEDevice object for the given BluetoothAddress value and BluetoothAddressType value.
 * @param {number} bluetoothAddress The 64-bit address of the Bluetooth LE device.
 * @param {Windows.Devices.Bluetooth.BluetoothAddressType} bluetoothAddressType The address type of the Bluetooth LE device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Bluetooth.BluetoothLEDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Bluetooth.BluetoothLEDevice>>} Returns an asynchronous operation that completes with the BluetoothLEDevice object.
 */
Windows.Devices.Bluetooth.BluetoothLEDevice.fromBluetoothAddressAsync = function(bluetoothAddress, bluetoothAddressType) {};

/**
 * Returns a BluetoothLEDevice object for the given Id.
 * @param {string} deviceId The Id of the Bluetooth LE device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Bluetooth.BluetoothLEDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Bluetooth.BluetoothLEDevice>>} After the asynchronous operation completes, returns the BluetoothLEDevice object with the given Id.
 */
Windows.Devices.Bluetooth.BluetoothLEDevice.fromIdAsync = function(deviceId) {};

/**
 * Gets an Advanced Query Syntax (AQS) string for identifying all Bluetooth Low Energy (LE) devices. This string is passed to the FindAllAsync or CreateWatcher method in order to get a list of Bluetooth LE devices.
 * @return {string} The device selector for this device.
 */
Windows.Devices.Bluetooth.BluetoothLEDevice.getDeviceSelector = function() {};

/**
 * Creates an Advanced Query Syntax (AQS) filter string from a BluetoothLEAppearance object. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects with the specified appearance.
 * @param {!Windows.Devices.Bluetooth.BluetoothLEAppearance} appearance The Bluetooth LE appearance used for constructing the AQS string.
 * @return {string} An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
Windows.Devices.Bluetooth.BluetoothLEDevice.getDeviceSelectorFromAppearance = function(appearance) {};

/**
 * Creates an Advanced Query Syntax (AQS) filter string from a 64-bit address that represents a Bluetooth LE device. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
 * Creates an Advanced Query Syntax (AQS) filter string from a 64-bit address and address type that represents a Bluetooth LE device. The AQS string is passed into the CreateWatcher method.
 * @param {number} bluetoothAddress A 64-bit Bluetooth LE device address used for constructing the AQS string.
 * @param {Windows.Devices.Bluetooth.BluetoothAddressType=} bluetoothAddressType The Bluetooth LE device address type.
 * @return {string} An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
Windows.Devices.Bluetooth.BluetoothLEDevice.getDeviceSelectorFromBluetoothAddress = function(bluetoothAddress, bluetoothAddressType) {};

/**
 * Creates an Advanced Query Syntax (AQS) filter string that contains a query for Bluetooth LE devices with the indicated BluetoothConnectionStatus . The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects with the indicated Bluetooth connection status.
 * @param {Windows.Devices.Bluetooth.BluetoothConnectionStatus} connectionStatus The connection status used for constructing the AQS string.
 * @return {string} An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
Windows.Devices.Bluetooth.BluetoothLEDevice.getDeviceSelectorFromConnectionStatus = function(connectionStatus) {};

/**
 * Creates an Advanced Query Syntax (AQS) filter string that contains a query for the Bluetooth LE device name. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects containing the specified Bluetooth LE device name.
 * @param {string} deviceName The Bluetooth LE device name used for constructing the AQS string.
 * @return {string} An AQS string that is passed as a parameter to the CreateWatcher method.
 */
Windows.Devices.Bluetooth.BluetoothLEDevice.getDeviceSelectorFromDeviceName = function(deviceName) {};

/**
 * Creates an Advanced Query Syntax (AQS) filter string that contains a query for Bluetooth LE devices that are either paired or unpaired. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
 * @param {boolean} pairingState The current pairing state for Bluetooth LE devices used for constructing the AQS string. Bluetooth LE devices can be either paired (true) or unpaired (false). The AQS Filter string will request scanning to be performed when the pairingState is false.
 * @return {string} An AQS string that can be passed as a parameter to the CreateWatcher method.
 */
Windows.Devices.Bluetooth.BluetoothLEDevice.getDeviceSelectorFromPairingState = function(pairingState) {};

/**
 * Closes this Bluetooth LE device.
 * @return {void}
 */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.close = function() {};

/**
 * Returns the GATT service with the given service Id.
 * @param {string} serviceUuid The service Id of the GATT service.
 * @return {!Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService} The GATT service represented by the given service Id.
 */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.getGattService = function(serviceUuid) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Bluetooth.BluetoothLEDevice.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Devices.Bluetooth.BluetoothMajorClass = {};
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMajorClass.miscellaneous;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMajorClass.computer;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMajorClass.phone;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMajorClass.networkAccessPoint;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMajorClass.audioVideo;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMajorClass.peripheral;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMajorClass.imaging;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMajorClass.wearable;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMajorClass.toy;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMajorClass.health;

/** @const */
Windows.Devices.Bluetooth.BluetoothMinorClass = {};
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.uncategorized;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.computerDesktop;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.computerServer;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.computerLaptop;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.computerHandheld;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.computerPalmSize;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.computerWearable;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.computerTablet;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.phoneCellular;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.phoneCordless;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.phoneSmartPhone;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.phoneWired;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.phoneIsdn;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.networkFullyAvailable;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.networkUsed01To17Percent;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.networkUsed17To33Percent;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.networkUsed33To50Percent;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.networkUsed50To67Percent;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.networkUsed67To83Percent;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.networkUsed83To99Percent;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.networkNoServiceAvailable;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoWearableHeadset;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoHandsFree;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoMicrophone;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoLoudspeaker;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoHeadphones;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoPortableAudio;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoCarAudio;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoSetTopBox;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoHifiAudioDevice;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoVcr;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoVideoCamera;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoCamcorder;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoVideoMonitor;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoVideoDisplayAndLoudspeaker;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoVideoConferencing;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.audioVideoGamingOrToy;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.peripheralJoystick;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.peripheralGamepad;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.peripheralRemoteControl;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.peripheralSensing;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.peripheralDigitizerTablet;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.peripheralCardReader;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.peripheralDigitalPen;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.peripheralHandheldScanner;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.peripheralHandheldGesture;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.wearableWristwatch;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.wearablePager;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.wearableJacket;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.wearableHelmet;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.wearableGlasses;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.toyRobot;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.toyVehicle;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.toyDoll;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.toyController;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.toyGame;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthBloodPressureMonitor;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthThermometer;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthWeighingScale;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthGlucoseMeter;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthPulseOximeter;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthHeartRateMonitor;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthHealthDataDisplay;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthStepCounter;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthBodyCompositionAnalyzer;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthPeakFlowMonitor;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthMedicationMonitor;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthKneeProsthesis;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthAnkleProsthesis;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthGenericHealthManager;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothMinorClass.healthPersonalMobilityDevice;

/** @const */
Windows.Devices.Bluetooth.BluetoothServiceCapabilities = {};
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothServiceCapabilities.none;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothServiceCapabilities.limitedDiscoverableMode;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothServiceCapabilities.positioningService;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothServiceCapabilities.networkingService;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothServiceCapabilities.renderingService;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothServiceCapabilities.capturingService;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothServiceCapabilities.objectTransferService;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothServiceCapabilities.audioService;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothServiceCapabilities.telephoneService;
/** @const {number} */
Windows.Devices.Bluetooth.BluetoothServiceCapabilities.informationService;

/**
 * @constructor
 * @struct
 * Create a new BluetoothSignalStrengthFilter object.
 */
Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter = function() {};
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter.prototype.inRangeThresholdInDBm;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter.prototype.outOfRangeThresholdInDBm;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter.prototype.outOfRangeTimeout;
 /** @type {number} */
Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter.prototype.samplingInterval;
/** @const */
Windows.Devices.Bluetooth.GenericAttributeProfile = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic = function() {};
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.attributeHandle;
 /** @type {Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicProperties} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.characteristicProperties;
 /** @type {function(?): void} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.onvaluechanged;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat>} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.presentationFormats;
 /** @type {Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtectionLevel} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.protectionLevel;
 /** @type {!Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.service;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.userDescription;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.uuid;

/**
 * Converts a Bluetooth SIG defined short Id to a full GATT UUID.
 * @param {number} shortId A 16-bit Bluetooth GATT Service UUID.
 * @return {string} The corresponding 128-bit GATT Characteristic UUID, that uniquely identifies this characteristic.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.convertShortIdToUuid = function(shortId) {};

/**
 * Gets the collection of all descriptors belonging to this GattCharacteristic instance.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor>} The collection of all descriptors belonging to this GattCharacteristic instance.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.getAllDescriptors = function() {};

/**
 * Returns a vector of descriptors, that are identified by the specified UUID, and belong to this GattCharacteristic instance.
 * @param {string} descriptorUuid The UUID for the descriptors to be retrieved.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor>} A vector of descriptors whose UUIDs match descriptorUuid.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.getDescriptors = function(descriptorUuid) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.removeEventListener = function(type, listener) {};

/**
 * Reads the current value of the ClientCharacteristicConfigurationDescriptor.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadClientCharacteristicConfigurationDescriptorResult, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadClientCharacteristicConfigurationDescriptorResult>>} The object that manages the asynchronous operation. Upon completion of the asynchronous method, the IAsyncOperation(GattReadClientCharacteristicConfigurationDescriptorResult) contains the result of the read operation, which contains the status of completed operation.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.readClientCharacteristicConfigurationDescriptorAsync = function() {};

/**
 * Performs a Characteristic Value read either from the value cache maintained by Windows, or directly from the device.
 * Performs a Characteristic Value read from the value cache maintained by Windows.
 * @param {Windows.Devices.Bluetooth.BluetoothCacheMode=} cacheMode Specifies whether to read the value directly from the device or from a value cache maintained by Windows.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadResult, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadResult>>} The object required to manage the asynchronous operation, which, upon completion, returns a GattReadResult object, which in turn contains the completion status of the asynchronous operation and, if successful, the data read from the device.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.readValueAsync = function(cacheMode) {};

/**
 * Writes the ClientCharacteristicConfigurationDescriptor to the Bluetooth LE device, and if the value to be written represents an indication or a notification and a ValueChanged event handler is registered, enables receiving ValueChanged events from the device.
 * @param {Windows.Devices.Bluetooth.GenericAttributeProfile.GattClientCharacteristicConfigurationDescriptorValue} clientCharacteristicConfigurationDescriptorValue Specifies a new value for the ClientCharacteristicConfigurationDescriptor of this Characteristic object.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus, !Windows.Foundation.IAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus>>} The object that manages the asynchronous operation, which, upon completion, returns the status with which the operation completed.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.writeClientCharacteristicConfigurationDescriptorAsync = function(clientCharacteristicConfigurationDescriptorValue) {};

/**
 * Performs a Characteristic Value write to a Bluetooth LE device.
 * Performs a Characteristic Value write to a Bluetooth LE device.
 * @param {!Windows.Storage.Streams.IBuffer} value A Windows.Storage.Streams.IBuffer object which contains the data to be written to the Bluetooth LE device.
 * @param {Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteOption=} writeOption Specifies what type of GATT write should be performed.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus, !Windows.Foundation.IAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus>>} The object that manages the asynchronous operation, which, upon completion, returns the status with which the operation completed.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic.prototype.writeValueAsync = function(value, writeOption) {};

/** @const */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicProperties = {};
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicProperties.none;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicProperties.broadcast;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicProperties.read;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicProperties.writeWithoutResponse;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicProperties.write;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicProperties.notify;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicProperties.indicate;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicProperties.authenticatedSignedWrites;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicProperties.extendedProperties;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicProperties.reliableWrites;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicProperties.writableAuxiliaries;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids = function() {};
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.alertCategoryId;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.alertCategoryIdBitMask;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.alertLevel;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.alertNotificationControlPoint;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.alertStatus;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.batteryLevel;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.bloodPressureFeature;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.bloodPressureMeasurement;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.bodySensorLocation;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.bootKeyboardInputReport;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.bootKeyboardOutputReport;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.bootMouseInputReport;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.cscFeature;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.cscMeasurement;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.currentTime;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.cyclingPowerControlPoint;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.cyclingPowerFeature;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.cyclingPowerMeasurement;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.cyclingPowerVector;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.dateTime;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.dayDateTime;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.dayOfWeek;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.dstOffset;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.exactTime256;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.firmwareRevisionString;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.gapAppearance;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.gapDeviceName;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.gapPeripheralPreferredConnectionParameters;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.gapPeripheralPrivacyFlag;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.gapReconnectionAddress;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.gattServiceChanged;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.glucoseFeature;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.glucoseMeasurement;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.glucoseMeasurementContext;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.hardwareRevisionString;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.heartRateControlPoint;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.heartRateMeasurement;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.hidControlPoint;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.hidInformation;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.ieee1107320601RegulatoryCertificationDataList;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.intermediateCuffPressure;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.intermediateTemperature;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.lnControlPoint;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.lnFeature;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.localTimeInformation;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.locationAndSpeed;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.manufacturerNameString;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.measurementInterval;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.modelNumberString;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.navigation;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.newAlert;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.pnpId;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.positionQuality;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.protocolMode;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.recordAccessControlPoint;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.referenceTimeInformation;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.report;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.reportMap;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.ringerControlPoint;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.ringerSetting;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.rscFeature;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.rscMeasurement;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.scControlPoint;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.scanIntervalWindow;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.scanRefresh;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.sensorLocation;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.serialNumberString;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.softwareRevisionString;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.supportUnreadAlertCategory;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.supportedNewAlertCategory;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.systemId;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.temperatureMeasurement;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.temperatureType;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.timeAccuracy;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.timeSource;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.timeUpdateControlPoint;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.timeUpdateState;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.timeWithDst;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.timeZone;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.txPowerLevel;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids.unreadAlertStatus;

/** @const */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattClientCharacteristicConfigurationDescriptorValue = {};
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattClientCharacteristicConfigurationDescriptorValue.none;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattClientCharacteristicConfigurationDescriptorValue.notify;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattClientCharacteristicConfigurationDescriptorValue.indicate;

/** @const */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus = {};
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus.success;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus.unreachable;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor = function() {};
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor.prototype.attributeHandle;
 /** @type {Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtectionLevel} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor.prototype.protectionLevel;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor.prototype.uuid;

/**
 * Converts a Bluetooth SIG defined short Id to a full GATT UUID.
 * @param {number} shortId A 16-bit Bluetooth GATT Descriptor UUID.
 * @return {string} The corresponding 128-bit GATT Descriptor UUID, that uniquely identifies this descriptor.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor.convertShortIdToUuid = function(shortId) {};

/**
 * Performs a Descriptor Value read either from the value cache maintained by Windows, or directly from the device.
 * Performs a Descriptor Value read from a value cache maintained by Windows.
 * @param {Windows.Devices.Bluetooth.BluetoothCacheMode=} cacheMode Specifies whether to read the value directly from the device or from a value cache maintained by Windows.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadResult, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadResult>>} The object required to manage the asynchronous operation, which, upon completion, returns a GattReadResult object, which in turn contains the completion status of the asynchronous operation and, if successful, the data read from the device.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor.prototype.readValueAsync = function(cacheMode) {};

/**
 * Performs a Descriptor Value write to a Bluetooth LE device.
 * @param {!Windows.Storage.Streams.IBuffer} value A Windows.Storage.Streams.IBuffer object which contains the data to be written to the Bluetooth LE device.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus, !Windows.Foundation.IAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus>>} The object that manages the asynchronous operation, which, upon completion, returns the status with which the operation completed.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor.prototype.writeValueAsync = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorUuids = function() {};
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorUuids.characteristicAggregateFormat;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorUuids.characteristicExtendedProperties;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorUuids.characteristicPresentationFormat;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorUuids.characteristicUserDescription;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorUuids.clientCharacteristicConfiguration;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorUuids.serverCharacteristicConfiguration;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService = function() {};
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService.prototype.attributeHandle;
 /** @type {!Windows.Devices.Bluetooth.BluetoothLEDevice} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService.prototype.device;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService.prototype.deviceId;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService>} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService.prototype.parentServices;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService.prototype.uuid;

/**
 * Converts a Bluetooth SIG defined short Id to a full GATT UUID.
 * @param {number} shortId A 16-bit Bluetooth GATT Service UUID.
 * @return {string} The corresponding 128-bit GATT Service UUID, that uniquely identifies this service.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService.convertShortIdToUuid = function(shortId) {};

/**
 * Instantiates a new GattDeviceService from the device ID.
 * @param {string} deviceId The GATT device ID.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService>>} The object for managing the asynchronous operation, which, upon completion, returns the newly instantiated GattDeviceService.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService.fromIdAsync = function(deviceId) {};

/**
 * Creates a suitable AQS Filter string for use with the CreateWatcher method, from a 16-bit Bluetooth GATT Service UUID.
 * @param {number} serviceShortId A 16-bit Bluetooth GATT Service UUID.
 * @return {string} A suitable AQS Selector String which can be passed as a parameter to the CreateWatcher method, in order to retrieve a GATT service instance path
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService.getDeviceSelectorFromShortId = function(serviceShortId) {};

/**
 * Creates a suitable AQS Filter string for use with the CreateWatcher method, from a Bluetooth service UUID.
 * @param {string} serviceUuid A 128-bit Bluetooth GATT Service UUID, represented as a standard GUID object.
 * @return {string} A suitable AQS Selector String which can be passed as a parameter to the CreateWatcher method, in order to retrieve a GATT service instance path.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService.getDeviceSelectorFromUuid = function(serviceUuid) {};

/**
 * Releases the resources associated with the GattDeviceService class. This allows other apps to access the resources of the GattDeviceService in question. A GattDeviceService object should not be used after Close is invoked, instead a new GattDeviceService object should be instantiated using the FromIdAsync method.
 * @return {void}
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService.prototype.close = function() {};

/**
 * Gets the collection of all characteristics belonging to this GattDeviceService instance.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic>} The collection of all characteristics belonging to this GattDeviceService instance.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService.prototype.getAllCharacteristics = function() {};

/**
 * Gets the collection of all included services belonging to this GattDeviceService instance.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService>} The collection of all included services belonging to this GattDeviceService instance.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService.prototype.getAllIncludedServices = function() {};

/**
 * Returns a vector of characteristics, that are identified by the specified UUID and belong to this GattDeviceService instance.
 * @param {string} characteristicUuid The UUID for the characteristics to be retrieved.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic>} A vector of GattCharacteristic objects whose UUIDs match characteristicUuid.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService.prototype.getCharacteristics = function(characteristicUuid) {};

/**
 * Returns a vector of included services, that are identified by the specified UUID and belong to this GattDeviceService instance.
 * @param {string} serviceUuid The UUID for the included services to be retrieved.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService>} A vector of included services whose UUIDs match serviceUuid.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService.prototype.getIncludedServices = function(serviceUuid) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat = function() {};
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat.bluetoothSigAssignedNumbers;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat.prototype.description;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat.prototype.exponent;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat.prototype.formatType;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat.prototype.namespace;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat.prototype.unit;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes = function() {};
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.bit2;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.boolean;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.duInt16;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.float;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.float32;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.float64;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.nibble;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.sfloat;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.sint12;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.sint128;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.sint16;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.sint24;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.sint32;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.sint48;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.sint64;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.sint8;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.struct;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.uint12;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.uint128;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.uint16;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.uint24;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.uint32;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.uint48;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.uint64;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.uint8;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.utf16;
 /** @type {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes.utf8;

/** @const */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtectionLevel = {};
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtectionLevel.plain;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtectionLevel.authenticationRequired;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtectionLevel.encryptionRequired;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtectionLevel.encryptionAndAuthenticationRequired;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadClientCharacteristicConfigurationDescriptorResult = function() {};
 /** @type {Windows.Devices.Bluetooth.GenericAttributeProfile.GattClientCharacteristicConfigurationDescriptorValue} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadClientCharacteristicConfigurationDescriptorResult.prototype.clientCharacteristicConfigurationDescriptor;
 /** @type {Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadClientCharacteristicConfigurationDescriptorResult.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadResult = function() {};
 /** @type {Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadResult.prototype.status;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadResult.prototype.value;

/**
 * @constructor
 * @struct
 * Creates a new GattReliableWriteTransaction object.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattReliableWriteTransaction = function() {};

/**
 * Performs all the queued writes, in sequence, writing the data to the device. Once a transaction object has been committed, no further operations are possible on the GattReliableWriteTransaction object.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus, !Windows.Foundation.IAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus>>} The object used to manage the asynchronous operation, which, upon completion, will return the status of the asynchronous operation.
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattReliableWriteTransaction.prototype.commitAsync = function() {};

/**
 * Adds a new write operation to the transaction object.
 * @param {!Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic} characteristic The GattCharacteristic object on which to perform the write operation.
 * @param {!Windows.Storage.Streams.IBuffer} value The Characteristic Value to be written to characteristic.
 * @return {void}
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattReliableWriteTransaction.prototype.writeValue = function(characteristic, value) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids = function() {};
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.alertNotification;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.battery;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.bloodPressure;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.currentTime;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.cyclingPower;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.cyclingSpeedAndCadence;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.deviceInformation;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.genericAccess;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.genericAttribute;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.glucose;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.healthThermometer;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.heartRate;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.humanInterfaceDevice;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.immediateAlert;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.linkLoss;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.locationAndNavigation;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.nextDstChange;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.phoneAlertStatus;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.referenceTimeUpdate;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.runningSpeedAndCadence;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.scanParameters;
 /** @type {string} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids.txPower;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattValueChangedEventArgs = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattValueChangedEventArgs.prototype.characteristicValue;
 /** @type {!Date} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattValueChangedEventArgs.prototype.timestamp;

/** @const */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteOption = {};
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteOption.writeWithResponse;
/** @const {number} */
Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteOption.writeWithoutResponse;
/** @const */
Windows.Devices.Bluetooth.Rfcomm = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService = function() {};
 /** @type {!Windows.Networking.HostName} */
Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService.prototype.connectionHostName;
 /** @type {string} */
Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService.prototype.connectionServiceName;
 /** @type {!Windows.Devices.Bluetooth.BluetoothDevice} */
Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService.prototype.device;
 /** @type {Windows.Networking.Sockets.SocketProtectionLevel} */
Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService.prototype.maxProtectionLevel;
 /** @type {Windows.Networking.Sockets.SocketProtectionLevel} */
Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService.prototype.protectionLevel;
 /** @type {!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId} */
Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService.prototype.serviceId;

/**
 * Gets an RfcommDeviceService object from a DeviceInformation Id for an RFCOMM service instance.
 * @param {string} deviceId The DeviceInformation Id that identifies the RFCOMM service instance. This id can be retrieved from Windows.Devices.Enumeration .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService>>} The RfcommDeviceService object that represents the RFCOMM service instance.
 */
Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService.fromIdAsync = function(deviceId) {};

/**
 * Gets an Advanced Query Syntax (AQS) string for identifying instances of an RFCOMM service. This string is passed to the CreateWatcher method.
 * @param {!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId} serviceId The service id for which to query.
 * @return {string} An AQS string for identifying RFCOMM service instances.
 */
Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService.getDeviceSelector = function(serviceId) {};

/**
 * Closes the RFCOMM device.
 * @return {void}
 */
Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService.prototype.close = function() {};

/**
 * Gets the cached SDP attributes of the RFCOMM service instance.
 * Gets the SDP attributes of the RFCOMM service instance.
 * @param {Windows.Devices.Bluetooth.BluetoothCacheMode=} cacheMode Indicates whether SDP attributes should be retrieved from the cache or from the device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IMapView<?, ?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IMapView<?, ?>>>} The SDP attributes of the RFCOMM service instance.
 */
Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService.prototype.getSdpRawAttributesAsync = function(cacheMode) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId = function() {};
 /** @type {!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId} */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId.genericFileTransfer;
 /** @type {!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId} */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId.obexFileTransfer;
 /** @type {!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId} */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId.obexObjectPush;
 /** @type {!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId} */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId.phoneBookAccessPce;
 /** @type {!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId} */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId.phoneBookAccessPse;
 /** @type {!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId} */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId.serialPort;
 /** @type {string} */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId.prototype.uuid;

/**
 * Creates a RfcommServiceId object from a 32-bit service id.
 * @param {number} shortId The 32-bit service id.
 * @return {!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId} The RfcommServiceId object.
 */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId.fromShortId = function(shortId) {};

/**
 * Creates a RfcommServiceId object from a 128-bit service id.
 * @param {string} uuid The 128-bit service id.
 * @return {!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId} The RfcommServiceId object.
 */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId.fromUuid = function(uuid) {};

/**
 * Converts the RfcommServiceId to a 32-bit service id if possible.
 * @return {number} Returns the 32-bit service id if the RfcommServiceId represents a standardized service.
 */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId.prototype.asShortId = function() {};

/**
 * Converts the RfcommServiceId to a string.
 * @return {string} Returns the string representation of the 128-bit service id.
 */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId.prototype.asString = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceProvider = function() {};
 /** @type {!Windows.Foundation.Collections.IMap<number, !Windows.Storage.Streams.IBuffer>} */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceProvider.prototype.sdpRawAttributes;
 /** @type {!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId} */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceProvider.prototype.serviceId;

/**
 * Gets a RfcommServiceProvider object from a DeviceInformation Id for a RFCOMM service instance.
 * @param {!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId} serviceId The RfcommServiceId to be hosted locally.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceProvider, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Bluetooth.Rfcomm.RfcommServiceProvider>>} The RfcommServiceProvider object that represents the local RFCOMM service instance.
 */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceProvider.createAsync = function(serviceId) {};

/**
 * Begins advertising the SDP attributes.
 * Begins advertising the SDP attributes.
 * @param {!Windows.Networking.Sockets.StreamSocketListener} listener The StreamSocketListener that is listening for incoming connections.
 * @param {boolean=} radioDiscoverable Indicates whether the radio is discoverable (true) or not (false).
 * @return {void}
 */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceProvider.prototype.startAdvertising = function(listener, radioDiscoverable) {};

/**
 * Stops advertising the SDP attributes.
 * @return {void}
 */
Windows.Devices.Bluetooth.Rfcomm.RfcommServiceProvider.prototype.stopAdvertising = function() {};
/** @const */
Windows.Devices.Custom = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Custom.CustomDevice = function() {};
 /** @type {!Windows.Storage.Streams.IInputStream} */
Windows.Devices.Custom.CustomDevice.prototype.inputStream;
 /** @type {!Windows.Storage.Streams.IOutputStream} */
Windows.Devices.Custom.CustomDevice.prototype.outputStream;

/**
 * Creates a CustomDevice object asynchronously for the specified DeviceInformation.Id .
 * @param {string} deviceId The DeviceInformation.Id of the device .
 * @param {Windows.Devices.Custom.DeviceAccessMode} desiredAccess The desired access.
 * @param {Windows.Devices.Custom.DeviceSharingMode} sharingMode The sharing mode.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Custom.CustomDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Custom.CustomDevice>>} Returns a custom device.
 */
Windows.Devices.Custom.CustomDevice.fromIdAsync = function(deviceId, desiredAccess, sharingMode) {};

/**
 * Gets a device selector.
 * @param {string} classGuid The Device Interface Class GUID of the device interface to create a device selector for.
 * @return {string} The device selector.
 */
Windows.Devices.Custom.CustomDevice.getDeviceSelector = function(classGuid) {};

/**
 * Sends an IO control code.
 * @param {!Windows.Devices.Custom.IIOControlCode} ioControlCode The IO control code.
 * @param {!Windows.Storage.Streams.IBuffer} inputBuffer The input buffer.
 * @param {!Windows.Storage.Streams.IBuffer} outputBuffer The output buffer.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} The result of the async operation.
 */
Windows.Devices.Custom.CustomDevice.prototype.sendIOControlAsync = function(ioControlCode, inputBuffer, outputBuffer) {};

/**
 * Sends an IO control code. A return value indicates whether the operation succeeded.
 * @param {!Windows.Devices.Custom.IIOControlCode} ioControlCode The IO control code.
 * @param {!Windows.Storage.Streams.IBuffer} inputBuffer The input buffer.
 * @param {!Windows.Storage.Streams.IBuffer} outputBuffer The output buffer.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} true if the operation is successful; otherwise, false.
 */
Windows.Devices.Custom.CustomDevice.prototype.trySendIOControlAsync = function(ioControlCode, inputBuffer, outputBuffer) {};

/** @const */
Windows.Devices.Custom.DeviceAccessMode = {};
/** @const {number} */
Windows.Devices.Custom.DeviceAccessMode.read;
/** @const {number} */
Windows.Devices.Custom.DeviceAccessMode.write;
/** @const {number} */
Windows.Devices.Custom.DeviceAccessMode.readWrite;

/** @const */
Windows.Devices.Custom.DeviceSharingMode = {};
/** @const {number} */
Windows.Devices.Custom.DeviceSharingMode.shared;
/** @const {number} */
Windows.Devices.Custom.DeviceSharingMode.exclusive;

/** @const */
Windows.Devices.Custom.IOControlAccessMode = {};
/** @const {number} */
Windows.Devices.Custom.IOControlAccessMode.any;
/** @const {number} */
Windows.Devices.Custom.IOControlAccessMode.read;
/** @const {number} */
Windows.Devices.Custom.IOControlAccessMode.write;
/** @const {number} */
Windows.Devices.Custom.IOControlAccessMode.readWrite;

/** @const */
Windows.Devices.Custom.IOControlBufferingMethod = {};
/** @const {number} */
Windows.Devices.Custom.IOControlBufferingMethod.buffered;
/** @const {number} */
Windows.Devices.Custom.IOControlBufferingMethod.directInput;
/** @const {number} */
Windows.Devices.Custom.IOControlBufferingMethod.directOutput;
/** @const {number} */
Windows.Devices.Custom.IOControlBufferingMethod.neither;

/**
 * @constructor
 * @struct
 * The control code.
 * @param {number} deviceType The device type.
 * @param {number} func
 * @param {Windows.Devices.Custom.IOControlAccessMode} accessMode The access mode.
 * @param {Windows.Devices.Custom.IOControlBufferingMethod} bufferingMethod The buffering method.
 */
Windows.Devices.Custom.IOControlCode = function(deviceType, func, accessMode, bufferingMethod) {};
 /** @type {Windows.Devices.Custom.IOControlAccessMode} */
Windows.Devices.Custom.IOControlCode.prototype.accessMode;
 /** @type {Windows.Devices.Custom.IOControlBufferingMethod} */
Windows.Devices.Custom.IOControlCode.prototype.bufferingMethod;
 /** @type {number} */
Windows.Devices.Custom.IOControlCode.prototype.controlCode;
 /** @type {number} */
Windows.Devices.Custom.IOControlCode.prototype.deviceType;
 /** @type {number} */
Windows.Devices.Custom.IOControlCode.prototype.function;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Custom.KnownDeviceTypes = function() {};
 /** @type {number} */
Windows.Devices.Custom.KnownDeviceTypes.unknown;
/**
 * @record
 * @struct
 */
Windows.Devices.Custom.IIOControlCode = function() {};
 /** @type {Windows.Devices.Custom.IOControlAccessMode} */
Windows.Devices.Custom.IIOControlCode.prototype.accessMode;
 /** @type {Windows.Devices.Custom.IOControlBufferingMethod} */
Windows.Devices.Custom.IIOControlCode.prototype.bufferingMethod;
 /** @type {number} */
Windows.Devices.Custom.IIOControlCode.prototype.controlCode;
 /** @type {number} */
Windows.Devices.Custom.IIOControlCode.prototype.deviceType;
 /** @type {number} */
Windows.Devices.Custom.IIOControlCode.prototype.function;
/** @const */
Windows.Devices.Enumeration = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceAccessChangedEventArgs = function() {};
 /** @type {Windows.Devices.Enumeration.DeviceAccessStatus} */
Windows.Devices.Enumeration.DeviceAccessChangedEventArgs.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceAccessInformation = function() {};
 /** @type {Windows.Devices.Enumeration.DeviceAccessStatus} */
Windows.Devices.Enumeration.DeviceAccessInformation.prototype.currentStatus;
 /** @type {function(?): void} */
Windows.Devices.Enumeration.DeviceAccessInformation.prototype.onaccesschanged;

/**
 * Initializes a DeviceAccessInformation object based on a given DeviceClass .
 * @param {Windows.Devices.Enumeration.DeviceClass} deviceClass Device class to get DeviceAccessInformation about.
 * @return {!Windows.Devices.Enumeration.DeviceAccessInformation} The DeviceAccessInformation object for the given DeviceClass .
 */
Windows.Devices.Enumeration.DeviceAccessInformation.createFromDeviceClass = function(deviceClass) {};

/**
 * Initializes a DeviceAccessInformation object based on a device class id.
 * @param {string} deviceClassId Id of the device class to get DeviceAccessInformation about.
 * @return {!Windows.Devices.Enumeration.DeviceAccessInformation} The DeviceAccessInformation object for the given device class id.
 */
Windows.Devices.Enumeration.DeviceAccessInformation.createFromDeviceClassId = function(deviceClassId) {};

/**
 * Initializes a DeviceAccessInformation object based on a device id.
 * @param {string} deviceId Id of the device to get DeviceAccessInformation about.
 * @return {!Windows.Devices.Enumeration.DeviceAccessInformation} The DeviceAccessInformation object for the given device id.
 */
Windows.Devices.Enumeration.DeviceAccessInformation.createFromId = function(deviceId) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Enumeration.DeviceAccessInformation.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Enumeration.DeviceAccessInformation.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Devices.Enumeration.DeviceAccessStatus = {};
/** @const {number} */
Windows.Devices.Enumeration.DeviceAccessStatus.unspecified;
/** @const {number} */
Windows.Devices.Enumeration.DeviceAccessStatus.allowed;
/** @const {number} */
Windows.Devices.Enumeration.DeviceAccessStatus.deniedByUser;
/** @const {number} */
Windows.Devices.Enumeration.DeviceAccessStatus.deniedBySystem;

/** @const */
Windows.Devices.Enumeration.DeviceClass = {};
/** @const {number} */
Windows.Devices.Enumeration.DeviceClass.all;
/** @const {number} */
Windows.Devices.Enumeration.DeviceClass.audioCapture;
/** @const {number} */
Windows.Devices.Enumeration.DeviceClass.audioRender;
/** @const {number} */
Windows.Devices.Enumeration.DeviceClass.portableStorageDevice;
/** @const {number} */
Windows.Devices.Enumeration.DeviceClass.videoCapture;
/** @const {number} */
Windows.Devices.Enumeration.DeviceClass.imageScanner;
/** @const {number} */
Windows.Devices.Enumeration.DeviceClass.location;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceConnectionChangeTriggerDetails = function() {};
 /** @type {string} */
Windows.Devices.Enumeration.DeviceConnectionChangeTriggerDetails.prototype.deviceId;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceDisconnectButtonClickedEventArgs = function() {};
 /** @type {!Windows.Devices.Enumeration.DeviceInformation} */
Windows.Devices.Enumeration.DeviceDisconnectButtonClickedEventArgs.prototype.device;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceInformation = function() {};
 /** @type {!Windows.Devices.Enumeration.EnclosureLocation} */
Windows.Devices.Enumeration.DeviceInformation.prototype.enclosureLocation;
 /** @type {string} */
Windows.Devices.Enumeration.DeviceInformation.prototype.id;
 /** @type {boolean} */
Windows.Devices.Enumeration.DeviceInformation.prototype.isDefault;
 /** @type {boolean} */
Windows.Devices.Enumeration.DeviceInformation.prototype.isEnabled;
 /** @type {Windows.Devices.Enumeration.DeviceInformationKind} */
Windows.Devices.Enumeration.DeviceInformation.prototype.kind;
 /** @type {string} */
Windows.Devices.Enumeration.DeviceInformation.prototype.name;
 /** @type {!Windows.Devices.Enumeration.DeviceInformationPairing} */
Windows.Devices.Enumeration.DeviceInformation.prototype.pairing;
 /** @type {!Windows.Foundation.Collections.IMapView<string, ?>} */
Windows.Devices.Enumeration.DeviceInformation.prototype.properties;

/**
 * Creates a DeviceInformation object from a DeviceInformation ID and a list of additional properties.
 * Creates a DeviceInformation object from a DeviceInformation ID.
 * Creates a DeviceInformation object from a DeviceInformation ID, a list of additional properties, and a DeviceInformationKind parameter.
 * @param {string} deviceId A string containing the DeviceInformation ID. / The device ID.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
 * @param {Windows.Devices.Enumeration.DeviceInformationKind=} kind The type of DeviceInformation object you want to create.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Enumeration.DeviceInformation, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Enumeration.DeviceInformation>>} An object for starting and managing the asynchronous creation of the DeviceInformation object.
 */
Windows.Devices.Enumeration.DeviceInformation.createFromIdAsync = function(deviceId, additionalProperties, kind) {};

/**
 * Creates a DeviceWatcher for all devices.
 * Creates a DeviceWatcher for devices matching the specified Advanced Query Syntax (AQS) string and the specified collection of properties.
 * Creates a DeviceWatcher for devices matching the specified Advanced Query Syntax (AQS) string.
 * Creates a DeviceWatcher for devices matching the specified DeviceClass .
 * Creates a DeviceWatcher for devices matching the specified Advanced Query Syntax (AQS) string, the specified collection of properties, and the kind of devices.
 * @param {string|Windows.Devices.Enumeration.DeviceClass=} aqsFilter_or_deviceClass An AQS string that filters the DeviceInformation objects to enumerate. Typically this string is retrieved from the GetDeviceSelector method of a class that interacts with devices. For example, GetDeviceSelector retrieves the string for the StorageDevice class. / The class of device to enumerate using the DeviceWatcher .
 * @param {!Windows.Foundation.Collections.IIterable<string>=} additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
 * @param {Windows.Devices.Enumeration.DeviceInformationKind=} kind The specific types of devices the DeviceWatcher is interested in.
 * @return {!Windows.Devices.Enumeration.DeviceWatcher} The created DeviceWatcher .
 */
Windows.Devices.Enumeration.DeviceInformation.createWatcher = function(aqsFilter_or_deviceClass, additionalProperties, kind) {};

/**
 * Enumerates DeviceInformation objects matching the specified Advanced Query Syntax (AQS) string and including the specified collection of properties.
 * Enumerates DeviceInformation objects of the specified class.
 * Enumerates DeviceInformation objects matching the specified Advanced Query Syntax (AQS) string.
 * Enumerates all DeviceInformation objects.
 * Enumerates DeviceInformation objects matching the specified Advanced Query Syntax (AQS) string, the device kind, and including the specified collection of properties.
 * @param {string|Windows.Devices.Enumeration.DeviceClass=} aqsFilter_or_deviceClass An AQS string that filters the DeviceInformation objects to enumerate. Typically this string is retrieved from the GetDeviceSelector method of a class that interacts with devices. For example, GetDeviceSelector retrieves the string for the StorageDevice class. / The class of devices to enumerate.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
 * @param {Windows.Devices.Enumeration.DeviceInformationKind=} kind The specific type of device to find.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Enumeration.DeviceInformationCollection, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Enumeration.DeviceInformationCollection>>} The object for managing the asynchronous operation.
 */
Windows.Devices.Enumeration.DeviceInformation.findAllAsync = function(aqsFilter_or_deviceClass, additionalProperties, kind) {};

/**
 * Creates a filter to use to enumerate through a subset of device types.
 * @param {Windows.Devices.Enumeration.DeviceClass} deviceClass The type of devices that you want to create a filter for.
 * @return {string} The Advanced Query Syntax (AQS) filter used to specifically enumerate through the device type specified by deviceClass.
 */
Windows.Devices.Enumeration.DeviceInformation.getAqsFilterFromDeviceClass = function(deviceClass) {};

/**
 * Gets a glyph for the device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Enumeration.DeviceThumbnail, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Enumeration.DeviceThumbnail>>} The object for managing the asynchronous operation that will return a DeviceThumbnail
 */
Windows.Devices.Enumeration.DeviceInformation.prototype.getGlyphThumbnailAsync = function() {};

/**
 * Returns a thumbnail image for the device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Enumeration.DeviceThumbnail, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Enumeration.DeviceThumbnail>>} The object for managing the asynchronous operation that will return a DeviceThumbnail .
 */
Windows.Devices.Enumeration.DeviceInformation.prototype.getThumbnailAsync = function() {};

/**
 * Updates the properties of an existing DeviceInformation object.
 * @param {!Windows.Devices.Enumeration.DeviceInformationUpdate} updateInfo Indicates the properties to update.
 * @return {void}
 */
Windows.Devices.Enumeration.DeviceInformation.prototype.update = function(updateInfo) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceInformationCollection = function() {};
 /** @type {number} */
Windows.Devices.Enumeration.DeviceInformationCollection.prototype.size;

/**
 * Gets an object that can iterate through the enumerated DeviceInformation objects, starting with the first.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Devices.Enumeration.DeviceInformation>} An object that can iterate through the enumerated devices, starting with the first.
 */
Windows.Devices.Enumeration.DeviceInformationCollection.prototype.first = function() {};

/**
 * Gets the DeviceInformation object at the specified index.
 * @param {number} index The index.
 * @return {!Windows.Devices.Enumeration.DeviceInformation} The DeviceInformation object at the specified index.
 */
Windows.Devices.Enumeration.DeviceInformationCollection.prototype.getAt = function(index) {};

/**
 * Gets a range of DeviceInformation objects.
 * @param {number} startIndex The index at which to start retrieving DeviceInformation objects.
 * @return {{items: !Windows.Devices.Enumeration.DeviceInformation, returnValue: number}}
 */
Windows.Devices.Enumeration.DeviceInformationCollection.prototype.getMany = function(startIndex) {};

/**
 * Returns the index of the specified DeviceInformation object in the collection.
 * @param {!Windows.Devices.Enumeration.DeviceInformation} value_or_searchElement The DeviceInformation object in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Devices.Enumeration.DeviceInformationCollection.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceInformationCustomPairing = function() {};
 /** @type {function(?): void} */
Windows.Devices.Enumeration.DeviceInformationCustomPairing.prototype.onpairingrequested;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Enumeration.DeviceInformationCustomPairing.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Enumeration.DeviceInformationCustomPairing.prototype.removeEventListener = function(type, listener) {};

/**
 * Attempts to pair the device.
 * Attempts to pair a device using a minimum protection level and custom settings.
 * Attempts to pair a device using a minimum protection level.
 * @param {Windows.Devices.Enumeration.DevicePairingKinds} pairingKindsSupported The different pairing kinds supported by this DeviceInformation object.
 * @param {Windows.Devices.Enumeration.DevicePairingProtectionLevel=} minProtectionLevel The minimum protection level this DeviceInformation object requires in order to pair.
 * @param {!Windows.Devices.Enumeration.IDevicePairingSettings=} devicePairingSettings The custom device pairing settings.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Enumeration.DevicePairingResult, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Enumeration.DevicePairingResult>>} The result of the pairing action.
 */
Windows.Devices.Enumeration.DeviceInformationCustomPairing.prototype.pairAsync = function(pairingKindsSupported, minProtectionLevel, devicePairingSettings) {};

/** @const */
Windows.Devices.Enumeration.DeviceInformationKind = {};
/** @const {number} */
Windows.Devices.Enumeration.DeviceInformationKind.unknown;
/** @const {number} */
Windows.Devices.Enumeration.DeviceInformationKind.deviceInterface;
/** @const {number} */
Windows.Devices.Enumeration.DeviceInformationKind.deviceContainer;
/** @const {number} */
Windows.Devices.Enumeration.DeviceInformationKind.device;
/** @const {number} */
Windows.Devices.Enumeration.DeviceInformationKind.deviceInterfaceClass;
/** @const {number} */
Windows.Devices.Enumeration.DeviceInformationKind.associationEndpoint;
/** @const {number} */
Windows.Devices.Enumeration.DeviceInformationKind.associationEndpointContainer;
/** @const {number} */
Windows.Devices.Enumeration.DeviceInformationKind.associationEndpointService;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceInformationPairing = function() {};
 /** @type {boolean} */
Windows.Devices.Enumeration.DeviceInformationPairing.prototype.canPair;
 /** @type {!Windows.Devices.Enumeration.DeviceInformationCustomPairing} */
Windows.Devices.Enumeration.DeviceInformationPairing.prototype.custom;
 /** @type {boolean} */
Windows.Devices.Enumeration.DeviceInformationPairing.prototype.isPaired;
 /** @type {Windows.Devices.Enumeration.DevicePairingProtectionLevel} */
Windows.Devices.Enumeration.DeviceInformationPairing.prototype.protectionLevel;

/**
 * Attempts to pair for all inbound pairing requests
 * @param {Windows.Devices.Enumeration.DevicePairingKinds} pairingKindsSupported The pairing kinds this device supports.
 * @return {boolean} Whether or not the attempt was successful.
 */
Windows.Devices.Enumeration.DeviceInformationPairing.tryRegisterForAllInboundPairingRequests = function(pairingKindsSupported) {};

/**
 * Attempts to pair the device.
 * Attempts to pair the device using a provided level of protection.
 * Attempts to pair a device object with a specified protection level and custom settings.
 * @param {Windows.Devices.Enumeration.DevicePairingProtectionLevel=} minProtectionLevel The required level of protection to use for the pairing action.
 * @param {!Windows.Devices.Enumeration.IDevicePairingSettings=} devicePairingSettings The custom device pairing settings.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Enumeration.DevicePairingResult, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Enumeration.DevicePairingResult>>} The result of the pairing action.
 */
Windows.Devices.Enumeration.DeviceInformationPairing.prototype.pairAsync = function(minProtectionLevel, devicePairingSettings) {};

/**
 * Attempts to unpair the device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Enumeration.DeviceUnpairingResult, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Enumeration.DeviceUnpairingResult>>} The result of the unpairing action.
 */
Windows.Devices.Enumeration.DeviceInformationPairing.prototype.unpairAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceInformationUpdate = function() {};
 /** @type {string} */
Windows.Devices.Enumeration.DeviceInformationUpdate.prototype.id;
 /** @type {Windows.Devices.Enumeration.DeviceInformationKind} */
Windows.Devices.Enumeration.DeviceInformationUpdate.prototype.kind;
 /** @type {!Windows.Foundation.Collections.IMapView<string, ?>} */
Windows.Devices.Enumeration.DeviceInformationUpdate.prototype.properties;

/** @const */
Windows.Devices.Enumeration.DevicePairingKinds = {};
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingKinds.none;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingKinds.confirmOnly;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingKinds.displayPin;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingKinds.providePin;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingKinds.confirmPinMatch;

/** @const */
Windows.Devices.Enumeration.DevicePairingProtectionLevel = {};
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingProtectionLevel.default;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingProtectionLevel.none;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingProtectionLevel.encryption;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingProtectionLevel.encryptionAndAuthentication;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DevicePairingRequestedEventArgs = function() {};
 /** @type {!Windows.Devices.Enumeration.DeviceInformation} */
Windows.Devices.Enumeration.DevicePairingRequestedEventArgs.prototype.deviceInformation;
 /** @type {Windows.Devices.Enumeration.DevicePairingKinds} */
Windows.Devices.Enumeration.DevicePairingRequestedEventArgs.prototype.pairingKind;
 /** @type {string} */
Windows.Devices.Enumeration.DevicePairingRequestedEventArgs.prototype.pin;

/**
 * Accepts a PairingRequested event and pairs the device with the application.
 * Accepts a PairingRequested event and pairs the device with the application. Requires a pin for pairing purposes.
 * @param {string=} pin The pin to use for attempting to pair a device.
 * @return {void}
 */
Windows.Devices.Enumeration.DevicePairingRequestedEventArgs.prototype.accept = function(pin) {};

/**
 * Requests a Deferral to support asynchronous operations.
 * @return {!Windows.Foundation.Deferral} The deferral necessary to support asynchronous actions.
 */
Windows.Devices.Enumeration.DevicePairingRequestedEventArgs.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DevicePairingResult = function() {};
 /** @type {Windows.Devices.Enumeration.DevicePairingProtectionLevel} */
Windows.Devices.Enumeration.DevicePairingResult.prototype.protectionLevelUsed;
 /** @type {Windows.Devices.Enumeration.DevicePairingResultStatus} */
Windows.Devices.Enumeration.DevicePairingResult.prototype.status;

/** @const */
Windows.Devices.Enumeration.DevicePairingResultStatus = {};
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.paired;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.notReadyToPair;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.notPaired;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.alreadyPaired;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.connectionRejected;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.tooManyConnections;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.hardwareFailure;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.authenticationTimeout;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.authenticationNotAllowed;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.authenticationFailure;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.noSupportedProfiles;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.protectionLevelCouldNotBeMet;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.accessDenied;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.invalidCeremonyData;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.pairingCanceled;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.operationAlreadyInProgress;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.requiredHandlerNotRegistered;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.rejectedByHandler;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.remoteDeviceHasAssociation;
/** @const {number} */
Windows.Devices.Enumeration.DevicePairingResultStatus.failed;

/**
 * @constructor
 * @struct
 * Creates a DevicePicker object.
 */
Windows.Devices.Enumeration.DevicePicker = function() {};
 /** @type {!Windows.Devices.Enumeration.DevicePickerAppearance} */
Windows.Devices.Enumeration.DevicePicker.prototype.appearance;
 /** @type {!Windows.Devices.Enumeration.DevicePickerFilter} */
Windows.Devices.Enumeration.DevicePicker.prototype.filter;
 /** @type {function(?): void} */
Windows.Devices.Enumeration.DevicePicker.prototype.ondevicepickerdismissed;
 /** @type {function(?): void} */
Windows.Devices.Enumeration.DevicePicker.prototype.ondeviceselected;
 /** @type {function(?): void} */
Windows.Devices.Enumeration.DevicePicker.prototype.ondisconnectbuttonclicked;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Devices.Enumeration.DevicePicker.prototype.requestedProperties;

/**
 * Hides the picker.
 * @return {void}
 */
Windows.Devices.Enumeration.DevicePicker.prototype.hide = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Enumeration.DevicePicker.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Enumeration.DevicePicker.prototype.removeEventListener = function(type, listener) {};

/**
 * Shows the picker UI and returns the selected device; does not require you to register for an event. The picker flies out from the specified edge of the specified rectangle.
 * Shows the picker UI and returns the selected device; does not require you to register for an event. The picker flies out from the edge of the specified rectangle.
 * @param {!Windows.Foundation.Rect} selection The rectangle from which you want the picker to fly out.
 * @param {Windows.UI.Popups.Placement=} placement The edge of the rectangle from which you want the picker to fly out.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Enumeration.DeviceInformation, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Enumeration.DeviceInformation>>} The device selected. / The device selected by the user.
 */
Windows.Devices.Enumeration.DevicePicker.prototype.pickSingleDeviceAsync = function(selection, placement) {};

/**
 * Updates the picker UI to reflect the provided status and display options for a specified device.
 * @param {!Windows.Devices.Enumeration.DeviceInformation} device The device information.
 * @param {string} status The status to display.
 * @param {Windows.Devices.Enumeration.DevicePickerDisplayStatusOptions} options The display options for the device.
 * @return {void}
 */
Windows.Devices.Enumeration.DevicePicker.prototype.setDisplayStatus = function(device, status, options) {};

/**
 * Shows the picker UI. The picker flies out from the specified edge of the specified rectangle.
 * Shows the picker UI. The picker flies out from the edge of the specified rectangle.
 * @param {!Windows.Foundation.Rect} selection The rectangle from which you want the picker to fly out.
 * @param {Windows.UI.Popups.Placement=} placement The edge of the rectangle from which you want the picker to fly out.
 * @return {void}
 */
Windows.Devices.Enumeration.DevicePicker.prototype.show = function(selection, placement) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DevicePickerAppearance = function() {};
 /** @type {!Windows.UI.Color} */
Windows.Devices.Enumeration.DevicePickerAppearance.prototype.accentColor;
 /** @type {!Windows.UI.Color} */
Windows.Devices.Enumeration.DevicePickerAppearance.prototype.backgroundColor;
 /** @type {!Windows.UI.Color} */
Windows.Devices.Enumeration.DevicePickerAppearance.prototype.foregroundColor;
 /** @type {!Windows.UI.Color} */
Windows.Devices.Enumeration.DevicePickerAppearance.prototype.selectedAccentColor;
 /** @type {!Windows.UI.Color} */
Windows.Devices.Enumeration.DevicePickerAppearance.prototype.selectedBackgroundColor;
 /** @type {!Windows.UI.Color} */
Windows.Devices.Enumeration.DevicePickerAppearance.prototype.selectedForegroundColor;
 /** @type {string} */
Windows.Devices.Enumeration.DevicePickerAppearance.prototype.title;

/** @const */
Windows.Devices.Enumeration.DevicePickerDisplayStatusOptions = {};
/** @const {number} */
Windows.Devices.Enumeration.DevicePickerDisplayStatusOptions.none;
/** @const {number} */
Windows.Devices.Enumeration.DevicePickerDisplayStatusOptions.showProgress;
/** @const {number} */
Windows.Devices.Enumeration.DevicePickerDisplayStatusOptions.showDisconnectButton;
/** @const {number} */
Windows.Devices.Enumeration.DevicePickerDisplayStatusOptions.showRetryButton;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DevicePickerFilter = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<Windows.Devices.Enumeration.DeviceClass>} */
Windows.Devices.Enumeration.DevicePickerFilter.prototype.supportedDeviceClasses;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Devices.Enumeration.DevicePickerFilter.prototype.supportedDeviceSelectors;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceSelectedEventArgs = function() {};
 /** @type {!Windows.Devices.Enumeration.DeviceInformation} */
Windows.Devices.Enumeration.DeviceSelectedEventArgs.prototype.selectedDevice;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceThumbnail = function() {};
 /** @type {boolean} */
Windows.Devices.Enumeration.DeviceThumbnail.prototype.canRead;
 /** @type {boolean} */
Windows.Devices.Enumeration.DeviceThumbnail.prototype.canWrite;
 /** @type {string} */
Windows.Devices.Enumeration.DeviceThumbnail.prototype.contentType;
 /** @type {number} */
Windows.Devices.Enumeration.DeviceThumbnail.prototype.position;
 /** @type {number} */
Windows.Devices.Enumeration.DeviceThumbnail.prototype.size;

/**
 * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
 * @return {!Windows.Storage.Streams.IRandomAccessStream} The new stream. The initial, internal position of the stream is 0.
 */
Windows.Devices.Enumeration.DeviceThumbnail.prototype.cloneStream = function() {};

/**
 * Closes the current stream and releases system resources.
 * @return {void}
 */
Windows.Devices.Enumeration.DeviceThumbnail.prototype.close = function() {};

/**
 * Flushes data asynchronously in a sequential stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The stream flush operation.
 */
Windows.Devices.Enumeration.DeviceThumbnail.prototype.flushAsync = function() {};

/**
 * Returns a pointer to an input stream starting at the specified location.
 * @param {number} position The position in the input stream.
 * @return {!Windows.Storage.Streams.IInputStream} A pointer to an input stream.
 */
Windows.Devices.Enumeration.DeviceThumbnail.prototype.getInputStreamAt = function(position) {};

/**
 * Returns a pointer to an output stream starting at the specified location.
 * @param {number} position The position in the output stream.
 * @return {!Windows.Storage.Streams.IOutputStream} A pointer to an output stream.
 */
Windows.Devices.Enumeration.DeviceThumbnail.prototype.getOutputStreamAt = function(position) {};

/**
 * Returns an asynchronous byte reader object.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param {number} count The number of bytes to read.
 * @param {Windows.Storage.Streams.InputStreamOptions} options Specifies the type of the asynchronous read operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The asynchronous operation.
 */
Windows.Devices.Enumeration.DeviceThumbnail.prototype.readAsync = function(buffer, count, options) {};

/**
 * Sets the position of the stream to the specified value.
 * @param {number} position The new position of the stream.
 * @return {void}
 */
Windows.Devices.Enumeration.DeviceThumbnail.prototype.seek = function(position) {};

/**
 * Writes data asynchronously in a sequential stream.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous writer operation writes.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The byte writer operation.
 */
Windows.Devices.Enumeration.DeviceThumbnail.prototype.writeAsync = function(buffer) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceUnpairingResult = function() {};
 /** @type {Windows.Devices.Enumeration.DeviceUnpairingResultStatus} */
Windows.Devices.Enumeration.DeviceUnpairingResult.prototype.status;

/** @const */
Windows.Devices.Enumeration.DeviceUnpairingResultStatus = {};
/** @const {number} */
Windows.Devices.Enumeration.DeviceUnpairingResultStatus.unpaired;
/** @const {number} */
Windows.Devices.Enumeration.DeviceUnpairingResultStatus.alreadyUnpaired;
/** @const {number} */
Windows.Devices.Enumeration.DeviceUnpairingResultStatus.operationAlreadyInProgress;
/** @const {number} */
Windows.Devices.Enumeration.DeviceUnpairingResultStatus.accessDenied;
/** @const {number} */
Windows.Devices.Enumeration.DeviceUnpairingResultStatus.failed;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceWatcher = function() {};
 /** @type {function(?): void} */
Windows.Devices.Enumeration.DeviceWatcher.prototype.onadded;
 /** @type {function(?): void} */
Windows.Devices.Enumeration.DeviceWatcher.prototype.onenumerationcompleted;
 /** @type {function(?): void} */
Windows.Devices.Enumeration.DeviceWatcher.prototype.onremoved;
 /** @type {function(?): void} */
Windows.Devices.Enumeration.DeviceWatcher.prototype.onstopped;
 /** @type {function(?): void} */
Windows.Devices.Enumeration.DeviceWatcher.prototype.onupdated;
 /** @type {Windows.Devices.Enumeration.DeviceWatcherStatus} */
Windows.Devices.Enumeration.DeviceWatcher.prototype.status;

/**
 * Gets a DeviceWatcherTrigger object monitoring for changes to the list of devices.
 * @param {!Windows.Foundation.Collections.IIterable<Windows.Devices.Enumeration.DeviceWatcherEventKind>} requestedEventKinds A list of the specific updates you want to monitor.
 * @return {!Windows.ApplicationModel.Background.DeviceWatcherTrigger} The watcher trigger to monitor for the specified changes.
 */
Windows.Devices.Enumeration.DeviceWatcher.prototype.getBackgroundTrigger = function(requestedEventKinds) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Enumeration.DeviceWatcher.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Enumeration.DeviceWatcher.prototype.removeEventListener = function(type, listener) {};

/**
 * Starts a search for devices, and subscribes to device enumeration events.
 * @return {void}
 */
Windows.Devices.Enumeration.DeviceWatcher.prototype.start = function() {};

/**
 * Stop raising the events that add, update and remove enumeration results.
 * @return {void}
 */
Windows.Devices.Enumeration.DeviceWatcher.prototype.stop = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceWatcherEvent = function() {};
 /** @type {!Windows.Devices.Enumeration.DeviceInformation} */
Windows.Devices.Enumeration.DeviceWatcherEvent.prototype.deviceInformation;
 /** @type {!Windows.Devices.Enumeration.DeviceInformationUpdate} */
Windows.Devices.Enumeration.DeviceWatcherEvent.prototype.deviceInformationUpdate;
 /** @type {Windows.Devices.Enumeration.DeviceWatcherEventKind} */
Windows.Devices.Enumeration.DeviceWatcherEvent.prototype.kind;

/** @const */
Windows.Devices.Enumeration.DeviceWatcherEventKind = {};
/** @const {number} */
Windows.Devices.Enumeration.DeviceWatcherEventKind.add;
/** @const {number} */
Windows.Devices.Enumeration.DeviceWatcherEventKind.update;
/** @const {number} */
Windows.Devices.Enumeration.DeviceWatcherEventKind.remove;

/** @const */
Windows.Devices.Enumeration.DeviceWatcherStatus = {};
/** @const {number} */
Windows.Devices.Enumeration.DeviceWatcherStatus.created;
/** @const {number} */
Windows.Devices.Enumeration.DeviceWatcherStatus.started;
/** @const {number} */
Windows.Devices.Enumeration.DeviceWatcherStatus.enumerationCompleted;
/** @const {number} */
Windows.Devices.Enumeration.DeviceWatcherStatus.stopping;
/** @const {number} */
Windows.Devices.Enumeration.DeviceWatcherStatus.stopped;
/** @const {number} */
Windows.Devices.Enumeration.DeviceWatcherStatus.aborted;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.DeviceWatcherTriggerDetails = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Enumeration.DeviceWatcherEvent>} */
Windows.Devices.Enumeration.DeviceWatcherTriggerDetails.prototype.deviceWatcherEvents;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.EnclosureLocation = function() {};
 /** @type {boolean} */
Windows.Devices.Enumeration.EnclosureLocation.prototype.inDock;
 /** @type {boolean} */
Windows.Devices.Enumeration.EnclosureLocation.prototype.inLid;
 /** @type {Windows.Devices.Enumeration.Panel} */
Windows.Devices.Enumeration.EnclosureLocation.prototype.panel;

/** @const */
Windows.Devices.Enumeration.Panel = {};
/** @const {number} */
Windows.Devices.Enumeration.Panel.unknown;
/** @const {number} */
Windows.Devices.Enumeration.Panel.front;
/** @const {number} */
Windows.Devices.Enumeration.Panel.back;
/** @const {number} */
Windows.Devices.Enumeration.Panel.top;
/** @const {number} */
Windows.Devices.Enumeration.Panel.bottom;
/** @const {number} */
Windows.Devices.Enumeration.Panel.left;
/** @const {number} */
Windows.Devices.Enumeration.Panel.right;
/** @const */
Windows.Devices.Enumeration.Pnp = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.Pnp.PnpObject = function() {};
 /** @type {string} */
Windows.Devices.Enumeration.Pnp.PnpObject.prototype.id;
 /** @type {!Windows.Foundation.Collections.IMapView<string, ?>} */
Windows.Devices.Enumeration.Pnp.PnpObject.prototype.properties;
 /** @type {Windows.Devices.Enumeration.Pnp.PnpObjectType} */
Windows.Devices.Enumeration.Pnp.PnpObject.prototype.type;

/**
 * Creates a PnpObject object asynchronously from a previously saved DeviceInformation ID.
 * @param {Windows.Devices.Enumeration.Pnp.PnpObjectType} type The type of the PnpObject .
 * @param {string} id The string value identifying the PnpObject .
 * @param {!Windows.Foundation.Collections.IIterable<string>} requestedProperties An iterable list of additional properties to include in the Properties property of the PnpObject object to create. For more info on what the properties represent, see Device information properties.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Enumeration.Pnp.PnpObject, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Enumeration.Pnp.PnpObject>>} The PnpObject created from the previously saved DeviceInformation ID.
 */
Windows.Devices.Enumeration.Pnp.PnpObject.createFromIdAsync = function(type, id, requestedProperties) {};

/**
 * Returns a PnpObjectWatcher object that is used to enumerate a filtered collection of PnP objects using events.
 * Returns a PnpObjectWatcher object that is used to enumerate the PnP objects in the collection using events.
 * @param {Windows.Devices.Enumeration.Pnp.PnpObjectType} type The type of the PnpObject .
 * @param {!Windows.Foundation.Collections.IIterable<string>} requestedProperties An iterable list of additional properties to include in the Properties property of the PnpObject objects included in enumeration results. For more info on what the properties represent, see Device information properties.
 * @param {string=} aqsFilter An AQS string that filters the PnP objects that will be returned. Typically, this string is retrieved from the GetDeviceSelector method of a class that interacts with devices.
 * @return {!Windows.Devices.Enumeration.Pnp.PnpObjectWatcher} A PnpObjectWatcher object used to enumerate the collection by registering event notification delegates and by issuing start and stop event notifications.
 */
Windows.Devices.Enumeration.Pnp.PnpObject.createWatcher = function(type, requestedProperties, aqsFilter) {};

/**
 * Returns all of the PnP objects of a specified type that match the specified filter.
 * Returns all of the PnP objects of a specified type that match the specified criteria.
 * @param {Windows.Devices.Enumeration.Pnp.PnpObjectType} type The type of the PnpObject .
 * @param {!Windows.Foundation.Collections.IIterable<string>} requestedProperties An iterable list of additional properties to include in the Properties property of the PnpObject objects included in enumeration results. For more info on what the properties represent, see Device information properties.
 * @param {string=} aqsFilter An AQS string that filters the PnP objects that will be returned. Typically, this string is retrieved from the GetDeviceSelector method of a class that interacts with devices.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Enumeration.Pnp.PnpObjectCollection, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Enumeration.Pnp.PnpObjectCollection>>} An object that represents the asynchronous operation.
 */
Windows.Devices.Enumeration.Pnp.PnpObject.findAllAsync = function(type, requestedProperties, aqsFilter) {};

/**
 * Updates the properties of an existing PnpObject by applying the changes described in a PnpObjectUpdate object.
 * @param {!Windows.Devices.Enumeration.Pnp.PnpObjectUpdate} updateInfo Indicates the properties to update.
 * @return {void}
 */
Windows.Devices.Enumeration.Pnp.PnpObject.prototype.update = function(updateInfo) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.Pnp.PnpObjectCollection = function() {};
 /** @type {number} */
Windows.Devices.Enumeration.Pnp.PnpObjectCollection.prototype.size;

/**
 * Returns the iterator for iteration over the items in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Devices.Enumeration.Pnp.PnpObject>} The iterator object. The iterator's current position is at the 0-index position, or at the end of the collection if the collection is empty.
 */
Windows.Devices.Enumeration.Pnp.PnpObjectCollection.prototype.first = function() {};

/**
 * Returns the PnpObject located at the specified index.
 * @param {number} index The integer index for the value to retrieve.
 * @return {!Windows.Devices.Enumeration.Pnp.PnpObject} The PnpObject at the specified index.
 */
Windows.Devices.Enumeration.Pnp.PnpObjectCollection.prototype.getAt = function(index) {};

/**
 * Retrieves multiple elements in a single pass through the iterator.
 * @param {number} startIndex The index from which to start retrieval.
 * @return {{items: !Windows.Devices.Enumeration.Pnp.PnpObject, returnValue: number}}
 */
Windows.Devices.Enumeration.Pnp.PnpObjectCollection.prototype.getMany = function(startIndex) {};

/**
 * Retrieves the index of the specified item.
 * @param {!Windows.Devices.Enumeration.Pnp.PnpObject} value_or_searchElement The value to find in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Devices.Enumeration.Pnp.PnpObjectCollection.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};

/** @const */
Windows.Devices.Enumeration.Pnp.PnpObjectType = {};
/** @const {number} */
Windows.Devices.Enumeration.Pnp.PnpObjectType.unknown;
/** @const {number} */
Windows.Devices.Enumeration.Pnp.PnpObjectType.deviceInterface;
/** @const {number} */
Windows.Devices.Enumeration.Pnp.PnpObjectType.deviceContainer;
/** @const {number} */
Windows.Devices.Enumeration.Pnp.PnpObjectType.device;
/** @const {number} */
Windows.Devices.Enumeration.Pnp.PnpObjectType.deviceInterfaceClass;
/** @const {number} */
Windows.Devices.Enumeration.Pnp.PnpObjectType.associationEndpoint;
/** @const {number} */
Windows.Devices.Enumeration.Pnp.PnpObjectType.associationEndpointContainer;
/** @const {number} */
Windows.Devices.Enumeration.Pnp.PnpObjectType.associationEndpointService;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.Pnp.PnpObjectUpdate = function() {};
 /** @type {string} */
Windows.Devices.Enumeration.Pnp.PnpObjectUpdate.prototype.id;
 /** @type {!Windows.Foundation.Collections.IMapView<string, ?>} */
Windows.Devices.Enumeration.Pnp.PnpObjectUpdate.prototype.properties;
 /** @type {Windows.Devices.Enumeration.Pnp.PnpObjectType} */
Windows.Devices.Enumeration.Pnp.PnpObjectUpdate.prototype.type;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Enumeration.Pnp.PnpObjectWatcher = function() {};
 /** @type {function(?): void} */
Windows.Devices.Enumeration.Pnp.PnpObjectWatcher.prototype.onadded;
 /** @type {function(?): void} */
Windows.Devices.Enumeration.Pnp.PnpObjectWatcher.prototype.onenumerationcompleted;
 /** @type {function(?): void} */
Windows.Devices.Enumeration.Pnp.PnpObjectWatcher.prototype.onremoved;
 /** @type {function(?): void} */
Windows.Devices.Enumeration.Pnp.PnpObjectWatcher.prototype.onstopped;
 /** @type {function(?): void} */
Windows.Devices.Enumeration.Pnp.PnpObjectWatcher.prototype.onupdated;
 /** @type {Windows.Devices.Enumeration.DeviceWatcherStatus} */
Windows.Devices.Enumeration.Pnp.PnpObjectWatcher.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Enumeration.Pnp.PnpObjectWatcher.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Enumeration.Pnp.PnpObjectWatcher.prototype.removeEventListener = function(type, listener) {};

/**
 * Starts raising the events to inform the client that a PnpObject has been added, updated, or removed.
 * @return {void}
 */
Windows.Devices.Enumeration.Pnp.PnpObjectWatcher.prototype.start = function() {};

/**
 * Stops raising the events to inform the client that a PnpObject has been added, updated, or removed.
 * @return {void}
 */
Windows.Devices.Enumeration.Pnp.PnpObjectWatcher.prototype.stop = function() {};
/**
 * @record
 * @struct
 */
Windows.Devices.Enumeration.IDevicePairingSettings = function() {};
/** @const */
Windows.Devices.Geolocation = {};

/** @const */
Windows.Devices.Geolocation.AltitudeReferenceSystem = {};
/** @const {number} */
Windows.Devices.Geolocation.AltitudeReferenceSystem.unspecified;
/** @const {number} */
Windows.Devices.Geolocation.AltitudeReferenceSystem.terrain;
/** @const {number} */
Windows.Devices.Geolocation.AltitudeReferenceSystem.ellipsoid;
/** @const {number} */
Windows.Devices.Geolocation.AltitudeReferenceSystem.geoid;
/** @const {number} */
Windows.Devices.Geolocation.AltitudeReferenceSystem.surface;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Geolocation.CivicAddress = function() {};
 /** @type {string} */
Windows.Devices.Geolocation.CivicAddress.prototype.city;
 /** @type {string} */
Windows.Devices.Geolocation.CivicAddress.prototype.country;
 /** @type {string} */
Windows.Devices.Geolocation.CivicAddress.prototype.postalCode;
 /** @type {string} */
Windows.Devices.Geolocation.CivicAddress.prototype.state;
 /** @type {!Date} */
Windows.Devices.Geolocation.CivicAddress.prototype.timestamp;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the GeoboundingBox class that has the specified corners.
 * Initializes a new instance of the GeoboundingBox class that has the specified corners and uses the specified altitude reference system.
 * Initializes a new instance of the GeoboundingBox class that has the specified corners and uses the specified altitude reference system and spatial reference ID (SRID).
 * @param {!Windows.Devices.Geolocation.BasicGeoposition} northwestCorner The northwest corner to use for the new GeoboundingBox . For more info, see the NorthwestCorner property.
 * @param {!Windows.Devices.Geolocation.BasicGeoposition} southeastCorner The southeast corner to use for the new GeoboundingBox . For more info, see the SoutheastCorner property.
 * @param {Windows.Devices.Geolocation.AltitudeReferenceSystem=} altitudeReferenceSystem The altitude reference system to use for the new GeoboundingBox . For more info, see the AltitudeReferenceSystem property.
 * @param {number=} spatialReferenceId The spatial reference ID (SRID) to use for the new GeoboundingBox . For more info, see the SpatialReferenceId property.
 */
Windows.Devices.Geolocation.GeoboundingBox = function(northwestCorner, southeastCorner, altitudeReferenceSystem, spatialReferenceId) {};
 /** @type {Windows.Devices.Geolocation.AltitudeReferenceSystem} */
Windows.Devices.Geolocation.GeoboundingBox.prototype.altitudeReferenceSystem;
 /** @type {!Windows.Devices.Geolocation.BasicGeoposition} */
Windows.Devices.Geolocation.GeoboundingBox.prototype.center;
 /** @type {Windows.Devices.Geolocation.GeoshapeType} */
Windows.Devices.Geolocation.GeoboundingBox.prototype.geoshapeType;
 /** @type {number} */
Windows.Devices.Geolocation.GeoboundingBox.prototype.maxAltitude;
 /** @type {number} */
Windows.Devices.Geolocation.GeoboundingBox.prototype.minAltitude;
 /** @type {!Windows.Devices.Geolocation.BasicGeoposition} */
Windows.Devices.Geolocation.GeoboundingBox.prototype.northwestCorner;
 /** @type {!Windows.Devices.Geolocation.BasicGeoposition} */
Windows.Devices.Geolocation.GeoboundingBox.prototype.southeastCorner;
 /** @type {number} */
Windows.Devices.Geolocation.GeoboundingBox.prototype.spatialReferenceId;

/**
 * Calculates a GeoboundingBox that contains the specified set of geographic positions.
 * Calculates a GeoboundingBox that contains the specified set of geographic positions and uses the specified altitude reference system and spatial reference ID (SRID).
 * Calculates a GeoboundingBox that contains the specified set of geographic positions and uses the specified altitude reference system.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Devices.Geolocation.BasicGeoposition>} positions A collection of geographic positions to include inside the GeoboundingBox .
 * @param {Windows.Devices.Geolocation.AltitudeReferenceSystem=} altitudeRefSystem The altitude reference system to use for the GeoboundingBox . For more info, see the AltitudeReferenceSystem property.
 * @param {number=} spatialReferenceId The spatial reference ID (SRID) to use for the GeoboundingBox . For more info, see the SpatialReferenceId property.
 * @return {!Windows.Devices.Geolocation.GeoboundingBox} The calculated rectangle that contains the specified set of geographic positions.
 */
Windows.Devices.Geolocation.GeoboundingBox.tryCompute = function(positions, altitudeRefSystem, spatialReferenceId) {};

/**
 * @constructor
 * @struct
 * Create a geographic circle object for the given position and radius.
 * Create a geographic circle object for the given position, radius, altitude reference system, and spatial reference id.
 * Create a geographic circle object for the given position, radius and altitude reference system.
 * @param {!Windows.Devices.Geolocation.BasicGeoposition} position The geographic position of the new circle.
 * @param {number} radius The radius of the new circle, in meters.
 * @param {Windows.Devices.Geolocation.AltitudeReferenceSystem=} altitudeReferenceSystem The altitude reference system of the new circle.
 * @param {number=} spatialReferenceId The spatial reference Id of the new circle.
 */
Windows.Devices.Geolocation.Geocircle = function(position, radius, altitudeReferenceSystem, spatialReferenceId) {};
 /** @type {Windows.Devices.Geolocation.AltitudeReferenceSystem} */
Windows.Devices.Geolocation.Geocircle.prototype.altitudeReferenceSystem;
 /** @type {!Windows.Devices.Geolocation.BasicGeoposition} */
Windows.Devices.Geolocation.Geocircle.prototype.center;
 /** @type {Windows.Devices.Geolocation.GeoshapeType} */
Windows.Devices.Geolocation.Geocircle.prototype.geoshapeType;
 /** @type {number} */
Windows.Devices.Geolocation.Geocircle.prototype.radius;
 /** @type {number} */
Windows.Devices.Geolocation.Geocircle.prototype.spatialReferenceId;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Geolocation.Geocoordinate = function() {};
 /** @type {number} */
Windows.Devices.Geolocation.Geocoordinate.prototype.accuracy;
 /** @type {number} */
Windows.Devices.Geolocation.Geocoordinate.prototype.altitude;
 /** @type {number} */
Windows.Devices.Geolocation.Geocoordinate.prototype.altitudeAccuracy;
 /** @type {number} */
Windows.Devices.Geolocation.Geocoordinate.prototype.heading;
 /** @type {number} */
Windows.Devices.Geolocation.Geocoordinate.prototype.latitude;
 /** @type {number} */
Windows.Devices.Geolocation.Geocoordinate.prototype.longitude;
 /** @type {!Windows.Devices.Geolocation.Geopoint} */
Windows.Devices.Geolocation.Geocoordinate.prototype.point;
 /** @type {Windows.Devices.Geolocation.PositionSource} */
Windows.Devices.Geolocation.Geocoordinate.prototype.positionSource;
 /** @type {!Date} */
Windows.Devices.Geolocation.Geocoordinate.prototype.positionSourceTimestamp;
 /** @type {!Windows.Devices.Geolocation.GeocoordinateSatelliteData} */
Windows.Devices.Geolocation.Geocoordinate.prototype.satelliteData;
 /** @type {number} */
Windows.Devices.Geolocation.Geocoordinate.prototype.speed;
 /** @type {!Date} */
Windows.Devices.Geolocation.Geocoordinate.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Geolocation.GeocoordinateSatelliteData = function() {};
 /** @type {number} */
Windows.Devices.Geolocation.GeocoordinateSatelliteData.prototype.horizontalDilutionOfPrecision;
 /** @type {number} */
Windows.Devices.Geolocation.GeocoordinateSatelliteData.prototype.positionDilutionOfPrecision;
 /** @type {number} */
Windows.Devices.Geolocation.GeocoordinateSatelliteData.prototype.verticalDilutionOfPrecision;
/** @const */
Windows.Devices.Geolocation.Geofencing = {};

/**
 * @constructor
 * @struct
 * Initializes a new Geofence object given the id, the shape of the geofence, the states to monitor the geofence for, the singleUse flag, the dwellTime for the geofence, the time to start monitoring the geofence, and the duration of the geofence.
 * Initializes a new Geofence object given the id, the shape of the geofence, the states to monitor the geofence for, and the singleUse flag.
 * Initializes a new Geofence object given the id and the shape of the geofence.
 * Initializes a new Geofence object given the id, the shape of the geofence, the states to monitor the geofence for, the singleUse flag, and the dwellTime for the geofence.
 * @param {string} id The Id of the geofence.
 * @param {!Windows.Devices.Geolocation.IGeoshape} geoshape The area that defines the geofence to monitor.
 * @param {Windows.Devices.Geolocation.Geofencing.MonitoredGeofenceStates=} monitoredStates The states to monitor the geofence for.
 * @param {boolean=} singleUse True indicates the geofence should be monitored only for one use. False indicates the geofence should be monitored for multiple uses.
 * @param {number=} dwellTime The time that a position has to be in or out of the geofence in order for the notification to be triggered.
 * @param {!Date=} startTime The time to start monitoring the geofence.
 * @param {number=} duration The duration of time to monitor the geofence for. The duration begins at the startTime.
 */
Windows.Devices.Geolocation.Geofencing.Geofence = function(id, geoshape, monitoredStates, singleUse, dwellTime, startTime, duration) {};
 /** @type {number} */
Windows.Devices.Geolocation.Geofencing.Geofence.prototype.duration;
 /** @type {number} */
Windows.Devices.Geolocation.Geofencing.Geofence.prototype.dwellTime;
 /** @type {!Windows.Devices.Geolocation.IGeoshape} */
Windows.Devices.Geolocation.Geofencing.Geofence.prototype.geoshape;
 /** @type {string} */
Windows.Devices.Geolocation.Geofencing.Geofence.prototype.id;
 /** @type {Windows.Devices.Geolocation.Geofencing.MonitoredGeofenceStates} */
Windows.Devices.Geolocation.Geofencing.Geofence.prototype.monitoredStates;
 /** @type {boolean} */
Windows.Devices.Geolocation.Geofencing.Geofence.prototype.singleUse;
 /** @type {!Date} */
Windows.Devices.Geolocation.Geofencing.Geofence.prototype.startTime;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitor = function() {};
 /** @type {!Windows.Devices.Geolocation.Geofencing.GeofenceMonitor} */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitor.current;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Devices.Geolocation.Geofencing.Geofence>} */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitor.prototype.geofences;
 /** @type {!Windows.Devices.Geolocation.Geoposition} */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitor.prototype.lastKnownGeoposition;
 /** @type {function(?): void} */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitor.prototype.ongeofencestatechanged;
 /** @type {function(?): void} */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitor.prototype.onstatuschanged;
 /** @type {Windows.Devices.Geolocation.Geofencing.GeofenceMonitorStatus} */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitor.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitor.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitor.prototype.removeEventListener = function(type, listener) {};

/**
 * Gets a collection of status changes to the Geofence objects in the Geofences collection of the GeofenceMonitor .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Geolocation.Geofencing.GeofenceStateChangeReport>} collection of status changes to the GeofenceMonitor .
 */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitor.prototype.readReports = function() {};

/** @const */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitorStatus = {};
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitorStatus.ready;
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitorStatus.initializing;
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitorStatus.noData;
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitorStatus.disabled;
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitorStatus.notInitialized;
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.GeofenceMonitorStatus.notAvailable;

/** @const */
Windows.Devices.Geolocation.Geofencing.GeofenceRemovalReason = {};
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.GeofenceRemovalReason.used;
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.GeofenceRemovalReason.expired;

/** @const */
Windows.Devices.Geolocation.Geofencing.GeofenceState = {};
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.GeofenceState.none;
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.GeofenceState.entered;
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.GeofenceState.exited;
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.GeofenceState.removed;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Geolocation.Geofencing.GeofenceStateChangeReport = function() {};
 /** @type {!Windows.Devices.Geolocation.Geofencing.Geofence} */
Windows.Devices.Geolocation.Geofencing.GeofenceStateChangeReport.prototype.geofence;
 /** @type {!Windows.Devices.Geolocation.Geoposition} */
Windows.Devices.Geolocation.Geofencing.GeofenceStateChangeReport.prototype.geoposition;
 /** @type {Windows.Devices.Geolocation.Geofencing.GeofenceState} */
Windows.Devices.Geolocation.Geofencing.GeofenceStateChangeReport.prototype.newState;
 /** @type {Windows.Devices.Geolocation.Geofencing.GeofenceRemovalReason} */
Windows.Devices.Geolocation.Geofencing.GeofenceStateChangeReport.prototype.removalReason;

/** @const */
Windows.Devices.Geolocation.Geofencing.MonitoredGeofenceStates = {};
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.MonitoredGeofenceStates.none;
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.MonitoredGeofenceStates.entered;
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.MonitoredGeofenceStates.exited;
/** @const {number} */
Windows.Devices.Geolocation.Geofencing.MonitoredGeofenceStates.removed;

/** @const */
Windows.Devices.Geolocation.GeolocationAccessStatus = {};
/** @const {number} */
Windows.Devices.Geolocation.GeolocationAccessStatus.unspecified;
/** @const {number} */
Windows.Devices.Geolocation.GeolocationAccessStatus.allowed;
/** @const {number} */
Windows.Devices.Geolocation.GeolocationAccessStatus.denied;

/**
 * @constructor
 * @struct
 * Initializes a new Geolocator object.
 */
Windows.Devices.Geolocation.Geolocator = function() {};
 /** @type {Windows.Devices.Geolocation.PositionAccuracy} */
Windows.Devices.Geolocation.Geolocator.prototype.desiredAccuracy;
 /** @type {number} */
Windows.Devices.Geolocation.Geolocator.prototype.desiredAccuracyInMeters;
 /** @type {Windows.Devices.Geolocation.PositionStatus} */
Windows.Devices.Geolocation.Geolocator.prototype.locationStatus;
 /** @type {number} */
Windows.Devices.Geolocation.Geolocator.prototype.movementThreshold;
 /** @type {function(?): void} */
Windows.Devices.Geolocation.Geolocator.prototype.onpositionchanged;
 /** @type {function(?): void} */
Windows.Devices.Geolocation.Geolocator.prototype.onstatuschanged;
 /** @type {number} */
Windows.Devices.Geolocation.Geolocator.prototype.reportInterval;

/**
 * Starts an asynchronous operation to retrieve the location history of the device.
 * Starts an asynchronous operation to retrieve the location history of the device.
 * @param {!Date} startTime Represents the beginning of the time span for which positions are to be returned.
 * @param {number=} duration Represents the length of time after startTime for which positions are to be returned.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} Positions (of type Geoposition ) that were collected during the specified time span.
 */
Windows.Devices.Geolocation.Geolocator.getGeopositionHistoryAsync = function(startTime, duration) {};

/**
 * Requests permission to access location data.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Devices.Geolocation.GeolocationAccessStatus, !Windows.Foundation.IAsyncOperation<Windows.Devices.Geolocation.GeolocationAccessStatus>>} A GeolocationAccessStatus that indicates if permission to location data has been granted.
 */
Windows.Devices.Geolocation.Geolocator.requestAccessAsync = function() {};

/**
 * Starts an asynchronous operation to retrieve the current location of the device.
 * Starts an asynchronous operation to retrieve the current location of the device.
 * @param {number=} maximumAge The maximum acceptable age of cached location data. A TimeSpan is a time period expressed in 100-nanosecond units.
 * @param {number=} timeout The timeout. A TimeSpan is a time period expressed in 100-nanosecond units.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Geolocation.Geoposition, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Geolocation.Geoposition>>} Provides methods for starting the asynchronous request for location data and handling its completion.
 */
Windows.Devices.Geolocation.Geolocator.prototype.getGeopositionAsync = function(maximumAge, timeout) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Geolocation.Geolocator.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Geolocation.Geolocator.prototype.removeEventListener = function(type, listener) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the Geopath class with the specified collection of positions.
 * Initializes a new instance of the Geopath class with the specified collection of positions and with the specified altitude reference system and spatial reference ID (SRID).
 * Initializes a new instance of the Geopath class with the specified collection of positions and with the specified altitude reference system.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Devices.Geolocation.BasicGeoposition>} positions The collection of positions to use to create the new Geopath . For more info, see the Positions property.
 * @param {Windows.Devices.Geolocation.AltitudeReferenceSystem=} altitudeReferenceSystem The altitude reference system to use to create the new Geopath . For more info, see the AltitudeReferenceSystem property.
 * @param {number=} spatialReferenceId The spatial reference ID (SRID) to use to create the new Geopath . For more info, see the SpatialReferenceId property.
 */
Windows.Devices.Geolocation.Geopath = function(positions, altitudeReferenceSystem, spatialReferenceId) {};
 /** @type {Windows.Devices.Geolocation.AltitudeReferenceSystem} */
Windows.Devices.Geolocation.Geopath.prototype.altitudeReferenceSystem;
 /** @type {Windows.Devices.Geolocation.GeoshapeType} */
Windows.Devices.Geolocation.Geopath.prototype.geoshapeType;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Geolocation.BasicGeoposition>} */
Windows.Devices.Geolocation.Geopath.prototype.positions;
 /** @type {number} */
Windows.Devices.Geolocation.Geopath.prototype.spatialReferenceId;

/**
 * @constructor
 * @struct
 * Create a geographic point object for the given position.
 * Create a geographic point object for the given position, altitude reference system, and spatial reference Id.
 * Create a geographic point object for the given position and altitude reference system.
 * @param {!Windows.Devices.Geolocation.BasicGeoposition} position Create a geographic point object for the given position.
 * @param {Windows.Devices.Geolocation.AltitudeReferenceSystem=} altitudeReferenceSystem The altitude reference system of the new point.
 * @param {number=} spatialReferenceId The spatial reference Id of the new point.
 */
Windows.Devices.Geolocation.Geopoint = function(position, altitudeReferenceSystem, spatialReferenceId) {};
 /** @type {Windows.Devices.Geolocation.AltitudeReferenceSystem} */
Windows.Devices.Geolocation.Geopoint.prototype.altitudeReferenceSystem;
 /** @type {Windows.Devices.Geolocation.GeoshapeType} */
Windows.Devices.Geolocation.Geopoint.prototype.geoshapeType;
 /** @type {!Windows.Devices.Geolocation.BasicGeoposition} */
Windows.Devices.Geolocation.Geopoint.prototype.position;
 /** @type {number} */
Windows.Devices.Geolocation.Geopoint.prototype.spatialReferenceId;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Geolocation.Geoposition = function() {};
 /** @type {!Windows.Devices.Geolocation.CivicAddress} */
Windows.Devices.Geolocation.Geoposition.prototype.civicAddress;
 /** @type {!Windows.Devices.Geolocation.Geocoordinate} */
Windows.Devices.Geolocation.Geoposition.prototype.coordinate;
 /** @type {!Windows.Devices.Geolocation.VenueData} */
Windows.Devices.Geolocation.Geoposition.prototype.venueData;

/** @const */
Windows.Devices.Geolocation.GeoshapeType = {};
/** @const {number} */
Windows.Devices.Geolocation.GeoshapeType.geopoint;
/** @const {number} */
Windows.Devices.Geolocation.GeoshapeType.geocircle;
/** @const {number} */
Windows.Devices.Geolocation.GeoshapeType.geopath;
/** @const {number} */
Windows.Devices.Geolocation.GeoshapeType.geoboundingBox;

/** @const */
Windows.Devices.Geolocation.PositionAccuracy = {};
/** @const {number} */
Windows.Devices.Geolocation.PositionAccuracy.default;
/** @const {number} */
Windows.Devices.Geolocation.PositionAccuracy.high;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Geolocation.PositionChangedEventArgs = function() {};
 /** @type {!Windows.Devices.Geolocation.Geoposition} */
Windows.Devices.Geolocation.PositionChangedEventArgs.prototype.position;

/** @const */
Windows.Devices.Geolocation.PositionSource = {};
/** @const {number} */
Windows.Devices.Geolocation.PositionSource.cellular;
/** @const {number} */
Windows.Devices.Geolocation.PositionSource.satellite;
/** @const {number} */
Windows.Devices.Geolocation.PositionSource.wiFi;
/** @const {number} */
Windows.Devices.Geolocation.PositionSource.ipAddress;
/** @const {number} */
Windows.Devices.Geolocation.PositionSource.unknown;

/** @const */
Windows.Devices.Geolocation.PositionStatus = {};
/** @const {number} */
Windows.Devices.Geolocation.PositionStatus.ready;
/** @const {number} */
Windows.Devices.Geolocation.PositionStatus.initializing;
/** @const {number} */
Windows.Devices.Geolocation.PositionStatus.noData;
/** @const {number} */
Windows.Devices.Geolocation.PositionStatus.disabled;
/** @const {number} */
Windows.Devices.Geolocation.PositionStatus.notInitialized;
/** @const {number} */
Windows.Devices.Geolocation.PositionStatus.notAvailable;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Geolocation.StatusChangedEventArgs = function() {};
 /** @type {Windows.Devices.Geolocation.PositionStatus} */
Windows.Devices.Geolocation.StatusChangedEventArgs.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Geolocation.VenueData = function() {};
 /** @type {string} */
Windows.Devices.Geolocation.VenueData.prototype.id;
 /** @type {string} */
Windows.Devices.Geolocation.VenueData.prototype.level;
/**
 * @record
 * @struct
 */
Windows.Devices.Geolocation.BasicGeoposition = function() {};
 /** @type {number} */
Windows.Devices.Geolocation.BasicGeoposition.prototype.altitude;
 /** @type {number} */
Windows.Devices.Geolocation.BasicGeoposition.prototype.latitude;
 /** @type {number} */
Windows.Devices.Geolocation.BasicGeoposition.prototype.longitude;
/**
 * @record
 * @struct
 */
Windows.Devices.Geolocation.IGeoshape = function() {};
 /** @type {Windows.Devices.Geolocation.AltitudeReferenceSystem} */
Windows.Devices.Geolocation.IGeoshape.prototype.altitudeReferenceSystem;
 /** @type {Windows.Devices.Geolocation.GeoshapeType} */
Windows.Devices.Geolocation.IGeoshape.prototype.geoshapeType;
 /** @type {number} */
Windows.Devices.Geolocation.IGeoshape.prototype.spatialReferenceId;
/** @const */
Windows.Devices.Gpio = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Gpio.GpioController = function() {};
 /** @type {number} */
Windows.Devices.Gpio.GpioController.prototype.pinCount;

/**
 * Gets all the controllers that are connected to the system asynchronously.
 * @param {!Windows.Devices.Gpio.Provider.IGpioProvider} provider The GPIO provider for the controllers on the system.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When the method completes successfully, it returns a list of values that represent the controllers available on the system.
 */
Windows.Devices.Gpio.GpioController.getControllersAsync = function(provider) {};

/**
 * Gets the default general-purpose I/O (GPIO) controller for the system.
 * @return {!Windows.Devices.Gpio.GpioController} The default GPIO controller for the system, or null if the system has no GPIO controller.
 */
Windows.Devices.Gpio.GpioController.getDefault = function() {};

/**
 * Gets the default general-purpose I/O (GPIO) controller for the system.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Gpio.GpioController, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Gpio.GpioController>>} The default GPIO controller for the system, or null if the system has no GPIO controller.
 */
Windows.Devices.Gpio.GpioController.getDefaultAsync = function() {};

/**
 * Opens a connection to the specified general-purpose I/O (GPIO) pin in exclusive mode.
 * Opens the specified general-purpose I/O (GPIO) pin in the specified mode.
 * @param {number} pinNumber The pin number of the GPIO pin that you want to open. Some pins may not be available in user mode. For information about how the pin numbers correspond to physical pins, see the documentation for your circuit board.
 * @param {Windows.Devices.Gpio.GpioSharingMode=} sharingMode The mode in which you want to open the GPIO pin, which determines whether other connections to the pin can be opened while you have the pin open.
 * @return {!Windows.Devices.Gpio.GpioPin} The opened GPIO pin.
 */
Windows.Devices.Gpio.GpioController.prototype.openPin = function(pinNumber, sharingMode) {};

/**
 * Opens the specified general-purpose I/O (GPIO) pin in the specified mode, and gets a status value that you can use to handle a failure to open the pin programmatically.
 * @param {number} pinNumber The pin number of the GPIO pin that you want to open. Some pins may not be available in user mode. For information about how the pin numbers correspond to physical pins, see the documentation for your circuit board.
 * @param {Windows.Devices.Gpio.GpioSharingMode} sharingMode The mode in which you want to open the GPIO pin, which determines whether other connections to the pin can be opened while you have the pin open.
 * @return {{pin: !Windows.Devices.Gpio.GpioPin, openStatus: Windows.Devices.Gpio.GpioOpenStatus, returnValue: boolean}}
 */
Windows.Devices.Gpio.GpioController.prototype.tryOpenPin = function(pinNumber, sharingMode) {};

/** @const */
Windows.Devices.Gpio.GpioOpenStatus = {};
/** @const {number} */
Windows.Devices.Gpio.GpioOpenStatus.pinOpened;
/** @const {number} */
Windows.Devices.Gpio.GpioOpenStatus.pinUnavailable;
/** @const {number} */
Windows.Devices.Gpio.GpioOpenStatus.sharingViolation;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Gpio.GpioPin = function() {};
 /** @type {number} */
Windows.Devices.Gpio.GpioPin.prototype.debounceTimeout;
 /** @type {function(?): void} */
Windows.Devices.Gpio.GpioPin.prototype.onvaluechanged;
 /** @type {number} */
Windows.Devices.Gpio.GpioPin.prototype.pinNumber;
 /** @type {Windows.Devices.Gpio.GpioSharingMode} */
Windows.Devices.Gpio.GpioPin.prototype.sharingMode;

/**
 * Closes the general-purpose I/O (GPIO) pin and releases the resources associated with it.
 * @return {void}
 */
Windows.Devices.Gpio.GpioPin.prototype.close = function() {};

/**
 * Gets the current drive mode for the general-purpose I/O (GPIO) pin. The drive mode specifies whether the pin is configured as an input or an output, and determines how values are driven onto the pin.
 * @return {Windows.Devices.Gpio.GpioPinDriveMode} An enumeration value that indicates the current drive mode for the GPIO pin. The drive mode specifies whether the pin is configured as an input or an output, and determines how values are driven onto the pin.
 */
Windows.Devices.Gpio.GpioPin.prototype.getDriveMode = function() {};

/**
 * Gets whether the general-purpose I/O (GPIO) pin supports the specified drive mode.
 * @param {Windows.Devices.Gpio.GpioPinDriveMode} driveMode The drive mode that you want to check for support.
 * @return {boolean} True if the GPIO pin supports the drive mode that driveMode specifies; otherwise false. If you specify a drive mode for which this method returns false when you call SetDriveMode , SetDriveMode generates an exception.
 */
Windows.Devices.Gpio.GpioPin.prototype.isDriveModeSupported = function(driveMode) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Gpio.GpioPin.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Gpio.GpioPin.prototype.removeEventListener = function(type, listener) {};

/**
 * Reads the current value of the general-purpose I/O (GPIO) pin.
 * @return {Windows.Devices.Gpio.GpioPinValue} The current value of the GPIO pin. If the pin is configured as an output, this value is the last value written to the pin.
 */
Windows.Devices.Gpio.GpioPin.prototype.read = function() {};

/**
 * Sets the drive mode of the general-purpose I/O (GPIO) pin. The drive mode specifies whether the pin is configured as an input or an output, and determines how values are driven onto the pin.
 * @param {Windows.Devices.Gpio.GpioPinDriveMode} value An enumeration value that specifies drive mode to use for the GPIO pin. The drive mode specifies whether the pin is configured as an input or an output, and determines how values are driven onto the pin.
 * @return {void}
 */
Windows.Devices.Gpio.GpioPin.prototype.setDriveMode = function(value) {};

/**
 * Drives the specified value onto the general purpose I/O (GPIO) pin according to the current drive mode for the pin if the pin is configured as an output, or updates the latched output value for the pin if the pin is configured as an input.
 * @param {Windows.Devices.Gpio.GpioPinValue} value The enumeration value to write to the GPIO pin.
 * @return {void}
 */
Windows.Devices.Gpio.GpioPin.prototype.write = function(value) {};

/** @const */
Windows.Devices.Gpio.GpioPinDriveMode = {};
/** @const {number} */
Windows.Devices.Gpio.GpioPinDriveMode.input;
/** @const {number} */
Windows.Devices.Gpio.GpioPinDriveMode.output;
/** @const {number} */
Windows.Devices.Gpio.GpioPinDriveMode.inputPullUp;
/** @const {number} */
Windows.Devices.Gpio.GpioPinDriveMode.inputPullDown;
/** @const {number} */
Windows.Devices.Gpio.GpioPinDriveMode.outputOpenDrain;
/** @const {number} */
Windows.Devices.Gpio.GpioPinDriveMode.outputOpenDrainPullUp;
/** @const {number} */
Windows.Devices.Gpio.GpioPinDriveMode.outputOpenSource;
/** @const {number} */
Windows.Devices.Gpio.GpioPinDriveMode.outputOpenSourcePullDown;

/** @const */
Windows.Devices.Gpio.GpioPinEdge = {};
/** @const {number} */
Windows.Devices.Gpio.GpioPinEdge.fallingEdge;
/** @const {number} */
Windows.Devices.Gpio.GpioPinEdge.risingEdge;

/** @const */
Windows.Devices.Gpio.GpioPinValue = {};
/** @const {number} */
Windows.Devices.Gpio.GpioPinValue.low;
/** @const {number} */
Windows.Devices.Gpio.GpioPinValue.high;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Gpio.GpioPinValueChangedEventArgs = function() {};
 /** @type {Windows.Devices.Gpio.GpioPinEdge} */
Windows.Devices.Gpio.GpioPinValueChangedEventArgs.prototype.edge;

/** @const */
Windows.Devices.Gpio.GpioSharingMode = {};
/** @const {number} */
Windows.Devices.Gpio.GpioSharingMode.exclusive;
/** @const {number} */
Windows.Devices.Gpio.GpioSharingMode.sharedReadOnly;
/** @const */
Windows.Devices.Gpio.Provider = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Gpio.Provider.GpioPinProviderValueChangedEventArgs = function() {};
 /** @type {?} */
Windows.Devices.Gpio.Provider.GpioPinProviderValueChangedEventArgs.prototype.edge;
/** @const */
Windows.Devices.Gpio.Provider.ProviderGpioPinDriveMode = {};
 /** @type {?} */
Windows.Devices.Gpio.Provider.ProviderGpioPinDriveMode.input;
 /** @type {?} */
Windows.Devices.Gpio.Provider.ProviderGpioPinDriveMode.output;
 /** @type {?} */
Windows.Devices.Gpio.Provider.ProviderGpioPinDriveMode.inputPullUp;
 /** @type {?} */
Windows.Devices.Gpio.Provider.ProviderGpioPinDriveMode.inputPullDown;
 /** @type {?} */
Windows.Devices.Gpio.Provider.ProviderGpioPinDriveMode.outputOpenDrain;
 /** @type {?} */
Windows.Devices.Gpio.Provider.ProviderGpioPinDriveMode.outputOpenDrainPullUp;
 /** @type {?} */
Windows.Devices.Gpio.Provider.ProviderGpioPinDriveMode.outputOpenSource;
 /** @type {?} */
Windows.Devices.Gpio.Provider.ProviderGpioPinDriveMode.outputOpenSourcePullDown;
/** @const */
Windows.Devices.Gpio.Provider.ProviderGpioPinEdge = {};
 /** @type {?} */
Windows.Devices.Gpio.Provider.ProviderGpioPinEdge.fallingEdge;
 /** @type {?} */
Windows.Devices.Gpio.Provider.ProviderGpioPinEdge.risingEdge;
/** @const */
Windows.Devices.Gpio.Provider.ProviderGpioPinValue = {};
 /** @type {?} */
Windows.Devices.Gpio.Provider.ProviderGpioPinValue.low;
 /** @type {?} */
Windows.Devices.Gpio.Provider.ProviderGpioPinValue.high;
/** @const */
Windows.Devices.Gpio.Provider.ProviderGpioSharingMode = {};
 /** @type {?} */
Windows.Devices.Gpio.Provider.ProviderGpioSharingMode.exclusive;
 /** @type {?} */
Windows.Devices.Gpio.Provider.ProviderGpioSharingMode.sharedReadOnly;
/**
 * @record
 * @struct
 */
Windows.Devices.Gpio.Provider.IGpioProvider = function() {};
 /** @type {?} */
Windows.Devices.Gpio.Provider.IGpioProvider.prototype.getControllers;
/** @const */
Windows.Devices.HumanInterfaceDevice = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.HumanInterfaceDevice.HidBooleanControl = function() {};
 /** @type {!Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription} */
Windows.Devices.HumanInterfaceDevice.HidBooleanControl.prototype.controlDescription;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidBooleanControl.prototype.id;
 /** @type {boolean} */
Windows.Devices.HumanInterfaceDevice.HidBooleanControl.prototype.isActive;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidBooleanControl.prototype.usageId;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidBooleanControl.prototype.usagePage;
/**
 * @constructor
 * @struct
 */
Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription = function() {};
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription.prototype.id;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.HumanInterfaceDevice.HidCollection>} */
Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription.prototype.parentCollections;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription.prototype.reportId;
 /** @type {Windows.Devices.HumanInterfaceDevice.HidReportType} */
Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription.prototype.reportType;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription.prototype.usageId;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription.prototype.usagePage;
/**
 * @constructor
 * @struct
 */
Windows.Devices.HumanInterfaceDevice.HidCollection = function() {};
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidCollection.prototype.id;
 /** @type {Windows.Devices.HumanInterfaceDevice.HidCollectionType} */
Windows.Devices.HumanInterfaceDevice.HidCollection.prototype.type;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidCollection.prototype.usageId;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidCollection.prototype.usagePage;

/** @const */
Windows.Devices.HumanInterfaceDevice.HidCollectionType = {};
/** @const {number} */
Windows.Devices.HumanInterfaceDevice.HidCollectionType.physical;
/** @const {number} */
Windows.Devices.HumanInterfaceDevice.HidCollectionType.application;
/** @const {number} */
Windows.Devices.HumanInterfaceDevice.HidCollectionType.logical;
/** @const {number} */
Windows.Devices.HumanInterfaceDevice.HidCollectionType.report;
/** @const {number} */
Windows.Devices.HumanInterfaceDevice.HidCollectionType.namedArray;
/** @const {number} */
Windows.Devices.HumanInterfaceDevice.HidCollectionType.usageSwitch;
/** @const {number} */
Windows.Devices.HumanInterfaceDevice.HidCollectionType.usageModifier;
/** @const {number} */
Windows.Devices.HumanInterfaceDevice.HidCollectionType.other;
/**
 * @constructor
 * @struct
 */
Windows.Devices.HumanInterfaceDevice.HidDevice = function() {};
 /** @type {function(?): void} */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.oninputreportreceived;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.productId;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.usageId;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.usagePage;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.vendorId;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.version;

/**
 * Opens a handle to the device identified by the deviceId parameter. The acess type is specified by the accessMode parameter.
 * @param {string} deviceId The DeviceInformation ID that identifies the HID device.
 * @param {Windows.Storage.FileAccessMode} accessMode Specifies the access mode. The supported access modes are Read and ReadWrite.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.HumanInterfaceDevice.HidDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.HumanInterfaceDevice.HidDevice>>} A HidDevice object.
 */
Windows.Devices.HumanInterfaceDevice.HidDevice.fromIdAsync = function(deviceId, accessMode) {};

/**
 * Retrieves an Advanced Query Syntax (AQS) string based on the given usagePage and usageId.
 * Retrieves an Advanced Query Syntax (AQS) string based on the given usagePage, usageId, vendorId, and productId.
 * @param {number} usagePage Specifies the usage page of the top-level collection for the given HID device.
 * @param {number} usageId Specifies the usage identifier of the top-level collection for the given HID device.
 * @param {number=} vendorId Identifies the device vendor.
 * @param {number=} productId Identifies the product.
 * @return {string} An Advanced Query Syntax (AQS) string that represents a device selector.
 */
Windows.Devices.HumanInterfaceDevice.HidDevice.getDeviceSelector = function(usagePage, usageId, vendorId, productId) {};

/**
 * Closes the connection between the host and the given HID device.
 * @return {void}
 */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.close = function() {};

/**
 * Creates the only, or default, feature report that the host will send to the device.
 * Creates a feature report, identified by the reportId parameter, that the host will send to the device.
 * @param {number=} reportId Identifies the report being created.
 * @return {!Windows.Devices.HumanInterfaceDevice.HidFeatureReport} A HidFeatureReport object.
 */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.createFeatureReport = function(reportId) {};

/**
 * Creates the only, or default, output report that the host will send to the device.
 * Creates an output report, identified by the reportId parameter, that the host will send to the device.
 * @param {number=} reportId Identifies the report being created.
 * @return {!Windows.Devices.HumanInterfaceDevice.HidOutputReport} A HidOutputReport object.
 */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.createOutputReport = function(reportId) {};

/**
 * Retrieves the descriptions of the boolean controls for the given HID device.
 * @param {Windows.Devices.HumanInterfaceDevice.HidReportType} reportType Specifies the type of report for which the control descriptions are requested.
 * @param {number} usagePage Identifies the usage page associated with the controls.
 * @param {number} usageId Identifies the usage associated with the controls.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription>} A vector of HidBooleanControlDescription objects.
 */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.getBooleanControlDescriptions = function(reportType, usagePage, usageId) {};

/**
 * Asynchronously retrieves a feature report, identified by the reportId parameter, for the given HID device.
 * Asynchronously retrieves the first, or default, feature report from the given HID device.
 * @param {number=} reportId Identifies the requested feature report.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.HumanInterfaceDevice.HidFeatureReport, !Windows.Foundation.IAsyncOperation<!Windows.Devices.HumanInterfaceDevice.HidFeatureReport>>} A HidFeatureReport object.
 */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.getFeatureReportAsync = function(reportId) {};

/**
 * Asynchronously retrieves the default, or first, input report from the given HID device.
 * Asynchronously retrieves an input report, identified by the reportId parameter, from the given HID device.
 * @param {number=} reportId Identifies the requested input report.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.HumanInterfaceDevice.HidInputReport, !Windows.Foundation.IAsyncOperation<!Windows.Devices.HumanInterfaceDevice.HidInputReport>>} A HidInputReport object.
 */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.getInputReportAsync = function(reportId) {};

/**
 * Retrieves the descriptions of the numeric controls for the given HID device.
 * @param {Windows.Devices.HumanInterfaceDevice.HidReportType} reportType Specifies the type of report for which the control descriptions are requested.
 * @param {number} usagePage Identifies the usage page associated with the controls.
 * @param {number} usageId Identifies the usage associated with the controls.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription>} A vector of HidNumericControlDescription objects.
 */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.getNumericControlDescriptions = function(reportType, usagePage, usageId) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.removeEventListener = function(type, listener) {};

/**
 * Sends an feature report asynchronously from the host to the device.
 * @param {!Windows.Devices.HumanInterfaceDevice.HidFeatureReport} featureReport The feature report which the host sends to the device.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} The result of the asynchronous operation.
 */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.sendFeatureReportAsync = function(featureReport) {};

/**
 * Sends an output report asynchronously from the host to the device.
 * @param {!Windows.Devices.HumanInterfaceDevice.HidOutputReport} outputReport The output report which the host sends to the device.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} Specifies the count of bytes written to the device.
 */
Windows.Devices.HumanInterfaceDevice.HidDevice.prototype.sendOutputReportAsync = function(outputReport) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.HumanInterfaceDevice.HidFeatureReport = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.HumanInterfaceDevice.HidFeatureReport.prototype.data;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidFeatureReport.prototype.id;

/**
 * Retrieves the Boolean control associated with the usagePage and usageIdparameter and found in the given feature report.
 * @param {number} usagePage The usage page of the top-level collection for the given HID device.
 * @param {number} usageId The usage identifier of the top-level collection for the given HID device.
 * @return {!Windows.Devices.HumanInterfaceDevice.HidBooleanControl} A HidBooleanControl object.
 */
Windows.Devices.HumanInterfaceDevice.HidFeatureReport.prototype.getBooleanControl = function(usagePage, usageId) {};

/**
 * Retrieves the Boolean control described by the controlDescription parameter and found in the given feature report.
 * @param {!Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription} controlDescription A HidBooleanControlDescription object.
 * @return {!Windows.Devices.HumanInterfaceDevice.HidBooleanControl} A HidBooleanControl object.
 */
Windows.Devices.HumanInterfaceDevice.HidFeatureReport.prototype.getBooleanControlByDescription = function(controlDescription) {};

/**
 * Retrieves the numeric control associated with the usagePage and usageId parameters and found in the given feature report.
 * @param {number} usagePage The usage page of the top-level collection for the given HID device.
 * @param {number} usageId The usage identifier of the top-level collection for the given HID device.
 * @return {!Windows.Devices.HumanInterfaceDevice.HidNumericControl} A HidNumericControl object.
 */
Windows.Devices.HumanInterfaceDevice.HidFeatureReport.prototype.getNumericControl = function(usagePage, usageId) {};

/**
 * Retrieves the numeric control described by the controlDescription parameter and found in the given feature report.
 * @param {!Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription} controlDescription A HidNumericControlDescription object.
 * @return {!Windows.Devices.HumanInterfaceDevice.HidNumericControl} A HidNumericControl object.
 */
Windows.Devices.HumanInterfaceDevice.HidFeatureReport.prototype.getNumericControlByDescription = function(controlDescription) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.HumanInterfaceDevice.HidInputReport = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.HumanInterfaceDevice.HidBooleanControl>} */
Windows.Devices.HumanInterfaceDevice.HidInputReport.prototype.activatedBooleanControls;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.HumanInterfaceDevice.HidInputReport.prototype.data;
 /** @type {?} */
Windows.Devices.HumanInterfaceDevice.HidInputReport.prototype.getBooleanControl;
 /** @type {?} */
Windows.Devices.HumanInterfaceDevice.HidInputReport.prototype.getNumericControl;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidInputReport.prototype.id;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.HumanInterfaceDevice.HidBooleanControl>} */
Windows.Devices.HumanInterfaceDevice.HidInputReport.prototype.transitionedBooleanControls;

/**
 * Retrieves the Boolean control described by the controlDescription parameter and found in the given input report.
 * @param {!Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription} controlDescription A HidBooleanControlDescription object.
 * @return {!Windows.Devices.HumanInterfaceDevice.HidBooleanControl} A HidBooleanControl object.
 */
Windows.Devices.HumanInterfaceDevice.HidInputReport.prototype.getBooleanControlByDescription = function(controlDescription) {};

/**
 * Retrieves the numeric control described by the controlDescription parameter and found in the given input report.
 * @param {!Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription} controlDescription A HidNumericControlDescription object.
 * @return {!Windows.Devices.HumanInterfaceDevice.HidNumericControl} A HidNumericControl object.
 */
Windows.Devices.HumanInterfaceDevice.HidInputReport.prototype.getNumericControlByDescription = function(controlDescription) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.HumanInterfaceDevice.HidInputReportReceivedEventArgs = function() {};
 /** @type {!Windows.Devices.HumanInterfaceDevice.HidInputReport} */
Windows.Devices.HumanInterfaceDevice.HidInputReportReceivedEventArgs.prototype.report;
/**
 * @constructor
 * @struct
 */
Windows.Devices.HumanInterfaceDevice.HidNumericControl = function() {};
 /** @type {!Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription} */
Windows.Devices.HumanInterfaceDevice.HidNumericControl.prototype.controlDescription;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControl.prototype.id;
 /** @type {boolean} */
Windows.Devices.HumanInterfaceDevice.HidNumericControl.prototype.isGrouped;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControl.prototype.scaledValue;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControl.prototype.usageId;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControl.prototype.usagePage;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControl.prototype.value;
/**
 * @constructor
 * @struct
 */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription = function() {};
 /** @type {boolean} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.hasNull;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.id;
 /** @type {boolean} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.isAbsolute;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.logicalMaximum;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.logicalMinimum;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.HumanInterfaceDevice.HidCollection>} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.parentCollections;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.physicalMaximum;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.physicalMinimum;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.reportCount;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.reportId;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.reportSize;
 /** @type {Windows.Devices.HumanInterfaceDevice.HidReportType} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.reportType;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.unit;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.unitExponent;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.usageId;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription.prototype.usagePage;
/**
 * @constructor
 * @struct
 */
Windows.Devices.HumanInterfaceDevice.HidOutputReport = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.HumanInterfaceDevice.HidOutputReport.prototype.data;
 /** @type {?} */
Windows.Devices.HumanInterfaceDevice.HidOutputReport.prototype.getBooleanControl;
 /** @type {?} */
Windows.Devices.HumanInterfaceDevice.HidOutputReport.prototype.getNumericControl;
 /** @type {number} */
Windows.Devices.HumanInterfaceDevice.HidOutputReport.prototype.id;

/**
 * Retrieves the boolean control associated with the given controlDescription.
 * @param {!Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription} controlDescription Describes the Boolean control.
 * @return {!Windows.Devices.HumanInterfaceDevice.HidBooleanControl} A HidBooleanControl object.
 */
Windows.Devices.HumanInterfaceDevice.HidOutputReport.prototype.getBooleanControlByDescription = function(controlDescription) {};

/**
 * Retrieves the numeric control associated with the given controlDescription.
 * @param {!Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription} controlDescription Describes the numeric control.
 * @return {!Windows.Devices.HumanInterfaceDevice.HidNumericControl} A HidNumericControl object.
 */
Windows.Devices.HumanInterfaceDevice.HidOutputReport.prototype.getNumericControlByDescription = function(controlDescription) {};

/** @const */
Windows.Devices.HumanInterfaceDevice.HidReportType = {};
/** @const {number} */
Windows.Devices.HumanInterfaceDevice.HidReportType.input;
/** @const {number} */
Windows.Devices.HumanInterfaceDevice.HidReportType.output;
/** @const {number} */
Windows.Devices.HumanInterfaceDevice.HidReportType.feature;
/** @const */
Windows.Devices.I2c = {};

/** @const */
Windows.Devices.I2c.I2cBusSpeed = {};
/** @const {number} */
Windows.Devices.I2c.I2cBusSpeed.standardMode;
/** @const {number} */
Windows.Devices.I2c.I2cBusSpeed.fastMode;

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the I2cConnectionSettings class for inter-integrated circuit (IC) device with specified bus address, using the default settings of the standard mode for the bus speed and exclusive sharing mode.
 * @param {number} slaveAddress The bus address of the inter-integrated circuit (IC) device to which the settings of the I2cConnectionSettings should apply. Only 7-bit addressing is supported, so the range of values that are valid is from 8 to 119.
 */
Windows.Devices.I2c.I2cConnectionSettings = function(slaveAddress) {};
 /** @type {Windows.Devices.I2c.I2cBusSpeed} */
Windows.Devices.I2c.I2cConnectionSettings.prototype.busSpeed;
 /** @type {Windows.Devices.I2c.I2cSharingMode} */
Windows.Devices.I2c.I2cConnectionSettings.prototype.sharingMode;
 /** @type {number} */
Windows.Devices.I2c.I2cConnectionSettings.prototype.slaveAddress;
/**
 * @constructor
 * @struct
 */
Windows.Devices.I2c.I2cController = function() {};

/**
 * Gets all the IC controllers that are on the system.
 * @param {!Windows.Devices.I2c.Provider.II2cProvider} provider The IC provider for the controllers on the system.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When the method completes successfully, it returns a list of values that represent the available IC controllers on the system.
 */
Windows.Devices.I2c.I2cController.getControllersAsync = function(provider) {};

/**
 * Gets the default IC controller on the system.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.I2c.I2cController, !Windows.Foundation.IAsyncOperation<!Windows.Devices.I2c.I2cController>>} The default IC controller on the system, or null if the system has no IC controller.
 */
Windows.Devices.I2c.I2cController.getDefaultAsync = function() {};

/**
 * Gets the IC device with the specified settings.
 * @param {!Windows.Devices.I2c.I2cConnectionSettings} settings The desired connection settings.
 * @return {!Windows.Devices.I2c.I2cDevice} The IC device.
 */
Windows.Devices.I2c.I2cController.prototype.getDevice = function(settings) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.I2c.I2cDevice = function() {};
 /** @type {!Windows.Devices.I2c.I2cConnectionSettings} */
Windows.Devices.I2c.I2cDevice.prototype.connectionSettings;
 /** @type {string} */
Windows.Devices.I2c.I2cDevice.prototype.deviceId;

/**
 * Retrieves an I2cDevice object asynchronously for the inter-integrated circuit (IC) bus controller that has the specified plug and play device identifier, using the specified connection settings.
 * @param {string} deviceId The plug and play device identifier of the IC bus controller for which you want to create an I2cDevice object.
 * @param {!Windows.Devices.I2c.I2cConnectionSettings} settings The connection settings to use for communication with the IC bus controller that deviceId specifies.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.I2c.I2cDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.I2c.I2cDevice>>} An asynchronous operation that returns the I2cDevice object.
 */
Windows.Devices.I2c.I2cDevice.fromIdAsync = function(deviceId, settings) {};

/**
 * Retrieves an Advanced Query Syntax (AQS) string for the inter-integrated circuit (IC) bus that has the specified friendly name. You can use this string with the DeviceInformation.FindAllAsync method to get a DeviceInformation object for that bus.
 * Retrieves an Advanced Query Syntax (AQS) string for all of the inter-integrated circuit (IC) bus controllers on the system. You can use this string with the DeviceInformation.FindAllAsync method to get DeviceInformation objects for those bus controllers.
 * @param {string=} friendlyName A friendly name for the particular IC bus on a particular hardware platform for which you want to get the AQS string.
 * @return {string} An AQS string for the IC bus that friendlyName specifies, which you can use with the DeviceInformation.FindAllAsync method to get a DeviceInformation object for that bus. / An AQS string for all of the IC bus controllers on the system, which you can use with the DeviceInformation.FindAllAsync method to get DeviceInformation objects for those bus controllers.
 */
Windows.Devices.I2c.I2cDevice.getDeviceSelector = function(friendlyName) {};

/**
 * Closes the connection to the inter-integrated circuit (IC) device.
 * @return {void}
 */
Windows.Devices.I2c.I2cDevice.prototype.close = function() {};

/**
 * Reads data from the inter-integrated circuit (IC) bus on which the device is connected into the specified buffer.
 * @param {!Array<number>} buffer The buffer to which you want to read the data from the IC bus. The length of the buffer determines how much data to request from the device.
 * @return {void}
 */
Windows.Devices.I2c.I2cDevice.prototype.read = function(buffer) {};

/**
 * Reads data from the inter-integrated circuit (IC) bus on which the device is connected into the specified buffer, and returns information about the success of the operation that you can use for error handling.
 * @param {!Array<number>} buffer The buffer to which you want to read the data from the IC bus. The length of the buffer determines how much data to request from the device.
 * @return {!Windows.Devices.I2c.I2cTransferResult} A structure that contains information about the success of the read operation and the actual number of bytes that the operation read into the buffer.
 */
Windows.Devices.I2c.I2cDevice.prototype.readPartial = function(buffer) {};

/**
 * Writes data to the inter-integrated circuit (IC) bus on which the device is connected, based on the bus address specified in the I2cConnectionSetting s object that you used to create the I2cDevice object.
 * @param {!Array<number>} buffer A buffer that contains the data that you want to write to the IC device. This data should not include the bus address.
 * @return {void}
 */
Windows.Devices.I2c.I2cDevice.prototype.write = function(buffer) {};

/**
 * Writes data to the inter-integrated circuit (IC) bus on which the device is connected, and returns information about the success of the operation that you can use for error handling.
 * @param {!Array<number>} buffer A buffer that contains the data that you want to write to the IC device. This data should not include the bus address.
 * @return {!Windows.Devices.I2c.I2cTransferResult} A structure that contains information about the success of the write operation and the actual number of bytes that the operation wrote into the buffer.
 */
Windows.Devices.I2c.I2cDevice.prototype.writePartial = function(buffer) {};

/**
 * Performs an atomic operation to write data to and then read data from the inter-integrated circuit (IC) bus on which the device is connected, and sends a restart condition between the write and read operations.
 * @param {!Array<number>} writeBuffer A buffer that contains the data that you want to write to the IC device. This data should not include the bus address.
 * @param {!Array<number>} readBuffer The buffer to which you want to read the data from the IC bus. The length of the buffer determines how much data to request from the device.
 * @return {void}
 */
Windows.Devices.I2c.I2cDevice.prototype.writeRead = function(writeBuffer, readBuffer) {};

/**
 * Performs an atomic operation to write data to and then read data from the inter-integrated circuit (IC) bus on which the device is connected, and returns information about the success of the operation that you can use for error handling.
 * @param {!Array<number>} writeBuffer A buffer that contains the data that you want to write to the IC device. This data should not include the bus address.
 * @param {!Array<number>} readBuffer The buffer to which you want to read the data from the IC bus. The length of the buffer determines how much data to request from the device.
 * @return {!Windows.Devices.I2c.I2cTransferResult} A structure that contains information about whether both the read and write parts of the operation succeeded and the sum of the actual number of bytes that the operation wrote and the actual number of bytes that the operation read.
 */
Windows.Devices.I2c.I2cDevice.prototype.writeReadPartial = function(writeBuffer, readBuffer) {};

/** @const */
Windows.Devices.I2c.I2cSharingMode = {};
/** @const {number} */
Windows.Devices.I2c.I2cSharingMode.exclusive;
/** @const {number} */
Windows.Devices.I2c.I2cSharingMode.shared;

/** @const */
Windows.Devices.I2c.I2cTransferStatus = {};
/** @const {number} */
Windows.Devices.I2c.I2cTransferStatus.fullTransfer;
/** @const {number} */
Windows.Devices.I2c.I2cTransferStatus.partialTransfer;
/** @const {number} */
Windows.Devices.I2c.I2cTransferStatus.slaveAddressNotAcknowledged;
/** @const */
Windows.Devices.I2c.Provider = {};
/** @const */
Windows.Devices.I2c.Provider.ProviderI2cBusSpeed = {};
 /** @type {?} */
Windows.Devices.I2c.Provider.ProviderI2cBusSpeed.standardMode;
 /** @type {?} */
Windows.Devices.I2c.Provider.ProviderI2cBusSpeed.fastMode;
/**
 * @constructor
 * @struct
 */
Windows.Devices.I2c.Provider.ProviderI2cConnectionSettings = function() {};
 /** @type {?} */
Windows.Devices.I2c.Provider.ProviderI2cConnectionSettings.prototype.busSpeed;
 /** @type {?} */
Windows.Devices.I2c.Provider.ProviderI2cConnectionSettings.prototype.sharingMode;
 /** @type {?} */
Windows.Devices.I2c.Provider.ProviderI2cConnectionSettings.prototype.slaveAddress;
/** @const */
Windows.Devices.I2c.Provider.ProviderI2cSharingMode = {};
 /** @type {?} */
Windows.Devices.I2c.Provider.ProviderI2cSharingMode.exclusive;
 /** @type {?} */
Windows.Devices.I2c.Provider.ProviderI2cSharingMode.shared;
/** @const */
Windows.Devices.I2c.Provider.ProviderI2cTransferStatus = {};
 /** @type {?} */
Windows.Devices.I2c.Provider.ProviderI2cTransferStatus.fullTransfer;
 /** @type {?} */
Windows.Devices.I2c.Provider.ProviderI2cTransferStatus.partialTransfer;
 /** @type {?} */
Windows.Devices.I2c.Provider.ProviderI2cTransferStatus.slaveAddressNotAcknowledged;
/**
 * @record
 * @struct
 */
Windows.Devices.I2c.Provider.II2cProvider = function() {};
 /** @type {?} */
Windows.Devices.I2c.Provider.II2cProvider.prototype.getControllersAsync;
/**
 * @record
 * @struct
 */
Windows.Devices.I2c.I2cTransferResult = function() {};
 /** @type {number} */
Windows.Devices.I2c.I2cTransferResult.prototype.bytesTransferred;
 /** @type {Windows.Devices.I2c.I2cTransferStatus} */
Windows.Devices.I2c.I2cTransferResult.prototype.status;
/** @const */
Windows.Devices.Input = {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the KeyboardCapabilities class.
 */
Windows.Devices.Input.KeyboardCapabilities = function() {};
 /** @type {number} */
Windows.Devices.Input.KeyboardCapabilities.prototype.keyboardPresent;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the MouseCapabilities class.
 */
Windows.Devices.Input.MouseCapabilities = function() {};
 /** @type {number} */
Windows.Devices.Input.MouseCapabilities.prototype.horizontalWheelPresent;
 /** @type {number} */
Windows.Devices.Input.MouseCapabilities.prototype.mousePresent;
 /** @type {number} */
Windows.Devices.Input.MouseCapabilities.prototype.numberOfButtons;
 /** @type {number} */
Windows.Devices.Input.MouseCapabilities.prototype.swapButtons;
 /** @type {number} */
Windows.Devices.Input.MouseCapabilities.prototype.verticalWheelPresent;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Input.MouseDevice = function() {};
 /** @type {function(?): void} */
Windows.Devices.Input.MouseDevice.prototype.onmousemoved;

/**
 * Retrieves the mouse device that is associated with the current view.
 * @return {!Windows.Devices.Input.MouseDevice} The mouse device.
 */
Windows.Devices.Input.MouseDevice.getForCurrentView = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Input.MouseDevice.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Input.MouseDevice.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Input.MouseEventArgs = function() {};
 /** @type {!Windows.Devices.Input.MouseDelta} */
Windows.Devices.Input.MouseEventArgs.prototype.mouseDelta;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Input.PointerDevice = function() {};
 /** @type {boolean} */
Windows.Devices.Input.PointerDevice.prototype.isIntegrated;
 /** @type {number} */
Windows.Devices.Input.PointerDevice.prototype.maxContacts;
 /** @type {?} */
Windows.Devices.Input.PointerDevice.prototype.maxPointersWithZDistance;
 /** @type {!Windows.Foundation.Rect} */
Windows.Devices.Input.PointerDevice.prototype.physicalDeviceRect;
 /** @type {Windows.Devices.Input.PointerDeviceType} */
Windows.Devices.Input.PointerDevice.prototype.pointerDeviceType;
 /** @type {!Windows.Foundation.Rect} */
Windows.Devices.Input.PointerDevice.prototype.screenRect;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Input.PointerDeviceUsage>} */
Windows.Devices.Input.PointerDevice.prototype.supportedUsages;

/**
 * Gets information about the pointer device associated with the specified input pointer ID.
 * @param {number} pointerId The ID of the pointer input.
 * @return {!Windows.Devices.Input.PointerDevice} The PointerDevice object that represents the associated pointer device.
 */
Windows.Devices.Input.PointerDevice.getPointerDevice = function(pointerId) {};

/**
 * Gets information about the pointer devices attached to the system.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Input.PointerDevice>} The collection of PointerDevice objects that represent the pointer devices attached to the system.
 */
Windows.Devices.Input.PointerDevice.getPointerDevices = function() {};

/** @const */
Windows.Devices.Input.PointerDeviceType = {};
/** @const {number} */
Windows.Devices.Input.PointerDeviceType.touch;
/** @const {number} */
Windows.Devices.Input.PointerDeviceType.pen;
/** @const {number} */
Windows.Devices.Input.PointerDeviceType.mouse;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the TouchCapabilities class.
 */
Windows.Devices.Input.TouchCapabilities = function() {};
 /** @type {number} */
Windows.Devices.Input.TouchCapabilities.prototype.contacts;
 /** @type {number} */
Windows.Devices.Input.TouchCapabilities.prototype.touchPresent;
/**
 * @record
 * @struct
 */
Windows.Devices.Input.MouseDelta = function() {};
 /** @type {number} */
Windows.Devices.Input.MouseDelta.prototype.x;
 /** @type {number} */
Windows.Devices.Input.MouseDelta.prototype.y;
/**
 * @record
 * @struct
 */
Windows.Devices.Input.PointerDeviceUsage = function() {};
 /** @type {number} */
Windows.Devices.Input.PointerDeviceUsage.prototype.maxLogical;
 /** @type {number} */
Windows.Devices.Input.PointerDeviceUsage.prototype.maxPhysical;
 /** @type {number} */
Windows.Devices.Input.PointerDeviceUsage.prototype.minLogical;
 /** @type {number} */
Windows.Devices.Input.PointerDeviceUsage.prototype.minPhysical;
 /** @type {number} */
Windows.Devices.Input.PointerDeviceUsage.prototype.physicalMultiplier;
 /** @type {number} */
Windows.Devices.Input.PointerDeviceUsage.prototype.unit;
 /** @type {number} */
Windows.Devices.Input.PointerDeviceUsage.prototype.usage;
 /** @type {number} */
Windows.Devices.Input.PointerDeviceUsage.prototype.usagePage;
/** @const */
Windows.Devices.Lights = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Lights.Lamp = function() {};
 /** @type {number} */
Windows.Devices.Lights.Lamp.prototype.brightnessLevel;
 /** @type {!Windows.UI.Color} */
Windows.Devices.Lights.Lamp.prototype.color;
 /** @type {string} */
Windows.Devices.Lights.Lamp.prototype.deviceId;
 /** @type {boolean} */
Windows.Devices.Lights.Lamp.prototype.isColorSettable;
 /** @type {boolean} */
Windows.Devices.Lights.Lamp.prototype.isEnabled;
 /** @type {function(?): void} */
Windows.Devices.Lights.Lamp.prototype.onavailabilitychanged;

/**
 * Gets a Lamp object representing the lamp device with the specified ID.
 * @param {string} deviceId The ID of the requested lamp device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Lights.Lamp, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Lights.Lamp>>} An asynchronous operation that returns a Lamp object upon successful completion.
 */
Windows.Devices.Lights.Lamp.fromIdAsync = function(deviceId) {};

/**
 * Gets a Lamp object representing the default lamp for the device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Lights.Lamp, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Lights.Lamp>>} An asynchronous operation that returns a Lamp object upon successful completion.
 */
Windows.Devices.Lights.Lamp.getDefaultAsync = function() {};

/**
 * Returns the class selection string that you can use to enumerate lamp devices.
 * @return {string} The class selection string for lamp devices.
 */
Windows.Devices.Lights.Lamp.getDeviceSelector = function() {};

/**
 * Releases the lamp device.
 * @return {void}
 */
Windows.Devices.Lights.Lamp.prototype.close = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Lights.Lamp.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Lights.Lamp.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Lights.LampAvailabilityChangedEventArgs = function() {};
 /** @type {boolean} */
Windows.Devices.Lights.LampAvailabilityChangedEventArgs.prototype.isAvailable;
/**
 * @constructor
 * @struct
 */
Windows.Devices.LowLevelDevicesAggregateProvider = function() {};
 /** @type {?} */
Windows.Devices.LowLevelDevicesAggregateProvider.prototype.adcControllerProvider;
 /** @type {?} */
Windows.Devices.LowLevelDevicesAggregateProvider.prototype.gpioControllerProvider;
 /** @type {?} */
Windows.Devices.LowLevelDevicesAggregateProvider.prototype.i2cControllerProvider;
 /** @type {?} */
Windows.Devices.LowLevelDevicesAggregateProvider.prototype.pwmControllerProvider;
 /** @type {?} */
Windows.Devices.LowLevelDevicesAggregateProvider.prototype.spiControllerProvider;
/**
 * @constructor
 * @struct
 */
Windows.Devices.LowLevelDevicesController = function() {};
 /** @type {?} */
Windows.Devices.LowLevelDevicesController.defaultProvider;
/** @const */
Windows.Devices.Midi = {};

/**
 * @constructor
 * @struct
 * Creates a new MidiActiveSensingMessage object.
 */
Windows.Devices.Midi.MidiActiveSensingMessage = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiActiveSensingMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiActiveSensingMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiActiveSensingMessage.prototype.type;

/**
 * @constructor
 * @struct
 * Creates a new MidiChannelPressureMessage object.
 * @param {number} channel The channel from 0-15 that this message applies to.
 * @param {number} pressure The pressure from 0-127.
 */
Windows.Devices.Midi.MidiChannelPressureMessage = function(channel, pressure) {};
 /** @type {number} */
Windows.Devices.Midi.MidiChannelPressureMessage.prototype.channel;
 /** @type {number} */
Windows.Devices.Midi.MidiChannelPressureMessage.prototype.pressure;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiChannelPressureMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiChannelPressureMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiChannelPressureMessage.prototype.type;

/**
 * @constructor
 * @struct
 * Creates a new MidiContinueMessage object.
 */
Windows.Devices.Midi.MidiContinueMessage = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiContinueMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiContinueMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiContinueMessage.prototype.type;

/**
 * @constructor
 * @struct
 * Creates a new MidiControlChangeMessage object.
 * @param {number} channel The channel from 0-15 that this message applies to.
 * @param {number} controller The controller from 0-127 to receive this message.
 * @param {number} controlValue The value from 0-127 to apply to the controller .
 */
Windows.Devices.Midi.MidiControlChangeMessage = function(channel, controller, controlValue) {};
 /** @type {number} */
Windows.Devices.Midi.MidiControlChangeMessage.prototype.channel;
 /** @type {number} */
Windows.Devices.Midi.MidiControlChangeMessage.prototype.controlValue;
 /** @type {number} */
Windows.Devices.Midi.MidiControlChangeMessage.prototype.controller;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiControlChangeMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiControlChangeMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiControlChangeMessage.prototype.type;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Midi.MidiInPort = function() {};
 /** @type {string} */
Windows.Devices.Midi.MidiInPort.prototype.deviceId;
 /** @type {function(?): void} */
Windows.Devices.Midi.MidiInPort.prototype.onmessagereceived;

/**
 * Creates a MidiInPort object for the specified device.
 * @param {string} deviceId The device ID, which can be obtained by enumerating the devices on the system Windows.Devices.Enumeration.DeviceInformation.FindAllAsync .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Midi.MidiInPort, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Midi.MidiInPort>>} The asynchronous operation. Upon completion, IAsyncOperation.GetResults returns a MidiInPort object.
 */
Windows.Devices.Midi.MidiInPort.fromIdAsync = function(deviceId) {};

/**
 * Gets a query string that can be used to enumerate all MidiInPort objects on the system.
 * @return {string} The query string used to enumerate the MidiInPort objects on the system.
 */
Windows.Devices.Midi.MidiInPort.getDeviceSelector = function() {};

/**
 * Closes the MidiInPort .
 * @return {void}
 */
Windows.Devices.Midi.MidiInPort.prototype.close = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Midi.MidiInPort.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Midi.MidiInPort.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Midi.MidiMessageReceivedEventArgs = function() {};
 /** @type {!Windows.Devices.Midi.IMidiMessage} */
Windows.Devices.Midi.MidiMessageReceivedEventArgs.prototype.message;

/** @const */
Windows.Devices.Midi.MidiMessageType = {};
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.none;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.noteOff;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.noteOn;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.polyphonicKeyPressure;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.controlChange;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.programChange;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.channelPressure;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.pitchBendChange;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.systemExclusive;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.midiTimeCode;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.songPositionPointer;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.songSelect;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.tuneRequest;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.timingClock;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.start;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.continue;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.stop;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.activeSensing;
/** @const {number} */
Windows.Devices.Midi.MidiMessageType.systemReset;

/**
 * @constructor
 * @struct
 * Creates a new MidiNoteOffMessage object.
 * @param {number} channel The channel from 0-15 that this message applies to.
 * @param {number} note The note which is specified as a value from 0-127.
 * @param {number} velocity The velocity which is specified as a value from 0-127.
 */
Windows.Devices.Midi.MidiNoteOffMessage = function(channel, note, velocity) {};
 /** @type {number} */
Windows.Devices.Midi.MidiNoteOffMessage.prototype.channel;
 /** @type {number} */
Windows.Devices.Midi.MidiNoteOffMessage.prototype.note;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiNoteOffMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiNoteOffMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiNoteOffMessage.prototype.type;
 /** @type {number} */
Windows.Devices.Midi.MidiNoteOffMessage.prototype.velocity;

/**
 * @constructor
 * @struct
 * Creates a new MidiNoteOnMessage object.
 * @param {number} channel The channel from 0-15 that this message applies to.
 * @param {number} note The note which is specified as a value from 0-127.
 * @param {number} velocity The velocity which is specified as a value from 0-127.
 */
Windows.Devices.Midi.MidiNoteOnMessage = function(channel, note, velocity) {};
 /** @type {number} */
Windows.Devices.Midi.MidiNoteOnMessage.prototype.channel;
 /** @type {number} */
Windows.Devices.Midi.MidiNoteOnMessage.prototype.note;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiNoteOnMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiNoteOnMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiNoteOnMessage.prototype.type;
 /** @type {number} */
Windows.Devices.Midi.MidiNoteOnMessage.prototype.velocity;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Midi.MidiOutPort = function() {};
 /** @type {string} */
Windows.Devices.Midi.MidiOutPort.prototype.deviceId;

/**
 * Creates a MidiOutPort object for the specified device.
 * @param {string} deviceId The device ID, which can be obtained by enumerating the devices on the system Windows.Devices.Enumeration.DeviceInformation.FindAllAsync .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Midi.IMidiOutPort, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Midi.IMidiOutPort>>} The asynchronous operation. Upon completion, IAsyncOperation.GetResults returns a MidiOutPort object.
 */
Windows.Devices.Midi.MidiOutPort.fromIdAsync = function(deviceId) {};

/**
 * Gets a query string that can be used to enumerate all MidiOutPort objects on the system.
 * @return {string} The query string used to enumerate the MidiOutPort objects on the system.
 */
Windows.Devices.Midi.MidiOutPort.getDeviceSelector = function() {};

/**
 * Closes the MidiOutPort .
 * @return {void}
 */
Windows.Devices.Midi.MidiOutPort.prototype.close = function() {};

/**
 * Send the specified data buffer to the device associated with this MidiOutPort .
 * @param {!Windows.Storage.Streams.IBuffer} midiData The data to send to the device.
 * @return {void}
 */
Windows.Devices.Midi.MidiOutPort.prototype.sendBuffer = function(midiData) {};

/**
 * Send the data in the specified MIDI message to the device associated with this MidiOutPort .
 * @param {!Windows.Devices.Midi.IMidiMessage} midiMessage The MIDI message to send to the device.
 * @return {void}
 */
Windows.Devices.Midi.MidiOutPort.prototype.sendMessage = function(midiMessage) {};

/**
 * @constructor
 * @struct
 * Creates a new MidiPitchBendChangeMessage object.
 * @param {number} channel The channel from 0-15 that this message applies to.
 * @param {number} bend The pitch bend value which is specified as a 14-bit value from 0-16383.
 */
Windows.Devices.Midi.MidiPitchBendChangeMessage = function(channel, bend) {};
 /** @type {number} */
Windows.Devices.Midi.MidiPitchBendChangeMessage.prototype.bend;
 /** @type {number} */
Windows.Devices.Midi.MidiPitchBendChangeMessage.prototype.channel;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiPitchBendChangeMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiPitchBendChangeMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiPitchBendChangeMessage.prototype.type;

/**
 * @constructor
 * @struct
 * Creates a new MidiPolyphonicKeyPressureMessage object.
 * @param {number} channel The channel from 0-15 that this message applies to.
 * @param {number} note The note which is specified as a value from 0-127.
 * @param {number} pressure The polyphonic key pressure which is specified as a value from 0-127.
 */
Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage = function(channel, note, pressure) {};
 /** @type {number} */
Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage.prototype.channel;
 /** @type {number} */
Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage.prototype.note;
 /** @type {number} */
Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage.prototype.pressure;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage.prototype.type;

/**
 * @constructor
 * @struct
 * Creates a new MidiProgramChangeMessage object.
 * @param {number} channel The channel from 0-15 that this message applies to.
 * @param {number} program The program to change from 0-127.
 */
Windows.Devices.Midi.MidiProgramChangeMessage = function(channel, program) {};
 /** @type {number} */
Windows.Devices.Midi.MidiProgramChangeMessage.prototype.channel;
 /** @type {number} */
Windows.Devices.Midi.MidiProgramChangeMessage.prototype.program;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiProgramChangeMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiProgramChangeMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiProgramChangeMessage.prototype.type;

/**
 * @constructor
 * @struct
 * Creates a new MidiSongPositionPointerMessage object.
 * @param {number} beats The song position pointer encoded in a 14-bit value from 0-16383.
 */
Windows.Devices.Midi.MidiSongPositionPointerMessage = function(beats) {};
 /** @type {number} */
Windows.Devices.Midi.MidiSongPositionPointerMessage.prototype.beats;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiSongPositionPointerMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiSongPositionPointerMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiSongPositionPointerMessage.prototype.type;

/**
 * @constructor
 * @struct
 * Creates a new MidiSongSelectMessage object.
 * @param {number} song The song to select from 0-127.
 */
Windows.Devices.Midi.MidiSongSelectMessage = function(song) {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiSongSelectMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiSongSelectMessage.prototype.song;
 /** @type {number} */
Windows.Devices.Midi.MidiSongSelectMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiSongSelectMessage.prototype.type;

/**
 * @constructor
 * @struct
 * Creates a new MidiStartMessage object.
 */
Windows.Devices.Midi.MidiStartMessage = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiStartMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiStartMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiStartMessage.prototype.type;

/**
 * @constructor
 * @struct
 * Creates a new MidiStopMessage object.
 */
Windows.Devices.Midi.MidiStopMessage = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiStopMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiStopMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiStopMessage.prototype.type;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Midi.MidiSynthesizer = function() {};
 /** @type {!Windows.Devices.Enumeration.DeviceInformation} */
Windows.Devices.Midi.MidiSynthesizer.prototype.audioDevice;
 /** @type {string} */
Windows.Devices.Midi.MidiSynthesizer.prototype.deviceId;
 /** @type {number} */
Windows.Devices.Midi.MidiSynthesizer.prototype.volume;

/**
 * Creates a new instance of the Microsoft MIDI synthesizer with a specified audio output device.
 * Creates a new instance of the Microsoft MIDI synthesizer that uses the system's default audio output device.
 * @param {!Windows.Devices.Enumeration.DeviceInformation=} audioDevice The audio output device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Midi.MidiSynthesizer, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Midi.MidiSynthesizer>>} An instance of the Microsoft MIDI synthesizer. / An instance of the Windows MIDI synthesizer.
 */
Windows.Devices.Midi.MidiSynthesizer.createAsync = function(audioDevice) {};

/**
 * Determines whether a particular device is an instance of the Microsoft MIDI synthesizer. When all MIDI out ports on the system are enumerated, this method can be used to identify which of them is the Microsoft MIDI synthesizer.
 * @param {!Windows.Devices.Enumeration.DeviceInformation} midiDevice An object that represents the device in question.
 * @return {boolean} True if the device is the Microsoft MIDI synthesizer; otherwise, false.
 */
Windows.Devices.Midi.MidiSynthesizer.isSynthesizer = function(midiDevice) {};

/**
 * Closes this instance of the Microsoft MIDI synthesizer. It is a best practice for the caller to use this method to clear resources used by the MIDI object.
 * @return {void}
 */
Windows.Devices.Midi.MidiSynthesizer.prototype.close = function() {};

/**
 * Sends an array of bytes through the synthesizer's out port . This enables you to send your data as a byte array instead of as a defined MIDI message.
 * @param {!Windows.Storage.Streams.IBuffer} midiData The array of bytes to send.
 * @return {void}
 */
Windows.Devices.Midi.MidiSynthesizer.prototype.sendBuffer = function(midiData) {};

/**
 * Sends a MIDI message through the Microsoft MIDI synthesizer's out port .
 * @param {!Windows.Devices.Midi.IMidiMessage} midiMessage The MIDI message to send.
 * @return {void}
 */
Windows.Devices.Midi.MidiSynthesizer.prototype.sendMessage = function(midiMessage) {};

/**
 * @constructor
 * @struct
 * Creates a new MidiSystemExclusiveMessage object.
 * @param {!Windows.Storage.Streams.IBuffer} rawData The system exclusive data.
 */
Windows.Devices.Midi.MidiSystemExclusiveMessage = function(rawData) {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiSystemExclusiveMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiSystemExclusiveMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiSystemExclusiveMessage.prototype.type;

/**
 * @constructor
 * @struct
 * Creates a new MidiSystemResetMessage object.
 */
Windows.Devices.Midi.MidiSystemResetMessage = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiSystemResetMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiSystemResetMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiSystemResetMessage.prototype.type;

/**
 * @constructor
 * @struct
 * Creates a new MidiTimeCodeMessage object.
 * @param {number} frameType The frame type from 0-7.
 * @param {number} values The time code from 0-32.
 */
Windows.Devices.Midi.MidiTimeCodeMessage = function(frameType, values) {};
 /** @type {number} */
Windows.Devices.Midi.MidiTimeCodeMessage.prototype.frameType;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiTimeCodeMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiTimeCodeMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiTimeCodeMessage.prototype.type;
 /** @type {number} */
Windows.Devices.Midi.MidiTimeCodeMessage.prototype.values;

/**
 * @constructor
 * @struct
 * Creates a new MidiTimingClockMessage object.
 */
Windows.Devices.Midi.MidiTimingClockMessage = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiTimingClockMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiTimingClockMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiTimingClockMessage.prototype.type;

/**
 * @constructor
 * @struct
 * Creates a new MidiTuneRequestMessage object.
 */
Windows.Devices.Midi.MidiTuneRequestMessage = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.MidiTuneRequestMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.MidiTuneRequestMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.MidiTuneRequestMessage.prototype.type;
/**
 * @record
 * @struct
 */
Windows.Devices.Midi.IMidiMessage = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Midi.IMidiMessage.prototype.rawData;
 /** @type {number} */
Windows.Devices.Midi.IMidiMessage.prototype.timestamp;
 /** @type {Windows.Devices.Midi.MidiMessageType} */
Windows.Devices.Midi.IMidiMessage.prototype.type;
/**
 * @extends {Windows.Foundation.IClosable}
 * @record
 * @struct
 */
Windows.Devices.Midi.IMidiOutPort = function() {};
 /** @type {string} */
Windows.Devices.Midi.IMidiOutPort.prototype.deviceId;

/**
 * Sends the contents of the buffer through the MIDI out port.
 * @param {!Windows.Storage.Streams.IBuffer} midiData The data to send to the device.
 * @return {void}
 */
Windows.Devices.Midi.IMidiOutPort.prototype.sendBuffer = function(midiData) {};

/**
 * Send the data in the specified MIDI message to the device associated with this MidiOutPort .
 * @param {!Windows.Devices.Midi.IMidiMessage} midiMessage The MIDI message to send to the device.
 * @return {void}
 */
Windows.Devices.Midi.IMidiOutPort.prototype.sendMessage = function(midiMessage) {};
/** @const */
Windows.Devices.Perception = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.KnownCameraIntrinsicsProperties = function() {};
 /** @type {string} */
Windows.Devices.Perception.KnownCameraIntrinsicsProperties.focalLength;
 /** @type {string} */
Windows.Devices.Perception.KnownCameraIntrinsicsProperties.principalPoint;
 /** @type {string} */
Windows.Devices.Perception.KnownCameraIntrinsicsProperties.radialDistortion;
 /** @type {string} */
Windows.Devices.Perception.KnownCameraIntrinsicsProperties.tangentialDistortion;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.KnownPerceptionColorFrameSourceProperties = function() {};
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionColorFrameSourceProperties.autoExposureEnabled;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionColorFrameSourceProperties.exposure;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionColorFrameSourceProperties.exposureCompensation;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.KnownPerceptionDepthFrameSourceProperties = function() {};
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionDepthFrameSourceProperties.maxDepth;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionDepthFrameSourceProperties.minDepth;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.KnownPerceptionFrameSourceProperties = function() {};
 /** @type {?} */
Windows.Devices.Perception.KnownPerceptionFrameSourceProperties.deviceId;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionFrameSourceProperties.deviceModelVersion;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionFrameSourceProperties.enclosureLocation;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionFrameSourceProperties.frameKind;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionFrameSourceProperties.id;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionFrameSourceProperties.physicalDeviceIds;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties = function() {};
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties.activeIlluminationEnabled;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties.ambientSubtractionEnabled;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties.autoExposureEnabled;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties.exposure;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties.exposureCompensation;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties.interleavedIlluminationEnabled;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties.structureLightPatternEnabled;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties = function() {};
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties.availableVideoProfiles;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties.cameraIntrinsics;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties.isMirrored;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties.supportedVideoProfiles;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties.videoProfile;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.KnownPerceptionVideoProfileProperties = function() {};
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionVideoProfileProperties.bitmapAlphaMode;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionVideoProfileProperties.bitmapPixelFormat;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionVideoProfileProperties.frameDuration;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionVideoProfileProperties.height;
 /** @type {string} */
Windows.Devices.Perception.KnownPerceptionVideoProfileProperties.width;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionColorFrame = function() {};
 /** @type {!Windows.Media.VideoFrame} */
Windows.Devices.Perception.PerceptionColorFrame.prototype.videoFrame;

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 * @return {void}
 */
Windows.Devices.Perception.PerceptionColorFrame.prototype.close = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionColorFrameArrivedEventArgs = function() {};
 /** @type {number} */
Windows.Devices.Perception.PerceptionColorFrameArrivedEventArgs.prototype.relativeTime;

/**
 * Attempts to open the color frame that has arrived.
 * @return {!Windows.Devices.Perception.PerceptionColorFrame} If the attempt is successful, this method returns the newly-arrived color frame. If the attempt is unsuccessful, this value is unchanged.
 */
Windows.Devices.Perception.PerceptionColorFrameArrivedEventArgs.prototype.tryOpenFrame = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionColorFrameReader = function() {};
 /** @type {boolean} */
Windows.Devices.Perception.PerceptionColorFrameReader.prototype.isPaused;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionColorFrameReader.prototype.onframearrived;
 /** @type {!Windows.Devices.Perception.PerceptionColorFrameSource} */
Windows.Devices.Perception.PerceptionColorFrameReader.prototype.source;

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 * @return {void}
 */
Windows.Devices.Perception.PerceptionColorFrameReader.prototype.close = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionColorFrameReader.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionColorFrameReader.prototype.removeEventListener = function(type, listener) {};

/**
 * Attempts to read the most recent frame that is available to this color frame reader.
 * @return {!Windows.Devices.Perception.PerceptionColorFrame} If the attempt was successful, this method returns the most recent frame that is available to this color frame reader. If the attempt was not successful, this method returns null.
 */
Windows.Devices.Perception.PerceptionColorFrameReader.prototype.tryReadLatestFrame = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionColorFrameSource = function() {};
 /** @type {boolean} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.active;
 /** @type {boolean} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.available;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Perception.PerceptionVideoProfile>} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.availableVideoProfiles;
 /** @type {!Windows.Media.Devices.Core.CameraIntrinsics} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.cameraIntrinsics;
 /** @type {?} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.deviceId;
 /** @type {string} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.deviceKind;
 /** @type {string} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.displayName;
 /** @type {string} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.id;
 /** @type {boolean} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.isControlled;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.onactivechanged;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.onavailablechanged;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.oncameraintrinsicschanged;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.onpropertieschanged;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.onvideoprofilechanged;
 /** @type {!Windows.Foundation.Collections.IMapView<string, ?>} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.properties;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Perception.PerceptionVideoProfile>} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.supportedVideoProfiles;
 /** @type {!Windows.Devices.Perception.PerceptionVideoProfile} */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.videoProfile;

/**
 * Creates a new color frame source watcher.
 * @return {!Windows.Devices.Perception.PerceptionColorFrameSourceWatcher} A new color frame source watcher.
 */
Windows.Devices.Perception.PerceptionColorFrameSource.createWatcher = function() {};

/**
 * Finds all color frame sources.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When the method completes, it asynchronously returns a list of color frame sources.
 */
Windows.Devices.Perception.PerceptionColorFrameSource.findAllAsync = function() {};

/**
 * Finds an color frame source by looking up its unique ID.
 * @param {string} id The unique ID of the color frame source.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Perception.PerceptionColorFrameSource, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Perception.PerceptionColorFrameSource>>} When this method completes, it asynchronously returns a color frame source if one exists with the specified ID. Otherwise, this method asynchronously returns null.
 */
Windows.Devices.Perception.PerceptionColorFrameSource.fromIdAsync = function(id) {};

/**
 * Requests access to use color frame sources.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Devices.Perception.PerceptionFrameSourceAccessStatus, !Windows.Foundation.IAsyncOperation<Windows.Devices.Perception.PerceptionFrameSourceAccessStatus>>} When this method completes, it asynchronously returns a PerceptionFrameSourceAccessStatus indicating the result of the access request.
 */
Windows.Devices.Perception.PerceptionColorFrameSource.requestAccessAsync = function() {};

/**
 * Attempts to acquire Controller Mode on the color frame source.
 * @return {!Windows.Devices.Perception.PerceptionControlSession} If the attempt is successful, this returns a PerceptionControlSession object that can be used to control properties of the color frame source. Otherwise, this returns null.
 */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.acquireControlSession = function() {};

/**
 * This method returns a boolean value indicating whether or not the color frame source can be controlled separately from another frame source.
 * @param {string} targetId A string representing the unique ID of the other frame source.
 * @return {boolean} Returns true if the two sources can be controlled independently of one another, otherwise returns false.
 */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.canControlIndependentlyFrom = function(targetId) {};

/**
 * Checks whether or not the color frame source is correlated with the target entity. If the result is true, a transform matrix can be retrieved to change coordinate basis from this color frame source to the entity, or vice versa.
 * @param {string} targetId The unique ID of the target entity.
 * @return {boolean} Returns true if a correlation exists, otherwise returns false.
 */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.isCorrelatedWith = function(targetId) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.removeEventListener = function(type, listener) {};

/**
 * Gets a frame reader that reads frames from this color frame source.
 * @return {!Windows.Devices.Perception.PerceptionColorFrameReader} Returns a frame reader that reads frames from this color frame source.
 */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.openReader = function() {};

/**
 * Attempts to get the intrinsic properties of the depth camera that is correlated with this color source.
 * @param {!Windows.Devices.Perception.PerceptionDepthFrameSource} correlatedDepthFrameSource The depth frame source to try to get intrinsic properties of.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics>>} If the attempt is successful, this will return a read-only collection of PerceptionDepthCorrelatedCameraIntrinsics objects specifying the intrinsic properties of the camera used by the correlated depth frame source. Otherwise, this returns null.
 */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.tryGetDepthCorrelatedCameraIntrinsicsAsync = function(correlatedDepthFrameSource) {};

/**
 * Attempts to get a coordinate mapper that maps from color frame image space to depth frame space.
 * @param {string} targetSourceId The unique ID of the depth frame source to try to map to.
 * @param {!Windows.Devices.Perception.PerceptionDepthFrameSource} correlatedDepthFrameSource The depth frame source to try to map to. This should be in a correlation group with the color frame source.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper>>} If the two sources are correlated, this method returns a PerceptionDepthCorrelatedCoordinateMapper. Otherwise, it returns null. This method returns asynchronously.
 */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.tryGetDepthCorrelatedCoordinateMapperAsync = function(targetSourceId, correlatedDepthFrameSource) {};

/**
 * This method returns the transform from the color frame source to the target entity and sets hasResult to true, if a correlation exists. If a correlation does not exist, hasResult is set to false and result is not modified.
 * @param {string} targetId The unique ID of the target entity.
 * @return {{result: !Windows.Foundation.Numerics.Matrix4x4, returnValue: boolean}}
 */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.tryGetTransformTo = function(targetId) {};

/**
 * Attempts to set a video profile on this color frame source. Requires an active Controller Mode control session on this frame source.
 * @param {!Windows.Devices.Perception.PerceptionControlSession} controlSession A PerceptionControlSession representing active control of this frame source.
 * @param {!Windows.Devices.Perception.PerceptionVideoProfile} profile The video profile to set.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult>>} This method returns an PerceptionFrameSourcePropertyChangeResult object asynchonously. If the control session was still active when the video profile was set, and if the video profile is supported and can be activated, this will be a result that indicates success.
 */
Windows.Devices.Perception.PerceptionColorFrameSource.prototype.trySetVideoProfileAsync = function(controlSession, profile) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionColorFrameSourceAddedEventArgs = function() {};
 /** @type {!Windows.Devices.Perception.PerceptionColorFrameSource} */
Windows.Devices.Perception.PerceptionColorFrameSourceAddedEventArgs.prototype.frameSource;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionColorFrameSourceRemovedEventArgs = function() {};
 /** @type {!Windows.Devices.Perception.PerceptionColorFrameSource} */
Windows.Devices.Perception.PerceptionColorFrameSourceRemovedEventArgs.prototype.frameSource;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionColorFrameSourceWatcher = function() {};
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionColorFrameSourceWatcher.prototype.onenumerationcompleted;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionColorFrameSourceWatcher.prototype.onsourceadded;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionColorFrameSourceWatcher.prototype.onsourceremoved;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionColorFrameSourceWatcher.prototype.onstopped;
 /** @type {Windows.Devices.Enumeration.DeviceWatcherStatus} */
Windows.Devices.Perception.PerceptionColorFrameSourceWatcher.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionColorFrameSourceWatcher.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionColorFrameSourceWatcher.prototype.removeEventListener = function(type, listener) {};

/**
 * When this method is called, the color frame source watcher enumerates any existing color frame sources it has not already enumerated by firing a SourceAdded event for each one. An EnumerationCompleted event is fired when this enumeration is complete. The color frame source then starts watching for new color frame sources.
 * @return {void}
 */
Windows.Devices.Perception.PerceptionColorFrameSourceWatcher.prototype.start = function() {};

/**
 * When this method is called, the color frame source watcher stops looking for changes to the color frame source list. This operation is not immediate; the Stopped event will be triggered when the Stop operation is complete.
 * @return {void}
 */
Windows.Devices.Perception.PerceptionColorFrameSourceWatcher.prototype.stop = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionControlSession = function() {};
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionControlSession.prototype.oncontrollost;

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 * @return {void}
 */
Windows.Devices.Perception.PerceptionControlSession.prototype.close = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionControlSession.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionControlSession.prototype.removeEventListener = function(type, listener) {};

/**
 * Creates a property change request. This request is asynchronously processed, and is not guaranteed to succeed. The property change result should be inspected to determine if the property change was actually accepted and, if it was not, the reason why the property change was not accepted.
 * @param {string} name The name of the property to change.
 * @param {?} value The new property value.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult>>} This method asynchronously returns the result of the property change request.
 */
Windows.Devices.Perception.PerceptionControlSession.prototype.trySetPropertyAsync = function(name, value) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics = function() {};

/**
 * Unprojects all pixels in an image from camera image space out into the coordinate frame of the camera device, using the corresponding depth values from a correlated depth camera.
 * @param {!Windows.Devices.Perception.PerceptionDepthFrame} depthFrame The depth frame containing the depth value to use when projecting the points into camera space. The coordinates of each pixel in the image will be mapped from camera image space to depth image space, and then used to look up the depth in this depth frame.
 * @return {{results: !Windows.Foundation.Numerics.Vector3, returnValue: !Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>}}
 */
Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics.prototype.unprojectAllPixelsAtCorrelatedDepthAsync = function(depthFrame) {};

/**
 * Unprojects a point in camera image space out into the coordinate frame of the camera device, using the corresponding depth from a correlated depth camera.
 * @param {!Windows.Foundation.Point} pixelCoordinate A point, relative to the camera frame.
 * @param {!Windows.Devices.Perception.PerceptionDepthFrame} depthFrame The depth frame containing the depth value to use when projecting the point into camera space. The pixelCoordinate will be mapped from camera image space to depth image space, and then used to look up the depth in depthFrame.
 * @return {!Windows.Foundation.Numerics.Vector3} An unprojected coordinate, relative to the coordinate system of the camera device. The coordinate is located in front of the camera, at the depth of the corresponding pixel in depthFrame.
 */
Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics.prototype.unprojectPixelAtCorrelatedDepth = function(pixelCoordinate, depthFrame) {};

/**
 * Unprojects a set of points in camera image space out into the coordinate frame of the camera device, using the corresponding depth values from a correlated depth camera.
 * @param {!Windows.Foundation.Point} sourceCoordinates A set of points, relative to the camera frame.
 * @param {!Windows.Devices.Perception.PerceptionDepthFrame} depthFrame The depth frame containing the depth value to use when projecting the points into camera space. The pixelCoordinate will be mapped from camera image space to depth image space, and then used to look up the depth in depthFrame.
 * @return {!Windows.Foundation.Numerics.Vector3} A set of coordinates, relative to the coordinate system of the camera device and with correlated depth values.
 */
Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics.prototype.unprojectPixelsAtCorrelatedDepth = function(sourceCoordinates, depthFrame) {};

/**
 * Unprojects a region of pixels in an image from camera image space out into the coordinate frame of the camera device, using the corresponding depth values from a correlated depth camera.
 * @param {!Windows.Foundation.Rect} region The region of pixels to project from camera image space out into the coordinate frame of the camera device.
 * @param {!Windows.Devices.Perception.PerceptionDepthFrame} depthFrame The depth frame containing the depth value to use when projecting the points into camera space. The pixelCoordinates will be mapped from camera image space to depth image space, and then used to look up the depth in depthFrame.
 * @return {{results: !Windows.Foundation.Numerics.Vector3, returnValue: !Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>}}
 */
Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics.prototype.unprojectRegionPixelsAtCorrelatedDepthAsync = function(region, depthFrame) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper = function() {};

/**
 * Maps all pixels in an image from camera image space to depth image space.
 * @param {!Windows.Devices.Perception.PerceptionDepthFrame} depthFrame The depth frame to map the pixels to.
 * @return {{targetCoordinates: !Windows.Foundation.Point, returnValue: !Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>}}
 */
Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper.prototype.mapAllPixelsToTargetAsync = function(depthFrame) {};

/**
 * Maps a pixel from camera image space to depth image space.
 * @param {!Windows.Foundation.Point} sourcePixelCoordinate A pixel coordinate, in camera image space.
 * @param {!Windows.Devices.Perception.PerceptionDepthFrame} depthFrame The depth frame to map the pixel to.
 * @return {!Windows.Foundation.Point} Returns the mapping of the pixel coordinate to depth image space.
 */
Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper.prototype.mapPixelToTarget = function(sourcePixelCoordinate, depthFrame) {};

/**
 * Maps a set of pixels from camera image space to depth image space.
 * @param {!Windows.Foundation.Point} sourceCoordinates A set of pixel coordinates, in camera image space.
 * @param {!Windows.Devices.Perception.PerceptionDepthFrame} depthFrame The depth frame to map the pixels to.
 * @return {!Windows.Foundation.Point} The mapping of the pixel coordinate to depth image space.
 */
Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper.prototype.mapPixelsToTarget = function(sourceCoordinates, depthFrame) {};

/**
 * Maps a region of pixels from camera image space to depth image space.
 * @param {!Windows.Foundation.Rect} region The region of pixels to map from camera image space to depth image space.
 * @param {!Windows.Devices.Perception.PerceptionDepthFrame} depthFrame The depth frame to map the region of pixels to.
 * @return {{targetCoordinates: !Windows.Foundation.Point, returnValue: !Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>}}
 */
Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper.prototype.mapRegionOfPixelsToTargetAsync = function(region, depthFrame) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionDepthFrame = function() {};
 /** @type {!Windows.Media.VideoFrame} */
Windows.Devices.Perception.PerceptionDepthFrame.prototype.videoFrame;

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 * @return {void}
 */
Windows.Devices.Perception.PerceptionDepthFrame.prototype.close = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionDepthFrameArrivedEventArgs = function() {};
 /** @type {number} */
Windows.Devices.Perception.PerceptionDepthFrameArrivedEventArgs.prototype.relativeTime;

/**
 * Attempts to open the depth frame that has arrived. Existing frames should be closed before opening new frames. If an app has three or more frames still open when this method is called, TryOpenFrame will fail.
 * @return {!Windows.Devices.Perception.PerceptionDepthFrame} If the attempt is successful, this method returns the newly-arrived depth frame. If the attempt is unsuccessful, this value is unchanged.
 */
Windows.Devices.Perception.PerceptionDepthFrameArrivedEventArgs.prototype.tryOpenFrame = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionDepthFrameReader = function() {};
 /** @type {boolean} */
Windows.Devices.Perception.PerceptionDepthFrameReader.prototype.isPaused;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionDepthFrameReader.prototype.onframearrived;
 /** @type {!Windows.Devices.Perception.PerceptionDepthFrameSource} */
Windows.Devices.Perception.PerceptionDepthFrameReader.prototype.source;

/**
 * Releases system resources that are exposed by a Windows Runtime object
 * @return {void}
 */
Windows.Devices.Perception.PerceptionDepthFrameReader.prototype.close = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionDepthFrameReader.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionDepthFrameReader.prototype.removeEventListener = function(type, listener) {};

/**
 * Attempts to read the most recent frame that is available to this depth frame reader.
 * @return {!Windows.Devices.Perception.PerceptionDepthFrame} If the attempt was successful, this method returns the most recent frame that is available to this depth frame reader. If the attempt was not successful, this method returns null.
 */
Windows.Devices.Perception.PerceptionDepthFrameReader.prototype.tryReadLatestFrame = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionDepthFrameSource = function() {};
 /** @type {boolean} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.active;
 /** @type {boolean} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.available;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Perception.PerceptionVideoProfile>} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.availableVideoProfiles;
 /** @type {!Windows.Media.Devices.Core.CameraIntrinsics} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.cameraIntrinsics;
 /** @type {?} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.deviceId;
 /** @type {string} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.deviceKind;
 /** @type {string} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.displayName;
 /** @type {string} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.id;
 /** @type {boolean} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.isControlled;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.onactivechanged;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.onavailablechanged;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.oncameraintrinsicschanged;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.onpropertieschanged;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.onvideoprofilechanged;
 /** @type {!Windows.Foundation.Collections.IMapView<string, ?>} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.properties;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Perception.PerceptionVideoProfile>} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.supportedVideoProfiles;
 /** @type {!Windows.Devices.Perception.PerceptionVideoProfile} */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.videoProfile;

/**
 * Creates a new depth frame source watcher.
 * @return {!Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher} A new depth frame source watcher.
 */
Windows.Devices.Perception.PerceptionDepthFrameSource.createWatcher = function() {};

/**
 * Finds all depth frame sources.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When the method completes, it asynchronously returns a list of depth frame sources.
 */
Windows.Devices.Perception.PerceptionDepthFrameSource.findAllAsync = function() {};

/**
 * Finds an depth frame source by looking up its unique ID.
 * @param {string} id The unique ID of the depth frame source.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Perception.PerceptionDepthFrameSource, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Perception.PerceptionDepthFrameSource>>} When this method completes, it asynchronously returns a depth frame source if one exists with the specified ID. Otherwise, this method asynchronously returns null.
 */
Windows.Devices.Perception.PerceptionDepthFrameSource.fromIdAsync = function(id) {};

/**
 * Requests access to use depth frame sources.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Devices.Perception.PerceptionFrameSourceAccessStatus, !Windows.Foundation.IAsyncOperation<Windows.Devices.Perception.PerceptionFrameSourceAccessStatus>>} When this method completes, it asynchronously returns a PerceptionFrameSourceAccessStatus indicating the result of the access request.
 */
Windows.Devices.Perception.PerceptionDepthFrameSource.requestAccessAsync = function() {};

/**
 * Attempts to acquire Controller Mode on the depth frame source.
 * @return {!Windows.Devices.Perception.PerceptionControlSession} If the attempt is successful, this returns a PerceptionControlSession object that can be used to control properties of the depth frame source. Otherwise, this returns null.
 */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.acquireControlSession = function() {};

/**
 * This method returns a boolean value indicating whether or not the depth frame source can be controlled separately from another frame source.
 * @param {string} targetId A string representing the unique ID of the other frame source.
 * @return {boolean} True if the two sources can be controlled independently of one another; otherwise, false.
 */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.canControlIndependentlyFrom = function(targetId) {};

/**
 * Checks whether or not the depth frame source is correlated with the target entity. If the result is true, a transform matrix can be retrieved to change coordinate basis from this depth frame source to the entity, or vice versa.
 * @param {string} targetId The unique ID of the target entity.
 * @return {boolean} True if a correlation exists, otherwise false.
 */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.isCorrelatedWith = function(targetId) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.removeEventListener = function(type, listener) {};

/**
 * Gets a frame reader that reads frames from this depth frame source.
 * @return {!Windows.Devices.Perception.PerceptionDepthFrameReader} A frame reader that reads frames from this depth frame source.
 */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.openReader = function() {};

/**
 * Attempts to get the intrinsic properties of the depth camera that is correlated with this depth source.
 * @param {!Windows.Devices.Perception.PerceptionDepthFrameSource} target The depth frame source to try to get intrinsic properties of.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics>>} If the attempt is successful, this returns a read-only collection of PerceptionDepthCorrelatedCameraIntrinsics objects specifying the intrinsic properties of the camera used by the correlated depth frame source. Otherwise, this returns null.
 */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.tryGetDepthCorrelatedCameraIntrinsicsAsync = function(target) {};

/**
 * Attempts to get a coordinate mapper that maps from depth frame image space to depth frame space.
 * @param {string} targetId The unique ID of the depth frame source to try to map to.
 * @param {!Windows.Devices.Perception.PerceptionDepthFrameSource} depthFrameSourceToMapWith The depth frame source to try to map to. This should be in a correlation group with the depth frame source.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper>>} If the two sources are correlated, this method returns a PerceptionDepthCorrelatedCoordinateMapper. Otherwise, it returns null. This method returns asynchronously.
 */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.tryGetDepthCorrelatedCoordinateMapperAsync = function(targetId, depthFrameSourceToMapWith) {};

/**
 * Gets the transform from the depth frame source to the target entity and sets hasResult to true, if a correlation exists. If a correlation does not exist, hasResult is set to false and result is not modified.
 * @param {string} targetId The unique ID of the target entity.
 * @return {{result: !Windows.Foundation.Numerics.Matrix4x4, returnValue: boolean}}
 */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.tryGetTransformTo = function(targetId) {};

/**
 * Attempts to set a video profile on this depth frame source. Requires an active Controller Mode control session on this frame source.
 * @param {!Windows.Devices.Perception.PerceptionControlSession} controlSession A PerceptionControlSession representing active control of this frame source.
 * @param {!Windows.Devices.Perception.PerceptionVideoProfile} profile The video profile to set.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult>>} This method returns an PerceptionFrameSourcePropertyChangeResult object asynchronously. If the control session was still active when the video profile was set, and if the video profile is supported and can be activated, this will be a result indicating success.
 */
Windows.Devices.Perception.PerceptionDepthFrameSource.prototype.trySetVideoProfileAsync = function(controlSession, profile) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionDepthFrameSourceAddedEventArgs = function() {};
 /** @type {!Windows.Devices.Perception.PerceptionDepthFrameSource} */
Windows.Devices.Perception.PerceptionDepthFrameSourceAddedEventArgs.prototype.frameSource;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionDepthFrameSourceRemovedEventArgs = function() {};
 /** @type {!Windows.Devices.Perception.PerceptionDepthFrameSource} */
Windows.Devices.Perception.PerceptionDepthFrameSourceRemovedEventArgs.prototype.frameSource;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher = function() {};
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher.prototype.onenumerationcompleted;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher.prototype.onsourceadded;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher.prototype.onsourceremoved;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher.prototype.onstopped;
 /** @type {Windows.Devices.Enumeration.DeviceWatcherStatus} */
Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher.prototype.removeEventListener = function(type, listener) {};

/**
 * When this method is called, the depth frame source watcher enumerates any existing depth frame sources it has not already enumerated by firing a SourceAdded event for each one. An EnumerationCompleted event is fired when this enumeration is complete. The depth frame source then starts watching for new depth frame sources.
 * @return {void}
 */
Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher.prototype.start = function() {};

/**
 * When this method is called, the depth frame source watcher stops looking for changes to the depth frame source list. This operation is not immediate; the Stopped event will be triggered when the Stop operation is complete.
 * @return {void}
 */
Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher.prototype.stop = function() {};

/** @const */
Windows.Devices.Perception.PerceptionFrameSourceAccessStatus = {};
/** @const {number} */
Windows.Devices.Perception.PerceptionFrameSourceAccessStatus.unspecified;
/** @const {number} */
Windows.Devices.Perception.PerceptionFrameSourceAccessStatus.allowed;
/** @const {number} */
Windows.Devices.Perception.PerceptionFrameSourceAccessStatus.deniedByUser;
/** @const {number} */
Windows.Devices.Perception.PerceptionFrameSourceAccessStatus.deniedBySystem;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs = function() {};
 /** @type {Windows.Foundation.Collections.CollectionChange} */
Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs.prototype.collectionChange;
 /** @type {string} */
Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs.prototype.key;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult = function() {};
 /** @type {?} */
Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult.prototype.newValue;
 /** @type {Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeStatus} */
Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult.prototype.status;

/** @const */
Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeStatus = {};
/** @const {number} */
Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeStatus.unknown;
/** @const {number} */
Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeStatus.accepted;
/** @const {number} */
Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeStatus.lostControl;
/** @const {number} */
Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeStatus.propertyNotSupported;
/** @const {number} */
Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeStatus.propertyReadOnly;
/** @const {number} */
Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeStatus.valueOutOfRange;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionInfraredFrame = function() {};
 /** @type {!Windows.Media.VideoFrame} */
Windows.Devices.Perception.PerceptionInfraredFrame.prototype.videoFrame;

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 * @return {void}
 */
Windows.Devices.Perception.PerceptionInfraredFrame.prototype.close = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionInfraredFrameArrivedEventArgs = function() {};
 /** @type {number} */
Windows.Devices.Perception.PerceptionInfraredFrameArrivedEventArgs.prototype.relativeTime;

/**
 * Attempts to open the infrared frame that has arrived.
 * @return {!Windows.Devices.Perception.PerceptionInfraredFrame} If the attempt is successful, this method returns the newly-arrived infrared frame. If the attempt is unsuccessful, this value is unchanged.
 */
Windows.Devices.Perception.PerceptionInfraredFrameArrivedEventArgs.prototype.tryOpenFrame = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionInfraredFrameReader = function() {};
 /** @type {boolean} */
Windows.Devices.Perception.PerceptionInfraredFrameReader.prototype.isPaused;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionInfraredFrameReader.prototype.onframearrived;
 /** @type {!Windows.Devices.Perception.PerceptionInfraredFrameSource} */
Windows.Devices.Perception.PerceptionInfraredFrameReader.prototype.source;

/**
 * Releases system resources that are exposed by a Windows Runtime object
 * @return {void}
 */
Windows.Devices.Perception.PerceptionInfraredFrameReader.prototype.close = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionInfraredFrameReader.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionInfraredFrameReader.prototype.removeEventListener = function(type, listener) {};

/**
 * Attempts to read the most recent frame that is available to this infrared frame reader.
 * @return {!Windows.Devices.Perception.PerceptionInfraredFrame} If the attempt was successful, this method returns the most recent frame that is available to this infrared frame reader. If the attempt was not successful, this method returns null.
 */
Windows.Devices.Perception.PerceptionInfraredFrameReader.prototype.tryReadLatestFrame = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource = function() {};
 /** @type {boolean} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.active;
 /** @type {boolean} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.available;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Perception.PerceptionVideoProfile>} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.availableVideoProfiles;
 /** @type {!Windows.Media.Devices.Core.CameraIntrinsics} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.cameraIntrinsics;
 /** @type {?} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.deviceId;
 /** @type {string} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.deviceKind;
 /** @type {string} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.displayName;
 /** @type {string} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.id;
 /** @type {boolean} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.isControlled;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.onactivechanged;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.onavailablechanged;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.oncameraintrinsicschanged;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.onpropertieschanged;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.onvideoprofilechanged;
 /** @type {!Windows.Foundation.Collections.IMapView<string, ?>} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.properties;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Perception.PerceptionVideoProfile>} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.supportedVideoProfiles;
 /** @type {!Windows.Devices.Perception.PerceptionVideoProfile} */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.videoProfile;

/**
 * Creates a new infrared frame source watcher.
 * @return {!Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher} A new infrared frame source watcher.
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource.createWatcher = function() {};

/**
 * Finds all infrared frame sources.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When the method completes, it asynchronously returns a list of infrared frame sources.
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource.findAllAsync = function() {};

/**
 * Finds an infrared frame source by looking up its unique ID.
 * @param {string} id The unique ID of the infrared frame source.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Perception.PerceptionInfraredFrameSource, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Perception.PerceptionInfraredFrameSource>>} When the method completes, it asynchronously returns an infrared frame source if one exists with the specified ID. Otherwise, this method asynchronously returns nullptr.
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource.fromIdAsync = function(id) {};

/**
 * Requests access to use infrared frame sources.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Devices.Perception.PerceptionFrameSourceAccessStatus, !Windows.Foundation.IAsyncOperation<Windows.Devices.Perception.PerceptionFrameSourceAccessStatus>>} When this method completes, it asynchronously returns a PerceptionFrameSourceAccessStatus indicating the result of the access request.
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource.requestAccessAsync = function() {};

/**
 * Attempts to acquire Controller Mode on the infrared frame source.
 * @return {!Windows.Devices.Perception.PerceptionControlSession} If the attempt is successful, this returns a PerceptionControlSession object that can be used to control properties of the infrared frame source. Otherwise, this returns null.
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.acquireControlSession = function() {};

/**
 * Retrieves a boolean value indicating whether or not the infrared frame source can be controlled separately from another frame source.
 * @param {string} targetId A string representing the unique ID of the other frame source.
 * @return {boolean} True if the two sources can be controlled independently of one another, otherwise false.
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.canControlIndependentlyFrom = function(targetId) {};

/**
 * Checks whether or not the infrared frame source is correlated with the target entity.
 * @param {string} targetId The unique ID of the target entity.
 * @return {boolean} True if a correlation exists, otherwise false. If the result is true, a transform matrix can be retrieved to change coordinate basis from this infrared frame source to the entity, or vice versa.
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.isCorrelatedWith = function(targetId) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.removeEventListener = function(type, listener) {};

/**
 * Gets a frame reader that reads frames from this infrared frame source.
 * @return {!Windows.Devices.Perception.PerceptionInfraredFrameReader} A frame reader that reads frames from this infrared frame source.
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.openReader = function() {};

/**
 * Attempts to get the intrinsic properties of the depth camera that is correlated with this infrared source.
 * @param {!Windows.Devices.Perception.PerceptionDepthFrameSource} target The depth frame source to try to get intrinsic properties of.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics>>} If the attempt is successful, this returns a read-only collection of PerceptionDepthCorrelatedCameraIntrinsics objects specifying the intrinsic properties of the camera used by the correlated depth frame source. Otherwise, this returns null.
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.tryGetDepthCorrelatedCameraIntrinsicsAsync = function(target) {};

/**
 * Attempts to get a coordinate mapper that maps from infrared frame image space to depth frame space.
 * @param {string} targetId The unique ID of the depth frame source to try to map to.
 * @param {!Windows.Devices.Perception.PerceptionDepthFrameSource} depthFrameSourceToMapWith The depth frame source to try to map to. This should be in a correlation group with the infrared frame source.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper>>} If the two sources are correlated, this method returns a PerceptionDepthCorrelatedCoordinateMapper. Otherwise, it returns null. This method returns asynchronously.
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.tryGetDepthCorrelatedCoordinateMapperAsync = function(targetId, depthFrameSourceToMapWith) {};

/**
 * Gets the transform from the infrared frame source to the target entity and sets hasResult to true, if a correlation exists. If a correlation does not exist, hasResult is set to false and result is not modified.
 * @param {string} targetId The unique ID of the target entity.
 * @return {{result: !Windows.Foundation.Numerics.Matrix4x4, returnValue: boolean}}
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.tryGetTransformTo = function(targetId) {};

/**
 * Attempts to set a video profile on this infrared frame source. Requires an active Controller Mode control session on this frame source.
 * @param {!Windows.Devices.Perception.PerceptionControlSession} controlSession A PerceptionControlSession representing active control of this frame source.
 * @param {!Windows.Devices.Perception.PerceptionVideoProfile} profile The video profile to set.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult>>} This method returns an PerceptionFrameSourcePropertyChangeResult object asynchonously. If the control session was still active when the video profile was set, and if the video profile is supported and can be activated, this will be a success result.
 */
Windows.Devices.Perception.PerceptionInfraredFrameSource.prototype.trySetVideoProfileAsync = function(controlSession, profile) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionInfraredFrameSourceAddedEventArgs = function() {};
 /** @type {!Windows.Devices.Perception.PerceptionInfraredFrameSource} */
Windows.Devices.Perception.PerceptionInfraredFrameSourceAddedEventArgs.prototype.frameSource;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionInfraredFrameSourceRemovedEventArgs = function() {};
 /** @type {!Windows.Devices.Perception.PerceptionInfraredFrameSource} */
Windows.Devices.Perception.PerceptionInfraredFrameSourceRemovedEventArgs.prototype.frameSource;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher = function() {};
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher.prototype.onenumerationcompleted;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher.prototype.onsourceadded;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher.prototype.onsourceremoved;
 /** @type {function(?): void} */
Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher.prototype.onstopped;
 /** @type {Windows.Devices.Enumeration.DeviceWatcherStatus} */
Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher.prototype.removeEventListener = function(type, listener) {};

/**
 * When this method is called, the infrared frame source watcher enumerates any existing infrared frame sources it has not already enumerated by firing a SourceAdded event for each one. An EnumerationCompleted event is fired when this enumeration is complete. The infrared frame source then starts watching for new infrared frame sources.
 * @return {void}
 */
Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher.prototype.start = function() {};

/**
 * When this method is called, the infrared frame source watcher stops looking for changes to the infrared frame source list. This operation is not immediate; the Stopped event will be triggered when the Stop operation is complete.
 * @return {void}
 */
Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher.prototype.stop = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.PerceptionVideoProfile = function() {};
 /** @type {Windows.Graphics.Imaging.BitmapAlphaMode} */
Windows.Devices.Perception.PerceptionVideoProfile.prototype.bitmapAlphaMode;
 /** @type {Windows.Graphics.Imaging.BitmapPixelFormat} */
Windows.Devices.Perception.PerceptionVideoProfile.prototype.bitmapPixelFormat;
 /** @type {number} */
Windows.Devices.Perception.PerceptionVideoProfile.prototype.frameDuration;
 /** @type {number} */
Windows.Devices.Perception.PerceptionVideoProfile.prototype.height;
 /** @type {number} */
Windows.Devices.Perception.PerceptionVideoProfile.prototype.width;

/**
 * A comparison function used to determine if two IPerceptionVideoProfile objects are equivalent.
 * @param {!Windows.Devices.Perception.PerceptionVideoProfile} other The IPerceptionVideoProfile object to compare to this one.
 * @return {boolean} True if the two video profiles are equivalent, otherwise false.
 */
Windows.Devices.Perception.PerceptionVideoProfile.prototype.isEqual = function(other) {};
/** @const */
Windows.Devices.Perception.Provider = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.Provider.KnownPerceptionFrameKind = function() {};
 /** @type {string} */
Windows.Devices.Perception.Provider.KnownPerceptionFrameKind.color;
 /** @type {string} */
Windows.Devices.Perception.Provider.KnownPerceptionFrameKind.depth;
 /** @type {string} */
Windows.Devices.Perception.Provider.KnownPerceptionFrameKind.infrared;

/**
 * @constructor
 * @struct
 * Creates a PerceptionControlGroup containing the IPerceptionFrameProviders with the ids specified.
 * @param {!Windows.Foundation.Collections.IIterable<string>} ids A list of the unique identifiers associated with the grouped IPerceptionFrameProviders. To be controllable, the id must match the associated PerceptionFrameProviderInfo::Id property.
 */
Windows.Devices.Perception.Provider.PerceptionControlGroup = function(ids) {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Devices.Perception.Provider.PerceptionControlGroup.prototype.frameProviderIds;

/**
 * @constructor
 * @struct
 * Initializes a new PerceptionCorrelation instance.
 * @param {string} targetId The unique identifier of the IPerceptionFrameProvider being described.
 * @param {!Windows.Foundation.Numerics.Vector3} position The position of the device in a common coordinate frame of all members of a PerceptionCorrelationGroup.
 * @param {!Windows.Foundation.Numerics.Quaternion} orientation The orientation of the device in a common coordinate frame of all members of a PerceptionCorrelationGroup.
 */
Windows.Devices.Perception.Provider.PerceptionCorrelation = function(targetId, position, orientation) {};
 /** @type {!Windows.Foundation.Numerics.Quaternion} */
Windows.Devices.Perception.Provider.PerceptionCorrelation.prototype.orientation;
 /** @type {!Windows.Foundation.Numerics.Vector3} */
Windows.Devices.Perception.Provider.PerceptionCorrelation.prototype.position;
 /** @type {string} */
Windows.Devices.Perception.Provider.PerceptionCorrelation.prototype.targetId;

/**
 * @constructor
 * @struct
 * Initializes a new PerceptionCorrelationGroup from a collection of one or more PerceptionCorrelation objects describing multiple providers in a common coordinate frame.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Devices.Perception.Provider.PerceptionCorrelation>} relativeLocations The collection of PerceptionCorrelations describing multiple providers in a common coordinate frame.
 */
Windows.Devices.Perception.Provider.PerceptionCorrelationGroup = function(relativeLocations) {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Perception.Provider.PerceptionCorrelation>} */
Windows.Devices.Perception.Provider.PerceptionCorrelationGroup.prototype.relativeLocations;

/**
 * @constructor
 * @struct
 * Initializes a new PerceptionFaceAuthenticationGroup instance.
 * @param {!Windows.Foundation.Collections.IIterable<string>} ids The collection of unique identifiers which maps to IPerceptionFrameProviders via PerceptionFrameProviderInfo::Id.
 * @param {function(!Windows.Devices.Perception.Provider.PerceptionFaceAuthenticationGroup): void} startHandler The handler to invoke when this group is requested to enter Face Authentication mode returning if it's ready.
 * @param {function(!Windows.Devices.Perception.Provider.PerceptionFaceAuthenticationGroup): void} stopHandler The handler to invoke when this group is leaving Face Authentication mode after startHandler is called and returned true.
 */
Windows.Devices.Perception.Provider.PerceptionFaceAuthenticationGroup = function(ids, startHandler, stopHandler) {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Devices.Perception.Provider.PerceptionFaceAuthenticationGroup.prototype.frameProviderIds;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.Provider.PerceptionFrame = function() {};
 /** @type {!Windows.Foundation.IMemoryBuffer} */
Windows.Devices.Perception.Provider.PerceptionFrame.prototype.frameData;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.Devices.Perception.Provider.PerceptionFrame.prototype.properties;
 /** @type {number} */
Windows.Devices.Perception.Provider.PerceptionFrame.prototype.relativeTime;

/**
 * @constructor
 * @struct
 * Initializes a new PerceptionFrameProviderInfo instance.
 */
Windows.Devices.Perception.Provider.PerceptionFrameProviderInfo = function() {};
 /** @type {string} */
Windows.Devices.Perception.Provider.PerceptionFrameProviderInfo.prototype.deviceKind;
 /** @type {string} */
Windows.Devices.Perception.Provider.PerceptionFrameProviderInfo.prototype.displayName;
 /** @type {string} */
Windows.Devices.Perception.Provider.PerceptionFrameProviderInfo.prototype.frameKind;
 /** @type {boolean} */
Windows.Devices.Perception.Provider.PerceptionFrameProviderInfo.prototype.hidden;
 /** @type {string} */
Windows.Devices.Perception.Provider.PerceptionFrameProviderInfo.prototype.id;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.Provider.PerceptionFrameProviderManagerService = function() {};

/**
 * Sends the PerceptionFrame to the service to tell any apps listening for frames for the provided provider. Frames aren't expected to be published before IPerceptionFrameProvider::Start() is called or after IPerceptionFrameProvider::Stop() is called.
 * @param {!Windows.Devices.Perception.Provider.IPerceptionFrameProvider} provider The IPerceptionFrameProvider which produced the frame.
 * @param {!Windows.Devices.Perception.Provider.PerceptionFrame} frame The PerceptionFrame that was produced and should be sent to apps.
 * @return {void}
 */
Windows.Devices.Perception.Provider.PerceptionFrameProviderManagerService.publishFrameForProvider = function(provider, frame) {};

/**
 * Registers a PerceptionControlGroup associated with the IPerceptionFrameProviderManager.
 * @param {!Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager} manager The manager that owns the lifetime of the group.
 * @param {!Windows.Devices.Perception.Provider.PerceptionControlGroup} controlGroup The group of IPerceptionFrameProvider(s) to control atomically.
 * @return {void}
 */
Windows.Devices.Perception.Provider.PerceptionFrameProviderManagerService.registerControlGroup = function(manager, controlGroup) {};

/**
 * Registers a PerceptionCorrelationGroup associated with the IPerceptionFrameProviderManager.
 * @param {!Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager} manager The manager that owns the lifetime of the group.
 * @param {!Windows.Devices.Perception.Provider.PerceptionCorrelationGroup} correlationGroup The group of PerceptionCorrelations(s) to control atomically.
 * @return {void}
 */
Windows.Devices.Perception.Provider.PerceptionFrameProviderManagerService.registerCorrelationGroup = function(manager, correlationGroup) {};

/**
 * Registers a PerceptionFaceAuthenticationGroup associated with the given IPerceptionProviderManager.
 * @param {!Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager} manager The manager that owns the lifetime of the group.
 * @param {!Windows.Devices.Perception.Provider.PerceptionFaceAuthenticationGroup} faceAuthenticationGroup The group of IPerceptionFrameProvider(s) to atomically control.
 * @return {void}
 */
Windows.Devices.Perception.Provider.PerceptionFrameProviderManagerService.registerFaceAuthenticationGroup = function(manager, faceAuthenticationGroup) {};

/**
 * Registers the PerceptionFrameProviderInfo in association with the given IPerceptionFrameProviderManager.
 * @param {!Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager} manager The manager which can provide the IPerceptionFrameProvider associated with the info.
 * @param {!Windows.Devices.Perception.Provider.PerceptionFrameProviderInfo} frameProviderInfo The PerceptionFrameProviderInfo which identifies the available IPerceptionFrameProvider.
 * @return {void}
 */
Windows.Devices.Perception.Provider.PerceptionFrameProviderManagerService.registerFrameProviderInfo = function(manager, frameProviderInfo) {};

/**
 * Removes the registration of a previously registered PerceptionControlGroup.
 * @param {!Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager} manager The manager that owns the lifetime of the group.
 * @param {!Windows.Devices.Perception.Provider.PerceptionControlGroup} controlGroup The group of IPerceptionFrameProvider(s) to prevent from being controlled.
 * @return {void}
 */
Windows.Devices.Perception.Provider.PerceptionFrameProviderManagerService.unregisterControlGroup = function(manager, controlGroup) {};

/**
 * Unregisters a PerceptionCorrelationGroup associated with the IPerceptionFrameProviderManager.
 * @param {!Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager} manager The manager that owns the lifetime of the group.
 * @param {!Windows.Devices.Perception.Provider.PerceptionCorrelationGroup} correlationGroup The PerceptionCorrelationGroup to unregister.
 * @return {void}
 */
Windows.Devices.Perception.Provider.PerceptionFrameProviderManagerService.unregisterCorrelationGroup = function(manager, correlationGroup) {};

/**
 * Unregisters a PerceptionFaceAuthenticationGroup in association with the given IPerceptionProviderManager.
 * @param {!Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager} manager The manager that owns the lifetime of the group.
 * @param {!Windows.Devices.Perception.Provider.PerceptionFaceAuthenticationGroup} faceAuthenticationGroup The PerceptionFaceAuthenticationGroup to unregister.
 * @return {void}
 */
Windows.Devices.Perception.Provider.PerceptionFrameProviderManagerService.unregisterFaceAuthenticationGroup = function(manager, faceAuthenticationGroup) {};

/**
 * Unregisters the PerceptionFrameProviderInfo in association with the given IPerceptionProviderManager.
 * @param {!Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager} manager The manager which previously registered this info.
 * @param {!Windows.Devices.Perception.Provider.PerceptionFrameProviderInfo} frameProviderInfo The PerceptionFrameProviderInfo which identifies the IPerceptionFrameProvider.
 * @return {void}
 */
Windows.Devices.Perception.Provider.PerceptionFrameProviderManagerService.unregisterFrameProviderInfo = function(manager, frameProviderInfo) {};

/**
 * Sets whether or not the IPerceptionFrameProvider is available.
 * @param {!Windows.Devices.Perception.Provider.IPerceptionFrameProvider} provider The provider to set availability for.
 * @param {boolean} available Whether or not the provider is available.
 * @return {void}
 */
Windows.Devices.Perception.Provider.PerceptionFrameProviderManagerService.updateAvailabilityForProvider = function(provider, available) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Perception.Provider.PerceptionPropertyChangeRequest = function() {};
 /** @type {string} */
Windows.Devices.Perception.Provider.PerceptionPropertyChangeRequest.prototype.name;
 /** @type {Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeStatus} */
Windows.Devices.Perception.Provider.PerceptionPropertyChangeRequest.prototype.status;
 /** @type {?} */
Windows.Devices.Perception.Provider.PerceptionPropertyChangeRequest.prototype.value;

/**
 * Gets a Windows::Foundation::Deferral object to allow background processing if needed.
 * @return {!Windows.Foundation.Deferral} The Deferral object.
 */
Windows.Devices.Perception.Provider.PerceptionPropertyChangeRequest.prototype.getDeferral = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new PerceptionVideoFrameAllocator with the required properties for use by the IPerceptionFrameProvider to create PerceptionFrames published via PerceptionFrameProviderManagerService::PublishFrameForProvider.
 * @param {number} maxOutstandingFrameCountForWrite This is the number of buffers in flight required by the FrameProvider to produce its * frames at framerate. The suggestion is at least 2.
 * @param {Windows.Graphics.Imaging.BitmapPixelFormat} format The Windows::Graphics::Imaging::BitmapPixelFormat describing the format of the bytes of the frame.
 * @param {!Windows.Foundation.Size} resolution The resolution in pixels of the frame.
 * @param {Windows.Graphics.Imaging.BitmapAlphaMode} alpha The Windows::Graphics::Imaging::BitmapAlphaMode describing how transparency is handled in the pixels.
 */
Windows.Devices.Perception.Provider.PerceptionVideoFrameAllocator = function(maxOutstandingFrameCountForWrite, format, resolution, alpha) {};

/**
 * Creates an empty PerceptionFrame with the properties specified when creating the PerceptionVideoFrameAllocator.
 * @return {!Windows.Devices.Perception.Provider.PerceptionFrame} The empty frame with the properties specified when creating the PerceptionVideoFrameAllocator.
 */
Windows.Devices.Perception.Provider.PerceptionVideoFrameAllocator.prototype.allocateFrame = function() {};

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 * @return {void}
 */
Windows.Devices.Perception.Provider.PerceptionVideoFrameAllocator.prototype.close = function() {};

/**
 * Creates a deep copy of the video FrameProvider with the bytes already filled in with the resulting PerceptionFrame.
 * @param {!Windows.Media.VideoFrame} frame The input frame from which to copy the pixel data.
 * @return {!Windows.Devices.Perception.Provider.PerceptionFrame} The resulting filled PerceptionFrame.
 */
Windows.Devices.Perception.Provider.PerceptionVideoFrameAllocator.prototype.copyFromVideoFrame = function(frame) {};

/** @typedef {function(!Windows.Devices.Perception.Provider.PerceptionFaceAuthenticationGroup): void} */
Windows.Devices.Perception.Provider.PerceptionStartFaceAuthenticationHandler;

/** @typedef {function(!Windows.Devices.Perception.Provider.PerceptionFaceAuthenticationGroup): void} */
Windows.Devices.Perception.Provider.PerceptionStopFaceAuthenticationHandler;
/**
 * @extends {Windows.Foundation.IClosable}
 * @record
 * @struct
 */
Windows.Devices.Perception.Provider.IPerceptionFrameProvider = function() {};
 /** @type {boolean} */
Windows.Devices.Perception.Provider.IPerceptionFrameProvider.prototype.available;
 /** @type {!Windows.Devices.Perception.Provider.PerceptionFrameProviderInfo} */
Windows.Devices.Perception.Provider.IPerceptionFrameProvider.prototype.frameProviderInfo;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Devices.Perception.Provider.IPerceptionFrameProvider.prototype.properties;

/**
 * The device is requested to update one of its Properties to a new value.
 * @param {!Windows.Devices.Perception.Provider.PerceptionPropertyChangeRequest} value Success or failure will be conveyed to the app.
 * @return {void}
 */
Windows.Devices.Perception.Provider.IPerceptionFrameProvider.prototype.setProperty = function(value) {};

/**
 * Tells the device to start producing frames. If success is returned, PerceptionFrameProviderManagerService::PublishFrameForProvider is expected to be called by this Provider.
 * @return {void}
 */
Windows.Devices.Perception.Provider.IPerceptionFrameProvider.prototype.start = function() {};

/**
 * Tells the device to stop producing frames. Called only after Start is called and only if Start returns success.
 * @return {void}
 */
Windows.Devices.Perception.Provider.IPerceptionFrameProvider.prototype.stop = function() {};
/**
 * @extends {Windows.Foundation.IClosable}
 * @record
 * @struct
 */
Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager = function() {};

/**
 * The method to request an IPerceptionFrameProvider associated with a registered PerceptionFrameProviderInfo.
 * @param {!Windows.Devices.Perception.Provider.PerceptionFrameProviderInfo} frameProviderInfo The info specifying the desired IPerceptionFrameProvider.
 * @return {!Windows.Devices.Perception.Provider.IPerceptionFrameProvider} The associated IPerceptionFrameProvider, or nullptr if there is no such registerd provider.
 */
Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager.prototype.getFrameProvider = function(frameProviderInfo) {};
/** @const */
Windows.Devices.PointOfService = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.BarcodeScanner = function() {};
 /** @type {!Windows.Devices.PointOfService.BarcodeScannerCapabilities} */
Windows.Devices.PointOfService.BarcodeScanner.prototype.capabilities;
 /** @type {string} */
Windows.Devices.PointOfService.BarcodeScanner.prototype.deviceId;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.BarcodeScanner.prototype.onstatusupdated;

/**
 * Creates BarcodeScanner object from the DeviceInformation.Id .
 * @param {string} deviceId The DeviceInformation.Id that identifies a specific barcode scanner, which can be retrieved from the DeviceId property.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.PointOfService.BarcodeScanner, !Windows.Foundation.IAsyncOperation<!Windows.Devices.PointOfService.BarcodeScanner>>} The barcode scanner specified by the unique device identifier. Returns a null object in the following cases:
 */
Windows.Devices.PointOfService.BarcodeScanner.fromIdAsync = function(deviceId) {};

/**
 * Returns the first available barcode scanner.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.PointOfService.BarcodeScanner, !Windows.Foundation.IAsyncOperation<!Windows.Devices.PointOfService.BarcodeScanner>>} The first available barcode scanner. Returns a null object in the following cases:
 */
Windows.Devices.PointOfService.BarcodeScanner.getDefaultAsync = function() {};

/**
 * Gets an Advanced Query Syntax (AQS) string that you can use to list the available barcode scanners.
 * @return {string} An Advanced Query Syntax (AQS) string that is used to enumerate available barcode scanners.
 */
Windows.Devices.PointOfService.BarcodeScanner.getDeviceSelector = function() {};

/**
 * Tests the state of the barcode scanner.
 * @param {Windows.Devices.PointOfService.UnifiedPosHealthCheckLevel} level The specified health check level.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} A text description of the test result. Returns an error if the specified check level is not supported by the device.
 */
Windows.Devices.PointOfService.BarcodeScanner.prototype.checkHealthAsync = function(level) {};

/**
 * Attempts to get an exclusive access to the barcode scanner.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.PointOfService.ClaimedBarcodeScanner, !Windows.Foundation.IAsyncOperation<!Windows.Devices.PointOfService.ClaimedBarcodeScanner>>} When the method completes, it returns a ClaimedBarcodeScanner .
 */
Windows.Devices.PointOfService.BarcodeScanner.prototype.claimScannerAsync = function() {};

/**
 * Gets the list of profiles supported by the barcode scanner.
 * @return {!Windows.Foundation.Collections.IVectorView<string>} As array of strings representing the supported profiles. Returns an empty list if the scanner does not support profiles.
 */
Windows.Devices.PointOfService.BarcodeScanner.prototype.getSupportedProfiles = function() {};

/**
 * Gets the symbologies supported by the claimed barcode scanner.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When the method completes successfully, it returns a list of values that represent the symbologies supported by the device.
 */
Windows.Devices.PointOfService.BarcodeScanner.prototype.getSupportedSymbologiesAsync = function() {};

/**
 * Determines whether the profile is supported.
 * @param {string} profile Barcode scanner profile.
 * @return {boolean} True if the barcode scanner supports the profile; otherwise false.
 */
Windows.Devices.PointOfService.BarcodeScanner.prototype.isProfileSupported = function(profile) {};

/**
 * Determines whether the specified symbology is supported by the barcode scanner.
 * @param {number} barcodeSymbology The specific barcode symbology.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} True if the device supports the specified symbology; otherwise, false.
 */
Windows.Devices.PointOfService.BarcodeScanner.prototype.isSymbologySupportedAsync = function(barcodeSymbology) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.BarcodeScanner.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.BarcodeScanner.prototype.removeEventListener = function(type, listener) {};

/**
 * Retrieves the requested statistics from the barcode scanner.
 * @param {!Windows.Foundation.Collections.IIterable<string>} statisticsCategories The list of statistics to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} IBuffer representing the requested statistics.
 */
Windows.Devices.PointOfService.BarcodeScanner.prototype.retrieveStatisticsAsync = function(statisticsCategories) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.BarcodeScannerCapabilities = function() {};
 /** @type {boolean} */
Windows.Devices.PointOfService.BarcodeScannerCapabilities.prototype.isImagePreviewSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.BarcodeScannerCapabilities.prototype.isSoftwareTriggerSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.BarcodeScannerCapabilities.prototype.isStatisticsReportingSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.BarcodeScannerCapabilities.prototype.isStatisticsUpdatingSupported;
 /** @type {Windows.Devices.PointOfService.UnifiedPosPowerReportingType} */
Windows.Devices.PointOfService.BarcodeScannerCapabilities.prototype.powerReportingType;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.BarcodeScannerDataReceivedEventArgs = function() {};
 /** @type {!Windows.Devices.PointOfService.BarcodeScannerReport} */
Windows.Devices.PointOfService.BarcodeScannerDataReceivedEventArgs.prototype.report;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.BarcodeScannerErrorOccurredEventArgs = function() {};
 /** @type {!Windows.Devices.PointOfService.UnifiedPosErrorData} */
Windows.Devices.PointOfService.BarcodeScannerErrorOccurredEventArgs.prototype.errorData;
 /** @type {boolean} */
Windows.Devices.PointOfService.BarcodeScannerErrorOccurredEventArgs.prototype.isRetriable;
 /** @type {!Windows.Devices.PointOfService.BarcodeScannerReport} */
Windows.Devices.PointOfService.BarcodeScannerErrorOccurredEventArgs.prototype.partialInputData;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.BarcodeScannerImagePreviewReceivedEventArgs = function() {};
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamWithContentType} */
Windows.Devices.PointOfService.BarcodeScannerImagePreviewReceivedEventArgs.prototype.preview;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.BarcodeScannerReport = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.PointOfService.BarcodeScannerReport.prototype.scanData;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.PointOfService.BarcodeScannerReport.prototype.scanDataLabel;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeScannerReport.prototype.scanDataType;

/** @const */
Windows.Devices.PointOfService.BarcodeScannerStatus = {};
/** @const {number} */
Windows.Devices.PointOfService.BarcodeScannerStatus.online;
/** @const {number} */
Windows.Devices.PointOfService.BarcodeScannerStatus.off;
/** @const {number} */
Windows.Devices.PointOfService.BarcodeScannerStatus.offline;
/** @const {number} */
Windows.Devices.PointOfService.BarcodeScannerStatus.offOrOffline;
/** @const {number} */
Windows.Devices.PointOfService.BarcodeScannerStatus.extended;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.BarcodeScannerStatusUpdatedEventArgs = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeScannerStatusUpdatedEventArgs.prototype.extendedStatus;
 /** @type {Windows.Devices.PointOfService.BarcodeScannerStatus} */
Windows.Devices.PointOfService.BarcodeScannerStatusUpdatedEventArgs.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.BarcodeSymbologies = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ausPost;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.aztec;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.canPost;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ccab;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ccc;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.chinaPost;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.codabar;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.codablock128;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.codablockA;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.codablockF;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.code11;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.code128;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.code16k;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.code32;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.code39;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.code39Ex;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.code49;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.code93;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.code93Ex;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.dataCode;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.dataMatrix;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.dutchKix;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ean13;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ean13Add2;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ean13Add5;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ean8;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ean8Add2;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ean8Add5;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ean99;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ean99Add2;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ean99Add5;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.eanv;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.eanvAdd2;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.eanvAdd5;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.extendedBase;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.gs1128;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.gs1128Coupon;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.gs1DatabarType1;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.gs1DatabarType2;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.gs1DatabarType3;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.hanXin;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.infoMail;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.isbn;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.isbnAdd5;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.isbt;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ismn;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ismnAdd2;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ismnAdd5;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.issn;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.issnAdd2;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.issnAdd5;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.italianPost25;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.italianPost39;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.japanPost;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.koreanPost;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.maxicode;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.micr;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.microPdf417;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.microQr;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.msTag;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.msi;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ocrA;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ocrB;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.pdf417;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.plessey;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.pzn;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.qr;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.sisac;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.swedenPost;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.telepen;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.tfDis;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.tfIata;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.tfInd;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.tfInt;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.tfMat;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.tfStd;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.tlc39;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.trioptic39;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.uccEan128;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.ukPost;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.unknown;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.upcCoupon;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.upca;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.upcaAdd2;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.upcaAdd5;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.upce;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.upceAdd2;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.upceAdd5;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.us4StateFics;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.usIntelligent;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.usIntelligentPkg;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.usPlanet;
 /** @type {number} */
Windows.Devices.PointOfService.BarcodeSymbologies.usPostNet;

/**
 * Returns the barcode symbology type as a string.
 * @param {number} scanDataType The barcode symbology type.
 * @return {string} The barcode symbology type as a string.
 */
Windows.Devices.PointOfService.BarcodeSymbologies.getName = function(scanDataType) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.CashDrawer = function() {};
 /** @type {!Windows.Devices.PointOfService.CashDrawerCapabilities} */
Windows.Devices.PointOfService.CashDrawer.prototype.capabilities;
 /** @type {string} */
Windows.Devices.PointOfService.CashDrawer.prototype.deviceId;
 /** @type {!Windows.Devices.PointOfService.CashDrawerEventSource} */
Windows.Devices.PointOfService.CashDrawer.prototype.drawerEventSource;
 /** @type {boolean} */
Windows.Devices.PointOfService.CashDrawer.prototype.isDrawerOpen;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.CashDrawer.prototype.onstatusupdated;
 /** @type {!Windows.Devices.PointOfService.CashDrawerStatus} */
Windows.Devices.PointOfService.CashDrawer.prototype.status;

/**
 * Creates CashDrawer object from the DeviceInformation.Id .
 * @param {string} deviceId The DeviceInformation.Id that identifies a specific cash drawer, which can be retrieved from the DeviceId property.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.PointOfService.CashDrawer, !Windows.Foundation.IAsyncOperation<!Windows.Devices.PointOfService.CashDrawer>>} The cash drawer specified by the unique device identifier. Returns a null object in the following cases:
 */
Windows.Devices.PointOfService.CashDrawer.fromIdAsync = function(deviceId) {};

/**
 * Gets the default paired or locally-connected cash drawer.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.PointOfService.CashDrawer, !Windows.Foundation.IAsyncOperation<!Windows.Devices.PointOfService.CashDrawer>>} The default locally-connected drawer. May return null if there is no drawer available.
 */
Windows.Devices.PointOfService.CashDrawer.getDefaultAsync = function() {};

/**
 * Gets an Advanced Query Syntax (AQS) string that you can use to list the available cash drawers.
 * @return {string} An Advanced Query Syntax (AQS) string that is used to enumerate available cash drawers.
 */
Windows.Devices.PointOfService.CashDrawer.getDeviceSelector = function() {};

/**
 * Gets the device's health state asynchronously.
 * @param {Windows.Devices.PointOfService.UnifiedPosHealthCheckLevel} level The specified health check level.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} This value is intended to be reflected in the app interface immediately so the user of the app can interpret it. For example, it will return OK as the health string if the device state is good.
 */
Windows.Devices.PointOfService.CashDrawer.prototype.checkHealthAsync = function(level) {};

/**
 * Attempts to get exclusive access on the cash drawer.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.PointOfService.ClaimedCashDrawer, !Windows.Foundation.IAsyncOperation<!Windows.Devices.PointOfService.ClaimedCashDrawer>>} When the method completes, it returns a ClaimedCashDrawer .
 */
Windows.Devices.PointOfService.CashDrawer.prototype.claimDrawerAsync = function() {};

/**
 * Retrieves the requested statistics from the cash drawer.
 * @param {!Windows.Foundation.Collections.IIterable<string>} statisticsCategories The list of statistics to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} String representing the requested statistics.
 */
Windows.Devices.PointOfService.CashDrawer.prototype.getStatisticsAsync = function(statisticsCategories) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.CashDrawer.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.CashDrawer.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.CashDrawerCapabilities = function() {};
 /** @type {boolean} */
Windows.Devices.PointOfService.CashDrawerCapabilities.prototype.isDrawerOpenSensorAvailable;
 /** @type {boolean} */
Windows.Devices.PointOfService.CashDrawerCapabilities.prototype.isStatisticsReportingSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.CashDrawerCapabilities.prototype.isStatisticsUpdatingSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.CashDrawerCapabilities.prototype.isStatusMultiDrawerDetectSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.CashDrawerCapabilities.prototype.isStatusReportingSupported;
 /** @type {Windows.Devices.PointOfService.UnifiedPosPowerReportingType} */
Windows.Devices.PointOfService.CashDrawerCapabilities.prototype.powerReportingType;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.CashDrawerCloseAlarm = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.CashDrawerCloseAlarm.prototype.alarmTimeout;
 /** @type {number} */
Windows.Devices.PointOfService.CashDrawerCloseAlarm.prototype.beepDelay;
 /** @type {number} */
Windows.Devices.PointOfService.CashDrawerCloseAlarm.prototype.beepDuration;
 /** @type {number} */
Windows.Devices.PointOfService.CashDrawerCloseAlarm.prototype.beepFrequency;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.CashDrawerCloseAlarm.prototype.onalarmtimeoutexpired;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.CashDrawerCloseAlarm.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.CashDrawerCloseAlarm.prototype.removeEventListener = function(type, listener) {};

/**
 * Starts the alarm countdown, returning an awaitable object that completes when the cash drawer is closed.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} True if the drawer has been closed; otherwise, false indicates a problem has occurred.
 */
Windows.Devices.PointOfService.CashDrawerCloseAlarm.prototype.startAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.CashDrawerClosedEventArgs = function() {};
 /** @type {!Windows.Devices.PointOfService.CashDrawer} */
Windows.Devices.PointOfService.CashDrawerClosedEventArgs.prototype.cashDrawer;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.CashDrawerEventSource = function() {};
 /** @type {function(?): void} */
Windows.Devices.PointOfService.CashDrawerEventSource.prototype.ondrawerclosed;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.CashDrawerEventSource.prototype.ondraweropened;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.CashDrawerEventSource.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.CashDrawerEventSource.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.CashDrawerOpenedEventArgs = function() {};
 /** @type {!Windows.Devices.PointOfService.CashDrawer} */
Windows.Devices.PointOfService.CashDrawerOpenedEventArgs.prototype.cashDrawer;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.CashDrawerStatus = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.CashDrawerStatus.prototype.extendedStatus;
 /** @type {Windows.Devices.PointOfService.CashDrawerStatusKind} */
Windows.Devices.PointOfService.CashDrawerStatus.prototype.statusKind;

/** @const */
Windows.Devices.PointOfService.CashDrawerStatusKind = {};
/** @const {number} */
Windows.Devices.PointOfService.CashDrawerStatusKind.online;
/** @const {number} */
Windows.Devices.PointOfService.CashDrawerStatusKind.off;
/** @const {number} */
Windows.Devices.PointOfService.CashDrawerStatusKind.offline;
/** @const {number} */
Windows.Devices.PointOfService.CashDrawerStatusKind.offOrOffline;
/** @const {number} */
Windows.Devices.PointOfService.CashDrawerStatusKind.extended;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.CashDrawerStatusUpdatedEventArgs = function() {};
 /** @type {!Windows.Devices.PointOfService.CashDrawerStatus} */
Windows.Devices.PointOfService.CashDrawerStatusUpdatedEventArgs.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.ClaimedBarcodeScanner = function() {};
 /** @type {string} */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.deviceId;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.isDecodeDataEnabled;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.isDisabledOnDataReceived;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.isEnabled;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.ondatareceived;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.onerroroccurred;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.onimagepreviewreceived;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.onreleasedevicerequested;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.ontriggerpressed;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.ontriggerreleased;

/**
 * Releases exclusive claim to the barcode scanner.
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.close = function() {};

/**
 * Puts the barcode scanner into a state where it cannot receive DataReceived events.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.disableAsync = function() {};

/**
 * Gets the barcode scanner into a ready state for DataReceived events.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.enableAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.removeEventListener = function(type, listener) {};

/**
 * Resets the specified statistics to zero for all statistics that can be reset.
 * @param {!Windows.Foundation.Collections.IIterable<string>} statisticsCategories The list of names of the statistics to reset.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method when it completes.
 */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.resetStatisticsAsync = function(statisticsCategories) {};

/**
 * Retains exclusive claim to the barcode scanner.
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.retainDevice = function() {};

/**
 * Sets the active profile on the barcode scanner.
 * @param {string} profile The name of the profile to set on the device.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when the method completes.
 */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.setActiveProfileAsync = function(profile) {};

/**
 * Sets the barcode symbologies for the device to use.
 * @param {!Windows.Foundation.Collections.IIterable<number>} symbologies The specific symbologies to use.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.setActiveSymbologiesAsync = function(symbologies) {};

/**
 * Used to signal the barcode scanner to start scanning. A session is active until StopSoftwareTriggerAsync is invoked, or until the scanner ends the session on its own.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.startSoftwareTriggerAsync = function() {};

/**
 * Used to stop a session that was started with StartSoftwareTriggerAsync . No error is raised if this is called when no session is active.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.stopSoftwareTriggerAsync = function() {};

/**
 * Updates the specified statistics.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} statistics The list of key-value pairs of statistics to update.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method when it completes.
 */
Windows.Devices.PointOfService.ClaimedBarcodeScanner.prototype.updateStatisticsAsync = function(statistics) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.ClaimedCashDrawer = function() {};
 /** @type {!Windows.Devices.PointOfService.CashDrawerCloseAlarm} */
Windows.Devices.PointOfService.ClaimedCashDrawer.prototype.closeAlarm;
 /** @type {string} */
Windows.Devices.PointOfService.ClaimedCashDrawer.prototype.deviceId;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedCashDrawer.prototype.isDrawerOpen;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedCashDrawer.prototype.isEnabled;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.ClaimedCashDrawer.prototype.onreleasedevicerequested;

/**
 * Disposes the claimed cash drawer, releases claim on the device, and disables the device the same way as calling DisableAsync.
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedCashDrawer.prototype.close = function() {};

/**
 * Notifies the underlying hardware to power off.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} Whether the attempt to disable succeeded or not.
 */
Windows.Devices.PointOfService.ClaimedCashDrawer.prototype.disableAsync = function() {};

/**
 * Asynchronously notifies the underlying hardware to power on for use.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} Whether the attempt to enable succeeded or not.
 */
Windows.Devices.PointOfService.ClaimedCashDrawer.prototype.enableAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedCashDrawer.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedCashDrawer.prototype.removeEventListener = function(type, listener) {};

/**
 * Opens the cash drawer.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} Boolean indicating whether the drawer was successfully opened.
 */
Windows.Devices.PointOfService.ClaimedCashDrawer.prototype.openDrawerAsync = function() {};

/**
 * Resets the specified device statistics to their defaults.
 * @param {!Windows.Foundation.Collections.IIterable<string>} statisticsCategories The list of names of the statistics to reset.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} True on success; otherwise false.
 */
Windows.Devices.PointOfService.ClaimedCashDrawer.prototype.resetStatisticsAsync = function(statisticsCategories) {};

/**
 * Retain the current claim on the cash drawer. This is usually called in response to a ReleaseDeviceRequested event notification.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} True if the retain attempt succeeded; false if the retain attempt failed.
 */
Windows.Devices.PointOfService.ClaimedCashDrawer.prototype.retainDeviceAsync = function() {};

/**
 * Updates device statistics values using the provided key/value pair.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} statistics The statistics to update.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} True if update succeeded; otherwise false.
 */
Windows.Devices.PointOfService.ClaimedCashDrawer.prototype.updateStatisticsAsync = function(statistics) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.ClaimedJournalPrinter = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.charactersPerLine;
 /** @type {Windows.Devices.PointOfService.PosPrinterColorCartridge} */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.colorCartridge;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.isCartridgeEmpty;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.isCartridgeRemoved;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.isCoverOpen;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.isHeadCleaning;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.isLetterQuality;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.isPaperEmpty;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.isPaperNearEnd;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.isReadyToPrint;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.lineHeight;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.lineSpacing;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.lineWidth;

/**
 * Creates a new print job for the journal printer station.
 * @return {!Windows.Devices.PointOfService.JournalPrintJob} The new print job for the journal printer station.
 */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.createJob = function() {};

/**
 * Determines if a JournalPrintJob can successfully execute a print instruction with the specified data.
 * @param {string} data The data sequence that you want to validate before you use it with the JournalPrintJob.Print method. This sequence may include printable data and escape sequences.
 * @return {boolean} True if the data passes validation; otherwise false.
 */
Windows.Devices.PointOfService.ClaimedJournalPrinter.prototype.validateData = function(data) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.dataEncryptionAlgorithm;
 /** @type {string} */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.deviceId;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.isDecodeDataEnabled;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.isDeviceAuthenticated;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.isDisabledOnDataReceived;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.isEnabled;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.isTransmitSentinelsEnabled;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.onaamvacarddatareceived;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.onbankcarddatareceived;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.onerroroccurred;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.onreleasedevicerequested;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.onvendorspecificdatareceived;
 /** @type {Windows.Devices.PointOfService.MagneticStripeReaderTrackIds} */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.tracksToRead;

/**
 * Puts the device into an authenticated state.
 * @param {!Array<number>} responseToken A buffer containing the response token generated from the challenge token retrieved from a previous call to the RetrieveDeviceAuthenticationDataAsync method.
 * @return {?}
 */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.authenticateDeviceAsync = function(responseToken) {};

/**
 * Releases the exclusive claim to the magnetic strip reader.
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.close = function() {};

/**
 * Puts the device into an unauthenticated state.
 * @param {!Array<number>} responseToken A buffer containing the response token generated from the challenge token retrieved from a previous call to the RetrieveDeviceAuthenticationDataAsync method.
 * @return {?}
 */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.deAuthenticateDeviceAsync = function(responseToken) {};

/**
 * Puts the ClaimedMagneticStripeReader into a state where it cannot receive data events.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.disableAsync = function() {};

/**
 * Gets the magnetic stripe reader into a ready state to receive data events.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method when it completes.
 */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.enableAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.removeEventListener = function(type, listener) {};

/**
 * Resets the specified statistics to zero for all statistics that can be reset.
 * @param {!Windows.Foundation.Collections.IIterable<string>} statisticsCategories The list of names of the statistics to reset.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method when it completes.
 */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.resetStatisticsAsync = function(statisticsCategories) {};

/**
 * Retains exclusive claim to the magnetic stripe reader.
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.retainDevice = function() {};

/**
 * Retrieves a challenge token from the device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} Buffer used to store the resulting challenge token from the device.
 */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.retrieveDeviceAuthenticationDataAsync = function() {};

/**
 * Sets the type of error to report by the ErrorOccurred event.
 * @param {Windows.Devices.PointOfService.MagneticStripeReaderErrorReportingType} value Error reporting type.
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.setErrorReportingType = function(value) {};

/**
 * Provides a new encryption key to the device.
 * @param {string} key The HEX-ASCII or base64-encoded value for the new key.
 * @param {string} keyName The name used to identify the key.
 * @return {?}
 */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.updateKeyAsync = function(key, keyName) {};

/**
 * Updates the specified statistics.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} statistics The list of key-value pairs of statistics to update.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method when it completes.
 */
Windows.Devices.PointOfService.ClaimedMagneticStripeReader.prototype.updateStatisticsAsync = function(statistics) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.ClaimedPosPrinter = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.characterSet;
 /** @type {string} */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.deviceId;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.isCharacterSetMappingEnabled;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.isCoverOpen;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.isEnabled;
 /** @type {!Windows.Devices.PointOfService.ClaimedJournalPrinter} */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.journal;
 /** @type {Windows.Devices.PointOfService.PosPrinterMapMode} */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.mapMode;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.onreleasedevicerequested;
 /** @type {!Windows.Devices.PointOfService.ClaimedReceiptPrinter} */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.receipt;
 /** @type {!Windows.Devices.PointOfService.ClaimedSlipPrinter} */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.slip;

/**
 * Disposes the claimed point-of-service printer object synchronously, releases the exclusive claim on the printer and disables it.
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.close = function() {};

/**
 * Notifies the underlying hardware to turn off.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} True if the attempt turn off the printer succeeded; otherwise false.
 */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.disableAsync = function() {};

/**
 * Notifies the underlying hardware asynchronously to power on for use.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} True if the attempt to turn on the printer succeeded; otherwise false.
 */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.enableAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.removeEventListener = function(type, listener) {};

/**
 * Resets the specified statistics to zero for all statistics for the point-of-service printer that can be reset.
 * @param {!Windows.Foundation.Collections.IIterable<string>} statisticsCategories A list of the names of the statistics that you want to reset.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An operation that returns true if the reset succeeds, or otherwise returns false.
 */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.resetStatisticsAsync = function(statisticsCategories) {};

/**
 * Retains the claim on the point-of-service printer asynchronously, usually in response to the ReleaseDeviceRequested event.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} True if the printer was successfully retained; otherwise, false.
 */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.retainDeviceAsync = function() {};

/**
 * Updates the specified statistics for the point-of-service printer.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} statistics The statistics to update.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An operation that returns true if the update succeeds, or otherwise returns false.
 */
Windows.Devices.PointOfService.ClaimedPosPrinter.prototype.updateStatisticsAsync = function(statistics) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.ClaimedReceiptPrinter = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.charactersPerLine;
 /** @type {Windows.Devices.PointOfService.PosPrinterColorCartridge} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.colorCartridge;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.isCartridgeEmpty;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.isCartridgeRemoved;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.isCoverOpen;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.isHeadCleaning;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.isLetterQuality;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.isPaperEmpty;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.isPaperNearEnd;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.isReadyToPrint;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.lineHeight;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.lineSpacing;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.lineWidth;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.linesToPaperCut;
 /** @type {!Windows.Foundation.Size} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.pageSize;
 /** @type {!Windows.Foundation.Rect} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.printArea;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.sidewaysMaxChars;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.sidewaysMaxLines;

/**
 * Creates a new print job for the receipt printer station.
 * @return {!Windows.Devices.PointOfService.ReceiptPrintJob} The new print job for the receipt printer station.
 */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.createJob = function() {};

/**
 * Determines whether a data sequence, possibly including one or more escape sequences, is valid for the receipt printer station, before you use that data sequence when you call the ReceiptPrintJob.Print and ReceiptPrintJob.ExecuteAsync methods.
 * @param {string} data The data sequence that you want to validate before you use it with the ReceiptPrintJob.Print method. This sequence may include printable data and escape sequences.
 * @return {boolean} True if the data passes validation; otherwise false.
 */
Windows.Devices.PointOfService.ClaimedReceiptPrinter.prototype.validateData = function(data) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.ClaimedSlipPrinter = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.charactersPerLine;
 /** @type {Windows.Devices.PointOfService.PosPrinterColorCartridge} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.colorCartridge;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.isCartridgeEmpty;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.isCartridgeRemoved;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.isCoverOpen;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.isHeadCleaning;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.isLetterQuality;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.isPaperEmpty;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.isPaperNearEnd;
 /** @type {boolean} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.isReadyToPrint;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.lineHeight;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.lineSpacing;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.lineWidth;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.linesNearEndToEnd;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.maxLines;
 /** @type {!Windows.Foundation.Size} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.pageSize;
 /** @type {!Windows.Foundation.Rect} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.printArea;
 /** @type {Windows.Devices.PointOfService.PosPrinterPrintSide} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.printSide;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.sidewaysMaxChars;
 /** @type {number} */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.sidewaysMaxLines;

/**
 * Changes the side of the sheet on which the claimed slip printer station is currently printing.
 * @param {Windows.Devices.PointOfService.PosPrinterPrintSide} printSide The side of the sheet on which the claimed slip printer station is currently printing.
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.changePrintSide = function(printSide) {};

/**
 * Closes the mechanism that holds the slip in place while the slip printer station is printing, typically after the user inserts or removes the slip.
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.closeJaws = function() {};

/**
 * Creates a new print job for the slip printer stiation.
 * @return {!Windows.Devices.PointOfService.SlipPrintJob} The new print job for the slip printer station.
 */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.createJob = function() {};

/**
 * Waits for the user to insert a slip into the slip printer station.
 * @param {number} timeout The interval of time that the operation should wait for the user to insert the slip before exiting.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An asynchronous operation that returns true if the user inserts the slip within the specified time span, and returns false otherwise.
 */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.insertSlipAsync = function(timeout) {};

/**
 * Opens the mechanism that holds the slip in place while the slip printer station is printing, typically before the user inserts or removes the slip.
 * @return {void}
 */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.openJaws = function() {};

/**
 * Waits for the user to remove a slip from the slip printer station.
 * @param {number} timeout The interval of time that the operation should wait for the user to remove the slip before exiting.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An asynchronous operation that returns true if the user removes the slip within the specified time span, and returns false otherwise.
 */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.removeSlipAsync = function(timeout) {};

/**
 * Determines whether a data sequence, possibly including one or more escape sequences, is valid for the slip printer station, before you use that data sequence when you call the SlipPrintJob.Print and SlipPrintJob.ExecuteAsync methods.
 * @param {string} data The data sequence that you want to validate before you use it with the SlipPrintJob.Print method. This sequence may include printable data and escape sequences.
 * @return {boolean} True if the data passes validation; otherwise false.
 */
Windows.Devices.PointOfService.ClaimedSlipPrinter.prototype.validateData = function(data) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.JournalPrintJob = function() {};

/**
 * Runs the print job on the journal printer station asynchronously.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The operation to run the print job. This operation returns true if the print job succeeds; otherwise, the operation returns false.
 */
Windows.Devices.PointOfService.JournalPrintJob.prototype.executeAsync = function() {};

/**
 * Adds an instruction to the print job to print the specified text on the journal printer station.
 * @param {string} data The text to print on the journal printer.
 * @return {void}
 */
Windows.Devices.PointOfService.JournalPrintJob.prototype.print = function(data) {};

/**
 * Adds an instruction to the print job to print the specified line of text on the journal printer station.
 * Adds an instruction to the print job to print a newline character on the journal printer station.
 * @param {string=} data The line of text to print.
 * @return {void}
 */
Windows.Devices.PointOfService.JournalPrintJob.prototype.printLine = function(data) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.JournalPrinterCapabilities = function() {};
 /** @type {Windows.Devices.PointOfService.PosPrinterCartridgeSensors} */
Windows.Devices.PointOfService.JournalPrinterCapabilities.prototype.cartridgeSensors;
 /** @type {Windows.Devices.PointOfService.PosPrinterColorCapabilities} */
Windows.Devices.PointOfService.JournalPrinterCapabilities.prototype.colorCartridgeCapabilities;
 /** @type {boolean} */
Windows.Devices.PointOfService.JournalPrinterCapabilities.prototype.isBoldSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.JournalPrinterCapabilities.prototype.isDoubleHighDoubleWidePrintSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.JournalPrinterCapabilities.prototype.isDoubleHighPrintSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.JournalPrinterCapabilities.prototype.isDoubleWidePrintSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.JournalPrinterCapabilities.prototype.isDualColorSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.JournalPrinterCapabilities.prototype.isItalicSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.JournalPrinterCapabilities.prototype.isPaperEmptySensorSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.JournalPrinterCapabilities.prototype.isPaperNearEndSensorSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.JournalPrinterCapabilities.prototype.isPrinterPresent;
 /** @type {boolean} */
Windows.Devices.PointOfService.JournalPrinterCapabilities.prototype.isUnderlineSupported;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Devices.PointOfService.JournalPrinterCapabilities.prototype.supportedCharactersPerLine;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.MagneticStripeReader = function() {};
 /** @type {!Windows.Devices.PointOfService.MagneticStripeReaderCapabilities} */
Windows.Devices.PointOfService.MagneticStripeReader.prototype.capabilities;
 /** @type {Windows.Devices.PointOfService.MagneticStripeReaderAuthenticationProtocol} */
Windows.Devices.PointOfService.MagneticStripeReader.prototype.deviceAuthenticationProtocol;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReader.prototype.deviceId;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.MagneticStripeReader.prototype.onstatusupdated;
 /** @type {number} */
Windows.Devices.PointOfService.MagneticStripeReader.prototype.supportedCardTypes;

/**
 * Creates a MagneticStripeReader object from DeviceInformation.Id .
 * @param {string} deviceId The DeviceInformation.Id that identifies a specific magnetic stripe reader, which can be retrieved from the DeviceId property.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.PointOfService.MagneticStripeReader, !Windows.Foundation.IAsyncOperation<!Windows.Devices.PointOfService.MagneticStripeReader>>} The magnetic stripe reader specified by the unique device identifier. Returns a null object in the following cases:
 */
Windows.Devices.PointOfService.MagneticStripeReader.fromIdAsync = function(deviceId) {};

/**
 * Returns the first magnetic stripe reader found.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.PointOfService.MagneticStripeReader, !Windows.Foundation.IAsyncOperation<!Windows.Devices.PointOfService.MagneticStripeReader>>} The first magnetic stripe reader found. Returns a null object in the following cases:
 */
Windows.Devices.PointOfService.MagneticStripeReader.getDefaultAsync = function() {};

/**
 * Returns an Advanced Query Syntax (AQS) string that is used to enumerate available magnetic stripe readers.
 * @return {string} An Advanced Query Syntax (AQS) string that is used to enumerate available magnetic stripe readers.
 */
Windows.Devices.PointOfService.MagneticStripeReader.getDeviceSelector = function() {};

/**
 * Tests the health of the magnetic stripe reader.
 * @param {Windows.Devices.PointOfService.UnifiedPosHealthCheckLevel} level The specific health check level.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} A text description of the text result. Returns an error if the specified check level is not supported by the device.
 */
Windows.Devices.PointOfService.MagneticStripeReader.prototype.checkHealthAsync = function(level) {};

/**
 * Attempts to get an exclusive access to the magnetic stripe reader.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.PointOfService.ClaimedMagneticStripeReader, !Windows.Foundation.IAsyncOperation<!Windows.Devices.PointOfService.ClaimedMagneticStripeReader>>} When the method completes, it returns a ClaimedMagneticStripeReader or it returns null if the operation fails to claim a magnetic stripe reader.
 */
Windows.Devices.PointOfService.MagneticStripeReader.prototype.claimReaderAsync = function() {};

/**
 * Gets the error reporting type the application wants to receive.
 * @return {Windows.Devices.PointOfService.MagneticStripeReaderErrorReportingType} The error reporting type.
 */
Windows.Devices.PointOfService.MagneticStripeReader.prototype.getErrorReportingType = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.MagneticStripeReader.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.MagneticStripeReader.prototype.removeEventListener = function(type, listener) {};

/**
 * Retrieves the requested statistics from the magnetic stripe reader.
 * @param {!Windows.Foundation.Collections.IIterable<string>} statisticsCategories The list of statistics to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} IBuffer representing the requested statistics.
 */
Windows.Devices.PointOfService.MagneticStripeReader.prototype.retrieveStatisticsAsync = function(statisticsCategories) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs = function() {};
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.address;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.birthDate;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.city;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.class;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.endorsements;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.expirationDate;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.eyeColor;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.firstName;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.gender;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.hairColor;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.height;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.licenseNumber;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.postalCode;
 /** @type {!Windows.Devices.PointOfService.MagneticStripeReaderReport} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.report;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.restrictions;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.state;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.suffix;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.surname;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs.prototype.weight;

/** @const */
Windows.Devices.PointOfService.MagneticStripeReaderAuthenticationLevel = {};
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderAuthenticationLevel.notSupported;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderAuthenticationLevel.optional;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderAuthenticationLevel.required;

/** @const */
Windows.Devices.PointOfService.MagneticStripeReaderAuthenticationProtocol = {};
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderAuthenticationProtocol.none;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderAuthenticationProtocol.challengeResponse;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs = function() {};
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs.prototype.accountNumber;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs.prototype.expirationDate;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs.prototype.firstName;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs.prototype.middleInitial;
 /** @type {!Windows.Devices.PointOfService.MagneticStripeReaderReport} */
Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs.prototype.report;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs.prototype.serviceCode;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs.prototype.suffix;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs.prototype.surname;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs.prototype.title;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.MagneticStripeReaderCapabilities = function() {};
 /** @type {Windows.Devices.PointOfService.MagneticStripeReaderAuthenticationLevel} */
Windows.Devices.PointOfService.MagneticStripeReaderCapabilities.prototype.authenticationLevel;
 /** @type {string} */
Windows.Devices.PointOfService.MagneticStripeReaderCapabilities.prototype.cardAuthentication;
 /** @type {boolean} */
Windows.Devices.PointOfService.MagneticStripeReaderCapabilities.prototype.isIsoSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.MagneticStripeReaderCapabilities.prototype.isJisOneSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.MagneticStripeReaderCapabilities.prototype.isJisTwoSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.MagneticStripeReaderCapabilities.prototype.isStatisticsReportingSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.MagneticStripeReaderCapabilities.prototype.isStatisticsUpdatingSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.MagneticStripeReaderCapabilities.prototype.isTrackDataMaskingSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.MagneticStripeReaderCapabilities.prototype.isTransmitSentinelsSupported;
 /** @type {Windows.Devices.PointOfService.UnifiedPosPowerReportingType} */
Windows.Devices.PointOfService.MagneticStripeReaderCapabilities.prototype.powerReportingType;
 /** @type {number} */
Windows.Devices.PointOfService.MagneticStripeReaderCapabilities.prototype.supportedEncryptionAlgorithms;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.MagneticStripeReaderCardTypes = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.MagneticStripeReaderCardTypes.aamva;
 /** @type {number} */
Windows.Devices.PointOfService.MagneticStripeReaderCardTypes.bank;
 /** @type {number} */
Windows.Devices.PointOfService.MagneticStripeReaderCardTypes.extendedBase;
 /** @type {number} */
Windows.Devices.PointOfService.MagneticStripeReaderCardTypes.unknown;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.MagneticStripeReaderEncryptionAlgorithms = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.MagneticStripeReaderEncryptionAlgorithms.extendedBase;
 /** @type {number} */
Windows.Devices.PointOfService.MagneticStripeReaderEncryptionAlgorithms.none;
 /** @type {number} */
Windows.Devices.PointOfService.MagneticStripeReaderEncryptionAlgorithms.tripleDesDukpt;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs = function() {};
 /** @type {!Windows.Devices.PointOfService.UnifiedPosErrorData} */
Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs.prototype.errorData;
 /** @type {!Windows.Devices.PointOfService.MagneticStripeReaderReport} */
Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs.prototype.partialInputData;
 /** @type {Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType} */
Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs.prototype.track1Status;
 /** @type {Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType} */
Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs.prototype.track2Status;
 /** @type {Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType} */
Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs.prototype.track3Status;
 /** @type {Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType} */
Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs.prototype.track4Status;

/** @const */
Windows.Devices.PointOfService.MagneticStripeReaderErrorReportingType = {};
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderErrorReportingType.cardLevel;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderErrorReportingType.trackLevel;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.MagneticStripeReaderReport = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.PointOfService.MagneticStripeReaderReport.prototype.additionalSecurityInformation;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.PointOfService.MagneticStripeReaderReport.prototype.cardAuthenticationData;
 /** @type {number} */
Windows.Devices.PointOfService.MagneticStripeReaderReport.prototype.cardAuthenticationDataLength;
 /** @type {number} */
Windows.Devices.PointOfService.MagneticStripeReaderReport.prototype.cardType;
 /** @type {!Windows.Foundation.Collections.IMapView<string, string>} */
Windows.Devices.PointOfService.MagneticStripeReaderReport.prototype.properties;
 /** @type {!Windows.Devices.PointOfService.MagneticStripeReaderTrackData} */
Windows.Devices.PointOfService.MagneticStripeReaderReport.prototype.track1;
 /** @type {!Windows.Devices.PointOfService.MagneticStripeReaderTrackData} */
Windows.Devices.PointOfService.MagneticStripeReaderReport.prototype.track2;
 /** @type {!Windows.Devices.PointOfService.MagneticStripeReaderTrackData} */
Windows.Devices.PointOfService.MagneticStripeReaderReport.prototype.track3;
 /** @type {!Windows.Devices.PointOfService.MagneticStripeReaderTrackData} */
Windows.Devices.PointOfService.MagneticStripeReaderReport.prototype.track4;

/** @const */
Windows.Devices.PointOfService.MagneticStripeReaderStatus = {};
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderStatus.unauthenticated;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderStatus.authenticated;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderStatus.extended;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.MagneticStripeReaderStatusUpdatedEventArgs = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.MagneticStripeReaderStatusUpdatedEventArgs.prototype.extendedStatus;
 /** @type {Windows.Devices.PointOfService.MagneticStripeReaderStatus} */
Windows.Devices.PointOfService.MagneticStripeReaderStatusUpdatedEventArgs.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.MagneticStripeReaderTrackData = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.PointOfService.MagneticStripeReaderTrackData.prototype.data;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.PointOfService.MagneticStripeReaderTrackData.prototype.discretionaryData;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.PointOfService.MagneticStripeReaderTrackData.prototype.encryptedData;

/** @const */
Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType = {};
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType.none;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType.startSentinelError;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType.endSentinelError;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType.parityError;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType.lrcError;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType.unknown;

/** @const */
Windows.Devices.PointOfService.MagneticStripeReaderTrackIds = {};
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderTrackIds.none;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderTrackIds.track1;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderTrackIds.track2;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderTrackIds.track3;
/** @const {number} */
Windows.Devices.PointOfService.MagneticStripeReaderTrackIds.track4;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs = function() {};
 /** @type {!Windows.Devices.PointOfService.MagneticStripeReaderReport} */
Windows.Devices.PointOfService.MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs.prototype.report;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.PosPrinter = function() {};
 /** @type {!Windows.Devices.PointOfService.PosPrinterCapabilities} */
Windows.Devices.PointOfService.PosPrinter.prototype.capabilities;
 /** @type {string} */
Windows.Devices.PointOfService.PosPrinter.prototype.deviceId;
 /** @type {function(?): void} */
Windows.Devices.PointOfService.PosPrinter.prototype.onstatusupdated;
 /** @type {!Windows.Devices.PointOfService.PosPrinterStatus} */
Windows.Devices.PointOfService.PosPrinter.prototype.status;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Devices.PointOfService.PosPrinter.prototype.supportedCharacterSets;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Devices.PointOfService.PosPrinter.prototype.supportedTypeFaces;

/**
 * Creates a PosPrinter object for point-of-service printer with the specified DeviceInformation.Id .
 * @param {string} deviceId The DeviceInformation.Id that identifies a specific point-of-service printer.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.PointOfService.PosPrinter, !Windows.Foundation.IAsyncOperation<!Windows.Devices.PointOfService.PosPrinter>>} The point-of-service printer that the unique device identifier identifies. Returns a null object in the following cases:
 */
Windows.Devices.PointOfService.PosPrinter.fromIdAsync = function(deviceId) {};

/**
 * Gets the default paired or locally-connected printer.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.PointOfService.PosPrinter, !Windows.Foundation.IAsyncOperation<!Windows.Devices.PointOfService.PosPrinter>>} The default locally-connected printer.
 */
Windows.Devices.PointOfService.PosPrinter.getDefaultAsync = function() {};

/**
 * Gets an Advanced Query Syntax (AQS) string that you can use to list the available point-of-service printers.
 * @return {string} An Advanced Query Syntax (AQS) string that you can use to list the available point-of-service printers.
 */
Windows.Devices.PointOfService.PosPrinter.getDeviceSelector = function() {};

/**
 * Gets the health state of the point-of-service printer asynchronously.
 * @param {Windows.Devices.PointOfService.UnifiedPosHealthCheckLevel} level The type of health check that you want to perform for the point-of-service printer. Only level POSInternal(1) should be used, as any other UnifiedPosHealthCheckLevel levels will result in an error.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} An asynchronous operation that returns the health state of the point-of-service printer. You should display this value in the app interface immediately so the user of the app can interpret the value. For example, the operation returns OK as the health state if the state of the point-of-service printer is good.
 */
Windows.Devices.PointOfService.PosPrinter.prototype.checkHealthAsync = function(level) {};

/**
 * Claims the point-of-service printer for use, and gets an instance of the ClaimedPosPrinter class for the point-of-service printer.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.PointOfService.ClaimedPosPrinter, !Windows.Foundation.IAsyncOperation<!Windows.Devices.PointOfService.ClaimedPosPrinter>>} The claimed point-of-service printer.
 */
Windows.Devices.PointOfService.PosPrinter.prototype.claimPrinterAsync = function() {};

/**
 * Gets the specified statistics from the point-of-service printer.
 * @param {!Windows.Foundation.Collections.IIterable<string>} statisticsCategories The list of statistics to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} The requested statistics.
 */
Windows.Devices.PointOfService.PosPrinter.prototype.getStatisticsAsync = function(statisticsCategories) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.PosPrinter.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.PointOfService.PosPrinter.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Devices.PointOfService.PosPrinterAlignment = {};
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterAlignment.left;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterAlignment.center;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterAlignment.right;

/** @const */
Windows.Devices.PointOfService.PosPrinterBarcodeTextPosition = {};
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterBarcodeTextPosition.none;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterBarcodeTextPosition.above;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterBarcodeTextPosition.below;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.PosPrinterCapabilities = function() {};
 /** @type {boolean} */
Windows.Devices.PointOfService.PosPrinterCapabilities.prototype.canMapCharacterSet;
 /** @type {number} */
Windows.Devices.PointOfService.PosPrinterCapabilities.prototype.defaultCharacterSet;
 /** @type {boolean} */
Windows.Devices.PointOfService.PosPrinterCapabilities.prototype.hasCoverSensor;
 /** @type {boolean} */
Windows.Devices.PointOfService.PosPrinterCapabilities.prototype.isStatisticsReportingSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.PosPrinterCapabilities.prototype.isStatisticsUpdatingSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.PosPrinterCapabilities.prototype.isTransactionSupported;
 /** @type {!Windows.Devices.PointOfService.JournalPrinterCapabilities} */
Windows.Devices.PointOfService.PosPrinterCapabilities.prototype.journal;
 /** @type {Windows.Devices.PointOfService.UnifiedPosPowerReportingType} */
Windows.Devices.PointOfService.PosPrinterCapabilities.prototype.powerReportingType;
 /** @type {!Windows.Devices.PointOfService.ReceiptPrinterCapabilities} */
Windows.Devices.PointOfService.PosPrinterCapabilities.prototype.receipt;
 /** @type {!Windows.Devices.PointOfService.SlipPrinterCapabilities} */
Windows.Devices.PointOfService.PosPrinterCapabilities.prototype.slip;

/** @const */
Windows.Devices.PointOfService.PosPrinterCartridgeSensors = {};
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterCartridgeSensors.none;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterCartridgeSensors.removed;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterCartridgeSensors.empty;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterCartridgeSensors.headCleaning;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterCartridgeSensors.nearEnd;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.PosPrinterCharacterSetIds = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.PosPrinterCharacterSetIds.ansi;
 /** @type {number} */
Windows.Devices.PointOfService.PosPrinterCharacterSetIds.ascii;
 /** @type {number} */
Windows.Devices.PointOfService.PosPrinterCharacterSetIds.utf16LE;

/** @const */
Windows.Devices.PointOfService.PosPrinterColorCapabilities = {};
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCapabilities.none;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCapabilities.primary;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCapabilities.custom1;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCapabilities.custom2;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCapabilities.custom3;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCapabilities.custom4;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCapabilities.custom5;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCapabilities.custom6;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCapabilities.cyan;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCapabilities.magenta;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCapabilities.yellow;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCapabilities.full;

/** @const */
Windows.Devices.PointOfService.PosPrinterColorCartridge = {};
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCartridge.unknown;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCartridge.primary;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCartridge.custom1;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCartridge.custom2;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCartridge.custom3;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCartridge.custom4;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCartridge.custom5;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCartridge.custom6;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCartridge.cyan;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCartridge.magenta;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterColorCartridge.yellow;

/** @const */
Windows.Devices.PointOfService.PosPrinterLineDirection = {};
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterLineDirection.horizontal;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterLineDirection.vertical;

/** @const */
Windows.Devices.PointOfService.PosPrinterLineStyle = {};
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterLineStyle.singleSolid;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterLineStyle.doubleSolid;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterLineStyle.broken;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterLineStyle.chain;

/** @const */
Windows.Devices.PointOfService.PosPrinterMapMode = {};
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterMapMode.dots;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterMapMode.twips;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterMapMode.english;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterMapMode.metric;

/** @const */
Windows.Devices.PointOfService.PosPrinterMarkFeedCapabilities = {};
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterMarkFeedCapabilities.none;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterMarkFeedCapabilities.toTakeUp;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterMarkFeedCapabilities.toCutter;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterMarkFeedCapabilities.toCurrentTopOfForm;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterMarkFeedCapabilities.toNextTopOfForm;

/** @const */
Windows.Devices.PointOfService.PosPrinterMarkFeedKind = {};
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterMarkFeedKind.toTakeUp;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterMarkFeedKind.toCutter;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterMarkFeedKind.toCurrentTopOfForm;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterMarkFeedKind.toNextTopOfForm;

/** @const */
Windows.Devices.PointOfService.PosPrinterPrintSide = {};
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterPrintSide.unknown;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterPrintSide.side1;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterPrintSide.side2;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.PosPrinterReleaseDeviceRequestedEventArgs = function() {};

/** @const */
Windows.Devices.PointOfService.PosPrinterRotation = {};
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterRotation.normal;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterRotation.right90;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterRotation.left90;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterRotation.rotate180;

/** @const */
Windows.Devices.PointOfService.PosPrinterRuledLineCapabilities = {};
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterRuledLineCapabilities.none;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterRuledLineCapabilities.horizontal;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterRuledLineCapabilities.vertical;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.PosPrinterStatus = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.PosPrinterStatus.prototype.extendedStatus;
 /** @type {Windows.Devices.PointOfService.PosPrinterStatusKind} */
Windows.Devices.PointOfService.PosPrinterStatus.prototype.statusKind;

/** @const */
Windows.Devices.PointOfService.PosPrinterStatusKind = {};
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterStatusKind.online;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterStatusKind.off;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterStatusKind.offline;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterStatusKind.offOrOffline;
/** @const {number} */
Windows.Devices.PointOfService.PosPrinterStatusKind.extended;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.PosPrinterStatusUpdatedEventArgs = function() {};
 /** @type {!Windows.Devices.PointOfService.PosPrinterStatus} */
Windows.Devices.PointOfService.PosPrinterStatusUpdatedEventArgs.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.ReceiptPrintJob = function() {};

/**
 * Adds an instruction to the printer job to cut the receipt paper completely.
 * Adds an instruction to the printer job to cut the specified percentage of the receipt paper.
 * @param {number=} percentage Decimal representation of the percentage of the receipt that the receipt printer should cut.
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.cutPaper = function(percentage) {};

/**
 * Adds an instruction to the print job to print a drawn, ruled line on the paper of the receipt printer station.
 * @param {string} positionList The position parameters for the ruled line. The character string for positionList differs depending on whether lineDirection specifies a horizontal ruled line or a vertical ruled line.
 * @param {Windows.Devices.PointOfService.PosPrinterLineDirection} lineDirection The direction in which to print the ruled line.
 * @param {number} lineWidth The width of the ruled line that the print should print. The unit of width is dot. If an unsupported value is specified, the best fit value for the printer is used.
 * @param {Windows.Devices.PointOfService.PosPrinterLineStyle} lineStyle The appearance of the ruled line, such as whether it is solid or broken, or single or double.
 * @param {number} lineColor The color of the ruled line, as an integer value that is equal to the value of the cartridge constant used in the ClaimedReceiptPrinter.ColorCartridge property. If an unsupported value is specified, the printing results may be unpredictable.
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.drawRuledLine = function(positionList, lineDirection, lineWidth, lineStyle, lineColor) {};

/**
 * Runs the print job on the receipt printer station asynchronously.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The operation to run the print job. This operation returns true if the print job succeeds; otherwise, the operation returns false.
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.executeAsync = function() {};

/**
 * Adds an instruction to the printer job to use the mark sensor of the receipt printer station to position the receipt paper.
 * @param {Windows.Devices.PointOfService.PosPrinterMarkFeedKind} kind An enumeration value that specifies how to position the receipt paper.
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.markFeed = function(kind) {};

/**
 * Adds an instruction to the print job to print the specified text on the receipt printer station.
 * @param {string} data The text to print on the receipt printer station.
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.print = function(data) {};

/**
 * Adds an instruction to the print job to print a barcode with the specified data and symbology on the receipt printer station.
 * @param {string} data The data to be represented as a barcode.
 * @param {number} symbology The symbology (encoding) of the barcode. This can be determined based on the BarcodeSymbologies class static methods.
 * @param {number} height The height of the barcode, in pixels.
 * @param {number} width The width of the barcode, in pixels.
 * @param {Windows.Devices.PointOfService.PosPrinterBarcodeTextPosition} textPosition The vertical position of the barcode text relative to the barcode.
 * @param {Windows.Devices.PointOfService.PosPrinterAlignment} alignment The horizontal alignment of the barcode on the page.
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.printBarcode = function(data, symbology, height, width, textPosition, alignment) {};

/**
 * Adds an instruction to the print job to print a barcode with the specified data, symbology, and custom alignment on the receipt printer station.
 * @param {string} data The data to be represented as a barcode.
 * @param {number} symbology The symbology (encoding) of the barcode.
 * @param {number} height The height of the barcode, in pixels.
 * @param {number} width The width of the barcode, in pixels.
 * @param {Windows.Devices.PointOfService.PosPrinterBarcodeTextPosition} textPosition The vertical position of the barcode text relative to the barcode.
 * @param {number} alignmentDistance The distance from the leftmost print column to the start of the barcode, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.printBarcodeCustomAlign = function(data, symbology, height, width, textPosition, alignmentDistance) {};

/**
 * Adds an instruction to the print job to print the specified bitmap with the specified width and a standard horizontal placement on the receipt printer station.
 * Adds an instruction to the print job to print the specified bitmap with the specified standard horizontal placement on the receipt printer station.
 * @param {!Windows.Graphics.Imaging.BitmapFrame} bitmap Information about the bitmap that you want to print.
 * @param {Windows.Devices.PointOfService.PosPrinterAlignment} alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
 * @param {number=} width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.printBitmap = function(bitmap, alignment, width) {};

/**
 * Adds an instruction to the print job to print the specified bitmap at the specified distance from the leftmost print column on the receipt printer station.
 * Adds an instruction to the print job to print the specified bitmap with the specified width and at the specified distance from the leftmost print column on the receipt printer station.
 * @param {!Windows.Graphics.Imaging.BitmapFrame} bitmap Information about the bitmap that you want to print.
 * @param {number} alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @param {number=} width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPriinter.MapMode property.
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.printCustomAlignedBitmap = function(bitmap, alignmentDistance, width) {};

/**
 * Adds an instruction to the print job to print a line of text on the receipt printer station.
 * Adds an instruction to the print job to print a newline character on the receipt printer station.
 * @param {string=} data The line of text to print.
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.printLine = function(data) {};

/**
 * Adds an instruction to the print job to print a bitmap on the receipt printer station by using the bitmap and information saved to the printer via SetBitmap or SetCustomAlignedBitmap .
 * @param {number} bitmapNumber The number that you assigned to the bitmap that you want to print when you called SetBitmap or SetCustomAlignedBitmap .
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.printSavedBitmap = function(bitmapNumber) {};

/**
 * Sets the rotation of the barcode on the page on the receipt printer station.
 * @param {Windows.Devices.PointOfService.PosPrinterRotation} value The rotation of the barcode on the page.
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.setBarcodeRotation = function(value) {};

/**
 * Saves information about a bitmap and a standard horizontal placement that you want to use to print that bitmap on the receipt printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * Saves information about a bitmap, along with the width and a standard horizontal placement that you want to use to print that bitmap on the receipt printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * @param {number} bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
 * @param {!Windows.Graphics.Imaging.BitmapFrame} bitmap Information about the bitmap that you want to print.
 * @param {Windows.Devices.PointOfService.PosPrinterAlignment} alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
 * @param {number=} width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.setBitmap = function(bitmapNumber, bitmap, alignment, width) {};

/**
 * Saves information about a bitmap and the distance from the leftmost print column at which you want to print that bitmap on the receipt printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * Saves information about a bitmap, along with the width and the distance from the leftmost print column that you want to use to print that bitmap on the receipt printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * @param {number} bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
 * @param {!Windows.Graphics.Imaging.BitmapFrame} bitmap Information about the bitmap that you want to print.
 * @param {number} alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @param {number=} width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.setCustomAlignedBitmap = function(bitmapNumber, bitmap, alignmentDistance, width) {};

/**
 * Sets the area of the page on which the receipt printer station can print the job.
 * @param {!Windows.Foundation.Rect} value The area of the page on which the receipt printer can print the job.
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.setPrintArea = function(value) {};

/**
 * Sets the rotation of the text or image on the page for the receipt printer station.
 * @param {Windows.Devices.PointOfService.PosPrinterRotation} value The rotation of the text or image on the page for the receipt printer station.
 * @param {boolean} includeBitmaps Whether bitmaps should also be rotated. This setting takes effect only for subsequent calls to PrintBitmap , and may not apply to saved bitmaps that you print using PrintSavedBitmap .
 * @return {void}
 */
Windows.Devices.PointOfService.ReceiptPrintJob.prototype.setPrintRotation = function(value, includeBitmaps) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities = function() {};
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.canCutPaper;
 /** @type {Windows.Devices.PointOfService.PosPrinterCartridgeSensors} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.cartridgeSensors;
 /** @type {Windows.Devices.PointOfService.PosPrinterColorCapabilities} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.colorCartridgeCapabilities;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.is180RotationSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isBarcodeSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isBitmapSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isBoldSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isDoubleHighDoubleWidePrintSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isDoubleHighPrintSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isDoubleWidePrintSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isDualColorSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isItalicSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isLeft90RotationSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isPaperEmptySensorSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isPaperNearEndSensorSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isPrintAreaSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isPrinterPresent;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isRight90RotationSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isStampSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.isUnderlineSupported;
 /** @type {Windows.Devices.PointOfService.PosPrinterMarkFeedCapabilities} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.markFeedCapabilities;
 /** @type {Windows.Devices.PointOfService.PosPrinterRuledLineCapabilities} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.ruledLineCapabilities;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Devices.PointOfService.PosPrinterRotation>} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.supportedBarcodeRotations;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Devices.PointOfService.PosPrinterRotation>} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.supportedBitmapRotations;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Devices.PointOfService.ReceiptPrinterCapabilities.prototype.supportedCharactersPerLine;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.SlipPrintJob = function() {};

/**
 * Adds an instruction to the print job to print a drawn, ruled line on the paper of the slip printer station.
 * @param {string} positionList The position parameters for the ruled line. The character string for positionList differs depending on whether lineDirection specifies a horizontal ruled line or a vertical ruled line.
 * @param {Windows.Devices.PointOfService.PosPrinterLineDirection} lineDirection The direction in which to print the ruled line.
 * @param {number} lineWidth The width of the ruled line that the print should print. The unit of width is dot. If an unsupported value is specified, the best fit value for the printer is used.
 * @param {Windows.Devices.PointOfService.PosPrinterLineStyle} lineStyle The appearance of the ruled line, such as whether it is solid or broken, or single or double.
 * @param {number} lineColor The color of the ruled line, as an integer value that is equal to the value of the cartridge constant used in the ClaimedSlipPrinter.ColorCartridge property. If an unsupported value is specified, the printing results may be unpredictable.
 * @return {void}
 */
Windows.Devices.PointOfService.SlipPrintJob.prototype.drawRuledLine = function(positionList, lineDirection, lineWidth, lineStyle, lineColor) {};

/**
 * Runs the print job on the slip printer station asynchronously.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The operation to run the print job. This operation returns true if the print job succeeds; otherwise, the operation returns false.
 */
Windows.Devices.PointOfService.SlipPrintJob.prototype.executeAsync = function() {};

/**
 * Adds an instruction to the print job to print the specified text on the slip printer station.
 * @param {string} data The text to print on the slip printer station.
 * @return {void}
 */
Windows.Devices.PointOfService.SlipPrintJob.prototype.print = function(data) {};

/**
 * Adds an instruction to the print job to print a barcode on the slip printer station with the specified data and symbology.
 * @param {string} data The data to represent as a barcode.
 * @param {number} symbology The symbology (encoding) of the barcode.
 * @param {number} height The height of the barcode, in pixels.
 * @param {number} width The width of the barcode, in pixels.
 * @param {Windows.Devices.PointOfService.PosPrinterBarcodeTextPosition} textPosition The vertical position of the barcode text relative to the barcode.
 * @param {Windows.Devices.PointOfService.PosPrinterAlignment} alignment The horizontal alignment of the barcode on the page.
 * @return {void}
 */
Windows.Devices.PointOfService.SlipPrintJob.prototype.printBarcode = function(data, symbology, height, width, textPosition, alignment) {};

/**
 * Adds an instruction to the print job to print a barcode on the slip printer station with the specified data, symbology, and custom alignment.
 * @param {string} data The data to represent as a barcode.
 * @param {number} symbology The symbology (encoding) of the barcode.
 * @param {number} height The height of the barcode, in pixels.
 * @param {number} width The width of the barcode, in pixels.
 * @param {Windows.Devices.PointOfService.PosPrinterBarcodeTextPosition} textPosition The vertical position of the barcode text relative to the barcode.
 * @param {number} alignmentDistance The distance from the leftmost print column to the start of the barcode, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @return {void}
 */
Windows.Devices.PointOfService.SlipPrintJob.prototype.printBarcodeCustomAlign = function(data, symbology, height, width, textPosition, alignmentDistance) {};

/**
 * Adds an instruction to the print job to print the specified bitmap with the specified width and a standard horizontal placement on the slip printer station.
 * Adds an instruction to the print job to print the specified bitmap with the specified standard horizontal placement on the slip printer station.
 * @param {!Windows.Graphics.Imaging.BitmapFrame} bitmap Information about the bitmap that you want to print.
 * @param {Windows.Devices.PointOfService.PosPrinterAlignment} alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
 * @param {number=} width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @return {void}
 */
Windows.Devices.PointOfService.SlipPrintJob.prototype.printBitmap = function(bitmap, alignment, width) {};

/**
 * Adds an instruction to the print job to print the specified bitmap at the specified distance from the leftmost print column on the slip printer station.
 * Adds an instruction to the print job to print the specified bitmap with the specified width and at the specified distance from the leftmost print column on the slip printer station.
 * @param {!Windows.Graphics.Imaging.BitmapFrame} bitmap Information about the bitmap that you want to print.
 * @param {number} alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @param {number=} width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @return {void}
 */
Windows.Devices.PointOfService.SlipPrintJob.prototype.printCustomAlignedBitmap = function(bitmap, alignmentDistance, width) {};

/**
 * Adds an instruction to the print job to print a line of text on the slip printer station.
 * Adds an instruction to the print job to print a newline character on the slip printer station.
 * @param {string=} data The line of text to print.
 * @return {void}
 */
Windows.Devices.PointOfService.SlipPrintJob.prototype.printLine = function(data) {};

/**
 * Adds an instruction to the print job to print a bitmap on the slip printer station by using the information that you saved about the bitmap and how to print it when you called the SetBitmap or SetCustomAlignedBitmap method.
 * @param {number} bitmapNumber The number that you assigned to the bitmap that you want to print when you called SetBitmap or SetCustomAlignedBitmap .
 * @return {void}
 */
Windows.Devices.PointOfService.SlipPrintJob.prototype.printSavedBitmap = function(bitmapNumber) {};

/**
 * Sets the rotation of the barcode on the page on the slip printer station.
 * @param {Windows.Devices.PointOfService.PosPrinterRotation} value The rotation of the barcode on the page on the slip printer station.
 * @return {void}
 */
Windows.Devices.PointOfService.SlipPrintJob.prototype.setBarcodeRotation = function(value) {};

/**
 * Saves information about a bitmap and a standard horizontal placement that you want to use to print that bitmap on the slip printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * Saves information about a bitmap, along with the width and a standard horizontal placement that you want to use to print that bitmap on the slip printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * @param {number} bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
 * @param {!Windows.Graphics.Imaging.BitmapFrame} bitmap Information about the bitmap that you want to print.
 * @param {Windows.Devices.PointOfService.PosPrinterAlignment} alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
 * @param {number=} width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @return {void}
 */
Windows.Devices.PointOfService.SlipPrintJob.prototype.setBitmap = function(bitmapNumber, bitmap, alignment, width) {};

/**
 * Saves information about a bitmap and the distance from the leftmost print column at which you want to print that bitmap on the slip printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * Saves information about a bitmap, along with the width and the distance from the leftmost print column that you want to use to print that bitmap on the slip printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
 * @param {number} bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
 * @param {!Windows.Graphics.Imaging.BitmapFrame} bitmap Information about the bitmap that you want to print.
 * @param {number} alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @param {number=} width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
 * @return {void}
 */
Windows.Devices.PointOfService.SlipPrintJob.prototype.setCustomAlignedBitmap = function(bitmapNumber, bitmap, alignmentDistance, width) {};

/**
 * Sets the area of the page on which the slip printer station can print the job.
 * @param {!Windows.Foundation.Rect} value The area of the page on which the slip printer station can print the job.
 * @return {void}
 */
Windows.Devices.PointOfService.SlipPrintJob.prototype.setPrintArea = function(value) {};

/**
 * Sets the rotation of the text or image on the page on the slip printer station.
 * @param {Windows.Devices.PointOfService.PosPrinterRotation} value The rotation of the text or image on the page.
 * @param {boolean} includeBitmaps Whether bitmaps should also be rotated. This setting takes effect only for subsequent calls to PrintBitmap , and may not apply to saved bitmaps that you print using PrintSavedBitmap .
 * @return {void}
 */
Windows.Devices.PointOfService.SlipPrintJob.prototype.setPrintRotation = function(value, includeBitmaps) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.SlipPrinterCapabilities = function() {};
 /** @type {Windows.Devices.PointOfService.PosPrinterCartridgeSensors} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.cartridgeSensors;
 /** @type {Windows.Devices.PointOfService.PosPrinterColorCapabilities} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.colorCartridgeCapabilities;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.is180RotationSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isBarcodeSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isBitmapSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isBoldSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isBothSidesPrintingSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isDoubleHighDoubleWidePrintSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isDoubleHighPrintSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isDoubleWidePrintSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isDualColorSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isFullLengthSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isItalicSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isLeft90RotationSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isPaperEmptySensorSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isPaperNearEndSensorSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isPrintAreaSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isPrinterPresent;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isRight90RotationSupported;
 /** @type {boolean} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.isUnderlineSupported;
 /** @type {Windows.Devices.PointOfService.PosPrinterRuledLineCapabilities} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.ruledLineCapabilities;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Devices.PointOfService.PosPrinterRotation>} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.supportedBarcodeRotations;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Devices.PointOfService.PosPrinterRotation>} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.supportedBitmapRotations;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Devices.PointOfService.SlipPrinterCapabilities.prototype.supportedCharactersPerLine;
/**
 * @constructor
 * @struct
 */
Windows.Devices.PointOfService.UnifiedPosErrorData = function() {};
 /** @type {number} */
Windows.Devices.PointOfService.UnifiedPosErrorData.prototype.extendedReason;
 /** @type {string} */
Windows.Devices.PointOfService.UnifiedPosErrorData.prototype.message;
 /** @type {Windows.Devices.PointOfService.UnifiedPosErrorReason} */
Windows.Devices.PointOfService.UnifiedPosErrorData.prototype.reason;
 /** @type {Windows.Devices.PointOfService.UnifiedPosErrorSeverity} */
Windows.Devices.PointOfService.UnifiedPosErrorData.prototype.severity;

/** @const */
Windows.Devices.PointOfService.UnifiedPosErrorReason = {};
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorReason.unknownErrorReason;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorReason.noService;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorReason.disabled;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorReason.illegal;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorReason.noHardware;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorReason.closed;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorReason.offline;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorReason.failure;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorReason.timeout;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorReason.busy;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorReason.extended;

/** @const */
Windows.Devices.PointOfService.UnifiedPosErrorSeverity = {};
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorSeverity.unknownErrorSeverity;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorSeverity.warning;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorSeverity.recoverable;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorSeverity.unrecoverable;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorSeverity.assistanceRequired;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosErrorSeverity.fatal;

/** @const */
Windows.Devices.PointOfService.UnifiedPosHealthCheckLevel = {};
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosHealthCheckLevel.unknownHealthCheckLevel;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosHealthCheckLevel.posinternal;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosHealthCheckLevel.external;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosHealthCheckLevel.interactive;

/** @const */
Windows.Devices.PointOfService.UnifiedPosPowerReportingType = {};
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosPowerReportingType.unknownPowerReportingType;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosPowerReportingType.standard;
/** @const {number} */
Windows.Devices.PointOfService.UnifiedPosPowerReportingType.advanced;
/** @const */
Windows.Devices.Portable = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Portable.ServiceDevice = function() {};

/**
 * Returns an Advanced Query Syntax (AQS) string that is used to enumerate device services of the specified ServiceDeviceType . This string is passed to the FindAllAsync or CreateWatcher method.
 * @param {Windows.Devices.Portable.ServiceDeviceType} serviceType The type of service to identify.
 * @return {string} The AQS string.
 */
Windows.Devices.Portable.ServiceDevice.getDeviceSelector = function(serviceType) {};

/**
 * An Advanced Query Syntax (AQS) string for identifying a device service by its GUIDs. This string is passed to the FindAllAsync or CreateWatcher method.
 * @param {string} serviceId The service identifier.
 * @return {string} The AQS string.
 */
Windows.Devices.Portable.ServiceDevice.getDeviceSelectorFromServiceId = function(serviceId) {};

/** @const */
Windows.Devices.Portable.ServiceDeviceType = {};
/** @const {number} */
Windows.Devices.Portable.ServiceDeviceType.calendarService;
/** @const {number} */
Windows.Devices.Portable.ServiceDeviceType.contactsService;
/** @const {number} */
Windows.Devices.Portable.ServiceDeviceType.deviceStatusService;
/** @const {number} */
Windows.Devices.Portable.ServiceDeviceType.notesService;
/** @const {number} */
Windows.Devices.Portable.ServiceDeviceType.ringtonesService;
/** @const {number} */
Windows.Devices.Portable.ServiceDeviceType.smsService;
/** @const {number} */
Windows.Devices.Portable.ServiceDeviceType.tasksService;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Portable.StorageDevice = function() {};

/**
 * Gets a StorageFolder object from a DeviceInformation Id for a removable storage device.
 * @param {string} DeviceId The DeviceInformation ID that identifies the removable storage device. This id can be retrieved from Windows.Devices.Enumeration or the DeviceInformationId property of the AutoPlay device event arguments. For more information, see Quickstart: Register an app for an AutoPlay device. In order for FromId to succeed, the app must declare both the removableStorage capability as shown in the App capability declarations and file type associations for the files it wishes to access on the device as shown in How to handle file activation. For more information, see the Removable Storage sample.
 * @return {!Windows.Storage.StorageFolder} The storage folder object that represents the removable storage device and provides access to content on the device.
 */
Windows.Devices.Portable.StorageDevice.fromId = function(DeviceId) {};

/**
 * An Advanced Query Syntax (AQS) string for identifying removable storage devices. This string is passed to the FindAllAsync or CreateWatcher method.
 * @return {string} An AQS string for identifying storage devices.
 */
Windows.Devices.Portable.StorageDevice.getDeviceSelector = function() {};
/** @const */
Windows.Devices.Power = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Power.Battery = function() {};
 /** @type {!Windows.Devices.Power.Battery} */
Windows.Devices.Power.Battery.aggregateBattery;
 /** @type {string} */
Windows.Devices.Power.Battery.prototype.deviceId;
 /** @type {function(?): void} */
Windows.Devices.Power.Battery.prototype.onreportupdated;

/**
 * Gets a Battery object that represents an individual battery controller connected to the device.
 * @param {string} deviceId The device ID of the battery controller ( DeviceId ).
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Power.Battery, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Power.Battery>>} A Battery object that corresponds to the specified battery controller.
 */
Windows.Devices.Power.Battery.fromIdAsync = function(deviceId) {};

/**
 * Gets an Advanced Query Syntax (AQS) string that can be used to find all battery controllers that are connected to the device.
 * @return {string} An AQS string that can be used to find all battery controllers connected to the device.
 */
Windows.Devices.Power.Battery.getDeviceSelector = function() {};

/**
 * Gets a BatteryReport object that indicates the charge, capacity, and status of the battery or aggregate.
 * @return {!Windows.Devices.Power.BatteryReport} Indicates the charge, capacity, and status of the battery or aggregate.
 */
Windows.Devices.Power.Battery.prototype.getReport = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Power.Battery.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Power.Battery.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Power.BatteryReport = function() {};
 /** @type {number} */
Windows.Devices.Power.BatteryReport.prototype.chargeRateInMilliwatts;
 /** @type {number} */
Windows.Devices.Power.BatteryReport.prototype.designCapacityInMilliwattHours;
 /** @type {number} */
Windows.Devices.Power.BatteryReport.prototype.fullChargeCapacityInMilliwattHours;
 /** @type {number} */
Windows.Devices.Power.BatteryReport.prototype.remainingCapacityInMilliwattHours;
 /** @type {Windows.System.Power.BatteryStatus} */
Windows.Devices.Power.BatteryReport.prototype.status;
/** @const */
Windows.Devices.Printers = {};
/** @const */
Windows.Devices.Printers.Extensions = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Printers.Extensions.Print3DWorkflow = function() {};
 /** @type {string} */
Windows.Devices.Printers.Extensions.Print3DWorkflow.prototype.deviceID;
 /** @type {boolean} */
Windows.Devices.Printers.Extensions.Print3DWorkflow.prototype.isPrintReady;
 /** @type {function(?): void} */
Windows.Devices.Printers.Extensions.Print3DWorkflow.prototype.onprintrequested;

/**
 * Gets the model of the 3D object to be printed.
 * @return {?} The model of the 3D object to be printed.
 */
Windows.Devices.Printers.Extensions.Print3DWorkflow.prototype.getPrintModelPackage = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Printers.Extensions.Print3DWorkflow.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Printers.Extensions.Print3DWorkflow.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Devices.Printers.Extensions.Print3DWorkflowDetail = {};
/** @const {number} */
Windows.Devices.Printers.Extensions.Print3DWorkflowDetail.unknown;
/** @const {number} */
Windows.Devices.Printers.Extensions.Print3DWorkflowDetail.modelExceedsPrintBed;
/** @const {number} */
Windows.Devices.Printers.Extensions.Print3DWorkflowDetail.uploadFailed;
/** @const {number} */
Windows.Devices.Printers.Extensions.Print3DWorkflowDetail.invalidMaterialSelection;
/** @const {number} */
Windows.Devices.Printers.Extensions.Print3DWorkflowDetail.invalidModel;
/** @const {number} */
Windows.Devices.Printers.Extensions.Print3DWorkflowDetail.modelNotManifold;
/** @const {number} */
Windows.Devices.Printers.Extensions.Print3DWorkflowDetail.invalidPrintTicket;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Printers.Extensions.Print3DWorkflowPrintRequestedEventArgs = function() {};
 /** @type {Windows.Devices.Printers.Extensions.Print3DWorkflowStatus} */
Windows.Devices.Printers.Extensions.Print3DWorkflowPrintRequestedEventArgs.prototype.status;

/**
 * Sets the extended status of the print request.
 * @param {Windows.Devices.Printers.Extensions.Print3DWorkflowDetail} value The extended status of the print request.
 * @return {void}
 */
Windows.Devices.Printers.Extensions.Print3DWorkflowPrintRequestedEventArgs.prototype.setExtendedStatus = function(value) {};

/**
 * Sets the latest model data, including any updates made by the Print3DWorkflow .
 * @param {?} source The latest model data, including any updates made by the Print3DWorkflow .
 * @return {void}
 */
Windows.Devices.Printers.Extensions.Print3DWorkflowPrintRequestedEventArgs.prototype.setSource = function(source) {};

/**
 * Indicates if the data model has been updated by the Print3DWorkflow .
 * @param {boolean} value Returns true if the data model has been updated; otherwise, false.
 * @return {void}
 */
Windows.Devices.Printers.Extensions.Print3DWorkflowPrintRequestedEventArgs.prototype.setSourceChanged = function(value) {};

/** @const */
Windows.Devices.Printers.Extensions.Print3DWorkflowStatus = {};
/** @const {number} */
Windows.Devices.Printers.Extensions.Print3DWorkflowStatus.abandoned;
/** @const {number} */
Windows.Devices.Printers.Extensions.Print3DWorkflowStatus.canceled;
/** @const {number} */
Windows.Devices.Printers.Extensions.Print3DWorkflowStatus.failed;
/** @const {number} */
Windows.Devices.Printers.Extensions.Print3DWorkflowStatus.slicing;
/** @const {number} */
Windows.Devices.Printers.Extensions.Print3DWorkflowStatus.submitted;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Printers.Extensions.PrintExtensionContext = function() {};

/**
 * Gets the context for the printer extension object based on the DeviceInformation ID.
 * @param {string} deviceId The device information ID for the print device.
 * @return {?} Pointer to the context.
 */
Windows.Devices.Printers.Extensions.PrintExtensionContext.fromDeviceId = function(deviceId) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Printers.Extensions.PrintNotificationEventDetails = function() {};
 /** @type {string} */
Windows.Devices.Printers.Extensions.PrintNotificationEventDetails.prototype.eventData;
 /** @type {string} */
Windows.Devices.Printers.Extensions.PrintNotificationEventDetails.prototype.printerName;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Printers.Extensions.PrintTaskConfiguration = function() {};
 /** @type {function(?): void} */
Windows.Devices.Printers.Extensions.PrintTaskConfiguration.prototype.onsaverequested;
 /** @type {?} */
Windows.Devices.Printers.Extensions.PrintTaskConfiguration.prototype.printerExtensionContext;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Printers.Extensions.PrintTaskConfiguration.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Printers.Extensions.PrintTaskConfiguration.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest = function() {};
 /** @type {!Date} */
Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest.prototype.deadline;

/**
 * Called by the device app to cancel the client's request to save the print task configuration.
 * @return {void}
 */
Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest.prototype.cancel = function() {};

/**
 * Called by the device app when it has to complete some asynchronous tasks before it can save the print task configuration information.
 * @return {!Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedDeferral} The object that represents the deferral for the print task configuration save request.
 */
Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest.prototype.getDeferral = function() {};

/**
 * Called by the device app to save the print task configuration.
 * @param {?} printerExtensionContext The object that represents the print task extension context.
 * @return {void}
 */
Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest.prototype.save = function(printerExtensionContext) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedDeferral = function() {};

/**
 * Called by the device app when the deferral is completed.
 * @return {void}
 */
Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs = function() {};
 /** @type {!Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest} */
Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs.prototype.request;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Printers.Print3DDevice = function() {};
 /** @type {!Windows.Devices.Printers.PrintSchema} */
Windows.Devices.Printers.Print3DDevice.prototype.printSchema;

/**
 * Creates a Print3DDevice object that represents a 3D printer connected to the device.
 * @param {string} deviceId The device ID of the 3D printer.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Printers.Print3DDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Printers.Print3DDevice>>} A Print3DDevice object that corresponds to the specified 3D printer.
 */
Windows.Devices.Printers.Print3DDevice.fromIdAsync = function(deviceId) {};

/**
 * Gets an Advanced Query Syntax (AQS) string that can be used to find all 3D printers that are connected to the device.
 * @return {string} An AQS string that can be used to find all 3D printers connected to the device.
 */
Windows.Devices.Printers.Print3DDevice.getDeviceSelector = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Printers.PrintSchema = function() {};

/**
 * Gets the 3D printer capabilities.
 * @param {!Windows.Storage.Streams.IRandomAccessStreamWithContentType} constrainTicket The print ticket.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType>>} An XML PrintCapabilities document containing 3D printer capabilities.
 */
Windows.Devices.Printers.PrintSchema.prototype.getCapabilitiesAsync = function(constrainTicket) {};

/**
 * Gets the 3D printer's default print ticket.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType>>} An XML PrintTicket document containing the 3D printer's default print ticket.
 */
Windows.Devices.Printers.PrintSchema.prototype.getDefaultPrintTicketAsync = function() {};

/**
 * Creates a new print ticket by merging the users selection with the default print ticket and validating that it will work for the device.
 * @param {!Windows.Storage.Streams.IRandomAccessStreamWithContentType} deltaTicket The delta print ticket, specifies the differences between the default print ticket and the user's selections.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType>>} An XML PrintTicket document containing the suggested print ticket.
 */
Windows.Devices.Printers.PrintSchema.prototype.mergeAndValidateWithDefaultPrintTicketAsync = function(deltaTicket) {};
/** @const */
Windows.Devices.Pwm = {};
/** @const */
Windows.Devices.Pwm.Provider = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Pwm.PwmController = function() {};
 /** @type {?} */
Windows.Devices.Pwm.PwmController.getControllersAsync;
 /** @type {?} */
Windows.Devices.Pwm.PwmController.getDefaultAsync;
 /** @type {?} */
Windows.Devices.Pwm.PwmController.prototype.actualFrequency;
 /** @type {?} */
Windows.Devices.Pwm.PwmController.prototype.maxFrequency;
 /** @type {?} */
Windows.Devices.Pwm.PwmController.prototype.minFrequency;
 /** @type {?} */
Windows.Devices.Pwm.PwmController.prototype.openPin;
 /** @type {?} */
Windows.Devices.Pwm.PwmController.prototype.pinCount;
 /** @type {?} */
Windows.Devices.Pwm.PwmController.prototype.setDesiredFrequency;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Pwm.PwmPin = function() {};
 /** @type {?} */
Windows.Devices.Pwm.PwmPin.prototype.close;
 /** @type {?} */
Windows.Devices.Pwm.PwmPin.prototype.controller;
 /** @type {?} */
Windows.Devices.Pwm.PwmPin.prototype.getActiveDutyCyclePercentage;
 /** @type {?} */
Windows.Devices.Pwm.PwmPin.prototype.isStarted;
 /** @type {?} */
Windows.Devices.Pwm.PwmPin.prototype.polarity;
 /** @type {?} */
Windows.Devices.Pwm.PwmPin.prototype.setActiveDutyCyclePercentage;
 /** @type {?} */
Windows.Devices.Pwm.PwmPin.prototype.start;
 /** @type {?} */
Windows.Devices.Pwm.PwmPin.prototype.stop;
/** @const */
Windows.Devices.Pwm.PwmPulsePolarity = {};
 /** @type {?} */
Windows.Devices.Pwm.PwmPulsePolarity.activeHigh;
 /** @type {?} */
Windows.Devices.Pwm.PwmPulsePolarity.activeLow;
/** @const */
Windows.Devices.Radios = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Radios.Radio = function() {};
 /** @type {Windows.Devices.Radios.RadioKind} */
Windows.Devices.Radios.Radio.prototype.kind;
 /** @type {string} */
Windows.Devices.Radios.Radio.prototype.name;
 /** @type {function(?): void} */
Windows.Devices.Radios.Radio.prototype.onstatechanged;
 /** @type {Windows.Devices.Radios.RadioState} */
Windows.Devices.Radios.Radio.prototype.state;

/**
 * A static method that retrieves a Radio object corresponding to a device Id obtained through Windows.Devices.Enumeration.DeviceInformation.FindAllAsync and related APIs.
 * @param {string} deviceId A string that identifies a particular radio device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Radios.Radio, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Radios.Radio>>} An asynchronous retrieval operation. On successful completion, it contains a Radio object that represents the specified radio device.
 */
Windows.Devices.Radios.Radio.fromIdAsync = function(deviceId) {};

/**
 * A static method that returns an Advanced Query Syntax (AQS) string to be used to enumerate or monitor Radio devices with Windows.Devices.Enumeration.DeviceInformation.FindAllAsync and related methods.
 * @return {string} An identifier to be used to enumerate radio devices.
 */
Windows.Devices.Radios.Radio.getDeviceSelector = function() {};

/**
 * A static, asynchronous method that retrieves a collection of Windows.Devices.Radios.Radio objects representing radio devices existing on the system.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous retrieval operation. When the operation is complete, contains a list of Windows.Devices.Radios.Radio objects describing available radios.
 */
Windows.Devices.Radios.Radio.getRadiosAsync = function() {};

/**
 * An asynchronous method that retrieves a value indicating what access the current user has to the radio represented by this object. In circumstances where user permission is required to access the radio, this method prompts the user for permission. Consequently, always call this method on the UI thread.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Devices.Radios.RadioAccessStatus, !Windows.Foundation.IAsyncOperation<Windows.Devices.Radios.RadioAccessStatus>>} An asynchronous status retrieval operation. On successful completion, contains an enumeration value describing the current user's access to this radio.
 */
Windows.Devices.Radios.Radio.requestAccessAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Radios.Radio.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Radios.Radio.prototype.removeEventListener = function(type, listener) {};

/**
 * An asynchronous operation that attempts to set the state of the radio represented by this object.
 * @param {Windows.Devices.Radios.RadioState} value The desired radio state.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Devices.Radios.RadioAccessStatus, !Windows.Foundation.IAsyncOperation<Windows.Devices.Radios.RadioAccessStatus>>} An asynchronous state setting operation. On successful completion, contains an enumeration value describing status of the state change request.
 */
Windows.Devices.Radios.Radio.prototype.setStateAsync = function(value) {};

/** @const */
Windows.Devices.Radios.RadioAccessStatus = {};
/** @const {number} */
Windows.Devices.Radios.RadioAccessStatus.unspecified;
/** @const {number} */
Windows.Devices.Radios.RadioAccessStatus.allowed;
/** @const {number} */
Windows.Devices.Radios.RadioAccessStatus.deniedByUser;
/** @const {number} */
Windows.Devices.Radios.RadioAccessStatus.deniedBySystem;

/** @const */
Windows.Devices.Radios.RadioKind = {};
/** @const {number} */
Windows.Devices.Radios.RadioKind.other;
/** @const {number} */
Windows.Devices.Radios.RadioKind.wiFi;
/** @const {number} */
Windows.Devices.Radios.RadioKind.mobileBroadband;
/** @const {number} */
Windows.Devices.Radios.RadioKind.bluetooth;
/** @const {number} */
Windows.Devices.Radios.RadioKind.fm;

/** @const */
Windows.Devices.Radios.RadioState = {};
/** @const {number} */
Windows.Devices.Radios.RadioState.unknown;
/** @const {number} */
Windows.Devices.Radios.RadioState.on;
/** @const {number} */
Windows.Devices.Radios.RadioState.off;
/** @const {number} */
Windows.Devices.Radios.RadioState.disabled;
/** @const */
Windows.Devices.Scanners = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Scanners.ImageScanner = function() {};
 /** @type {!Windows.Devices.Scanners.ImageScannerAutoConfiguration} */
Windows.Devices.Scanners.ImageScanner.prototype.autoConfiguration;
 /** @type {Windows.Devices.Scanners.ImageScannerScanSource} */
Windows.Devices.Scanners.ImageScanner.prototype.defaultScanSource;
 /** @type {string} */
Windows.Devices.Scanners.ImageScanner.prototype.deviceId;
 /** @type {!Windows.Devices.Scanners.ImageScannerFeederConfiguration} */
Windows.Devices.Scanners.ImageScanner.prototype.feederConfiguration;
 /** @type {!Windows.Devices.Scanners.ImageScannerFlatbedConfiguration} */
Windows.Devices.Scanners.ImageScanner.prototype.flatbedConfiguration;

/**
 * Creates an instance of a ImageScanner object based on a scanners device information ID. This method is required for broker device enumeration.
 * @param {string} deviceId The device information ID. See DeviceInformation.Id property.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Scanners.ImageScanner, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Scanners.ImageScanner>>} The ImageScanner object.
 */
Windows.Devices.Scanners.ImageScanner.fromIdAsync = function(deviceId) {};

/**
 * Returns the class selection string that apps can use to enumerate scanner devices. This method is required for the brokered device enumeration.
 * @return {string} The class selection.
 */
Windows.Devices.Scanners.ImageScanner.getDeviceSelector = function() {};

/**
 * Determines if the specified scan source supports scan preview.
 * @param {Windows.Devices.Scanners.ImageScannerScanSource} scanSource The scan source.
 * @return {boolean} Returns True if the specified scan source supports preview; otherwise False.
 */
Windows.Devices.Scanners.ImageScanner.prototype.isPreviewSupported = function(scanSource) {};

/**
 * Determines if the specified scan source is available on the scanner.
 * @param {Windows.Devices.Scanners.ImageScannerScanSource} value The scan source.
 * @return {boolean} True if the scan source, Flatbed or Feeder, is available; otherwise False.
 */
Windows.Devices.Scanners.ImageScanner.prototype.isScanSourceSupported = function(value) {};

/**
 * Starts a scan job with the specified scan source and writes one or multiple images to one multi-page file like TIFF, XPS, and PDF; or one or multiple single-page files like DIB, PNG, JPG, and TIFF to the specified folder location. Returns the progress of the scan.
 * @param {Windows.Devices.Scanners.ImageScannerScanSource} scanSource The image scan source.
 * @param {!Windows.Storage.StorageFolder} storageFolder The target folder location of the scanned file.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Scanners.ImageScannerScanResult, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Devices.Scanners.ImageScannerScanResult, number>>} The list of scanned image files from ImageScannerScanResult and the progress of the WIA scan job from UInt32, which indicates how many files were transferred to the target folder.
 */
Windows.Devices.Scanners.ImageScanner.prototype.scanFilesToFolderAsync = function(scanSource, storageFolder) {};

/**
 * Scans one image from the specified scan source and applies the lowest scan resolution with the selected image file format.
 * @param {Windows.Devices.Scanners.ImageScannerScanSource} scanSource The image scan source.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} targetStream The scanned image file.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Scanners.ImageScannerPreviewResult, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Scanners.ImageScannerPreviewResult>>} The progress of the scan and the scanned file format.
 */
Windows.Devices.Scanners.ImageScanner.prototype.scanPreviewToStreamAsync = function(scanSource, targetStream) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Scanners.ImageScannerAutoConfiguration = function() {};
 /** @type {Windows.Devices.Scanners.ImageScannerFormat} */
Windows.Devices.Scanners.ImageScannerAutoConfiguration.prototype.defaultFormat;
 /** @type {Windows.Devices.Scanners.ImageScannerFormat} */
Windows.Devices.Scanners.ImageScannerAutoConfiguration.prototype.format;

/**
 * Determines if the input scanner supports the specified file format.
 * @param {Windows.Devices.Scanners.ImageScannerFormat} value The file type.
 * @return {boolean} True if the specified file type is supported; otherwise False.
 */
Windows.Devices.Scanners.ImageScannerAutoConfiguration.prototype.isFormatSupported = function(value) {};

/** @const */
Windows.Devices.Scanners.ImageScannerAutoCroppingMode = {};
/** @const {number} */
Windows.Devices.Scanners.ImageScannerAutoCroppingMode.disabled;
/** @const {number} */
Windows.Devices.Scanners.ImageScannerAutoCroppingMode.singleRegion;
/** @const {number} */
Windows.Devices.Scanners.ImageScannerAutoCroppingMode.multipleRegion;

/** @const */
Windows.Devices.Scanners.ImageScannerColorMode = {};
/** @const {number} */
Windows.Devices.Scanners.ImageScannerColorMode.color;
/** @const {number} */
Windows.Devices.Scanners.ImageScannerColorMode.grayscale;
/** @const {number} */
Windows.Devices.Scanners.ImageScannerColorMode.monochrome;
/** @const {number} */
Windows.Devices.Scanners.ImageScannerColorMode.autoColor;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Scanners.ImageScannerFeederConfiguration = function() {};
 /** @type {!Windows.Devices.Scanners.ImageScannerResolution} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.actualResolution;
 /** @type {Windows.Devices.Scanners.ImageScannerAutoCroppingMode} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.autoCroppingMode;
 /** @type {boolean} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.autoDetectPageSize;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.brightness;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.brightnessStep;
 /** @type {boolean} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.canAutoDetectPageSize;
 /** @type {boolean} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.canScanAhead;
 /** @type {boolean} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.canScanDuplex;
 /** @type {Windows.Devices.Scanners.ImageScannerColorMode} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.colorMode;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.contrast;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.contrastStep;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.defaultBrightness;
 /** @type {Windows.Devices.Scanners.ImageScannerColorMode} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.defaultColorMode;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.defaultContrast;
 /** @type {Windows.Devices.Scanners.ImageScannerFormat} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.defaultFormat;
 /** @type {!Windows.Devices.Scanners.ImageScannerResolution} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.desiredResolution;
 /** @type {boolean} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.duplex;
 /** @type {Windows.Devices.Scanners.ImageScannerFormat} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.format;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.maxBrightness;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.maxContrast;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.maxNumberOfPages;
 /** @type {!Windows.Devices.Scanners.ImageScannerResolution} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.maxResolution;
 /** @type {!Windows.Foundation.Size} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.maxScanArea;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.minBrightness;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.minContrast;
 /** @type {!Windows.Devices.Scanners.ImageScannerResolution} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.minResolution;
 /** @type {!Windows.Foundation.Size} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.minScanArea;
 /** @type {!Windows.Devices.Scanners.ImageScannerResolution} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.opticalResolution;
 /** @type {Windows.Graphics.Printing.PrintOrientation} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.pageOrientation;
 /** @type {Windows.Graphics.Printing.PrintMediaSize} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.pageSize;
 /** @type {!Windows.Foundation.Size} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.pageSizeDimensions;
 /** @type {boolean} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.scanAhead;
 /** @type {!Windows.Foundation.Rect} */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.selectedScanRegion;

/**
 * Returns whether the scanner's Feeder supports the specified ImageScannerAutoCroppingMode .
 * @param {Windows.Devices.Scanners.ImageScannerAutoCroppingMode} value The auto crop mode of the image to scan.
 * @return {boolean} Indicates whether the device supports value mode.
 */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.isAutoCroppingModeSupported = function(value) {};

/**
 * Returns whether the scanner's Feeder can scan and transfer images in the specified color mode.
 * @param {Windows.Devices.Scanners.ImageScannerColorMode} value The color mode.
 * @return {boolean} Indicates whether the scanner can scan images in value mode.
 */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.isColorModeSupported = function(value) {};

/**
 * Determines whether the scanner's Feeder supports the specified file format or not.
 * @param {Windows.Devices.Scanners.ImageScannerFormat} value The file type.
 * @return {boolean} Indicates whether the specified file type is supported.
 */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.isFormatSupported = function(value) {};

/**
 * Returns whether the Feeder can scan documents in the specified page size and orientation.
 * @param {Windows.Graphics.Printing.PrintMediaSize} pageSize The page size.
 * @param {Windows.Graphics.Printing.PrintOrientation} pageOrientation The page orientation.
 * @return {boolean} Indicates the scanner can scan with pageSize and pageOrientation values.
 */
Windows.Devices.Scanners.ImageScannerFeederConfiguration.prototype.isPageSizeSupported = function(pageSize, pageOrientation) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration = function() {};
 /** @type {!Windows.Devices.Scanners.ImageScannerResolution} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.actualResolution;
 /** @type {Windows.Devices.Scanners.ImageScannerAutoCroppingMode} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.autoCroppingMode;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.brightness;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.brightnessStep;
 /** @type {Windows.Devices.Scanners.ImageScannerColorMode} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.colorMode;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.contrast;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.contrastStep;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.defaultBrightness;
 /** @type {Windows.Devices.Scanners.ImageScannerColorMode} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.defaultColorMode;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.defaultContrast;
 /** @type {Windows.Devices.Scanners.ImageScannerFormat} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.defaultFormat;
 /** @type {!Windows.Devices.Scanners.ImageScannerResolution} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.desiredResolution;
 /** @type {Windows.Devices.Scanners.ImageScannerFormat} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.format;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.maxBrightness;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.maxContrast;
 /** @type {!Windows.Devices.Scanners.ImageScannerResolution} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.maxResolution;
 /** @type {!Windows.Foundation.Size} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.maxScanArea;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.minBrightness;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.minContrast;
 /** @type {!Windows.Devices.Scanners.ImageScannerResolution} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.minResolution;
 /** @type {!Windows.Foundation.Size} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.minScanArea;
 /** @type {!Windows.Devices.Scanners.ImageScannerResolution} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.opticalResolution;
 /** @type {!Windows.Foundation.Rect} */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.selectedScanRegion;

/**
 * Returns whether the scanner's Flatbed supports the specified ImageScannerAutoCroppingMode .
 * @param {Windows.Devices.Scanners.ImageScannerAutoCroppingMode} value The auto crop mode of the image to scan.
 * @return {boolean} Indicates whether the device supports value mode.
 */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.isAutoCroppingModeSupported = function(value) {};

/**
 * Returns whether the scanner's Flatbed can scan and transfer images in the specified color mode.
 * @param {Windows.Devices.Scanners.ImageScannerColorMode} value The color mode.
 * @return {boolean} Indicates whether the scanner can scan images in value mode.
 */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.isColorModeSupported = function(value) {};

/**
 * Determines whether the scanner's Flatbed supports the specified file format or not.
 * @param {Windows.Devices.Scanners.ImageScannerFormat} value The file type.
 * @return {boolean} Indicates whether the specified file type is supported.
 */
Windows.Devices.Scanners.ImageScannerFlatbedConfiguration.prototype.isFormatSupported = function(value) {};

/** @const */
Windows.Devices.Scanners.ImageScannerFormat = {};
/** @const {number} */
Windows.Devices.Scanners.ImageScannerFormat.jpeg;
/** @const {number} */
Windows.Devices.Scanners.ImageScannerFormat.png;
/** @const {number} */
Windows.Devices.Scanners.ImageScannerFormat.deviceIndependentBitmap;
/** @const {number} */
Windows.Devices.Scanners.ImageScannerFormat.tiff;
/** @const {number} */
Windows.Devices.Scanners.ImageScannerFormat.xps;
/** @const {number} */
Windows.Devices.Scanners.ImageScannerFormat.openXps;
/** @const {number} */
Windows.Devices.Scanners.ImageScannerFormat.pdf;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Scanners.ImageScannerPreviewResult = function() {};
 /** @type {Windows.Devices.Scanners.ImageScannerFormat} */
Windows.Devices.Scanners.ImageScannerPreviewResult.prototype.format;
 /** @type {boolean} */
Windows.Devices.Scanners.ImageScannerPreviewResult.prototype.succeeded;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Scanners.ImageScannerScanResult = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Storage.StorageFile>} */
Windows.Devices.Scanners.ImageScannerScanResult.prototype.scannedFiles;

/** @const */
Windows.Devices.Scanners.ImageScannerScanSource = {};
/** @const {number} */
Windows.Devices.Scanners.ImageScannerScanSource.default;
/** @const {number} */
Windows.Devices.Scanners.ImageScannerScanSource.flatbed;
/** @const {number} */
Windows.Devices.Scanners.ImageScannerScanSource.feeder;
/** @const {number} */
Windows.Devices.Scanners.ImageScannerScanSource.autoConfigured;
/**
 * @record
 * @struct
 */
Windows.Devices.Scanners.ImageScannerResolution = function() {};
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerResolution.prototype.dpiX;
 /** @type {number} */
Windows.Devices.Scanners.ImageScannerResolution.prototype.dpiY;
/** @const */
Windows.Devices.Sensors = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.Accelerometer = function() {};
 /** @type {string} */
Windows.Devices.Sensors.Accelerometer.prototype.deviceId;
 /** @type {number} */
Windows.Devices.Sensors.Accelerometer.prototype.maxBatchSize;
 /** @type {number} */
Windows.Devices.Sensors.Accelerometer.prototype.minimumReportInterval;
 /** @type {function(?): void} */
Windows.Devices.Sensors.Accelerometer.prototype.onreadingchanged;
 /** @type {function(?): void} */
Windows.Devices.Sensors.Accelerometer.prototype.onshaken;
 /** @type {Windows.Graphics.Display.DisplayOrientations} */
Windows.Devices.Sensors.Accelerometer.prototype.readingTransform;
 /** @type {number} */
Windows.Devices.Sensors.Accelerometer.prototype.reportInterval;
 /** @type {number} */
Windows.Devices.Sensors.Accelerometer.prototype.reportLatency;

/**
 * Returns the default accelerometer.
 * @return {!Windows.Devices.Sensors.Accelerometer} The default accelerometer or null if no integrated accelerometers are found.
 */
Windows.Devices.Sensors.Accelerometer.getDefault = function() {};

/**
 * Gets the current accelerometer reading.
 * @return {!Windows.Devices.Sensors.AccelerometerReading} This method has no parameters.
 */
Windows.Devices.Sensors.Accelerometer.prototype.getCurrentReading = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Accelerometer.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Accelerometer.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.AccelerometerReading = function() {};
 /** @type {number} */
Windows.Devices.Sensors.AccelerometerReading.prototype.accelerationX;
 /** @type {number} */
Windows.Devices.Sensors.AccelerometerReading.prototype.accelerationY;
 /** @type {number} */
Windows.Devices.Sensors.AccelerometerReading.prototype.accelerationZ;
 /** @type {!Date} */
Windows.Devices.Sensors.AccelerometerReading.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs = function() {};
 /** @type {!Windows.Devices.Sensors.AccelerometerReading} */
Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs.prototype.reading;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.AccelerometerShakenEventArgs = function() {};
 /** @type {!Date} */
Windows.Devices.Sensors.AccelerometerShakenEventArgs.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.ActivitySensor = function() {};
 /** @type {string} */
Windows.Devices.Sensors.ActivitySensor.prototype.deviceId;
 /** @type {number} */
Windows.Devices.Sensors.ActivitySensor.prototype.minimumReportInterval;
 /** @type {function(?): void} */
Windows.Devices.Sensors.ActivitySensor.prototype.onreadingchanged;
 /** @type {number} */
Windows.Devices.Sensors.ActivitySensor.prototype.powerInMilliwatts;
 /** @type {!Windows.Foundation.Collections.IVector<Windows.Devices.Sensors.ActivityType>} */
Windows.Devices.Sensors.ActivitySensor.prototype.subscribedActivities;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Devices.Sensors.ActivityType>} */
Windows.Devices.Sensors.ActivitySensor.prototype.supportedActivities;

/**
 * Asynchronously obtains the sensor from its identifier.
 * @param {string} deviceId The sensor identifier.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Sensors.ActivitySensor, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Sensors.ActivitySensor>>} Returns the ActivitySensor object from its identifier.
 */
Windows.Devices.Sensors.ActivitySensor.fromIdAsync = function(deviceId) {};

/**
 * Asynchronously obtains the default sensor.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Sensors.ActivitySensor, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Sensors.ActivitySensor>>} Asynchronously returns a ActivitySensor object that represents the default sensor.
 */
Windows.Devices.Sensors.ActivitySensor.getDefaultAsync = function() {};

/**
 * Gets the device selector.
 * @return {string} Returns the device selector, if it exists; otherwise, null.
 */
Windows.Devices.Sensors.ActivitySensor.getDeviceSelector = function() {};

/**
 * Asynchronously gets sensor readings from a specific time.
 * Asynchronously gets sensor readings from a specific time and duration.
 * @param {!Date} fromTime The time at which to get sensor readings.
 * @param {number=} duration The time span during which to get sensor readings.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} Asynchronously returns a list of ActivitySensorReading objects that represent info about the sensor.
 */
Windows.Devices.Sensors.ActivitySensor.getSystemHistoryAsync = function(fromTime, duration) {};

/**
 * Asynchronously gets the current sensor reading.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Sensors.ActivitySensorReading, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Sensors.ActivitySensorReading>>} Asynchronously returns a ActivitySensorReading object that represents info about the sensor.
 */
Windows.Devices.Sensors.ActivitySensor.prototype.getCurrentReadingAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.ActivitySensor.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.ActivitySensor.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.ActivitySensorReading = function() {};
 /** @type {Windows.Devices.Sensors.ActivityType} */
Windows.Devices.Sensors.ActivitySensorReading.prototype.activity;
 /** @type {Windows.Devices.Sensors.ActivitySensorReadingConfidence} */
Windows.Devices.Sensors.ActivitySensorReading.prototype.confidence;
 /** @type {!Date} */
Windows.Devices.Sensors.ActivitySensorReading.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.ActivitySensorReadingChangeReport = function() {};
 /** @type {!Windows.Devices.Sensors.ActivitySensorReading} */
Windows.Devices.Sensors.ActivitySensorReadingChangeReport.prototype.reading;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.ActivitySensorReadingChangedEventArgs = function() {};
 /** @type {!Windows.Devices.Sensors.ActivitySensorReading} */
Windows.Devices.Sensors.ActivitySensorReadingChangedEventArgs.prototype.reading;

/** @const */
Windows.Devices.Sensors.ActivitySensorReadingConfidence = {};
/** @const {number} */
Windows.Devices.Sensors.ActivitySensorReadingConfidence.high;
/** @const {number} */
Windows.Devices.Sensors.ActivitySensorReadingConfidence.low;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.ActivitySensorTriggerDetails = function() {};

/**
 * Reads reports about the sensor triggering.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Sensors.ActivitySensorReadingChangeReport>} Returns a list of ActivitySensorReadingChangeReport objects that provides data for the sensor trigger.
 */
Windows.Devices.Sensors.ActivitySensorTriggerDetails.prototype.readReports = function() {};

/** @const */
Windows.Devices.Sensors.ActivityType = {};
/** @const {number} */
Windows.Devices.Sensors.ActivityType.unknown;
/** @const {number} */
Windows.Devices.Sensors.ActivityType.idle;
/** @const {number} */
Windows.Devices.Sensors.ActivityType.stationary;
/** @const {number} */
Windows.Devices.Sensors.ActivityType.fidgeting;
/** @const {number} */
Windows.Devices.Sensors.ActivityType.walking;
/** @const {number} */
Windows.Devices.Sensors.ActivityType.running;
/** @const {number} */
Windows.Devices.Sensors.ActivityType.inVehicle;
/** @const {number} */
Windows.Devices.Sensors.ActivityType.biking;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.Altimeter = function() {};
 /** @type {string} */
Windows.Devices.Sensors.Altimeter.prototype.deviceId;
 /** @type {number} */
Windows.Devices.Sensors.Altimeter.prototype.minimumReportInterval;
 /** @type {function(?): void} */
Windows.Devices.Sensors.Altimeter.prototype.onreadingchanged;
 /** @type {number} */
Windows.Devices.Sensors.Altimeter.prototype.reportInterval;

/**
 * Returns the default altimeter sensor.
 * @return {!Windows.Devices.Sensors.Altimeter} The default altimeter.
 */
Windows.Devices.Sensors.Altimeter.getDefault = function() {};

/**
 * Gets the current reading for the altimeter.
 * @return {!Windows.Devices.Sensors.AltimeterReading} The current alititude reading for this sensor.
 */
Windows.Devices.Sensors.Altimeter.prototype.getCurrentReading = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Altimeter.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Altimeter.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.AltimeterReading = function() {};
 /** @type {number} */
Windows.Devices.Sensors.AltimeterReading.prototype.altitudeChangeInMeters;
 /** @type {!Date} */
Windows.Devices.Sensors.AltimeterReading.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.AltimeterReadingChangedEventArgs = function() {};
 /** @type {!Windows.Devices.Sensors.AltimeterReading} */
Windows.Devices.Sensors.AltimeterReadingChangedEventArgs.prototype.reading;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.Barometer = function() {};
 /** @type {string} */
Windows.Devices.Sensors.Barometer.prototype.deviceId;
 /** @type {number} */
Windows.Devices.Sensors.Barometer.prototype.minimumReportInterval;
 /** @type {function(?): void} */
Windows.Devices.Sensors.Barometer.prototype.onreadingchanged;
 /** @type {number} */
Windows.Devices.Sensors.Barometer.prototype.reportInterval;

/**
 * Returns the default barometer sensor.
 * @return {!Windows.Devices.Sensors.Barometer} The default barometer.
 */
Windows.Devices.Sensors.Barometer.getDefault = function() {};

/**
 * Gets the current reading for the barometer.
 * @return {!Windows.Devices.Sensors.BarometerReading} The current atmospheric pressure according to this sensor.
 */
Windows.Devices.Sensors.Barometer.prototype.getCurrentReading = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Barometer.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Barometer.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.BarometerReading = function() {};
 /** @type {number} */
Windows.Devices.Sensors.BarometerReading.prototype.stationPressureInHectopascals;
 /** @type {!Date} */
Windows.Devices.Sensors.BarometerReading.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.BarometerReadingChangedEventArgs = function() {};
 /** @type {!Windows.Devices.Sensors.BarometerReading} */
Windows.Devices.Sensors.BarometerReadingChangedEventArgs.prototype.reading;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.Compass = function() {};
 /** @type {string} */
Windows.Devices.Sensors.Compass.prototype.deviceId;
 /** @type {number} */
Windows.Devices.Sensors.Compass.prototype.minimumReportInterval;
 /** @type {function(?): void} */
Windows.Devices.Sensors.Compass.prototype.onreadingchanged;
 /** @type {Windows.Graphics.Display.DisplayOrientations} */
Windows.Devices.Sensors.Compass.prototype.readingTransform;
 /** @type {number} */
Windows.Devices.Sensors.Compass.prototype.reportInterval;

/**
 * Returns the default compass.
 * @return {!Windows.Devices.Sensors.Compass} The default compass or null if no integrated compasses are found.
 */
Windows.Devices.Sensors.Compass.getDefault = function() {};

/**
 * Gets the current compass reading.
 * @return {!Windows.Devices.Sensors.CompassReading} The current compass reading.
 */
Windows.Devices.Sensors.Compass.prototype.getCurrentReading = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Compass.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Compass.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.CompassReading = function() {};
 /** @type {Windows.Devices.Sensors.MagnetometerAccuracy} */
Windows.Devices.Sensors.CompassReading.prototype.headingAccuracy;
 /** @type {number} */
Windows.Devices.Sensors.CompassReading.prototype.headingMagneticNorth;
 /** @type {number} */
Windows.Devices.Sensors.CompassReading.prototype.headingTrueNorth;
 /** @type {!Date} */
Windows.Devices.Sensors.CompassReading.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.CompassReadingChangedEventArgs = function() {};
 /** @type {!Windows.Devices.Sensors.CompassReading} */
Windows.Devices.Sensors.CompassReadingChangedEventArgs.prototype.reading;
/** @const */
Windows.Devices.Sensors.Custom = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.Custom.CustomSensor = function() {};
 /** @type {string} */
Windows.Devices.Sensors.Custom.CustomSensor.prototype.deviceId;
 /** @type {number} */
Windows.Devices.Sensors.Custom.CustomSensor.prototype.minimumReportInterval;
 /** @type {function(?): void} */
Windows.Devices.Sensors.Custom.CustomSensor.prototype.onreadingchanged;
 /** @type {number} */
Windows.Devices.Sensors.Custom.CustomSensor.prototype.reportInterval;

/**
 * Asynchronously obtains the sensor from its identifier.
 * @param {string} sensorId The sensor identifier.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Sensors.Custom.CustomSensor, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Sensors.Custom.CustomSensor>>} Returns the CustomSensor object from its identifier.
 */
Windows.Devices.Sensors.Custom.CustomSensor.fromIdAsync = function(sensorId) {};

/**
 * Gets the device selector from the given interface identifier.
 * @param {string} interfaceId The interface Guid that is associated with the custom sensor. This Guid is defined and registered by the sensor.
 * @return {string} Returns the device selector, if it exists; otherwise, null.
 */
Windows.Devices.Sensors.Custom.CustomSensor.getDeviceSelector = function(interfaceId) {};

/**
 * Gets the current sensor reading.
 * @return {!Windows.Devices.Sensors.Custom.CustomSensorReading} The current sensor reading.
 */
Windows.Devices.Sensors.Custom.CustomSensor.prototype.getCurrentReading = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Custom.CustomSensor.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Custom.CustomSensor.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.Custom.CustomSensorReading = function() {};
 /** @type {!Windows.Foundation.Collections.IMapView<string, ?>} */
Windows.Devices.Sensors.Custom.CustomSensorReading.prototype.properties;
 /** @type {!Date} */
Windows.Devices.Sensors.Custom.CustomSensorReading.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.Custom.CustomSensorReadingChangedEventArgs = function() {};
 /** @type {!Windows.Devices.Sensors.Custom.CustomSensorReading} */
Windows.Devices.Sensors.Custom.CustomSensorReadingChangedEventArgs.prototype.reading;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.Gyrometer = function() {};
 /** @type {string} */
Windows.Devices.Sensors.Gyrometer.prototype.deviceId;
 /** @type {number} */
Windows.Devices.Sensors.Gyrometer.prototype.minimumReportInterval;
 /** @type {function(?): void} */
Windows.Devices.Sensors.Gyrometer.prototype.onreadingchanged;
 /** @type {Windows.Graphics.Display.DisplayOrientations} */
Windows.Devices.Sensors.Gyrometer.prototype.readingTransform;
 /** @type {number} */
Windows.Devices.Sensors.Gyrometer.prototype.reportInterval;

/**
 * Returns the default gyrometer.
 * @return {!Windows.Devices.Sensors.Gyrometer} The default gyrometer or null if no integrated gyrometers are found.
 */
Windows.Devices.Sensors.Gyrometer.getDefault = function() {};

/**
 * Gets the current gyrometer reading.
 * @return {!Windows.Devices.Sensors.GyrometerReading} This method has no parameters.
 */
Windows.Devices.Sensors.Gyrometer.prototype.getCurrentReading = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Gyrometer.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Gyrometer.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.GyrometerReading = function() {};
 /** @type {number} */
Windows.Devices.Sensors.GyrometerReading.prototype.angularVelocityX;
 /** @type {number} */
Windows.Devices.Sensors.GyrometerReading.prototype.angularVelocityY;
 /** @type {number} */
Windows.Devices.Sensors.GyrometerReading.prototype.angularVelocityZ;
 /** @type {!Date} */
Windows.Devices.Sensors.GyrometerReading.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.GyrometerReadingChangedEventArgs = function() {};
 /** @type {!Windows.Devices.Sensors.GyrometerReading} */
Windows.Devices.Sensors.GyrometerReadingChangedEventArgs.prototype.reading;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.Inclinometer = function() {};
 /** @type {string} */
Windows.Devices.Sensors.Inclinometer.prototype.deviceId;
 /** @type {number} */
Windows.Devices.Sensors.Inclinometer.prototype.minimumReportInterval;
 /** @type {function(?): void} */
Windows.Devices.Sensors.Inclinometer.prototype.onreadingchanged;
 /** @type {Windows.Graphics.Display.DisplayOrientations} */
Windows.Devices.Sensors.Inclinometer.prototype.readingTransform;
 /** @type {Windows.Devices.Sensors.SensorReadingType} */
Windows.Devices.Sensors.Inclinometer.prototype.readingType;
 /** @type {number} */
Windows.Devices.Sensors.Inclinometer.prototype.reportInterval;

/**
 * Returns the default inclinometer.
 * @return {!Windows.Devices.Sensors.Inclinometer} The default inclinometer or null if no inclinometers are found.
 */
Windows.Devices.Sensors.Inclinometer.getDefault = function() {};

/**
 * Returns the default inclinometer.
 * @return {!Windows.Devices.Sensors.Inclinometer} The default inclinometer or null if no inclinometers are found.
 */
Windows.Devices.Sensors.Inclinometer.getDefaultForRelativeReadings = function() {};

/**
 * Gets the current inclinometer reading.
 * @return {!Windows.Devices.Sensors.InclinometerReading} The current inclinometer reading.
 */
Windows.Devices.Sensors.Inclinometer.prototype.getCurrentReading = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Inclinometer.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Inclinometer.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.InclinometerReading = function() {};
 /** @type {number} */
Windows.Devices.Sensors.InclinometerReading.prototype.pitchDegrees;
 /** @type {number} */
Windows.Devices.Sensors.InclinometerReading.prototype.rollDegrees;
 /** @type {!Date} */
Windows.Devices.Sensors.InclinometerReading.prototype.timestamp;
 /** @type {Windows.Devices.Sensors.MagnetometerAccuracy} */
Windows.Devices.Sensors.InclinometerReading.prototype.yawAccuracy;
 /** @type {number} */
Windows.Devices.Sensors.InclinometerReading.prototype.yawDegrees;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.InclinometerReadingChangedEventArgs = function() {};
 /** @type {!Windows.Devices.Sensors.InclinometerReading} */
Windows.Devices.Sensors.InclinometerReadingChangedEventArgs.prototype.reading;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.LightSensor = function() {};
 /** @type {string} */
Windows.Devices.Sensors.LightSensor.prototype.deviceId;
 /** @type {number} */
Windows.Devices.Sensors.LightSensor.prototype.minimumReportInterval;
 /** @type {function(?): void} */
Windows.Devices.Sensors.LightSensor.prototype.onreadingchanged;
 /** @type {number} */
Windows.Devices.Sensors.LightSensor.prototype.reportInterval;

/**
 * Returns the default ambient-light sensor.
 * @return {!Windows.Devices.Sensors.LightSensor} The default ambient-light sensor or null if no integrated light sensors are found.
 */
Windows.Devices.Sensors.LightSensor.getDefault = function() {};

/**
 * Gets the current ambient-light sensor reading.
 * @return {!Windows.Devices.Sensors.LightSensorReading} The current ambient-light sensor reading.
 */
Windows.Devices.Sensors.LightSensor.prototype.getCurrentReading = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.LightSensor.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.LightSensor.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.LightSensorReading = function() {};
 /** @type {number} */
Windows.Devices.Sensors.LightSensorReading.prototype.illuminanceInLux;
 /** @type {!Date} */
Windows.Devices.Sensors.LightSensorReading.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.LightSensorReadingChangedEventArgs = function() {};
 /** @type {!Windows.Devices.Sensors.LightSensorReading} */
Windows.Devices.Sensors.LightSensorReadingChangedEventArgs.prototype.reading;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.Magnetometer = function() {};
 /** @type {string} */
Windows.Devices.Sensors.Magnetometer.prototype.deviceId;
 /** @type {number} */
Windows.Devices.Sensors.Magnetometer.prototype.minimumReportInterval;
 /** @type {function(?): void} */
Windows.Devices.Sensors.Magnetometer.prototype.onreadingchanged;
 /** @type {Windows.Graphics.Display.DisplayOrientations} */
Windows.Devices.Sensors.Magnetometer.prototype.readingTransform;
 /** @type {number} */
Windows.Devices.Sensors.Magnetometer.prototype.reportInterval;

/**
 * Returns the default magnetometer.
 * @return {!Windows.Devices.Sensors.Magnetometer} The default magnetometer.
 */
Windows.Devices.Sensors.Magnetometer.getDefault = function() {};

/**
 * Gets the current magnetometer reading.
 * @return {!Windows.Devices.Sensors.MagnetometerReading} The current magnetometer reading.
 */
Windows.Devices.Sensors.Magnetometer.prototype.getCurrentReading = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Magnetometer.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Magnetometer.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Devices.Sensors.MagnetometerAccuracy = {};
/** @const {number} */
Windows.Devices.Sensors.MagnetometerAccuracy.unknown;
/** @const {number} */
Windows.Devices.Sensors.MagnetometerAccuracy.unreliable;
/** @const {number} */
Windows.Devices.Sensors.MagnetometerAccuracy.approximate;
/** @const {number} */
Windows.Devices.Sensors.MagnetometerAccuracy.high;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.MagnetometerReading = function() {};
 /** @type {Windows.Devices.Sensors.MagnetometerAccuracy} */
Windows.Devices.Sensors.MagnetometerReading.prototype.directionalAccuracy;
 /** @type {number} */
Windows.Devices.Sensors.MagnetometerReading.prototype.magneticFieldX;
 /** @type {number} */
Windows.Devices.Sensors.MagnetometerReading.prototype.magneticFieldY;
 /** @type {number} */
Windows.Devices.Sensors.MagnetometerReading.prototype.magneticFieldZ;
 /** @type {!Date} */
Windows.Devices.Sensors.MagnetometerReading.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.MagnetometerReadingChangedEventArgs = function() {};
 /** @type {!Windows.Devices.Sensors.MagnetometerReading} */
Windows.Devices.Sensors.MagnetometerReadingChangedEventArgs.prototype.reading;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.OrientationSensor = function() {};
 /** @type {string} */
Windows.Devices.Sensors.OrientationSensor.prototype.deviceId;
 /** @type {number} */
Windows.Devices.Sensors.OrientationSensor.prototype.minimumReportInterval;
 /** @type {function(?): void} */
Windows.Devices.Sensors.OrientationSensor.prototype.onreadingchanged;
 /** @type {Windows.Graphics.Display.DisplayOrientations} */
Windows.Devices.Sensors.OrientationSensor.prototype.readingTransform;
 /** @type {Windows.Devices.Sensors.SensorReadingType} */
Windows.Devices.Sensors.OrientationSensor.prototype.readingType;
 /** @type {number} */
Windows.Devices.Sensors.OrientationSensor.prototype.reportInterval;

/**
 * Gets the default orientation sensor.
 * @return {!Windows.Devices.Sensors.OrientationSensor} The default orientation sensor or null if no orientation sensors are found.
 */
Windows.Devices.Sensors.OrientationSensor.getDefault = function() {};

/**
 * Gets the default orientation sensor.
 * @return {!Windows.Devices.Sensors.OrientationSensor} The default orientation sensor or null if no orientation sensors are found.
 */
Windows.Devices.Sensors.OrientationSensor.getDefaultForRelativeReadings = function() {};

/**
 * Gets the current sensor reading.
 * @return {!Windows.Devices.Sensors.OrientationSensorReading} The current sensor reading.
 */
Windows.Devices.Sensors.OrientationSensor.prototype.getCurrentReading = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.OrientationSensor.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.OrientationSensor.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.OrientationSensorReading = function() {};
 /** @type {!Windows.Devices.Sensors.SensorQuaternion} */
Windows.Devices.Sensors.OrientationSensorReading.prototype.quaternion;
 /** @type {!Windows.Devices.Sensors.SensorRotationMatrix} */
Windows.Devices.Sensors.OrientationSensorReading.prototype.rotationMatrix;
 /** @type {!Date} */
Windows.Devices.Sensors.OrientationSensorReading.prototype.timestamp;
 /** @type {Windows.Devices.Sensors.MagnetometerAccuracy} */
Windows.Devices.Sensors.OrientationSensorReading.prototype.yawAccuracy;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs = function() {};
 /** @type {!Windows.Devices.Sensors.OrientationSensorReading} */
Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs.prototype.reading;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.Pedometer = function() {};
 /** @type {?} */
Windows.Devices.Sensors.Pedometer.getReadingsFromTriggerDetails;
 /** @type {string} */
Windows.Devices.Sensors.Pedometer.prototype.deviceId;
 /** @type {?} */
Windows.Devices.Sensors.Pedometer.prototype.getCurrentReadings;
 /** @type {number} */
Windows.Devices.Sensors.Pedometer.prototype.minimumReportInterval;
 /** @type {function(?): void} */
Windows.Devices.Sensors.Pedometer.prototype.onreadingchanged;
 /** @type {number} */
Windows.Devices.Sensors.Pedometer.prototype.powerInMilliwatts;
 /** @type {number} */
Windows.Devices.Sensors.Pedometer.prototype.reportInterval;

/**
 * Obtains the pedometer from its identifier.
 * @param {string} deviceId The sensor identifier.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Sensors.Pedometer, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Sensors.Pedometer>>} Returns the Pedometer object from its identifier.
 */
Windows.Devices.Sensors.Pedometer.fromIdAsync = function(deviceId) {};

/**
 * Asynchronously obtains the default pedometer.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Sensors.Pedometer, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Sensors.Pedometer>>} Asynchronously returns a Pedometer object that represents the default sensor.
 */
Windows.Devices.Sensors.Pedometer.getDefaultAsync = function() {};

/**
 * Gets the device selector.
 * @return {string} Returns the device selector, if it exists; otherwise null.
 */
Windows.Devices.Sensors.Pedometer.getDeviceSelector = function() {};

/**
 * Asynchronously gets sensor readings from a specific time.
 * Asynchronously gets pedometer readings from a specific time and duration.
 * @param {!Date} fromTime The time for which you want to retrieve the reading.
 * @param {number=} duration The duration over which you want to retrieve data.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} Asynchronously returns a list of PedometerReading objects that represent info about the sensor.
 */
Windows.Devices.Sensors.Pedometer.getSystemHistoryAsync = function(fromTime, duration) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Pedometer.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.Pedometer.prototype.removeEventListener = function(type, listener) {};

/**
 * @constructor
 * @struct
 * Creates a PedometerDataThreshold object.
 * @param {!Windows.Devices.Sensors.Pedometer} sensor The pedometer sensor.
 * @param {number} stepGoal The number of steps before the threshold is exceeded and the background task is activated.
 */
Windows.Devices.Sensors.PedometerDataThreshold = function(sensor, stepGoal) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.PedometerReading = function() {};
 /** @type {number} */
Windows.Devices.Sensors.PedometerReading.prototype.cumulativeSteps;
 /** @type {number} */
Windows.Devices.Sensors.PedometerReading.prototype.cumulativeStepsDuration;
 /** @type {Windows.Devices.Sensors.PedometerStepKind} */
Windows.Devices.Sensors.PedometerReading.prototype.stepKind;
 /** @type {!Date} */
Windows.Devices.Sensors.PedometerReading.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.PedometerReadingChangedEventArgs = function() {};
 /** @type {!Windows.Devices.Sensors.PedometerReading} */
Windows.Devices.Sensors.PedometerReadingChangedEventArgs.prototype.reading;

/** @const */
Windows.Devices.Sensors.PedometerStepKind = {};
/** @const {number} */
Windows.Devices.Sensors.PedometerStepKind.unknown;
/** @const {number} */
Windows.Devices.Sensors.PedometerStepKind.walking;
/** @const {number} */
Windows.Devices.Sensors.PedometerStepKind.running;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.ProximitySensor = function() {};
 /** @type {string} */
Windows.Devices.Sensors.ProximitySensor.prototype.deviceId;
 /** @type {number} */
Windows.Devices.Sensors.ProximitySensor.prototype.maxDistanceInMillimeters;
 /** @type {number} */
Windows.Devices.Sensors.ProximitySensor.prototype.minDistanceInMillimeters;
 /** @type {function(?): void} */
Windows.Devices.Sensors.ProximitySensor.prototype.onreadingchanged;

/**
 * Obtains the proximity sensor from its identifier.
 * @param {string} sensorId The sensor identifier.
 * @return {!Windows.Devices.Sensors.ProximitySensor} Returns the ProximitySensor object from its identifier.
 */
Windows.Devices.Sensors.ProximitySensor.fromId = function(sensorId) {};

/**
 * Gets the device selector.
 * @return {string} Returns the device selector. If no device selector is available, this method returns null.
 */
Windows.Devices.Sensors.ProximitySensor.getDeviceSelector = function() {};

/**
 * Gets readings from the trigger details in background task.
 * @param {!Windows.Devices.Sensors.SensorDataThresholdTriggerDetails} triggerDetails The trigger details received from the background task.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Sensors.ProximitySensorReading>} The collection of proximity data retrieved from the trigger details.
 */
Windows.Devices.Sensors.ProximitySensor.getReadingsFromTriggerDetails = function(triggerDetails) {};

/**
 * Creates a controller responsible for turning the display on or off based on the ProximitySensorReading .
 * @return {!Windows.Devices.Sensors.ProximitySensorDisplayOnOffController} The controller for the phone display.
 */
Windows.Devices.Sensors.ProximitySensor.prototype.createDisplayOnOffController = function() {};

/**
 * Gets the current reading for the proximity sensor.
 * @return {!Windows.Devices.Sensors.ProximitySensorReading} Indicates whether or not the proximity sensor detects an object, and if so, the distance to that object.
 */
Windows.Devices.Sensors.ProximitySensor.prototype.getCurrentReading = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.ProximitySensor.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.ProximitySensor.prototype.removeEventListener = function(type, listener) {};

/**
 * @constructor
 * @struct
 * Creates a ProximitySensorDataThreshold object.
 * @param {!Windows.Devices.Sensors.ProximitySensor} sensor The proximity sensor.
 */
Windows.Devices.Sensors.ProximitySensorDataThreshold = function(sensor) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.ProximitySensorDisplayOnOffController = function() {};

/**
 * Disconnects this ProximitySensorDisplayOnOffController instance from the service and frees all the allocated resources.
 * @return {void}
 */
Windows.Devices.Sensors.ProximitySensorDisplayOnOffController.prototype.close = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.ProximitySensorReading = function() {};
 /** @type {number} */
Windows.Devices.Sensors.ProximitySensorReading.prototype.distanceInMillimeters;
 /** @type {boolean} */
Windows.Devices.Sensors.ProximitySensorReading.prototype.isDetected;
 /** @type {!Date} */
Windows.Devices.Sensors.ProximitySensorReading.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.ProximitySensorReadingChangedEventArgs = function() {};
 /** @type {!Windows.Devices.Sensors.ProximitySensorReading} */
Windows.Devices.Sensors.ProximitySensorReadingChangedEventArgs.prototype.reading;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.SensorDataThresholdTriggerDetails = function() {};
 /** @type {string} */
Windows.Devices.Sensors.SensorDataThresholdTriggerDetails.prototype.deviceId;
 /** @type {Windows.Devices.Sensors.SensorType} */
Windows.Devices.Sensors.SensorDataThresholdTriggerDetails.prototype.sensorType;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.SensorQuaternion = function() {};
 /** @type {number} */
Windows.Devices.Sensors.SensorQuaternion.prototype.w;
 /** @type {number} */
Windows.Devices.Sensors.SensorQuaternion.prototype.x;
 /** @type {number} */
Windows.Devices.Sensors.SensorQuaternion.prototype.y;
 /** @type {number} */
Windows.Devices.Sensors.SensorQuaternion.prototype.z;

/** @const */
Windows.Devices.Sensors.SensorReadingType = {};
/** @const {number} */
Windows.Devices.Sensors.SensorReadingType.absolute;
/** @const {number} */
Windows.Devices.Sensors.SensorReadingType.relative;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.SensorRotationMatrix = function() {};
 /** @type {number} */
Windows.Devices.Sensors.SensorRotationMatrix.prototype.m11;
 /** @type {number} */
Windows.Devices.Sensors.SensorRotationMatrix.prototype.m12;
 /** @type {number} */
Windows.Devices.Sensors.SensorRotationMatrix.prototype.m13;
 /** @type {number} */
Windows.Devices.Sensors.SensorRotationMatrix.prototype.m21;
 /** @type {number} */
Windows.Devices.Sensors.SensorRotationMatrix.prototype.m22;
 /** @type {number} */
Windows.Devices.Sensors.SensorRotationMatrix.prototype.m23;
 /** @type {number} */
Windows.Devices.Sensors.SensorRotationMatrix.prototype.m31;
 /** @type {number} */
Windows.Devices.Sensors.SensorRotationMatrix.prototype.m32;
 /** @type {number} */
Windows.Devices.Sensors.SensorRotationMatrix.prototype.m33;

/** @const */
Windows.Devices.Sensors.SensorType = {};
/** @const {number} */
Windows.Devices.Sensors.SensorType.accelerometer;
/** @const {number} */
Windows.Devices.Sensors.SensorType.activitySensor;
/** @const {number} */
Windows.Devices.Sensors.SensorType.barometer;
/** @const {number} */
Windows.Devices.Sensors.SensorType.compass;
/** @const {number} */
Windows.Devices.Sensors.SensorType.customSensor;
/** @const {number} */
Windows.Devices.Sensors.SensorType.gyroscope;
/** @const {number} */
Windows.Devices.Sensors.SensorType.proximitySensor;
/** @const {number} */
Windows.Devices.Sensors.SensorType.inclinometer;
/** @const {number} */
Windows.Devices.Sensors.SensorType.lightSensor;
/** @const {number} */
Windows.Devices.Sensors.SensorType.orientationSensor;
/** @const {number} */
Windows.Devices.Sensors.SensorType.pedometer;
/** @const {number} */
Windows.Devices.Sensors.SensorType.relativeInclinometer;
/** @const {number} */
Windows.Devices.Sensors.SensorType.relativeOrientationSensor;
/** @const {number} */
Windows.Devices.Sensors.SensorType.simpleOrientationSensor;

/** @const */
Windows.Devices.Sensors.SimpleOrientation = {};
/** @const {number} */
Windows.Devices.Sensors.SimpleOrientation.notRotated;
/** @const {number} */
Windows.Devices.Sensors.SimpleOrientation.rotated90DegreesCounterclockwise;
/** @const {number} */
Windows.Devices.Sensors.SimpleOrientation.rotated180DegreesCounterclockwise;
/** @const {number} */
Windows.Devices.Sensors.SimpleOrientation.rotated270DegreesCounterclockwise;
/** @const {number} */
Windows.Devices.Sensors.SimpleOrientation.faceup;
/** @const {number} */
Windows.Devices.Sensors.SimpleOrientation.facedown;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.SimpleOrientationSensor = function() {};
 /** @type {string} */
Windows.Devices.Sensors.SimpleOrientationSensor.prototype.deviceId;
 /** @type {function(?): void} */
Windows.Devices.Sensors.SimpleOrientationSensor.prototype.onorientationchanged;
 /** @type {Windows.Graphics.Display.DisplayOrientations} */
Windows.Devices.Sensors.SimpleOrientationSensor.prototype.readingTransform;

/**
 * Gets the default simple orientation sensor.
 * @return {!Windows.Devices.Sensors.SimpleOrientationSensor} The default simple orientation sensor or null if no simple orientation sensors are found.
 */
Windows.Devices.Sensors.SimpleOrientationSensor.getDefault = function() {};

/**
 * Gets the default simple orientation sensor.
 * @return {Windows.Devices.Sensors.SimpleOrientation} The default simple orientation sensor.
 */
Windows.Devices.Sensors.SimpleOrientationSensor.prototype.getCurrentOrientation = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.SimpleOrientationSensor.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sensors.SimpleOrientationSensor.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs = function() {};
 /** @type {Windows.Devices.Sensors.SimpleOrientation} */
Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs.prototype.orientation;
 /** @type {!Date} */
Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs.prototype.timestamp;
/**
 * @extends {Windows.IInspectable}
 * @record
 * @struct
 */
Windows.Devices.Sensors.ISensorDataThreshold = function() {};
/** @const */
Windows.Devices.SerialCommunication = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.SerialCommunication.ErrorReceivedEventArgs = function() {};
 /** @type {Windows.Devices.SerialCommunication.SerialError} */
Windows.Devices.SerialCommunication.ErrorReceivedEventArgs.prototype.error;
/**
 * @constructor
 * @struct
 */
Windows.Devices.SerialCommunication.PinChangedEventArgs = function() {};
 /** @type {Windows.Devices.SerialCommunication.SerialPinChange} */
Windows.Devices.SerialCommunication.PinChangedEventArgs.prototype.pinChange;
/**
 * @constructor
 * @struct
 */
Windows.Devices.SerialCommunication.SerialDevice = function() {};
 /** @type {number} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.baudRate;
 /** @type {boolean} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.breakSignalState;
 /** @type {number} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.bytesReceived;
 /** @type {boolean} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.carrierDetectState;
 /** @type {boolean} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.clearToSendState;
 /** @type {number} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.dataBits;
 /** @type {boolean} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.dataSetReadyState;
 /** @type {Windows.Devices.SerialCommunication.SerialHandshake} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.handshake;
 /** @type {!Windows.Storage.Streams.IInputStream} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.inputStream;
 /** @type {boolean} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.isDataTerminalReadyEnabled;
 /** @type {boolean} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.isRequestToSendEnabled;
 /** @type {function(?): void} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.onerrorreceived;
 /** @type {function(?): void} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.onpinchanged;
 /** @type {!Windows.Storage.Streams.IOutputStream} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.outputStream;
 /** @type {Windows.Devices.SerialCommunication.SerialParity} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.parity;
 /** @type {string} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.portName;
 /** @type {number} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.readTimeout;
 /** @type {Windows.Devices.SerialCommunication.SerialStopBitCount} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.stopBits;
 /** @type {number} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.usbProductId;
 /** @type {number} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.usbVendorId;
 /** @type {number} */
Windows.Devices.SerialCommunication.SerialDevice.prototype.writeTimeout;

/**
 * Starts an asynchronous operation that creates a SerialDevice object.
 * @param {string} deviceId The device instance path of the device. To obtain that value, get the DeviceInformation.Id property value.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.SerialCommunication.SerialDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.SerialCommunication.SerialDevice>>} Returns an IAsyncOperation(SerialDevice) object that returns the results of the operation.
 */
Windows.Devices.SerialCommunication.SerialDevice.fromIdAsync = function(deviceId) {};

/**
 * Gets an Advanced Query Syntax (AQS) string that the app can pass to DeviceInformation.FindAllAsync in order to find a serial device by specifying its port name.
 * Gets an Advanced Query Syntax (AQS) string that the app can pass to DeviceInformation.FindAllAsync in order to find all serial devices on the system.
 * @param {string=} portName The serial port name. For example, "COM1".
 * @return {string} String formatted as an AQS query.
 */
Windows.Devices.SerialCommunication.SerialDevice.getDeviceSelector = function(portName) {};

/**
 * Gets an Advanced Query Syntax (AQS) string that the app can pass to DeviceInformation.FindAllAsync in order to find a specific Serial-to-USB device by specifying it's VID and PID.
 * @param {number} vendorId Specifies the vendor identifier for the device as assigned by the USB specification committee. Possible values are 0 through 0xffff.
 * @param {number} productId Specifies the product identifier. This value is assigned by the manufacturer and is device-specific. Possible values are 0 through 0xffff.
 * @return {string} String formatted as an AQS query.
 */
Windows.Devices.SerialCommunication.SerialDevice.getDeviceSelectorFromUsbVidPid = function(vendorId, productId) {};

/**
 * Releases the reference to the SerialDevice object that was previously obtained by calling FromIdAsync .
 * @return {void}
 */
Windows.Devices.SerialCommunication.SerialDevice.prototype.close = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.SerialCommunication.SerialDevice.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.SerialCommunication.SerialDevice.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Devices.SerialCommunication.SerialError = {};
/** @const {number} */
Windows.Devices.SerialCommunication.SerialError.frame;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialError.bufferOverrun;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialError.receiveFull;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialError.receiveParity;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialError.transmitFull;

/** @const */
Windows.Devices.SerialCommunication.SerialHandshake = {};
/** @const {number} */
Windows.Devices.SerialCommunication.SerialHandshake.none;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialHandshake.requestToSend;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialHandshake.xonXOff;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialHandshake.requestToSendXOnXOff;

/** @const */
Windows.Devices.SerialCommunication.SerialParity = {};
/** @const {number} */
Windows.Devices.SerialCommunication.SerialParity.none;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialParity.odd;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialParity.even;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialParity.mark;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialParity.space;

/** @const */
Windows.Devices.SerialCommunication.SerialPinChange = {};
/** @const {number} */
Windows.Devices.SerialCommunication.SerialPinChange.breakSignal;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialPinChange.carrierDetect;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialPinChange.clearToSend;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialPinChange.dataSetReady;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialPinChange.ringIndicator;

/** @const */
Windows.Devices.SerialCommunication.SerialStopBitCount = {};
/** @const {number} */
Windows.Devices.SerialCommunication.SerialStopBitCount.one;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialStopBitCount.onePointFive;
/** @const {number} */
Windows.Devices.SerialCommunication.SerialStopBitCount.two;
/** @const */
Windows.Devices.SmartCards = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.SmartCards.CardAddedEventArgs = function() {};
 /** @type {!Windows.Devices.SmartCards.SmartCard} */
Windows.Devices.SmartCards.CardAddedEventArgs.prototype.smartCard;
/**
 * @constructor
 * @struct
 */
Windows.Devices.SmartCards.CardRemovedEventArgs = function() {};
 /** @type {!Windows.Devices.SmartCards.SmartCard} */
Windows.Devices.SmartCards.CardRemovedEventArgs.prototype.smartCard;
/**
 * @constructor
 * @struct
 */
Windows.Devices.SmartCards.SmartCard = function() {};
 /** @type {!Windows.Devices.SmartCards.SmartCardReader} */
Windows.Devices.SmartCards.SmartCard.prototype.reader;

/**
 * Establishes a connection to the smart card and returns a SmartCardConnection object representing the connection.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.SmartCards.SmartCardConnection, !Windows.Foundation.IAsyncOperation<!Windows.Devices.SmartCards.SmartCardConnection>>} Asynchronous operation that, when complete, returns the SmartCardConnection object representing the connection.
 */
Windows.Devices.SmartCards.SmartCard.prototype.connectAsync = function() {};

/**
 * Returns the smart card's Answer to Reset (ATR), a standard series of bytes that contains info about the smart card's characteristics, behaviors, and state.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} The smart card's ATR byte set.
 */
Windows.Devices.SmartCards.SmartCard.prototype.getAnswerToResetAsync = function() {};

/**
 * Returns the smart card's status.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Devices.SmartCards.SmartCardStatus, !Windows.Foundation.IAsyncOperation<Windows.Devices.SmartCards.SmartCardStatus>>} One of the SmartCardStatus enumeration values, representing the smart card's status.
 */
Windows.Devices.SmartCards.SmartCard.prototype.getStatusAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.SmartCards.SmartCardChallengeContext = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.SmartCards.SmartCardChallengeContext.prototype.challenge;

/**
 * Changes the smart card's admin key (also known as an administrator PIN or unblock PIN).
 * @param {!Windows.Storage.Streams.IBuffer} response The response to a smart card authentication challenge/response operation.
 * @param {!Windows.Storage.Streams.IBuffer} newAdministrativeKey The new smart card admin key.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action that completes after the admin key change attempt is done.
 */
Windows.Devices.SmartCards.SmartCardChallengeContext.prototype.changeAdministrativeKeyAsync = function(response, newAdministrativeKey) {};

/**
 * Completes the smart card authentication challenge/response operation and frees associated system resources.
 * @return {void}
 */
Windows.Devices.SmartCards.SmartCardChallengeContext.prototype.close = function() {};

/**
 * Reconfigures an existing, configured smart card with a new response. Optionally, formats the smart card.
 * Reconfigures an existing, configured smart card with a new response and ID. Optionally, formats the smart card.
 * @param {!Windows.Storage.Streams.IBuffer} response The new response to a smart card authentication challenge/response operation.
 * @param {boolean} formatCard True to format the smart card; otherwise false.
 * @param {string=} newCardId The new smart card ID.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action that completes after the smart card reconfiguration attempt is done.
 */
Windows.Devices.SmartCards.SmartCardChallengeContext.prototype.provisionAsync = function(response, formatCard, newCardId) {};

/**
 * Verifies the response to the smart card challenge request.
 * @param {!Windows.Storage.Streams.IBuffer} response The response to the smart card challenge request.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} After the verification attempt is done, true if the response was successfully verified; otherwise false.
 */
Windows.Devices.SmartCards.SmartCardChallengeContext.prototype.verifyResponseAsync = function(response) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.SmartCards.SmartCardConnection = function() {};

/**
 * Completes the smart card authentication challenge/response operation and frees associated system resources.
 * @return {void}
 */
Windows.Devices.SmartCards.SmartCardConnection.prototype.close = function() {};

/**
 * Asynchronously transmits the supplied application protocol data unit (APDU) command and returns the response.
 * @param {!Windows.Storage.Streams.IBuffer} command The APDU command to transmit to the smart card.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} An asynchronous operation that, when completed, returns the response to the command that was transmitted.
 */
Windows.Devices.SmartCards.SmartCardConnection.prototype.transmitAsync = function(command) {};

/** @const */
Windows.Devices.SmartCards.SmartCardPinCharacterPolicyOption = {};
/** @const {number} */
Windows.Devices.SmartCards.SmartCardPinCharacterPolicyOption.allow;
/** @const {number} */
Windows.Devices.SmartCards.SmartCardPinCharacterPolicyOption.requireAtLeastOne;
/** @const {number} */
Windows.Devices.SmartCards.SmartCardPinCharacterPolicyOption.disallow;

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of a set of personal identification number (PIN) rules on a Trusted Platform Module (TPM) virtual smart card.
 */
Windows.Devices.SmartCards.SmartCardPinPolicy = function() {};
 /** @type {Windows.Devices.SmartCards.SmartCardPinCharacterPolicyOption} */
Windows.Devices.SmartCards.SmartCardPinPolicy.prototype.digits;
 /** @type {Windows.Devices.SmartCards.SmartCardPinCharacterPolicyOption} */
Windows.Devices.SmartCards.SmartCardPinPolicy.prototype.lowercaseLetters;
 /** @type {number} */
Windows.Devices.SmartCards.SmartCardPinPolicy.prototype.maxLength;
 /** @type {number} */
Windows.Devices.SmartCards.SmartCardPinPolicy.prototype.minLength;
 /** @type {Windows.Devices.SmartCards.SmartCardPinCharacterPolicyOption} */
Windows.Devices.SmartCards.SmartCardPinPolicy.prototype.specialCharacters;
 /** @type {Windows.Devices.SmartCards.SmartCardPinCharacterPolicyOption} */
Windows.Devices.SmartCards.SmartCardPinPolicy.prototype.uppercaseLetters;
/**
 * @constructor
 * @struct
 */
Windows.Devices.SmartCards.SmartCardPinResetDeferral = function() {};

/**
 * Returns a wait time completion for a smart card personal identification number (PIN) reset.
 * @return {void}
 */
Windows.Devices.SmartCards.SmartCardPinResetDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.SmartCards.SmartCardPinResetRequest = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.SmartCards.SmartCardPinResetRequest.prototype.challenge;
 /** @type {!Date} */
Windows.Devices.SmartCards.SmartCardPinResetRequest.prototype.deadline;

/**
 * Gets an instance of a wait time for a requested smart card personal identification number (PIN) reset.
 * @return {!Windows.Devices.SmartCards.SmartCardPinResetDeferral} An instance of a wait time for a requested smart card PIN reset.
 */
Windows.Devices.SmartCards.SmartCardPinResetRequest.prototype.getDeferral = function() {};

/**
 * Sets the response to a smart card authentication challenge/response operation.
 * @param {!Windows.Storage.Streams.IBuffer} response The response to a smart card authentication challenge/response operation.
 * @return {void}
 */
Windows.Devices.SmartCards.SmartCardPinResetRequest.prototype.setResponse = function(response) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.SmartCards.SmartCardProvisioning = function() {};
 /** @type {?} */
Windows.Devices.SmartCards.SmartCardProvisioning.requestAttestedVirtualSmartCardCreationAsync;
 /** @type {?} */
Windows.Devices.SmartCards.SmartCardProvisioning.prototype.getAuthorityKeyContainerNameAsync;
 /** @type {!Windows.Devices.SmartCards.SmartCard} */
Windows.Devices.SmartCards.SmartCardProvisioning.prototype.smartCard;

/**
 * Returns a smart card to be configured.
 * @param {!Windows.Devices.SmartCards.SmartCard} card The specified smart card.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.SmartCards.SmartCardProvisioning, !Windows.Foundation.IAsyncOperation<!Windows.Devices.SmartCards.SmartCardProvisioning>>} An instance of SmartCardProvisioning , representing the smart card to be configured.
 */
Windows.Devices.SmartCards.SmartCardProvisioning.fromSmartCardAsync = function(card) {};

/**
 * Creates a Trusted Platform Module (TPM) virtual smart card with a given human-readable name, admin key, personal identification number (PIN) rules set, and ID.
 * Creates a Trusted Platform Module (TPM) virtual smart card with a given human-readable name, admin key, and personal identification number (PIN) rules set.
 * @param {string} friendlyName The smart card's human-readable name.
 * @param {!Windows.Storage.Streams.IBuffer} administrativeKey The smart card's admin key (also known as an administrator PIN or unblock PIN).
 * @param {!Windows.Devices.SmartCards.SmartCardPinPolicy} pinPolicy The smart card's PIN rules set.
 * @param {string=} cardId The smart card's ID.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.SmartCards.SmartCardProvisioning, !Windows.Foundation.IAsyncOperation<!Windows.Devices.SmartCards.SmartCardProvisioning>>} After the operation completes, returns an instance of SmartCardProvisioning , representing the configured TPM virtual smart card.
 */
Windows.Devices.SmartCards.SmartCardProvisioning.requestVirtualSmartCardCreationAsync = function(friendlyName, administrativeKey, pinPolicy, cardId) {};

/**
 * Deletes a Trusted Platform Module (TPM) virtual smart card.
 * @param {!Windows.Devices.SmartCards.SmartCard} card The TPM virtual smart card to delete.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} After the deletion attempt completes, returns true if the TPM virtual smart card was successfully deleted; otherwise false.
 */
Windows.Devices.SmartCards.SmartCardProvisioning.requestVirtualSmartCardDeletionAsync = function(card) {};

/**
 * Returns a smart card's authentication challenge/response context.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.SmartCards.SmartCardChallengeContext, !Windows.Foundation.IAsyncOperation<!Windows.Devices.SmartCards.SmartCardChallengeContext>>} After the asynchronous operation completes, returns an instance of SmartCardChalllengeContext , representing the smart card's authentication challenge/response context.
 */
Windows.Devices.SmartCards.SmartCardProvisioning.prototype.getChallengeContextAsync = function() {};

/**
 * Returns the smart card's ID.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} After the asynchronous operation completes, returns the smart card's ID.
 */
Windows.Devices.SmartCards.SmartCardProvisioning.prototype.getIdAsync = function() {};

/**
 * Returns the smart card's minidriver name.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} After the asynchronous operation completes, returns the smart card's name.
 */
Windows.Devices.SmartCards.SmartCardProvisioning.prototype.getNameAsync = function() {};

/**
 * Changes a smart card's personal identification number (PIN).
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} After the smart card PIN change attempt completes, returns true if the smart card's PIN was successfully changed; otherwise false.
 */
Windows.Devices.SmartCards.SmartCardProvisioning.prototype.requestPinChangeAsync = function() {};

/**
 * Resets a smart card's personal identification number (PIN).
 * @param {function(!Windows.Devices.SmartCards.SmartCardProvisioning, !Windows.Devices.SmartCards.SmartCardPinResetRequest): void} handler The method that handles the smart card PIN reset.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} After the smart card PIN reset attempt completes, returns true if the smart card's PIN was successfully reset; otherwise false.
 */
Windows.Devices.SmartCards.SmartCardProvisioning.prototype.requestPinResetAsync = function(handler) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.SmartCards.SmartCardReader = function() {};
 /** @type {string} */
Windows.Devices.SmartCards.SmartCardReader.prototype.deviceId;
 /** @type {Windows.Devices.SmartCards.SmartCardReaderKind} */
Windows.Devices.SmartCards.SmartCardReader.prototype.kind;
 /** @type {string} */
Windows.Devices.SmartCards.SmartCardReader.prototype.name;
 /** @type {function(?): void} */
Windows.Devices.SmartCards.SmartCardReader.prototype.oncardadded;
 /** @type {function(?): void} */
Windows.Devices.SmartCards.SmartCardReader.prototype.oncardremoved;

/**
 * Returns a smart card reader that matches the specified device ID.
 * @param {string} deviceId The smart card reader's device ID.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.SmartCards.SmartCardReader, !Windows.Foundation.IAsyncOperation<!Windows.Devices.SmartCards.SmartCardReader>>} The matching smart card reader.
 */
Windows.Devices.SmartCards.SmartCardReader.fromIdAsync = function(deviceId) {};

/**
 * Returns an Advanced Query Syntax (AQS) string representing a set of a specific type of smart card readers connected to the device. This string is passed to the FindAllAsync method to enumerate the given set of smart card readers.
 * Returns an Advanced Query Syntax (AQS) string representing all smart card readers connected to the device. This string is passed to the FindAllAsync method to enumerate the given set of smart card readers.
 * @param {Windows.Devices.SmartCards.SmartCardReaderKind=} kind One of the enumeration values, representing a specific smart card reader type.
 * @return {string} The Advanced Query Syntax (AQS) string representing a set of the specified type of smart card readers connected to the device. / The Advanced Query Syntax (AQS) string representing all smart card readers connected to the device.
 */
Windows.Devices.SmartCards.SmartCardReader.getDeviceSelector = function(kind) {};

/**
 * Returns a list of info about all smart cards that are connected to the smart card reader.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} After the operation completes, returns the list of info about all smart cards that are connected to the smart card reader.
 */
Windows.Devices.SmartCards.SmartCardReader.prototype.findAllCardsAsync = function() {};

/**
 * Returns the smart card reader's status.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Devices.SmartCards.SmartCardReaderStatus, !Windows.Foundation.IAsyncOperation<Windows.Devices.SmartCards.SmartCardReaderStatus>>} After the status request completes, returns one of the SmartCardReaderStatus enumeration values, representing the smart card reader's status.
 */
Windows.Devices.SmartCards.SmartCardReader.prototype.getStatusAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.SmartCards.SmartCardReader.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.SmartCards.SmartCardReader.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Devices.SmartCards.SmartCardReaderKind = {};
/** @const {number} */
Windows.Devices.SmartCards.SmartCardReaderKind.any;
/** @const {number} */
Windows.Devices.SmartCards.SmartCardReaderKind.generic;
/** @const {number} */
Windows.Devices.SmartCards.SmartCardReaderKind.tpm;
/** @const {number} */
Windows.Devices.SmartCards.SmartCardReaderKind.nfc;
/** @const {number} */
Windows.Devices.SmartCards.SmartCardReaderKind.uicc;

/** @const */
Windows.Devices.SmartCards.SmartCardReaderStatus = {};
/** @const {number} */
Windows.Devices.SmartCards.SmartCardReaderStatus.disconnected;
/** @const {number} */
Windows.Devices.SmartCards.SmartCardReaderStatus.ready;
/** @const {number} */
Windows.Devices.SmartCards.SmartCardReaderStatus.exclusive;

/** @const */
Windows.Devices.SmartCards.SmartCardStatus = {};
/** @const {number} */
Windows.Devices.SmartCards.SmartCardStatus.disconnected;
/** @const {number} */
Windows.Devices.SmartCards.SmartCardStatus.ready;
/** @const {number} */
Windows.Devices.SmartCards.SmartCardStatus.shared;
/** @const {number} */
Windows.Devices.SmartCards.SmartCardStatus.exclusive;
/** @const {number} */
Windows.Devices.SmartCards.SmartCardStatus.unresponsive;

/** @typedef {function(!Windows.Devices.SmartCards.SmartCardProvisioning, !Windows.Devices.SmartCards.SmartCardPinResetRequest): void} */
Windows.Devices.SmartCards.SmartCardPinResetHandler;
/** @const */
Windows.Devices.Sms = {};

/** @const */
Windows.Devices.Sms.CellularClass = {};
/** @const {number} */
Windows.Devices.Sms.CellularClass.none;
/** @const {number} */
Windows.Devices.Sms.CellularClass.gsm;
/** @const {number} */
Windows.Devices.Sms.CellularClass.cdma;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.DeleteSmsMessageOperation = function() {};
 /** @type {function(!Windows.Foundation.IAsyncAction, Windows.Foundation.AsyncStatus): void} */
Windows.Devices.Sms.DeleteSmsMessageOperation.prototype.completed;
 /** @type {!Windows.WinRTError} */
Windows.Devices.Sms.DeleteSmsMessageOperation.prototype.errorCode;
 /** @type {number} */
Windows.Devices.Sms.DeleteSmsMessageOperation.prototype.id;
 /** @type {Windows.Foundation.AsyncStatus} */
Windows.Devices.Sms.DeleteSmsMessageOperation.prototype.status;

/**
 * Cancels the asynchronous SMS message delete operation.
 * @return {void}
 */
Windows.Devices.Sms.DeleteSmsMessageOperation.prototype.cancel = function() {};

/**
 * Closes the asynchronous SMS message delete operation.
 * @return {void}
 */
Windows.Devices.Sms.DeleteSmsMessageOperation.prototype.close = function() {};

/**
 * Retrieves the result of the asynchronous SMS message delete operation.
 * @return {void}
 */
Windows.Devices.Sms.DeleteSmsMessageOperation.prototype.getResults = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.DeleteSmsMessagesOperation = function() {};
 /** @type {function(!Windows.Foundation.IAsyncAction, Windows.Foundation.AsyncStatus): void} */
Windows.Devices.Sms.DeleteSmsMessagesOperation.prototype.completed;
 /** @type {!Windows.WinRTError} */
Windows.Devices.Sms.DeleteSmsMessagesOperation.prototype.errorCode;
 /** @type {number} */
Windows.Devices.Sms.DeleteSmsMessagesOperation.prototype.id;
 /** @type {Windows.Foundation.AsyncStatus} */
Windows.Devices.Sms.DeleteSmsMessagesOperation.prototype.status;

/**
 * Cancels the asynchronous SMS message delete operations.
 * @return {void}
 */
Windows.Devices.Sms.DeleteSmsMessagesOperation.prototype.cancel = function() {};

/**
 * Closes the asynchronous SMS message delete operations.
 * @return {void}
 */
Windows.Devices.Sms.DeleteSmsMessagesOperation.prototype.close = function() {};

/**
 * Retrieves the result of the asynchronous message operations.
 * @return {void}
 */
Windows.Devices.Sms.DeleteSmsMessagesOperation.prototype.getResults = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.GetSmsDeviceOperation = function() {};
 /** @type {function(!Windows.Foundation.IAsyncOperation<!Windows.Devices.Sms.SmsDevice>, Windows.Foundation.AsyncStatus): void} */
Windows.Devices.Sms.GetSmsDeviceOperation.prototype.completed;
 /** @type {!Windows.WinRTError} */
Windows.Devices.Sms.GetSmsDeviceOperation.prototype.errorCode;
 /** @type {number} */
Windows.Devices.Sms.GetSmsDeviceOperation.prototype.id;
 /** @type {Windows.Foundation.AsyncStatus} */
Windows.Devices.Sms.GetSmsDeviceOperation.prototype.status;

/**
 * Cancels the asynchronous SmsDevice object retrieval.
 * @return {void}
 */
Windows.Devices.Sms.GetSmsDeviceOperation.prototype.cancel = function() {};

/**
 * Closes the asynchronous SmsDevice object retrieval operation.
 * @return {void}
 */
Windows.Devices.Sms.GetSmsDeviceOperation.prototype.close = function() {};

/**
 * Gets the results of the asynchronous SmsDevice object retrieval operation.
 * @return {!Windows.Devices.Sms.SmsDevice} A reference to an SmsDevice object.
 */
Windows.Devices.Sms.GetSmsDeviceOperation.prototype.getResults = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.GetSmsMessageOperation = function() {};
 /** @type {function(!Windows.Foundation.IAsyncOperation<!Windows.Devices.Sms.ISmsMessage>, Windows.Foundation.AsyncStatus): void} */
Windows.Devices.Sms.GetSmsMessageOperation.prototype.completed;
 /** @type {!Windows.WinRTError} */
Windows.Devices.Sms.GetSmsMessageOperation.prototype.errorCode;
 /** @type {number} */
Windows.Devices.Sms.GetSmsMessageOperation.prototype.id;
 /** @type {Windows.Foundation.AsyncStatus} */
Windows.Devices.Sms.GetSmsMessageOperation.prototype.status;

/**
 * Cancels the asynchronous SMS message retrieval operation.
 * @return {void}
 */
Windows.Devices.Sms.GetSmsMessageOperation.prototype.cancel = function() {};

/**
 * Closes the asynchronous SMS message retrieval operation.
 * @return {void}
 */
Windows.Devices.Sms.GetSmsMessageOperation.prototype.close = function() {};

/**
 * Retrieves the result of the asynchronous SMS message retrieval operation.
 * @return {!Windows.Devices.Sms.ISmsMessage} An interface that accesses the retrieved message.
 */
Windows.Devices.Sms.GetSmsMessageOperation.prototype.getResults = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.GetSmsMessagesOperation = function() {};
 /** @type {function(!Windows.Foundation.IAsyncOperationWithProgress<!Windows.Foundation.Collections.IVectorView<?>, number>, Windows.Foundation.AsyncStatus): void} */
Windows.Devices.Sms.GetSmsMessagesOperation.prototype.completed;
 /** @type {!Windows.WinRTError} */
Windows.Devices.Sms.GetSmsMessagesOperation.prototype.errorCode;
 /** @type {number} */
Windows.Devices.Sms.GetSmsMessagesOperation.prototype.id;
 /** @type {function(!Windows.Foundation.IAsyncOperationWithProgress<!Windows.Foundation.Collections.IVectorView<?>, number>, number): void} */
Windows.Devices.Sms.GetSmsMessagesOperation.prototype.progress;
 /** @type {Windows.Foundation.AsyncStatus} */
Windows.Devices.Sms.GetSmsMessagesOperation.prototype.status;

/**
 * Cancels the asynchronous operations.
 * @return {void}
 */
Windows.Devices.Sms.GetSmsMessagesOperation.prototype.cancel = function() {};

/**
 * Closes the asynchronous operations.
 * @return {void}
 */
Windows.Devices.Sms.GetSmsMessagesOperation.prototype.close = function() {};

/**
 * Retrieves the result of the asynchronous message retrieval operation.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Sms.ISmsMessage>} A reference to the SMS messages retrieved.
 */
Windows.Devices.Sms.GetSmsMessagesOperation.prototype.getResults = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.SendSmsMessageOperation = function() {};
 /** @type {function(!Windows.Foundation.IAsyncAction, Windows.Foundation.AsyncStatus): void} */
Windows.Devices.Sms.SendSmsMessageOperation.prototype.completed;
 /** @type {!Windows.WinRTError} */
Windows.Devices.Sms.SendSmsMessageOperation.prototype.errorCode;
 /** @type {number} */
Windows.Devices.Sms.SendSmsMessageOperation.prototype.id;
 /** @type {Windows.Foundation.AsyncStatus} */
Windows.Devices.Sms.SendSmsMessageOperation.prototype.status;

/**
 * Cancels the asynchronous operation.
 * @return {void}
 */
Windows.Devices.Sms.SendSmsMessageOperation.prototype.cancel = function() {};

/**
 * Closes the asynchronous operation.
 * @return {void}
 */
Windows.Devices.Sms.SendSmsMessageOperation.prototype.close = function() {};

/**
 * Retrieves the result of the asynchronous operation.
 * @return {void}
 */
Windows.Devices.Sms.SendSmsMessageOperation.prototype.getResults = function() {};

/**
 * @constructor
 * @struct
 * Constructor. Used to create an SmsAppMessage prior to sending it.
 */
Windows.Devices.Sms.SmsAppMessage = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Sms.SmsAppMessage.prototype.binaryBody;
 /** @type {string} */
Windows.Devices.Sms.SmsAppMessage.prototype.body;
 /** @type {string} */
Windows.Devices.Sms.SmsAppMessage.prototype.callbackNumber;
 /** @type {Windows.Devices.Sms.CellularClass} */
Windows.Devices.Sms.SmsAppMessage.prototype.cellularClass;
 /** @type {string} */
Windows.Devices.Sms.SmsAppMessage.prototype.deviceId;
 /** @type {Windows.Devices.Sms.SmsEncoding} */
Windows.Devices.Sms.SmsAppMessage.prototype.encoding;
 /** @type {string} */
Windows.Devices.Sms.SmsAppMessage.prototype.from;
 /** @type {boolean} */
Windows.Devices.Sms.SmsAppMessage.prototype.isDeliveryNotificationEnabled;
 /** @type {Windows.Devices.Sms.SmsMessageClass} */
Windows.Devices.Sms.SmsAppMessage.prototype.messageClass;
 /** @type {Windows.Devices.Sms.SmsMessageType} */
Windows.Devices.Sms.SmsAppMessage.prototype.messageType;
 /** @type {number} */
Windows.Devices.Sms.SmsAppMessage.prototype.portNumber;
 /** @type {number} */
Windows.Devices.Sms.SmsAppMessage.prototype.protocolId;
 /** @type {number} */
Windows.Devices.Sms.SmsAppMessage.prototype.retryAttemptCount;
 /** @type {string} */
Windows.Devices.Sms.SmsAppMessage.prototype.simIccId;
 /** @type {number} */
Windows.Devices.Sms.SmsAppMessage.prototype.teleserviceId;
 /** @type {!Date} */
Windows.Devices.Sms.SmsAppMessage.prototype.timestamp;
 /** @type {string} */
Windows.Devices.Sms.SmsAppMessage.prototype.to;

/**
 * @constructor
 * @struct
 * Creates an instance of the SmsBinaryMessage class.
 */
Windows.Devices.Sms.SmsBinaryMessage = function() {};
 /** @type {Windows.Devices.Sms.SmsDataFormat} */
Windows.Devices.Sms.SmsBinaryMessage.prototype.format;
 /** @type {number} */
Windows.Devices.Sms.SmsBinaryMessage.prototype.id;
 /** @type {Windows.Devices.Sms.SmsMessageClass} */
Windows.Devices.Sms.SmsBinaryMessage.prototype.messageClass;

/**
 * Returns the raw buffer of the message in binary protocol description unit (PDU) format as a byte array.
 * @return {!Array<number>} A byte array representing message data. If there is no message data, the returned array is empty.
 */
Windows.Devices.Sms.SmsBinaryMessage.prototype.getData = function() {};

/**
 * Specifies the raw binary payload of the SMS message. It should be formatted according to the protocol description unit (PDU) standard.
 * @param {!Array<number>} value A byte array representing message data. If there is no message data, the returned array is empty.
 * @return {void}
 */
Windows.Devices.Sms.SmsBinaryMessage.prototype.setData = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.SmsBroadcastMessage = function() {};
 /** @type {string} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.body;
 /** @type {Windows.Devices.Sms.SmsBroadcastType} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.broadcastType;
 /** @type {Windows.Devices.Sms.CellularClass} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.cellularClass;
 /** @type {number} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.channel;
 /** @type {string} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.deviceId;
 /** @type {Windows.Devices.Sms.SmsGeographicalScope} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.geographicalScope;
 /** @type {boolean} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.isEmergencyAlert;
 /** @type {boolean} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.isUserPopupRequested;
 /** @type {Windows.Devices.Sms.SmsMessageClass} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.messageClass;
 /** @type {number} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.messageCode;
 /** @type {Windows.Devices.Sms.SmsMessageType} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.messageType;
 /** @type {string} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.simIccId;
 /** @type {!Date} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.timestamp;
 /** @type {string} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.to;
 /** @type {number} */
Windows.Devices.Sms.SmsBroadcastMessage.prototype.updateNumber;

/** @const */
Windows.Devices.Sms.SmsBroadcastType = {};
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.other;
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.cmasPresidential;
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.cmasExtreme;
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.cmasSevere;
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.cmasAmber;
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.cmasTest;
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.euAlert1;
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.euAlert2;
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.euAlert3;
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.euAlertAmber;
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.euAlertInfo;
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.etwsEarthquake;
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.etwsTsunami;
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.etwsTsunamiAndEarthquake;
/** @const {number} */
Windows.Devices.Sms.SmsBroadcastType.latAlertLocal;

/** @const */
Windows.Devices.Sms.SmsDataFormat = {};
/** @const {number} */
Windows.Devices.Sms.SmsDataFormat.unknown;
/** @const {number} */
Windows.Devices.Sms.SmsDataFormat.cdmaSubmit;
/** @const {number} */
Windows.Devices.Sms.SmsDataFormat.gsmSubmit;
/** @const {number} */
Windows.Devices.Sms.SmsDataFormat.cdmaDeliver;
/** @const {number} */
Windows.Devices.Sms.SmsDataFormat.gsmDeliver;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.SmsDevice = function() {};
 /** @type {string} */
Windows.Devices.Sms.SmsDevice.prototype.accountPhoneNumber;
 /** @type {Windows.Devices.Sms.CellularClass} */
Windows.Devices.Sms.SmsDevice.prototype.cellularClass;
 /** @type {Windows.Devices.Sms.SmsDeviceStatus} */
Windows.Devices.Sms.SmsDevice.prototype.deviceStatus;
 /** @type {!Windows.Devices.Sms.SmsDeviceMessageStore} */
Windows.Devices.Sms.SmsDevice.prototype.messageStore;
 /** @type {function(!Windows.WinRTEvent<!Windows.Devices.Sms.SmsDevice>): void} */
Windows.Devices.Sms.SmsDevice.prototype.onsmsdevicestatuschanged;
 /** @type {function(?): void} */
Windows.Devices.Sms.SmsDevice.prototype.onsmsmessagereceived;

/**
 * Creates an instance of SmsDevice for the device that received the SMS message.
 * @param {string} deviceId A string representation of the DeviceInformation ID of the SMS device that received the SMS message.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Sms.SmsDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Sms.SmsDevice>>} The SMS device operation object.
 */
Windows.Devices.Sms.SmsDevice.fromIdAsync = function(deviceId) {};

/**
 * Creates an instance of SmsDevice for the specified Mobile Broadband network account ID.
 * @param {string} networkAccountId The Mobile Broadband network account ID to use to select the corresponding mobile broadband device to use for the SMS device
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Sms.SmsDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Sms.SmsDevice>>} When this method completes, it returns the SmsDevice for the specified Mobile Broadband network account ID.
 */
Windows.Devices.Sms.SmsDevice.fromNetworkAccountIdAsync = function(networkAccountId) {};

/**
 * Creates an instance of an SmsDevice object associated with the default SMS device. Because the device might be busy, the operation executes asynchronously. The asynchronous operation object returns immediately.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Sms.SmsDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Sms.SmsDevice>>} A reference to an IAsyncOperation(SmsDevice) object that supports asynchronous SmsDevice object retrieval.
 */
Windows.Devices.Sms.SmsDevice.getDefaultAsync = function() {};

/**
 * Retrieves the class selection string that can be used to enumerate SMS devices.
 * @return {string} A reference to an Advanced Query Syntax (AQS) string that identifies an SMS device.
 */
Windows.Devices.Sms.SmsDevice.getDeviceSelector = function() {};

/**
 * Estimates the transmitted message length of the specified text message. The estimate can be useful to clients who want to give an indication of how many messages will be sent on the network to carry the text of the full message.
 * @param {!Windows.Devices.Sms.SmsTextMessage} message A reference to the SMS text message to measure.
 * @return {!Windows.Devices.Sms.SmsEncodedLength} A reference to an SmsEncodedLength structure that is populated with the length information.
 */
Windows.Devices.Sms.SmsDevice.prototype.calculateLength = function(message) {};

/**
 * @param {string} type
 * @param {function(!Windows.WinRTEvent<!Windows.Devices.Sms.SmsDevice>): void|function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sms.SmsDevice.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(!Windows.WinRTEvent<!Windows.Devices.Sms.SmsDevice>): void|function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sms.SmsDevice.prototype.removeEventListener = function(type, listener) {};

/**
 * Asynchronously sends a message using the SMS device. The method is asynchronous because the send operation might not occur instantaneously. The message operation object is returned immediately.
 * @param {!Windows.Devices.Sms.ISmsMessage} message A reference to an ISmsMessage object. The message can be in text or binary format.
 * @return {!Windows.Foundation.IPromiseWithOperation<?, !Windows.Devices.Sms.SendSmsMessageOperation>} The message operation object.
 */
Windows.Devices.Sms.SmsDevice.prototype.sendMessageAsync = function(message) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.SmsDevice2 = function() {};
 /** @type {string} */
Windows.Devices.Sms.SmsDevice2.prototype.accountPhoneNumber;
 /** @type {Windows.Devices.Sms.CellularClass} */
Windows.Devices.Sms.SmsDevice2.prototype.cellularClass;
 /** @type {string} */
Windows.Devices.Sms.SmsDevice2.prototype.deviceId;
 /** @type {Windows.Devices.Sms.SmsDeviceStatus} */
Windows.Devices.Sms.SmsDevice2.prototype.deviceStatus;
 /** @type {function(?): void} */
Windows.Devices.Sms.SmsDevice2.prototype.ondevicestatuschanged;
 /** @type {string} */
Windows.Devices.Sms.SmsDevice2.prototype.parentDeviceId;
 /** @type {string} */
Windows.Devices.Sms.SmsDevice2.prototype.smscAddress;

/**
 * Creates an instance of SmsDevice2 for a device that received an SMS message.
 * @param {string} deviceId A string representation of the device ID of the device that received an SMS message.
 * @return {!Windows.Devices.Sms.SmsDevice2} An instance of SmsDevice2 initialized for the device with the given ID.
 */
Windows.Devices.Sms.SmsDevice2.fromId = function(deviceId) {};

/**
 * Creates an instance of SmsDevice2 for a device, given the device ID of the parent device.
 * @param {string} parentDeviceId The device ID of the parent device.
 * @return {!Windows.Devices.Sms.SmsDevice2} An instance of SmsDevice2 initialized for the device with the given parent ID.
 */
Windows.Devices.Sms.SmsDevice2.fromParentId = function(parentDeviceId) {};

/**
 * Creates an instance of SmsDevice2 associated with the default SMS device.
 * @return {!Windows.Devices.Sms.SmsDevice2} An instance of SmsDevice2 initialized for the default SMS device.
 */
Windows.Devices.Sms.SmsDevice2.getDefault = function() {};

/**
 * Retrieves the class selection string that can be used to enumerate SMS devices.
 * @return {string} A reference to an Advanced Query Syntax (AQS) string that identifies an SMS device.
 */
Windows.Devices.Sms.SmsDevice2.getDeviceSelector = function() {};

/**
 * Estimates the transmitted message length of the specified text message. The estimate can be useful to clients that want to give an indication of how many messages will be sent on the network to carry the text of the full message.
 * @param {!Windows.Devices.Sms.ISmsMessageBase} message A reference to the SMS text message to measure.
 * @return {!Windows.Devices.Sms.SmsEncodedLength} A reference to an SmsEncodedLength structure that is populated with the length information.
 */
Windows.Devices.Sms.SmsDevice2.prototype.calculateLength = function(message) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sms.SmsDevice2.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sms.SmsDevice2.prototype.removeEventListener = function(type, listener) {};

/**
 * Asynchronously sends a message using the SMS device. The method is asynchronous because the send operation might not occur instantaneously. The message operation object is returned immediately.
 * @param {!Windows.Devices.Sms.ISmsMessageBase} message A reference to an object that implements the ISmsMessageBase interface. The message can be in text or binary format.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Sms.SmsSendMessageResult, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Sms.SmsSendMessageResult>>} The message operation object.
 */
Windows.Devices.Sms.SmsDevice2.prototype.sendMessageAndGetResultAsync = function(message) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.SmsDeviceMessageStore = function() {};
 /** @type {number} */
Windows.Devices.Sms.SmsDeviceMessageStore.prototype.maxMessages;

/**
 * Deletes the message with the specified ID. Because the device might be busy, the operation executes asynchronously. The asynchronous operation object returns immediately.
 * @param {number} messageId Integer ID of the message to delete, which was previously read from an SmsTextMessage object obtained from the device message store.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} A new message operation object that is used to start and track the asynchronous operation.
 */
Windows.Devices.Sms.SmsDeviceMessageStore.prototype.deleteMessageAsync = function(messageId) {};

/**
 * Deletes the messages to which the filter applies. The filter can be used to delete all messages, or only messages that are read, unread, sent, or in a draft state. Because the operation might not be instantaneous, it executes asynchronously. The asynchronous operation object returns immediately.
 * @param {Windows.Devices.Sms.SmsMessageFilter} messageFilter A search filter that specifies which messages to delete.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} A new message operation object that is used to start and track the asynchronous operation.
 */
Windows.Devices.Sms.SmsDeviceMessageStore.prototype.deleteMessagesAsync = function(messageFilter) {};

/**
 * Retrieves the message with the specified ID. The device might be busy, so the method executes asynchronously. The asynchronous operation object returns immediately.
 * @param {number} messageId ID of the message to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Sms.ISmsMessage, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Sms.ISmsMessage>>} Returns a new message operation object that is used to start and track the asynchronous operation.
 */
Windows.Devices.Sms.SmsDeviceMessageStore.prototype.getMessageAsync = function(messageId) {};

/**
 * Retrieves a list of messages that match the conditions specified in a filter. The messages can be filtered as read, unread, sent, or in the draft state.
 * @param {Windows.Devices.Sms.SmsMessageFilter} messageFilter ID of the message to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Foundation.Collections.IVectorView<?>, number>>} Returns a new message operation object that is used to start and track the asynchronous operation.
 */
Windows.Devices.Sms.SmsDeviceMessageStore.prototype.getMessagesAsync = function(messageFilter) {};

/** @const */
Windows.Devices.Sms.SmsDeviceStatus = {};
/** @const {number} */
Windows.Devices.Sms.SmsDeviceStatus.off;
/** @const {number} */
Windows.Devices.Sms.SmsDeviceStatus.ready;
/** @const {number} */
Windows.Devices.Sms.SmsDeviceStatus.simNotInserted;
/** @const {number} */
Windows.Devices.Sms.SmsDeviceStatus.badSim;
/** @const {number} */
Windows.Devices.Sms.SmsDeviceStatus.deviceFailure;
/** @const {number} */
Windows.Devices.Sms.SmsDeviceStatus.subscriptionNotActivated;
/** @const {number} */
Windows.Devices.Sms.SmsDeviceStatus.deviceLocked;
/** @const {number} */
Windows.Devices.Sms.SmsDeviceStatus.deviceBlocked;

/** @const */
Windows.Devices.Sms.SmsEncoding = {};
/** @const {number} */
Windows.Devices.Sms.SmsEncoding.unknown;
/** @const {number} */
Windows.Devices.Sms.SmsEncoding.optimal;
/** @const {number} */
Windows.Devices.Sms.SmsEncoding.sevenBitAscii;
/** @const {number} */
Windows.Devices.Sms.SmsEncoding.unicode;
/** @const {number} */
Windows.Devices.Sms.SmsEncoding.gsmSevenBit;
/** @const {number} */
Windows.Devices.Sms.SmsEncoding.eightBit;
/** @const {number} */
Windows.Devices.Sms.SmsEncoding.latin;
/** @const {number} */
Windows.Devices.Sms.SmsEncoding.korean;
/** @const {number} */
Windows.Devices.Sms.SmsEncoding.ia5;
/** @const {number} */
Windows.Devices.Sms.SmsEncoding.shiftJis;
/** @const {number} */
Windows.Devices.Sms.SmsEncoding.latinHebrew;

/** @const */
Windows.Devices.Sms.SmsFilterActionType = {};
/** @const {number} */
Windows.Devices.Sms.SmsFilterActionType.acceptImmediately;
/** @const {number} */
Windows.Devices.Sms.SmsFilterActionType.drop;
/** @const {number} */
Windows.Devices.Sms.SmsFilterActionType.peek;
/** @const {number} */
Windows.Devices.Sms.SmsFilterActionType.accept;

/**
 * @constructor
 * @struct
 * Creates a new, empty SmsFilterRule .
 * @param {Windows.Devices.Sms.SmsMessageType} messageType An enumeration value specifying the message type that will match this rule.
 */
Windows.Devices.Sms.SmsFilterRule = function(messageType) {};
 /** @type {!Windows.Foundation.Collections.IVector<number>} */
Windows.Devices.Sms.SmsFilterRule.prototype.broadcastChannels;
 /** @type {!Windows.Foundation.Collections.IVector<Windows.Devices.Sms.SmsBroadcastType>} */
Windows.Devices.Sms.SmsFilterRule.prototype.broadcastTypes;
 /** @type {Windows.Devices.Sms.CellularClass} */
Windows.Devices.Sms.SmsFilterRule.prototype.cellularClass;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Devices.Sms.SmsFilterRule.prototype.deviceIds;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Devices.Sms.SmsFilterRule.prototype.imsiPrefixes;
 /** @type {Windows.Devices.Sms.SmsMessageType} */
Windows.Devices.Sms.SmsFilterRule.prototype.messageType;
 /** @type {!Windows.Foundation.Collections.IVector<number>} */
Windows.Devices.Sms.SmsFilterRule.prototype.portNumbers;
 /** @type {!Windows.Foundation.Collections.IVector<number>} */
Windows.Devices.Sms.SmsFilterRule.prototype.protocolIds;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Devices.Sms.SmsFilterRule.prototype.senderNumbers;
 /** @type {!Windows.Foundation.Collections.IVector<number>} */
Windows.Devices.Sms.SmsFilterRule.prototype.teleserviceIds;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Devices.Sms.SmsFilterRule.prototype.textMessagePrefixes;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Devices.Sms.SmsFilterRule.prototype.wapApplicationIds;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Devices.Sms.SmsFilterRule.prototype.wapContentTypes;

/**
 * @constructor
 * @struct
 * Creates an instance of SmsFilterRules .
 * @param {Windows.Devices.Sms.SmsFilterActionType} actionType An enumeration value that specifies which action type is to be associated with the rules for this instance. Action type determines the order in which rules are evaluated, as well as the action to be taken when a rule is matched.
 */
Windows.Devices.Sms.SmsFilterRules = function(actionType) {};
 /** @type {Windows.Devices.Sms.SmsFilterActionType} */
Windows.Devices.Sms.SmsFilterRules.prototype.actionType;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Devices.Sms.SmsFilterRule>} */
Windows.Devices.Sms.SmsFilterRules.prototype.rules;

/** @const */
Windows.Devices.Sms.SmsGeographicalScope = {};
/** @const {number} */
Windows.Devices.Sms.SmsGeographicalScope.none;
/** @const {number} */
Windows.Devices.Sms.SmsGeographicalScope.cellWithImmediateDisplay;
/** @const {number} */
Windows.Devices.Sms.SmsGeographicalScope.locationArea;
/** @const {number} */
Windows.Devices.Sms.SmsGeographicalScope.plmn;
/** @const {number} */
Windows.Devices.Sms.SmsGeographicalScope.cell;

/** @const */
Windows.Devices.Sms.SmsMessageClass = {};
/** @const {number} */
Windows.Devices.Sms.SmsMessageClass.none;
/** @const {number} */
Windows.Devices.Sms.SmsMessageClass.class0;
/** @const {number} */
Windows.Devices.Sms.SmsMessageClass.class1;
/** @const {number} */
Windows.Devices.Sms.SmsMessageClass.class2;
/** @const {number} */
Windows.Devices.Sms.SmsMessageClass.class3;

/** @const */
Windows.Devices.Sms.SmsMessageFilter = {};
/** @const {number} */
Windows.Devices.Sms.SmsMessageFilter.all;
/** @const {number} */
Windows.Devices.Sms.SmsMessageFilter.unread;
/** @const {number} */
Windows.Devices.Sms.SmsMessageFilter.read;
/** @const {number} */
Windows.Devices.Sms.SmsMessageFilter.sent;
/** @const {number} */
Windows.Devices.Sms.SmsMessageFilter.draft;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.SmsMessageReceivedEventArgs = function() {};
 /** @type {!Windows.Devices.Sms.SmsBinaryMessage} */
Windows.Devices.Sms.SmsMessageReceivedEventArgs.prototype.binaryMessage;
 /** @type {!Windows.Devices.Sms.SmsTextMessage} */
Windows.Devices.Sms.SmsMessageReceivedEventArgs.prototype.textMessage;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.SmsMessageReceivedTriggerDetails = function() {};
 /** @type {!Windows.Devices.Sms.SmsAppMessage} */
Windows.Devices.Sms.SmsMessageReceivedTriggerDetails.prototype.appMessage;
 /** @type {!Windows.Devices.Sms.SmsBroadcastMessage} */
Windows.Devices.Sms.SmsMessageReceivedTriggerDetails.prototype.broadcastMessage;
 /** @type {Windows.Devices.Sms.SmsMessageType} */
Windows.Devices.Sms.SmsMessageReceivedTriggerDetails.prototype.messageType;
 /** @type {!Windows.Devices.Sms.SmsStatusMessage} */
Windows.Devices.Sms.SmsMessageReceivedTriggerDetails.prototype.statusMessage;
 /** @type {!Windows.Devices.Sms.SmsTextMessage2} */
Windows.Devices.Sms.SmsMessageReceivedTriggerDetails.prototype.textMessage;
 /** @type {!Windows.Devices.Sms.SmsVoicemailMessage} */
Windows.Devices.Sms.SmsMessageReceivedTriggerDetails.prototype.voicemailMessage;
 /** @type {!Windows.Devices.Sms.SmsWapMessage} */
Windows.Devices.Sms.SmsMessageReceivedTriggerDetails.prototype.wapMessage;

/**
 * Delivers the filtered message to the messaging app.
 * @return {void}
 */
Windows.Devices.Sms.SmsMessageReceivedTriggerDetails.prototype.accept = function() {};

/**
 * Drops the filtered message, so that it is not passed on to the messaging app.
 * @return {void}
 */
Windows.Devices.Sms.SmsMessageReceivedTriggerDetails.prototype.drop = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.SmsMessageRegistration = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Sms.SmsMessageRegistration>} */
Windows.Devices.Sms.SmsMessageRegistration.allRegistrations;
 /** @type {string} */
Windows.Devices.Sms.SmsMessageRegistration.prototype.id;
 /** @type {function(?): void} */
Windows.Devices.Sms.SmsMessageRegistration.prototype.onmessagereceived;

/**
 * Registers a message filter.
 * @param {string} id Identifier used to describe this message filter.
 * @param {!Windows.Devices.Sms.SmsFilterRules} filterRules An object that represents the filter rules to be used for this registered message filter.
 * @return {!Windows.Devices.Sms.SmsMessageRegistration} On successful completion, the SmsMessageRegistration object that represents this registered message filter.
 */
Windows.Devices.Sms.SmsMessageRegistration.register = function(id, filterRules) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sms.SmsMessageRegistration.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Sms.SmsMessageRegistration.prototype.removeEventListener = function(type, listener) {};

/**
 * Unregisters a previously-registered message filter. The filter will no longer be applied to incoming messages.
 * @return {void}
 */
Windows.Devices.Sms.SmsMessageRegistration.prototype.unregister = function() {};

/** @const */
Windows.Devices.Sms.SmsMessageType = {};
/** @const {number} */
Windows.Devices.Sms.SmsMessageType.binary;
/** @const {number} */
Windows.Devices.Sms.SmsMessageType.text;
/** @const {number} */
Windows.Devices.Sms.SmsMessageType.wap;
/** @const {number} */
Windows.Devices.Sms.SmsMessageType.app;
/** @const {number} */
Windows.Devices.Sms.SmsMessageType.broadcast;
/** @const {number} */
Windows.Devices.Sms.SmsMessageType.voicemail;
/** @const {number} */
Windows.Devices.Sms.SmsMessageType.status;

/** @const */
Windows.Devices.Sms.SmsModemErrorCode = {};
/** @const {number} */
Windows.Devices.Sms.SmsModemErrorCode.other;
/** @const {number} */
Windows.Devices.Sms.SmsModemErrorCode.messagingNetworkError;
/** @const {number} */
Windows.Devices.Sms.SmsModemErrorCode.smsOperationNotSupportedByDevice;
/** @const {number} */
Windows.Devices.Sms.SmsModemErrorCode.smsServiceNotSupportedByNetwork;
/** @const {number} */
Windows.Devices.Sms.SmsModemErrorCode.deviceFailure;
/** @const {number} */
Windows.Devices.Sms.SmsModemErrorCode.messageNotEncodedProperly;
/** @const {number} */
Windows.Devices.Sms.SmsModemErrorCode.messageTooLarge;
/** @const {number} */
Windows.Devices.Sms.SmsModemErrorCode.deviceNotReady;
/** @const {number} */
Windows.Devices.Sms.SmsModemErrorCode.networkNotReady;
/** @const {number} */
Windows.Devices.Sms.SmsModemErrorCode.invalidSmscAddress;
/** @const {number} */
Windows.Devices.Sms.SmsModemErrorCode.networkFailure;
/** @const {number} */
Windows.Devices.Sms.SmsModemErrorCode.fixedDialingNumberRestricted;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.SmsReceivedEventDetails = function() {};
 /** @type {!Windows.Devices.Sms.SmsBinaryMessage} */
Windows.Devices.Sms.SmsReceivedEventDetails.prototype.binaryMessage;
 /** @type {string} */
Windows.Devices.Sms.SmsReceivedEventDetails.prototype.deviceId;
 /** @type {Windows.Devices.Sms.SmsMessageClass} */
Windows.Devices.Sms.SmsReceivedEventDetails.prototype.messageClass;
 /** @type {number} */
Windows.Devices.Sms.SmsReceivedEventDetails.prototype.messageIndex;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.SmsSendMessageResult = function() {};
 /** @type {Windows.Devices.Sms.CellularClass} */
Windows.Devices.Sms.SmsSendMessageResult.prototype.cellularClass;
 /** @type {boolean} */
Windows.Devices.Sms.SmsSendMessageResult.prototype.isErrorTransient;
 /** @type {boolean} */
Windows.Devices.Sms.SmsSendMessageResult.prototype.isSuccessful;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Devices.Sms.SmsSendMessageResult.prototype.messageReferenceNumbers;
 /** @type {Windows.Devices.Sms.SmsModemErrorCode} */
Windows.Devices.Sms.SmsSendMessageResult.prototype.modemErrorCode;
 /** @type {number} */
Windows.Devices.Sms.SmsSendMessageResult.prototype.networkCauseCode;
 /** @type {number} */
Windows.Devices.Sms.SmsSendMessageResult.prototype.transportFailureCause;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.SmsStatusMessage = function() {};
 /** @type {string} */
Windows.Devices.Sms.SmsStatusMessage.prototype.body;
 /** @type {Windows.Devices.Sms.CellularClass} */
Windows.Devices.Sms.SmsStatusMessage.prototype.cellularClass;
 /** @type {string} */
Windows.Devices.Sms.SmsStatusMessage.prototype.deviceId;
 /** @type {!Date} */
Windows.Devices.Sms.SmsStatusMessage.prototype.dischargeTime;
 /** @type {string} */
Windows.Devices.Sms.SmsStatusMessage.prototype.from;
 /** @type {Windows.Devices.Sms.SmsMessageClass} */
Windows.Devices.Sms.SmsStatusMessage.prototype.messageClass;
 /** @type {number} */
Windows.Devices.Sms.SmsStatusMessage.prototype.messageReferenceNumber;
 /** @type {Windows.Devices.Sms.SmsMessageType} */
Windows.Devices.Sms.SmsStatusMessage.prototype.messageType;
 /** @type {!Date} */
Windows.Devices.Sms.SmsStatusMessage.prototype.serviceCenterTimestamp;
 /** @type {string} */
Windows.Devices.Sms.SmsStatusMessage.prototype.simIccId;
 /** @type {number} */
Windows.Devices.Sms.SmsStatusMessage.prototype.status;
 /** @type {string} */
Windows.Devices.Sms.SmsStatusMessage.prototype.to;

/**
 * @constructor
 * @struct
 * Creates an instance of the SmsTextMessage class.
 */
Windows.Devices.Sms.SmsTextMessage = function() {};
 /** @type {string} */
Windows.Devices.Sms.SmsTextMessage.prototype.body;
 /** @type {Windows.Devices.Sms.SmsEncoding} */
Windows.Devices.Sms.SmsTextMessage.prototype.encoding;
 /** @type {string} */
Windows.Devices.Sms.SmsTextMessage.prototype.from;
 /** @type {number} */
Windows.Devices.Sms.SmsTextMessage.prototype.id;
 /** @type {Windows.Devices.Sms.SmsMessageClass} */
Windows.Devices.Sms.SmsTextMessage.prototype.messageClass;
 /** @type {number} */
Windows.Devices.Sms.SmsTextMessage.prototype.partCount;
 /** @type {number} */
Windows.Devices.Sms.SmsTextMessage.prototype.partNumber;
 /** @type {number} */
Windows.Devices.Sms.SmsTextMessage.prototype.partReferenceId;
 /** @type {!Date} */
Windows.Devices.Sms.SmsTextMessage.prototype.timestamp;
 /** @type {string} */
Windows.Devices.Sms.SmsTextMessage.prototype.to;

/**
 * Decodes a binary message and places the results in a new instance of a text message. This method represents the binary message as a reference to a buffer of bytes and a selection of how the buffer is encoded. Therefore, it can be used when the message did not originate directly from the device or as an instance of an SmsBinaryMessage class.
 * @param {Windows.Devices.Sms.SmsDataFormat} format An SmsDataFormat enumerated value that identifies the format of a particular protocol description unit (PDU) buffer.
 * @param {!Array<number>} value An array of bytes containing the binary data to decode.
 * @return {!Windows.Devices.Sms.SmsTextMessage} A new SmsTextMessage object if the decoding was successful.
 */
Windows.Devices.Sms.SmsTextMessage.fromBinaryData = function(format, value) {};

/**
 * Reads a binary message and decodes it. The results are placed in a new instance of a text message.
 * @param {!Windows.Devices.Sms.SmsBinaryMessage} binaryMessage An instance of a binary message to decode.
 * @return {!Windows.Devices.Sms.SmsTextMessage} A new SmsTextMessage object.
 */
Windows.Devices.Sms.SmsTextMessage.fromBinaryMessage = function(binaryMessage) {};

/**
 * Reads a message in the specified format and places the results in a new instance of a binary message.
 * @param {Windows.Devices.Sms.SmsDataFormat} format A value from the SmsDataFormat enumeration.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Sms.ISmsBinaryMessage>} The new binary message that holds the result of this method call.
 */
Windows.Devices.Sms.SmsTextMessage.prototype.toBinaryMessages = function(format) {};

/**
 * @constructor
 * @struct
 * Constructs a new, default instance of this class.
 */
Windows.Devices.Sms.SmsTextMessage2 = function() {};
 /** @type {string} */
Windows.Devices.Sms.SmsTextMessage2.prototype.body;
 /** @type {string} */
Windows.Devices.Sms.SmsTextMessage2.prototype.callbackNumber;
 /** @type {Windows.Devices.Sms.CellularClass} */
Windows.Devices.Sms.SmsTextMessage2.prototype.cellularClass;
 /** @type {string} */
Windows.Devices.Sms.SmsTextMessage2.prototype.deviceId;
 /** @type {Windows.Devices.Sms.SmsEncoding} */
Windows.Devices.Sms.SmsTextMessage2.prototype.encoding;
 /** @type {string} */
Windows.Devices.Sms.SmsTextMessage2.prototype.from;
 /** @type {boolean} */
Windows.Devices.Sms.SmsTextMessage2.prototype.isDeliveryNotificationEnabled;
 /** @type {Windows.Devices.Sms.SmsMessageClass} */
Windows.Devices.Sms.SmsTextMessage2.prototype.messageClass;
 /** @type {Windows.Devices.Sms.SmsMessageType} */
Windows.Devices.Sms.SmsTextMessage2.prototype.messageType;
 /** @type {number} */
Windows.Devices.Sms.SmsTextMessage2.prototype.protocolId;
 /** @type {number} */
Windows.Devices.Sms.SmsTextMessage2.prototype.retryAttemptCount;
 /** @type {string} */
Windows.Devices.Sms.SmsTextMessage2.prototype.simIccId;
 /** @type {number} */
Windows.Devices.Sms.SmsTextMessage2.prototype.teleserviceId;
 /** @type {!Date} */
Windows.Devices.Sms.SmsTextMessage2.prototype.timestamp;
 /** @type {string} */
Windows.Devices.Sms.SmsTextMessage2.prototype.to;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.SmsVoicemailMessage = function() {};
 /** @type {string} */
Windows.Devices.Sms.SmsVoicemailMessage.prototype.body;
 /** @type {Windows.Devices.Sms.CellularClass} */
Windows.Devices.Sms.SmsVoicemailMessage.prototype.cellularClass;
 /** @type {string} */
Windows.Devices.Sms.SmsVoicemailMessage.prototype.deviceId;
 /** @type {Windows.Devices.Sms.SmsMessageClass} */
Windows.Devices.Sms.SmsVoicemailMessage.prototype.messageClass;
 /** @type {number} */
Windows.Devices.Sms.SmsVoicemailMessage.prototype.messageCount;
 /** @type {Windows.Devices.Sms.SmsMessageType} */
Windows.Devices.Sms.SmsVoicemailMessage.prototype.messageType;
 /** @type {string} */
Windows.Devices.Sms.SmsVoicemailMessage.prototype.simIccId;
 /** @type {!Date} */
Windows.Devices.Sms.SmsVoicemailMessage.prototype.timestamp;
 /** @type {string} */
Windows.Devices.Sms.SmsVoicemailMessage.prototype.to;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Sms.SmsWapMessage = function() {};
 /** @type {string} */
Windows.Devices.Sms.SmsWapMessage.prototype.applicationId;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Sms.SmsWapMessage.prototype.binaryBody;
 /** @type {Windows.Devices.Sms.CellularClass} */
Windows.Devices.Sms.SmsWapMessage.prototype.cellularClass;
 /** @type {string} */
Windows.Devices.Sms.SmsWapMessage.prototype.contentType;
 /** @type {string} */
Windows.Devices.Sms.SmsWapMessage.prototype.deviceId;
 /** @type {string} */
Windows.Devices.Sms.SmsWapMessage.prototype.from;
 /** @type {!Windows.Foundation.Collections.IMap<string, string>} */
Windows.Devices.Sms.SmsWapMessage.prototype.headers;
 /** @type {Windows.Devices.Sms.SmsMessageClass} */
Windows.Devices.Sms.SmsWapMessage.prototype.messageClass;
 /** @type {Windows.Devices.Sms.SmsMessageType} */
Windows.Devices.Sms.SmsWapMessage.prototype.messageType;
 /** @type {string} */
Windows.Devices.Sms.SmsWapMessage.prototype.simIccId;
 /** @type {!Date} */
Windows.Devices.Sms.SmsWapMessage.prototype.timestamp;
 /** @type {string} */
Windows.Devices.Sms.SmsWapMessage.prototype.to;
/**
 * @record
 * @struct
 */
Windows.Devices.Sms.ISmsMessage = function() {};
 /** @type {number} */
Windows.Devices.Sms.ISmsMessage.prototype.id;
 /** @type {Windows.Devices.Sms.SmsMessageClass} */
Windows.Devices.Sms.ISmsMessage.prototype.messageClass;
/**
 * @record
 * @struct
 */
Windows.Devices.Sms.SmsEncodedLength = function() {};
 /** @type {number} */
Windows.Devices.Sms.SmsEncodedLength.prototype.byteCountLastSegment;
 /** @type {number} */
Windows.Devices.Sms.SmsEncodedLength.prototype.bytesPerSegment;
 /** @type {number} */
Windows.Devices.Sms.SmsEncodedLength.prototype.characterCountLastSegment;
 /** @type {number} */
Windows.Devices.Sms.SmsEncodedLength.prototype.charactersPerSegment;
 /** @type {number} */
Windows.Devices.Sms.SmsEncodedLength.prototype.segmentCount;

/** @typedef {function(!Windows.WinRTEvent<!Windows.Devices.Sms.SmsDevice>): void} */
Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler;

/** @typedef {function(?): void} */
Windows.Devices.Sms.SmsMessageReceivedEventHandler;
/**
 * @record
 * @struct
 */
Windows.Devices.Sms.ISmsMessageBase = function() {};
 /** @type {Windows.Devices.Sms.CellularClass} */
Windows.Devices.Sms.ISmsMessageBase.prototype.cellularClass;
 /** @type {string} */
Windows.Devices.Sms.ISmsMessageBase.prototype.deviceId;
 /** @type {Windows.Devices.Sms.SmsMessageClass} */
Windows.Devices.Sms.ISmsMessageBase.prototype.messageClass;
 /** @type {Windows.Devices.Sms.SmsMessageType} */
Windows.Devices.Sms.ISmsMessageBase.prototype.messageType;
 /** @type {string} */
Windows.Devices.Sms.ISmsMessageBase.prototype.simIccId;
/**
 * @extends {Windows.Devices.Sms.ISmsMessage}
 * @record
 * @struct
 */
Windows.Devices.Sms.ISmsBinaryMessage = function() {};
 /** @type {Windows.Devices.Sms.SmsDataFormat} */
Windows.Devices.Sms.ISmsBinaryMessage.prototype.format;

/**
 * Returns the raw buffer of the message in binary protocol description unit (PDU) format as a byte array.
 * @return {!Array<number>} A byte array representing message data. If there is no message data, the returned array is empty.
 */
Windows.Devices.Sms.ISmsBinaryMessage.prototype.getData = function() {};

/**
 * Specifies the raw binary payload of the SMS message. It should be formatted according to the protocol description unit (PDU) standard.
 * @param {!Array<number>} value A byte array representing message data, formatted according to the protocol description unit (PDU) standard.
 * @return {void}
 */
Windows.Devices.Sms.ISmsBinaryMessage.prototype.setData = function(value) {};
/** @const */
Windows.Devices.Spi = {};
/** @const */
Windows.Devices.Spi.Provider = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Spi.Provider.ProviderSpiConnectionSettings = function() {};
 /** @type {?} */
Windows.Devices.Spi.Provider.ProviderSpiConnectionSettings.prototype.chipSelectLine;
 /** @type {?} */
Windows.Devices.Spi.Provider.ProviderSpiConnectionSettings.prototype.clockFrequency;
 /** @type {?} */
Windows.Devices.Spi.Provider.ProviderSpiConnectionSettings.prototype.dataBitLength;
 /** @type {?} */
Windows.Devices.Spi.Provider.ProviderSpiConnectionSettings.prototype.mode;
 /** @type {?} */
Windows.Devices.Spi.Provider.ProviderSpiConnectionSettings.prototype.sharingMode;
/** @const */
Windows.Devices.Spi.Provider.ProviderSpiMode = {};
 /** @type {?} */
Windows.Devices.Spi.Provider.ProviderSpiMode.mode0;
 /** @type {?} */
Windows.Devices.Spi.Provider.ProviderSpiMode.mode1;
 /** @type {?} */
Windows.Devices.Spi.Provider.ProviderSpiMode.mode2;
 /** @type {?} */
Windows.Devices.Spi.Provider.ProviderSpiMode.mode3;
/** @const */
Windows.Devices.Spi.Provider.ProviderSpiSharingMode = {};
 /** @type {?} */
Windows.Devices.Spi.Provider.ProviderSpiSharingMode.exclusive;
 /** @type {?} */
Windows.Devices.Spi.Provider.ProviderSpiSharingMode.shared;
/**
 * @record
 * @struct
 */
Windows.Devices.Spi.Provider.ISpiProvider = function() {};
 /** @type {?} */
Windows.Devices.Spi.Provider.ISpiProvider.prototype.getControllersAsync;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Spi.SpiBusInfo = function() {};
 /** @type {number} */
Windows.Devices.Spi.SpiBusInfo.prototype.chipSelectLineCount;
 /** @type {number} */
Windows.Devices.Spi.SpiBusInfo.prototype.maxClockFrequency;
 /** @type {number} */
Windows.Devices.Spi.SpiBusInfo.prototype.minClockFrequency;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Devices.Spi.SpiBusInfo.prototype.supportedDataBitLengths;

/**
 * @constructor
 * @struct
 * Initializes new instance of SpiConnectionSettings .
 * @param {number} chipSelectLine The chip select line on which the connection will be made.
 */
Windows.Devices.Spi.SpiConnectionSettings = function(chipSelectLine) {};
 /** @type {number} */
Windows.Devices.Spi.SpiConnectionSettings.prototype.chipSelectLine;
 /** @type {number} */
Windows.Devices.Spi.SpiConnectionSettings.prototype.clockFrequency;
 /** @type {number} */
Windows.Devices.Spi.SpiConnectionSettings.prototype.dataBitLength;
 /** @type {Windows.Devices.Spi.SpiMode} */
Windows.Devices.Spi.SpiConnectionSettings.prototype.mode;
 /** @type {Windows.Devices.Spi.SpiSharingMode} */
Windows.Devices.Spi.SpiConnectionSettings.prototype.sharingMode;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Spi.SpiController = function() {};

/**
 * Gets all the SPI controllers that are on the system.
 * @param {!Windows.Devices.Spi.Provider.ISpiProvider} provider The SPI provider for the controllers on the system.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When the method completes successfully, it returns a list of values that represent the available SPI controllers on the system.
 */
Windows.Devices.Spi.SpiController.getControllersAsync = function(provider) {};

/**
 * Gets the default SPI controller on the system.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Spi.SpiController, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Spi.SpiController>>} The default SPI controller on the system, or null if the system has no SPI controller.
 */
Windows.Devices.Spi.SpiController.getDefaultAsync = function() {};

/**
 * Gets the SPI device with the specified settings.
 * @param {!Windows.Devices.Spi.SpiConnectionSettings} settings The desired connection settings.
 * @return {!Windows.Devices.Spi.SpiDevice} The SPI device.
 */
Windows.Devices.Spi.SpiController.prototype.getDevice = function(settings) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Spi.SpiDevice = function() {};
 /** @type {!Windows.Devices.Spi.SpiConnectionSettings} */
Windows.Devices.Spi.SpiDevice.prototype.connectionSettings;
 /** @type {string} */
Windows.Devices.Spi.SpiDevice.prototype.deviceId;

/**
 * Opens a device with the connection settings provided.
 * @param {string} busId The id of the bus.
 * @param {!Windows.Devices.Spi.SpiConnectionSettings} settings The connection settings.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Spi.SpiDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Spi.SpiDevice>>} The SPI device requested.
 */
Windows.Devices.Spi.SpiDevice.fromIdAsync = function(busId, settings) {};

/**
 * Retrieves the info about a certain bus.
 * @param {string} busId The id of the bus.
 * @return {!Windows.Devices.Spi.SpiBusInfo} The bus info requested.
 */
Windows.Devices.Spi.SpiDevice.getBusInfo = function(busId) {};

/**
 * Gets all the SPI buses found on the system that match the input parameter.
 * Gets all the SPI buses found on the system.
 * @param {string=} friendlyName Input parameter specifying an identifying name for the desired bus. This usually corresponds to a name on the schematic.
 * @return {string} String containing all the buses that have the input in the name. / String containing all the buses found on the system.
 */
Windows.Devices.Spi.SpiDevice.getDeviceSelector = function(friendlyName) {};

/**
 * Closes the connection to the device.
 * @return {void}
 */
Windows.Devices.Spi.SpiDevice.prototype.close = function() {};

/**
 * Reads from the connected device.
 * @return {!Array<number>} Array containing data read from the device.
 */
Windows.Devices.Spi.SpiDevice.prototype.read = function() {};

/**
 * Transfer data using a full duplex communication system. Full duplex allows both the master and the slave to communicate simultaneously.
 * @param {!Array<number>} writeBuffer Array containing data to write to the device.
 * @return {!Array<number>} Array containing data read from the device.
 */
Windows.Devices.Spi.SpiDevice.prototype.transferFullDuplex = function(writeBuffer) {};

/**
 * Transfer data sequentially to the device.
 * @param {!Array<number>} writeBuffer Array containing data to write to the device.
 * @return {!Array<number>} Array containing data read from the device.
 */
Windows.Devices.Spi.SpiDevice.prototype.transferSequential = function(writeBuffer) {};

/**
 * Writes to the connected device.
 * @param {!Array<number>} buffer Array containing the data to write to the device.
 * @return {void}
 */
Windows.Devices.Spi.SpiDevice.prototype.write = function(buffer) {};

/** @const */
Windows.Devices.Spi.SpiMode = {};
/** @const {number} */
Windows.Devices.Spi.SpiMode.mode0;
/** @const {number} */
Windows.Devices.Spi.SpiMode.mode1;
/** @const {number} */
Windows.Devices.Spi.SpiMode.mode2;
/** @const {number} */
Windows.Devices.Spi.SpiMode.mode3;

/** @const */
Windows.Devices.Spi.SpiSharingMode = {};
/** @const {number} */
Windows.Devices.Spi.SpiSharingMode.exclusive;
/** @const {number} */
Windows.Devices.Spi.SpiSharingMode.shared;
/** @const */
Windows.Devices.Usb = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbBulkInEndpointDescriptor = function() {};
 /** @type {number} */
Windows.Devices.Usb.UsbBulkInEndpointDescriptor.prototype.endpointNumber;
 /** @type {number} */
Windows.Devices.Usb.UsbBulkInEndpointDescriptor.prototype.maxPacketSize;
 /** @type {!Windows.Devices.Usb.UsbBulkInPipe} */
Windows.Devices.Usb.UsbBulkInEndpointDescriptor.prototype.pipe;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbBulkInPipe = function() {};
 /** @type {!Windows.Devices.Usb.UsbBulkInEndpointDescriptor} */
Windows.Devices.Usb.UsbBulkInPipe.prototype.endpointDescriptor;
 /** @type {!Windows.Storage.Streams.IInputStream} */
Windows.Devices.Usb.UsbBulkInPipe.prototype.inputStream;
 /** @type {number} */
Windows.Devices.Usb.UsbBulkInPipe.prototype.maxTransferSizeBytes;
 /** @type {Windows.Devices.Usb.UsbReadOptions} */
Windows.Devices.Usb.UsbBulkInPipe.prototype.readOptions;

/**
 * Starts an asynchronous operation to clear a stall condition (endpoint halt) on the USB bulk IN endpoint that is associated with the pipe.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Devices.Usb.UsbBulkInPipe.prototype.clearStallAsync = function() {};

/**
 * Discards any data that is cached in the bulk IN pipe.
 * @return {void}
 */
Windows.Devices.Usb.UsbBulkInPipe.prototype.flushBuffer = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbBulkOutEndpointDescriptor = function() {};
 /** @type {number} */
Windows.Devices.Usb.UsbBulkOutEndpointDescriptor.prototype.endpointNumber;
 /** @type {number} */
Windows.Devices.Usb.UsbBulkOutEndpointDescriptor.prototype.maxPacketSize;
 /** @type {!Windows.Devices.Usb.UsbBulkOutPipe} */
Windows.Devices.Usb.UsbBulkOutEndpointDescriptor.prototype.pipe;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbBulkOutPipe = function() {};
 /** @type {!Windows.Devices.Usb.UsbBulkOutEndpointDescriptor} */
Windows.Devices.Usb.UsbBulkOutPipe.prototype.endpointDescriptor;
 /** @type {!Windows.Storage.Streams.IOutputStream} */
Windows.Devices.Usb.UsbBulkOutPipe.prototype.outputStream;
 /** @type {Windows.Devices.Usb.UsbWriteOptions} */
Windows.Devices.Usb.UsbBulkOutPipe.prototype.writeOptions;

/**
 * Starts an asynchronous operation to clear a stall condition (endpoint halt) on the USB bulk OUT endpoint that is associated with the pipe.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Devices.Usb.UsbBulkOutPipe.prototype.clearStallAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbConfiguration = function() {};
 /** @type {!Windows.Devices.Usb.UsbConfigurationDescriptor} */
Windows.Devices.Usb.UsbConfiguration.prototype.configurationDescriptor;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Usb.UsbDescriptor>} */
Windows.Devices.Usb.UsbConfiguration.prototype.descriptors;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Usb.UsbInterface>} */
Windows.Devices.Usb.UsbConfiguration.prototype.usbInterfaces;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbConfigurationDescriptor = function() {};
 /** @type {number} */
Windows.Devices.Usb.UsbConfigurationDescriptor.prototype.configurationValue;
 /** @type {number} */
Windows.Devices.Usb.UsbConfigurationDescriptor.prototype.maxPowerMilliamps;
 /** @type {boolean} */
Windows.Devices.Usb.UsbConfigurationDescriptor.prototype.remoteWakeup;
 /** @type {boolean} */
Windows.Devices.Usb.UsbConfigurationDescriptor.prototype.selfPowered;

/**
 * Parses the specified USB descriptor and returns fields of a USB configuration descriptor.
 * @param {!Windows.Devices.Usb.UsbDescriptor} descriptor A UsbDescriptor object that contains first 9 bytes of the USB configuration descriptor.
 * @return {!Windows.Devices.Usb.UsbConfigurationDescriptor} A UsbConfigurationDescriptor object that contains fields of a USB configuration descriptor.
 */
Windows.Devices.Usb.UsbConfigurationDescriptor.parse = function(descriptor) {};

/**
 * Retrieves the first 9 bytes of a USB configuration descriptor in a UsbConfigurationDescriptor object that is contained in a UsbDescriptor object.
 * @param {!Windows.Devices.Usb.UsbDescriptor} descriptor The UsbDescriptor object to parse.
 * @return {{parsed: !Windows.Devices.Usb.UsbConfigurationDescriptor, returnValue: boolean}}
 */
Windows.Devices.Usb.UsbConfigurationDescriptor.tryParse = function(descriptor) {};

/** @const */
Windows.Devices.Usb.UsbControlRecipient = {};
/** @const {number} */
Windows.Devices.Usb.UsbControlRecipient.device;
/** @const {number} */
Windows.Devices.Usb.UsbControlRecipient.specifiedInterface;
/** @const {number} */
Windows.Devices.Usb.UsbControlRecipient.endpoint;
/** @const {number} */
Windows.Devices.Usb.UsbControlRecipient.other;
/** @const {number} */
Windows.Devices.Usb.UsbControlRecipient.defaultInterface;

/**
 * @constructor
 * @struct
 * Creates a UsbControlRequestType object.
 */
Windows.Devices.Usb.UsbControlRequestType = function() {};
 /** @type {number} */
Windows.Devices.Usb.UsbControlRequestType.prototype.asByte;
 /** @type {Windows.Devices.Usb.UsbControlTransferType} */
Windows.Devices.Usb.UsbControlRequestType.prototype.controlTransferType;
 /** @type {Windows.Devices.Usb.UsbTransferDirection} */
Windows.Devices.Usb.UsbControlRequestType.prototype.direction;
 /** @type {Windows.Devices.Usb.UsbControlRecipient} */
Windows.Devices.Usb.UsbControlRequestType.prototype.recipient;

/** @const */
Windows.Devices.Usb.UsbControlTransferType = {};
/** @const {number} */
Windows.Devices.Usb.UsbControlTransferType.standard;
/** @const {number} */
Windows.Devices.Usb.UsbControlTransferType.class;
/** @const {number} */
Windows.Devices.Usb.UsbControlTransferType.vendor;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbDescriptor = function() {};
 /** @type {number} */
Windows.Devices.Usb.UsbDescriptor.prototype.descriptorType;
 /** @type {number} */
Windows.Devices.Usb.UsbDescriptor.prototype.length;

/**
 * Reads descriptor data in the caller-supplied buffer.
 * @param {!Windows.Storage.Streams.IBuffer} buffer A caller-supplied buffer that receives descriptor data.
 * @return {void}
 */
Windows.Devices.Usb.UsbDescriptor.prototype.readDescriptorBuffer = function(buffer) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbDevice = function() {};
 /** @type {!Windows.Devices.Usb.UsbConfiguration} */
Windows.Devices.Usb.UsbDevice.prototype.configuration;
 /** @type {!Windows.Devices.Usb.UsbInterface} */
Windows.Devices.Usb.UsbDevice.prototype.defaultInterface;
 /** @type {!Windows.Devices.Usb.UsbDeviceDescriptor} */
Windows.Devices.Usb.UsbDevice.prototype.deviceDescriptor;

/**
 * Starts an asynchronous operation that creates a UsbDevice object.
 * @param {string} deviceId The device instance path of the device. To obtain that value, get the DeviceInformation.Id property value.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Usb.UsbDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Usb.UsbDevice>>} Returns an IAsyncOperation(UsbDevice) object that returns the results of the operation.
 */
Windows.Devices.Usb.UsbDevice.fromIdAsync = function(deviceId) {};

/**
 * Gets an Advanced Query Syntax (AQS) string that the app can pass to DeviceInformation.FindAllAsync in order to find a specific type of USB device.
 * @param {!Windows.Devices.Usb.UsbDeviceClass} usbClass A UsbDeviceClass object for the device class specified by the app.
 * @return {string} String formatted as an AQS query.
 */
Windows.Devices.Usb.UsbDevice.getDeviceClassSelector = function(usbClass) {};

/**
 * Gets an Advanced Query Syntax (AQS) string, based on vendor and product identifiers, specified by the app. The app passes the string to DeviceInformation.FindAllAsync in order to find a specific type of USB device.
 * Gets an Advanced Query Syntax (AQS) string, based on the device interface GUID identifier, specified by the app. The app passes the string to DeviceInformation.FindAllAsync in order to find a specific type of USB device.
 * Gets an Advanced Query Syntax (AQS) string, based on vendor, product, and device interface GUID identifiers, specified by the app. The app passes the string to DeviceInformation.FindAllAsync in order to find a specific type of USB device.
 * @param {number|string} vendorId_or_winUsbInterfaceClass Specifies the vendor identifier for the device as assigned by the USB specification committee. Possible values are 0 through 0xffff. / The device interface GUID exposed by the Winusb.sys driver. See the remarks section.
 * @param {number=} productId Specifies the product identifier. This value is assigned by the manufacturer and is device-specific. Possible values are 0 through 0xffff.
 * @param {string=} winUsbInterfaceClass The device interface GUID exposed by the Winusb.sys driver. See the remarks section.
 * @return {string} String formatted as an AQS query.
 */
Windows.Devices.Usb.UsbDevice.getDeviceSelector = function(vendorId_or_winUsbInterfaceClass, productId, winUsbInterfaceClass) {};

/**
 * Releases the reference to the UsbDevice object that was previously obtained by calling FromIdAsync .
 * @return {void}
 */
Windows.Devices.Usb.UsbDevice.prototype.close = function() {};

/**
 * Starts a USB control transfer to receive data from the default control endpoint of the device.
 * Starts a zero-length USB control transfer that reads from the default control endpoint of the device.
 * @param {!Windows.Devices.Usb.UsbSetupPacket} setupPacket A UsbSetupPacket object that contains the setup packet for the control transfer.
 * @param {!Windows.Storage.Streams.IBuffer=} buffer A caller-supplied buffer that contains transfer data.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} Returns an IAsyncOperation(IBuffer) object that returns the results of the operation.
 */
Windows.Devices.Usb.UsbDevice.prototype.sendControlInTransferAsync = function(setupPacket, buffer) {};

/**
 * Starts a zero-length USB control transfer that writes to the default control endpoint of the device.
 * Starts a USB control transfer to send data to the default control endpoint of the device.
 * @param {!Windows.Devices.Usb.UsbSetupPacket} setupPacket A UsbSetupPacket object that contains the setup packet for the control transfer.
 * @param {!Windows.Storage.Streams.IBuffer=} buffer A caller-supplied buffer that contains the transfer data.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} Returns an IAsyncOperation(UInt32) object that returns the results of the operation.
 */
Windows.Devices.Usb.UsbDevice.prototype.sendControlOutTransferAsync = function(setupPacket, buffer) {};

/**
 * @constructor
 * @struct
 * Creates a UsbDeviceClass object.
 */
Windows.Devices.Usb.UsbDeviceClass = function() {};
 /** @type {number} */
Windows.Devices.Usb.UsbDeviceClass.prototype.classCode;
 /** @type {number} */
Windows.Devices.Usb.UsbDeviceClass.prototype.protocolCode;
 /** @type {number} */
Windows.Devices.Usb.UsbDeviceClass.prototype.subclassCode;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbDeviceClasses = function() {};
 /** @type {!Windows.Devices.Usb.UsbDeviceClass} */
Windows.Devices.Usb.UsbDeviceClasses.activeSync;
 /** @type {!Windows.Devices.Usb.UsbDeviceClass} */
Windows.Devices.Usb.UsbDeviceClasses.cdcControl;
 /** @type {!Windows.Devices.Usb.UsbDeviceClass} */
Windows.Devices.Usb.UsbDeviceClasses.deviceFirmwareUpdate;
 /** @type {!Windows.Devices.Usb.UsbDeviceClass} */
Windows.Devices.Usb.UsbDeviceClasses.irda;
 /** @type {!Windows.Devices.Usb.UsbDeviceClass} */
Windows.Devices.Usb.UsbDeviceClasses.measurement;
 /** @type {!Windows.Devices.Usb.UsbDeviceClass} */
Windows.Devices.Usb.UsbDeviceClasses.palmSync;
 /** @type {!Windows.Devices.Usb.UsbDeviceClass} */
Windows.Devices.Usb.UsbDeviceClasses.personalHealthcare;
 /** @type {!Windows.Devices.Usb.UsbDeviceClass} */
Windows.Devices.Usb.UsbDeviceClasses.physical;
 /** @type {!Windows.Devices.Usb.UsbDeviceClass} */
Windows.Devices.Usb.UsbDeviceClasses.vendorSpecific;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbDeviceDescriptor = function() {};
 /** @type {number} */
Windows.Devices.Usb.UsbDeviceDescriptor.prototype.bcdDeviceRevision;
 /** @type {number} */
Windows.Devices.Usb.UsbDeviceDescriptor.prototype.bcdUsb;
 /** @type {number} */
Windows.Devices.Usb.UsbDeviceDescriptor.prototype.maxPacketSize0;
 /** @type {number} */
Windows.Devices.Usb.UsbDeviceDescriptor.prototype.numberOfConfigurations;
 /** @type {number} */
Windows.Devices.Usb.UsbDeviceDescriptor.prototype.productId;
 /** @type {number} */
Windows.Devices.Usb.UsbDeviceDescriptor.prototype.vendorId;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbEndpointDescriptor = function() {};
 /** @type {!Windows.Devices.Usb.UsbBulkInEndpointDescriptor} */
Windows.Devices.Usb.UsbEndpointDescriptor.prototype.asBulkInEndpointDescriptor;
 /** @type {!Windows.Devices.Usb.UsbBulkOutEndpointDescriptor} */
Windows.Devices.Usb.UsbEndpointDescriptor.prototype.asBulkOutEndpointDescriptor;
 /** @type {!Windows.Devices.Usb.UsbInterruptInEndpointDescriptor} */
Windows.Devices.Usb.UsbEndpointDescriptor.prototype.asInterruptInEndpointDescriptor;
 /** @type {!Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor} */
Windows.Devices.Usb.UsbEndpointDescriptor.prototype.asInterruptOutEndpointDescriptor;
 /** @type {Windows.Devices.Usb.UsbTransferDirection} */
Windows.Devices.Usb.UsbEndpointDescriptor.prototype.direction;
 /** @type {number} */
Windows.Devices.Usb.UsbEndpointDescriptor.prototype.endpointNumber;
 /** @type {Windows.Devices.Usb.UsbEndpointType} */
Windows.Devices.Usb.UsbEndpointDescriptor.prototype.endpointType;

/**
 * Parses the specified USB descriptor and returns the USB endpoint descriptor in a UsbEndpointDescriptor object.
 * @param {!Windows.Devices.Usb.UsbDescriptor} descriptor A UsbDescriptor object that contains the USB endpoint descriptor.
 * @return {!Windows.Devices.Usb.UsbEndpointDescriptor} A UsbEndpointDescriptor object that contains the USB endpoint descriptor.
 */
Windows.Devices.Usb.UsbEndpointDescriptor.parse = function(descriptor) {};

/**
 * Retrieves the USB endpoint descriptor in a UsbEndpointDescriptor object that is contained in a UsbDescriptor object.
 * @param {!Windows.Devices.Usb.UsbDescriptor} descriptor The UsbDescriptor object to parse.
 * @return {{parsed: !Windows.Devices.Usb.UsbEndpointDescriptor, returnValue: boolean}}
 */
Windows.Devices.Usb.UsbEndpointDescriptor.tryParse = function(descriptor) {};

/** @const */
Windows.Devices.Usb.UsbEndpointType = {};
/** @const {number} */
Windows.Devices.Usb.UsbEndpointType.control;
/** @const {number} */
Windows.Devices.Usb.UsbEndpointType.isochronous;
/** @const {number} */
Windows.Devices.Usb.UsbEndpointType.bulk;
/** @const {number} */
Windows.Devices.Usb.UsbEndpointType.interrupt;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbInterface = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Usb.UsbBulkInPipe>} */
Windows.Devices.Usb.UsbInterface.prototype.bulkInPipes;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Usb.UsbBulkOutPipe>} */
Windows.Devices.Usb.UsbInterface.prototype.bulkOutPipes;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Usb.UsbDescriptor>} */
Windows.Devices.Usb.UsbInterface.prototype.descriptors;
 /** @type {number} */
Windows.Devices.Usb.UsbInterface.prototype.interfaceNumber;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Usb.UsbInterfaceSetting>} */
Windows.Devices.Usb.UsbInterface.prototype.interfaceSettings;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Usb.UsbInterruptInPipe>} */
Windows.Devices.Usb.UsbInterface.prototype.interruptInPipes;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Usb.UsbInterruptOutPipe>} */
Windows.Devices.Usb.UsbInterface.prototype.interruptOutPipes;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbInterfaceDescriptor = function() {};
 /** @type {number} */
Windows.Devices.Usb.UsbInterfaceDescriptor.prototype.alternateSettingNumber;
 /** @type {number} */
Windows.Devices.Usb.UsbInterfaceDescriptor.prototype.classCode;
 /** @type {number} */
Windows.Devices.Usb.UsbInterfaceDescriptor.prototype.interfaceNumber;
 /** @type {number} */
Windows.Devices.Usb.UsbInterfaceDescriptor.prototype.protocolCode;
 /** @type {number} */
Windows.Devices.Usb.UsbInterfaceDescriptor.prototype.subclassCode;

/**
 * Parses the specified USB descriptor and returns alternate setting information in a UsbInterfaceDescriptor object.
 * @param {!Windows.Devices.Usb.UsbDescriptor} descriptor A UsbDescriptor object that contains the USB interface descriptor.
 * @return {!Windows.Devices.Usb.UsbInterfaceDescriptor} A UsbInterfaceDescriptor object describes the alternate setting.
 */
Windows.Devices.Usb.UsbInterfaceDescriptor.parse = function(descriptor) {};

/**
 * Retrieves information about the alternate setting in a UsbInterfaceDescriptor object that is contained in a UsbDescriptor object.
 * @param {!Windows.Devices.Usb.UsbDescriptor} descriptor The UsbDescriptor object to parse.
 * @return {{parsed: !Windows.Devices.Usb.UsbInterfaceDescriptor, returnValue: boolean}}
 */
Windows.Devices.Usb.UsbInterfaceDescriptor.tryParse = function(descriptor) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbInterfaceSetting = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Usb.UsbBulkInEndpointDescriptor>} */
Windows.Devices.Usb.UsbInterfaceSetting.prototype.bulkInEndpoints;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Usb.UsbBulkOutEndpointDescriptor>} */
Windows.Devices.Usb.UsbInterfaceSetting.prototype.bulkOutEndpoints;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Usb.UsbDescriptor>} */
Windows.Devices.Usb.UsbInterfaceSetting.prototype.descriptors;
 /** @type {!Windows.Devices.Usb.UsbInterfaceDescriptor} */
Windows.Devices.Usb.UsbInterfaceSetting.prototype.interfaceDescriptor;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Usb.UsbInterruptInEndpointDescriptor>} */
Windows.Devices.Usb.UsbInterfaceSetting.prototype.interruptInEndpoints;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor>} */
Windows.Devices.Usb.UsbInterfaceSetting.prototype.interruptOutEndpoints;
 /** @type {boolean} */
Windows.Devices.Usb.UsbInterfaceSetting.prototype.selected;

/**
 * Selects the alternate setting as the current setting in the USB interface.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Devices.Usb.UsbInterfaceSetting.prototype.selectSettingAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbInterruptInEndpointDescriptor = function() {};
 /** @type {number} */
Windows.Devices.Usb.UsbInterruptInEndpointDescriptor.prototype.endpointNumber;
 /** @type {number} */
Windows.Devices.Usb.UsbInterruptInEndpointDescriptor.prototype.interval;
 /** @type {number} */
Windows.Devices.Usb.UsbInterruptInEndpointDescriptor.prototype.maxPacketSize;
 /** @type {!Windows.Devices.Usb.UsbInterruptInPipe} */
Windows.Devices.Usb.UsbInterruptInEndpointDescriptor.prototype.pipe;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbInterruptInEventArgs = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.Usb.UsbInterruptInEventArgs.prototype.interruptData;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbInterruptInPipe = function() {};
 /** @type {!Windows.Devices.Usb.UsbInterruptInEndpointDescriptor} */
Windows.Devices.Usb.UsbInterruptInPipe.prototype.endpointDescriptor;
 /** @type {function(?): void} */
Windows.Devices.Usb.UsbInterruptInPipe.prototype.ondatareceived;

/**
 * Starts an asynchronous operation to clear a stall condition (endpoint halt) on the USB interrupt IN endpoint that is associated with the pipe.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Devices.Usb.UsbInterruptInPipe.prototype.clearStallAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Usb.UsbInterruptInPipe.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.Usb.UsbInterruptInPipe.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor = function() {};
 /** @type {number} */
Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor.prototype.endpointNumber;
 /** @type {number} */
Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor.prototype.interval;
 /** @type {number} */
Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor.prototype.maxPacketSize;
 /** @type {!Windows.Devices.Usb.UsbInterruptOutPipe} */
Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor.prototype.pipe;
/**
 * @constructor
 * @struct
 */
Windows.Devices.Usb.UsbInterruptOutPipe = function() {};
 /** @type {!Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor} */
Windows.Devices.Usb.UsbInterruptOutPipe.prototype.endpointDescriptor;
 /** @type {!Windows.Storage.Streams.IOutputStream} */
Windows.Devices.Usb.UsbInterruptOutPipe.prototype.outputStream;
 /** @type {Windows.Devices.Usb.UsbWriteOptions} */
Windows.Devices.Usb.UsbInterruptOutPipe.prototype.writeOptions;

/**
 * Starts an asynchronous operation to clear a stall condition (endpoint halt) on the USB interrupt OUT endpoint that is associated with the pipe.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Devices.Usb.UsbInterruptOutPipe.prototype.clearStallAsync = function() {};

/** @const */
Windows.Devices.Usb.UsbReadOptions = {};
/** @const {number} */
Windows.Devices.Usb.UsbReadOptions.none;
/** @const {number} */
Windows.Devices.Usb.UsbReadOptions.autoClearStall;
/** @const {number} */
Windows.Devices.Usb.UsbReadOptions.overrideAutomaticBufferManagement;
/** @const {number} */
Windows.Devices.Usb.UsbReadOptions.ignoreShortPacket;
/** @const {number} */
Windows.Devices.Usb.UsbReadOptions.allowPartialReads;

/**
 * @constructor
 * @struct
 * Creates a UsbSetupPacket object.
 * Creates a UsbSetupPacket object from a formatted buffer (eight bytes) that contains the setup packet.
 * @param {!Windows.Storage.Streams.IBuffer=} eightByteBuffer A caller-supplied buffer that contains the setup packet formatted as per the standard USB specification. The length of the buffer must be eight bytes because that is the size of a setup packet on the bus.
 */
Windows.Devices.Usb.UsbSetupPacket = function(eightByteBuffer) {};
 /** @type {number} */
Windows.Devices.Usb.UsbSetupPacket.prototype.index;
 /** @type {number} */
Windows.Devices.Usb.UsbSetupPacket.prototype.length;
 /** @type {number} */
Windows.Devices.Usb.UsbSetupPacket.prototype.request;
 /** @type {!Windows.Devices.Usb.UsbControlRequestType} */
Windows.Devices.Usb.UsbSetupPacket.prototype.requestType;
 /** @type {number} */
Windows.Devices.Usb.UsbSetupPacket.prototype.value;

/** @const */
Windows.Devices.Usb.UsbTransferDirection = {};
/** @const {number} */
Windows.Devices.Usb.UsbTransferDirection.out;
/** @const {number} */
Windows.Devices.Usb.UsbTransferDirection.in;

/** @const */
Windows.Devices.Usb.UsbWriteOptions = {};
/** @const {number} */
Windows.Devices.Usb.UsbWriteOptions.none;
/** @const {number} */
Windows.Devices.Usb.UsbWriteOptions.autoClearStall;
/** @const {number} */
Windows.Devices.Usb.UsbWriteOptions.shortPacketTerminate;
/** @const */
Windows.Devices.WiFi = {};

/** @const */
Windows.Devices.WiFi.WiFiAccessStatus = {};
/** @const {number} */
Windows.Devices.WiFi.WiFiAccessStatus.unspecified;
/** @const {number} */
Windows.Devices.WiFi.WiFiAccessStatus.allowed;
/** @const {number} */
Windows.Devices.WiFi.WiFiAccessStatus.deniedByUser;
/** @const {number} */
Windows.Devices.WiFi.WiFiAccessStatus.deniedBySystem;
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFi.WiFiAdapter = function() {};
 /** @type {!Windows.Networking.Connectivity.NetworkAdapter} */
Windows.Devices.WiFi.WiFiAdapter.prototype.networkAdapter;
 /** @type {!Windows.Devices.WiFi.WiFiNetworkReport} */
Windows.Devices.WiFi.WiFiAdapter.prototype.networkReport;
 /** @type {function(?): void} */
Windows.Devices.WiFi.WiFiAdapter.prototype.onavailablenetworkschanged;

/**
 * A static method that initiates an asynchronous operation to enumerate all Wi-Fi adapters in the system.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous enumeration operation. On successful completion, returns a list of available Wi-Fi adapters.
 */
Windows.Devices.WiFi.WiFiAdapter.findAllAdaptersAsync = function() {};

/**
 * A static method that initiates an asynchronous operation to get a WiFiAdapter object.
 * @param {string} deviceId The Device ID of the Wi-Fi adapter to be retrieved. Obtain a Device ID through the Windows.Devices.Enumeration namespace.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.WiFi.WiFiAdapter, !Windows.Foundation.IAsyncOperation<!Windows.Devices.WiFi.WiFiAdapter>>} An asynchronous get operation. On successful completion, returns a WiFiAdapter object specific to the requested Device ID.
 */
Windows.Devices.WiFi.WiFiAdapter.fromIdAsync = function(deviceId) {};

/**
 * A static method that returns an Advanced Query Syntax (AQS) string to be used to enumerate Wi-Fi adapters using Windows.Devices.Enumeration.DeviceInformation.FindAllAsync and related methods.
 * @return {string} An identifier to be used to enumerate Wi-Fi devices.
 */
Windows.Devices.WiFi.WiFiAdapter.getDeviceSelector = function() {};

/**
 * A static method for determining whether the current user can access any of the Wi-Fi adapters on this device.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Devices.WiFi.WiFiAccessStatus, !Windows.Foundation.IAsyncOperation<Windows.Devices.WiFi.WiFiAccessStatus>>} An asynchronous access operation. On successful completion, returns a status enumeration value describing whether the current user can access any Wi-Fi adapter.
 */
Windows.Devices.WiFi.WiFiAdapter.requestAccessAsync = function() {};

/**
 * Connect this Wi-Fi device to the specified network, with the specified reconnection policy.
 * Connect this Wi-Fi device to the specified network, with the specified passphrase and reconnection policy.
 * Connect this Wi-Fi device to a hidden network, with the given passphrase and reconnection policy.
 * @param {!Windows.Devices.WiFi.WiFiAvailableNetwork} availableNetwork Describes the Wi-Fi network to be connected. / Specifies the Wi-Fi network to connect to. / Describes the Wi-Fi network to connect to.
 * @param {Windows.Devices.WiFi.WiFiReconnectionKind} reconnectionKind Specifies how to reconnect if the connection is lost. / Describes how to reconnect to the network if connection is lost.
 * @param {!Windows.Security.Credentials.PasswordCredential=} passwordCredential The passphrase to be used to connect to the access point. / Password or other credential to use to connect to the network.
 * @param {string=} ssid When the network SSID is hidden, use this parameter to provide the SSID.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.WiFi.WiFiConnectionResult, !Windows.Foundation.IAsyncOperation<!Windows.Devices.WiFi.WiFiConnectionResult>>} An asynchronous connect operation. On successful conclusion of the operation, returns an object that describes the result of the connect operation.
 */
Windows.Devices.WiFi.WiFiAdapter.prototype.connectAsync = function(availableNetwork, reconnectionKind, passwordCredential, ssid) {};

/**
 * Disconnects any active Wi-Fi connection through this adapter.
 * @return {void}
 */
Windows.Devices.WiFi.WiFiAdapter.prototype.disconnect = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.WiFi.WiFiAdapter.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.WiFi.WiFiAdapter.prototype.removeEventListener = function(type, listener) {};

/**
 * Directs this adapter to initiate an asynchronous network scan.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous scan operation. On successful completion, returns a list of networks scanned by this adapter.
 */
Windows.Devices.WiFi.WiFiAdapter.prototype.scanAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFi.WiFiAvailableNetwork = function() {};
 /** @type {number} */
Windows.Devices.WiFi.WiFiAvailableNetwork.prototype.beaconInterval;
 /** @type {string} */
Windows.Devices.WiFi.WiFiAvailableNetwork.prototype.bssid;
 /** @type {number} */
Windows.Devices.WiFi.WiFiAvailableNetwork.prototype.channelCenterFrequencyInKilohertz;
 /** @type {boolean} */
Windows.Devices.WiFi.WiFiAvailableNetwork.prototype.isWiFiDirect;
 /** @type {Windows.Devices.WiFi.WiFiNetworkKind} */
Windows.Devices.WiFi.WiFiAvailableNetwork.prototype.networkKind;
 /** @type {number} */
Windows.Devices.WiFi.WiFiAvailableNetwork.prototype.networkRssiInDecibelMilliwatts;
 /** @type {Windows.Devices.WiFi.WiFiPhyKind} */
Windows.Devices.WiFi.WiFiAvailableNetwork.prototype.phyKind;
 /** @type {!Windows.Networking.Connectivity.NetworkSecuritySettings} */
Windows.Devices.WiFi.WiFiAvailableNetwork.prototype.securitySettings;
 /** @type {number} */
Windows.Devices.WiFi.WiFiAvailableNetwork.prototype.signalBars;
 /** @type {string} */
Windows.Devices.WiFi.WiFiAvailableNetwork.prototype.ssid;
 /** @type {number} */
Windows.Devices.WiFi.WiFiAvailableNetwork.prototype.uptime;
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFi.WiFiConnectionResult = function() {};
 /** @type {Windows.Devices.WiFi.WiFiConnectionStatus} */
Windows.Devices.WiFi.WiFiConnectionResult.prototype.connectionStatus;

/** @const */
Windows.Devices.WiFi.WiFiConnectionStatus = {};
/** @const {number} */
Windows.Devices.WiFi.WiFiConnectionStatus.unspecifiedFailure;
/** @const {number} */
Windows.Devices.WiFi.WiFiConnectionStatus.success;
/** @const {number} */
Windows.Devices.WiFi.WiFiConnectionStatus.accessRevoked;
/** @const {number} */
Windows.Devices.WiFi.WiFiConnectionStatus.invalidCredential;
/** @const {number} */
Windows.Devices.WiFi.WiFiConnectionStatus.networkNotAvailable;
/** @const {number} */
Windows.Devices.WiFi.WiFiConnectionStatus.timeout;
/** @const {number} */
Windows.Devices.WiFi.WiFiConnectionStatus.unsupportedAuthenticationProtocol;

/** @const */
Windows.Devices.WiFi.WiFiNetworkKind = {};
/** @const {number} */
Windows.Devices.WiFi.WiFiNetworkKind.any;
/** @const {number} */
Windows.Devices.WiFi.WiFiNetworkKind.infrastructure;
/** @const {number} */
Windows.Devices.WiFi.WiFiNetworkKind.adhoc;
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFi.WiFiNetworkReport = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Devices.WiFi.WiFiAvailableNetwork>} */
Windows.Devices.WiFi.WiFiNetworkReport.prototype.availableNetworks;
 /** @type {!Date} */
Windows.Devices.WiFi.WiFiNetworkReport.prototype.timestamp;

/** @const */
Windows.Devices.WiFi.WiFiPhyKind = {};
/** @const {number} */
Windows.Devices.WiFi.WiFiPhyKind.unknown;
/** @const {number} */
Windows.Devices.WiFi.WiFiPhyKind.fhss;
/** @const {number} */
Windows.Devices.WiFi.WiFiPhyKind.dsss;
/** @const {number} */
Windows.Devices.WiFi.WiFiPhyKind.irBaseband;
/** @const {number} */
Windows.Devices.WiFi.WiFiPhyKind.ofdm;
/** @const {number} */
Windows.Devices.WiFi.WiFiPhyKind.hrdsss;
/** @const {number} */
Windows.Devices.WiFi.WiFiPhyKind.erp;
/** @const {number} */
Windows.Devices.WiFi.WiFiPhyKind.ht;
/** @const {number} */
Windows.Devices.WiFi.WiFiPhyKind.vht;

/** @const */
Windows.Devices.WiFi.WiFiReconnectionKind = {};
/** @const {number} */
Windows.Devices.WiFi.WiFiReconnectionKind.automatic;
/** @const {number} */
Windows.Devices.WiFi.WiFiReconnectionKind.manual;
 /** @type {?} */
Windows.Devices.WiFi.irect;
/** @const */
Windows.Devices.WiFiDirect = {};
/** @const */
Windows.Devices.WiFiDirect.Services = {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectService = function() {};
 /** @type {function(?): void} */
Windows.Devices.WiFiDirect.Services.WiFiDirectService.prototype.onsessiondeferred;
 /** @type {boolean} */
Windows.Devices.WiFiDirect.Services.WiFiDirectService.prototype.preferGroupOwnerMode;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.WiFiDirect.Services.WiFiDirectService.prototype.remoteServiceInfo;
 /** @type {Windows.Devices.WiFiDirect.Services.WiFiDirectServiceError} */
Windows.Devices.WiFiDirect.Services.WiFiDirectService.prototype.serviceError;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.WiFiDirect.Services.WiFiDirectService.prototype.sessionInfo;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceConfigurationMethod>} */
Windows.Devices.WiFiDirect.Services.WiFiDirectService.prototype.supportedConfigurationMethods;

/**
 * Static method that retrieves a WiFiDirectService instance for a Wi-Fi Direct Service offered by the device with a given device ID.
 * @param {string} deviceId Device ID of the device that advertises the desired Wi-Fi Direct Service.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.WiFiDirect.Services.WiFiDirectService, !Windows.Foundation.IAsyncOperation<!Windows.Devices.WiFiDirect.Services.WiFiDirectService>>} An asynchronous retrieval operation. On successful completion, returns an instance of WiFiDirectService specific to the desired service instance, advertised by the indicated device.
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectService.fromIdAsync = function(deviceId) {};

/**
 * Gets an Advanced Query Syntax (AQS) string to be used to find Wi-Fi Direct Service advertisers for a particular service.
 * Gets an Advanced Query Syntax (AQS) string to be used to find Wi-Fi Direct Service advertisers for a particular service, where a given byte sequence appears in the advertiser's service information blob.
 * @param {string} serviceName The service name to be found.
 * @param {!Windows.Storage.Streams.IBuffer=} serviceInfoFilter A byte sequence that must be found in the advertiser's service information blob.
 * @return {string} The AQS string for the requested advertiser query.
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectService.getSelector = function(serviceName, serviceInfoFilter) {};

/**
 * Initiates the establishment of a service session with the Wi-Fi Direct Service represented by this instance.
 * Initiates the establishment of a service session with the Wi-Fi Direct Service represented by this instance, using a PIN to configure the session.
 * @param {string=} pin The PIN to be used to configure the connection.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession, !Windows.Foundation.IAsyncOperation<!Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession>>} An asynchronous connection operation. When successfully completed, returns an object that represents the session that has been established.
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectService.prototype.connectAsync = function(pin) {};

/**
 * Asynchronously retrieves Wi-Fi Direct Service session provisioning information.
 * @param {Windows.Devices.WiFiDirect.Services.WiFiDirectServiceConfigurationMethod} selectedConfigurationMethod The preferred method of configuring the session.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.WiFiDirect.Services.WiFiDirectServiceProvisioningInfo, !Windows.Foundation.IAsyncOperation<!Windows.Devices.WiFiDirect.Services.WiFiDirectServiceProvisioningInfo>>} An asynchronous retrieval operation. On successful completion, returns provisioning information.
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectService.prototype.getProvisioningInfoAsync = function(selectedConfigurationMethod) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectService.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectService.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertisementStatus = {};
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertisementStatus.created;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertisementStatus.started;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertisementStatus.stopped;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertisementStatus.aborted;

/**
 * @constructor
 * @struct
 * Creates an instance of the WiFiDirectServiceAdvertiser class. To start advertising a Wi-Fi Direct Service, create an instance of this class, set its properties appropriately for your service, and then call its Start method.
 * @param {string} serviceName The name of the service to be advertised. Service names are UTF-8 strings no more than 255 characters long. It is recommended that names use reverse domain name notation, where the service owner's DNS name (such as "contoso.com") is reversed and used as the beginning of the service name (such as "com.contoso.serviceX"). This convention is intended to make it easy to choose unique service names. Service names that start with "org.wi-fi.wfds" are reserved for use by the Wi-Fi Alliance, and you may not use such names for your service.
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser = function(serviceName) {};
 /** @type {Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertisementStatus} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.advertisementStatus;
 /** @type {boolean} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.autoAcceptSession;
 /** @type {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.customServiceStatusCode;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.deferredSessionInfo;
 /** @type {function(?): void} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.onadvertisementstatuschanged;
 /** @type {function(?): void} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.onautoacceptsessionconnected;
 /** @type {function(?): void} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.onsessionrequested;
 /** @type {boolean} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.preferGroupOwnerMode;
 /** @type {!Windows.Foundation.Collections.IVector<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceConfigurationMethod>} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.preferredConfigurationMethods;
 /** @type {Windows.Devices.WiFiDirect.Services.WiFiDirectServiceError} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.serviceError;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.serviceInfo;
 /** @type {string} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.serviceName;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.serviceNamePrefixes;
 /** @type {Windows.Devices.WiFiDirect.Services.WiFiDirectServiceStatus} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.serviceStatus;

/**
 * Accepts a session request by connecting with the given PIN.
 * Accepts a session request without requiring a PIN.
 * @param {!Windows.Devices.Enumeration.DeviceInformation} deviceInfo Describes the device to be connected. Pass in the WiFiDirectServiceSessionRequestedEventArgs.DeviceInformation property value.
 * @param {string=} pin The PIN to be used to configure the session.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession, !Windows.Foundation.IAsyncOperation<!Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession>>} An asynchronous connection operation. On successful completion, returns an object that describes the session that has been created.
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.connectAsync = function(deviceInfo, pin) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.removeEventListener = function(type, listener) {};

/**
 * Starts advertising the service, using current property values to set the parameters of the advertisement.
 * @return {void}
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.start = function() {};

/**
 * Stops advertising the service. This does not affect existing sessions that are connected to the service.
 * @return {void}
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser.prototype.stop = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAutoAcceptSessionConnectedEventArgs = function() {};
 /** @type {!Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAutoAcceptSessionConnectedEventArgs.prototype.session;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAutoAcceptSessionConnectedEventArgs.prototype.sessionInfo;

/** @const */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceConfigurationMethod = {};
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceConfigurationMethod.default;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceConfigurationMethod.pinDisplay;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceConfigurationMethod.pinEntry;

/** @const */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceError = {};
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceError.success;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceError.radioNotAvailable;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceError.resourceInUse;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceError.unsupportedHardware;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceError.noHardware;

/** @const */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceIPProtocol = {};
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceIPProtocol.tcp;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceIPProtocol.udp;
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceProvisioningInfo = function() {};
 /** @type {boolean} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceProvisioningInfo.prototype.isGroupFormationNeeded;
 /** @type {Windows.Devices.WiFiDirect.Services.WiFiDirectServiceConfigurationMethod} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceProvisioningInfo.prototype.selectedConfigurationMethod;
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceRemotePortAddedEventArgs = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.EndpointPair>} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceRemotePortAddedEventArgs.prototype.endpointPairs;
 /** @type {Windows.Devices.WiFiDirect.Services.WiFiDirectServiceIPProtocol} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceRemotePortAddedEventArgs.prototype.protocol;
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession = function() {};
 /** @type {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.advertisementId;
 /** @type {Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionErrorStatus} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.errorStatus;
 /** @type {function(?): void} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.onremoteportadded;
 /** @type {function(?): void} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.onsessionstatuschanged;
 /** @type {string} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.serviceAddress;
 /** @type {string} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.serviceName;
 /** @type {string} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.sessionAddress;
 /** @type {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.sessionId;
 /** @type {Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionStatus} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.status;

/**
 * Adds a DatagramSocket to the session. Your code creates the DatagramSocket before calling this method. Associating a socket to the session causes port information to be sent to the remote device(s) in the session. (In terms of this API, a RemotePortAdded event is raised on each remote device in the session, specifying the UDP protocol.) A remote device can use that information to open a socket and connect back to the local machine.
 * @param {!Windows.Networking.Sockets.DatagramSocket} value The DatagramSocket instance to associate with this session.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous association action. Returns on successful completion of the association.
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.addDatagramSocketAsync = function(value) {};

/**
 * Adds a StreamSocketListener to the session. Your code creates the StreamSocketListener before calling this method. Associating a socket to the session causes port information to be sent to the remote device(s) in the session. (In terms of this API, a RemotePortAdded event is raised on each remote device in the session, specifying the TCP protocol.) A remote device can use that information to open a socket and connect back to the local machine.
 * @param {!Windows.Networking.Sockets.StreamSocketListener} value The StreamSocketListener instance to be associated with the session.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous association action. Returns on successful completion of the association.
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.addStreamSocketListenerAsync = function(value) {};

/**
 * Closes the session.
 * @return {void}
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.close = function() {};

/**
 * Gets a list of connection endpoint pairs for the session. Your code uses IVectorView operations to enumerate the endpoint pairs in the list.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.EndpointPair>} An immutable snapshot list of endpoint pairs involved in the session.
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.getConnectionEndpointPairs = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionDeferredEventArgs = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionDeferredEventArgs.prototype.deferredSessionInfo;

/** @const */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionErrorStatus = {};
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionErrorStatus.ok;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionErrorStatus.disassociated;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionErrorStatus.localClose;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionErrorStatus.remoteClose;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionErrorStatus.systemFailure;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionErrorStatus.noResponseFromRemote;
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionRequest = function() {};
 /** @type {!Windows.Devices.Enumeration.DeviceInformation} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionRequest.prototype.deviceInformation;
 /** @type {!Windows.Devices.WiFiDirect.Services.WiFiDirectServiceProvisioningInfo} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionRequest.prototype.provisioningInfo;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionRequest.prototype.sessionInfo;

/**
 * Closes the session request. Your server code calls this method to reject a session request.
 * @return {void}
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionRequest.prototype.close = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionRequestedEventArgs = function() {};

/**
 * Gets information about the session request that raised a WiFiDirectServiceAdvertiser.SessionRequested event.
 * @return {!Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionRequest} Information about a new session request.
 */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionRequestedEventArgs.prototype.getSessionRequest = function() {};

/** @const */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionStatus = {};
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionStatus.closed;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionStatus.initiated;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionStatus.requested;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionStatus.open;

/** @const */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceStatus = {};
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceStatus.available;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceStatus.busy;
/** @const {number} */
Windows.Devices.WiFiDirect.Services.WiFiDirectServiceStatus.custom;
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisement = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Devices.WiFiDirect.WiFiDirectInformationElement>} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisement.prototype.informationElements;
 /** @type {boolean} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisement.prototype.isAutonomousGroupOwnerEnabled;
 /** @type {!Windows.Devices.WiFiDirect.WiFiDirectLegacySettings} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisement.prototype.legacySettings;
 /** @type {Windows.Devices.WiFiDirect.WiFiDirectAdvertisementListenStateDiscoverability} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisement.prototype.listenStateDiscoverability;
 /** @type {!Windows.Foundation.Collections.IVector<Windows.Devices.WiFiDirect.WiFiDirectConfigurationMethod>} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisement.prototype.supportedConfigurationMethods;

/** @const */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementListenStateDiscoverability = {};
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementListenStateDiscoverability.none;
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementListenStateDiscoverability.normal;
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementListenStateDiscoverability.intensive;

/**
 * @constructor
 * @struct
 * Creates a new WiFiDirectAdvertisementPublisher object.
 */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisher = function() {};
 /** @type {!Windows.Devices.WiFiDirect.WiFiDirectAdvertisement} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisher.prototype.advertisement;
 /** @type {function(?): void} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisher.prototype.onstatuschanged;
 /** @type {Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatus} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisher.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisher.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisher.prototype.removeEventListener = function(type, listener) {};

/**
 * Starts the Wi-Fi Direct advertisement.
 * @return {void}
 */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisher.prototype.start = function() {};

/**
 * Stops the Wi-Fi Direct advertisement.
 * @return {void}
 */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisher.prototype.stop = function() {};

/** @const */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatus = {};
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatus.created;
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatus.started;
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatus.stopped;
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatus.aborted;
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatusChangedEventArgs = function() {};
 /** @type {Windows.Devices.WiFiDirect.WiFiDirectError} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatusChangedEventArgs.prototype.error;
 /** @type {Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatus} */
Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatusChangedEventArgs.prototype.status;

/** @const */
Windows.Devices.WiFiDirect.WiFiDirectConfigurationMethod = {};
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectConfigurationMethod.providePin;
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectConfigurationMethod.displayPin;
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectConfigurationMethod.pushButton;

/**
 * @constructor
 * @struct
 * Creates a new WiFiDirectConnectionListener object.
 */
Windows.Devices.WiFiDirect.WiFiDirectConnectionListener = function() {};
 /** @type {function(?): void} */
Windows.Devices.WiFiDirect.WiFiDirectConnectionListener.prototype.onconnectionrequested;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.WiFiDirect.WiFiDirectConnectionListener.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.WiFiDirect.WiFiDirectConnectionListener.prototype.removeEventListener = function(type, listener) {};

/**
 * @constructor
 * @struct
 * Creates a new WiFiDirectConnectionParameters object.
 */
Windows.Devices.WiFiDirect.WiFiDirectConnectionParameters = function() {};
 /** @type {number} */
Windows.Devices.WiFiDirect.WiFiDirectConnectionParameters.prototype.groupOwnerIntent;
 /** @type {!Windows.Foundation.Collections.IVector<Windows.Devices.WiFiDirect.WiFiDirectConfigurationMethod>} */
Windows.Devices.WiFiDirect.WiFiDirectConnectionParameters.prototype.preferenceOrderedConfigurationMethods;
 /** @type {Windows.Devices.WiFiDirect.WiFiDirectPairingProcedure} */
Windows.Devices.WiFiDirect.WiFiDirectConnectionParameters.prototype.preferredPairingProcedure;

/**
 * Gets a list of the DevicePairingKinds supporting the given configuration method.
 * @param {Windows.Devices.WiFiDirect.WiFiDirectConfigurationMethod} configurationMethod A value specifying a configuration method.
 * @return {Windows.Devices.Enumeration.DevicePairingKinds} A value specifying a pairing kind, for use with the pairing functionality in the Windows.Devices.Enumeration API.
 */
Windows.Devices.WiFiDirect.WiFiDirectConnectionParameters.getDevicePairingKinds = function(configurationMethod) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFiDirect.WiFiDirectConnectionRequest = function() {};
 /** @type {!Windows.Devices.Enumeration.DeviceInformation} */
Windows.Devices.WiFiDirect.WiFiDirectConnectionRequest.prototype.deviceInformation;

/**
 * Closes the WiFiDirectConnectionRequest object.
 * @return {void}
 */
Windows.Devices.WiFiDirect.WiFiDirectConnectionRequest.prototype.close = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFiDirect.WiFiDirectConnectionRequestedEventArgs = function() {};

/**
 * Retrieves the WiFiDirectConnectionRequest received on a ConnectionRequested event by a WiFiDirectConnectionListener .
 * @return {!Windows.Devices.WiFiDirect.WiFiDirectConnectionRequest} The Wi-FI Direct connection request.
 */
Windows.Devices.WiFiDirect.WiFiDirectConnectionRequestedEventArgs.prototype.getConnectionRequest = function() {};

/** @const */
Windows.Devices.WiFiDirect.WiFiDirectConnectionStatus = {};
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectConnectionStatus.disconnected;
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectConnectionStatus.connected;
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFiDirect.WiFiDirectDevice = function() {};
 /** @type {Windows.Devices.WiFiDirect.WiFiDirectConnectionStatus} */
Windows.Devices.WiFiDirect.WiFiDirectDevice.prototype.connectionStatus;
 /** @type {string} */
Windows.Devices.WiFiDirect.WiFiDirectDevice.prototype.deviceId;
 /** @type {function(?): void} */
Windows.Devices.WiFiDirect.WiFiDirectDevice.prototype.onconnectionstatuschanged;

/**
 * Creates an instance of the WiFiDirectDevice class for the specified device interface id.
 * Creates an instance of the WiFiDirectDevice class for the specified device interface id with specific connection parameters.
 * @param {string} deviceId The DeviceInformation Id of a Wi-Fi Direct device.
 * @param {!Windows.Devices.WiFiDirect.WiFiDirectConnectionParameters=} connectionParameters Connection parameters for a Wi-Fi Direct connect/pairing operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.WiFiDirect.WiFiDirectDevice, !Windows.Foundation.IAsyncOperation<!Windows.Devices.WiFiDirect.WiFiDirectDevice>>} An asynchronous operation to retrieve the WiFiDirectDevice that was created.
 */
Windows.Devices.WiFiDirect.WiFiDirectDevice.fromIdAsync = function(deviceId, connectionParameters) {};

/**
 * Returns the class selection string that you can use to enumerate Wi-Fi Direct devices.
 * Returns the class selection string that you can use to enumerate Wi-Fi Direct devices for a specific Wi-Fi Direct device selector type.
 * @param {Windows.Devices.WiFiDirect.WiFiDirectDeviceSelectorType=} type A specific Wi-Fi Direct device selector type.
 * @return {string} The class selection string that you can use to enumerate Wi-Fi Direct devices.
 */
Windows.Devices.WiFiDirect.WiFiDirectDevice.getDeviceSelector = function(type) {};

/**
 * Close the active Wi-Fi Direct device connection.
 * @return {void}
 */
Windows.Devices.WiFiDirect.WiFiDirectDevice.prototype.close = function() {};

/**
 * Gets a collection of network addresses for the Wi-Fi Direct device as endpoint pairs.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.EndpointPair>} A collection of network addresses for the Wi-Fi Direct device as endpoint pairs.
 */
Windows.Devices.WiFiDirect.WiFiDirectDevice.prototype.getConnectionEndpointPairs = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.WiFiDirect.WiFiDirectDevice.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Devices.WiFiDirect.WiFiDirectDevice.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Devices.WiFiDirect.WiFiDirectDeviceSelectorType = {};
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectDeviceSelectorType.deviceInterface;
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectDeviceSelectorType.associationEndpoint;

/** @const */
Windows.Devices.WiFiDirect.WiFiDirectError = {};
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectError.success;
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectError.radioNotAvailable;
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectError.resourceInUse;

/**
 * @constructor
 * @struct
 * Creates a new WiFiDirectInformationElement object.
 */
Windows.Devices.WiFiDirect.WiFiDirectInformationElement = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.WiFiDirect.WiFiDirectInformationElement.prototype.oui;
 /** @type {number} */
Windows.Devices.WiFiDirect.WiFiDirectInformationElement.prototype.ouiType;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Devices.WiFiDirect.WiFiDirectInformationElement.prototype.value;

/**
 * Create an array of information elements from a data buffer.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The data buffer that contains a information element.
 * @return {!Windows.Foundation.Collections.IVector<!Windows.Devices.WiFiDirect.WiFiDirectInformationElement>} A array of information elements created from the buffer.
 */
Windows.Devices.WiFiDirect.WiFiDirectInformationElement.createFromBuffer = function(buffer) {};

/**
 * Create an array of information elements from a DeviceInformation object.
 * @param {!Windows.Devices.Enumeration.DeviceInformation} deviceInformation The device information object that contains the information elements.
 * @return {!Windows.Foundation.Collections.IVector<!Windows.Devices.WiFiDirect.WiFiDirectInformationElement>} A array of information elements created from the device information object.
 */
Windows.Devices.WiFiDirect.WiFiDirectInformationElement.createFromDeviceInformation = function(deviceInformation) {};
/**
 * @constructor
 * @struct
 */
Windows.Devices.WiFiDirect.WiFiDirectLegacySettings = function() {};
 /** @type {boolean} */
Windows.Devices.WiFiDirect.WiFiDirectLegacySettings.prototype.isEnabled;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Devices.WiFiDirect.WiFiDirectLegacySettings.prototype.passphrase;
 /** @type {string} */
Windows.Devices.WiFiDirect.WiFiDirectLegacySettings.prototype.ssid;

/** @const */
Windows.Devices.WiFiDirect.WiFiDirectPairingProcedure = {};
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectPairingProcedure.groupOwnerNegotiation;
/** @const {number} */
Windows.Devices.WiFiDirect.WiFiDirectPairingProcedure.invitation;

/** @const */
Windows.Foundation.AsyncStatus = {};
/** @const {number} */
Windows.Foundation.AsyncStatus.canceled;
/** @const {number} */
Windows.Foundation.AsyncStatus.completed;
/** @const {number} */
Windows.Foundation.AsyncStatus.error;
/** @const {number} */
Windows.Foundation.AsyncStatus.started;

/** @const */
Windows.Foundation.Collections.CollectionChange = {};
/** @const {number} */
Windows.Foundation.Collections.CollectionChange.reset;
/** @const {number} */
Windows.Foundation.Collections.CollectionChange.itemInserted;
/** @const {number} */
Windows.Foundation.Collections.CollectionChange.itemRemoved;
/** @const {number} */
Windows.Foundation.Collections.CollectionChange.itemChanged;

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the property set.
 */
Windows.Foundation.Collections.PropertySet = function() {};
 /** @type {function(?): void} */
Windows.Foundation.Collections.PropertySet.prototype.onmapchanged;
 /** @type {number} */
Windows.Foundation.Collections.PropertySet.prototype.size;

/**
 * Removes all items from the property set.
 * @return {void}
 */
Windows.Foundation.Collections.PropertySet.prototype.clear = function() {};

/**
 * Returns an iterator to enumerate the items in the property set.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The iterator. The current position of the iterator is index 0, or the end of the property set if the property set is empty.
 */
Windows.Foundation.Collections.PropertySet.prototype.first = function() {};

/**
 * Gets an immutable view of the property set.
 * @return {!Windows.Foundation.Collections.IMapView<string, ?>} The immutable view.
 */
Windows.Foundation.Collections.PropertySet.prototype.getView = function() {};

/**
 * Indicates whether the property set has an item with the specified key.
 * @param {string} key The key.
 * @return {boolean} True if the property set has an item with the specified key; otherwise, false.
 */
Windows.Foundation.Collections.PropertySet.prototype.hasKey = function(key) {};

/**
 * Adds an item to the property set.
 * @param {string} key The key to insert.
 * @param {?} value The value to insert.
 * @return {boolean} True if the method replaces a value that already exists for the key; false if this is a new key.
 */
Windows.Foundation.Collections.PropertySet.prototype.insert = function(key, value) {};

/**
 * Retrieves the value for the specified key.
 * @param {string} key The key.
 * @return {?} The value, if an item with the specified key exists; otherwise, null.
 */
Windows.Foundation.Collections.PropertySet.prototype.lookup = function(key) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Foundation.Collections.PropertySet.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Foundation.Collections.PropertySet.prototype.removeEventListener = function(type, listener) {};

/**
 * Removes an item from the property set.
 * Removes a specific item from the PropertySet .
 * @param {string} key The key. / The key of the item to remove.
 * @return {void|boolean} true if the item was removed, otherwise false.
 */
Windows.Foundation.Collections.PropertySet.prototype.remove = function(key) {};

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the StringMap.
 */
Windows.Foundation.Collections.StringMap = function() {};
 /** @type {function(?): void} */
Windows.Foundation.Collections.StringMap.prototype.onmapchanged;
 /** @type {number} */
Windows.Foundation.Collections.StringMap.prototype.size;

/**
 * Removes all items from the map.
 * @return {void}
 */
Windows.Foundation.Collections.StringMap.prototype.clear = function() {};

/**
 * Returns an iterator containing the items in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The items in the collection.
 */
Windows.Foundation.Collections.StringMap.prototype.first = function() {};

/**
 * Returns an immutable view of the map.
 * @return {!Windows.Foundation.Collections.IMapView<string, string>} The view of the map.
 */
Windows.Foundation.Collections.StringMap.prototype.getView = function() {};

/**
 * Determines whether the map contains the specified key.
 * @param {string} key The key associated with the item to locate.
 * @return {boolean} True if the key is found; otherwise, false.
 */
Windows.Foundation.Collections.StringMap.prototype.hasKey = function(key) {};

/**
 * Inserts or replaces an item in the map.
 * @param {string} key The key associated with the item to insert.
 * @param {string} value The item to insert.
 * @return {boolean} True if an item with the specified key is an existing item that was replaced; otherwise, false.
 */
Windows.Foundation.Collections.StringMap.prototype.insert = function(key, value) {};

/**
 * Returns the item at the specified key in the map.
 * @param {string} key The key associated with the item to locate.
 * @return {string} The item associated with the specified key.
 */
Windows.Foundation.Collections.StringMap.prototype.lookup = function(key) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Foundation.Collections.StringMap.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Foundation.Collections.StringMap.prototype.removeEventListener = function(type, listener) {};

/**
 * Removes an item from the map.
 * @param {string} key The key associated with the item to remove.
 * @return {void}
 */
Windows.Foundation.Collections.StringMap.prototype.remove = function(key) {};

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the property set.
 */
Windows.Foundation.Collections.ValueSet = function() {};
 /** @type {function(?): void} */
Windows.Foundation.Collections.ValueSet.prototype.onmapchanged;
 /** @type {number} */
Windows.Foundation.Collections.ValueSet.prototype.size;

/**
 * Removes all items from the value set.
 * @return {void}
 */
Windows.Foundation.Collections.ValueSet.prototype.clear = function() {};

/**
 * Returns an iterator to enumerate the items in the value set.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The iterator. The current position of the iterator is index 0, or the end of the value set if the value set is empty.
 */
Windows.Foundation.Collections.ValueSet.prototype.first = function() {};

/**
 * Gets an immutable view of the value set.
 * @return {!Windows.Foundation.Collections.IMapView<string, ?>} The immutable view.
 */
Windows.Foundation.Collections.ValueSet.prototype.getView = function() {};

/**
 * Indicates whether the value set has an item with the specified key.
 * @param {string} key The key.
 * @return {boolean} True if the value set has an item with the specified key; otherwise, false.
 */
Windows.Foundation.Collections.ValueSet.prototype.hasKey = function(key) {};

/**
 * Adds an item to the value set.
 * @param {string} key The key to insert.
 * @param {?} value The value to insert.
 * @return {boolean} True if the method replaces a value that already exists for the key; false if this is a new key.
 */
Windows.Foundation.Collections.ValueSet.prototype.insert = function(key, value) {};

/**
 * Retrieves the value for the specified key.
 * @param {string} key The key.
 * @return {?} The value, if an item with the specified key exists; otherwise, null.
 */
Windows.Foundation.Collections.ValueSet.prototype.lookup = function(key) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Foundation.Collections.ValueSet.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Foundation.Collections.ValueSet.prototype.removeEventListener = function(type, listener) {};

/**
 * Removes a specific item from the ValueSet .
 * Removes an item from the value set.
 * @param {string} key The key of the item to remove. / The key.
 * @return {boolean|void} true if the item was removed, otherwise false.
 */
Windows.Foundation.Collections.ValueSet.prototype.remove = function(key) {};
 /** @type {number} */
Windows.Foundation.Collections.IVectorView.prototype.size;

/**
 * Returns the item at the specified index in the vector view.
 * @param {number} index The zero-based index of the item.
 * @return {T} The item at the specified index.
 */
Windows.Foundation.Collections.IVectorView.prototype.getAt = function(index) {};

/**
 * Retrieves the items that start at the specified index in the vector view.
 * @param {number} startIndex The zero-based index of the start of the items in the vector view.
 * @return {{items: T, returnValue: number}}
 */
Windows.Foundation.Collections.IVectorView.prototype.getMany = function(startIndex) {};

/**
 * Retrieves the index of a specified item in the vector view.
 * @param {T} value The item to find in the vector view.
 * @return {{index: number, returnValue: boolean}}
 */
Windows.Foundation.Collections.IVectorView.prototype.indexOf = function(value) {};
 /** @type {number} */
Windows.Foundation.Collections.IVector.prototype.size;

/**
 * Appends an item to the end of the vector.
 * @param {T} value The item to append to the vector.
 * @return {void}
 */
Windows.Foundation.Collections.IVector.prototype.append = function(value) {};

/**
 * Removes all items from the vector.
 * @return {void}
 */
Windows.Foundation.Collections.IVector.prototype.clear = function() {};

/**
 * Returns the item at the specified index in the vector.
 * @param {number} index The zero-based index of the item.
 * @return {T} The item at the specified index.
 */
Windows.Foundation.Collections.IVector.prototype.getAt = function(index) {};

/**
 * Retrieves the items that start at the specified index in the vector.
 * @param {number} startIndex The zero-based index of the start of the items in the vector.
 * @return {{items: T, returnValue: number}}
 */
Windows.Foundation.Collections.IVector.prototype.getMany = function(startIndex) {};

/**
 * Returns an immutable view of the vector.
 * @return {!Windows.Foundation.Collections.IVectorView<T>} The view of the vector.
 */
Windows.Foundation.Collections.IVector.prototype.getView = function() {};

/**
 * Retrieves the index of a specified item in the vector.
 * @param {T} value The item to find in the vector.
 * @return {{index: number, returnValue: boolean}}
 */
Windows.Foundation.Collections.IVector.prototype.indexOf = function(value) {};

/**
 * Inserts an item at a specified index in the vector.
 * @param {number} index The zero-based index.
 * @param {T} value The item to insert.
 * @return {void}
 */
Windows.Foundation.Collections.IVector.prototype.insertAt = function(index, value) {};

/**
 * Removes the item at the specified index in the vector.
 * @param {number} index The zero-based index of the vector item to remove.
 * @return {void}
 */
Windows.Foundation.Collections.IVector.prototype.removeAt = function(index) {};

/**
 * Removes the last item from the vector.
 * @return {void}
 */
Windows.Foundation.Collections.IVector.prototype.removeAtEnd = function() {};

/**
 * Replaces all the items in the vector with the specified items.
 * @param {T} items The collection of items to add to the vector.
 * @return {void}
 */
Windows.Foundation.Collections.IVector.prototype.replaceAll = function(items) {};

/**
 * Sets the value at the specified index in the vector.
 * @param {number} index The zero-based index at which to set the value.
 * @param {T} value The item to set.
 * @return {void}
 */
Windows.Foundation.Collections.IVector.prototype.setAt = function(index, value) {};
/**
 * @record
 * @struct
 */
Windows.Foundation.Collections.IIterable = function() {};

/**
 * Returns an iterator for the items in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<T>} The iterator.
 */
Windows.Foundation.Collections.IIterable.prototype.first = function() {};
/**
 * @extends {Windows.Foundation.Collections.IIterable}
 * @record
 * @struct
 */
Windows.Foundation.Collections.IMapView = function() {};
 /** @type {number} */
Windows.Foundation.Collections.IMapView.prototype.size;

/**
 * Determines whether the map view contains the specified key.
 * @param {K} key The key to locate in the map view.
 * @return {boolean} True if the key is found; otherwise, false.
 */
Windows.Foundation.Collections.IMapView.prototype.hasKey = function(key) {};

/**
 * Returns the item at the specified key in the map view.
 * @param {K} key The key to locate in the map view.
 * @return {V} The item associated with the specified key.
 */
Windows.Foundation.Collections.IMapView.prototype.lookup = function(key) {};

/**
 * Splits the map view into two views.
 * @return {{first: !Windows.Foundation.Collections.IMapView, second: !Windows.Foundation.Collections.IMapView}}
 */
Windows.Foundation.Collections.IMapView.prototype.split = function() {};
/**
 * @extends {Windows.Foundation.Collections.IObservableMap}
 * @extends {Windows.Foundation.Collections.IMap}
 * @extends {Windows.Foundation.Collections.IIterable}
 * @record
 * @struct
 */
Windows.Foundation.Collections.IPropertySet = function() {};
/**
 * @extends {Windows.Foundation.Collections.IIterable}
 * @record
 * @struct
 */
Windows.Foundation.Collections.IMap = function() {};
 /** @type {number} */
Windows.Foundation.Collections.IMap.prototype.size;

/**
 * Removes all items from the map.
 * @return {void}
 */
Windows.Foundation.Collections.IMap.prototype.clear = function() {};

/**
 * Returns an immutable view of the map.
 * @return {!Windows.Foundation.Collections.IMapView<K, V>} The view of the map.
 */
Windows.Foundation.Collections.IMap.prototype.getView = function() {};

/**
 * Determines whether the map contains the specified key.
 * @param {K} key The key associated with the item to locate.
 * @return {boolean} True if the key is found; otherwise, false.
 */
Windows.Foundation.Collections.IMap.prototype.hasKey = function(key) {};

/**
 * Inserts or replaces an item in the map.
 * @param {K} key The key associated with the item to insert.
 * @param {V} value The item to insert.
 * @return {boolean} True if an item with the specified key is an existing item that was replaced; otherwise, false.
 */
Windows.Foundation.Collections.IMap.prototype.insert = function(key, value) {};

/**
 * Returns the item at the specified key in the map.
 * @param {K} key The key associated with the item to locate.
 * @return {V} The item associated with the specified key.
 */
Windows.Foundation.Collections.IMap.prototype.lookup = function(key) {};

/**
 * Removes an item from the map.
 * @param {K} key The key associated with the item to remove.
 * @return {void}
 */
Windows.Foundation.Collections.IMap.prototype.remove = function(key) {};
/**
 * @record
 * @struct
 */
Windows.Foundation.Collections.IIterator = function() {};
 /** @type {T} */
Windows.Foundation.Collections.IIterator.prototype.current;
 /** @type {boolean} */
Windows.Foundation.Collections.IIterator.prototype.hasCurrent;

/**
 * Retrieves all items in the collection.
 * @return {{items: T, returnValue: number}}
 */
Windows.Foundation.Collections.IIterator.prototype.getMany = function() {};

/**
 * Advances the iterator to the next item in the collection.
 * @return {boolean} True if the iterator refers to a valid item in the collection; false if the iterator passes the end of the collection.
 */
Windows.Foundation.Collections.IIterator.prototype.moveNext = function() {};
/**
 * @record
 * @struct
 */
Windows.Foundation.Collections.IKeyValuePair = function() {};
 /** @type {K} */
Windows.Foundation.Collections.IKeyValuePair.prototype.key;
 /** @type {V} */
Windows.Foundation.Collections.IKeyValuePair.prototype.value;
/**
 * @extends {Windows.Foundation.Collections.IMap}
 * @extends {Windows.Foundation.Collections.IIterable}
 * @record
 * @struct
 */
Windows.Foundation.Collections.IObservableMap = function() {};

/** @typedef {function(?): void} */
Windows.Foundation.Collections.MapChangedEventHandler;
/**
 * @extends {Windows.Foundation.Collections.IVector}
 * @extends {Windows.Foundation.Collections.IIterable}
 * @record
 * @struct
 */
Windows.Foundation.Collections.IObservableVector = function() {};
/**
 * @record
 * @struct
 */
Windows.Foundation.Collections.IVectorChangedEventArgs = function() {};
 /** @type {Windows.Foundation.Collections.CollectionChange} */
Windows.Foundation.Collections.IVectorChangedEventArgs.prototype.collectionChange;
 /** @type {number} */
Windows.Foundation.Collections.IVectorChangedEventArgs.prototype.index;
/**
 * @record
 * @struct
 */
Windows.Foundation.Collections.IMapChangedEventArgs = function() {};
 /** @type {Windows.Foundation.Collections.CollectionChange} */
Windows.Foundation.Collections.IMapChangedEventArgs.prototype.collectionChange;
 /** @type {K} */
Windows.Foundation.Collections.IMapChangedEventArgs.prototype.key;

/**
 * @constructor
 * @struct
 * Initializes a new Deferral object and specifies a DeferralCompletedHandler to be called upon completion of the deferral.
 * @param {function(): void} handler A DeferralCompletedHandler to be called upon completion of the deferral.
 */
Windows.Foundation.Deferral = function(handler) {};

/**
 * If the DeferralCompletedHandler has not yet been invoked, this will call it and drop the reference to the delegate.
 * @return {void}
 */
Windows.Foundation.Deferral.prototype.close = function() {};

/**
 * If the DeferralCompletedHandler has not yet been invoked, this will call it and drop the reference to the delegate.
 * @return {void}
 */
Windows.Foundation.Deferral.prototype.complete = function() {};
/** @const */
Windows.Foundation.Diagnostics = {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Diagnostics.AsyncCausalityTracer = function() {};
 /** @type {function(?): void} */
Windows.Foundation.Diagnostics.AsyncCausalityTracer.ontracingstatuschanged;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Foundation.Diagnostics.AsyncCausalityTracer.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Foundation.Diagnostics.AsyncCausalityTracer.removeEventListener = function(type, listener) {};

/**
 * Indicates that a previously created asynchronous operation has completed all of its asynchronous work.
 * @param {Windows.Foundation.Diagnostics.CausalityTraceLevel} traceLevel The trace level.
 * @param {Windows.Foundation.Diagnostics.CausalitySource} source The trace source.
 * @param {string} platformId Identifier for the operation type.
 * @param {number} operationId The identifier for the asynchronous operation that's unique within the platform for the operation's lifetime.
 * @param {Windows.Foundation.AsyncStatus} status The completion status of the asynchronous operation.
 * @return {void}
 */
Windows.Foundation.Diagnostics.AsyncCausalityTracer.traceOperationCompletion = function(traceLevel, source, platformId, operationId, status) {};

/**
 * Logs the creation of an asynchronous operation.
 * @param {Windows.Foundation.Diagnostics.CausalityTraceLevel} traceLevel The trace level.
 * @param {Windows.Foundation.Diagnostics.CausalitySource} source The trace source.
 * @param {string} platformId Identifier for the operation type.
 * @param {number} operationId An identifier for the asynchronous operation that's unique within the platform for the operation's lifetime.
 * @param {string} operationName A human-readable description of the asynchronous work.
 * @param {number} relatedContext Additional information related to this operation.
 * @return {void}
 */
Windows.Foundation.Diagnostics.AsyncCausalityTracer.traceOperationCreation = function(traceLevel, source, platformId, operationId, operationName, relatedContext) {};

/**
 * Logs the relation between the currently running synchronous work item and a specific asynchronous operation that it's related to.
 * @param {Windows.Foundation.Diagnostics.CausalityTraceLevel} traceLevel The trace level.
 * @param {Windows.Foundation.Diagnostics.CausalitySource} source The trace source.
 * @param {string} platformId Identifier for the operation type.
 * @param {number} operationId The identifier for the asynchronous operation that's unique within the platform for the operation's lifetime.
 * @param {Windows.Foundation.Diagnostics.CausalityRelation} relation The relationship between the synchronous work item and asynchronous operation identified by operationId.
 * @return {void}
 */
Windows.Foundation.Diagnostics.AsyncCausalityTracer.traceOperationRelation = function(traceLevel, source, platformId, operationId, relation) {};

/**
 * Indicates that the most recently created synchronous work item running on the thread that the TraceSynchronousWorkCompletion method is called on has completed.
 * @param {Windows.Foundation.Diagnostics.CausalityTraceLevel} traceLevel The trace level.
 * @param {Windows.Foundation.Diagnostics.CausalitySource} source The trace source.
 * @param {Windows.Foundation.Diagnostics.CausalitySynchronousWork} work Indicates the type of completion.
 * @return {void}
 */
Windows.Foundation.Diagnostics.AsyncCausalityTracer.traceSynchronousWorkCompletion = function(traceLevel, source, work) {};

/**
 * Indicates that the specified asynchronous operation is scheduling synchronous work on the thread that the TraceSynchronousWorkStart method is called on.
 * @param {Windows.Foundation.Diagnostics.CausalityTraceLevel} traceLevel The trace level.
 * @param {Windows.Foundation.Diagnostics.CausalitySource} source The trace source.
 * @param {string} platformId Identifier for the operation type.
 * @param {number} operationId The identifier for the asynchronous operation that's unique within the platform for the operation's lifetime.
 * @param {Windows.Foundation.Diagnostics.CausalitySynchronousWork} work The relationship between the work item and the asynchronous operation.
 * @return {void}
 */
Windows.Foundation.Diagnostics.AsyncCausalityTracer.traceSynchronousWorkStart = function(traceLevel, source, platformId, operationId, work) {};

/** @const */
Windows.Foundation.Diagnostics.CausalityRelation = {};
/** @const {number} */
Windows.Foundation.Diagnostics.CausalityRelation.assignDelegate;
/** @const {number} */
Windows.Foundation.Diagnostics.CausalityRelation.join;
/** @const {number} */
Windows.Foundation.Diagnostics.CausalityRelation.choice;
/** @const {number} */
Windows.Foundation.Diagnostics.CausalityRelation.cancel;
/** @const {number} */
Windows.Foundation.Diagnostics.CausalityRelation.error;

/** @const */
Windows.Foundation.Diagnostics.CausalitySource = {};
/** @const {number} */
Windows.Foundation.Diagnostics.CausalitySource.application;
/** @const {number} */
Windows.Foundation.Diagnostics.CausalitySource.library;
/** @const {number} */
Windows.Foundation.Diagnostics.CausalitySource.system;

/** @const */
Windows.Foundation.Diagnostics.CausalitySynchronousWork = {};
/** @const {number} */
Windows.Foundation.Diagnostics.CausalitySynchronousWork.completionNotification;
/** @const {number} */
Windows.Foundation.Diagnostics.CausalitySynchronousWork.progressNotification;
/** @const {number} */
Windows.Foundation.Diagnostics.CausalitySynchronousWork.execution;

/** @const */
Windows.Foundation.Diagnostics.CausalityTraceLevel = {};
/** @const {number} */
Windows.Foundation.Diagnostics.CausalityTraceLevel.required;
/** @const {number} */
Windows.Foundation.Diagnostics.CausalityTraceLevel.important;
/** @const {number} */
Windows.Foundation.Diagnostics.CausalityTraceLevel.verbose;
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Diagnostics.ErrorDetails = function() {};
 /** @type {string} */
Windows.Foundation.Diagnostics.ErrorDetails.prototype.description;
 /** @type {!Windows.Foundation.Uri} */
Windows.Foundation.Diagnostics.ErrorDetails.prototype.helpUri;
 /** @type {string} */
Windows.Foundation.Diagnostics.ErrorDetails.prototype.longDescription;

/**
 * Asynchronously creates an ErrorDetails object based on an HRESULT error code.
 * @param {number} errorCode The unique code representing the error.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Diagnostics.ErrorDetails, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Diagnostics.ErrorDetails>>} The newly created ErrorDetails object representing the error.
 */
Windows.Foundation.Diagnostics.ErrorDetails.createFromHResultAsync = function(errorCode) {};

/** @const */
Windows.Foundation.Diagnostics.ErrorOptions = {};
/** @const {number} */
Windows.Foundation.Diagnostics.ErrorOptions.none;
/** @const {number} */
Windows.Foundation.Diagnostics.ErrorOptions.suppressExceptions;
/** @const {number} */
Windows.Foundation.Diagnostics.ErrorOptions.forceExceptions;
/** @const {number} */
Windows.Foundation.Diagnostics.ErrorOptions.useSetErrorInfo;
/** @const {number} */
Windows.Foundation.Diagnostics.ErrorOptions.suppressSetErrorInfo;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the FileLoggingSession class.
 * @param {string} name The name of the logging session.
 */
Windows.Foundation.Diagnostics.FileLoggingSession = function(name) {};
 /** @type {string} */
Windows.Foundation.Diagnostics.FileLoggingSession.prototype.name;
 /** @type {function(?): void} */
Windows.Foundation.Diagnostics.FileLoggingSession.prototype.onlogfilegenerated;

/**
 * Adds a logging channel to the current logging session. The logging channel only accepts events that have a logging level at or above the specified logging level.
 * Adds a logging channel to the current logging session.
 * @param {!Windows.Foundation.Diagnostics.ILoggingChannel} loggingChannel The logging channel to add.
 * @param {Windows.Foundation.Diagnostics.LoggingLevel=} maxLevel The minimum logging level that an event must have to be accepted by the session.
 * @return {void}
 */
Windows.Foundation.Diagnostics.FileLoggingSession.prototype.addLoggingChannel = function(loggingChannel, maxLevel) {};

/**
 * Ends the current logging session.
 * @return {void}
 */
Windows.Foundation.Diagnostics.FileLoggingSession.prototype.close = function() {};

/**
 * Ends the current logging session and saves it to a file.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns the new file as a StorageFile . Returns NULL if there are no events in the session or if logging has just rolled over into a new file that doesn't contain events yet.
 */
Windows.Foundation.Diagnostics.FileLoggingSession.prototype.closeAndSaveToFileAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Foundation.Diagnostics.FileLoggingSession.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Foundation.Diagnostics.FileLoggingSession.prototype.removeEventListener = function(type, listener) {};

/**
 * Removes the specified logging channel from the current logging session.
 * @param {!Windows.Foundation.Diagnostics.ILoggingChannel} loggingChannel The logging channel to remove.
 * @return {void}
 */
Windows.Foundation.Diagnostics.FileLoggingSession.prototype.removeLoggingChannel = function(loggingChannel) {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Diagnostics.LogFileGeneratedEventArgs = function() {};
 /** @type {!Windows.Storage.StorageFile} */
Windows.Foundation.Diagnostics.LogFileGeneratedEventArgs.prototype.file;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the LoggingActivity class for the specified LoggingChannel and LoggingLevel in Windows 8.1 compatibility mode.
 * Initializes a new instance of the LoggingActivity class for the specified LoggingChannel in Windows 8.1 compatibility mode.
 * @param {string} activityName The name of the logging activity.
 * @param {!Windows.Foundation.Diagnostics.ILoggingChannel} loggingChannel The logging channel.
 * @param {Windows.Foundation.Diagnostics.LoggingLevel=} level The logging level.
 */
Windows.Foundation.Diagnostics.LoggingActivity = function(activityName, loggingChannel, level) {};
 /** @type {!Windows.Foundation.Diagnostics.LoggingChannel} */
Windows.Foundation.Diagnostics.LoggingActivity.prototype.channel;
 /** @type {string} */
Windows.Foundation.Diagnostics.LoggingActivity.prototype.id;
 /** @type {string} */
Windows.Foundation.Diagnostics.LoggingActivity.prototype.name;

/**
 * Ends the current logging activity.
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingActivity.prototype.close = function() {};

/**
 * Indicates whether at least one session is listening for events with the specified level and keywords from the channel associated with this activity.
 * Indicates whether at least one session is listening for events from the channel associated with this activity.
 * Indicates whether at least one session is listening for events with the specified event severity level from the channel associated with this activity.
 * @param {Windows.Foundation.Diagnostics.LoggingLevel=} level The event severity level.
 * @param {number=} keywords The keywords. Each bit of the keywords value represents an event category.
 * @return {boolean} Returns true if at least one session is listening for events with the specified level and keywords from the channel associated with this activity, and otherwise false. / Returns true if at least one session is listening for events from the channel associated with this activity, and otherwise false. / Returns true if at least one session is listening for events with the specified level from the channel associated with this activity, and otherwise false.
 */
Windows.Foundation.Diagnostics.LoggingActivity.prototype.isEnabled = function(level, keywords) {};

/**
 * Logs an event with the specified name.
 * Logs an event with the specified name, fields, and level.
 * Logs an event with the specified name and fields.
 * Logs an event with the specified name, fields, level, and options.
 * @param {string} eventName The name for this event.
 * @param {!Windows.Foundation.Diagnostics.LoggingFields=} fields The fields for this event. May be null.
 * @param {Windows.Foundation.Diagnostics.LoggingLevel=} level The severity level for this event.
 * @param {!Windows.Foundation.Diagnostics.LoggingOptions=} options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingActivity.prototype.logEvent = function(eventName, fields, level, options) {};

/**
 * Writes an activity start event with the specified fields and level and creates a LoggingActivity object.
 * Writes an activity start event and creates a LoggingActivity object.
 * Writes an activity start event with fields and creates a LoggingActivity object.
 * Writes an activity start event with the specified fields, level, and options, and creates a LoggingActivity object.
 * @param {string} startEventName The name for the start event. / The name for this event.
 * @param {!Windows.Foundation.Diagnostics.LoggingFields=} fields The fields for this event. May be null . / The fields for this event. / The fields for this event. May be null.
 * @param {Windows.Foundation.Diagnostics.LoggingLevel=} level The level of detail for this event.
 * @param {!Windows.Foundation.Diagnostics.LoggingOptions=} options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
 * @return {!Windows.Foundation.Diagnostics.LoggingActivity} An object that represents the new activity. / An object the represents the new activity.
 */
Windows.Foundation.Diagnostics.LoggingActivity.prototype.startActivity = function(startEventName, fields, level, options) {};

/**
 * Marks the activity as closed/disposed and generates a stop event with the specified event name, fields, and options.
 * Marks the activity as closed/disposed and generates a stop event with the specified event name.
 * Marks the activity as closed/disposed and generates a stop event with the specified event name and fields.
 * @param {string} stopEventName The name for the stop event. / The name for this event.
 * @param {!Windows.Foundation.Diagnostics.LoggingFields=} fields The fields for this event. May be null.
 * @param {!Windows.Foundation.Diagnostics.LoggingOptions=} options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingActivity.prototype.stopActivity = function(stopEventName, fields, options) {};

/**
 * @constructor
 * @struct
 * This constructor creates a LoggingChannel in Windows 8.1 compatibility mode.
 * Initializes a new instance of the LoggingChannel class with the specified options.
 * Initializes a new instance of the LoggingChannel class with the specified options and channel ID.
 * @param {string} name The name of the logging channel.
 * @param {!Windows.Foundation.Diagnostics.LoggingChannelOptions=} options The channel options. Pass null to specify the default options.
 * @param {string=} id The channel identifier to use instead of the automatically generated identifier.
 */
Windows.Foundation.Diagnostics.LoggingChannel = function(name, options, id) {};
 /** @type {boolean} */
Windows.Foundation.Diagnostics.LoggingChannel.prototype.enabled;
 /** @type {string} */
Windows.Foundation.Diagnostics.LoggingChannel.prototype.id;
 /** @type {Windows.Foundation.Diagnostics.LoggingLevel} */
Windows.Foundation.Diagnostics.LoggingChannel.prototype.level;
 /** @type {string} */
Windows.Foundation.Diagnostics.LoggingChannel.prototype.name;
 /** @type {function(?): void} */
Windows.Foundation.Diagnostics.LoggingChannel.prototype.onloggingenabled;

/**
 * Ends logging on the current logging channel.
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingChannel.prototype.close = function() {};

/**
 * Indicates whether at least one session is listening for events with the specified level and keywords from this channel.
 * Indicates whether at least one session is listening for events from the channel.
 * Indicates whether at least one session is listening for events with the specified event severity level from the channel.
 * @param {Windows.Foundation.Diagnostics.LoggingLevel=} level The event severity level.
 * @param {number=} keywords The keywords. Each bit of the keywords value represents an event category.
 * @return {boolean} Returns true if at least one session is listening for events with the specified level and keywords from the channel, and otherwise false. / Returns true if at least one session is listening for events from the channel, and otherwise false. / Returns true if at least one session is listening for events with the specified level from the channel, and otherwise false.
 */
Windows.Foundation.Diagnostics.LoggingChannel.prototype.isEnabled = function(level, keywords) {};

/**
 * Logs an event with the specified name.
 * Logs an event with the specified name, fields, and level.
 * Logs an event with the specified name and fields.
 * Logs an event with the specified name, fields, level, and options.
 * @param {string} eventName The name for this event.
 * @param {!Windows.Foundation.Diagnostics.LoggingFields=} fields The fields for this event. May be null.
 * @param {Windows.Foundation.Diagnostics.LoggingLevel=} level The level of detail for this event.
 * @param {!Windows.Foundation.Diagnostics.LoggingOptions=} options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingChannel.prototype.logEvent = function(eventName, fields, level, options) {};

/**
 * Logs a message to the current LoggingChannel .
 * Logs a message to the current LoggingChannel with the specified LoggingLevel .
 * @param {string} eventString The message to log.
 * @param {Windows.Foundation.Diagnostics.LoggingLevel=} level The logging level.
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingChannel.prototype.logMessage = function(eventString, level) {};

/**
 * Logs data to the current LoggingChannel with the specified LoggingLevel .
 * Logs data to the current LoggingChannel .
 * @param {string} value1 The string to associate with value2.
 * @param {number} value2 The value to associate with value1.
 * @param {Windows.Foundation.Diagnostics.LoggingLevel=} level The logging level.
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingChannel.prototype.logValuePair = function(value1, value2, level) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingChannel.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingChannel.prototype.removeEventListener = function(type, listener) {};

/**
 * Writes an activity start event with the specified fields and level, and creates a LoggingActivity object.
 * Writes an activity start event and creates a LoggingActivity object.
 * Writes an activity start event with the specified fields and creates a LoggingActivity object.
 * Writes an activity start event with the specified fields, level, and options, and creates a LoggingActivity object.
 * @param {string} startEventName The name for this event.
 * @param {!Windows.Foundation.Diagnostics.LoggingFields=} fields The fields for this event. May be null . / The fields for this event. / The fields for this event. May be null.
 * @param {Windows.Foundation.Diagnostics.LoggingLevel=} level The level of detail for this event.
 * @param {!Windows.Foundation.Diagnostics.LoggingOptions=} options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
 * @return {!Windows.Foundation.Diagnostics.LoggingActivity} Returns an object that represents the new activity.
 */
Windows.Foundation.Diagnostics.LoggingChannel.prototype.startActivity = function(startEventName, fields, level, options) {};

/**
 * @constructor
 * @struct
 * Creates a LoggingChannelOptions object with all options set to default values.
 * Creates a LoggingChannelOptions object with all properties set to default values except for the specified group.
 * @param {string=} group The group identifier.
 */
Windows.Foundation.Diagnostics.LoggingChannelOptions = function(group) {};
 /** @type {string} */
Windows.Foundation.Diagnostics.LoggingChannelOptions.prototype.group;

/** @const */
Windows.Foundation.Diagnostics.LoggingFieldFormat = {};
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.default;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.hidden;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.string;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.boolean;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.hexadecimal;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.processId;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.threadId;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.port;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.ipv4Address;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.ipv6Address;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.socketAddress;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.xml;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.json;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.win32Error;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.ntStatus;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.hresult;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.fileTime;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.signed;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingFieldFormat.unsigned;

/**
 * @constructor
 * @struct
 * Initializes a new LoggingFields instance.
 */
Windows.Foundation.Diagnostics.LoggingFields = function() {};

/**
 * Adds a boolean field with the specified field name, format, and tags.
 * Adds a boolean field with the specified field name and format.
 * Adds a boolean field with the specified field name.
 * @param {string} name The name of the event field. / Name of the event field.
 * @param {boolean} value The value of the event field. / Value of the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addBoolean = function(name, value, format, tags) {};

/**
 * Adds a boolean array field with the specified field name.
 * Adds a boolean array field with the specified field name and format.
 * Adds a boolean array field with the specified field name, format, and tag.
 * @param {string} name The name of the event field.
 * @param {!Array<boolean>} value The array values for the event field. / The array of values for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addBooleanArray = function(name, value, format, tags) {};

/**
 * Adds a 16-bit character field with the specified field name.
 * Adds a 16-bit character field with the specified field name and format.
 * Adds a 16-bit character field with the specified field name, format, and tag.
 * @param {string} name The name of the event field.
 * @param {string} value The value of the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addChar16 = function(name, value, format, tags) {};

/**
 * Adds a 16-bit character array field with the specified field name.
 * Adds a 16-bit character array field with the specified field name and format, and tags.
 * Adds a 16-bit character array field with the specified field name and format.
 * @param {string} name The name of the event field.
 * @param {!Array<string>} value The array of values for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addChar16Array = function(name, value, format, tags) {};

/**
 * Adds a DateTime field with the specified field name.
 * Adds a DateTime field with the specified field name, format, and tags.
 * Adds a DateTime field with the specified field name and format.
 * @param {string} name The name of the event field.
 * @param {!Date} value The value of the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addDateTime = function(name, value, format, tags) {};

/**
 * Adds a DateTime array field with the specified field name, format, and tags.
 * Adds a DateTime array field with the specified field name and format.
 * Adds a DateTime array field with the specified field name.
 * @param {string} name The name of the event field.
 * @param {!Array<!Date>} value The array of values for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addDateTimeArray = function(name, value, format, tags) {};

/**
 * Adds a Double field with the specified field name, format, and tags.
 * Adds a Double field with the specified field name and format.
 * Adds a Double field with the specified field name.
 * @param {string} name Name of the event field.
 * @param {number} value Value of the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addDouble = function(name, value, format, tags) {};

/**
 * Adds a Double array field with the specified field name, format, and tags.
 * Adds a Double array field with the specified field name and format.
 * Adds a Double array field with the specified field name.
 * @param {string} name Name of the event field.
 * @param {!Float64Array} value The array of values for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addDoubleArray = function(name, value, format, tags) {};

/**
 * Adds an empty field.
 * Adds an empty field.
 * Adds an empty field.
 * @param {string} name Name of the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addEmpty = function(name, format, tags) {};

/**
 * Adds a GUID field with the specified field name, format, and tags.
 * Adds a GUID field with the specified field name and format.
 * Adds a GUID field with the specified field name.
 * @param {string} name Name of the event field.
 * @param {string} value Value of the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addGuid = function(name, value, format, tags) {};

/**
 * Adds a GUID array field with the specified field name, format, and tags.
 * Adds a GUID array field with the specified field name and format
 * Adds a GUID array field with the specified field name.
 * @param {string} name Name of the event field.
 * @param {!Array<string>} value The array values for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools. / The format of the event field.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addGuidArray = function(name, value, format, tags) {};

/**
 * Adds a 16-bit integer field with the specified field name and format.
 * Adds a 16-bit integer field with the specified field name, format, and tags.
 * Adds a 16-bit integer field with the specified field name.
 * @param {string} name Name of the event field.
 * @param {number} value Value of the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addInt16 = function(name, value, format, tags) {};

/**
 * Adds a 16-bit integer array field with the specified field name.
 * Adds a 16-bit integer array field with the specified field name and format.
 * Adds a 16-bit integer array field with the specified field name, format, and tags.
 * @param {string} name Name of the event field.
 * @param {!Int16Array} value Value of the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addInt16Array = function(name, value, format, tags) {};

/**
 * Adds a 32-bit integer array field with the specified field name, format, and tags.
 * Adds a 32-bit integer array field with the specified field name and format.
 * Adds a 32-bit integer array field with the specified field name.
 * @param {string} name Name of the event field.
 * @param {number} value The array values for the event field. / Value of the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addInt32 = function(name, value, format, tags) {};

/**
 * Adds a 32-bit integer array field with the specified field name and format.
 * Adds a 32-bit integer array field with the specified field name, format, and tags.
 * Adds a 32-bit integer array field with the specified field name.
 * @param {string} name Name of the event field.
 * @param {!Int32Array} value The array values for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addInt32Array = function(name, value, format, tags) {};

/**
 * Adds a 64-bit integer array field with the specified field name and format.
 * Adds a 64-bit integer field with the specified field name, format, and tags.
 * Adds a 64-bit integer array field with the specified field name.
 * @param {string} name Name of the event field.
 * @param {number} value The array values for the event field. / The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addInt64 = function(name, value, format, tags) {};

/**
 * Adds a 64-bit integer array field with the specified field name, format, and tags.
 * Adds a 64-bit integer array field with the specified field name and format.
 * Adds a 64-bit integer array field with the specified field name.
 * @param {string} name Name of the event field.
 * @param {!Array<number>} value The array values for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addInt64Array = function(name, value, format, tags) {};

/**
 * Adds a Point field with the specified name.
 * Adds a Point field with the specified name and format.
 * Adds a Point field with the specified name, format, and tags.
 * @param {string} name Name of the event field.
 * @param {!Windows.Foundation.Point} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addPoint = function(name, value, format, tags) {};

/**
 * Adds a Point array field with the specified field name and format.
 * Adds a Point array field with the specified field name, format, and tags.
 * Adds a Point array field with the specified field name.
 * @param {string} name Name of the event field.
 * @param {!Windows.Foundation.Point} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addPointArray = function(name, value, format, tags) {};

/**
 * Adds a Rect field with the specified field name, format, and tags.
 * Adds a Rect field with the specified field name, and format.
 * Adds a Rect field with the specified field name.
 * @param {string} name Name of the event field.
 * @param {!Windows.Foundation.Rect} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addRect = function(name, value, format, tags) {};

/**
 * Adds a Rect array field with the specified field name.
 * Adds a Rect array field with the specified field name and format.
 * Adds a Rect array field with the specified field name, format, and tags.
 * @param {string} name Name of the event field.
 * @param {!Windows.Foundation.Rect} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The value for the event field. / The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addRectArray = function(name, value, format, tags) {};

/**
 * Adds a Single field with the specified field name and format.
 * Adds a Single field with the specified field name, format, and tags.
 * Adds a Single field with the specified field name.
 * @param {string} name Name of the event field.
 * @param {number} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addSingle = function(name, value, format, tags) {};

/**
 * Adds a Single array field with the specified field name.
 * Adds a Single array field with the specified field name and format.
 * Adds a Single array field with the specified field name, format, and tags.
 * @param {string} name Name of the event field.
 * @param {!Float32Array} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addSingleArray = function(name, value, format, tags) {};

/**
 * Adds a Size field with the specified field name.
 * Adds a Size field with the specified field name and format.
 * Adds a Size field with the specified field name, format, and tags.
 * @param {string} name Name of the event field.
 * @param {!Windows.Foundation.Size} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addSize = function(name, value, format, tags) {};

/**
 * Adds a Size array field with the specified field name, format, and tags.
 * Adds a Size array field with the specified field name.
 * Adds a Size array field with the specified field name and format.
 * @param {string} name Name of the event field. / The name of the field.
 * @param {!Windows.Foundation.Size} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addSizeArray = function(name, value, format, tags) {};

/**
 * Adds a String field with the specified field name.
 * Adds a String field with the specified field name, format, and tags.
 * Adds a String field with the specified field name and format.
 * @param {string} name Name of the event field.
 * @param {string} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addString = function(name, value, format, tags) {};

/**
 * Adds a String array field with the specified field name and format.
 * Adds a String array field with the specified field name, format, and tags.
 * Adds a String array field with the specified field name.
 * @param {string} name Name of the event field.
 * @param {!Array<string>} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addStringArray = function(name, value, format, tags) {};

/**
 * Adds a time span field with the specified field name and format.
 * Adds a time span field with the specified field name, format, and tags.
 * Adds a time span field with the specified field name.
 * @param {string} name Name of the event field.
 * @param {number} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addTimeSpan = function(name, value, format, tags) {};

/**
 * Adds a time span array field with the specified field name.
 * Adds a time span array field with the specified field name and format.
 * Adds a time span array field with the specified field name, format, and tags.
 * @param {string} name Name of the event field.
 * @param {!Array<number>} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addTimeSpanArray = function(name, value, format, tags) {};

/**
 * Adds a 16-bit unsigned integer field with the specified field name, format, and tags.
 * Adds a 16-bit unsigned integer field with the specified field name.
 * Adds a 16-bit unsigned integer field with the specified field name and format.
 * @param {string} name Name of the event field.
 * @param {number} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addUInt16 = function(name, value, format, tags) {};

/**
 * Adds a16-bit unsigned integer field with the specified field name.
 * Adds a 16-bit unsigned integer array field with the specified field name, format, and tags.
 * Adds a 16-bit unsigned integer array field with the specified field name and format.
 * @param {string} name Name of the event field.
 * @param {!Uint16Array} value The value for the event field. The default format for the array is binary. See the remarks section for other formats that may be specified.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addUInt16Array = function(name, value, format, tags) {};

/**
 * Adds a 32-bit unsigned integer field with the specified field name.
 * Adds a 32-bit unsigned integer field with the specified field name, format, and tags.
 * Adds a 32-bit unsigned integer field with the specified field name and format.
 * @param {string} name Name of the event field.
 * @param {number} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addUInt32 = function(name, value, format, tags) {};

/**
 * Adds a 32-bit unsigned integer array field with the specified field name.
 * Adds a 32-bit unsigned integer array field with the specified field name, format, and tags.
 * Adds a 32-bit unsigned integer array field with the specified field name and format.
 * @param {string} name Name of the event field.
 * @param {!Uint32Array} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addUInt32Array = function(name, value, format, tags) {};

/**
 * Adds a 64-bit unsigned integer field with the specified field name and format.
 * Adds a 64-bit unsigned integer field with the specified field name.
 * Adds a 64-bit unsigned integer field with the specified field name, format, and tags.
 * @param {string} name Name of the event field.
 * @param {number} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addUInt64 = function(name, value, format, tags) {};

/**
 * Adds a 64-bit unsigned integer array field with the specified field name.
 * Adds a 64-bit unsigned integer array field with the specified field name, format, and tags.
 * Adds a 64-bit unsigned integer array field with the specified field name and format.
 * @param {string} name Name of the event field.
 * @param {!Array<number>} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addUInt64Array = function(name, value, format, tags) {};

/**
 * Adds an 8-bit unsigned integer field with the specified field name.
 * Adds an 8-bit unsigned integer field with the specified field name, format, and tags.
 * Adds an 8-bit unsigned integer field with the specified field name and format.
 * @param {string} name Name of the event field.
 * @param {number} value The value for the event field.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addUInt8 = function(name, value, format, tags) {};

/**
 * Adds an 8-bit unsigned integer array field with the specified field name.
 * Adds an 8-bit unsigned integer array field with the specified field name and format.
 * Adds an 8-bit unsigned integer array field with the specified field name, format, and tags.
 * @param {string} name Name of the event field.
 * @param {!Array<number>} value The value for the event field. The format for the array is binary. / The value for the event field. The default format for the array is binary. See the remarks section for other formats that may be specified.
 * @param {Windows.Foundation.Diagnostics.LoggingFieldFormat=} format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
 * @param {number=} tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.addUInt8Array = function(name, value, format, tags) {};

/**
 * Begins a new structured field with the specified field name.
 * Begins a new structured field with the specified field name and tags.
 * @param {string} name Name of the structured field.
 * @param {number=} tags Specifies up to twenty-eight bits of user-defined field metadata. The top four bits are reserved and must be set to zero (0).
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.beginStruct = function(name, tags) {};

/**
 * Removes all fields stored in the object and resets the object to its newly-constructed state.
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.clear = function() {};

/**
 * Ends a structured field.
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingFields.prototype.endStruct = function() {};

/** @const */
Windows.Foundation.Diagnostics.LoggingLevel = {};
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingLevel.verbose;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingLevel.information;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingLevel.warning;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingLevel.error;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingLevel.critical;

/** @const */
Windows.Foundation.Diagnostics.LoggingOpcode = {};
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingOpcode.info;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingOpcode.start;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingOpcode.stop;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingOpcode.reply;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingOpcode.resume;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingOpcode.suspend;
/** @const {number} */
Windows.Foundation.Diagnostics.LoggingOpcode.send;

/**
 * @constructor
 * @struct
 * Initializes a new LoggingOptions instance with default option values.
 * Initializes a new LoggingOptions instance with the specified keyword value.
 * @param {number=} keywords The keyword value.
 */
Windows.Foundation.Diagnostics.LoggingOptions = function(keywords) {};
 /** @type {string} */
Windows.Foundation.Diagnostics.LoggingOptions.prototype.activityId;
 /** @type {number} */
Windows.Foundation.Diagnostics.LoggingOptions.prototype.keywords;
 /** @type {Windows.Foundation.Diagnostics.LoggingOpcode} */
Windows.Foundation.Diagnostics.LoggingOptions.prototype.opcode;
 /** @type {string} */
Windows.Foundation.Diagnostics.LoggingOptions.prototype.relatedActivityId;
 /** @type {number} */
Windows.Foundation.Diagnostics.LoggingOptions.prototype.tags;
 /** @type {number} */
Windows.Foundation.Diagnostics.LoggingOptions.prototype.task;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the LoggingSession class.
 * @param {string} name The name of the logging session.
 */
Windows.Foundation.Diagnostics.LoggingSession = function(name) {};
 /** @type {string} */
Windows.Foundation.Diagnostics.LoggingSession.prototype.name;

/**
 * Adds a logging channel with the specified logging level to the current logging session.
 * Adds a logging channel to the current logging session.
 * @param {!Windows.Foundation.Diagnostics.ILoggingChannel} loggingChannel The logging channel to add.
 * @param {Windows.Foundation.Diagnostics.LoggingLevel=} maxLevel The logging level for loggingChannel.
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingSession.prototype.addLoggingChannel = function(loggingChannel, maxLevel) {};

/**
 * Ends the current logging session.
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingSession.prototype.close = function() {};

/**
 * Removes the specified logging channel from the current logging session.
 * @param {!Windows.Foundation.Diagnostics.ILoggingChannel} loggingChannel The logging channel to remove.
 * @return {void}
 */
Windows.Foundation.Diagnostics.LoggingSession.prototype.removeLoggingChannel = function(loggingChannel) {};

/**
 * Saves the current logging session to a file.
 * @param {!Windows.Storage.IStorageFolder} folder The folder that contains the log file.
 * @param {string} fileName The name of the log file.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns the new file as a StorageFile .
 */
Windows.Foundation.Diagnostics.LoggingSession.prototype.saveToFileAsync = function(folder, fileName) {};

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the RuntimeBrokerErrorSettings .
 */
Windows.Foundation.Diagnostics.RuntimeBrokerErrorSettings = function() {};

/**
 * Gets the type of error reporting for the error object.
 * @return {Windows.Foundation.Diagnostics.ErrorOptions} One of the enumeration values.
 */
Windows.Foundation.Diagnostics.RuntimeBrokerErrorSettings.prototype.getErrorOptions = function() {};

/**
 * Sets the type of error reporting for the error object.
 * @param {Windows.Foundation.Diagnostics.ErrorOptions} value One of the enumeration values.
 * @return {void}
 */
Windows.Foundation.Diagnostics.RuntimeBrokerErrorSettings.prototype.setErrorOptions = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Diagnostics.TracingStatusChangedEventArgs = function() {};
 /** @type {boolean} */
Windows.Foundation.Diagnostics.TracingStatusChangedEventArgs.prototype.enabled;
 /** @type {Windows.Foundation.Diagnostics.CausalityTraceLevel} */
Windows.Foundation.Diagnostics.TracingStatusChangedEventArgs.prototype.traceLevel;
/**
 * @extends {Windows.Foundation.IClosable}
 * @record
 * @struct
 */
Windows.Foundation.Diagnostics.ILoggingChannel = function() {};
 /** @type {boolean} */
Windows.Foundation.Diagnostics.ILoggingChannel.prototype.enabled;
 /** @type {Windows.Foundation.Diagnostics.LoggingLevel} */
Windows.Foundation.Diagnostics.ILoggingChannel.prototype.level;
 /** @type {string} */
Windows.Foundation.Diagnostics.ILoggingChannel.prototype.name;

/**
 * Logs a message to the current LoggingChannel .
 * Logs a message to the current LoggingChannel with the specified LoggingLevel .
 * @param {string} eventString The message to log.
 * @param {Windows.Foundation.Diagnostics.LoggingLevel=} level The logging level.
 * @return {void}
 */
Windows.Foundation.Diagnostics.ILoggingChannel.prototype.logMessage = function(eventString, level) {};

/**
 * Logs data to the current LoggingChannel with the specified LoggingLevel .
 * Logs data to the current LoggingChannel .
 * @param {string} value1 The string to associate with value2.
 * @param {number} value2 The value to associate with value1.
 * @param {Windows.Foundation.Diagnostics.LoggingLevel=} level The logging level.
 * @return {void}
 */
Windows.Foundation.Diagnostics.ILoggingChannel.prototype.logValuePair = function(value1, value2, level) {};
/**
 * @extends {Windows.Foundation.IClosable}
 * @record
 * @struct
 */
Windows.Foundation.Diagnostics.IFileLoggingSession = function() {};
 /** @type {string} */
Windows.Foundation.Diagnostics.IFileLoggingSession.prototype.name;

/**
 * Adds a logging channel with the specified logging level to the current logging session.
 * Adds a logging channel to the current logging session.
 * @param {!Windows.Foundation.Diagnostics.ILoggingChannel} loggingChannel The logging channel to add.
 * @param {Windows.Foundation.Diagnostics.LoggingLevel=} maxLevel The logging level for loggingChannel.
 * @return {void}
 */
Windows.Foundation.Diagnostics.IFileLoggingSession.prototype.addLoggingChannel = function(loggingChannel, maxLevel) {};

/**
 * Ends the current logging session and saves it to a file.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns the new file as a StorageFile .
 */
Windows.Foundation.Diagnostics.IFileLoggingSession.prototype.closeAndSaveToFileAsync = function() {};

/**
 * Removes the specified logging channel from the current logging session.
 * @param {!Windows.Foundation.Diagnostics.ILoggingChannel} loggingChannel The logging channel to remove.
 * @return {void}
 */
Windows.Foundation.Diagnostics.IFileLoggingSession.prototype.removeLoggingChannel = function(loggingChannel) {};

/**
 * @constructor
 * @struct
 * Initializes a new MemoryBuffer instance with the specified capacity.
 * @param {number} capacity The desired size of the new memory buffer.
 */
Windows.Foundation.MemoryBuffer = function(capacity) {};

/**
 * Disconnects this MemoryBuffer object from the actual memory buffer.
 * @return {void}
 */
Windows.Foundation.MemoryBuffer.prototype.close = function() {};

/**
 * Returns a new managed object that implements the IMemoryBufferReference interface.
 * @return {!Windows.Foundation.IMemoryBufferReference} A new managed object that implements the IMemoryBufferReference interface.
 */
Windows.Foundation.MemoryBuffer.prototype.createReference = function() {};
/** @const */
Windows.Foundation.Metadata = {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.ActivatableAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.AllowForWebAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.AllowMultipleAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.ApiContractAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.ApiInformation = function() {};

/**
 * Returns true or false to indicate whether the API contract with the specified name and major version number is present.
 * Returns true or false to indicate whether the API contract with the specified name and major and minor version number is present.
 * @param {string} contractName The name of the API contract.
 * @param {number} majorVersion The major version number of the API contract.
 * @param {number=} minorVersion The minor version number of the API contract.
 * @return {boolean} True if the specified API contract is present; otherwise, false.
 */
Windows.Foundation.Metadata.ApiInformation.isApiContractPresent = function(contractName, majorVersion, minorVersion) {};

/**
 * Returns true or false to indicate whether a specified named constant is present for a specified enumeration.
 * @param {string} enumTypeName The namespace-qualified name of the type.
 * @param {string} valueName The name of the constant.
 * @return {boolean} True if the specified constant is present; otherwise, false.
 */
Windows.Foundation.Metadata.ApiInformation.isEnumNamedValuePresent = function(enumTypeName, valueName) {};

/**
 * Returns true or false to indicate whether a specified event is present for a specified type.
 * @param {string} typeName The namespace-qualified name of the type.
 * @param {string} eventName The name of the event.
 * @return {boolean} True if the specified event is present for the type; otherwise, false.
 */
Windows.Foundation.Metadata.ApiInformation.isEventPresent = function(typeName, eventName) {};

/**
 * Returns true or false to indicate whether a specified method is present for a specified type.
 * Returns true or false to indicate whether a specified method overload with the specified number of input parameters is present for a specified type.
 * @param {string} typeName The namespace-qualified name of the type.
 * @param {string} methodName The name of the method.
 * @param {number=} inputParameterCount The number of input parameters for the overload.
 * @return {boolean} True if the specified method is present for the type; otherwise, false.
 */
Windows.Foundation.Metadata.ApiInformation.isMethodPresent = function(typeName, methodName, inputParameterCount) {};

/**
 * Returns true or false to indicate whether a specified property (writeable or read-only) is present for a specified type.
 * @param {string} typeName The namespace-qualified name of the type.
 * @param {string} propertyName The name of the property.
 * @return {boolean} True if the specified property is present for the type; otherwise, false.
 */
Windows.Foundation.Metadata.ApiInformation.isPropertyPresent = function(typeName, propertyName) {};

/**
 * Returns true or false to indicate whether a specified read-only property is present for a specified type.
 * @param {string} typeName The namespace-qualified name of the type.
 * @param {string} propertyName The name of the property.
 * @return {boolean} True if the specified property is present for the type; otherwise, false.
 */
Windows.Foundation.Metadata.ApiInformation.isReadOnlyPropertyPresent = function(typeName, propertyName) {};

/**
 * Returns true or false to indicate whether a specified type is present.
 * @param {string} typeName The namespace-qualified name of the type.
 * @return {boolean} True if the specified type is present; otherwise, false.
 */
Windows.Foundation.Metadata.ApiInformation.isTypePresent = function(typeName) {};

/**
 * Returns true or false to indicate whether a specified writeable property is present for a specified type.
 * @param {string} typeName The namespace-qualified name of the type.
 * @param {string} propertyName The name of the property.
 * @return {boolean} True if the specified property is present for the type; otherwise, false.
 */
Windows.Foundation.Metadata.ApiInformation.isWriteablePropertyPresent = function(typeName, propertyName) {};

/** @const */
Windows.Foundation.Metadata.AttributeTargets = {};
/** @const {number} */
Windows.Foundation.Metadata.AttributeTargets.all;
/** @const {number} */
Windows.Foundation.Metadata.AttributeTargets.delegate;
/** @const {number} */
Windows.Foundation.Metadata.AttributeTargets.enum;
/** @const {number} */
Windows.Foundation.Metadata.AttributeTargets.event;
/** @const {number} */
Windows.Foundation.Metadata.AttributeTargets.field;
/** @const {number} */
Windows.Foundation.Metadata.AttributeTargets.interface;
/** @const {number} */
Windows.Foundation.Metadata.AttributeTargets.method;
/** @const {number} */
Windows.Foundation.Metadata.AttributeTargets.parameter;
/** @const {number} */
Windows.Foundation.Metadata.AttributeTargets.property;
/** @const {number} */
Windows.Foundation.Metadata.AttributeTargets.runtimeClass;
/** @const {number} */
Windows.Foundation.Metadata.AttributeTargets.struct;
/** @const {number} */
Windows.Foundation.Metadata.AttributeTargets.interfaceImpl;
/** @const {number} */
Windows.Foundation.Metadata.AttributeTargets.apiContract;
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.AttributeUsageAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.ComposableAttribute = function() {};

/** @const */
Windows.Foundation.Metadata.CompositionType = {};
/** @const {number} */
Windows.Foundation.Metadata.CompositionType.protected;
/** @const {number} */
Windows.Foundation.Metadata.CompositionType.public;
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.ContractVersionAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.DefaultAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.DefaultOverloadAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.DeprecatedAttribute = function() {};

/** @const */
Windows.Foundation.Metadata.DeprecationType = {};
/** @const {number} */
Windows.Foundation.Metadata.DeprecationType.deprecate;
/** @const {number} */
Windows.Foundation.Metadata.DeprecationType.remove;
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.DualApiPartitionAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.ExclusiveToAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.ExperimentalAttribute = function() {};

/** @const */
Windows.Foundation.Metadata.GCPressureAmount = {};
/** @const {number} */
Windows.Foundation.Metadata.GCPressureAmount.low;
/** @const {number} */
Windows.Foundation.Metadata.GCPressureAmount.medium;
/** @const {number} */
Windows.Foundation.Metadata.GCPressureAmount.high;
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.GCPressureAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.GuidAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.HasVariantAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.InternalAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.LengthIsAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.MarshalingBehaviorAttribute = function() {};

/** @const */
Windows.Foundation.Metadata.MarshalingType = {};
/** @const {number} */
Windows.Foundation.Metadata.MarshalingType.none;
/** @const {number} */
Windows.Foundation.Metadata.MarshalingType.agile;
/** @const {number} */
Windows.Foundation.Metadata.MarshalingType.standard;
/** @const {number} */
Windows.Foundation.Metadata.MarshalingType.invalidMarshaling;
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.MetadataMarshalAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.MuseAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.OverloadAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.OverridableAttribute = function() {};

/** @const */
Windows.Foundation.Metadata.Platform = {};
/** @const {number} */
Windows.Foundation.Metadata.Platform.windows;
/** @const {number} */
Windows.Foundation.Metadata.Platform.windowsPhone;
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.PlatformAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.PreviousContractVersionAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.ProtectedAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.RangeAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.RemoteAsyncAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.StaticAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.ThreadingAttribute = function() {};

/** @const */
Windows.Foundation.Metadata.ThreadingModel = {};
/** @const {number} */
Windows.Foundation.Metadata.ThreadingModel.sta;
/** @const {number} */
Windows.Foundation.Metadata.ThreadingModel.mta;
/** @const {number} */
Windows.Foundation.Metadata.ThreadingModel.both;
/** @const {number} */
Windows.Foundation.Metadata.ThreadingModel.invalidThreading;
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.VariantAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.VersionAttribute = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.Metadata.WebHostHiddenAttribute = function() {};
/** @const */
Windows.Foundation.Numerics = {};
/**
 * @record
 * @struct
 */
Windows.Foundation.Numerics.Matrix4x4 = function() {};
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m11;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m12;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m13;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m14;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m21;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m22;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m23;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m24;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m31;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m32;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m33;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m34;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m41;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m42;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m43;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix4x4.prototype.m44;
/**
 * @record
 * @struct
 */
Windows.Foundation.Numerics.Vector3 = function() {};
 /** @type {number} */
Windows.Foundation.Numerics.Vector3.prototype.x;
 /** @type {number} */
Windows.Foundation.Numerics.Vector3.prototype.y;
 /** @type {number} */
Windows.Foundation.Numerics.Vector3.prototype.z;
/**
 * @record
 * @struct
 */
Windows.Foundation.Numerics.Quaternion = function() {};
 /** @type {number} */
Windows.Foundation.Numerics.Quaternion.prototype.w;
 /** @type {number} */
Windows.Foundation.Numerics.Quaternion.prototype.x;
 /** @type {number} */
Windows.Foundation.Numerics.Quaternion.prototype.y;
 /** @type {number} */
Windows.Foundation.Numerics.Quaternion.prototype.z;
/**
 * @record
 * @struct
 */
Windows.Foundation.Numerics.Vector2 = function() {};
 /** @type {number} */
Windows.Foundation.Numerics.Vector2.prototype.x;
 /** @type {number} */
Windows.Foundation.Numerics.Vector2.prototype.y;
/**
 * @record
 * @struct
 */
Windows.Foundation.Numerics.Matrix3x2 = function() {};
 /** @type {number} */
Windows.Foundation.Numerics.Matrix3x2.prototype.m11;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix3x2.prototype.m12;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix3x2.prototype.m21;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix3x2.prototype.m22;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix3x2.prototype.m31;
 /** @type {number} */
Windows.Foundation.Numerics.Matrix3x2.prototype.m32;

/** @const */
Windows.Foundation.PropertyType = {};
/** @const {number} */
Windows.Foundation.PropertyType.empty;
/** @const {number} */
Windows.Foundation.PropertyType.uint8;
/** @const {number} */
Windows.Foundation.PropertyType.int16;
/** @const {number} */
Windows.Foundation.PropertyType.uint16;
/** @const {number} */
Windows.Foundation.PropertyType.int32;
/** @const {number} */
Windows.Foundation.PropertyType.uint32;
/** @const {number} */
Windows.Foundation.PropertyType.int64;
/** @const {number} */
Windows.Foundation.PropertyType.uint64;
/** @const {number} */
Windows.Foundation.PropertyType.single;
/** @const {number} */
Windows.Foundation.PropertyType.double;
/** @const {number} */
Windows.Foundation.PropertyType.char16;
/** @const {number} */
Windows.Foundation.PropertyType.boolean;
/** @const {number} */
Windows.Foundation.PropertyType.string;
/** @const {number} */
Windows.Foundation.PropertyType.inspectable;
/** @const {number} */
Windows.Foundation.PropertyType.dateTime;
/** @const {number} */
Windows.Foundation.PropertyType.timeSpan;
/** @const {number} */
Windows.Foundation.PropertyType.guid;
/** @const {number} */
Windows.Foundation.PropertyType.point;
/** @const {number} */
Windows.Foundation.PropertyType.size;
/** @const {number} */
Windows.Foundation.PropertyType.rect;
/** @const {number} */
Windows.Foundation.PropertyType.otherType;
/** @const {number} */
Windows.Foundation.PropertyType.uint8Array;
/** @const {number} */
Windows.Foundation.PropertyType.int16Array;
/** @const {number} */
Windows.Foundation.PropertyType.uint16Array;
/** @const {number} */
Windows.Foundation.PropertyType.int32Array;
/** @const {number} */
Windows.Foundation.PropertyType.uint32Array;
/** @const {number} */
Windows.Foundation.PropertyType.int64Array;
/** @const {number} */
Windows.Foundation.PropertyType.uint64Array;
/** @const {number} */
Windows.Foundation.PropertyType.singleArray;
/** @const {number} */
Windows.Foundation.PropertyType.doubleArray;
/** @const {number} */
Windows.Foundation.PropertyType.char16Array;
/** @const {number} */
Windows.Foundation.PropertyType.booleanArray;
/** @const {number} */
Windows.Foundation.PropertyType.stringArray;
/** @const {number} */
Windows.Foundation.PropertyType.inspectableArray;
/** @const {number} */
Windows.Foundation.PropertyType.dateTimeArray;
/** @const {number} */
Windows.Foundation.PropertyType.timeSpanArray;
/** @const {number} */
Windows.Foundation.PropertyType.guidArray;
/** @const {number} */
Windows.Foundation.PropertyType.pointArray;
/** @const {number} */
Windows.Foundation.PropertyType.sizeArray;
/** @const {number} */
Windows.Foundation.PropertyType.rectArray;
/** @const {number} */
Windows.Foundation.PropertyType.otherTypeArray;

/**
 * @constructor
 * @struct
 * Initializes a new Uri by combining a base Uniform Resource Identifier (URI) and a relative URI. Initializing the Uri also parses the combined string and populates the Uri properties that represent URI components.
 * Initializes a new Uri object from the specified Uniform Resource Identifier (URI) string. Initializing the Uri also parses the string and populates the Uri properties that represent URI components.
 * @param {string} baseUri_or_uri The base URI. / The string from which the new Uri object is created.
 * @param {string=} relativeUri The relative URI.
 */
Windows.Foundation.Uri = function(baseUri_or_uri, relativeUri) {};
 /** @type {string} */
Windows.Foundation.Uri.prototype.absoluteCanonicalUri;
 /** @type {string} */
Windows.Foundation.Uri.prototype.absoluteUri;
 /** @type {string} */
Windows.Foundation.Uri.prototype.displayIri;
 /** @type {string} */
Windows.Foundation.Uri.prototype.displayUri;
 /** @type {string} */
Windows.Foundation.Uri.prototype.domain;
 /** @type {string} */
Windows.Foundation.Uri.prototype.extension;
 /** @type {string} */
Windows.Foundation.Uri.prototype.fragment;
 /** @type {string} */
Windows.Foundation.Uri.prototype.host;
 /** @type {string} */
Windows.Foundation.Uri.prototype.password;
 /** @type {string} */
Windows.Foundation.Uri.prototype.path;
 /** @type {number} */
Windows.Foundation.Uri.prototype.port;
 /** @type {string} */
Windows.Foundation.Uri.prototype.query;
 /** @type {!Windows.Foundation.WwwFormUrlDecoder} */
Windows.Foundation.Uri.prototype.queryParsed;
 /** @type {string} */
Windows.Foundation.Uri.prototype.rawUri;
 /** @type {string} */
Windows.Foundation.Uri.prototype.schemeName;
 /** @type {boolean} */
Windows.Foundation.Uri.prototype.suspicious;
 /** @type {string} */
Windows.Foundation.Uri.prototype.userName;

/**
 * Converts a Uniform Resource Identifier (URI) string to its escaped representation.
 * @param {string} toEscape The string to convert.
 * @return {string} The escaped representation of toEscape.
 */
Windows.Foundation.Uri.escapeComponent = function(toEscape) {};

/**
 * Converts the specified string by replacing any escape sequences with their unescaped representation.
 * @param {string} toUnescape The string to convert.
 * @return {string} The unescaped representation of stringToUnescape.
 */
Windows.Foundation.Uri.unescapeComponent = function(toUnescape) {};

/**
 * Adds the specified Uniform Resource Identifier (URI) to the current Uri .
 * @param {string} relativeUri A relative URI specified as a string. This relative path is evaluated using the host/authority of the Uri instance where this method is called.
 * @return {!Windows.Foundation.Uri} The combined Uri value.
 */
Windows.Foundation.Uri.prototype.combineUri = function(relativeUri) {};

/**
 * Determines whether the specified Uri object is equal to the current Uri object.
 * @param {!Windows.Foundation.Uri} pUri The Uri object to be compared.
 * @return {boolean} true if the two Uri values are the same; otherwise, false.
 */
Windows.Foundation.Uri.prototype.equals = function(pUri) {};

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the WwwFormUrlDecoder class.
 * @param {string} query The URL to parse.
 */
Windows.Foundation.WwwFormUrlDecoder = function(query) {};
 /** @type {number} */
Windows.Foundation.WwwFormUrlDecoder.prototype.size;

/**
 * Gets an iterator that represents the first name-value pair in the current URL query string.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.IWwwFormUrlDecoderEntry>} The first name-value pair.
 */
Windows.Foundation.WwwFormUrlDecoder.prototype.first = function() {};

/**
 * Gets the name-value pair at the specified index in the current URL query string.
 * @param {number} index The index of the name-value pair.
 * @return {!Windows.Foundation.IWwwFormUrlDecoderEntry} The name-value pair at the position specified by index.
 */
Windows.Foundation.WwwFormUrlDecoder.prototype.getAt = function(index) {};

/**
 * Gets the first name-value pair that has the specified name, as obtained from the constructing Uniform Resource Identifier (URI) query string.
 * @param {string} name The name of the value to get.
 * @return {string} The first value in list order that corresponds with name.
 */
Windows.Foundation.WwwFormUrlDecoder.prototype.getFirstValueByName = function(name) {};

/**
 * Gets name-value pairs starting at the specified index in the current URL query string.
 * @param {number} startIndex The index to start getting name-value pairs at.
 * @return {{items: !Windows.Foundation.IWwwFormUrlDecoderEntry, returnValue: number}}
 */
Windows.Foundation.WwwFormUrlDecoder.prototype.getMany = function(startIndex) {};

/**
 * Gets a value indicating whether the specified IWwwFormUrlDecoderEntry is at the specified index in the current URL query string.
 * @param {!Windows.Foundation.IWwwFormUrlDecoderEntry} value_or_searchElement The name-value pair to get the index of.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Foundation.WwwFormUrlDecoder.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};
/**
 * @constructor
 * @struct
 */
Windows.Foundation.WwwFormUrlDecoderEntry = function() {};
 /** @type {string} */
Windows.Foundation.WwwFormUrlDecoderEntry.prototype.name;
 /** @type {string} */
Windows.Foundation.WwwFormUrlDecoderEntry.prototype.value;

/** @typedef {function(?): void} */
Windows.Foundation.EventHandler;
/**
 * @record
 * @struct
 */
Windows.Foundation.Rect = function() {};
 /** @type {number} */
Windows.Foundation.Rect.prototype.height;
 /** @type {number} */
Windows.Foundation.Rect.prototype.width;
 /** @type {number} */
Windows.Foundation.Rect.prototype.x;
 /** @type {number} */
Windows.Foundation.Rect.prototype.y;

/** @typedef {function(?): void} */
Windows.Foundation.TypedEventHandler;
/**
 * @record
 * @struct
 */
Windows.Foundation.Size = function() {};
 /** @type {number} */
Windows.Foundation.Size.prototype.height;
 /** @type {number} */
Windows.Foundation.Size.prototype.width;
/**
 * @extends {Windows.Foundation.IAsyncInfo}
 * @record
 * @struct
 */
Windows.Foundation.IAsyncOperation = function() {};
 /** @type {function(!Windows.Foundation.IAsyncOperation, Windows.Foundation.AsyncStatus): void} */
Windows.Foundation.IAsyncOperation.prototype.completed;

/**
 * Returns the results of the operation.
 * @return {TResult} The results of the operation.
 */
Windows.Foundation.IAsyncOperation.prototype.getResults = function() {};
/**
 * @extends {Windows.Foundation.IAsyncInfo}
 * @record
 * @struct
 */
Windows.Foundation.IAsyncAction = function() {};
 /** @type {function(!Windows.Foundation.IAsyncAction, Windows.Foundation.AsyncStatus): void} */
Windows.Foundation.IAsyncAction.prototype.completed;

/**
 * Returns the results of the action.
 * @return {void}
 */
Windows.Foundation.IAsyncAction.prototype.getResults = function() {};
/**
 * @extends {Windows.Foundation.IAsyncInfo}
 * @record
 * @struct
 */
Windows.Foundation.IAsyncOperationWithProgress = function() {};
 /** @type {function(!Windows.Foundation.IAsyncOperationWithProgress, Windows.Foundation.AsyncStatus): void} */
Windows.Foundation.IAsyncOperationWithProgress.prototype.completed;
 /** @type {function(!Windows.Foundation.IAsyncOperationWithProgress, TProgress): void} */
Windows.Foundation.IAsyncOperationWithProgress.prototype.progress;

/**
 * Returns the results of the operation.
 * @return {TResult} The results of the operation.
 */
Windows.Foundation.IAsyncOperationWithProgress.prototype.getResults = function() {};
/**
 * @record
 * @struct
 */
Windows.Foundation.Point = function() {};
 /** @type {number} */
Windows.Foundation.Point.prototype.x;
 /** @type {number} */
Windows.Foundation.Point.prototype.y;
/**
 * @extends {Windows.Foundation.IClosable}
 * @record
 * @struct
 */
Windows.Foundation.IMemoryBuffer = function() {};

/**
 * Returns a new managed object that implements the IMemoryBufferReference interface.
 * @return {!Windows.Foundation.IMemoryBufferReference} A new managed object that implements the IMemoryBufferReference interface.
 */
Windows.Foundation.IMemoryBuffer.prototype.createReference = function() {};

/** @typedef {function(!Windows.Foundation.IAsyncAction, Windows.Foundation.AsyncStatus): void} */
Windows.Foundation.AsyncActionCompletedHandler;

/** @typedef {function(!Windows.Foundation.IAsyncOperation<TResult>, Windows.Foundation.AsyncStatus): void} */
Windows.Foundation.AsyncOperationCompletedHandler;

/** @typedef {function(!Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>, Windows.Foundation.AsyncStatus): void} */
Windows.Foundation.AsyncOperationWithProgressCompletedHandler;

/** @typedef {function(!Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>, TProgress): void} */
Windows.Foundation.AsyncOperationProgressHandler;

/** @typedef {function(): void} */
Windows.Foundation.DeferralCompletedHandler;
/**
 * @extends {Windows.Foundation.IClosable}
 * @record
 * @struct
 */
Windows.Foundation.IMemoryBufferReference = function() {};
 /** @type {number} */
Windows.Foundation.IMemoryBufferReference.prototype.capacity;
/**
 * @record
 * @struct
 */
Windows.Foundation.IWwwFormUrlDecoderEntry = function() {};
 /** @type {string} */
Windows.Foundation.IWwwFormUrlDecoderEntry.prototype.name;
 /** @type {string} */
Windows.Foundation.IWwwFormUrlDecoderEntry.prototype.value;
/**
 * @extends {Windows.Foundation.IAsyncInfo}
 * @record
 * @struct
 */
Windows.Foundation.IAsyncActionWithProgress = function() {};
 /** @type {function(!Windows.Foundation.IAsyncActionWithProgress, Windows.Foundation.AsyncStatus): void} */
Windows.Foundation.IAsyncActionWithProgress.prototype.completed;
 /** @type {function(!Windows.Foundation.IAsyncActionWithProgress, TProgress): void} */
Windows.Foundation.IAsyncActionWithProgress.prototype.progress;

/**
 * Returns the results of the action.
 * @return {void}
 */
Windows.Foundation.IAsyncActionWithProgress.prototype.getResults = function() {};
/**
 * @record
 * @struct
 */
Windows.Foundation.IAsyncInfo = function() {};
 /** @type {!Windows.WinRTError} */
Windows.Foundation.IAsyncInfo.prototype.errorCode;
 /** @type {number} */
Windows.Foundation.IAsyncInfo.prototype.id;
 /** @type {Windows.Foundation.AsyncStatus} */
Windows.Foundation.IAsyncInfo.prototype.status;

/**
 * Cancels the asynchronous operation.
 * @return {void}
 */
Windows.Foundation.IAsyncInfo.prototype.cancel = function() {};

/**
 * Closes the asynchronous operation.
 * @return {void}
 */
Windows.Foundation.IAsyncInfo.prototype.close = function() {};
/**
 * @record
 * @struct
 */
Windows.Foundation.IClosable = function() {};

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 * @return {void}
 */
Windows.Foundation.IClosable.prototype.close = function() {};

/** @typedef {function(!Windows.Foundation.IAsyncActionWithProgress<TProgress>, Windows.Foundation.AsyncStatus): void} */
Windows.Foundation.AsyncActionWithProgressCompletedHandler;

/** @typedef {function(!Windows.Foundation.IAsyncActionWithProgress<TProgress>, TProgress): void} */
Windows.Foundation.AsyncActionProgressHandler;
/**
 * @record
 * @struct
 */
Windows.Foundation.IStringable = function() {};

/**
 * Gets a string that represents the current object.
 * @return {string} A string that represents the current object.
 */
Windows.Foundation.IStringable.prototype.toString = function() {};
/** @const */
Windows.Gaming = {};
/** @const */
Windows.Gaming.Input = {};
/**
 * @constructor
 * @struct
 */
Windows.Gaming.Input.Gamepad = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Gaming.Input.Gamepad>} */
Windows.Gaming.Input.Gamepad.gamepads;
 /** @type {function(?): void} */
Windows.Gaming.Input.Gamepad.ongamepadadded;
 /** @type {function(?): void} */
Windows.Gaming.Input.Gamepad.ongamepadremoved;
 /** @type {!Windows.Gaming.Input.Headset} */
Windows.Gaming.Input.Gamepad.prototype.headset;
 /** @type {boolean} */
Windows.Gaming.Input.Gamepad.prototype.isWireless;
 /** @type {function(?): void} */
Windows.Gaming.Input.Gamepad.prototype.onheadsetconnected;
 /** @type {function(?): void} */
Windows.Gaming.Input.Gamepad.prototype.onheadsetdisconnected;
 /** @type {function(?): void} */
Windows.Gaming.Input.Gamepad.prototype.onuserchanged;
 /** @type {!Windows.System.User} */
Windows.Gaming.Input.Gamepad.prototype.user;
 /** @type {!Windows.Gaming.Input.GamepadVibration} */
Windows.Gaming.Input.Gamepad.prototype.vibration;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Gaming.Input.Gamepad.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Gaming.Input.Gamepad.removeEventListener = function(type, listener) {};

/**
 * Gets a snapshot of the gamepad state.
 * @return {!Windows.Gaming.Input.GamepadReading} Returns a GamepadReading containing the current state of the gamepad.
 */
Windows.Gaming.Input.Gamepad.prototype.getCurrentReading = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Gaming.Input.Gamepad.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Gaming.Input.Gamepad.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Gaming.Input.GamepadButtons = {};
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.none;
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.menu;
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.view;
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.a;
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.b;
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.x;
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.y;
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.dpadUp;
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.dpadDown;
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.dpadLeft;
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.dpadRight;
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.leftShoulder;
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.rightShoulder;
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.leftThumbstick;
/** @const {number} */
Windows.Gaming.Input.GamepadButtons.rightThumbstick;
/**
 * @constructor
 * @struct
 */
Windows.Gaming.Input.Headset = function() {};
 /** @type {string} */
Windows.Gaming.Input.Headset.prototype.captureDeviceId;
 /** @type {string} */
Windows.Gaming.Input.Headset.prototype.renderDeviceId;
/**
 * @record
 * @struct
 */
Windows.Gaming.Input.GamepadReading = function() {};
 /** @type {Windows.Gaming.Input.GamepadButtons} */
Windows.Gaming.Input.GamepadReading.prototype.buttons;
 /** @type {number} */
Windows.Gaming.Input.GamepadReading.prototype.leftThumbstickX;
 /** @type {number} */
Windows.Gaming.Input.GamepadReading.prototype.leftThumbstickY;
 /** @type {number} */
Windows.Gaming.Input.GamepadReading.prototype.leftTrigger;
 /** @type {number} */
Windows.Gaming.Input.GamepadReading.prototype.rightThumbstickX;
 /** @type {number} */
Windows.Gaming.Input.GamepadReading.prototype.rightThumbstickY;
 /** @type {number} */
Windows.Gaming.Input.GamepadReading.prototype.rightTrigger;
 /** @type {number} */
Windows.Gaming.Input.GamepadReading.prototype.timestamp;
/**
 * @record
 * @struct
 */
Windows.Gaming.Input.IGameController = function() {};
 /** @type {!Windows.Gaming.Input.Headset} */
Windows.Gaming.Input.IGameController.prototype.headset;
 /** @type {boolean} */
Windows.Gaming.Input.IGameController.prototype.isWireless;
 /** @type {!Windows.System.User} */
Windows.Gaming.Input.IGameController.prototype.user;
/**
 * @record
 * @struct
 */
Windows.Gaming.Input.GamepadVibration = function() {};
 /** @type {number} */
Windows.Gaming.Input.GamepadVibration.prototype.leftMotor;
 /** @type {number} */
Windows.Gaming.Input.GamepadVibration.prototype.leftTrigger;
 /** @type {number} */
Windows.Gaming.Input.GamepadVibration.prototype.rightMotor;
 /** @type {number} */
Windows.Gaming.Input.GamepadVibration.prototype.rightTrigger;
/** @const */
Windows.Gaming.Preview = {};
/** @const */
Windows.Gaming.Preview.GamesEnumeration = {};
/**
 * @constructor
 * @struct
 */
Windows.Gaming.Preview.GamesEnumeration.GameList = function() {};
 /** @type {?} */
Windows.Gaming.Preview.GamesEnumeration.GameList.addEventListener;
 /** @type {?} */
Windows.Gaming.Preview.GamesEnumeration.GameList.findAllAsync;
 /** @type {?} */
Windows.Gaming.Preview.GamesEnumeration.GameList.ongameadded;
 /** @type {?} */
Windows.Gaming.Preview.GamesEnumeration.GameList.ongameremoved;
 /** @type {?} */
Windows.Gaming.Preview.GamesEnumeration.GameList.ongameupdated;
 /** @type {?} */
Windows.Gaming.Preview.GamesEnumeration.GameList.removeEventListener;
/** @const */
Windows.Gaming.Preview.GamesEnumeration.GameListCategory = {};
 /** @type {?} */
Windows.Gaming.Preview.GamesEnumeration.GameListCategory.candidate;
 /** @type {?} */
Windows.Gaming.Preview.GamesEnumeration.GameListCategory.confirmedBySystem;
 /** @type {?} */
Windows.Gaming.Preview.GamesEnumeration.GameListCategory.confirmedByUser;
/**
 * @constructor
 * @struct
 */
Windows.Gaming.Preview.GamesEnumeration.GameListEntry = function() {};
 /** @type {?} */
Windows.Gaming.Preview.GamesEnumeration.GameListEntry.prototype.category;
 /** @type {?} */
Windows.Gaming.Preview.GamesEnumeration.GameListEntry.prototype.displayInfo;
 /** @type {?} */
Windows.Gaming.Preview.GamesEnumeration.GameListEntry.prototype.launchAsync;
 /** @type {?} */
Windows.Gaming.Preview.GamesEnumeration.GameListEntry.prototype.properties;
 /** @type {?} */
Windows.Gaming.Preview.GamesEnumeration.GameListEntry.prototype.setCategoryAsync;
/** @const */
Windows.Gaming.UI = {};
/**
 * @constructor
 * @struct
 */
Windows.Gaming.UI.GameBar = function() {};
 /** @type {?} */
Windows.Gaming.UI.GameBar.addEventListener;
 /** @type {?} */
Windows.Gaming.UI.GameBar.isInputRedirected;
 /** @type {?} */
Windows.Gaming.UI.GameBar.onisinputredirectedchanged;
 /** @type {?} */
Windows.Gaming.UI.GameBar.onvisibilitychanged;
 /** @type {?} */
Windows.Gaming.UI.GameBar.removeEventListener;
 /** @type {?} */
Windows.Gaming.UI.GameBar.visible;
/** @const */
Windows.Gaming.XboxLive = {};
/** @const */
Windows.Gaming.XboxLive.Storage = {};
/**
 * @constructor
 * @struct
 */
Windows.Gaming.XboxLive.Storage.GameSaveBlobGetResult = function() {};
 /** @type {Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus} */
Windows.Gaming.XboxLive.Storage.GameSaveBlobGetResult.prototype.status;
 /** @type {!Windows.Foundation.Collections.IMapView<string, !Windows.Storage.Streams.IBuffer>} */
Windows.Gaming.XboxLive.Storage.GameSaveBlobGetResult.prototype.value;
/**
 * @constructor
 * @struct
 */
Windows.Gaming.XboxLive.Storage.GameSaveBlobInfo = function() {};
 /** @type {string} */
Windows.Gaming.XboxLive.Storage.GameSaveBlobInfo.prototype.name;
 /** @type {number} */
Windows.Gaming.XboxLive.Storage.GameSaveBlobInfo.prototype.size;
/**
 * @constructor
 * @struct
 */
Windows.Gaming.XboxLive.Storage.GameSaveBlobInfoGetResult = function() {};
 /** @type {Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus} */
Windows.Gaming.XboxLive.Storage.GameSaveBlobInfoGetResult.prototype.status;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Gaming.XboxLive.Storage.GameSaveBlobInfo>} */
Windows.Gaming.XboxLive.Storage.GameSaveBlobInfoGetResult.prototype.value;
/**
 * @constructor
 * @struct
 */
Windows.Gaming.XboxLive.Storage.GameSaveBlobInfoQuery = function() {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {number=} startIndex This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {number=} maxNumberOfItems This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Gaming.XboxLive.Storage.GameSaveBlobInfoGetResult, !Windows.Foundation.IAsyncOperation<!Windows.Gaming.XboxLive.Storage.GameSaveBlobInfoGetResult>>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveBlobInfoQuery.prototype.getBlobInfoAsync = function(startIndex, maxNumberOfItems) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveBlobInfoQuery.prototype.getItemCountAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Gaming.XboxLive.Storage.GameSaveContainer = function() {};
 /** @type {string} */
Windows.Gaming.XboxLive.Storage.GameSaveContainer.prototype.name;
 /** @type {!Windows.Gaming.XboxLive.Storage.GameSaveProvider} */
Windows.Gaming.XboxLive.Storage.GameSaveContainer.prototype.provider;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {string} blobNamePrefix This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Gaming.XboxLive.Storage.GameSaveBlobInfoQuery} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveContainer.prototype.createBlobInfoQuery = function(blobNamePrefix) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Foundation.Collections.IIterable<string>} blobsToRead This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Gaming.XboxLive.Storage.GameSaveBlobGetResult, !Windows.Foundation.IAsyncOperation<!Windows.Gaming.XboxLive.Storage.GameSaveBlobGetResult>>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveContainer.prototype.getAsync = function(blobsToRead) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Foundation.Collections.IMapView<string, !Windows.Storage.Streams.IBuffer>} blobsToRead This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Gaming.XboxLive.Storage.GameSaveOperationResult, !Windows.Foundation.IAsyncOperation<!Windows.Gaming.XboxLive.Storage.GameSaveOperationResult>>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveContainer.prototype.readAsync = function(blobsToRead) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Foundation.Collections.IPropertySet} blobsToWrite This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Foundation.Collections.IIterable<string>} blobsToDelete This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {string} displayName This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Gaming.XboxLive.Storage.GameSaveOperationResult, !Windows.Foundation.IAsyncOperation<!Windows.Gaming.XboxLive.Storage.GameSaveOperationResult>>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveContainer.prototype.submitPropertySetUpdatesAsync = function(blobsToWrite, blobsToDelete, displayName) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Foundation.Collections.IMapView<string, !Windows.Storage.Streams.IBuffer>} blobsToWrite This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Foundation.Collections.IIterable<string>} blobsToDelete This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {string} displayName This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Gaming.XboxLive.Storage.GameSaveOperationResult, !Windows.Foundation.IAsyncOperation<!Windows.Gaming.XboxLive.Storage.GameSaveOperationResult>>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveContainer.prototype.submitUpdatesAsync = function(blobsToWrite, blobsToDelete, displayName) {};
/**
 * @constructor
 * @struct
 */
Windows.Gaming.XboxLive.Storage.GameSaveContainerInfo = function() {};
 /** @type {string} */
Windows.Gaming.XboxLive.Storage.GameSaveContainerInfo.prototype.displayName;
 /** @type {!Date} */
Windows.Gaming.XboxLive.Storage.GameSaveContainerInfo.prototype.lastModifiedTime;
 /** @type {string} */
Windows.Gaming.XboxLive.Storage.GameSaveContainerInfo.prototype.name;
 /** @type {boolean} */
Windows.Gaming.XboxLive.Storage.GameSaveContainerInfo.prototype.needsSync;
 /** @type {number} */
Windows.Gaming.XboxLive.Storage.GameSaveContainerInfo.prototype.totalSize;
/**
 * @constructor
 * @struct
 */
Windows.Gaming.XboxLive.Storage.GameSaveContainerInfoGetResult = function() {};
 /** @type {Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus} */
Windows.Gaming.XboxLive.Storage.GameSaveContainerInfoGetResult.prototype.status;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Gaming.XboxLive.Storage.GameSaveContainerInfo>} */
Windows.Gaming.XboxLive.Storage.GameSaveContainerInfoGetResult.prototype.value;
/**
 * @constructor
 * @struct
 */
Windows.Gaming.XboxLive.Storage.GameSaveContainerInfoQuery = function() {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {number=} startIndex This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {number=} maxNumberOfItems This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Gaming.XboxLive.Storage.GameSaveContainerInfoGetResult, !Windows.Foundation.IAsyncOperation<!Windows.Gaming.XboxLive.Storage.GameSaveContainerInfoGetResult>>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveContainerInfoQuery.prototype.getContainerInfoAsync = function(startIndex, maxNumberOfItems) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveContainerInfoQuery.prototype.getItemCountAsync = function() {};

/** @const */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus = {};
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.ok;
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.abort;
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.invalidContainerName;
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.noAccess;
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.outOfLocalStorage;
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.userCanceled;
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.updateTooBig;
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.quotaExceeded;
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.providedBufferTooSmall;
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.blobNotFound;
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.noXboxLiveInfo;
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.containerNotInSync;
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.containerSyncFailed;
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.userHasNoXboxLiveInfo;
/** @const {number} */
Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus.objectExpired;
/**
 * @constructor
 * @struct
 */
Windows.Gaming.XboxLive.Storage.GameSaveOperationResult = function() {};
 /** @type {Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus} */
Windows.Gaming.XboxLive.Storage.GameSaveOperationResult.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Gaming.XboxLive.Storage.GameSaveProvider = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Gaming.XboxLive.Storage.GameSaveProvider.prototype.containersChangedSinceLastSync;
 /** @type {!Windows.System.User} */
Windows.Gaming.XboxLive.Storage.GameSaveProvider.prototype.user;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.System.User} user This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {string} serviceConfigId This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Gaming.XboxLive.Storage.GameSaveProviderGetResult, !Windows.Foundation.IAsyncOperation<!Windows.Gaming.XboxLive.Storage.GameSaveProviderGetResult>>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveProvider.getForUserAsync = function(user, serviceConfigId) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.System.User} user This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {string} serviceConfigId This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Gaming.XboxLive.Storage.GameSaveProviderGetResult, !Windows.Foundation.IAsyncOperation<!Windows.Gaming.XboxLive.Storage.GameSaveProviderGetResult>>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveProvider.getSyncOnDemandForUserAsync = function(user, serviceConfigId) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {string} name This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Gaming.XboxLive.Storage.GameSaveContainer} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveProvider.prototype.createContainer = function(name) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {string=} containerNamePrefix This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Gaming.XboxLive.Storage.GameSaveContainerInfoQuery} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveProvider.prototype.createContainerInfoQuery = function(containerNamePrefix) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {string} name This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Gaming.XboxLive.Storage.GameSaveOperationResult, !Windows.Foundation.IAsyncOperation<!Windows.Gaming.XboxLive.Storage.GameSaveOperationResult>>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveProvider.prototype.deleteContainerAsync = function(name) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Gaming.XboxLive.Storage.GameSaveProvider.prototype.getRemainingBytesInQuotaAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Gaming.XboxLive.Storage.GameSaveProviderGetResult = function() {};
 /** @type {Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus} */
Windows.Gaming.XboxLive.Storage.GameSaveProviderGetResult.prototype.status;
 /** @type {!Windows.Gaming.XboxLive.Storage.GameSaveProvider} */
Windows.Gaming.XboxLive.Storage.GameSaveProviderGetResult.prototype.value;
/** @const */
Windows.Globalization = {};
/**
 * @constructor
 * @struct
 */
Windows.Globalization.ApplicationLanguages = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Globalization.ApplicationLanguages.languages;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Globalization.ApplicationLanguages.manifestLanguages;
 /** @type {string} */
Windows.Globalization.ApplicationLanguages.primaryLanguageOverride;

/**
 * @constructor
 * @struct
 * Creates a Calendar object that is initialized with a language list, calendar, and clock.
 * Creates a Calendar object that is initialized with a language list.
 * Creates a Calendar object and initializes it to the current date and time.
 * Creates a Calendar object that is initialized with a language list, calendar, clock, and time zone.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} languages The list of language identifiers, in priority order, representing the choice of languages. These are used for resolving patterns to strings. See Remarks. / The list of language identifiers, in priority order, that represents the choice of languages. These are used for resolving patterns to strings. See Remarks.
 * @param {string=} calendar The calendar identifier to use.
 * @param {string=} clock The clock identifier to use.
 * @param {string=} timeZoneId An identifier from the IANA Time Zone Database which identifies the time zone that should be used (for example, "Americas/Los_Angeles" for Pacific Time).
 */
Windows.Globalization.Calendar = function(languages, calendar, clock, timeZoneId) {};
 /** @type {number} */
Windows.Globalization.Calendar.prototype.day;
 /** @type {Windows.Globalization.DayOfWeek} */
Windows.Globalization.Calendar.prototype.dayOfWeek;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.era;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.firstDayInThisMonth;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.firstEra;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.firstHourInThisPeriod;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.firstMinuteInThisHour;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.firstMonthInThisYear;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.firstPeriodInThisDay;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.firstSecondInThisMinute;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.firstYearInThisEra;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.hour;
 /** @type {boolean} */
Windows.Globalization.Calendar.prototype.isDaylightSavingTime;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Globalization.Calendar.prototype.languages;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.lastDayInThisMonth;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.lastEra;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.lastHourInThisPeriod;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.lastMinuteInThisHour;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.lastMonthInThisYear;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.lastPeriodInThisDay;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.lastSecondInThisMinute;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.lastYearInThisEra;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.minute;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.month;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.nanosecond;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.numberOfDaysInThisMonth;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.numberOfEras;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.numberOfHoursInThisPeriod;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.numberOfMinutesInThisHour;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.numberOfMonthsInThisYear;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.numberOfPeriodsInThisDay;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.numberOfSecondsInThisMinute;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.numberOfYearsInThisEra;
 /** @type {string} */
Windows.Globalization.Calendar.prototype.numeralSystem;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.period;
 /** @type {string} */
Windows.Globalization.Calendar.prototype.resolvedLanguage;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.second;
 /** @type {number} */
Windows.Globalization.Calendar.prototype.year;

/**
 * Increments or decrements the day.
 * @param {number} days The number of days by which to increment the day (if the value is positive) or decrement the day (if the value is negative).
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.addDays = function(days) {};

/**
 * Increments or decrements the era.
 * @param {number} eras The number of eras by which to increment the era (if the value is positive) or decrement the era (if the value is negative).
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.addEras = function(eras) {};

/**
 * Increments or decrements the hour.
 * @param {number} hours The number of hours by which to increment the hour (if the value is positive) or decrement the hour (if the value is negative).
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.addHours = function(hours) {};

/**
 * Increments or decrements the minute.
 * @param {number} minutes The number of minutes by which to increment the minute (if the value is positive) or decrement the minute (if the value is negative).
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.addMinutes = function(minutes) {};

/**
 * Increments or decrements the month.
 * @param {number} months The number of months by which to increment the month (if the value is positive) or decrement the month (if the value is negative).
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.addMonths = function(months) {};

/**
 * Increments or decrements the nanosecond.
 * @param {number} nanoseconds The number of nanoseconds by which to increment the nanosecond (if the value is positive) or decrement the nanosecond (if the value is negative).
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.addNanoseconds = function(nanoseconds) {};

/**
 * Increments or decrements the period.
 * @param {number} periods The number of periods by which to increment the period (if the value is positive) or decrement the period (if the value is negative).
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.addPeriods = function(periods) {};

/**
 * Increments or decrements the second.
 * @param {number} seconds The number of seconds by which to increment the second (if the value is positive) or decrement the second (if the value is negative).
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.addSeconds = function(seconds) {};

/**
 * Increments or decrements the day by the specified number of weeks.
 * @param {number} weeks The number of weeks by which to increment the day (if the value is positive) or decrement the day (if the value is negative).
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.addWeeks = function(weeks) {};

/**
 * Increments or decrements the year.
 * @param {number} years The number of years by which to increment the year (if the value is positive) or decrement the year (if the value is negative).
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.addYears = function(years) {};

/**
 * Sets a new calendar system to be used by this Calendar object.
 * @param {string} value The calendar identifier to use.
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.changeCalendarSystem = function(value) {};

/**
 * Sets a new clock to be used by this Calendar object.
 * @param {string} value The clock identifier to use.
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.changeClock = function(value) {};

/**
 * Sets a new time zone to be used by this Calendar object.
 * @param {string} timeZoneId An identifier from the IANA Time Zone Database which identifies the time zone that should be used (for example, "Americas/Los_Angeles" for Pacific Time).
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.changeTimeZone = function(timeZoneId) {};

/**
 * Creates a copy of the Calendar object.
 * @return {!Windows.Globalization.Calendar} A copy of the Calendar .
 */
Windows.Globalization.Calendar.prototype.clone = function() {};

/**
 * Compares this calendar to another Calendar object and indicates whether the date and time of one is earlier, equal to, or later than that of the other.
 * @param {!Windows.Globalization.Calendar} other The Calendar object to compare to the current calendar.
 * @return {number} One of the following values:
 */
Windows.Globalization.Calendar.prototype.compare = function(other) {};

/**
 * Compares this calendar to a DateTime object and indicates whether the date and time of one is earlier, equal to, or later than that of the other.
 * @param {!Date} other The DateTime object to compare to the current calendar.
 * @return {number} One of the following values:
 */
Windows.Globalization.Calendar.prototype.compareDateTime = function(other) {};

/**
 * Copies the values from another Calendar object into this Calendar.
 * @param {!Windows.Globalization.Calendar} other The Calendar object to be copied.
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.copyTo = function(other) {};

/**
 * Returns a string representation of the day, optionally zero-padded.
 * @param {number} minDigits The minimum number of integer digits to be displayed. If the day does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the day 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
 * @return {string} A string representation of the day.
 */
Windows.Globalization.Calendar.prototype.dayAsPaddedString = function(minDigits) {};

/**
 * Returns a string that contains the numeric representation of the day.
 * @return {string} A string representation of the day.
 */
Windows.Globalization.Calendar.prototype.dayAsString = function() {};

/**
 * Returns a string representation of the day of the week suitable for stand-alone display.
 * Returns a string representation of the day of the week suitable for stand-alone display.
 * @param {number=} idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
 * @return {string} A string representation of the day of the week. / A string representation of the day of the week, using the most common abbreviation available.
 */
Windows.Globalization.Calendar.prototype.dayOfWeekAsSoloString = function(idealLength) {};

/**
 * Returns a string representation of the day of the week suitable for inclusion with other date components.
 * Returns a string representation of the day of the week suitable for inclusion with other date components.
 * @param {number=} idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
 * @return {string} A string representation of the day of the week. / A string representation of the day of the week, using the most common abbreviation available.
 */
Windows.Globalization.Calendar.prototype.dayOfWeekAsString = function(idealLength) {};

/**
 * Returns a string representation of the era. The string chosen is closest in length to the ideal length.
 * Returns a string representation of the era.
 * @param {number=} idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
 * @return {string} A string representation of the era. / A string representation of the era, using the most common abbreviation available.
 */
Windows.Globalization.Calendar.prototype.eraAsString = function(idealLength) {};

/**
 * Gets the calendar system that is used by this Calendar object.
 * @return {string} The identifier of the calendar system.
 */
Windows.Globalization.Calendar.prototype.getCalendarSystem = function() {};

/**
 * Gets the clock that is used by this Calendar object.
 * @return {string} The identifier of the clock.
 */
Windows.Globalization.Calendar.prototype.getClock = function() {};

/**
 * Builds a date and time, given the components of this Calendar object.
 * @return {!Date} The DateTime representing the date and time of this Calendar .
 */
Windows.Globalization.Calendar.prototype.getDateTime = function() {};

/**
 * Gets the identifier that identifies the time zone that is used by this Calendar object.
 * @return {string} The identifier from the IANA Time Zone Database that identifies the time zone that is used by this Calendar object. (An example is "Americas/Los_Angeles" for Pacific Time.)
 */
Windows.Globalization.Calendar.prototype.getTimeZone = function() {};

/**
 * Returns a string representation of the hour, optionally zero-padded.
 * @param {number} minDigits The minimum number of integer digits to be displayed. If the hour does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the hour 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
 * @return {string} A string representation of the hour.
 */
Windows.Globalization.Calendar.prototype.hourAsPaddedString = function(minDigits) {};

/**
 * Returns a string that contains the numeric representation of the hour.
 * @return {string} A string representation of the hour.
 */
Windows.Globalization.Calendar.prototype.hourAsString = function() {};

/**
 * Returns a string representation of the minute, optionally zero-padded.
 * @param {number} minDigits The minimum number of integer digits to be displayed. If the minute does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the minute 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
 * @return {string} A string representation of the minute.
 */
Windows.Globalization.Calendar.prototype.minuteAsPaddedString = function(minDigits) {};

/**
 * Returns a string that contains the numeric representation of the minute.
 * @return {string} A string representation of the minute.
 */
Windows.Globalization.Calendar.prototype.minuteAsString = function() {};

/**
 * Returns a string that contains the numeric representation of the month.
 * @return {string} A string representation of the month.
 */
Windows.Globalization.Calendar.prototype.monthAsNumericString = function() {};

/**
 * Returns a string representation of the month, optionally zero-padded.
 * @param {number} minDigits The minimum number of integer digits to be displayed. If the month does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the month 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
 * @return {string} A string representation of the month.
 */
Windows.Globalization.Calendar.prototype.monthAsPaddedNumericString = function(minDigits) {};

/**
 * Returns a string representation of the month suitable for stand-alone display.
 * Returns a string representation of the month suitable for stand-alone display.
 * @param {number=} idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
 * @return {string} A string representation of the month. / A string representation of the month, using the most common abbreviation available.
 */
Windows.Globalization.Calendar.prototype.monthAsSoloString = function(idealLength) {};

/**
 * Returns a string representation of the month suitable for inclusion with other date components.
 * Returns a string representation of the month suitable for inclusion with other date components.
 * @param {number=} idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
 * @return {string} A string representation of the month. / A string representation of the month, using the most common abbreviation available.
 */
Windows.Globalization.Calendar.prototype.monthAsString = function(idealLength) {};

/**
 * Returns a string representation of the nanosecond, optionally zero-padded.
 * @param {number} minDigits The minimum number of integer digits to be displayed. If the nanosecond does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the nanosecond 42, a parameter of 1 or 2 returns 42, and a parameter of 3 returns 042.
 * @return {string} A string representation of the nanosecond.
 */
Windows.Globalization.Calendar.prototype.nanosecondAsPaddedString = function(minDigits) {};

/**
 * Returns a string that contains the numeric representation of the nanosecond.
 * @return {string} A string representation of the nanosecond.
 */
Windows.Globalization.Calendar.prototype.nanosecondAsString = function() {};

/**
 * Returns a string representation of the day period, such as AM or PM, that uses the most common abbreviation available.
 * Returns a string representation of the day period, such as AM or PM.
 * @param {number=} idealLength A positive integer that specifies the ideal length, in characters, for the returned string; or a zero that specifies the most common abbreviation available.
 * @return {string} A string representation of the day period. / A string representation for the day period.
 */
Windows.Globalization.Calendar.prototype.periodAsString = function(idealLength) {};

/**
 * Returns a string representation of the second, optionally zero-padded.
 * @param {number} minDigits The minimum number of integer digits to be displayed. If the second does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the second 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
 * @return {string} A string representation of the second.
 */
Windows.Globalization.Calendar.prototype.secondAsPaddedString = function(minDigits) {};

/**
 * Returns a string that contains the numeric representation of the second.
 * @return {string} A string representation of the second.
 */
Windows.Globalization.Calendar.prototype.secondAsString = function() {};

/**
 * Sets all the date and time fields to the date and time represented by the DateTime parameter.
 * @param {!Date} value The DateTime that is used to set all of the date and time fields.
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.setDateTime = function(value) {};

/**
 * Sets the components of this Calendar object to the latest date and time that are supported.
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.setToMax = function() {};

/**
 * Sets the components of this Calendar object to the earliest date and time that are supported.
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.setToMin = function() {};

/**
 * Sets the components of this Calendar object to the current date and time.
 * @return {void}
 */
Windows.Globalization.Calendar.prototype.setToNow = function() {};

/**
 * Returns the full time zone name applicable at the instant of time that this Calendar object represents.
 * Returns the abbreviated time zone name applicable at the instant of time that this Calendar object represents.
 * @param {number=} idealLength The desired length of the abbreviation to be returned. Use 0 to request the abbreviation in most common use.
 * @return {string} The full time zone name. This usually differs depending on whether the time zone is observing Daylight Saving Time or not. It also may differ due to historical changes. (An example is "Americas/Los_Angeles" for Pacific Time.) / The time zone abbreviation that is closest in length to idealLength. If there is a tie, the shorter abbreviation is returned. If idealLength is 0, the abbreviation in most common use is returned. (An example is "Americas/Los_Angeles" for Pacific Time.)
 */
Windows.Globalization.Calendar.prototype.timeZoneAsString = function(idealLength) {};

/**
 * Returns a string representation of the year, optionally zero-padded.
 * @param {number} minDigits The minimum number of integer digits to be displayed. If the year does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the year 42, a parameter of 1 or 2 returns 42, and a parameter of 3 returns 042.
 * @return {string} A string representation of the year.
 */
Windows.Globalization.Calendar.prototype.yearAsPaddedString = function(minDigits) {};

/**
 * Returns a string representation of the year without any initial zero padding.
 * @return {string} A string representation of the year.
 */
Windows.Globalization.Calendar.prototype.yearAsString = function() {};

/**
 * Returns a string representation of the year, optionally truncated.
 * @param {number} remainingDigits A positive integer that represents the number of least significant digits that should be included. For example, for the year 1234, a parameter of 2 returns 34, and a parameter of 4 or larger returns 1234.
 * @return {string} A string representation of the year.
 */
Windows.Globalization.Calendar.prototype.yearAsTruncatedString = function(remainingDigits) {};
/**
 * @constructor
 * @struct
 */
Windows.Globalization.CalendarIdentifiers = function() {};
 /** @type {string} */
Windows.Globalization.CalendarIdentifiers.gregorian;
 /** @type {string} */
Windows.Globalization.CalendarIdentifiers.hebrew;
 /** @type {string} */
Windows.Globalization.CalendarIdentifiers.hijri;
 /** @type {string} */
Windows.Globalization.CalendarIdentifiers.japanese;
 /** @type {string} */
Windows.Globalization.CalendarIdentifiers.julian;
 /** @type {string} */
Windows.Globalization.CalendarIdentifiers.korean;
 /** @type {string} */
Windows.Globalization.CalendarIdentifiers.persian;
 /** @type {string} */
Windows.Globalization.CalendarIdentifiers.taiwan;
 /** @type {string} */
Windows.Globalization.CalendarIdentifiers.thai;
 /** @type {string} */
Windows.Globalization.CalendarIdentifiers.umAlQura;
/**
 * @constructor
 * @struct
 */
Windows.Globalization.ClockIdentifiers = function() {};
 /** @type {string} */
Windows.Globalization.ClockIdentifiers.twelveHour;
 /** @type {string} */
Windows.Globalization.ClockIdentifiers.twentyFourHour;
/** @const */
Windows.Globalization.Collation = {};
/**
 * @constructor
 * @struct
 */
Windows.Globalization.Collation.CharacterGrouping = function() {};
 /** @type {string} */
Windows.Globalization.Collation.CharacterGrouping.prototype.first;
 /** @type {string} */
Windows.Globalization.Collation.CharacterGrouping.prototype.label;

/**
 * @constructor
 * @struct
 * Create a CharacterGroupings object for the default collation.
 */
Windows.Globalization.Collation.CharacterGroupings = function() {};
 /** @type {number} */
Windows.Globalization.Collation.CharacterGroupings.prototype.size;

/**
 * Returns an iterator to enumerate the items in the set of character groups.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Globalization.Collation.CharacterGrouping>} The iterator. The current position of the iterator is index 0, or the end of the set of character groups if the set is empty.
 */
Windows.Globalization.Collation.CharacterGroupings.prototype.first = function() {};

/**
 * Returns the CharacterGrouping at the specified index in the set of character groups.
 * @param {number} index The zero-based index of the CharacterGrouping in the set to return.
 * @return {!Windows.Globalization.Collation.CharacterGrouping} The CharacterGrouping at the specified index.
 */
Windows.Globalization.Collation.CharacterGroupings.prototype.getAt = function(index) {};

/**
 * Returns the CharacterGrouping objects that start at the specified index in the set of character groups.
 * @param {number} startIndex The zero-based index of the start of the CharacterGrouping objects in the set to return.
 * @return {{items: !Windows.Globalization.Collation.CharacterGrouping, returnValue: number}}
 */
Windows.Globalization.Collation.CharacterGroupings.prototype.getMany = function(startIndex) {};

/**
 * Returns the index of a specified CharacterGrouping object in the set of character groups.
 * @param {!Windows.Globalization.Collation.CharacterGrouping} value_or_searchElement The CharacterGrouping object to find in the set.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Globalization.Collation.CharacterGroupings.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};

/**
 * Gets the label under which the provided text falls.
 * @param {string} text The string for which to get the label.
 * @return {string} The first character grouping label that applies to the given text.
 */
Windows.Globalization.Collation.CharacterGroupings.prototype.lookup = function(text) {};
/**
 * @constructor
 * @struct
 */
Windows.Globalization.CurrencyIdentifiers = function() {};
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.aed;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.afn;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.all;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.amd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.ang;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.aoa;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.ars;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.aud;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.awg;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.azn;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.bam;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.bbd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.bdt;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.bgn;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.bhd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.bif;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.bmd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.bnd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.bob;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.brl;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.bsd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.btn;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.bwp;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.byr;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.bzd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.cad;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.cdf;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.chf;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.clp;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.cny;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.cop;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.crc;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.cup;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.cve;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.czk;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.djf;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.dkk;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.dop;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.dzd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.egp;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.ern;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.etb;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.eur;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.fjd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.fkp;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.gbp;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.gel;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.ghs;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.gip;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.gmd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.gnf;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.gtq;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.gyd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.hkd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.hnl;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.hrk;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.htg;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.huf;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.idr;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.ils;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.inr;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.iqd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.irr;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.isk;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.jmd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.jod;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.jpy;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.kes;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.kgs;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.khr;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.kmf;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.kpw;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.krw;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.kwd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.kyd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.kzt;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.lak;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.lbp;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.lkr;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.lrd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.lsl;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.ltl;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.lvl;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.lyd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.mad;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.mdl;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.mga;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.mkd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.mmk;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.mnt;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.mop;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.mro;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.mur;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.mvr;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.mwk;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.mxn;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.myr;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.mzn;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.nad;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.ngn;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.nio;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.nok;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.npr;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.nzd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.omr;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.pab;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.pen;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.pgk;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.php;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.pkr;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.pln;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.pyg;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.qar;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.ron;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.rsd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.rub;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.rwf;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.sar;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.sbd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.scr;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.sdg;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.sek;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.sgd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.shp;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.sll;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.sos;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.srd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.std;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.syp;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.szl;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.thb;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.tjs;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.tmt;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.tnd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.top;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.try;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.ttd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.twd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.tzs;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.uah;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.ugx;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.usd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.uyu;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.uzs;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.vef;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.vnd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.vuv;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.wst;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.xaf;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.xcd;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.xof;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.xpf;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.xxx;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.yer;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.zar;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.zmw;
 /** @type {string} */
Windows.Globalization.CurrencyIdentifiers.zwl;
/** @const */
Windows.Globalization.DateTimeFormatting = {};

/**
 * @constructor
 * @struct
 * Creates a DateTimeFormatter object that is initialized with hour, minute, and second formats.
 * Creates a DateTimeFormatter object that is initialized by a format template string.
 * Creates a DateTimeFormatter object with all formats and identifiers specified.
 * Creates a DateTimeFormatter object that is initialized by a format template string, language list, geographic region, calendar, and clock.
 * Creates a DateTimeFormatter object that is initialized with year, month, day, and day of week formats.
 * Creates a DateTimeFormatter object that is initialized with year, month, day, day of week, hour, minute, and second formats, and a language list.
 * Creates a DateTimeFormatter object that is initialized by a format template string and language list.
 * @param {Windows.Globalization.DateTimeFormatting.HourFormat|string|Windows.Globalization.DateTimeFormatting.YearFormat} hourFormat_or_formatTemplate_or_yearFormat The desired hour format to include in the template. / A format template string that specifies the requested components. The order of the components is irrelevant. This can also be a format pattern. See the remarks for the DateTimeFormatter class for a list of valid format templates and format patterns. / The desired year format to include in the template. / The year format to include in the template.
 * @param {Windows.Globalization.DateTimeFormatting.MinuteFormat|Windows.Globalization.DateTimeFormatting.MonthFormat|!Windows.Foundation.Collections.IIterable<string>=} minuteFormat_or_monthFormat_or_languages The desired minute format to include in the template. / The desired month format to include in the template. / The list of language identifiers, in priority order, that represent the choice of languages. These identifiers are used for resolving the template to a pattern, and for formatting. See Remarks. / The month format to include in the template. / The list of language identifiers, in priority order, that represent the choice of languages. These identifiers are used for resolving the template to a pattern and for formatting. See Remarks.
 * @param {Windows.Globalization.DateTimeFormatting.SecondFormat|Windows.Globalization.DateTimeFormatting.DayFormat|string=} secondFormat_or_dayFormat_or_geographicRegion The desired second format to include in the template. / The desired day format to include in the template. / The identifier for the geographic region. This identifier is used for resolving the template to a pattern. / The day format to include in the template.
 * @param {Windows.Globalization.DateTimeFormatting.DayOfWeekFormat|string=} dayOfWeekFormat_or_calendar The desired day of week format to include in the template. / The calendar identifier to use. / The day of week format to include in the template.
 * @param {Windows.Globalization.DateTimeFormatting.HourFormat|string=} hourFormat_or_clock The desired hour format to include in the template. / The clock identifier to use. / The hour format to include in the template.
 * @param {Windows.Globalization.DateTimeFormatting.MinuteFormat=} minuteFormat The desired minute format to include in the template. / The minute format to include in the template.
 * @param {Windows.Globalization.DateTimeFormatting.SecondFormat=} secondFormat The desired second format to include in the template. / The second format to include in the template.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} languages The list of language identifiers, in priority order, that represent the choice of languages. These identifiers are used for resolving the template to a pattern, and for formatting. See Remarks. / The list of language identifiers, in priority order, that represent the choice of languages. These identifiers are used for resolving the template to a pattern and for formatting. See Remarks.
 * @param {string=} geographicRegion The identifier for the geographic region. This identifier is used for resolving the template to a pattern.
 * @param {string=} calendar The calendar identifier to use.
 * @param {string=} clock The clock identifier to use.
 */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter = function(hourFormat_or_formatTemplate_or_yearFormat, minuteFormat_or_monthFormat_or_languages, secondFormat_or_dayFormat_or_geographicRegion, dayOfWeekFormat_or_calendar, hourFormat_or_clock, minuteFormat, secondFormat, languages, geographicRegion, calendar, clock) {};
 /** @type {!Windows.Globalization.DateTimeFormatting.DateTimeFormatter} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.longDate;
 /** @type {!Windows.Globalization.DateTimeFormatting.DateTimeFormatter} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.longTime;
 /** @type {!Windows.Globalization.DateTimeFormatting.DateTimeFormatter} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.shortDate;
 /** @type {!Windows.Globalization.DateTimeFormatting.DateTimeFormatter} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.shortTime;
 /** @type {string} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.calendar;
 /** @type {string} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.clock;
 /** @type {string} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.geographicRegion;
 /** @type {Windows.Globalization.DateTimeFormatting.DayFormat} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.includeDay;
 /** @type {Windows.Globalization.DateTimeFormatting.DayOfWeekFormat} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.includeDayOfWeek;
 /** @type {Windows.Globalization.DateTimeFormatting.HourFormat} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.includeHour;
 /** @type {Windows.Globalization.DateTimeFormatting.MinuteFormat} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.includeMinute;
 /** @type {Windows.Globalization.DateTimeFormatting.MonthFormat} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.includeMonth;
 /** @type {Windows.Globalization.DateTimeFormatting.SecondFormat} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.includeSecond;
 /** @type {Windows.Globalization.DateTimeFormatting.YearFormat} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.includeYear;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.languages;
 /** @type {string} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.numeralSystem;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.patterns;
 /** @type {string} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.resolvedGeographicRegion;
 /** @type {string} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.resolvedLanguage;
 /** @type {string} */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.template;

/**
 * Returns a string representation of the provided date and time.
 * Returns a string that represents the given date and time in the given time zone, conforming to the template the formatter is currently using.
 * @param {!Date} value_or_datetime The date and time to be formatted.
 * @param {string=} timeZoneId An identifier from the IANA Time Zone Database which identifies the time zone that should be used (for example, "Americas/Los_Angeles" for Pacific Time).
 * @return {string} A string that represents the date and time. / A string that represents the date, time, and time zone.
 */
Windows.Globalization.DateTimeFormatting.DateTimeFormatter.prototype.format = function(value_or_datetime, timeZoneId) {};

/** @const */
Windows.Globalization.DateTimeFormatting.DayFormat = {};
/** @const {number} */
Windows.Globalization.DateTimeFormatting.DayFormat.none;
/** @const {number} */
Windows.Globalization.DateTimeFormatting.DayFormat.default;

/** @const */
Windows.Globalization.DateTimeFormatting.DayOfWeekFormat = {};
/** @const {number} */
Windows.Globalization.DateTimeFormatting.DayOfWeekFormat.none;
/** @const {number} */
Windows.Globalization.DateTimeFormatting.DayOfWeekFormat.default;
/** @const {number} */
Windows.Globalization.DateTimeFormatting.DayOfWeekFormat.abbreviated;
/** @const {number} */
Windows.Globalization.DateTimeFormatting.DayOfWeekFormat.full;

/** @const */
Windows.Globalization.DateTimeFormatting.HourFormat = {};
/** @const {number} */
Windows.Globalization.DateTimeFormatting.HourFormat.none;
/** @const {number} */
Windows.Globalization.DateTimeFormatting.HourFormat.default;

/** @const */
Windows.Globalization.DateTimeFormatting.MinuteFormat = {};
/** @const {number} */
Windows.Globalization.DateTimeFormatting.MinuteFormat.none;
/** @const {number} */
Windows.Globalization.DateTimeFormatting.MinuteFormat.default;

/** @const */
Windows.Globalization.DateTimeFormatting.MonthFormat = {};
/** @const {number} */
Windows.Globalization.DateTimeFormatting.MonthFormat.none;
/** @const {number} */
Windows.Globalization.DateTimeFormatting.MonthFormat.default;
/** @const {number} */
Windows.Globalization.DateTimeFormatting.MonthFormat.abbreviated;
/** @const {number} */
Windows.Globalization.DateTimeFormatting.MonthFormat.full;
/** @const {number} */
Windows.Globalization.DateTimeFormatting.MonthFormat.numeric;

/** @const */
Windows.Globalization.DateTimeFormatting.SecondFormat = {};
/** @const {number} */
Windows.Globalization.DateTimeFormatting.SecondFormat.none;
/** @const {number} */
Windows.Globalization.DateTimeFormatting.SecondFormat.default;

/** @const */
Windows.Globalization.DateTimeFormatting.YearFormat = {};
/** @const {number} */
Windows.Globalization.DateTimeFormatting.YearFormat.none;
/** @const {number} */
Windows.Globalization.DateTimeFormatting.YearFormat.default;
/** @const {number} */
Windows.Globalization.DateTimeFormatting.YearFormat.abbreviated;
/** @const {number} */
Windows.Globalization.DateTimeFormatting.YearFormat.full;

/** @const */
Windows.Globalization.DayOfWeek = {};
/** @const {number} */
Windows.Globalization.DayOfWeek.sunday;
/** @const {number} */
Windows.Globalization.DayOfWeek.monday;
/** @const {number} */
Windows.Globalization.DayOfWeek.tuesday;
/** @const {number} */
Windows.Globalization.DayOfWeek.wednesday;
/** @const {number} */
Windows.Globalization.DayOfWeek.thursday;
/** @const {number} */
Windows.Globalization.DayOfWeek.friday;
/** @const {number} */
Windows.Globalization.DayOfWeek.saturday;
/** @const */
Windows.Globalization.Fonts = {};
/**
 * @constructor
 * @struct
 */
Windows.Globalization.Fonts.LanguageFont = function() {};
 /** @type {string} */
Windows.Globalization.Fonts.LanguageFont.prototype.fontFamily;
 /** @type {Windows.UI.Text.FontStretch} */
Windows.Globalization.Fonts.LanguageFont.prototype.fontStretch;
 /** @type {Windows.UI.Text.FontStyle} */
Windows.Globalization.Fonts.LanguageFont.prototype.fontStyle;
 /** @type {!Windows.UI.Text.FontWeight} */
Windows.Globalization.Fonts.LanguageFont.prototype.fontWeight;
 /** @type {number} */
Windows.Globalization.Fonts.LanguageFont.prototype.scaleFactor;

/**
 * @constructor
 * @struct
 * Creates a LanguageFontGroup object for a given language or script.
 * @param {string} languageTag A BCP-47 language tag, or an ISO 15924 script identifier.
 */
Windows.Globalization.Fonts.LanguageFontGroup = function(languageTag) {};
 /** @type {!Windows.Globalization.Fonts.LanguageFont} */
Windows.Globalization.Fonts.LanguageFontGroup.prototype.documentAlternate1Font;
 /** @type {!Windows.Globalization.Fonts.LanguageFont} */
Windows.Globalization.Fonts.LanguageFontGroup.prototype.documentAlternate2Font;
 /** @type {!Windows.Globalization.Fonts.LanguageFont} */
Windows.Globalization.Fonts.LanguageFontGroup.prototype.documentHeadingFont;
 /** @type {!Windows.Globalization.Fonts.LanguageFont} */
Windows.Globalization.Fonts.LanguageFontGroup.prototype.fixedWidthTextFont;
 /** @type {!Windows.Globalization.Fonts.LanguageFont} */
Windows.Globalization.Fonts.LanguageFontGroup.prototype.modernDocumentFont;
 /** @type {!Windows.Globalization.Fonts.LanguageFont} */
Windows.Globalization.Fonts.LanguageFontGroup.prototype.traditionalDocumentFont;
 /** @type {!Windows.Globalization.Fonts.LanguageFont} */
Windows.Globalization.Fonts.LanguageFontGroup.prototype.uiCaptionFont;
 /** @type {!Windows.Globalization.Fonts.LanguageFont} */
Windows.Globalization.Fonts.LanguageFontGroup.prototype.uiHeadingFont;
 /** @type {!Windows.Globalization.Fonts.LanguageFont} */
Windows.Globalization.Fonts.LanguageFontGroup.prototype.uiNotificationHeadingFont;
 /** @type {!Windows.Globalization.Fonts.LanguageFont} */
Windows.Globalization.Fonts.LanguageFontGroup.prototype.uiTextFont;
 /** @type {!Windows.Globalization.Fonts.LanguageFont} */
Windows.Globalization.Fonts.LanguageFontGroup.prototype.uiTitleFont;

/**
 * @constructor
 * @struct
 * Creates a GeographicRegion object that defaults to the user's home region.
 * Creates a GeographicRegion object.
 * @param {string=} geographicRegionCode One of the ISO 3166-1 two-letter or three-letter codes that identify the country, or one of the three-digit UN-M49 codes that identify the geographical region.
 */
Windows.Globalization.GeographicRegion = function(geographicRegionCode) {};
 /** @type {string} */
Windows.Globalization.GeographicRegion.prototype.code;
 /** @type {string} */
Windows.Globalization.GeographicRegion.prototype.codeThreeDigit;
 /** @type {string} */
Windows.Globalization.GeographicRegion.prototype.codeThreeLetter;
 /** @type {string} */
Windows.Globalization.GeographicRegion.prototype.codeTwoLetter;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Globalization.GeographicRegion.prototype.currenciesInUse;
 /** @type {string} */
Windows.Globalization.GeographicRegion.prototype.displayName;
 /** @type {string} */
Windows.Globalization.GeographicRegion.prototype.nativeName;

/**
 * Determines whether a geographic region identifier is supported.
 * @param {string} geographicRegionCode One of the ISO 3166-1 two-letter or three-letter codes that identify the country, or one of the three-digit UN-M49 codes that identify the geographical region.
 * @return {boolean} True if the ID is known; otherwise, false. If this method returns true, an app can safely construct a region by using this region identifier. If it returns false, attempting to construct a region for the given code will throw an exception.
 */
Windows.Globalization.GeographicRegion.isSupported = function(geographicRegionCode) {};
/**
 * @constructor
 * @struct
 */
Windows.Globalization.JapanesePhoneme = function() {};
 /** @type {string} */
Windows.Globalization.JapanesePhoneme.prototype.displayText;
 /** @type {boolean} */
Windows.Globalization.JapanesePhoneme.prototype.isPhraseStart;
 /** @type {string} */
Windows.Globalization.JapanesePhoneme.prototype.yomiText;
/**
 * @constructor
 * @struct
 */
Windows.Globalization.JapanesePhoneticAnalyzer = function() {};

/**
 * Reads a Japanese string that is a combination of Kanji characters and Hiragana characters, and returns a collection of proper readings from the string with word breaks. Optionally uses the "Mono Ruby" strategy in breaking multi-Kanji words into multiple Kanji words.
 * Reads a Japanese string that is a combination of Kanji characters and Hiragana characters, and returns a collection of proper readings from the string with word breaks.
 * @param {string} input A Japanese string that is a combination of Kanji characters and Hiragana characters.
 * @param {boolean=} monoRuby Specifies the use of the word-breaking strategy "Mono Ruby".
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Globalization.JapanesePhoneme>} A collection of JapanesePhoneme objects that represent proper readings from the string with word breaks.
 */
Windows.Globalization.JapanesePhoneticAnalyzer.getWords = function(input, monoRuby) {};

/**
 * @constructor
 * @struct
 * Creates a Language object.
 * @param {string} languageTag A BCP-47 language tag. See Remarks.
 */
Windows.Globalization.Language = function(languageTag) {};
 /** @type {string} */
Windows.Globalization.Language.currentInputMethodLanguageTag;
 /** @type {string} */
Windows.Globalization.Language.prototype.displayName;
 /** @type {string} */
Windows.Globalization.Language.prototype.languageTag;
 /** @type {string} */
Windows.Globalization.Language.prototype.nativeName;
 /** @type {string} */
Windows.Globalization.Language.prototype.script;

/**
 * Determines whether a BCP-47 language tag is well-formed.
 * @param {string} languageTag A BCP-47 language tag.
 * @return {boolean} True if the language tag is well-formed as defined by BCP-47, except when the language tag can never be valid according to BCP-47. Otherwise it returns false. If this method returns true, an application can safely construct a language by using this tag. If it returns false, attempting to construct a language for the given tag will throw an exception.
 */
Windows.Globalization.Language.isWellFormed = function(languageTag) {};

/**
 * Tries to set the normalized BCP-47 language tag of this language.
 * @param {string} languageTag The normalized BCP-47 language tag.
 * @return {boolean} true if the value is successfully set, otherwise false.
 */
Windows.Globalization.Language.trySetInputMethodLanguageTag = function(languageTag) {};

/**
 * Retrieves a vector of extension subtags in the current language for the given extension identified by singleton.
 * @param {string} singleton A single-character subtag for the LanguageTag of the current language. See BCP-47 language tags, Extensions and the Extensions Registry.
 * @return {!Windows.Foundation.Collections.IVectorView<string>} The list of extension subtags identified by singleton.
 */
Windows.Globalization.Language.prototype.getExtensionSubtags = function(singleton) {};
/** @const */
Windows.Globalization.NumberFormatting = {};

/**
 * @constructor
 * @struct
 * Creates a CurrencyFormatter object initialized with a currency identifier, language list, and geographic region.
 * Creates a CurrencyFormatter object that is initialized with a currency identifier.
 * @param {string} currencyCode The currency identifier to use when formatting and parsing currency values.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} languages The list of language identifiers, in priority order, representing the choice of languages. See Remarks.
 * @param {string=} geographicRegion The identifier for the geographic region.
 */
Windows.Globalization.NumberFormatting.CurrencyFormatter = function(currencyCode, languages, geographicRegion) {};
 /** @type {string} */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.currency;
 /** @type {number} */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.fractionDigits;
 /** @type {string} */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.geographicRegion;
 /** @type {number} */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.integerDigits;
 /** @type {boolean} */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.isDecimalPointAlwaysDisplayed;
 /** @type {boolean} */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.isGrouped;
 /** @type {boolean} */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.isZeroSigned;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.languages;
 /** @type {Windows.Globalization.NumberFormatting.CurrencyFormatterMode} */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.mode;
 /** @type {!Windows.Globalization.NumberFormatting.INumberRounder} */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.numberRounder;
 /** @type {string} */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.numeralSystem;
 /** @type {string} */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.resolvedGeographicRegion;
 /** @type {string} */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.resolvedLanguage;
 /** @type {number} */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.significantDigits;

/**
 * Prepares the CurrencyFormatter object to format currency values with a specified rounding algorithm.
 * @param {Windows.Globalization.NumberFormatting.RoundingAlgorithm} roundingAlgorithm The desired rounding algorithm for the currency. This must be one of the members of RoundingAlgorithm , excluding None.
 * @return {void}
 */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.applyRoundingForCurrency = function(roundingAlgorithm) {};

/**
 * Returns a string representation of a UInt64 currency value.
 * Returns a string representation of a Double currency value.
 * Returns a string representation of an Int64 currency value.
 * @param {number} value The UInt64 currency value to be formatted. / The Double currency value to be formatted. / The Int64 currency value to be formatted.
 * @return {string} A string that represents the value.
 */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.format = function(value) {};

/**
 * Returns a string representation of a Double currency value.
 * @param {number} value The Double currency value to be formatted.
 * @return {string} A string that represents the value.
 */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.formatDouble = function(value) {};

/**
 * Returns a string representation of an Int64 currency value.
 * @param {number} value The Int64 currency value to be formatted.
 * @return {string} A string that represents the value.
 */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.formatInt = function(value) {};

/**
 * Returns a string representation of a UInt64 currency value.
 * @param {number} value The UInt64 currency value to be formatted.
 * @return {string} The UInt64 currency value to be formatted.
 */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.formatUInt = function(value) {};

/**
 * Attempts to parse a string representation of a Double currency value.
 * @param {string} text The text to be parsed.
 * @return {number} If successful, a Double that corresponds to the string representation, and otherwise null.
 */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.parseDouble = function(text) {};

/**
 * Attempts to parse a string representation of an integer currency value.
 * @param {string} text The text to be parsed.
 * @return {number} If successful, an Int64 that corresponds to the string representation, and otherwise null.
 */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.parseInt = function(text) {};

/**
 * Attempts to parse a string representation of an unsigned integer currency value.
 * @param {string} text The text to be parsed.
 * @return {number} If successful, a UInt64 that corresponds to the string representation, and otherwise null.
 */
Windows.Globalization.NumberFormatting.CurrencyFormatter.prototype.parseUInt = function(text) {};

/** @const */
Windows.Globalization.NumberFormatting.CurrencyFormatterMode = {};
/** @const {number} */
Windows.Globalization.NumberFormatting.CurrencyFormatterMode.useSymbol;
/** @const {number} */
Windows.Globalization.NumberFormatting.CurrencyFormatterMode.useCurrencyCode;

/**
 * @constructor
 * @struct
 * Creates a DecimalFormatter object and initializes it to default values.
 * Creates a DecimalFormatter object initialized by a language list and a geographic region.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} languages The list of language identifiers, in priority order, representing the choice of languages. See Remarks.
 * @param {string=} geographicRegion The identifier for the geographic region.
 */
Windows.Globalization.NumberFormatting.DecimalFormatter = function(languages, geographicRegion) {};
 /** @type {number} */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.fractionDigits;
 /** @type {string} */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.geographicRegion;
 /** @type {number} */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.integerDigits;
 /** @type {boolean} */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.isDecimalPointAlwaysDisplayed;
 /** @type {boolean} */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.isGrouped;
 /** @type {boolean} */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.isZeroSigned;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.languages;
 /** @type {!Windows.Globalization.NumberFormatting.INumberRounder} */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.numberRounder;
 /** @type {string} */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.numeralSystem;
 /** @type {string} */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.resolvedGeographicRegion;
 /** @type {string} */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.resolvedLanguage;
 /** @type {number} */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.significantDigits;

/**
 * Returns a string representation of a Double number.
 * Returns a string representation of an Int64 number.
 * Returns a string representation of a UInt64 number.
 * @param {number} value The Double value to be formatted. / The Int64 value to be formatted. / The UInt64 value to be formatted.
 * @return {string} A string that represents the number.
 */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.format = function(value) {};

/**
 * Returns a string representation of a Double number.
 * @param {number} value The Double value to be formatted.
 * @return {string} A string that represents the number.
 */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.formatDouble = function(value) {};

/**
 * Returns a string representation of an Int64 number.
 * @param {number} value The Int64 value to be formatted.
 * @return {string} A string that represents the number.
 */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.formatInt = function(value) {};

/**
 * Returns a string representation of a UInt64 number.
 * @param {number} value The UInt64 value to be formatted.
 * @return {string} A string that represents the number.
 */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.formatUInt = function(value) {};

/**
 * Attempts to parse a string representation of a Double number.
 * @param {string} text The text to be parsed.
 * @return {number} If successful, a Double that corresponds to the string representation, and otherwise null.
 */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.parseDouble = function(text) {};

/**
 * Attempts to parse a string representation of an integer.
 * @param {string} text The text to be parsed.
 * @return {number} If successful, an Int64 that corresponds to the string representation, and otherwise null.
 */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.parseInt = function(text) {};

/**
 * Attempts to parse a string representation of an unsigned integer.
 * @param {string} text The text to be parsed.
 * @return {number} If successful, a UInt64 that corresponds to the string representation, and otherwise null.
 */
Windows.Globalization.NumberFormatting.DecimalFormatter.prototype.parseUInt = function(text) {};

/**
 * @constructor
 * @struct
 * Creates an IncrementNumberRounder object.
 */
Windows.Globalization.NumberFormatting.IncrementNumberRounder = function() {};
 /** @type {number} */
Windows.Globalization.NumberFormatting.IncrementNumberRounder.prototype.increment;
 /** @type {Windows.Globalization.NumberFormatting.RoundingAlgorithm} */
Windows.Globalization.NumberFormatting.IncrementNumberRounder.prototype.roundingAlgorithm;

/**
 * Rounds a Double number to the specified increment.
 * @param {number} value The Double value to be rounded.
 * @return {number} The rounded number. This result is a double precision floating point number, which is not necessarily an integer.
 */
Windows.Globalization.NumberFormatting.IncrementNumberRounder.prototype.roundDouble = function(value) {};

/**
 * Rounds an Int32 number to the specified increment.
 * @param {number} value The Int32 value to be rounded.
 * @return {number} The rounded 32 bit integer.
 */
Windows.Globalization.NumberFormatting.IncrementNumberRounder.prototype.roundInt32 = function(value) {};

/**
 * Rounds an Int64 number to the specified increment.
 * @param {number} value The Int64 value to be rounded.
 * @return {number} The rounded 64 bit integer.
 */
Windows.Globalization.NumberFormatting.IncrementNumberRounder.prototype.roundInt64 = function(value) {};

/**
 * Rounds a Single number to the specified increment.
 * @param {number} value The Single value to be rounded.
 * @return {number} The rounded number. This result is a single precision floating point number, which is not necessarily an integer.
 */
Windows.Globalization.NumberFormatting.IncrementNumberRounder.prototype.roundSingle = function(value) {};

/**
 * Rounds a UInt32 number to the specified increment.
 * @param {number} value The UInt32 value to be rounded.
 * @return {number} The rounded unsigned 32 bit integer.
 */
Windows.Globalization.NumberFormatting.IncrementNumberRounder.prototype.roundUInt32 = function(value) {};

/**
 * Rounds a UInt64 number to the specified increment.
 * @param {number} value The UInt64 value to be rounded.
 * @return {number} The rounded unsigned 64 bit integer.
 */
Windows.Globalization.NumberFormatting.IncrementNumberRounder.prototype.roundUInt64 = function(value) {};

/**
 * @constructor
 * @struct
 * Creates a NumeralSystemTranslator object initialized by a language list.
 * Creates a NumeralSystemTranslator object initialized by the list of current runtime language values preferred by the user.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} languages A list of BCP-47 language tags, in priority order, representing the choice of languages. They must all be well-formed according to Windows.Globalization.Language.isWellFormed .
 */
Windows.Globalization.NumberFormatting.NumeralSystemTranslator = function(languages) {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Globalization.NumberFormatting.NumeralSystemTranslator.prototype.languages;
 /** @type {string} */
Windows.Globalization.NumberFormatting.NumeralSystemTranslator.prototype.numeralSystem;
 /** @type {string} */
Windows.Globalization.NumberFormatting.NumeralSystemTranslator.prototype.resolvedLanguage;

/**
 * Converts a string of characters containing Latin digits to a string containing the corresponding digits of NumeralSystem .
 * @param {string} value A string of characters containing Latin digits to be converted.
 * @return {string} A string containing the converted digits. This string may be a different length than value.
 */
Windows.Globalization.NumberFormatting.NumeralSystemTranslator.prototype.translateNumerals = function(value) {};

/**
 * @constructor
 * @struct
 * Creates a PercentFormatter object and initializes it to default values.
 * Creates a PercentFormatter object initialized by a language list and a geographic region.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} languages The list of language identifiers, in priority order, representing the choice of languages. See Remarks.
 * @param {string=} geographicRegion The identifier for the geographic region.
 */
Windows.Globalization.NumberFormatting.PercentFormatter = function(languages, geographicRegion) {};
 /** @type {number} */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.fractionDigits;
 /** @type {string} */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.geographicRegion;
 /** @type {number} */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.integerDigits;
 /** @type {boolean} */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.isDecimalPointAlwaysDisplayed;
 /** @type {boolean} */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.isGrouped;
 /** @type {boolean} */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.isZeroSigned;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.languages;
 /** @type {!Windows.Globalization.NumberFormatting.INumberRounder} */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.numberRounder;
 /** @type {string} */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.numeralSystem;
 /** @type {string} */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.resolvedGeographicRegion;
 /** @type {string} */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.resolvedLanguage;
 /** @type {number} */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.significantDigits;

/**
 * Returns a string representation of a UInt64 percentage.
 * Returns a string representation of an Int64 percentage.
 * Returns a string representation of a Double percentage.
 * @param {number} value The UInt64 value to be formatted. / The Int64 value to be formatted. / The Double value to be formatted.
 * @return {string} A string that represents the percentage.
 */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.format = function(value) {};

/**
 * Returns a string representation of a Double percentage.
 * @param {number} value The Double value to be formatted.
 * @return {string} A string that represents the percentage.
 */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.formatDouble = function(value) {};

/**
 * Returns a string representation of an Int64 percentage.
 * @param {number} value The Int64 value to be formatted.
 * @return {string} A string that represents the percentage.
 */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.formatInt = function(value) {};

/**
 * Returns a string representation of a UInt64 percentage.
 * @param {number} value The UInt64 value to be formatted.
 * @return {string} A string that represents the percentage.
 */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.formatUInt = function(value) {};

/**
 * Attempts to parse a string representation of a Double percentage.
 * @param {string} text The text to be parsed.
 * @return {number} If successful, a Double that corresponds to the string representation, and otherwise null.
 */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.parseDouble = function(text) {};

/**
 * Attempts to parse a string representation of an integer percentage.
 * @param {string} text The text to be parsed.
 * @return {number} If successful, an Int64 that corresponds to the string representation, and otherwise null.
 */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.parseInt = function(text) {};

/**
 * Attempts to parse a string representation of an unsigned integer percentage.
 * @param {string} text The text to be parsed.
 * @return {number} If successful, a UInt64 that corresponds to the string representation, and otherwise null.
 */
Windows.Globalization.NumberFormatting.PercentFormatter.prototype.parseUInt = function(text) {};

/**
 * @constructor
 * @struct
 * Creates a PermilleFormatter object and initializes it to default values.
 * Creates a PermilleFormatter object initialized by a language list and a geographic region.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} languages The list of language identifiers, in priority order, representing the choice of languages. See Remarks.
 * @param {string=} geographicRegion The identifier for the geographic region.
 */
Windows.Globalization.NumberFormatting.PermilleFormatter = function(languages, geographicRegion) {};
 /** @type {number} */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.fractionDigits;
 /** @type {string} */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.geographicRegion;
 /** @type {number} */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.integerDigits;
 /** @type {boolean} */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.isDecimalPointAlwaysDisplayed;
 /** @type {boolean} */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.isGrouped;
 /** @type {boolean} */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.isZeroSigned;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.languages;
 /** @type {!Windows.Globalization.NumberFormatting.INumberRounder} */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.numberRounder;
 /** @type {string} */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.numeralSystem;
 /** @type {string} */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.resolvedGeographicRegion;
 /** @type {string} */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.resolvedLanguage;
 /** @type {number} */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.significantDigits;

/**
 * Returns a string representation of a UInt64 permillage.
 * Returns a string representation of an Int64 permillage.
 * Returns a string representation of a Double permillage.
 * @param {number} value The UInt64 value to be formatted. / The Int64 value to be formatted. / The Double value to be formatted.
 * @return {string} A string that represents the permillage.
 */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.format = function(value) {};

/**
 * Returns a string representation of a Double permillage.
 * @param {number} value The Double value to be formatted.
 * @return {string} A string that represents the permillage.
 */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.formatDouble = function(value) {};

/**
 * Returns a string representation of an Int64 permillage.
 * @param {number} value The Int64 value to be formatted.
 * @return {string} A string that represents the permillage.
 */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.formatInt = function(value) {};

/**
 * Returns a string representation of a UInt64 permillage.
 * @param {number} value The UInt64 value to be formatted.
 * @return {string} A string that represents the permillage.
 */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.formatUInt = function(value) {};

/**
 * Attempts to parse a string representation of a Double permillage.
 * @param {string} text The text to be parsed.
 * @return {number} If successful, a Double that corresponds to the string representation, and otherwise null.
 */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.parseDouble = function(text) {};

/**
 * Attempts to parse a string representation of an integer permillage.
 * @param {string} text The text to be parsed.
 * @return {number} If successful, an Int64 that corresponds to the string representation, and otherwise null.
 */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.parseInt = function(text) {};

/**
 * Attempts to parse a string representation of an unsigned integer permillage.
 * @param {string} text The text to be parsed.
 * @return {number} If successful, a UInt64 that corresponds to the string representation, and otherwise null.
 */
Windows.Globalization.NumberFormatting.PermilleFormatter.prototype.parseUInt = function(text) {};

/** @const */
Windows.Globalization.NumberFormatting.RoundingAlgorithm = {};
/** @const {number} */
Windows.Globalization.NumberFormatting.RoundingAlgorithm.none;
/** @const {number} */
Windows.Globalization.NumberFormatting.RoundingAlgorithm.roundDown;
/** @const {number} */
Windows.Globalization.NumberFormatting.RoundingAlgorithm.roundUp;
/** @const {number} */
Windows.Globalization.NumberFormatting.RoundingAlgorithm.roundTowardsZero;
/** @const {number} */
Windows.Globalization.NumberFormatting.RoundingAlgorithm.roundAwayFromZero;
/** @const {number} */
Windows.Globalization.NumberFormatting.RoundingAlgorithm.roundHalfDown;
/** @const {number} */
Windows.Globalization.NumberFormatting.RoundingAlgorithm.roundHalfUp;
/** @const {number} */
Windows.Globalization.NumberFormatting.RoundingAlgorithm.roundHalfTowardsZero;
/** @const {number} */
Windows.Globalization.NumberFormatting.RoundingAlgorithm.roundHalfAwayFromZero;
/** @const {number} */
Windows.Globalization.NumberFormatting.RoundingAlgorithm.roundHalfToEven;
/** @const {number} */
Windows.Globalization.NumberFormatting.RoundingAlgorithm.roundHalfToOdd;

/**
 * @constructor
 * @struct
 * Creates a SignificantDigitsNumberRounder object.
 */
Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder = function() {};
 /** @type {Windows.Globalization.NumberFormatting.RoundingAlgorithm} */
Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder.prototype.roundingAlgorithm;
 /** @type {number} */
Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder.prototype.significantDigits;

/**
 * Rounds a Double number to the specified number of significant digits.
 * @param {number} value The Double value to be rounded.
 * @return {number} The rounded number. This result is a double precision floating point number, which is not necessarily an integer.
 */
Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder.prototype.roundDouble = function(value) {};

/**
 * Rounds an Int32 number to the specified number of significant digits.
 * @param {number} value The Int32 value to be rounded.
 * @return {number} The rounded 32 bit integer.
 */
Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder.prototype.roundInt32 = function(value) {};

/**
 * Rounds an Int64 number to the specified number of significant digits.
 * @param {number} value The Int64 value to be rounded.
 * @return {number} The rounded 64 bit integer.
 */
Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder.prototype.roundInt64 = function(value) {};

/**
 * Rounds a Single number to the specified number of significant digits.
 * @param {number} value The Single value to be rounded.
 * @return {number} The rounded number. This result is a single precision floating point number, which is not necessarily an integer.
 */
Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder.prototype.roundSingle = function(value) {};

/**
 * Rounds a UInt32 number to the specified number of significant digits.
 * @param {number} value The UInt32 value to be rounded.
 * @return {number} The rounded unsigned 32 bit integer.
 */
Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder.prototype.roundUInt32 = function(value) {};

/**
 * Rounds a UInt64 number to the specified number of significant digits.
 * @param {number} value The UInt64 value to be rounded.
 * @return {number} The rounded unsigned 64 bit integer.
 */
Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder.prototype.roundUInt64 = function(value) {};
/**
 * @record
 * @struct
 */
Windows.Globalization.NumberFormatting.INumberRounder = function() {};

/**
 * Rounds a Double number.
 * @param {number} value The Double value to be rounded.
 * @return {number} The rounded number. This result is a double precision floating point number, which is not necessarily an integer.
 */
Windows.Globalization.NumberFormatting.INumberRounder.prototype.roundDouble = function(value) {};

/**
 * Rounds an Int32 number.
 * @param {number} value The Int32 value to be rounded.
 * @return {number} The rounded 32 bit integer.
 */
Windows.Globalization.NumberFormatting.INumberRounder.prototype.roundInt32 = function(value) {};

/**
 * Rounds an Int64 number.
 * @param {number} value The Int64 value to be rounded.
 * @return {number} The rounded 64 bit integer.
 */
Windows.Globalization.NumberFormatting.INumberRounder.prototype.roundInt64 = function(value) {};

/**
 * Rounds a Single number.
 * @param {number} value The Single value to be rounded.
 * @return {number} The rounded number. This result is a single precision floating point number, which is not necessarily an integer.
 */
Windows.Globalization.NumberFormatting.INumberRounder.prototype.roundSingle = function(value) {};

/**
 * Rounds a UInt32 number.
 * @param {number} value The UInt32 value to be rounded.
 * @return {number} The rounded unsigned 32 bit integer.
 */
Windows.Globalization.NumberFormatting.INumberRounder.prototype.roundUInt32 = function(value) {};

/**
 * Rounds a UInt64 number.
 * @param {number} value The UInt64 value to be rounded.
 * @return {number} The rounded unsigned 64 bit integer.
 */
Windows.Globalization.NumberFormatting.INumberRounder.prototype.roundUInt64 = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Globalization.NumeralSystemIdentifiers = function() {};
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.arab;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.arabExt;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.bali;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.beng;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.brah;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.cham;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.deva;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.fullWide;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.gujr;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.guru;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.haniDec;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.java;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.kali;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.khmr;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.knda;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.lana;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.lanaTham;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.laoo;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.latn;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.lepc;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.limb;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.mathBold;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.mathDbl;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.mathMono;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.mathSanb;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.mathSans;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.mlym;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.mong;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.mtei;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.mymr;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.mymrShan;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.nkoo;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.olck;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.orya;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.osma;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.saur;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.sund;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.talu;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.tamlDec;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.telu;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.thai;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.tibt;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.vaii;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.zmthBold;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.zmthDbl;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.zmthMono;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.zmthSanb;
 /** @type {string} */
Windows.Globalization.NumeralSystemIdentifiers.zmthSans;
/** @const */
Windows.Graphics = {};
/** @const */
Windows.Graphics.DirectX = {};
/** @const */
Windows.Graphics.DirectX.Direct3D11 = {};

/** @const */
Windows.Graphics.DirectX.Direct3D11.Direct3DBindings = {};
/** @const {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DBindings.vertexBuffer;
/** @const {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DBindings.indexBuffer;
/** @const {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DBindings.constantBuffer;
/** @const {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DBindings.shaderResource;
/** @const {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DBindings.streamOutput;
/** @const {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DBindings.renderTarget;
/** @const {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DBindings.depthStencil;
/** @const {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DBindings.unorderedAccess;
/** @const {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DBindings.decoder;
/** @const {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DBindings.videoEncoder;

/** @const */
Windows.Graphics.DirectX.Direct3D11.Direct3DUsage = {};
/** @const {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DUsage.default;
/** @const {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DUsage.immutable;
/** @const {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DUsage.dynamic;
/** @const {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DUsage.staging;
/**
 * @extends {Windows.Foundation.IClosable}
 * @record
 * @struct
 */
Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface = function() {};
 /** @type {!Windows.Graphics.DirectX.Direct3D11.Direct3DSurfaceDescription} */
Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface.prototype.description;
/**
 * @record
 * @struct
 */
Windows.Graphics.DirectX.Direct3D11.Direct3DSurfaceDescription = function() {};
 /** @type {Windows.Graphics.DirectX.DirectXPixelFormat} */
Windows.Graphics.DirectX.Direct3D11.Direct3DSurfaceDescription.prototype.format;
 /** @type {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DSurfaceDescription.prototype.height;
 /** @type {!Windows.Graphics.DirectX.Direct3D11.Direct3DMultisampleDescription} */
Windows.Graphics.DirectX.Direct3D11.Direct3DSurfaceDescription.prototype.multisampleDescription;
 /** @type {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DSurfaceDescription.prototype.width;
/**
 * @record
 * @struct
 */
Windows.Graphics.DirectX.Direct3D11.Direct3DMultisampleDescription = function() {};
 /** @type {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DMultisampleDescription.prototype.count;
 /** @type {number} */
Windows.Graphics.DirectX.Direct3D11.Direct3DMultisampleDescription.prototype.quality;

/** @const */
Windows.Graphics.DirectX.DirectXAlphaMode = {};
/** @const {number} */
Windows.Graphics.DirectX.DirectXAlphaMode.unspecified;
/** @const {number} */
Windows.Graphics.DirectX.DirectXAlphaMode.premultiplied;
/** @const {number} */
Windows.Graphics.DirectX.DirectXAlphaMode.straight;
/** @const {number} */
Windows.Graphics.DirectX.DirectXAlphaMode.ignore;

/** @const */
Windows.Graphics.DirectX.DirectXPixelFormat = {};
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.unknown;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32G32B32A32Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32G32B32A32Float;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32G32B32A32UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32G32B32A32Int;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32G32B32Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32G32B32Float;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32G32B32UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32G32B32Int;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16G16B16A16Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16G16B16A16Float;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16G16B16A16UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16G16B16A16UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16G16B16A16IntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16G16B16A16Int;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32G32Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32G32Float;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32G32UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32G32Int;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32G8X24Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.d32FloatS8X24UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32FloatX8X24Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.x32TypelessG8X24UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r10G10B10A2Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r10G10B10A2UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r10G10B10A2UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r11G11B10Float;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8G8B8A8Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8G8B8A8UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8G8B8A8UIntNormalizedSrgb;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8G8B8A8UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8G8B8A8IntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8G8B8A8Int;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16G16Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16G16Float;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16G16UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16G16UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16G16IntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16G16Int;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.d32Float;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32Float;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r32Int;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r24G8Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.d24UIntNormalizedS8UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r24UIntNormalizedX8Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.x24TypelessG8UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8G8Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8G8UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8G8UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8G8IntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8G8Int;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16Float;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.d16UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16IntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r16Int;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8UInt;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8IntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8Int;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.a8UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r1UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r9G9B9E5SharedExponent;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r8G8B8G8UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.g8R8G8B8UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc1Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc1UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc1UIntNormalizedSrgb;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc2Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc2UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc2UIntNormalizedSrgb;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc3Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc3UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc3UIntNormalizedSrgb;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc4Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc4UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc4IntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc5Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc5UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc5IntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.b5G6R5UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.b5G5R5A1UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.b8G8R8A8UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.b8G8R8X8UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.r10G10B10XRBiasA2UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.b8G8R8A8Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.b8G8R8A8UIntNormalizedSrgb;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.b8G8R8X8Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.b8G8R8X8UIntNormalizedSrgb;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc6HTypeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc6H16UnsignedFloat;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc6H16Float;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc7Typeless;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc7UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.bc7UIntNormalizedSrgb;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.ayuv;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.y410;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.y416;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.nv12;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.p010;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.p016;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.opaque420;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.yuy2;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.y210;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.y216;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.nv11;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.ai44;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.ia44;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.p8;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.a8P8;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.b4G4R4A4UIntNormalized;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.p208;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.v208;
/** @const {number} */
Windows.Graphics.DirectX.DirectXPixelFormat.v408;
/** @const */
Windows.Graphics.Display = {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Display.DisplayInformation = function() {};
 /** @type {Windows.Graphics.Display.DisplayOrientations} */
Windows.Graphics.Display.DisplayInformation.autoRotationPreferences;
 /** @type {function(?): void} */
Windows.Graphics.Display.DisplayInformation.ondisplaycontentsinvalidated;
 /** @type {Windows.Graphics.Display.DisplayOrientations} */
Windows.Graphics.Display.DisplayInformation.prototype.currentOrientation;
 /** @type {number} */
Windows.Graphics.Display.DisplayInformation.prototype.diagonalSizeInInches;
 /** @type {number} */
Windows.Graphics.Display.DisplayInformation.prototype.logicalDpi;
 /** @type {Windows.Graphics.Display.DisplayOrientations} */
Windows.Graphics.Display.DisplayInformation.prototype.nativeOrientation;
 /** @type {function(?): void} */
Windows.Graphics.Display.DisplayInformation.prototype.oncolorprofilechanged;
 /** @type {function(?): void} */
Windows.Graphics.Display.DisplayInformation.prototype.ondpichanged;
 /** @type {function(?): void} */
Windows.Graphics.Display.DisplayInformation.prototype.onorientationchanged;
 /** @type {function(?): void} */
Windows.Graphics.Display.DisplayInformation.prototype.onstereoenabledchanged;
 /** @type {number} */
Windows.Graphics.Display.DisplayInformation.prototype.rawDpiX;
 /** @type {number} */
Windows.Graphics.Display.DisplayInformation.prototype.rawDpiY;
 /** @type {number} */
Windows.Graphics.Display.DisplayInformation.prototype.rawPixelsPerViewPixel;
 /** @type {Windows.Graphics.Display.ResolutionScale} */
Windows.Graphics.Display.DisplayInformation.prototype.resolutionScale;
 /** @type {boolean} */
Windows.Graphics.Display.DisplayInformation.prototype.stereoEnabled;

/**
 * Gets the current physical display information.
 * @return {!Windows.Graphics.Display.DisplayInformation} A DisplayInformation object that contains the current physical display information.
 */
Windows.Graphics.Display.DisplayInformation.getForCurrentView = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Display.DisplayInformation.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Display.DisplayInformation.removeEventListener = function(type, listener) {};

/**
 * Asynchronously gets the default International Color Consortium (ICC) color profile that is associated with the physical display.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStream, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStream>>} Object that manages the asynchronous retrieval of the color profile.
 */
Windows.Graphics.Display.DisplayInformation.prototype.getColorProfileAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Display.DisplayInformation.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Display.DisplayInformation.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Graphics.Display.DisplayOrientations = {};
/** @const {number} */
Windows.Graphics.Display.DisplayOrientations.none;
/** @const {number} */
Windows.Graphics.Display.DisplayOrientations.landscape;
/** @const {number} */
Windows.Graphics.Display.DisplayOrientations.portrait;
/** @const {number} */
Windows.Graphics.Display.DisplayOrientations.landscapeFlipped;
/** @const {number} */
Windows.Graphics.Display.DisplayOrientations.portraitFlipped;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Display.DisplayProperties = function() {};
 /** @type {Windows.Graphics.Display.DisplayOrientations} */
Windows.Graphics.Display.DisplayProperties.autoRotationPreferences;
 /** @type {Windows.Graphics.Display.DisplayOrientations} */
Windows.Graphics.Display.DisplayProperties.currentOrientation;
 /** @type {number} */
Windows.Graphics.Display.DisplayProperties.logicalDpi;
 /** @type {Windows.Graphics.Display.DisplayOrientations} */
Windows.Graphics.Display.DisplayProperties.nativeOrientation;
 /** @type {function(!Windows.WinRTEvent<?>): void} */
Windows.Graphics.Display.DisplayProperties.oncolorprofilechanged;
 /** @type {function(!Windows.WinRTEvent<?>): void} */
Windows.Graphics.Display.DisplayProperties.ondisplaycontentsinvalidated;
 /** @type {function(!Windows.WinRTEvent<?>): void} */
Windows.Graphics.Display.DisplayProperties.onlogicaldpichanged;
 /** @type {function(!Windows.WinRTEvent<?>): void} */
Windows.Graphics.Display.DisplayProperties.onorientationchanged;
 /** @type {function(!Windows.WinRTEvent<?>): void} */
Windows.Graphics.Display.DisplayProperties.onstereoenabledchanged;
 /** @type {Windows.Graphics.Display.ResolutionScale} */
Windows.Graphics.Display.DisplayProperties.resolutionScale;
 /** @type {boolean} */
Windows.Graphics.Display.DisplayProperties.stereoEnabled;

/**
 * Asynchronously gets the default International Color Consortium (ICC) color profile that is associated with the physical display.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStream, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStream>>} Object that manages the asynchronous retrieval of the color profile.
 */
Windows.Graphics.Display.DisplayProperties.getColorProfileAsync = function() {};

/**
 * @param {string} type
 * @param {function(!Windows.WinRTEvent<?>): void|function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Display.DisplayProperties.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(!Windows.WinRTEvent<?>): void|function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Display.DisplayProperties.removeEventListener = function(type, listener) {};

/** @const */
Windows.Graphics.Display.ResolutionScale = {};
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.invalid;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale100Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale120Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale125Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale140Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale150Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale160Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale175Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale180Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale200Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale225Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale250Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale300Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale350Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale400Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale450Percent;
/** @const {number} */
Windows.Graphics.Display.ResolutionScale.scale500Percent;

/** @typedef {function(!Windows.WinRTEvent<?>): void} */
Windows.Graphics.Display.DisplayPropertiesEventHandler;
/** @const */
Windows.Graphics.Effects = {};
/** @const */
Windows.Graphics.Holographic = {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Holographic.HolographicCamera = function() {};
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCamera.prototype.id;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCamera.prototype.isStereo;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCamera.prototype.renderTargetSize;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCamera.prototype.setFarPlaneDistance;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCamera.prototype.setNearPlaneDistance;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCamera.prototype.viewportScaleFactor;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Holographic.HolographicCameraPose = function() {};
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCameraPose.prototype.farPlaneDistance;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCameraPose.prototype.holographicCamera;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCameraPose.prototype.nearPlaneDistance;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCameraPose.prototype.projectionTransform;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCameraPose.prototype.tryGetCullingFrustum;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCameraPose.prototype.tryGetViewTransform;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCameraPose.prototype.tryGetVisibleFrustum;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCameraPose.prototype.viewport;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Holographic.HolographicCameraRenderingParameters = function() {};
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCameraRenderingParameters.prototype.direct3D11BackBuffer;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCameraRenderingParameters.prototype.direct3D11Device;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicCameraRenderingParameters.prototype.setFocusPoint;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Holographic.HolographicFrame = function() {};
 /** @type {?} */
Windows.Graphics.Holographic.HolographicFrame.prototype.addedCameras;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicFrame.prototype.currentPrediction;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicFrame.prototype.duration;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicFrame.prototype.getRenderingParameters;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicFrame.prototype.presentUsingCurrentPrediction;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicFrame.prototype.removedCameras;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicFrame.prototype.updateCurrentPrediction;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicFrame.prototype.waitForFrameToFinish;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Holographic.HolographicFramePrediction = function() {};
 /** @type {?} */
Windows.Graphics.Holographic.HolographicFramePrediction.prototype.cameraPoses;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicFramePrediction.prototype.timestamp;
/** @const */
Windows.Graphics.Holographic.HolographicFramePresentResult = {};
 /** @type {?} */
Windows.Graphics.Holographic.HolographicFramePresentResult.success;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicFramePresentResult.deviceRemoved;
/** @const */
Windows.Graphics.Holographic.HolographicFramePresentWaitBehavior = {};
 /** @type {?} */
Windows.Graphics.Holographic.HolographicFramePresentWaitBehavior.waitForFrameToFinish;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicFramePresentWaitBehavior.doNotWaitForFrameToFinish;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Holographic.HolographicSpace = function() {};
 /** @type {?} */
Windows.Graphics.Holographic.HolographicSpace.createForCoreWindow;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicSpace.prototype.addEventListener;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicSpace.prototype.createNextFrame;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicSpace.prototype.oncameraadded;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicSpace.prototype.oncameraremoved;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicSpace.prototype.primaryAdapterId;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicSpace.prototype.removeEventListener;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicSpace.prototype.setDirect3D11Device;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Holographic.HolographicSpaceCameraAddedEventArgs = function() {};
 /** @type {?} */
Windows.Graphics.Holographic.HolographicSpaceCameraAddedEventArgs.prototype.camera;
 /** @type {?} */
Windows.Graphics.Holographic.HolographicSpaceCameraAddedEventArgs.prototype.getDeferral;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Holographic.HolographicSpaceCameraRemovedEventArgs = function() {};
 /** @type {?} */
Windows.Graphics.Holographic.HolographicSpaceCameraRemovedEventArgs.prototype.camera;
/** @const */
Windows.Graphics.Imaging = {};

/** @const */
Windows.Graphics.Imaging.BitmapAlphaMode = {};
/** @const {number} */
Windows.Graphics.Imaging.BitmapAlphaMode.premultiplied;
/** @const {number} */
Windows.Graphics.Imaging.BitmapAlphaMode.straight;
/** @const {number} */
Windows.Graphics.Imaging.BitmapAlphaMode.ignore;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Imaging.BitmapBuffer = function() {};

/**
 * Disposes of the object and associated resources.
 * @return {void}
 */
Windows.Graphics.Imaging.BitmapBuffer.prototype.close = function() {};

/**
 * Creates a reference to the underlying memory buffer.
 * @return {!Windows.Foundation.IMemoryBufferReference} A reference to the underlying memory buffer.
 */
Windows.Graphics.Imaging.BitmapBuffer.prototype.createReference = function() {};

/**
 * Gets the number of bit planes in the bitmap buffer.
 * @return {number} The number of bit planes in the bitmap buffer.
 */
Windows.Graphics.Imaging.BitmapBuffer.prototype.getPlaneCount = function() {};

/**
 * Gets a BitmapPlaneDescription object that describes the size, offset, and stride of the bitmap data in the bit plane with the specified index.
 * @param {number} index The index of the bit plane for which the description is retrieved.
 * @return {!Windows.Graphics.Imaging.BitmapPlaneDescription} The bit plane description.
 */
Windows.Graphics.Imaging.BitmapBuffer.prototype.getPlaneDescription = function(index) {};

/** @const */
Windows.Graphics.Imaging.BitmapBufferAccessMode = {};
/** @const {number} */
Windows.Graphics.Imaging.BitmapBufferAccessMode.read;
/** @const {number} */
Windows.Graphics.Imaging.BitmapBufferAccessMode.readWrite;
/** @const {number} */
Windows.Graphics.Imaging.BitmapBufferAccessMode.write;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Imaging.BitmapCodecInformation = function() {};
 /** @type {string} */
Windows.Graphics.Imaging.BitmapCodecInformation.prototype.codecId;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Graphics.Imaging.BitmapCodecInformation.prototype.fileExtensions;
 /** @type {string} */
Windows.Graphics.Imaging.BitmapCodecInformation.prototype.friendlyName;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Graphics.Imaging.BitmapCodecInformation.prototype.mimeTypes;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Imaging.BitmapDecoder = function() {};
 /** @type {string} */
Windows.Graphics.Imaging.BitmapDecoder.bmpDecoderId;
 /** @type {string} */
Windows.Graphics.Imaging.BitmapDecoder.gifDecoderId;
 /** @type {string} */
Windows.Graphics.Imaging.BitmapDecoder.icoDecoderId;
 /** @type {string} */
Windows.Graphics.Imaging.BitmapDecoder.jpegDecoderId;
 /** @type {string} */
Windows.Graphics.Imaging.BitmapDecoder.jpegXRDecoderId;
 /** @type {string} */
Windows.Graphics.Imaging.BitmapDecoder.pngDecoderId;
 /** @type {string} */
Windows.Graphics.Imaging.BitmapDecoder.tiffDecoderId;
 /** @type {Windows.Graphics.Imaging.BitmapAlphaMode} */
Windows.Graphics.Imaging.BitmapDecoder.prototype.bitmapAlphaMode;
 /** @type {!Windows.Graphics.Imaging.BitmapPropertiesView} */
Windows.Graphics.Imaging.BitmapDecoder.prototype.bitmapContainerProperties;
 /** @type {Windows.Graphics.Imaging.BitmapPixelFormat} */
Windows.Graphics.Imaging.BitmapDecoder.prototype.bitmapPixelFormat;
 /** @type {!Windows.Graphics.Imaging.BitmapPropertiesView} */
Windows.Graphics.Imaging.BitmapDecoder.prototype.bitmapProperties;
 /** @type {!Windows.Graphics.Imaging.BitmapCodecInformation} */
Windows.Graphics.Imaging.BitmapDecoder.prototype.decoderInformation;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapDecoder.prototype.dpiX;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapDecoder.prototype.dpiY;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapDecoder.prototype.frameCount;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapDecoder.prototype.orientedPixelHeight;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapDecoder.prototype.orientedPixelWidth;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapDecoder.prototype.pixelHeight;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapDecoder.prototype.pixelWidth;

/**
 * Asynchronously creates a new BitmapDecoder and initializes it using a stream.
 * Asynchronously creates a new BitmapDecoder using a specific bitmap codec and initializes it using a stream.
 * @param {!Windows.Storage.Streams.IRandomAccessStream|string} stream_or_decoderId The stream containing the image file to be decoded. / The unique identifier of the specified bitmap codec.
 * @param {!Windows.Storage.Streams.IRandomAccessStream=} stream The stream containing the image file to be decoded.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.BitmapDecoder, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.BitmapDecoder>>} An object that manages the asynchronous creation of a new BitmapDecoder .
 */
Windows.Graphics.Imaging.BitmapDecoder.createAsync = function(stream_or_decoderId, stream) {};

/**
 * The bitmap decoders installed on the system and information about them.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Graphics.Imaging.BitmapCodecInformation>} A list of BitmapCodecInformation objects containing information about each decoder.
 */
Windows.Graphics.Imaging.BitmapDecoder.getDecoderInformationEnumerator = function() {};

/**
 * Asynchronously retrieves a frame from the image file.
 * @param {number} frameIndex The zero-based index of the frame to be retrieved.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.BitmapFrame, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.BitmapFrame>>} Object that manages the asynchronous retrieval of the frame.
 */
Windows.Graphics.Imaging.BitmapDecoder.prototype.getFrameAsync = function(frameIndex) {};

/**
 * Asynchronously requests the pixel data for the frame.
 * Asynchronously requests the pixel data for the frame using the specified parameters.
 * @param {Windows.Graphics.Imaging.BitmapPixelFormat=} pixelFormat The specified pixel format.
 * @param {Windows.Graphics.Imaging.BitmapAlphaMode=} alphaMode The specified alpha mode.
 * @param {!Windows.Graphics.Imaging.BitmapTransform=} transform The set of transformations to be applied to the frame.
 * @param {Windows.Graphics.Imaging.ExifOrientationMode=} exifOrientationMode Indicates whether the EXIF orientation flag should be ignored or respected.
 * @param {Windows.Graphics.Imaging.ColorManagementMode=} colorManagementMode Indicates whether the pixel data should be color managed to the sRGB color space.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.PixelDataProvider, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.PixelDataProvider>>} Object that manages the asynchronous retrieval of the pixel data.
 */
Windows.Graphics.Imaging.BitmapDecoder.prototype.getPixelDataAsync = function(pixelFormat, alphaMode, transform, exifOrientationMode, colorManagementMode) {};

/**
 * Asynchronously returns a stream containing the preview image.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.ImageStream, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.ImageStream>>} Object that manages the asynchronous retrieval of the bitmap preview data.
 */
Windows.Graphics.Imaging.BitmapDecoder.prototype.getPreviewAsync = function() {};

/**
 * Asynchronously gets a SoftwareBitmap representation of the decoded bitmap.
 * Asynchronously gets a SoftwareBitmap representation of the decoded bitmap.
 * Asynchronously gets a SoftwareBitmap representation of the decoded bitmap.
 * @param {Windows.Graphics.Imaging.BitmapPixelFormat=} pixelFormat The pixel format of the software bitmap.
 * @param {Windows.Graphics.Imaging.BitmapAlphaMode=} alphaMode The alpha mode of the software bitmap.
 * @param {!Windows.Graphics.Imaging.BitmapTransform=} transform The transform of the software bitmap.
 * @param {Windows.Graphics.Imaging.ExifOrientationMode=} exifOrientationMode The EXIF orientation mode of the software bitmap.
 * @param {Windows.Graphics.Imaging.ColorManagementMode=} colorManagementMode The color management mode of the software bitmap.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.SoftwareBitmap, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.SoftwareBitmap>>} An asynchronous operation that returns a SoftwareBitmap on successful completion.
 */
Windows.Graphics.Imaging.BitmapDecoder.prototype.getSoftwareBitmapAsync = function(pixelFormat, alphaMode, transform, exifOrientationMode, colorManagementMode) {};

/**
 * Asynchronously returns a stream containing the thumbnail image.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.ImageStream, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.ImageStream>>} Object that manages the asynchronous retrieval of the thumbnail stream.
 */
Windows.Graphics.Imaging.BitmapDecoder.prototype.getThumbnailAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Imaging.BitmapEncoder = function() {};
 /** @type {string} */
Windows.Graphics.Imaging.BitmapEncoder.bmpEncoderId;
 /** @type {string} */
Windows.Graphics.Imaging.BitmapEncoder.gifEncoderId;
 /** @type {string} */
Windows.Graphics.Imaging.BitmapEncoder.jpegEncoderId;
 /** @type {string} */
Windows.Graphics.Imaging.BitmapEncoder.jpegXREncoderId;
 /** @type {string} */
Windows.Graphics.Imaging.BitmapEncoder.pngEncoderId;
 /** @type {string} */
Windows.Graphics.Imaging.BitmapEncoder.tiffEncoderId;
 /** @type {!Windows.Graphics.Imaging.BitmapProperties} */
Windows.Graphics.Imaging.BitmapEncoder.prototype.bitmapContainerProperties;
 /** @type {!Windows.Graphics.Imaging.BitmapProperties} */
Windows.Graphics.Imaging.BitmapEncoder.prototype.bitmapProperties;
 /** @type {!Windows.Graphics.Imaging.BitmapTransform} */
Windows.Graphics.Imaging.BitmapEncoder.prototype.bitmapTransform;
 /** @type {!Windows.Graphics.Imaging.BitmapCodecInformation} */
Windows.Graphics.Imaging.BitmapEncoder.prototype.encoderInformation;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapEncoder.prototype.generatedThumbnailHeight;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapEncoder.prototype.generatedThumbnailWidth;
 /** @type {boolean} */
Windows.Graphics.Imaging.BitmapEncoder.prototype.isThumbnailGenerated;

/**
 * Asynchronously creates a new BitmapEncoder for the specified codec with the specified encoding options and initializes it on a stream.
 * Asynchronously creates a new BitmapEncoder .
 * @param {string} encoderId The unique identifier of the specified encoder.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} stream A stream representing where the image file is to be written. / The output stream.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>=} encodingOptions A collection of key-value pairs containing one or more codec-specific encoding options and the desired values.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.BitmapEncoder, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.BitmapEncoder>>} An object that manages the asynchronous creation of a new BitmapEncoder .
 */
Windows.Graphics.Imaging.BitmapEncoder.createAsync = function(encoderId, stream, encodingOptions) {};

/**
 * Asynchronously creates a new BitmapEncoder for in-place property and metadata editing. The new encoder can only edit bitmap properties in-place and will fail for any other uses.
 * @param {!Windows.Graphics.Imaging.BitmapDecoder} bitmapDecoder A BitmapDecoder containing the image data to be edited. This parameter must be created on a stream with an access mode of ReadWrite .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.BitmapEncoder, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.BitmapEncoder>>} An object that manages the asynchronous initialization of a new BitmapEncoder using data from an existing BitmapDecoder .
 */
Windows.Graphics.Imaging.BitmapEncoder.createForInPlacePropertyEncodingAsync = function(bitmapDecoder) {};

/**
 * Asynchronously creates a new BitmapEncoder and initializes it using data from an existing BitmapDecoder .
 * @param {!Windows.Storage.Streams.IRandomAccessStream} stream The output stream.
 * @param {!Windows.Graphics.Imaging.BitmapDecoder} bitmapDecoder A BitmapDecoder containing the image data to be copied.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.BitmapEncoder, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.BitmapEncoder>>} An object that manages the asynchronous creation of a new BitmapEncoder using data from an existing BitmapDecoder .
 */
Windows.Graphics.Imaging.BitmapEncoder.createForTranscodingAsync = function(stream, bitmapDecoder) {};

/**
 * A list of the bitmap encoders installed on the system and information about them.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Graphics.Imaging.BitmapCodecInformation>} A list of BitmapCodecInformation objects containing information about each encoder.
 */
Windows.Graphics.Imaging.BitmapEncoder.getEncoderInformationEnumerator = function() {};

/**
 * Asynchronously commits and flushes all of the image data.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An object that manages the asynchronous flush operation.
 */
Windows.Graphics.Imaging.BitmapEncoder.prototype.flushAsync = function() {};

/**
 * Asynchronously commits the current frame data and appends a new empty frame, with the specified encoding options, to be edited.
 * Asynchronously commits the current frame data and appends a new empty frame to be edited.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>=} encodingOptions The specified encoding options. A collection of key-value pairs containing one or more codec-specific encoding options and the desired values.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An object that manages the asynchronous operation of committing the current frame data and appending a new empty frame to be edited.
 */
Windows.Graphics.Imaging.BitmapEncoder.prototype.goToNextFrameAsync = function(encodingOptions) {};

/**
 * Sets pixel data on the frame.
 * @param {Windows.Graphics.Imaging.BitmapPixelFormat} pixelFormat The pixel format of the pixel data.
 * @param {Windows.Graphics.Imaging.BitmapAlphaMode} alphaMode The alpha mode of the pixel data.
 * @param {number} width The width, in pixels, of the pixel data.
 * @param {number} height The height, in pixels, of the pixel data.
 * @param {number} dpiX The horizontal resolution, in dots per inch, of the pixel data.
 * @param {number} dpiY The vertical resolution, in dots per inch, of the pixel data.
 * @param {!Array<number>} pixels The pixel data.
 * @return {void}
 */
Windows.Graphics.Imaging.BitmapEncoder.prototype.setPixelData = function(pixelFormat, alphaMode, width, height, dpiX, dpiY, pixels) {};

/**
 * Sets the image data of the current frame using the specified SoftwareBitmap .
 * @param {!Windows.Graphics.Imaging.SoftwareBitmap} bitmap The software bitmap containing the image data.
 * @return {void}
 */
Windows.Graphics.Imaging.BitmapEncoder.prototype.setSoftwareBitmap = function(bitmap) {};

/** @const */
Windows.Graphics.Imaging.BitmapFlip = {};
/** @const {number} */
Windows.Graphics.Imaging.BitmapFlip.none;
/** @const {number} */
Windows.Graphics.Imaging.BitmapFlip.horizontal;
/** @const {number} */
Windows.Graphics.Imaging.BitmapFlip.vertical;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Imaging.BitmapFrame = function() {};
 /** @type {Windows.Graphics.Imaging.BitmapAlphaMode} */
Windows.Graphics.Imaging.BitmapFrame.prototype.bitmapAlphaMode;
 /** @type {Windows.Graphics.Imaging.BitmapPixelFormat} */
Windows.Graphics.Imaging.BitmapFrame.prototype.bitmapPixelFormat;
 /** @type {!Windows.Graphics.Imaging.BitmapPropertiesView} */
Windows.Graphics.Imaging.BitmapFrame.prototype.bitmapProperties;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapFrame.prototype.dpiX;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapFrame.prototype.dpiY;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapFrame.prototype.orientedPixelHeight;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapFrame.prototype.orientedPixelWidth;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapFrame.prototype.pixelHeight;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapFrame.prototype.pixelWidth;

/**
 * Asynchronously requests the pixel data for the frame. The resulting pixel data array will use the bitmap pixel format and alpha mode specified in the BitmapPixelFormat and BitmapAlphaMode properties. It will also have color management and EXIF orientation applied (see the Remarks section for more information).
 * Asynchronously requests the pixel data for the frame using the specified parameters.
 * @param {Windows.Graphics.Imaging.BitmapPixelFormat=} pixelFormat The specified pixel format.
 * @param {Windows.Graphics.Imaging.BitmapAlphaMode=} alphaMode The specified alpha mode.
 * @param {!Windows.Graphics.Imaging.BitmapTransform=} transform The set of transformations to be applied to the frame.
 * @param {Windows.Graphics.Imaging.ExifOrientationMode=} exifOrientationMode Indicates whether the EXIF orientation flag should be ignored or respected.
 * @param {Windows.Graphics.Imaging.ColorManagementMode=} colorManagementMode Indicates whether the pixel data should be color managed to the sRGB color space.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.PixelDataProvider, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.PixelDataProvider>>} Object that manages the asynchronous retrieval of the pixel data.
 */
Windows.Graphics.Imaging.BitmapFrame.prototype.getPixelDataAsync = function(pixelFormat, alphaMode, transform, exifOrientationMode, colorManagementMode) {};

/**
 * Asynchronously gets a SoftwareBitmap representation of the bitmap frame.
 * Asynchronously gets a SoftwareBitmap representation of the bitmap frame.
 * Asynchronously gets a SoftwareBitmap representation of the bitmap frame.
 * @param {Windows.Graphics.Imaging.BitmapPixelFormat=} pixelFormat The pixel format of the software bitmap.
 * @param {Windows.Graphics.Imaging.BitmapAlphaMode=} alphaMode The alpha mode of the software bitmap.
 * @param {!Windows.Graphics.Imaging.BitmapTransform=} transform The transform of the software bitmap.
 * @param {Windows.Graphics.Imaging.ExifOrientationMode=} exifOrientationMode The EXIF orientation mode of the software bitmap.
 * @param {Windows.Graphics.Imaging.ColorManagementMode=} colorManagementMode The color management mode of the software bitmap.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.SoftwareBitmap, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.SoftwareBitmap>>} An asynchronous operation that returns a SoftwareBitmap on successful completion.
 */
Windows.Graphics.Imaging.BitmapFrame.prototype.getSoftwareBitmapAsync = function(pixelFormat, alphaMode, transform, exifOrientationMode, colorManagementMode) {};

/**
 * Asynchronously returns a stream containing the thumbnail image.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.ImageStream, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.ImageStream>>} Object that manages the asynchronous retrieval of the thumbnail data.
 */
Windows.Graphics.Imaging.BitmapFrame.prototype.getThumbnailAsync = function() {};

/** @const */
Windows.Graphics.Imaging.BitmapInterpolationMode = {};
/** @const {number} */
Windows.Graphics.Imaging.BitmapInterpolationMode.nearestNeighbor;
/** @const {number} */
Windows.Graphics.Imaging.BitmapInterpolationMode.linear;
/** @const {number} */
Windows.Graphics.Imaging.BitmapInterpolationMode.cubic;
/** @const {number} */
Windows.Graphics.Imaging.BitmapInterpolationMode.fant;

/** @const */
Windows.Graphics.Imaging.BitmapPixelFormat = {};
/** @const {number} */
Windows.Graphics.Imaging.BitmapPixelFormat.unknown;
/** @const {number} */
Windows.Graphics.Imaging.BitmapPixelFormat.rgba16;
/** @const {number} */
Windows.Graphics.Imaging.BitmapPixelFormat.rgba8;
/** @const {number} */
Windows.Graphics.Imaging.BitmapPixelFormat.gray16;
/** @const {number} */
Windows.Graphics.Imaging.BitmapPixelFormat.gray8;
/** @const {number} */
Windows.Graphics.Imaging.BitmapPixelFormat.bgra8;
/** @const {number} */
Windows.Graphics.Imaging.BitmapPixelFormat.nv12;
/** @const {number} */
Windows.Graphics.Imaging.BitmapPixelFormat.yuy2;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Imaging.BitmapProperties = function() {};

/**
 * Asynchronously retrieves one or more bitmap properties.
 * @param {!Windows.Foundation.Collections.IIterable<string>} propertiesToRetrieve A collection of strings containing the specified property keys.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.BitmapPropertySet, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.BitmapPropertySet>>} Object that manages the asynchronous retrieval of the bitmap properties.
 */
Windows.Graphics.Imaging.BitmapProperties.prototype.getPropertiesAsync = function(propertiesToRetrieve) {};

/**
 * Asynchronously sets one or more bitmap properties.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} propertiesToSet A collection of key-value pairs representing the bitmap properties to be set. Each key is a string containing the Windows property or metadata query, and the corresponding value is a BitmapTypedValue with the data and the correct PropertyType .
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Object that manages the setting of the bitmap properties asynchronously.
 */
Windows.Graphics.Imaging.BitmapProperties.prototype.setPropertiesAsync = function(propertiesToSet) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Imaging.BitmapPropertiesView = function() {};

/**
 * Asynchronously retrieves one or more bitmap properties.
 * @param {!Windows.Foundation.Collections.IIterable<string>} propertiesToRetrieve A collection of strings representing the property keys or queries that are being requested. Valid strings include Windows properties and Windows Imaging Component metadata queries.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.BitmapPropertySet, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.BitmapPropertySet>>} Object that manages the asynchronous retrieval of the bitmap properties.
 */
Windows.Graphics.Imaging.BitmapPropertiesView.prototype.getPropertiesAsync = function(propertiesToRetrieve) {};

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the bitmap property set.
 */
Windows.Graphics.Imaging.BitmapPropertySet = function() {};
 /** @type {number} */
Windows.Graphics.Imaging.BitmapPropertySet.prototype.size;

/**
 * Removes all items from the property set.
 * @return {void}
 */
Windows.Graphics.Imaging.BitmapPropertySet.prototype.clear = function() {};

/**
 * Returns an iterator to enumerate the items in the property set.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The iterator. The current position of the iterator is index 0, or the end of the property set if the property set is empty.
 */
Windows.Graphics.Imaging.BitmapPropertySet.prototype.first = function() {};

/**
 * Gets an immutable view of the property set.
 * @return {!Windows.Foundation.Collections.IMapView<string, !Windows.Graphics.Imaging.BitmapTypedValue>} The immutable view.
 */
Windows.Graphics.Imaging.BitmapPropertySet.prototype.getView = function() {};

/**
 * Indicates whether the property set has an item with the specified key.
 * @param {string} key The key.
 * @return {boolean} True if the property set has an item with the specified key; otherwise, false.
 */
Windows.Graphics.Imaging.BitmapPropertySet.prototype.hasKey = function(key) {};

/**
 * Adds an item to the property set.
 * @param {string} key The key to insert.
 * @param {!Windows.Graphics.Imaging.BitmapTypedValue} value The value to insert.
 * @return {boolean} True if the method replaces a value that already exists for the key; false if this is a new key.
 */
Windows.Graphics.Imaging.BitmapPropertySet.prototype.insert = function(key, value) {};

/**
 * Retrieves the value for the specified key.
 * @param {string} key The key.
 * @return {!Windows.Graphics.Imaging.BitmapTypedValue} The value, if an item with the specified key exists; otherwise, null.
 */
Windows.Graphics.Imaging.BitmapPropertySet.prototype.lookup = function(key) {};

/**
 * Removes an item from the property set.
 * Removes a specific item from the BitmapPropertySet .
 * @param {string} key The key. / The key of the item to remove.
 * @return {void|boolean} true if the item was removed, otherwise false.
 */
Windows.Graphics.Imaging.BitmapPropertySet.prototype.remove = function(key) {};

/** @const */
Windows.Graphics.Imaging.BitmapRotation = {};
/** @const {number} */
Windows.Graphics.Imaging.BitmapRotation.none;
/** @const {number} */
Windows.Graphics.Imaging.BitmapRotation.clockwise90Degrees;
/** @const {number} */
Windows.Graphics.Imaging.BitmapRotation.clockwise180Degrees;
/** @const {number} */
Windows.Graphics.Imaging.BitmapRotation.clockwise270Degrees;

/**
 * @constructor
 * @struct
 * Creates a new BitmapTransform object.
 */
Windows.Graphics.Imaging.BitmapTransform = function() {};
 /** @type {!Windows.Graphics.Imaging.BitmapBounds} */
Windows.Graphics.Imaging.BitmapTransform.prototype.bounds;
 /** @type {Windows.Graphics.Imaging.BitmapFlip} */
Windows.Graphics.Imaging.BitmapTransform.prototype.flip;
 /** @type {Windows.Graphics.Imaging.BitmapInterpolationMode} */
Windows.Graphics.Imaging.BitmapTransform.prototype.interpolationMode;
 /** @type {Windows.Graphics.Imaging.BitmapRotation} */
Windows.Graphics.Imaging.BitmapTransform.prototype.rotation;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapTransform.prototype.scaledHeight;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapTransform.prototype.scaledWidth;

/**
 * @constructor
 * @struct
 * Creates a new BitmapTypedValue object.
 * @param {?} value The value to store.
 * @param {Windows.Foundation.PropertyType} type The type of the value parameter.
 */
Windows.Graphics.Imaging.BitmapTypedValue = function(value, type) {};
 /** @type {Windows.Foundation.PropertyType} */
Windows.Graphics.Imaging.BitmapTypedValue.prototype.type;
 /** @type {?} */
Windows.Graphics.Imaging.BitmapTypedValue.prototype.value;

/** @const */
Windows.Graphics.Imaging.ColorManagementMode = {};
/** @const {number} */
Windows.Graphics.Imaging.ColorManagementMode.doNotColorManage;
/** @const {number} */
Windows.Graphics.Imaging.ColorManagementMode.colorManageToSRgb;

/** @const */
Windows.Graphics.Imaging.ExifOrientationMode = {};
/** @const {number} */
Windows.Graphics.Imaging.ExifOrientationMode.ignoreExifOrientation;
/** @const {number} */
Windows.Graphics.Imaging.ExifOrientationMode.respectExifOrientation;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Imaging.ImageStream = function() {};
 /** @type {boolean} */
Windows.Graphics.Imaging.ImageStream.prototype.canRead;
 /** @type {boolean} */
Windows.Graphics.Imaging.ImageStream.prototype.canWrite;
 /** @type {string} */
Windows.Graphics.Imaging.ImageStream.prototype.contentType;
 /** @type {number} */
Windows.Graphics.Imaging.ImageStream.prototype.position;
 /** @type {number} */
Windows.Graphics.Imaging.ImageStream.prototype.size;

/**
 * Returns the file stream for the ImageStream .
 * @return {!Windows.Storage.Streams.IRandomAccessStream} The file stream for the image.
 */
Windows.Graphics.Imaging.ImageStream.prototype.cloneStream = function() {};

/**
 * Closes the ImageStream .
 * @return {void}
 */
Windows.Graphics.Imaging.ImageStream.prototype.close = function() {};

/**
 * Asynchronously commits the current frame data and flushes all of the data on the image stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An object that manages the asynchronous flush operation.
 */
Windows.Graphics.Imaging.ImageStream.prototype.flushAsync = function() {};

/**
 * Returns an input stream at a specified location in a stream.
 * @param {number} position The location in the stream at which to begin.
 * @return {!Windows.Storage.Streams.IInputStream} The input stream.
 */
Windows.Graphics.Imaging.ImageStream.prototype.getInputStreamAt = function(position) {};

/**
 * Returns an output stream at a specified location in a stream.
 * @param {number} position The location in the output stream at which to begin.
 * @return {!Windows.Storage.Streams.IOutputStream} The output stream.
 */
Windows.Graphics.Imaging.ImageStream.prototype.getOutputStreamAt = function(position) {};

/**
 * Reads data asynchronously from a sequential stream.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous read operation stores the data.
 * @param {number} count The size of the buffer.
 * @param {Windows.Storage.Streams.InputStreamOptions} options The options for the stream to be read.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The byte reader operation.
 */
Windows.Graphics.Imaging.ImageStream.prototype.readAsync = function(buffer, count, options) {};

/**
 * Sets the position of the stream to the specified value.
 * @param {number} position The new position of the stream.
 * @return {void}
 */
Windows.Graphics.Imaging.ImageStream.prototype.seek = function(position) {};

/**
 * Writes data asynchronously in a sequential stream.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous writer operation writes.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The byte writer operation.
 */
Windows.Graphics.Imaging.ImageStream.prototype.writeAsync = function(buffer) {};

/** @const */
Windows.Graphics.Imaging.JpegSubsamplingMode = {};
/** @const {number} */
Windows.Graphics.Imaging.JpegSubsamplingMode.default;
/** @const {number} */
Windows.Graphics.Imaging.JpegSubsamplingMode.y4Cb2Cr0;
/** @const {number} */
Windows.Graphics.Imaging.JpegSubsamplingMode.y4Cb2Cr2;
/** @const {number} */
Windows.Graphics.Imaging.JpegSubsamplingMode.y4Cb4Cr4;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Imaging.PixelDataProvider = function() {};

/**
 * Returns the internally-stored pixel data.
 * @return {!Array<number>} The pixel data.
 */
Windows.Graphics.Imaging.PixelDataProvider.prototype.detachPixelData = function() {};

/** @const */
Windows.Graphics.Imaging.PngFilterMode = {};
/** @const {number} */
Windows.Graphics.Imaging.PngFilterMode.automatic;
/** @const {number} */
Windows.Graphics.Imaging.PngFilterMode.none;
/** @const {number} */
Windows.Graphics.Imaging.PngFilterMode.sub;
/** @const {number} */
Windows.Graphics.Imaging.PngFilterMode.up;
/** @const {number} */
Windows.Graphics.Imaging.PngFilterMode.average;
/** @const {number} */
Windows.Graphics.Imaging.PngFilterMode.paeth;
/** @const {number} */
Windows.Graphics.Imaging.PngFilterMode.adaptive;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the SoftwareBitmap class.
 * Initializes a new instance of the SoftwareBitmap class.
 * @param {Windows.Graphics.Imaging.BitmapPixelFormat} format The pixel format of the new software bitmap.
 * @param {number} width The width of the new software bitmap, in pixels.
 * @param {number} height The height of the new software bitmap, in pixels.
 * @param {Windows.Graphics.Imaging.BitmapAlphaMode=} alpha The alpha mode of the new software bitmap.
 */
Windows.Graphics.Imaging.SoftwareBitmap = function(format, width, height, alpha) {};
 /** @type {Windows.Graphics.Imaging.BitmapAlphaMode} */
Windows.Graphics.Imaging.SoftwareBitmap.prototype.bitmapAlphaMode;
 /** @type {Windows.Graphics.Imaging.BitmapPixelFormat} */
Windows.Graphics.Imaging.SoftwareBitmap.prototype.bitmapPixelFormat;
 /** @type {number} */
Windows.Graphics.Imaging.SoftwareBitmap.prototype.dpiX;
 /** @type {number} */
Windows.Graphics.Imaging.SoftwareBitmap.prototype.dpiY;
 /** @type {boolean} */
Windows.Graphics.Imaging.SoftwareBitmap.prototype.isReadOnly;
 /** @type {number} */
Windows.Graphics.Imaging.SoftwareBitmap.prototype.pixelHeight;
 /** @type {number} */
Windows.Graphics.Imaging.SoftwareBitmap.prototype.pixelWidth;

/**
 * Converts an existing SoftwareBitmap to a SoftwareBitmap with a different pixel format or alpha mode.
 * Converts an existing SoftwareBitmap to a SoftwareBitmap with a different pixel format.
 * @param {!Windows.Graphics.Imaging.SoftwareBitmap} source The software bitmap to convert.
 * @param {Windows.Graphics.Imaging.BitmapPixelFormat} format The pixel format of the new software bitmap.
 * @param {Windows.Graphics.Imaging.BitmapAlphaMode=} alpha The alpha mode of the new software bitmap.
 * @return {!Windows.Graphics.Imaging.SoftwareBitmap} The converted software bitmap.
 */
Windows.Graphics.Imaging.SoftwareBitmap.convert = function(source, format, alpha) {};

/**
 * Creates a copy of the provided SoftwareBitmap object.
 * @param {!Windows.Graphics.Imaging.SoftwareBitmap} source The software bitmap to copy.
 * @return {!Windows.Graphics.Imaging.SoftwareBitmap} The newly created copy of the software bitmap.
 */
Windows.Graphics.Imaging.SoftwareBitmap.copy = function(source) {};

/**
 * Creates a new SoftwareBitmap by performing a deep copy of the provided buffer. Modifications to the data in the new SoftwareBitmap will not effect the buffer from which it was created.
 * Creates a new SoftwareBitmap by performing a deep copy of the provided buffer. Modifications to the data in the new SoftwareBitmap will not effect the buffer from which it was created.
 * @param {!Windows.Storage.Streams.IBuffer} source The source buffer from which the copy will be created.
 * @param {Windows.Graphics.Imaging.BitmapPixelFormat} format The pixel format of the software bitmap.
 * @param {number} width The width of the software bitmap, in pixels.
 * @param {number} height The height of the software bitmap, in pixels.
 * @param {Windows.Graphics.Imaging.BitmapAlphaMode=} alpha The alpha mode of the software bitmap.
 * @return {!Windows.Graphics.Imaging.SoftwareBitmap} The new software bitmap.
 */
Windows.Graphics.Imaging.SoftwareBitmap.createCopyFromBuffer = function(source, format, width, height, alpha) {};

/**
 * Asynchronously creates a new SoftwareBitmap by performing a deep copy of the provided IDirect3DSurface . Modifications to the data in the new SoftwareBitmap will not effect the surface from which it was created.
 * Asynchronously creates a new SoftwareBitmap by performing a deep copy of the provided IDirect3DSurface . Modifications to the data in the new SoftwareBitmap will not effect the surface from which it was created.
 * @param {!Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface} surface The source surface from which the copy will be created.
 * @param {Windows.Graphics.Imaging.BitmapAlphaMode=} alpha The alpha mode of the software bitmap.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.SoftwareBitmap, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.SoftwareBitmap>>} An asynchronous operation that returns a SoftwareBitmap on successful completion.
 */
Windows.Graphics.Imaging.SoftwareBitmap.createCopyFromSurfaceAsync = function(surface, alpha) {};

/**
 * Disposes of the object and associated resources.
 * @return {void}
 */
Windows.Graphics.Imaging.SoftwareBitmap.prototype.close = function() {};

/**
 * Copies the pixel data from an IBuffer into the SoftwareBitmap .
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer containing the pixel data to be copied.
 * @return {void}
 */
Windows.Graphics.Imaging.SoftwareBitmap.prototype.copyFromBuffer = function(buffer) {};

/**
 * Copies the current SoftwareBitmap into the provided SoftwareBitmap object.
 * @param {!Windows.Graphics.Imaging.SoftwareBitmap} bitmap The target software bitmap into which the data will be copied.
 * @return {void}
 */
Windows.Graphics.Imaging.SoftwareBitmap.prototype.copyTo = function(bitmap) {};

/**
 * Copies the software bitmap pixel data into the specified IBuffer .
 * @param {!Windows.Storage.Streams.IBuffer} buffer The target buffer to which the pixel data will be copied.
 * @return {void}
 */
Windows.Graphics.Imaging.SoftwareBitmap.prototype.copyToBuffer = function(buffer) {};

/**
 * Gets a read-only representation of the SoftwareBitmap object.
 * @return {!Windows.Graphics.Imaging.SoftwareBitmap} A read-only representation of the SoftwareBitmap object.
 */
Windows.Graphics.Imaging.SoftwareBitmap.prototype.getReadOnlyView = function() {};

/**
 * Gets a BitmapBuffer object that allows you to operate directly on the software bitmap's pixel data.
 * @param {Windows.Graphics.Imaging.BitmapBufferAccessMode} mode A value indicating the access mode of the returned buffer.
 * @return {!Windows.Graphics.Imaging.BitmapBuffer} The buffer containing pixel data.
 */
Windows.Graphics.Imaging.SoftwareBitmap.prototype.lockBuffer = function(mode) {};

/** @const */
Windows.Graphics.Imaging.TiffCompressionMode = {};
/** @const {number} */
Windows.Graphics.Imaging.TiffCompressionMode.automatic;
/** @const {number} */
Windows.Graphics.Imaging.TiffCompressionMode.none;
/** @const {number} */
Windows.Graphics.Imaging.TiffCompressionMode.ccitt3;
/** @const {number} */
Windows.Graphics.Imaging.TiffCompressionMode.ccitt4;
/** @const {number} */
Windows.Graphics.Imaging.TiffCompressionMode.lzw;
/** @const {number} */
Windows.Graphics.Imaging.TiffCompressionMode.rle;
/** @const {number} */
Windows.Graphics.Imaging.TiffCompressionMode.zip;
/** @const {number} */
Windows.Graphics.Imaging.TiffCompressionMode.lzwhDifferencing;
/**
 * @record
 * @struct
 */
Windows.Graphics.Imaging.BitmapPlaneDescription = function() {};
 /** @type {number} */
Windows.Graphics.Imaging.BitmapPlaneDescription.prototype.height;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapPlaneDescription.prototype.startIndex;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapPlaneDescription.prototype.stride;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapPlaneDescription.prototype.width;
/**
 * @record
 * @struct
 */
Windows.Graphics.Imaging.BitmapBounds = function() {};
 /** @type {number} */
Windows.Graphics.Imaging.BitmapBounds.prototype.height;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapBounds.prototype.width;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapBounds.prototype.x;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapBounds.prototype.y;
/**
 * @record
 * @struct
 */
Windows.Graphics.Imaging.BitmapSize = function() {};
 /** @type {number} */
Windows.Graphics.Imaging.BitmapSize.prototype.height;
 /** @type {number} */
Windows.Graphics.Imaging.BitmapSize.prototype.width;
/** @const */
Windows.Graphics.Printing = {};
 /** @type {void} */
Windows.Graphics.Printing.D;
/** @const */
Windows.Graphics.Printing.OptionDetails = {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails.prototype.errorText;
 /** @type {!Windows.Foundation.Collections.IVectorView<?>} */
Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails.prototype.items;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails.prototype.optionId;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionType} */
Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails.prototype.optionType;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionStates} */
Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails.prototype.state;
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails.prototype.value;

/**
 * Sets the value for the print binding option.
 * @param {?} value Value for the print binding option.
 * @return {boolean} Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
Windows.Graphics.Printing.OptionDetails.PrintBindingOptionDetails.prototype.trySetValue = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails.prototype.errorText;
 /** @type {!Windows.Foundation.Collections.IVectorView<?>} */
Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails.prototype.items;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails.prototype.optionId;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionType} */
Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails.prototype.optionType;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionStates} */
Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails.prototype.state;
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails.prototype.value;

/**
 * Sets the value for the print collation option.
 * @param {?} value Value for the print collation option.
 * @return {boolean} Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
Windows.Graphics.Printing.OptionDetails.PrintCollationOptionDetails.prototype.trySetValue = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails.prototype.errorText;
 /** @type {!Windows.Foundation.Collections.IVectorView<?>} */
Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails.prototype.items;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails.prototype.optionId;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionType} */
Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails.prototype.optionType;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionStates} */
Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails.prototype.state;
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails.prototype.value;

/**
 * Sets the value for the print color mode option.
 * @param {?} value Value for the print color mode option.
 * @return {boolean} Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
Windows.Graphics.Printing.OptionDetails.PrintColorModeOptionDetails.prototype.trySetValue = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails.prototype.errorText;
 /** @type {number} */
Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails.prototype.maxValue;
 /** @type {number} */
Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails.prototype.minValue;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails.prototype.optionId;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionType} */
Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails.prototype.optionType;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionStates} */
Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails.prototype.state;
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails.prototype.value;

/**
 * Sets the value for the print copies option.
 * @param {?} value Value for the print copies option.
 * @return {boolean} Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
Windows.Graphics.Printing.OptionDetails.PrintCopiesOptionDetails.prototype.trySetValue = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintCustomItemDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintCustomItemDetails.prototype.itemDisplayName;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintCustomItemDetails.prototype.itemId;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails.prototype.displayName;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails.prototype.errorText;
 /** @type {!Windows.Foundation.Collections.IVectorView<?>} */
Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails.prototype.items;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails.prototype.optionId;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionType} */
Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails.prototype.optionType;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionStates} */
Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails.prototype.state;
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails.prototype.value;

/**
 * Sets the ID or display name of an item in the list of custom print task options.
 * @param {string} itemId The ID of the option item.
 * @param {string} displayName The display name of the option item.
 * @return {void}
 */
Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails.prototype.addItem = function(itemId, displayName) {};

/**
 * Sets the value for the item ID or the display name of the custom item.
 * @param {?} value Value for the item ID or the display name of the custom item.
 * @return {boolean} Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails.prototype.trySetValue = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails.prototype.displayName;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails.prototype.errorText;
 /** @type {number} */
Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails.prototype.maxCharacters;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails.prototype.optionId;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionType} */
Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails.prototype.optionType;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionStates} */
Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails.prototype.state;
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails.prototype.value;

/**
 * Sets the value for the custom print task.
 * @param {?} value Value for the custom print task.
 * @return {boolean} Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails.prototype.trySetValue = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails.prototype.errorText;
 /** @type {!Windows.Foundation.Collections.IVectorView<?>} */
Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails.prototype.items;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails.prototype.optionId;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionType} */
Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails.prototype.optionType;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionStates} */
Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails.prototype.state;
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails.prototype.value;

/**
 * Sets the value for the duplex option.
 * @param {?} value Value for the duplex option.
 * @return {boolean} Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
Windows.Graphics.Printing.OptionDetails.PrintDuplexOptionDetails.prototype.trySetValue = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails.prototype.errorText;
 /** @type {!Windows.Foundation.Collections.IVectorView<?>} */
Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails.prototype.items;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails.prototype.optionId;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionType} */
Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails.prototype.optionType;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionStates} */
Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails.prototype.state;
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails.prototype.value;

/**
 * Sets the value for the hole punch option.
 * @param {?} value Value for the hole punch option.
 * @return {boolean} Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
Windows.Graphics.Printing.OptionDetails.PrintHolePunchOptionDetails.prototype.trySetValue = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails.prototype.errorText;
 /** @type {!Windows.Foundation.Collections.IVectorView<?>} */
Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails.prototype.items;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails.prototype.optionId;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionType} */
Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails.prototype.optionType;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionStates} */
Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails.prototype.state;
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails.prototype.value;

/**
 * Sets the value for the media size option.
 * @param {?} value Value for the media size option.
 * @return {boolean} Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
Windows.Graphics.Printing.OptionDetails.PrintMediaSizeOptionDetails.prototype.trySetValue = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails.prototype.errorText;
 /** @type {!Windows.Foundation.Collections.IVectorView<?>} */
Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails.prototype.items;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails.prototype.optionId;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionType} */
Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails.prototype.optionType;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionStates} */
Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails.prototype.state;
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails.prototype.value;

/**
 * Sets the value for the media type option.
 * @param {?} value Value for the media type option.
 * @return {boolean} Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
Windows.Graphics.Printing.OptionDetails.PrintMediaTypeOptionDetails.prototype.trySetValue = function(value) {};

/** @const */
Windows.Graphics.Printing.OptionDetails.PrintOptionStates = {};
/** @const {number} */
Windows.Graphics.Printing.OptionDetails.PrintOptionStates.none;
/** @const {number} */
Windows.Graphics.Printing.OptionDetails.PrintOptionStates.enabled;
/** @const {number} */
Windows.Graphics.Printing.OptionDetails.PrintOptionStates.constrained;

/** @const */
Windows.Graphics.Printing.OptionDetails.PrintOptionType = {};
/** @const {number} */
Windows.Graphics.Printing.OptionDetails.PrintOptionType.unknown;
/** @const {number} */
Windows.Graphics.Printing.OptionDetails.PrintOptionType.number;
/** @const {number} */
Windows.Graphics.Printing.OptionDetails.PrintOptionType.text;
/** @const {number} */
Windows.Graphics.Printing.OptionDetails.PrintOptionType.itemList;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails.prototype.errorText;
 /** @type {!Windows.Foundation.Collections.IVectorView<?>} */
Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails.prototype.items;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails.prototype.optionId;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionType} */
Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails.prototype.optionType;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionStates} */
Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails.prototype.state;
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails.prototype.value;

/**
 * Sets the value for the print orientation option.
 * @param {?} value Value for the print orientation option.
 * @return {boolean} Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
Windows.Graphics.Printing.OptionDetails.PrintOrientationOptionDetails.prototype.trySetValue = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails.prototype.errorText;
 /** @type {!Windows.Foundation.Collections.IVectorView<?>} */
Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails.prototype.items;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails.prototype.optionId;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionType} */
Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails.prototype.optionType;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionStates} */
Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails.prototype.state;
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails.prototype.value;

/**
 * Sets the value for the print quality option.
 * @param {?} value Value for the print quality option.
 * @return {boolean} Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
Windows.Graphics.Printing.OptionDetails.PrintQualityOptionDetails.prototype.trySetValue = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails.prototype.errorText;
 /** @type {!Windows.Foundation.Collections.IVectorView<?>} */
Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails.prototype.items;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails.prototype.optionId;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionType} */
Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails.prototype.optionType;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionStates} */
Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails.prototype.state;
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails.prototype.value;

/**
 * Sets the value for the staple opiton.
 * @param {?} value Value for the staple opiton.
 * @return {boolean} Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
Windows.Graphics.Printing.OptionDetails.PrintStapleOptionDetails.prototype.trySetValue = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs = function() {};
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs.prototype.optionId;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails.prototype.displayedOptions;
 /** @type {function(?): void} */
Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails.prototype.onbeginvalidation;
 /** @type {function(?): void} */
Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails.prototype.onoptionchanged;
 /** @type {!Windows.Foundation.Collections.IMapView<string, !Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails>} */
Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails.prototype.options;

/**
 * Used to retrieve the available options for a print task.
 * @param {!Windows.Graphics.Printing.PrintTaskOptions} printTaskOptions Pointer to a PrintTaskOptions object.
 * @return {!Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails} Pointer to a PrintTaskOptionDetails object.
 */
Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails.getFromPrintTaskOptions = function(printTaskOptions) {};

/**
 * Creates a custom list of items that allow the user to choose the page format.
 * @param {string} optionId The ID for the custom item.
 * @param {string} displayName The display name for the custom item.
 * @return {!Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails} The list of custom items.
 */
Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails.prototype.createItemListOption = function(optionId, displayName) {};

/**
 * Creates a CustomPrintTaskOptionText object to handle the display name and other parameters of the advanced print task option item.
 * @param {string} optionId The ID of the print task option.
 * @param {string} displayName The display name of the print task option.
 * @return {!Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails} The CustomPrintTaskOptionText object.
 */
Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails.prototype.createTextOption = function(optionId, displayName) {};

/**
 * Returns a PrintPageDescription object for the referenced page number.
 * @param {number} jobPageNumber The page number.
 * @return {!Windows.Graphics.Printing.PrintPageDescription} The PrintPageDescription object.
 */
Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails.prototype.getPageDescription = function(jobPageNumber) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails.prototype.removeEventListener = function(type, listener) {};
/**
 * @record
 * @struct
 */
Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails = function() {};
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails.prototype.errorText;
 /** @type {string} */
Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails.prototype.optionId;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionType} */
Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails.prototype.optionType;
 /** @type {Windows.Graphics.Printing.OptionDetails.PrintOptionStates} */
Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails.prototype.state;
 /** @type {?} */
Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails.prototype.value;

/**
 * Sets the value for the print task option.
 * @param {?} value Value for the print task option.
 * @return {boolean} Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
 */
Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails.prototype.trySetValue = function(value) {};

/** @const */
Windows.Graphics.Printing.PrintBinding = {};
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.default;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.notAvailable;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.printerCustom;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.none;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.bale;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.bindBottom;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.bindLeft;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.bindRight;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.bindTop;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.booklet;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.edgeStitchBottom;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.edgeStitchLeft;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.edgeStitchRight;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.edgeStitchTop;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.fold;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.jogOffset;
/** @const {number} */
Windows.Graphics.Printing.PrintBinding.trim;

/** @const */
Windows.Graphics.Printing.PrintCollation = {};
/** @const {number} */
Windows.Graphics.Printing.PrintCollation.default;
/** @const {number} */
Windows.Graphics.Printing.PrintCollation.notAvailable;
/** @const {number} */
Windows.Graphics.Printing.PrintCollation.printerCustom;
/** @const {number} */
Windows.Graphics.Printing.PrintCollation.collated;
/** @const {number} */
Windows.Graphics.Printing.PrintCollation.uncollated;

/** @const */
Windows.Graphics.Printing.PrintColorMode = {};
/** @const {number} */
Windows.Graphics.Printing.PrintColorMode.default;
/** @const {number} */
Windows.Graphics.Printing.PrintColorMode.notAvailable;
/** @const {number} */
Windows.Graphics.Printing.PrintColorMode.printerCustom;
/** @const {number} */
Windows.Graphics.Printing.PrintColorMode.color;
/** @const {number} */
Windows.Graphics.Printing.PrintColorMode.grayscale;
/** @const {number} */
Windows.Graphics.Printing.PrintColorMode.monochrome;

/** @const */
Windows.Graphics.Printing.PrintDuplex = {};
/** @const {number} */
Windows.Graphics.Printing.PrintDuplex.default;
/** @const {number} */
Windows.Graphics.Printing.PrintDuplex.notAvailable;
/** @const {number} */
Windows.Graphics.Printing.PrintDuplex.printerCustom;
/** @const {number} */
Windows.Graphics.Printing.PrintDuplex.oneSided;
/** @const {number} */
Windows.Graphics.Printing.PrintDuplex.twoSidedShortEdge;
/** @const {number} */
Windows.Graphics.Printing.PrintDuplex.twoSidedLongEdge;

/** @const */
Windows.Graphics.Printing.PrintHolePunch = {};
/** @const {number} */
Windows.Graphics.Printing.PrintHolePunch.default;
/** @const {number} */
Windows.Graphics.Printing.PrintHolePunch.notAvailable;
/** @const {number} */
Windows.Graphics.Printing.PrintHolePunch.printerCustom;
/** @const {number} */
Windows.Graphics.Printing.PrintHolePunch.none;
/** @const {number} */
Windows.Graphics.Printing.PrintHolePunch.leftEdge;
/** @const {number} */
Windows.Graphics.Printing.PrintHolePunch.rightEdge;
/** @const {number} */
Windows.Graphics.Printing.PrintHolePunch.topEdge;
/** @const {number} */
Windows.Graphics.Printing.PrintHolePunch.bottomEdge;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.PrintManager = function() {};
 /** @type {function(?): void} */
Windows.Graphics.Printing.PrintManager.prototype.onprinttaskrequested;

/**
 * Retrieves the PrintManager object associated with the current window.
 * @return {!Windows.Graphics.Printing.PrintManager} The PrintManager object.
 */
Windows.Graphics.Printing.PrintManager.getForCurrentView = function() {};

/**
 * Programmatically initiates the user interface for printing content.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} A Boolean value to indicate a TRUE for success or a FALSE for a failure.
 */
Windows.Graphics.Printing.PrintManager.showPrintUIAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Printing.PrintManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Printing.PrintManager.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Graphics.Printing.PrintMediaSize = {};
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.default;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.notAvailable;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.printerCustom;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.businessCard;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.creditCard;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA0;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA1;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA10;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA2;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA3;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA3Extra;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA3Rotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA4;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA4Extra;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA4Rotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA5;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA5Extra;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA5Rotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA6;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA6Rotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA7;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA8;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoA9;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoB0;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoB1;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoB10;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoB2;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoB3;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoB4;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoB4Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoB5Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoB5Extra;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoB7;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoB8;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoB9;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC0;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC1;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC10;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC2;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC3;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC3Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC4;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC4Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC5;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC5Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC6;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC6C5Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC6Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC7;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC8;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoC9;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoDLEnvelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoDLEnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.isoSRA3;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japan2LPhoto;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanChou3Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanChou3EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanChou4Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanChou4EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanDoubleHagakiPostcard;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanDoubleHagakiPostcardRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanHagakiPostcard;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanHagakiPostcardRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanKaku2Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanKaku2EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanKaku3Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanKaku3EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanLPhoto;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanQuadrupleHagakiPostcard;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanYou1Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanYou2Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanYou3Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanYou4Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanYou4EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanYou6Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.japanYou6EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.jisB0;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.jisB1;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.jisB10;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.jisB2;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.jisB3;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.jisB4;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.jisB4Rotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.jisB5;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.jisB5Rotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.jisB6;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.jisB6Rotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.jisB7;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.jisB8;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.jisB9;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmerica10x11;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmerica10x12;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmerica10x14;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmerica11x17;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmerica14x17;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmerica4x6;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmerica4x8;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmerica5x7;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmerica8x10;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmerica9x11;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaArchitectureASheet;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaArchitectureBSheet;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaArchitectureCSheet;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaArchitectureDSheet;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaArchitectureESheet;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaCSheet;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaDSheet;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaESheet;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaExecutive;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaGermanLegalFanfold;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaGermanStandardFanfold;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaLegal;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaLegalExtra;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaLetter;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaLetterExtra;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaLetterPlus;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaLetterRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaMonarchEnvelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaNote;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaNumber10Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaNumber10EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaNumber11Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaNumber12Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaNumber14Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaNumber9Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaPersonalEnvelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaQuarto;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaStatement;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaSuperA;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaSuperB;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaTabloid;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.northAmericaTabloidExtra;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.otherMetricA3Plus;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.otherMetricA4Plus;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.otherMetricFolio;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.otherMetricInviteEnvelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.otherMetricItalianEnvelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc10Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc10EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc16K;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc16KRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc1Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc1EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc2Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc2EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc32K;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc32KBig;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc32KRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc3Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc3EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc4Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc4EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc5Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc5EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc6Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc6EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc7Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc7EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc8Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc8EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc9Envelope;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.prc9EnvelopeRotated;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.roll04Inch;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.roll06Inch;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.roll08Inch;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.roll12Inch;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.roll15Inch;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.roll18Inch;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.roll22Inch;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.roll24Inch;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.roll30Inch;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.roll36Inch;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaSize.roll54Inch;

/** @const */
Windows.Graphics.Printing.PrintMediaType = {};
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.default;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.notAvailable;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.printerCustom;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.autoSelect;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.archival;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.backPrintFilm;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.bond;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.cardStock;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.continuous;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.envelopePlain;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.envelopeWindow;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.fabric;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.highResolution;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.label;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.multiLayerForm;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.multiPartForm;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.photographic;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.photographicFilm;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.photographicGlossy;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.photographicHighGloss;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.photographicMatte;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.photographicSatin;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.photographicSemiGloss;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.plain;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.screen;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.screenPaged;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.stationery;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.tabStockFull;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.tabStockPreCut;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.transparency;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.tshirtTransfer;
/** @const {number} */
Windows.Graphics.Printing.PrintMediaType.none;

/** @const */
Windows.Graphics.Printing.PrintOrientation = {};
/** @const {number} */
Windows.Graphics.Printing.PrintOrientation.default;
/** @const {number} */
Windows.Graphics.Printing.PrintOrientation.notAvailable;
/** @const {number} */
Windows.Graphics.Printing.PrintOrientation.printerCustom;
/** @const {number} */
Windows.Graphics.Printing.PrintOrientation.portrait;
/** @const {number} */
Windows.Graphics.Printing.PrintOrientation.portraitFlipped;
/** @const {number} */
Windows.Graphics.Printing.PrintOrientation.landscape;
/** @const {number} */
Windows.Graphics.Printing.PrintOrientation.landscapeFlipped;

/** @const */
Windows.Graphics.Printing.PrintQuality = {};
/** @const {number} */
Windows.Graphics.Printing.PrintQuality.default;
/** @const {number} */
Windows.Graphics.Printing.PrintQuality.notAvailable;
/** @const {number} */
Windows.Graphics.Printing.PrintQuality.printerCustom;
/** @const {number} */
Windows.Graphics.Printing.PrintQuality.automatic;
/** @const {number} */
Windows.Graphics.Printing.PrintQuality.draft;
/** @const {number} */
Windows.Graphics.Printing.PrintQuality.fax;
/** @const {number} */
Windows.Graphics.Printing.PrintQuality.high;
/** @const {number} */
Windows.Graphics.Printing.PrintQuality.normal;
/** @const {number} */
Windows.Graphics.Printing.PrintQuality.photographic;
/** @const {number} */
Windows.Graphics.Printing.PrintQuality.text;

/** @const */
Windows.Graphics.Printing.PrintStaple = {};
/** @const {number} */
Windows.Graphics.Printing.PrintStaple.default;
/** @const {number} */
Windows.Graphics.Printing.PrintStaple.notAvailable;
/** @const {number} */
Windows.Graphics.Printing.PrintStaple.printerCustom;
/** @const {number} */
Windows.Graphics.Printing.PrintStaple.none;
/** @const {number} */
Windows.Graphics.Printing.PrintStaple.stapleTopLeft;
/** @const {number} */
Windows.Graphics.Printing.PrintStaple.stapleTopRight;
/** @const {number} */
Windows.Graphics.Printing.PrintStaple.stapleBottomLeft;
/** @const {number} */
Windows.Graphics.Printing.PrintStaple.stapleBottomRight;
/** @const {number} */
Windows.Graphics.Printing.PrintStaple.stapleDualLeft;
/** @const {number} */
Windows.Graphics.Printing.PrintStaple.stapleDualRight;
/** @const {number} */
Windows.Graphics.Printing.PrintStaple.stapleDualTop;
/** @const {number} */
Windows.Graphics.Printing.PrintStaple.stapleDualBottom;
/** @const {number} */
Windows.Graphics.Printing.PrintStaple.saddleStitch;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.PrintTask = function() {};
 /** @type {boolean} */
Windows.Graphics.Printing.PrintTask.prototype.is3DManufacturingTargetEnabled;
 /** @type {boolean} */
Windows.Graphics.Printing.PrintTask.prototype.isPrinterTargetEnabled;
 /** @type {function(?): void} */
Windows.Graphics.Printing.PrintTask.prototype.oncompleted;
 /** @type {function(?): void} */
Windows.Graphics.Printing.PrintTask.prototype.onpreviewing;
 /** @type {function(?): void} */
Windows.Graphics.Printing.PrintTask.prototype.onprogressing;
 /** @type {function(?): void} */
Windows.Graphics.Printing.PrintTask.prototype.onsubmitting;
 /** @type {!Windows.Graphics.Printing.PrintTaskOptions} */
Windows.Graphics.Printing.PrintTask.prototype.options;
 /** @type {!Windows.ApplicationModel.DataTransfer.DataPackagePropertySet} */
Windows.Graphics.Printing.PrintTask.prototype.properties;
 /** @type {!Windows.Graphics.Printing.IPrintDocumentSource} */
Windows.Graphics.Printing.PrintTask.prototype.source;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Printing.PrintTask.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Printing.PrintTask.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.PrintTaskCompletedEventArgs = function() {};
 /** @type {Windows.Graphics.Printing.PrintTaskCompletion} */
Windows.Graphics.Printing.PrintTaskCompletedEventArgs.prototype.completion;

/** @const */
Windows.Graphics.Printing.PrintTaskCompletion = {};
/** @const {number} */
Windows.Graphics.Printing.PrintTaskCompletion.abandoned;
/** @const {number} */
Windows.Graphics.Printing.PrintTaskCompletion.canceled;
/** @const {number} */
Windows.Graphics.Printing.PrintTaskCompletion.failed;
/** @const {number} */
Windows.Graphics.Printing.PrintTaskCompletion.submitted;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.PrintTaskOptions = function() {};
 /** @type {Windows.Graphics.Printing.PrintBinding} */
Windows.Graphics.Printing.PrintTaskOptions.prototype.binding;
 /** @type {Windows.Graphics.Printing.PrintCollation} */
Windows.Graphics.Printing.PrintTaskOptions.prototype.collation;
 /** @type {Windows.Graphics.Printing.PrintColorMode} */
Windows.Graphics.Printing.PrintTaskOptions.prototype.colorMode;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Graphics.Printing.PrintTaskOptions.prototype.displayedOptions;
 /** @type {Windows.Graphics.Printing.PrintDuplex} */
Windows.Graphics.Printing.PrintTaskOptions.prototype.duplex;
 /** @type {Windows.Graphics.Printing.PrintHolePunch} */
Windows.Graphics.Printing.PrintTaskOptions.prototype.holePunch;
 /** @type {number} */
Windows.Graphics.Printing.PrintTaskOptions.prototype.maxCopies;
 /** @type {Windows.Graphics.Printing.PrintMediaSize} */
Windows.Graphics.Printing.PrintTaskOptions.prototype.mediaSize;
 /** @type {Windows.Graphics.Printing.PrintMediaType} */
Windows.Graphics.Printing.PrintTaskOptions.prototype.mediaType;
 /** @type {number} */
Windows.Graphics.Printing.PrintTaskOptions.prototype.minCopies;
 /** @type {number} */
Windows.Graphics.Printing.PrintTaskOptions.prototype.numberOfCopies;
 /** @type {Windows.Graphics.Printing.PrintOrientation} */
Windows.Graphics.Printing.PrintTaskOptions.prototype.orientation;
 /** @type {Windows.Graphics.Printing.PrintQuality} */
Windows.Graphics.Printing.PrintTaskOptions.prototype.printQuality;
 /** @type {Windows.Graphics.Printing.PrintStaple} */
Windows.Graphics.Printing.PrintTaskOptions.prototype.staple;

/**
 * Retrieves the physical dimensions of the printed page.
 * @param {number} jobPageNumber The page number.
 * @return {!Windows.Graphics.Printing.PrintPageDescription} The page description data.
 */
Windows.Graphics.Printing.PrintTaskOptions.prototype.getPageDescription = function(jobPageNumber) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.PrintTaskProgressingEventArgs = function() {};
 /** @type {number} */
Windows.Graphics.Printing.PrintTaskProgressingEventArgs.prototype.documentPageCount;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.PrintTaskRequest = function() {};
 /** @type {!Date} */
Windows.Graphics.Printing.PrintTaskRequest.prototype.deadline;

/**
 * Creates a new PrintTask which indicates that the app has content to be printed.
 * @param {string} title Title for the print task.
 * @param {function(!Windows.Graphics.Printing.PrintTaskSourceRequestedArgs): void} handler Pointer to a PrintTaskSourceRequestedHandler delegate for the print task.
 * @return {!Windows.Graphics.Printing.PrintTask} Pointer to the print task that was created.
 */
Windows.Graphics.Printing.PrintTaskRequest.prototype.createPrintTask = function(title, handler) {};

/**
 * Retrieves the deferral object associated with the PrintTaskRequest . The deferral object is used to handle asynchronous calls in the PrintTaskRequested event handler.
 * @return {!Windows.Graphics.Printing.PrintTaskRequestedDeferral} The PrintTaskRequestedDeferral for a print task.
 */
Windows.Graphics.Printing.PrintTaskRequest.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.PrintTaskRequestedDeferral = function() {};

/**
 * Indicates when the deferral for the print task request is over.
 * @return {void}
 */
Windows.Graphics.Printing.PrintTaskRequestedDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.PrintTaskRequestedEventArgs = function() {};
 /** @type {!Windows.Graphics.Printing.PrintTaskRequest} */
Windows.Graphics.Printing.PrintTaskRequestedEventArgs.prototype.request;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.PrintTaskSourceRequestedArgs = function() {};
 /** @type {!Date} */
Windows.Graphics.Printing.PrintTaskSourceRequestedArgs.prototype.deadline;

/**
 * Gets a PrintTaskSourceRequestedDeferral object that provides access to a Complete method. This method indicates then the deferral is over.
 * @return {!Windows.Graphics.Printing.PrintTaskSourceRequestedDeferral} Provides access to a Complete method.
 */
Windows.Graphics.Printing.PrintTaskSourceRequestedArgs.prototype.getDeferral = function() {};

/**
 * Informs the print task of the content to be printed.
 * @param {!Windows.Graphics.Printing.IPrintDocumentSource} source A pointer to the IPrintDocumentSource interface.
 * @return {void}
 */
Windows.Graphics.Printing.PrintTaskSourceRequestedArgs.prototype.setSource = function(source) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.PrintTaskSourceRequestedDeferral = function() {};

/**
 * Indicates when the deferral for a print task source request is over.
 * @return {void}
 */
Windows.Graphics.Printing.PrintTaskSourceRequestedDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing.StandardPrintTaskOptions = function() {};
 /** @type {string} */
Windows.Graphics.Printing.StandardPrintTaskOptions.binding;
 /** @type {string} */
Windows.Graphics.Printing.StandardPrintTaskOptions.collation;
 /** @type {string} */
Windows.Graphics.Printing.StandardPrintTaskOptions.colorMode;
 /** @type {string} */
Windows.Graphics.Printing.StandardPrintTaskOptions.copies;
 /** @type {string} */
Windows.Graphics.Printing.StandardPrintTaskOptions.duplex;
 /** @type {string} */
Windows.Graphics.Printing.StandardPrintTaskOptions.holePunch;
 /** @type {string} */
Windows.Graphics.Printing.StandardPrintTaskOptions.inputBin;
 /** @type {string} */
Windows.Graphics.Printing.StandardPrintTaskOptions.mediaSize;
 /** @type {string} */
Windows.Graphics.Printing.StandardPrintTaskOptions.mediaType;
 /** @type {string} */
Windows.Graphics.Printing.StandardPrintTaskOptions.nup;
 /** @type {string} */
Windows.Graphics.Printing.StandardPrintTaskOptions.orientation;
 /** @type {string} */
Windows.Graphics.Printing.StandardPrintTaskOptions.printQuality;
 /** @type {string} */
Windows.Graphics.Printing.StandardPrintTaskOptions.staple;
/**
 * @record
 * @struct
 */
Windows.Graphics.Printing.PrintPageDescription = function() {};
 /** @type {number} */
Windows.Graphics.Printing.PrintPageDescription.prototype.dpiX;
 /** @type {number} */
Windows.Graphics.Printing.PrintPageDescription.prototype.dpiY;
 /** @type {!Windows.Foundation.Rect} */
Windows.Graphics.Printing.PrintPageDescription.prototype.imageableRect;
 /** @type {!Windows.Foundation.Size} */
Windows.Graphics.Printing.PrintPageDescription.prototype.pageSize;
/**
 * @record
 * @struct
 */
Windows.Graphics.Printing.IPrintDocumentSource = function() {};

/** @typedef {function(!Windows.Graphics.Printing.PrintTaskSourceRequestedArgs): void} */
Windows.Graphics.Printing.PrintTaskSourceRequestedHandler;
/** @const */
Windows.Graphics.Printing3D = {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing3D.Print3DManager = function() {};
 /** @type {function(?): void} */
Windows.Graphics.Printing3D.Print3DManager.prototype.ontaskrequested;

/**
 * Gets a 3D print manager.
 * @return {!Windows.Graphics.Printing3D.Print3DManager} The 3D print manager.
 */
Windows.Graphics.Printing3D.Print3DManager.getForCurrentView = function() {};

/**
 * Programmatically initiates the 3D printing user interface.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} true if the operation completes successfully; otherwise, false.
 */
Windows.Graphics.Printing3D.Print3DManager.showPrintUIAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Printing3D.Print3DManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Printing3D.Print3DManager.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing3D.Print3DTask = function() {};
 /** @type {function(?): void} */
Windows.Graphics.Printing3D.Print3DTask.prototype.oncompleted;
 /** @type {function(?): void} */
Windows.Graphics.Printing3D.Print3DTask.prototype.onsourcechanged;
 /** @type {function(?): void} */
Windows.Graphics.Printing3D.Print3DTask.prototype.onsubmitting;
 /** @type {!Windows.Graphics.Printing3D.Printing3D3MFPackage} */
Windows.Graphics.Printing3D.Print3DTask.prototype.source;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Printing3D.Print3DTask.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Graphics.Printing3D.Print3DTask.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing3D.Print3DTaskCompletedEventArgs = function() {};
 /** @type {Windows.Graphics.Printing3D.Print3DTaskCompletion} */
Windows.Graphics.Printing3D.Print3DTaskCompletedEventArgs.prototype.completion;
 /** @type {Windows.Graphics.Printing3D.Print3DTaskDetail} */
Windows.Graphics.Printing3D.Print3DTaskCompletedEventArgs.prototype.extendedStatus;

/** @const */
Windows.Graphics.Printing3D.Print3DTaskCompletion = {};
/** @const {number} */
Windows.Graphics.Printing3D.Print3DTaskCompletion.abandoned;
/** @const {number} */
Windows.Graphics.Printing3D.Print3DTaskCompletion.canceled;
/** @const {number} */
Windows.Graphics.Printing3D.Print3DTaskCompletion.failed;
/** @const {number} */
Windows.Graphics.Printing3D.Print3DTaskCompletion.slicing;
/** @const {number} */
Windows.Graphics.Printing3D.Print3DTaskCompletion.submitted;

/** @const */
Windows.Graphics.Printing3D.Print3DTaskDetail = {};
/** @const {number} */
Windows.Graphics.Printing3D.Print3DTaskDetail.unknown;
/** @const {number} */
Windows.Graphics.Printing3D.Print3DTaskDetail.modelExceedsPrintBed;
/** @const {number} */
Windows.Graphics.Printing3D.Print3DTaskDetail.uploadFailed;
/** @const {number} */
Windows.Graphics.Printing3D.Print3DTaskDetail.invalidMaterialSelection;
/** @const {number} */
Windows.Graphics.Printing3D.Print3DTaskDetail.invalidModel;
/** @const {number} */
Windows.Graphics.Printing3D.Print3DTaskDetail.modelNotManifold;
/** @const {number} */
Windows.Graphics.Printing3D.Print3DTaskDetail.invalidPrintTicket;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing3D.Print3DTaskRequest = function() {};

/**
 * Creates a 3D print job.
 * @param {string} title The name of the print job.
 * @param {string} printerId The identifier of the 3D printer.
 * @param {function(!Windows.Graphics.Printing3D.Print3DTaskSourceRequestedArgs): void} handler The callback for the source of the print job request.
 * @return {!Windows.Graphics.Printing3D.Print3DTask} The 3D print job.
 */
Windows.Graphics.Printing3D.Print3DTaskRequest.prototype.createTask = function(title, printerId, handler) {};
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing3D.Print3DTaskRequestedEventArgs = function() {};
 /** @type {!Windows.Graphics.Printing3D.Print3DTaskRequest} */
Windows.Graphics.Printing3D.Print3DTaskRequestedEventArgs.prototype.request;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing3D.Print3DTaskSourceChangedEventArgs = function() {};
 /** @type {!Windows.Graphics.Printing3D.Printing3D3MFPackage} */
Windows.Graphics.Printing3D.Print3DTaskSourceChangedEventArgs.prototype.source;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing3D.Print3DTaskSourceRequestedArgs = function() {};

/**
 * Specifies the 3D Manufacturing Format (3MF) package to use in the print job.
 * @param {!Windows.Graphics.Printing3D.Printing3D3MFPackage} source The 3D Manufacturing Format (3MF) package to use in the print job.
 * @return {void}
 */
Windows.Graphics.Printing3D.Print3DTaskSourceRequestedArgs.prototype.setSource = function(source) {};

/**
 * @constructor
 * @struct
 * Creates a Printing3D3MFPackage object.
 */
Windows.Graphics.Printing3D.Printing3D3MFPackage = function() {};
 /** @type {!Windows.Storage.Streams.IRandomAccessStream} */
Windows.Graphics.Printing3D.Printing3D3MFPackage.prototype.modelPart;
 /** @type {!Windows.Storage.Streams.IRandomAccessStream} */
Windows.Graphics.Printing3D.Printing3D3MFPackage.prototype.printTicket;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DTextureResource>} */
Windows.Graphics.Printing3D.Printing3D3MFPackage.prototype.textures;
 /** @type {!Windows.Graphics.Printing3D.Printing3DTextureResource} */
Windows.Graphics.Printing3D.Printing3D3MFPackage.prototype.thumbnail;

/**
 * Creates a Printing3D3MFPackage object from a 3D Manufacturing Format (3MF) file stream.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} value A 3MF file stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Printing3D.Printing3D3MFPackage, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Printing3D.Printing3D3MFPackage>>} A Printing3D3MFPackage created from the specified 3MF package stream.
 */
Windows.Graphics.Printing3D.Printing3D3MFPackage.loadAsync = function(value) {};

/**
 * Creates a Printing3DModel object from a 3D Manufacturing Format (3MF) file stream.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} value A 3MF file stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Printing3D.Printing3DModel, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Printing3D.Printing3DModel>>} A Printing3DModel object created from the specified 3MF object stream.
 */
Windows.Graphics.Printing3D.Printing3D3MFPackage.prototype.loadModelFromPackageAsync = function(value) {};

/**
 * Saves the Printing3D3MFPackage object to a 3D Manufacturing Format (3MF) file stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStream, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStream>>} A stream to the 3MF file where the package is to be saved.
 */
Windows.Graphics.Printing3D.Printing3D3MFPackage.prototype.saveAsync = function() {};

/**
 * Saves the specified 3D model to the 3D Manufacturing Format (3MF) package.
 * @param {!Windows.Graphics.Printing3D.Printing3DModel} value The 3D model to be saved to the 3MF package.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The results of the operation.
 */
Windows.Graphics.Printing3D.Printing3D3MFPackage.prototype.saveModelToPackageAsync = function(value) {};

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DBaseMaterial class.
 */
Windows.Graphics.Printing3D.Printing3DBaseMaterial = function() {};
 /** @type {string} */
Windows.Graphics.Printing3D.Printing3DBaseMaterial.abs;
 /** @type {string} */
Windows.Graphics.Printing3D.Printing3DBaseMaterial.pla;
 /** @type {!Windows.Graphics.Printing3D.Printing3DColorMaterial} */
Windows.Graphics.Printing3D.Printing3DBaseMaterial.prototype.color;
 /** @type {string} */
Windows.Graphics.Printing3D.Printing3DBaseMaterial.prototype.name;

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DBaseMaterialGroup class.
 * @param {number} MaterialGroupId The identifier for the group of base materials used in the 3D model; a value greater than zero.
 */
Windows.Graphics.Printing3D.Printing3DBaseMaterialGroup = function(MaterialGroupId) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DBaseMaterial>} */
Windows.Graphics.Printing3D.Printing3DBaseMaterialGroup.prototype.bases;
 /** @type {number} */
Windows.Graphics.Printing3D.Printing3DBaseMaterialGroup.prototype.materialGroupId;

/** @const */
Windows.Graphics.Printing3D.Printing3DBufferFormat = {};
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DBufferFormat.unknown;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DBufferFormat.r32G32B32A32Float;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DBufferFormat.r32G32B32A32UInt;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DBufferFormat.r32G32B32Float;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DBufferFormat.r32G32B32UInt;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DBufferFormat.printing3DDouble;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DBufferFormat.printing3DUInt;

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DColorMaterial class.
 */
Windows.Graphics.Printing3D.Printing3DColorMaterial = function() {};
 /** @type {!Windows.UI.Color} */
Windows.Graphics.Printing3D.Printing3DColorMaterial.prototype.color;
 /** @type {number} */
Windows.Graphics.Printing3D.Printing3DColorMaterial.prototype.value;

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DColorMaterialGroup class.
 * @param {number} MaterialGroupId The identifier for the group of color materials used in the 3D model; a value greater than zero.
 */
Windows.Graphics.Printing3D.Printing3DColorMaterialGroup = function(MaterialGroupId) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DColorMaterial>} */
Windows.Graphics.Printing3D.Printing3DColorMaterialGroup.prototype.colors;
 /** @type {number} */
Windows.Graphics.Printing3D.Printing3DColorMaterialGroup.prototype.materialGroupId;

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DComponent class.
 */
Windows.Graphics.Printing3D.Printing3DComponent = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DComponentWithMatrix>} */
Windows.Graphics.Printing3D.Printing3DComponent.prototype.components;
 /** @type {!Windows.Graphics.Printing3D.Printing3DMesh} */
Windows.Graphics.Printing3D.Printing3DComponent.prototype.mesh;
 /** @type {string} */
Windows.Graphics.Printing3D.Printing3DComponent.prototype.name;
 /** @type {string} */
Windows.Graphics.Printing3D.Printing3DComponent.prototype.partNumber;
 /** @type {!Windows.Graphics.Printing3D.Printing3DTextureResource} */
Windows.Graphics.Printing3D.Printing3DComponent.prototype.thumbnail;
 /** @type {Windows.Graphics.Printing3D.Printing3DObjectType} */
Windows.Graphics.Printing3D.Printing3DComponent.prototype.type;

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DComponentWithMatrix class.
 */
Windows.Graphics.Printing3D.Printing3DComponentWithMatrix = function() {};
 /** @type {!Windows.Graphics.Printing3D.Printing3DComponent} */
Windows.Graphics.Printing3D.Printing3DComponentWithMatrix.prototype.component;
 /** @type {!Windows.Foundation.Numerics.Matrix4x4} */
Windows.Graphics.Printing3D.Printing3DComponentWithMatrix.prototype.matrix;

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DCompositeMaterial class.
 */
Windows.Graphics.Printing3D.Printing3DCompositeMaterial = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<number>} */
Windows.Graphics.Printing3D.Printing3DCompositeMaterial.prototype.values;

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DCompositeMaterialGroup class.
 * @param {number} MaterialGroupId The identifier (ID) of the composite material group; a value greater than zero.
 */
Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup = function(MaterialGroupId) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DCompositeMaterial>} */
Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup.prototype.composites;
 /** @type {number} */
Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup.prototype.materialGroupId;
 /** @type {!Windows.Foundation.Collections.IVector<number>} */
Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup.prototype.materialIndices;

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DMaterial class.
 */
Windows.Graphics.Printing3D.Printing3DMaterial = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DBaseMaterialGroup>} */
Windows.Graphics.Printing3D.Printing3DMaterial.prototype.baseGroups;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DColorMaterialGroup>} */
Windows.Graphics.Printing3D.Printing3DMaterial.prototype.colorGroups;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup>} */
Windows.Graphics.Printing3D.Printing3DMaterial.prototype.compositeGroups;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterialGroup>} */
Windows.Graphics.Printing3D.Printing3DMaterial.prototype.multiplePropertyGroups;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterialGroup>} */
Windows.Graphics.Printing3D.Printing3DMaterial.prototype.texture2CoordGroups;

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DMesh class.
 */
Windows.Graphics.Printing3D.Printing3DMesh = function() {};
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.bufferDescriptionSet;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.bufferSet;
 /** @type {number} */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.indexCount;
 /** @type {!Windows.Graphics.Printing3D.Printing3DBufferDescription} */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.triangleIndicesDescription;
 /** @type {!Windows.Graphics.Printing3D.Printing3DBufferDescription} */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.triangleMaterialIndicesDescription;
 /** @type {number} */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.vertexCount;
 /** @type {!Windows.Graphics.Printing3D.Printing3DBufferDescription} */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.vertexNormalsDescription;
 /** @type {!Windows.Graphics.Printing3D.Printing3DBufferDescription} */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.vertexPositionsDescription;

/**
 * Creates the buffer for triangle indices.
 * @param {number} value The capacity of the buffer, the maximum number of bytes that the IBuffer can hold.
 * @return {void}
 */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.createTriangleIndices = function(value) {};

/**
 * Creates the buffer for triangle material indices.
 * @param {number} value The capacity of the buffer, the maximum number of bytes that the IBuffer can hold.
 * @return {void}
 */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.createTriangleMaterialIndices = function(value) {};

/**
 * Creates the buffer for vertex normals.
 * @param {number} value The capacity of the buffer, the maximum number of bytes that the IBuffer can hold.
 * @return {void}
 */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.createVertexNormals = function(value) {};

/**
 * Creates the buffer for vertex positions.
 * @param {number} value The capacity of the buffer, the maximum number of bytes that the IBuffer can hold.
 * @return {void}
 */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.createVertexPositions = function(value) {};

/**
 * Gets the buffer for triangle indices.
 * @return {!Windows.Storage.Streams.IBuffer} The buffer for triangle indices.
 */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.getTriangleIndices = function() {};

/**
 * Gets the buffer for triangle material indices.
 * @return {!Windows.Storage.Streams.IBuffer} The buffer for triangle material indices.
 */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.getTriangleMaterialIndices = function() {};

/**
 * Gets the buffer for vertex normals.
 * @return {!Windows.Storage.Streams.IBuffer} The buffer for vertex normals.
 */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.getVertexNormals = function() {};

/**
 * Gets the buffer for vertex positions.
 * @return {!Windows.Storage.Streams.IBuffer} The buffer for vertex positions.
 */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.getVertexPositions = function() {};

/**
 * Verifies the mesh has manifold edges and normal triangles.
 * @param {Windows.Graphics.Printing3D.Printing3DMeshVerificationMode} value Specifies how the mesh is verified.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Printing3D.Printing3DMeshVerificationResult, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Printing3D.Printing3DMeshVerificationResult>>} The results of the verification, of type Printing3DMeshVerificationResult .
 */
Windows.Graphics.Printing3D.Printing3DMesh.prototype.verifyAsync = function(value) {};

/** @const */
Windows.Graphics.Printing3D.Printing3DMeshVerificationMode = {};
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DMeshVerificationMode.findFirstError;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DMeshVerificationMode.findAllErrors;
/**
 * @constructor
 * @struct
 */
Windows.Graphics.Printing3D.Printing3DMeshVerificationResult = function() {};
 /** @type {boolean} */
Windows.Graphics.Printing3D.Printing3DMeshVerificationResult.prototype.isValid;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Graphics.Printing3D.Printing3DMeshVerificationResult.prototype.nonmanifoldTriangles;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Graphics.Printing3D.Printing3DMeshVerificationResult.prototype.reversedNormalTriangles;

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DModel class.
 */
Windows.Graphics.Printing3D.Printing3DModel = function() {};
 /** @type {!Windows.Graphics.Printing3D.Printing3DComponent} */
Windows.Graphics.Printing3D.Printing3DModel.prototype.build;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DComponent>} */
Windows.Graphics.Printing3D.Printing3DModel.prototype.components;
 /** @type {!Windows.Graphics.Printing3D.Printing3DMaterial} */
Windows.Graphics.Printing3D.Printing3DModel.prototype.material;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DMesh>} */
Windows.Graphics.Printing3D.Printing3DModel.prototype.meshes;
 /** @type {!Windows.Foundation.Collections.IMap<string, string>} */
Windows.Graphics.Printing3D.Printing3DModel.prototype.metadata;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Graphics.Printing3D.Printing3DModel.prototype.requiredExtensions;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DModelTexture>} */
Windows.Graphics.Printing3D.Printing3DModel.prototype.textures;
 /** @type {Windows.Graphics.Printing3D.Printing3DModelUnit} */
Windows.Graphics.Printing3D.Printing3DModel.prototype.unit;
 /** @type {string} */
Windows.Graphics.Printing3D.Printing3DModel.prototype.version;

/**
 * Gets a copy of the current 3D model.
 * @return {!Windows.Graphics.Printing3D.Printing3DModel} A copy of the current 3D model.
 */
Windows.Graphics.Printing3D.Printing3DModel.prototype.clone = function() {};

/**
 * Repairs the 3D model.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Results of the operation.
 */
Windows.Graphics.Printing3D.Printing3DModel.prototype.repairAsync = function() {};

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DModelTexture class.
 */
Windows.Graphics.Printing3D.Printing3DModelTexture = function() {};
 /** @type {!Windows.Graphics.Printing3D.Printing3DTextureResource} */
Windows.Graphics.Printing3D.Printing3DModelTexture.prototype.textureResource;
 /** @type {Windows.Graphics.Printing3D.Printing3DTextureEdgeBehavior} */
Windows.Graphics.Printing3D.Printing3DModelTexture.prototype.tileStyleU;
 /** @type {Windows.Graphics.Printing3D.Printing3DTextureEdgeBehavior} */
Windows.Graphics.Printing3D.Printing3DModelTexture.prototype.tileStyleV;

/** @const */
Windows.Graphics.Printing3D.Printing3DModelUnit = {};
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DModelUnit.meter;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DModelUnit.micron;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DModelUnit.millimeter;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DModelUnit.centimeter;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DModelUnit.inch;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DModelUnit.foot;

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DMultiplePropertyMaterial class.
 */
Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterial = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<number>} */
Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterial.prototype.materialIndices;

/**
 * @constructor
 * @struct
 * Creates a new instance of the Printing3DMultiplePropertyMaterialGroup class.
 * @param {number} MaterialGroupId The identifier (ID) of the multi-property material group; a value greater than zero.
 */
Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterialGroup = function(MaterialGroupId) {};
 /** @type {number} */
Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterialGroup.prototype.materialGroupId;
 /** @type {!Windows.Foundation.Collections.IVector<number>} */
Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterialGroup.prototype.materialGroupIndices;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterial>} */
Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterialGroup.prototype.multipleProperties;

/** @const */
Windows.Graphics.Printing3D.Printing3DObjectType = {};
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DObjectType.model;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DObjectType.support;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DObjectType.others;

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DTexture2CoordMaterial class.
 */
Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial = function() {};
 /** @type {!Windows.Graphics.Printing3D.Printing3DModelTexture} */
Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial.prototype.texture;
 /** @type {number} */
Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial.prototype.u;
 /** @type {number} */
Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial.prototype.v;

/**
 * @constructor
 * @struct
 * Creates a instance of the Printing3DTexture2CoordMaterialGroup class.
 * @param {number} MaterialGroupId The identifier for a group of 2D texture materials used in the 3D model; a value greater than zero.
 */
Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterialGroup = function(MaterialGroupId) {};
 /** @type {number} */
Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterialGroup.prototype.materialGroupId;
 /** @type {!Windows.Graphics.Printing3D.Printing3DModelTexture} */
Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterialGroup.prototype.texture;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial>} */
Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterialGroup.prototype.texture2Coords;

/** @const */
Windows.Graphics.Printing3D.Printing3DTextureEdgeBehavior = {};
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DTextureEdgeBehavior.none;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DTextureEdgeBehavior.wrap;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DTextureEdgeBehavior.mirror;
/** @const {number} */
Windows.Graphics.Printing3D.Printing3DTextureEdgeBehavior.clamp;

/**
 * @constructor
 * @struct
 * Creates an instance of the Printing3DTextureResource class.
 */
Windows.Graphics.Printing3D.Printing3DTextureResource = function() {};
 /** @type {string} */
Windows.Graphics.Printing3D.Printing3DTextureResource.prototype.name;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamWithContentType} */
Windows.Graphics.Printing3D.Printing3DTextureResource.prototype.textureData;

/** @typedef {function(!Windows.Graphics.Printing3D.Print3DTaskSourceRequestedArgs): void} */
Windows.Graphics.Printing3D.Print3DTaskSourceRequestedHandler;
/**
 * @record
 * @struct
 */
Windows.Graphics.Printing3D.Printing3DBufferDescription = function() {};
 /** @type {Windows.Graphics.Printing3D.Printing3DBufferFormat} */
Windows.Graphics.Printing3D.Printing3DBufferDescription.prototype.format;
 /** @type {number} */
Windows.Graphics.Printing3D.Printing3DBufferDescription.prototype.stride;
/** @const */
Windows.Management = {};
/** @const */
Windows.Management.Core = {};
/**
 * @constructor
 * @struct
 */
Windows.Management.Core.ApplicationDataManager = function() {};

/**
 * Provides access to the app data store for the specified package family.
 * @param {string} packageFamilyName The package family name.
 * @return {!Windows.Storage.ApplicationData} The app data store.
 */
Windows.Management.Core.ApplicationDataManager.createForPackageFamily = function(packageFamilyName) {};
/** @const */
Windows.Management.Deployment = {};

/** @const */
Windows.Management.Deployment.DeploymentOptions = {};
/** @const {number} */
Windows.Management.Deployment.DeploymentOptions.none;
/** @const {number} */
Windows.Management.Deployment.DeploymentOptions.forceApplicationShutdown;
/** @const {number} */
Windows.Management.Deployment.DeploymentOptions.developmentMode;
/** @const {number} */
Windows.Management.Deployment.DeploymentOptions.installAllResources;
/** @const {number} */
Windows.Management.Deployment.DeploymentOptions.forceTargetApplicationShutdown;

/** @const */
Windows.Management.Deployment.DeploymentProgressState = {};
/** @const {number} */
Windows.Management.Deployment.DeploymentProgressState.queued;
/** @const {number} */
Windows.Management.Deployment.DeploymentProgressState.processing;
/**
 * @constructor
 * @struct
 */
Windows.Management.Deployment.DeploymentResult = function() {};
 /** @type {string} */
Windows.Management.Deployment.DeploymentResult.prototype.activityId;
 /** @type {string} */
Windows.Management.Deployment.DeploymentResult.prototype.errorText;
 /** @type {!Windows.WinRTError} */
Windows.Management.Deployment.DeploymentResult.prototype.extendedErrorCode;

/** @const */
Windows.Management.Deployment.PackageInstallState = {};
/** @const {number} */
Windows.Management.Deployment.PackageInstallState.notInstalled;
/** @const {number} */
Windows.Management.Deployment.PackageInstallState.staged;
/** @const {number} */
Windows.Management.Deployment.PackageInstallState.installed;
/** @const {number} */
Windows.Management.Deployment.PackageInstallState.paused;

/** @const */
Windows.Management.Deployment.PackageState = {};
/** @const {number} */
Windows.Management.Deployment.PackageState.normal;
/** @const {number} */
Windows.Management.Deployment.PackageState.licenseInvalid;
/** @const {number} */
Windows.Management.Deployment.PackageState.modified;
/** @const {number} */
Windows.Management.Deployment.PackageState.tampered;

/** @const */
Windows.Management.Deployment.PackageStatus = {};
/** @const {number} */
Windows.Management.Deployment.PackageStatus.ok;
/** @const {number} */
Windows.Management.Deployment.PackageStatus.licenseIssue;
/** @const {number} */
Windows.Management.Deployment.PackageStatus.modified;
/** @const {number} */
Windows.Management.Deployment.PackageStatus.tampered;
/** @const {number} */
Windows.Management.Deployment.PackageStatus.disabled;

/** @const */
Windows.Management.Deployment.PackageTypes = {};
/** @const {number} */
Windows.Management.Deployment.PackageTypes.none;
/** @const {number} */
Windows.Management.Deployment.PackageTypes.main;
/** @const {number} */
Windows.Management.Deployment.PackageTypes.framework;
/** @const {number} */
Windows.Management.Deployment.PackageTypes.resource;
/** @const {number} */
Windows.Management.Deployment.PackageTypes.bundle;
/** @const {number} */
Windows.Management.Deployment.PackageTypes.xap;
/**
 * @constructor
 * @struct
 */
Windows.Management.Deployment.PackageUserInformation = function() {};
 /** @type {Windows.Management.Deployment.PackageInstallState} */
Windows.Management.Deployment.PackageUserInformation.prototype.installState;
 /** @type {string} */
Windows.Management.Deployment.PackageUserInformation.prototype.userSecurityId;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PackageVolume class.
 */
Windows.Management.Deployment.PackageVolume = function() {};
 /** @type {boolean} */
Windows.Management.Deployment.PackageVolume.prototype.isOffline;
 /** @type {boolean} */
Windows.Management.Deployment.PackageVolume.prototype.isSystemVolume;
 /** @type {string} */
Windows.Management.Deployment.PackageVolume.prototype.mountPoint;
 /** @type {string} */
Windows.Management.Deployment.PackageVolume.prototype.name;
 /** @type {string} */
Windows.Management.Deployment.PackageVolume.prototype.packageStorePath;
 /** @type {boolean} */
Windows.Management.Deployment.PackageVolume.prototype.supportsHardLinks;

/**
 * Gets a collection of info about all installed instances of the specified package for all registered users.
 * @param {string} packageFullName The full name of the package.
 * @return {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Package>} A collection of info about all installed instances of the specified package for all registered users.
 */
Windows.Management.Deployment.PackageVolume.prototype.findPackage = function(packageFullName) {};

/**
 * Gets a collection of info about the installed instances of the specified package for the specified user or users.
 * @param {string} userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
 * @param {string} packageFullName The full name of the package.
 * @return {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Package>} A collection of info about all installed instances of the specified package for the specified user or users.
 */
Windows.Management.Deployment.PackageVolume.prototype.findPackageForUser = function(userSecurityId, packageFullName) {};

/**
 * Gets a collection of info about all installed instances of all packages for all registered users.
 * Gets a collection of info about all installed instances of the specified package from the specified publisher for all registered users.
 * Gets a collection of info about all installed instances of the specified package for all registered users.
 * @param {string=} packageName_or_packageFamilyName The full name of the package. / The package family name of the package.
 * @param {string=} packagePublisher The publisher of the package.
 * @return {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Package>} A collection of info about the specified packages.
 */
Windows.Management.Deployment.PackageVolume.prototype.findPackages = function(packageName_or_packageFamilyName, packagePublisher) {};

/**
 * Gets a collection of info about all installed instances of the specified package for the specified user or users.
 * Gets a collection of info about all installed instances of the specified package from the specified publisher for the specified user or users.
 * Gets a collection of info about all installed instances of all packages for the specified user or users.
 * @param {string} userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
 * @param {string=} packageFamilyName_or_packageName The package family name. / The full name of the package.
 * @param {string=} packagePublisher The publisher of the package.
 * @return {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Package>} A collection of info about the specified packages.
 */
Windows.Management.Deployment.PackageVolume.prototype.findPackagesForUser = function(userSecurityId, packageFamilyName_or_packageName, packagePublisher) {};

/**
 * Gets a collection of info about all installed instances of all packages for the specified user or users and with the specified package types.
 * Gets a collection of info about all installed instances of the specified package for the specified user or users and with the specified package types.
 * Gets a collection of info about all installed instances of the specified package for the specified user or users and with the specified package types.
 * @param {string} userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
 * @param {Windows.Management.Deployment.PackageTypes} packageTypes A bitwise combination of the enumeration values that specifies the types of packages to return.
 * @param {string=} packageName_or_packageFamilyName The full name of the package. / The package family name.
 * @param {string=} packagePublisher The publisher of the package.
 * @return {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Package>} A collection of info about the specified packages.
 */
Windows.Management.Deployment.PackageVolume.prototype.findPackagesForUserWithPackageTypes = function(userSecurityId, packageTypes, packageName_or_packageFamilyName, packagePublisher) {};

/**
 * Gets a collection of info about all installed instances of the specified package with the specified package types for all registered users.
 * Gets a collection of info about all installed instances of all packages with the specified package types for all registered users.
 * Gets a collection of info about all installed instances of the specified package from the specified publisher with the specified package types for all registered users.
 * @param {Windows.Management.Deployment.PackageTypes} packageTypes A bitwise combination of the enumeration values that specifies the types of packages to return.
 * @param {string=} packageFamilyName_or_packageName The package family name. / The full name of the package.
 * @param {string=} packagePublisher The publisher of the package.
 * @return {!Windows.Foundation.Collections.IVector<!Windows.ApplicationModel.Package>} A collection of info about the specified packages.
 */
Windows.Management.Deployment.PackageVolume.prototype.findPackagesWithPackageTypes = function(packageTypes, packageFamilyName_or_packageName, packagePublisher) {};
/** @const */
Windows.Management.Deployment.Preview = {};
/**
 * @constructor
 * @struct
 */
Windows.Management.Deployment.Preview.ClassicAppManager = function() {};
 /** @type {?} */
Windows.Management.Deployment.Preview.ClassicAppManager.findInstalledApp;
/**
 * @constructor
 * @struct
 */
Windows.Management.Deployment.Preview.InstalledClassicAppInfo = function() {};
 /** @type {?} */
Windows.Management.Deployment.Preview.InstalledClassicAppInfo.prototype.displayName;
 /** @type {?} */
Windows.Management.Deployment.Preview.InstalledClassicAppInfo.prototype.displayVersion;

/** @const */
Windows.Management.Deployment.RemovalOptions = {};
/** @const {number} */
Windows.Management.Deployment.RemovalOptions.none;
/** @const {number} */
Windows.Management.Deployment.RemovalOptions.preserveApplicationData;
/** @const */
Windows.Management.Orchestration = {};
/**
 * @constructor
 * @struct
 */
Windows.Management.Orchestration.CurrentAppOrchestration = function() {};
 /** @type {?} */
Windows.Management.Orchestration.CurrentAppOrchestration.getForCurrentView;
 /** @type {?} */
Windows.Management.Orchestration.CurrentAppOrchestration.prototype.startSingleAppMode;
/**
 * @constructor
 * @struct
 */
Windows.Management.Orchestration.SingleAppModeContext = function() {};
 /** @type {?} */
Windows.Management.Orchestration.SingleAppModeContext.prototype.close;
/** @const */
Windows.Management.Workplace = {};
/**
 * @constructor
 * @struct
 */
Windows.Management.Workplace.MdmPolicy = function() {};

/**
 * Returns true if a browser is allowed.
 * @return {boolean} true if a browser is allowed.
 */
Windows.Management.Workplace.MdmPolicy.isBrowserAllowed = function() {};

/**
 * Returns true if a camera is allowed.
 * @return {boolean} true if a camera is allowed.
 */
Windows.Management.Workplace.MdmPolicy.isCameraAllowed = function() {};

/**
 * Returns true if a Microsoft Account is allowed.
 * @return {boolean} true if a Microsoft Account is allowed.
 */
Windows.Management.Workplace.MdmPolicy.isMicrosoftAccountAllowed = function() {};

/**
 * Returns true if a Store is allowed.
 * @return {boolean} true if a Store is allowed.
 */
Windows.Management.Workplace.MdmPolicy.isStoreAllowed = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Management.Workplace.WorkplaceSettings = function() {};
 /** @type {boolean} */
Windows.Management.Workplace.WorkplaceSettings.isMicrosoftAccountOptional;
/** @const */
Windows.Media.Audio = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.AudioDeviceInputNode = function() {};
 /** @type {boolean} */
Windows.Media.Audio.AudioDeviceInputNode.prototype.consumeInput;
 /** @type {!Windows.Devices.Enumeration.DeviceInformation} */
Windows.Media.Audio.AudioDeviceInputNode.prototype.device;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Effects.IAudioEffectDefinition>} */
Windows.Media.Audio.AudioDeviceInputNode.prototype.effectDefinitions;
 /** @type {!Windows.Media.MediaProperties.AudioEncodingProperties} */
Windows.Media.Audio.AudioDeviceInputNode.prototype.encodingProperties;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Audio.AudioGraphConnection>} */
Windows.Media.Audio.AudioDeviceInputNode.prototype.outgoingConnections;
 /** @type {number} */
Windows.Media.Audio.AudioDeviceInputNode.prototype.outgoingGain;

/**
 * Adds an outgoing connection with gain to the audio device input node.
 * Adds an outgoing connection to the audio device input node.
 * @param {!Windows.Media.Audio.IAudioNode} destination The destination node for the connection.
 * @param {number=} gain A value indicating the gain associated with the connection.
 * @return {void}
 */
Windows.Media.Audio.AudioDeviceInputNode.prototype.addOutgoingConnection = function(destination, gain) {};

/**
 * Closes the audio device input node.
 * @return {void}
 */
Windows.Media.Audio.AudioDeviceInputNode.prototype.close = function() {};

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to disable.
 * @return {void}
 */
Windows.Media.Audio.AudioDeviceInputNode.prototype.disableEffectsByDefinition = function(definition) {};

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to enable.
 * @return {void}
 */
Windows.Media.Audio.AudioDeviceInputNode.prototype.enableEffectsByDefinition = function(definition) {};

/**
 * Removes the outgoing connection for the audio device input node.
 * @param {!Windows.Media.Audio.IAudioNode} destination The destination for the outgoing connection.
 * @return {void}
 */
Windows.Media.Audio.AudioDeviceInputNode.prototype.removeOutgoingConnection = function(destination) {};

/**
 * Resets the audio device input node.
 * @return {void}
 */
Windows.Media.Audio.AudioDeviceInputNode.prototype.reset = function() {};

/**
 * Starts the audio device input node.
 * @return {void}
 */
Windows.Media.Audio.AudioDeviceInputNode.prototype.start = function() {};

/**
 * Stops the audio device input node.
 * @return {void}
 */
Windows.Media.Audio.AudioDeviceInputNode.prototype.stop = function() {};

/** @const */
Windows.Media.Audio.AudioDeviceNodeCreationStatus = {};
/** @const {number} */
Windows.Media.Audio.AudioDeviceNodeCreationStatus.success;
/** @const {number} */
Windows.Media.Audio.AudioDeviceNodeCreationStatus.deviceNotAvailable;
/** @const {number} */
Windows.Media.Audio.AudioDeviceNodeCreationStatus.formatNotSupported;
/** @const {number} */
Windows.Media.Audio.AudioDeviceNodeCreationStatus.unknownFailure;
/** @const {number} */
Windows.Media.Audio.AudioDeviceNodeCreationStatus.accessDenied;
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.AudioDeviceOutputNode = function() {};
 /** @type {boolean} */
Windows.Media.Audio.AudioDeviceOutputNode.prototype.consumeInput;
 /** @type {!Windows.Devices.Enumeration.DeviceInformation} */
Windows.Media.Audio.AudioDeviceOutputNode.prototype.device;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Effects.IAudioEffectDefinition>} */
Windows.Media.Audio.AudioDeviceOutputNode.prototype.effectDefinitions;
 /** @type {!Windows.Media.MediaProperties.AudioEncodingProperties} */
Windows.Media.Audio.AudioDeviceOutputNode.prototype.encodingProperties;
 /** @type {number} */
Windows.Media.Audio.AudioDeviceOutputNode.prototype.outgoingGain;

/**
 * Closes the audio device output node.
 * @return {void}
 */
Windows.Media.Audio.AudioDeviceOutputNode.prototype.close = function() {};

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to disable.
 * @return {void}
 */
Windows.Media.Audio.AudioDeviceOutputNode.prototype.disableEffectsByDefinition = function(definition) {};

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to enable.
 * @return {void}
 */
Windows.Media.Audio.AudioDeviceOutputNode.prototype.enableEffectsByDefinition = function(definition) {};

/**
 * Resets the audio device output node.
 * @return {void}
 */
Windows.Media.Audio.AudioDeviceOutputNode.prototype.reset = function() {};

/**
 * Starts the audio device output node.
 * @return {void}
 */
Windows.Media.Audio.AudioDeviceOutputNode.prototype.start = function() {};

/**
 * Stops the audio device output node.
 * @return {void}
 */
Windows.Media.Audio.AudioDeviceOutputNode.prototype.stop = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.AudioFileInputNode = function() {};
 /** @type {boolean} */
Windows.Media.Audio.AudioFileInputNode.prototype.consumeInput;
 /** @type {number} */
Windows.Media.Audio.AudioFileInputNode.prototype.duration;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Effects.IAudioEffectDefinition>} */
Windows.Media.Audio.AudioFileInputNode.prototype.effectDefinitions;
 /** @type {!Windows.Media.MediaProperties.AudioEncodingProperties} */
Windows.Media.Audio.AudioFileInputNode.prototype.encodingProperties;
 /** @type {number} */
Windows.Media.Audio.AudioFileInputNode.prototype.endTime;
 /** @type {number} */
Windows.Media.Audio.AudioFileInputNode.prototype.loopCount;
 /** @type {function(?): void} */
Windows.Media.Audio.AudioFileInputNode.prototype.onfilecompleted;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Audio.AudioGraphConnection>} */
Windows.Media.Audio.AudioFileInputNode.prototype.outgoingConnections;
 /** @type {number} */
Windows.Media.Audio.AudioFileInputNode.prototype.outgoingGain;
 /** @type {number} */
Windows.Media.Audio.AudioFileInputNode.prototype.playbackSpeedFactor;
 /** @type {number} */
Windows.Media.Audio.AudioFileInputNode.prototype.position;
 /** @type {!Windows.Storage.StorageFile} */
Windows.Media.Audio.AudioFileInputNode.prototype.sourceFile;
 /** @type {number} */
Windows.Media.Audio.AudioFileInputNode.prototype.startTime;

/**
 * Adds an outgoing connection with gain to the audio file input node.
 * Adds an outgoing connection to the audio file input node.
 * @param {!Windows.Media.Audio.IAudioNode} destination The destination node for the connection.
 * @param {number=} gain A value indicating the gain associated with the connection.
 * @return {void}
 */
Windows.Media.Audio.AudioFileInputNode.prototype.addOutgoingConnection = function(destination, gain) {};

/**
 * Closes the audio file input node.
 * @return {void}
 */
Windows.Media.Audio.AudioFileInputNode.prototype.close = function() {};

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to disable.
 * @return {void}
 */
Windows.Media.Audio.AudioFileInputNode.prototype.disableEffectsByDefinition = function(definition) {};

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to enable.
 * @return {void}
 */
Windows.Media.Audio.AudioFileInputNode.prototype.enableEffectsByDefinition = function(definition) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Audio.AudioFileInputNode.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Audio.AudioFileInputNode.prototype.removeEventListener = function(type, listener) {};

/**
 * Removes the outgoing connection for the audio file input node.
 * @param {!Windows.Media.Audio.IAudioNode} destination The destination for the outgoing connection.
 * @return {void}
 */
Windows.Media.Audio.AudioFileInputNode.prototype.removeOutgoingConnection = function(destination) {};

/**
 * Resets the audio file input node.
 * @return {void}
 */
Windows.Media.Audio.AudioFileInputNode.prototype.reset = function() {};

/**
 * Moves the playback position of the node to the specified time within the audio input file.
 * @param {number} position A value indicating the position to which the node should seek.
 * @return {void}
 */
Windows.Media.Audio.AudioFileInputNode.prototype.seek = function(position) {};

/**
 * Starts the audio file input node.
 * @return {void}
 */
Windows.Media.Audio.AudioFileInputNode.prototype.start = function() {};

/**
 * Stops the audio file input node.
 * @return {void}
 */
Windows.Media.Audio.AudioFileInputNode.prototype.stop = function() {};

/** @const */
Windows.Media.Audio.AudioFileNodeCreationStatus = {};
/** @const {number} */
Windows.Media.Audio.AudioFileNodeCreationStatus.success;
/** @const {number} */
Windows.Media.Audio.AudioFileNodeCreationStatus.fileNotFound;
/** @const {number} */
Windows.Media.Audio.AudioFileNodeCreationStatus.invalidFileType;
/** @const {number} */
Windows.Media.Audio.AudioFileNodeCreationStatus.formatNotSupported;
/** @const {number} */
Windows.Media.Audio.AudioFileNodeCreationStatus.unknownFailure;
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.AudioFileOutputNode = function() {};
 /** @type {boolean} */
Windows.Media.Audio.AudioFileOutputNode.prototype.consumeInput;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Effects.IAudioEffectDefinition>} */
Windows.Media.Audio.AudioFileOutputNode.prototype.effectDefinitions;
 /** @type {!Windows.Media.MediaProperties.AudioEncodingProperties} */
Windows.Media.Audio.AudioFileOutputNode.prototype.encodingProperties;
 /** @type {!Windows.Storage.IStorageFile} */
Windows.Media.Audio.AudioFileOutputNode.prototype.file;
 /** @type {!Windows.Media.MediaProperties.MediaEncodingProfile} */
Windows.Media.Audio.AudioFileOutputNode.prototype.fileEncodingProfile;
 /** @type {number} */
Windows.Media.Audio.AudioFileOutputNode.prototype.outgoingGain;

/**
 * Closes the audio file output node.
 * @return {void}
 */
Windows.Media.Audio.AudioFileOutputNode.prototype.close = function() {};

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to disable.
 * @return {void}
 */
Windows.Media.Audio.AudioFileOutputNode.prototype.disableEffectsByDefinition = function(definition) {};

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to enable.
 * @return {void}
 */
Windows.Media.Audio.AudioFileOutputNode.prototype.enableEffectsByDefinition = function(definition) {};

/**
 * Finalizes the asynchronous operation of the audio file output node.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Media.Transcoding.TranscodeFailureReason, !Windows.Foundation.IAsyncOperation<Windows.Media.Transcoding.TranscodeFailureReason>>} When this operation completes, a TranscodeFailureReason value is returned.
 */
Windows.Media.Audio.AudioFileOutputNode.prototype.finalizeAsync = function() {};

/**
 * Resets the audio file output node.
 * @return {void}
 */
Windows.Media.Audio.AudioFileOutputNode.prototype.reset = function() {};

/**
 * Starts the audio file output node.
 * @return {void}
 */
Windows.Media.Audio.AudioFileOutputNode.prototype.start = function() {};

/**
 * Stops the audio file output node.
 * @return {void}
 */
Windows.Media.Audio.AudioFileOutputNode.prototype.stop = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.AudioFrameCompletedEventArgs = function() {};
 /** @type {!Windows.Media.AudioFrame} */
Windows.Media.Audio.AudioFrameCompletedEventArgs.prototype.frame;
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.AudioFrameInputNode = function() {};
 /** @type {boolean} */
Windows.Media.Audio.AudioFrameInputNode.prototype.consumeInput;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Effects.IAudioEffectDefinition>} */
Windows.Media.Audio.AudioFrameInputNode.prototype.effectDefinitions;
 /** @type {!Windows.Media.MediaProperties.AudioEncodingProperties} */
Windows.Media.Audio.AudioFrameInputNode.prototype.encodingProperties;
 /** @type {function(?): void} */
Windows.Media.Audio.AudioFrameInputNode.prototype.onaudioframecompleted;
 /** @type {function(?): void} */
Windows.Media.Audio.AudioFrameInputNode.prototype.onquantumstarted;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Audio.AudioGraphConnection>} */
Windows.Media.Audio.AudioFrameInputNode.prototype.outgoingConnections;
 /** @type {number} */
Windows.Media.Audio.AudioFrameInputNode.prototype.outgoingGain;
 /** @type {number} */
Windows.Media.Audio.AudioFrameInputNode.prototype.playbackSpeedFactor;
 /** @type {number} */
Windows.Media.Audio.AudioFrameInputNode.prototype.queuedSampleCount;

/**
 * Adds an audio frame to the audio frame input node.
 * @param {!Windows.Media.AudioFrame} frame An AudioFrame object representing the frame.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameInputNode.prototype.addFrame = function(frame) {};

/**
 * Adds an outgoing connection with gain to the audio frame input node.
 * Adds an outgoing connection to the audio frame input node.
 * @param {!Windows.Media.Audio.IAudioNode} destination The destination node for the connection.
 * @param {number=} gain A value indicating the gain associated with the connection.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameInputNode.prototype.addOutgoingConnection = function(destination, gain) {};

/**
 * Closes the audio frame input node.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameInputNode.prototype.close = function() {};

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to disable.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameInputNode.prototype.disableEffectsByDefinition = function(definition) {};

/**
 * Removes queued frames from the audio frame input node.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameInputNode.prototype.discardQueuedFrames = function() {};

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to enable.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameInputNode.prototype.enableEffectsByDefinition = function(definition) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Audio.AudioFrameInputNode.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Audio.AudioFrameInputNode.prototype.removeEventListener = function(type, listener) {};

/**
 * Removes an outgoing connection from the audio frame input node.
 * @param {!Windows.Media.Audio.IAudioNode} destination The destination for the outgoing connection.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameInputNode.prototype.removeOutgoingConnection = function(destination) {};

/**
 * Resets the audio frame input node.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameInputNode.prototype.reset = function() {};

/**
 * Starts the audio frame input node.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameInputNode.prototype.start = function() {};

/**
 * Stops the audio frame input node.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameInputNode.prototype.stop = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.AudioFrameOutputNode = function() {};
 /** @type {boolean} */
Windows.Media.Audio.AudioFrameOutputNode.prototype.consumeInput;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Effects.IAudioEffectDefinition>} */
Windows.Media.Audio.AudioFrameOutputNode.prototype.effectDefinitions;
 /** @type {!Windows.Media.MediaProperties.AudioEncodingProperties} */
Windows.Media.Audio.AudioFrameOutputNode.prototype.encodingProperties;
 /** @type {number} */
Windows.Media.Audio.AudioFrameOutputNode.prototype.outgoingGain;

/**
 * Closes the audio frame output node.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameOutputNode.prototype.close = function() {};

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to disable.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameOutputNode.prototype.disableEffectsByDefinition = function(definition) {};

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to enable.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameOutputNode.prototype.enableEffectsByDefinition = function(definition) {};

/**
 * Gets an audio frame containing all of the data accumulated by this node since the previous call to GetFrame. If GetFrame has not yet been called, the audio frame will contain all of the data accumulated since the node was created.
 * @return {!Windows.Media.AudioFrame} An AudioFrame object representing the frame.
 */
Windows.Media.Audio.AudioFrameOutputNode.prototype.getFrame = function() {};

/**
 * Resets the audio frame output node.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameOutputNode.prototype.reset = function() {};

/**
 * Starts the audio frame output node.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameOutputNode.prototype.start = function() {};

/**
 * Stops the audio frame output node.
 * @return {void}
 */
Windows.Media.Audio.AudioFrameOutputNode.prototype.stop = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.AudioGraph = function() {};
 /** @type {number} */
Windows.Media.Audio.AudioGraph.prototype.completedQuantumCount;
 /** @type {!Windows.Media.MediaProperties.AudioEncodingProperties} */
Windows.Media.Audio.AudioGraph.prototype.encodingProperties;
 /** @type {number} */
Windows.Media.Audio.AudioGraph.prototype.latencyInSamples;
 /** @type {function(?): void} */
Windows.Media.Audio.AudioGraph.prototype.onquantumprocessed;
 /** @type {function(?): void} */
Windows.Media.Audio.AudioGraph.prototype.onquantumstarted;
 /** @type {function(?): void} */
Windows.Media.Audio.AudioGraph.prototype.onunrecoverableerroroccurred;
 /** @type {!Windows.Devices.Enumeration.DeviceInformation} */
Windows.Media.Audio.AudioGraph.prototype.primaryRenderDevice;
 /** @type {Windows.Media.AudioProcessing} */
Windows.Media.Audio.AudioGraph.prototype.renderDeviceAudioProcessing;
 /** @type {number} */
Windows.Media.Audio.AudioGraph.prototype.samplesPerQuantum;

/**
 * Creates an audio graph with specific settings.
 * @param {!Windows.Media.Audio.AudioGraphSettings} settings An AudioGraphSettings object representing the source audio file.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Audio.CreateAudioGraphResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Audio.CreateAudioGraphResult>>} When this operation completes, a CreateAudioGraphResult object is returned.
 */
Windows.Media.Audio.AudioGraph.createAsync = function(settings) {};

/**
 * Closes the audio graph.
 * @return {void}
 */
Windows.Media.Audio.AudioGraph.prototype.close = function() {};

/**
 * Creates a device input node for the indicated media and audio encoding properties.
 * Creates a device input node for the indicated media.
 * Creates a device input node for the indicated media, audio encoding properties, and device information.
 * @param {Windows.Media.Capture.MediaCategory} category An enumeration value indicating the media category.
 * @param {!Windows.Media.MediaProperties.AudioEncodingProperties=} encodingProperties An object representing the audio encoding properties for the device input node.
 * @param {!Windows.Devices.Enumeration.DeviceInformation=} device An object representing the device associated with the device input node.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Audio.CreateAudioDeviceInputNodeResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Audio.CreateAudioDeviceInputNodeResult>>} An asynchronous operation that returns a CreateAudioDeviceInputNodeResult on completion. This object exposes a Status property, that indicates either that the operation was successful or the reason why the operation failed. The DeviceInputNode property provides a reference to the created input node on success.
 */
Windows.Media.Audio.AudioGraph.prototype.createDeviceInputNodeAsync = function(category, encodingProperties, device) {};

/**
 * Creates a new device output node for the audio graph.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Audio.CreateAudioDeviceOutputNodeResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Audio.CreateAudioDeviceOutputNodeResult>>} An asynchronous operation that returns a CreateAudioDeviceOutputNodeResult on completion. This object exposes a Status property, that indicates either that the operation was successful or the reason why the operation failed. The DeviceOutputNode property provides a reference to the created output node on success.
 */
Windows.Media.Audio.AudioGraph.prototype.createDeviceOutputNodeAsync = function() {};

/**
 * Creates a file input node for the audio graph.
 * @param {!Windows.Storage.IStorageFile} file A IStorageFile object representing the file associated with the file input node.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Audio.CreateAudioFileInputNodeResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Audio.CreateAudioFileInputNodeResult>>} When this operation completes, a CreateAudioFileInputNodeResult object is returned.
 */
Windows.Media.Audio.AudioGraph.prototype.createFileInputNodeAsync = function(file) {};

/**
 * Creates a file output node for the indicated file.
 * Creates a file output node for the indicated file and media encoding profile.
 * @param {!Windows.Storage.IStorageFile} file A StorageFile object representing the file.
 * @param {!Windows.Media.MediaProperties.MediaEncodingProfile=} fileEncodingProfile An objecting representing the media encoding profile.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Audio.CreateAudioFileOutputNodeResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Audio.CreateAudioFileOutputNodeResult>>} When this operation completes, a CreateAudioFileOutputNodeResult object is returned.
 */
Windows.Media.Audio.AudioGraph.prototype.createFileOutputNodeAsync = function(file, fileEncodingProfile) {};

/**
 * Creates an audio frame input node from encoding properties.
 * Creates a simple audio frame input node for the audio graph.
 * @param {!Windows.Media.MediaProperties.AudioEncodingProperties=} encodingProperties An object representing encoding properties.
 * @return {!Windows.Media.Audio.AudioFrameInputNode} An audio frame input node.
 */
Windows.Media.Audio.AudioGraph.prototype.createFrameInputNode = function(encodingProperties) {};

/**
 * Creates a frame output node from encoding properties.
 * Creates a simple frame output node for the audio graph.
 * @param {!Windows.Media.MediaProperties.AudioEncodingProperties=} encodingProperties An object representing audio encoding properties.
 * @return {!Windows.Media.Audio.AudioFrameOutputNode} An audio frame output node.
 */
Windows.Media.Audio.AudioGraph.prototype.createFrameOutputNode = function(encodingProperties) {};

/**
 * Creates an audio graph submix node that mixes the output of one or more nodes into single output that can be connected to output nodes or other submix nodes.
 * Creates an audio graph submix node that mixes the output of one or more nodes into single output that can be connected to output nodes or other submix nodes.
 * @param {!Windows.Media.MediaProperties.AudioEncodingProperties=} encodingProperties An object representing audio encoding properties.
 * @return {!Windows.Media.Audio.AudioSubmixNode} An audio submix node.
 */
Windows.Media.Audio.AudioGraph.prototype.createSubmixNode = function(encodingProperties) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Audio.AudioGraph.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Audio.AudioGraph.prototype.removeEventListener = function(type, listener) {};

/**
 * Resets all nodes in the audio graph.
 * @return {void}
 */
Windows.Media.Audio.AudioGraph.prototype.resetAllNodes = function() {};

/**
 * Starts the audio graph.
 * @return {void}
 */
Windows.Media.Audio.AudioGraph.prototype.start = function() {};

/**
 * Stops the audio graph.
 * @return {void}
 */
Windows.Media.Audio.AudioGraph.prototype.stop = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.AudioGraphConnection = function() {};
 /** @type {!Windows.Media.Audio.IAudioNode} */
Windows.Media.Audio.AudioGraphConnection.prototype.destination;
 /** @type {number} */
Windows.Media.Audio.AudioGraphConnection.prototype.gain;

/** @const */
Windows.Media.Audio.AudioGraphCreationStatus = {};
/** @const {number} */
Windows.Media.Audio.AudioGraphCreationStatus.success;
/** @const {number} */
Windows.Media.Audio.AudioGraphCreationStatus.deviceNotAvailable;
/** @const {number} */
Windows.Media.Audio.AudioGraphCreationStatus.formatNotSupported;
/** @const {number} */
Windows.Media.Audio.AudioGraphCreationStatus.unknownFailure;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the AudioGraphSettings class with initial settings values optimized for the specified AudioRenderCategory .
 * @param {Windows.Media.Render.AudioRenderCategory} audioRenderCategory The AudioRenderCategory that determines the initial settings values.
 */
Windows.Media.Audio.AudioGraphSettings = function(audioRenderCategory) {};
 /** @type {Windows.Media.Render.AudioRenderCategory} */
Windows.Media.Audio.AudioGraphSettings.prototype.audioRenderCategory;
 /** @type {Windows.Media.AudioProcessing} */
Windows.Media.Audio.AudioGraphSettings.prototype.desiredRenderDeviceAudioProcessing;
 /** @type {number} */
Windows.Media.Audio.AudioGraphSettings.prototype.desiredSamplesPerQuantum;
 /** @type {!Windows.Media.MediaProperties.AudioEncodingProperties} */
Windows.Media.Audio.AudioGraphSettings.prototype.encodingProperties;
 /** @type {!Windows.Devices.Enumeration.DeviceInformation} */
Windows.Media.Audio.AudioGraphSettings.prototype.primaryRenderDevice;
 /** @type {Windows.Media.Audio.QuantumSizeSelectionMode} */
Windows.Media.Audio.AudioGraphSettings.prototype.quantumSizeSelectionMode;

/** @const */
Windows.Media.Audio.AudioGraphUnrecoverableError = {};
/** @const {number} */
Windows.Media.Audio.AudioGraphUnrecoverableError.none;
/** @const {number} */
Windows.Media.Audio.AudioGraphUnrecoverableError.audioDeviceLost;
/** @const {number} */
Windows.Media.Audio.AudioGraphUnrecoverableError.audioSessionDisconnected;
/** @const {number} */
Windows.Media.Audio.AudioGraphUnrecoverableError.unknownFailure;
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.AudioGraphUnrecoverableErrorOccurredEventArgs = function() {};
 /** @type {Windows.Media.Audio.AudioGraphUnrecoverableError} */
Windows.Media.Audio.AudioGraphUnrecoverableErrorOccurredEventArgs.prototype.error;
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.AudioSubmixNode = function() {};
 /** @type {boolean} */
Windows.Media.Audio.AudioSubmixNode.prototype.consumeInput;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Effects.IAudioEffectDefinition>} */
Windows.Media.Audio.AudioSubmixNode.prototype.effectDefinitions;
 /** @type {!Windows.Media.MediaProperties.AudioEncodingProperties} */
Windows.Media.Audio.AudioSubmixNode.prototype.encodingProperties;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Audio.AudioGraphConnection>} */
Windows.Media.Audio.AudioSubmixNode.prototype.outgoingConnections;
 /** @type {number} */
Windows.Media.Audio.AudioSubmixNode.prototype.outgoingGain;

/**
 * Adds an outgoing connection with gain to the audio submix node.
 * Adds an outgoing connection to the audio submix node.
 * @param {!Windows.Media.Audio.IAudioNode} destination The destination node for the connection.
 * @param {number=} gain A value indicating the gain associated with the connection.
 * @return {void}
 */
Windows.Media.Audio.AudioSubmixNode.prototype.addOutgoingConnection = function(destination, gain) {};

/**
 * Closes the audio submix node.
 * @return {void}
 */
Windows.Media.Audio.AudioSubmixNode.prototype.close = function() {};

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to disable.
 * @return {void}
 */
Windows.Media.Audio.AudioSubmixNode.prototype.disableEffectsByDefinition = function(definition) {};

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to enable.
 * @return {void}
 */
Windows.Media.Audio.AudioSubmixNode.prototype.enableEffectsByDefinition = function(definition) {};

/**
 * Removes an outgoing connection from the audio submix node.
 * @param {!Windows.Media.Audio.IAudioNode} destination The destination for the outgoing connection.
 * @return {void}
 */
Windows.Media.Audio.AudioSubmixNode.prototype.removeOutgoingConnection = function(destination) {};

/**
 * Resets the audio submix node.
 * @return {void}
 */
Windows.Media.Audio.AudioSubmixNode.prototype.reset = function() {};

/**
 * Starts the audio submix node.
 * @return {void}
 */
Windows.Media.Audio.AudioSubmixNode.prototype.start = function() {};

/**
 * Stops the audio submix node.
 * @return {void}
 */
Windows.Media.Audio.AudioSubmixNode.prototype.stop = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.CreateAudioDeviceInputNodeResult = function() {};
 /** @type {!Windows.Media.Audio.AudioDeviceInputNode} */
Windows.Media.Audio.CreateAudioDeviceInputNodeResult.prototype.deviceInputNode;
 /** @type {Windows.Media.Audio.AudioDeviceNodeCreationStatus} */
Windows.Media.Audio.CreateAudioDeviceInputNodeResult.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.CreateAudioDeviceOutputNodeResult = function() {};
 /** @type {!Windows.Media.Audio.AudioDeviceOutputNode} */
Windows.Media.Audio.CreateAudioDeviceOutputNodeResult.prototype.deviceOutputNode;
 /** @type {Windows.Media.Audio.AudioDeviceNodeCreationStatus} */
Windows.Media.Audio.CreateAudioDeviceOutputNodeResult.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.CreateAudioFileInputNodeResult = function() {};
 /** @type {!Windows.Media.Audio.AudioFileInputNode} */
Windows.Media.Audio.CreateAudioFileInputNodeResult.prototype.fileInputNode;
 /** @type {Windows.Media.Audio.AudioFileNodeCreationStatus} */
Windows.Media.Audio.CreateAudioFileInputNodeResult.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.CreateAudioFileOutputNodeResult = function() {};
 /** @type {!Windows.Media.Audio.AudioFileOutputNode} */
Windows.Media.Audio.CreateAudioFileOutputNodeResult.prototype.fileOutputNode;
 /** @type {Windows.Media.Audio.AudioFileNodeCreationStatus} */
Windows.Media.Audio.CreateAudioFileOutputNodeResult.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.CreateAudioGraphResult = function() {};
 /** @type {!Windows.Media.Audio.AudioGraph} */
Windows.Media.Audio.CreateAudioGraphResult.prototype.graph;
 /** @type {Windows.Media.Audio.AudioGraphCreationStatus} */
Windows.Media.Audio.CreateAudioGraphResult.prototype.status;

/**
 * @constructor
 * @struct
 * Creates an EchoEffectDefinition object.
 * @param {!Windows.Media.Audio.AudioGraph} audioGraph The AudioGraph with which the effect will be used. Using effects outside of the audio graph it was created with is not supported.
 */
Windows.Media.Audio.EchoEffectDefinition = function(audioGraph) {};
 /** @type {string} */
Windows.Media.Audio.EchoEffectDefinition.prototype.activatableClassId;
 /** @type {number} */
Windows.Media.Audio.EchoEffectDefinition.prototype.delay;
 /** @type {number} */
Windows.Media.Audio.EchoEffectDefinition.prototype.feedback;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Audio.EchoEffectDefinition.prototype.properties;
 /** @type {number} */
Windows.Media.Audio.EchoEffectDefinition.prototype.wetDryMix;
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.EqualizerBand = function() {};
 /** @type {number} */
Windows.Media.Audio.EqualizerBand.prototype.bandwidth;
 /** @type {number} */
Windows.Media.Audio.EqualizerBand.prototype.frequencyCenter;
 /** @type {number} */
Windows.Media.Audio.EqualizerBand.prototype.gain;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the EqualizerEffectDefinition class.
 * @param {!Windows.Media.Audio.AudioGraph} audioGraph The AudioGraph with which the effect will be used. Using effects outside of the audio graph it was created with is not supported.
 */
Windows.Media.Audio.EqualizerEffectDefinition = function(audioGraph) {};
 /** @type {string} */
Windows.Media.Audio.EqualizerEffectDefinition.prototype.activatableClassId;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Audio.EqualizerBand>} */
Windows.Media.Audio.EqualizerEffectDefinition.prototype.bands;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Audio.EqualizerEffectDefinition.prototype.properties;
/**
 * @constructor
 * @struct
 */
Windows.Media.Audio.FrameInputNodeQuantumStartedEventArgs = function() {};
 /** @type {number} */
Windows.Media.Audio.FrameInputNodeQuantumStartedEventArgs.prototype.requiredSamples;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the LimiterEffectDefinition class.
 * @param {!Windows.Media.Audio.AudioGraph} audioGraph The AudioGraph with which the effect will be used. Using effects outside of the audio graph it was created with is not supported.
 */
Windows.Media.Audio.LimiterEffectDefinition = function(audioGraph) {};
 /** @type {string} */
Windows.Media.Audio.LimiterEffectDefinition.prototype.activatableClassId;
 /** @type {number} */
Windows.Media.Audio.LimiterEffectDefinition.prototype.loudness;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Audio.LimiterEffectDefinition.prototype.properties;
 /** @type {number} */
Windows.Media.Audio.LimiterEffectDefinition.prototype.release;

/** @const */
Windows.Media.Audio.QuantumSizeSelectionMode = {};
/** @const {number} */
Windows.Media.Audio.QuantumSizeSelectionMode.systemDefault;
/** @const {number} */
Windows.Media.Audio.QuantumSizeSelectionMode.lowestLatency;
/** @const {number} */
Windows.Media.Audio.QuantumSizeSelectionMode.closestToDesired;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the ReverbffectDefinition class.
 * @param {!Windows.Media.Audio.AudioGraph} audioGraph The AudioGraph with which the effect will be used. Using effects outside of the audio graph it was created with is not supported.
 */
Windows.Media.Audio.ReverbEffectDefinition = function(audioGraph) {};
 /** @type {string} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.activatableClassId;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.decayTime;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.density;
 /** @type {boolean} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.disableLateField;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.earlyDiffusion;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.highEQCutoff;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.highEQGain;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.lateDiffusion;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.lowEQCutoff;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.lowEQGain;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.positionLeft;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.positionMatrixLeft;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.positionMatrixRight;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.positionRight;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.properties;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.rearDelay;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.reflectionsDelay;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.reflectionsGain;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.reverbDelay;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.reverbGain;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.roomFilterFreq;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.roomFilterHF;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.roomFilterMain;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.roomSize;
 /** @type {number} */
Windows.Media.Audio.ReverbEffectDefinition.prototype.wetDryMix;
 /** @type {?} */
Windows.Media.Audio.rame;
 /** @type {?} */
Windows.Media.Audio.rocessing;
 /** @type {?} */
Windows.Media.Audio.uffer;
 /** @type {?} */
Windows.Media.Audio.ufferAccessMode;
/**
 * @extends {Windows.Foundation.IClosable}
 * @record
 * @struct
 */
Windows.Media.Audio.IAudioNode = function() {};
 /** @type {boolean} */
Windows.Media.Audio.IAudioNode.prototype.consumeInput;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Effects.IAudioEffectDefinition>} */
Windows.Media.Audio.IAudioNode.prototype.effectDefinitions;
 /** @type {!Windows.Media.MediaProperties.AudioEncodingProperties} */
Windows.Media.Audio.IAudioNode.prototype.encodingProperties;
 /** @type {number} */
Windows.Media.Audio.IAudioNode.prototype.outgoingGain;

/**
 * Disables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to disable.
 * @return {void}
 */
Windows.Media.Audio.IAudioNode.prototype.disableEffectsByDefinition = function(definition) {};

/**
 * Enables all effects in the EffectDefinitions list with the specified effect definition.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The effect definition of the effects to enable.
 * @return {void}
 */
Windows.Media.Audio.IAudioNode.prototype.enableEffectsByDefinition = function(definition) {};

/**
 * Resets the audio node.
 * @return {void}
 */
Windows.Media.Audio.IAudioNode.prototype.reset = function() {};

/**
 * Starts the audio node.
 * @return {void}
 */
Windows.Media.Audio.IAudioNode.prototype.start = function() {};

/**
 * Stops the audio node.
 * @return {void}
 */
Windows.Media.Audio.IAudioNode.prototype.stop = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.AudioBuffer = function() {};
 /** @type {number} */
Windows.Media.AudioBuffer.prototype.capacity;
 /** @type {number} */
Windows.Media.AudioBuffer.prototype.length;

/**
 * Disposes of the object and associated resources.
 * @return {void}
 */
Windows.Media.AudioBuffer.prototype.close = function() {};

/**
 * Returns an IMemoryBufferReference representation of the audio buffer.
 * @return {!Windows.Foundation.IMemoryBufferReference} The IMemoryBufferReference representation of the audio buffer.
 */
Windows.Media.AudioBuffer.prototype.createReference = function() {};

/** @const */
Windows.Media.AudioBufferAccessMode = {};
/** @const {number} */
Windows.Media.AudioBufferAccessMode.read;
/** @const {number} */
Windows.Media.AudioBufferAccessMode.readWrite;
/** @const {number} */
Windows.Media.AudioBufferAccessMode.write;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the AudioFrame class.
 * @param {number} capacity The maximum number of bytes that the buffer can hold.
 */
Windows.Media.AudioFrame = function(capacity) {};
 /** @type {number} */
Windows.Media.AudioFrame.prototype.duration;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.AudioFrame.prototype.extendedProperties;
 /** @type {boolean} */
Windows.Media.AudioFrame.prototype.isDiscontinuous;
 /** @type {boolean} */
Windows.Media.AudioFrame.prototype.isReadOnly;
 /** @type {number} */
Windows.Media.AudioFrame.prototype.relativeTime;
 /** @type {number} */
Windows.Media.AudioFrame.prototype.systemRelativeTime;
 /** @type {string} */
Windows.Media.AudioFrame.prototype.type;

/**
 * Disposes of the object and associated resources.
 * @return {void}
 */
Windows.Media.AudioFrame.prototype.close = function() {};

/**
 * Gets a AudioBuffer object that allows you to operate directly on the software bitmap's pixel data.
 * @param {Windows.Media.AudioBufferAccessMode} mode A value indicating the access mode of the returned audio buffer.
 * @return {!Windows.Media.AudioBuffer} The buffer containing pixel data.
 */
Windows.Media.AudioFrame.prototype.lockBuffer = function(mode) {};

/** @const */
Windows.Media.AudioProcessing = {};
/** @const {number} */
Windows.Media.AudioProcessing.default;
/** @const {number} */
Windows.Media.AudioProcessing.raw;
/**
 * @constructor
 * @struct
 */
Windows.Media.AutoRepeatModeChangeRequestedEventArgs = function() {};
 /** @type {Windows.Media.MediaPlaybackAutoRepeatMode} */
Windows.Media.AutoRepeatModeChangeRequestedEventArgs.prototype.requestedAutoRepeatMode;
/** @const */
Windows.Media.Capture = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.AdvancedCapturedPhoto = function() {};
 /** @type {?} */
Windows.Media.Capture.AdvancedCapturedPhoto.prototype.context;
 /** @type {!Windows.Media.Capture.CapturedFrame} */
Windows.Media.Capture.AdvancedCapturedPhoto.prototype.frame;
 /** @type {Windows.Media.Devices.AdvancedPhotoMode} */
Windows.Media.Capture.AdvancedCapturedPhoto.prototype.mode;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.AdvancedPhotoCapture = function() {};
 /** @type {function(?): void} */
Windows.Media.Capture.AdvancedPhotoCapture.prototype.onallphotoscaptured;
 /** @type {function(?): void} */
Windows.Media.Capture.AdvancedPhotoCapture.prototype.onoptionalreferencephotocaptured;

/**
 * Asynchronously performs an advanced photo capture.
 * Asynchronously performs an advanced photo capture passing the provided app-defined context object to the result of the operation.
 * @param {?=} context An app-defined context object that passes context information to the result of the operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Capture.AdvancedCapturedPhoto, !Windows.Foundation.IAsyncOperation<!Windows.Media.Capture.AdvancedCapturedPhoto>>} An asynchronous operation that returns an AdvancedCapturedPhoto upon successful completion.
 */
Windows.Media.Capture.AdvancedPhotoCapture.prototype.captureAsync = function(context) {};

/**
 * Asynchronously releases the AdvancedPhotoCapture object and resources used by the advanced photo capture operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.Media.Capture.AdvancedPhotoCapture.prototype.finishAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Capture.AdvancedPhotoCapture.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Capture.AdvancedPhotoCapture.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.AppCapture = function() {};
 /** @type {?} */
Windows.Media.Capture.AppCapture.getForCurrentView;
 /** @type {?} */
Windows.Media.Capture.AppCapture.prototype.addEventListener;
 /** @type {?} */
Windows.Media.Capture.AppCapture.prototype.isCapturingAudio;
 /** @type {?} */
Windows.Media.Capture.AppCapture.prototype.isCapturingVideo;
 /** @type {?} */
Windows.Media.Capture.AppCapture.prototype.oncapturingchanged;
 /** @type {?} */
Windows.Media.Capture.AppCapture.prototype.removeEventListener;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.AppCaptureAlternateShortcutKeys = function() {};
 /** @type {Windows.System.VirtualKey} */
Windows.Media.Capture.AppCaptureAlternateShortcutKeys.prototype.saveHistoricalVideoKey;
 /** @type {Windows.System.VirtualKeyModifiers} */
Windows.Media.Capture.AppCaptureAlternateShortcutKeys.prototype.saveHistoricalVideoKeyModifiers;
 /** @type {Windows.System.VirtualKey} */
Windows.Media.Capture.AppCaptureAlternateShortcutKeys.prototype.takeScreenshotKey;
 /** @type {Windows.System.VirtualKeyModifiers} */
Windows.Media.Capture.AppCaptureAlternateShortcutKeys.prototype.takeScreenshotKeyModifiers;
 /** @type {Windows.System.VirtualKey} */
Windows.Media.Capture.AppCaptureAlternateShortcutKeys.prototype.toggleGameBarKey;
 /** @type {Windows.System.VirtualKeyModifiers} */
Windows.Media.Capture.AppCaptureAlternateShortcutKeys.prototype.toggleGameBarKeyModifiers;
 /** @type {?} */
Windows.Media.Capture.AppCaptureAlternateShortcutKeys.prototype.toggleMicrophoneCaptureKey;
 /** @type {?} */
Windows.Media.Capture.AppCaptureAlternateShortcutKeys.prototype.toggleMicrophoneCaptureKeyModifiers;
 /** @type {Windows.System.VirtualKey} */
Windows.Media.Capture.AppCaptureAlternateShortcutKeys.prototype.toggleRecordingIndicatorKey;
 /** @type {Windows.System.VirtualKeyModifiers} */
Windows.Media.Capture.AppCaptureAlternateShortcutKeys.prototype.toggleRecordingIndicatorKeyModifiers;
 /** @type {Windows.System.VirtualKey} */
Windows.Media.Capture.AppCaptureAlternateShortcutKeys.prototype.toggleRecordingKey;
 /** @type {Windows.System.VirtualKeyModifiers} */
Windows.Media.Capture.AppCaptureAlternateShortcutKeys.prototype.toggleRecordingKeyModifiers;

/** @const */
Windows.Media.Capture.AppCaptureHistoricalBufferLengthUnit = {};
/** @const {number} */
Windows.Media.Capture.AppCaptureHistoricalBufferLengthUnit.megabytes;
/** @const {number} */
Windows.Media.Capture.AppCaptureHistoricalBufferLengthUnit.seconds;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.AppCaptureManager = function() {};

/**
 * Applies app capture settings.
 * @param {!Windows.Media.Capture.AppCaptureSettings} appCaptureSettings The settings to apply.
 * @return {void}
 */
Windows.Media.Capture.AppCaptureManager.applySettings = function(appCaptureSettings) {};

/**
 * Gets the current app capture settings.
 * @return {!Windows.Media.Capture.AppCaptureSettings} The current app capture settings.
 */
Windows.Media.Capture.AppCaptureManager.getCurrentSettings = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.AppCaptureSettings = function() {};
 /** @type {!Windows.Media.Capture.AppCaptureAlternateShortcutKeys} */
Windows.Media.Capture.AppCaptureSettings.prototype.alternateShortcutKeys;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Media.Capture.AppCaptureSettings.prototype.appCaptureDestinationFolder;
 /** @type {number} */
Windows.Media.Capture.AppCaptureSettings.prototype.audioEncodingBitrate;
 /** @type {number} */
Windows.Media.Capture.AppCaptureSettings.prototype.customVideoEncodingBitrate;
 /** @type {number} */
Windows.Media.Capture.AppCaptureSettings.prototype.customVideoEncodingHeight;
 /** @type {number} */
Windows.Media.Capture.AppCaptureSettings.prototype.customVideoEncodingWidth;
 /** @type {boolean} */
Windows.Media.Capture.AppCaptureSettings.prototype.hasHardwareEncoder;
 /** @type {number} */
Windows.Media.Capture.AppCaptureSettings.prototype.historicalBufferLength;
 /** @type {Windows.Media.Capture.AppCaptureHistoricalBufferLengthUnit} */
Windows.Media.Capture.AppCaptureSettings.prototype.historicalBufferLengthUnit;
 /** @type {boolean} */
Windows.Media.Capture.AppCaptureSettings.prototype.isAppCaptureEnabled;
 /** @type {boolean} */
Windows.Media.Capture.AppCaptureSettings.prototype.isAudioCaptureEnabled;
 /** @type {boolean} */
Windows.Media.Capture.AppCaptureSettings.prototype.isCpuConstrained;
 /** @type {boolean} */
Windows.Media.Capture.AppCaptureSettings.prototype.isDisabledByPolicy;
 /** @type {boolean} */
Windows.Media.Capture.AppCaptureSettings.prototype.isGpuConstrained;
 /** @type {boolean} */
Windows.Media.Capture.AppCaptureSettings.prototype.isHistoricalCaptureEnabled;
 /** @type {boolean} */
Windows.Media.Capture.AppCaptureSettings.prototype.isHistoricalCaptureOnBatteryAllowed;
 /** @type {boolean} */
Windows.Media.Capture.AppCaptureSettings.prototype.isHistoricalCaptureOnWirelessDisplayAllowed;
 /** @type {boolean} */
Windows.Media.Capture.AppCaptureSettings.prototype.isMemoryConstrained;
 /** @type {?} */
Windows.Media.Capture.AppCaptureSettings.prototype.isMicrophoneCaptureEnabled;
 /** @type {number} */
Windows.Media.Capture.AppCaptureSettings.prototype.maximumRecordLength;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Media.Capture.AppCaptureSettings.prototype.screenshotDestinationFolder;
 /** @type {Windows.Media.Capture.AppCaptureVideoEncodingBitrateMode} */
Windows.Media.Capture.AppCaptureSettings.prototype.videoEncodingBitrateMode;
 /** @type {Windows.Media.Capture.AppCaptureVideoEncodingResolutionMode} */
Windows.Media.Capture.AppCaptureSettings.prototype.videoEncodingResolutionMode;

/** @const */
Windows.Media.Capture.AppCaptureVideoEncodingBitrateMode = {};
/** @const {number} */
Windows.Media.Capture.AppCaptureVideoEncodingBitrateMode.custom;
/** @const {number} */
Windows.Media.Capture.AppCaptureVideoEncodingBitrateMode.high;
/** @const {number} */
Windows.Media.Capture.AppCaptureVideoEncodingBitrateMode.standard;

/** @const */
Windows.Media.Capture.AppCaptureVideoEncodingResolutionMode = {};
/** @const {number} */
Windows.Media.Capture.AppCaptureVideoEncodingResolutionMode.custom;
/** @const {number} */
Windows.Media.Capture.AppCaptureVideoEncodingResolutionMode.high;
/** @const {number} */
Windows.Media.Capture.AppCaptureVideoEncodingResolutionMode.standard;

/**
 * @constructor
 * @struct
 * Create a new CameraCaptureUI object.
 */
Windows.Media.Capture.CameraCaptureUI = function() {};
 /** @type {!Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings} */
Windows.Media.Capture.CameraCaptureUI.prototype.photoSettings;
 /** @type {!Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings} */
Windows.Media.Capture.CameraCaptureUI.prototype.videoSettings;

/**
 * Launches the CameraCaptureUI user interface.
 * @param {Windows.Media.Capture.CameraCaptureUIMode} mode Specifies whether the user interface that will be shown allows the user to capture a photo, capture a video, or capture both photos and videos.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this operation completes, a StorageFile object is returned.
 */
Windows.Media.Capture.CameraCaptureUI.prototype.captureFileAsync = function(mode) {};

/** @const */
Windows.Media.Capture.CameraCaptureUIMaxPhotoResolution = {};
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIMaxPhotoResolution.highestAvailable;
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIMaxPhotoResolution.verySmallQvga;
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIMaxPhotoResolution.smallVga;
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIMaxPhotoResolution.mediumXga;
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIMaxPhotoResolution.large3M;
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIMaxPhotoResolution.veryLarge5M;

/** @const */
Windows.Media.Capture.CameraCaptureUIMaxVideoResolution = {};
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIMaxVideoResolution.highestAvailable;
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIMaxVideoResolution.lowDefinition;
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIMaxVideoResolution.standardDefinition;
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIMaxVideoResolution.highDefinition;

/** @const */
Windows.Media.Capture.CameraCaptureUIMode = {};
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIMode.photoOrVideo;
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIMode.photo;
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIMode.video;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings = function() {};
 /** @type {boolean} */
Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings.prototype.allowCropping;
 /** @type {!Windows.Foundation.Size} */
Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings.prototype.croppedAspectRatio;
 /** @type {!Windows.Foundation.Size} */
Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings.prototype.croppedSizeInPixels;
 /** @type {Windows.Media.Capture.CameraCaptureUIPhotoFormat} */
Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings.prototype.format;
 /** @type {Windows.Media.Capture.CameraCaptureUIMaxPhotoResolution} */
Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings.prototype.maxResolution;

/** @const */
Windows.Media.Capture.CameraCaptureUIPhotoFormat = {};
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIPhotoFormat.jpeg;
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIPhotoFormat.png;
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIPhotoFormat.jpegXR;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings = function() {};
 /** @type {boolean} */
Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings.prototype.allowTrimming;
 /** @type {Windows.Media.Capture.CameraCaptureUIVideoFormat} */
Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings.prototype.format;
 /** @type {number} */
Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings.prototype.maxDurationInSeconds;
 /** @type {Windows.Media.Capture.CameraCaptureUIMaxVideoResolution} */
Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings.prototype.maxResolution;

/** @const */
Windows.Media.Capture.CameraCaptureUIVideoFormat = {};
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIVideoFormat.mp4;
/** @const {number} */
Windows.Media.Capture.CameraCaptureUIVideoFormat.wmv;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.CameraOptionsUI = function() {};

/**
 * Displays a UI that contains options for the capture of photos, audio recordings and videos.
 * @param {!Windows.Media.Capture.MediaCapture} mediaCapture The MediaCapture object that provides methods for the capture of photos, audio recordings and videos.
 * @return {void}
 */
Windows.Media.Capture.CameraOptionsUI.show = function(mediaCapture) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.CapturedFrame = function() {};
 /** @type {boolean} */
Windows.Media.Capture.CapturedFrame.prototype.canRead;
 /** @type {boolean} */
Windows.Media.Capture.CapturedFrame.prototype.canWrite;
 /** @type {string} */
Windows.Media.Capture.CapturedFrame.prototype.contentType;
 /** @type {number} */
Windows.Media.Capture.CapturedFrame.prototype.height;
 /** @type {number} */
Windows.Media.Capture.CapturedFrame.prototype.position;
 /** @type {number} */
Windows.Media.Capture.CapturedFrame.prototype.size;
 /** @type {!Windows.Graphics.Imaging.SoftwareBitmap} */
Windows.Media.Capture.CapturedFrame.prototype.softwareBitmap;
 /** @type {number} */
Windows.Media.Capture.CapturedFrame.prototype.width;

/**
 * Creates a copy of the stream.
 * @return {!Windows.Storage.Streams.IRandomAccessStream} The clone of the strem.
 */
Windows.Media.Capture.CapturedFrame.prototype.cloneStream = function() {};

/**
 * Closes the captured framed object.
 * @return {void}
 */
Windows.Media.Capture.CapturedFrame.prototype.close = function() {};

/**
 * Asynchronously commits and flushes all of the data of the CapturedFrame .
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} When this method completes, a boolean value is returned which specifies true if the operation completed successfully; otherwise, false.
 */
Windows.Media.Capture.CapturedFrame.prototype.flushAsync = function() {};

/**
 * Gets the input stream at the specified position.
 * @param {number} position The position in the input stream.
 * @return {!Windows.Storage.Streams.IInputStream} The input stream.
 */
Windows.Media.Capture.CapturedFrame.prototype.getInputStreamAt = function(position) {};

/**
 * Gets the output stream at the specified position.
 * @param {number} position The position in the output stream.
 * @return {!Windows.Storage.Streams.IOutputStream} The output stream.
 */
Windows.Media.Capture.CapturedFrame.prototype.getOutputStreamAt = function(position) {};

/**
 * Returns an asynchronous byte reader object.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param {number} count The number of bytes to read that is less than or equal to the Capacity value.
 * @param {Windows.Storage.Streams.InputStreamOptions} options Specifies the type of the asynchronous read operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The asynchronous operation.
 */
Windows.Media.Capture.CapturedFrame.prototype.readAsync = function(buffer, count, options) {};

/**
 * Seeks the stream to the specified position.
 * @param {number} position The position in the stream to seek too.
 * @return {void}
 */
Windows.Media.Capture.CapturedFrame.prototype.seek = function(position) {};

/**
 * Asynchronously writes the specified data to the stream.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The data to write to the stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} Represents an asynchronous operation that returns a result and reports progress.
 */
Windows.Media.Capture.CapturedFrame.prototype.writeAsync = function(buffer) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.CapturedFrameControlValues = function() {};
 /** @type {number} */
Windows.Media.Capture.CapturedFrameControlValues.prototype.exposure;
 /** @type {number} */
Windows.Media.Capture.CapturedFrameControlValues.prototype.exposureCompensation;
 /** @type {number} */
Windows.Media.Capture.CapturedFrameControlValues.prototype.flashPowerPercent;
 /** @type {boolean} */
Windows.Media.Capture.CapturedFrameControlValues.prototype.flashed;
 /** @type {number} */
Windows.Media.Capture.CapturedFrameControlValues.prototype.focus;
 /** @type {Windows.Media.Devices.MediaCaptureFocusState} */
Windows.Media.Capture.CapturedFrameControlValues.prototype.focusState;
 /** @type {number} */
Windows.Media.Capture.CapturedFrameControlValues.prototype.isoAnalogGain;
 /** @type {number} */
Windows.Media.Capture.CapturedFrameControlValues.prototype.isoDigitalGain;
 /** @type {number} */
Windows.Media.Capture.CapturedFrameControlValues.prototype.isoSpeed;
 /** @type {Windows.Media.Devices.CaptureSceneMode} */
Windows.Media.Capture.CapturedFrameControlValues.prototype.sceneMode;
 /** @type {!Windows.Media.MediaProperties.MediaRatio} */
Windows.Media.Capture.CapturedFrameControlValues.prototype.sensorFrameRate;
 /** @type {number} */
Windows.Media.Capture.CapturedFrameControlValues.prototype.whiteBalance;
 /** @type {!Windows.Media.Capture.WhiteBalanceGain} */
Windows.Media.Capture.CapturedFrameControlValues.prototype.whiteBalanceGain;
 /** @type {number} */
Windows.Media.Capture.CapturedFrameControlValues.prototype.zoomFactor;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.CapturedPhoto = function() {};
 /** @type {!Windows.Media.Capture.CapturedFrame} */
Windows.Media.Capture.CapturedPhoto.prototype.frame;
 /** @type {!Windows.Media.Capture.CapturedFrame} */
Windows.Media.Capture.CapturedPhoto.prototype.thumbnail;
/** @const */
Windows.Media.Capture.Core = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.Core.VariablePhotoCapturedEventArgs = function() {};
 /** @type {number} */
Windows.Media.Capture.Core.VariablePhotoCapturedEventArgs.prototype.captureTimeOffset;
 /** @type {!Windows.Media.Capture.CapturedFrameControlValues} */
Windows.Media.Capture.Core.VariablePhotoCapturedEventArgs.prototype.capturedFrameControlValues;
 /** @type {!Windows.Media.Capture.CapturedFrame} */
Windows.Media.Capture.Core.VariablePhotoCapturedEventArgs.prototype.frame;
 /** @type {number} */
Windows.Media.Capture.Core.VariablePhotoCapturedEventArgs.prototype.usedFrameControllerIndex;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.Core.VariablePhotoSequenceCapture = function() {};
 /** @type {function(?): void} */
Windows.Media.Capture.Core.VariablePhotoSequenceCapture.prototype.onphotocaptured;
 /** @type {function(?): void} */
Windows.Media.Capture.Core.VariablePhotoSequenceCapture.prototype.onstopped;

/**
 * Asynchronously releases the VariablePhotoSequenceCapture object and resources used by the capture operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.Media.Capture.Core.VariablePhotoSequenceCapture.prototype.finishAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Capture.Core.VariablePhotoSequenceCapture.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Capture.Core.VariablePhotoSequenceCapture.prototype.removeEventListener = function(type, listener) {};

/**
 * Starts the capturing of variable photo sequence frames.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.Media.Capture.Core.VariablePhotoSequenceCapture.prototype.startAsync = function() {};

/**
 * Stops the capturing of variable photo sequence frames.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.Media.Capture.Core.VariablePhotoSequenceCapture.prototype.stopAsync = function() {};

/**
 * Updates the frame control values of the variable photo sequence.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.Media.Capture.Core.VariablePhotoSequenceCapture.prototype.updateSettingsAsync = function() {};

/** @const */
Windows.Media.Capture.KnownVideoProfile = {};
/** @const {number} */
Windows.Media.Capture.KnownVideoProfile.videoRecording;
/** @const {number} */
Windows.Media.Capture.KnownVideoProfile.highQualityPhoto;
/** @const {number} */
Windows.Media.Capture.KnownVideoProfile.balancedVideoAndPhoto;
/** @const {number} */
Windows.Media.Capture.KnownVideoProfile.videoConferencing;
/** @const {number} */
Windows.Media.Capture.KnownVideoProfile.photoSequence;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.LowLagMediaRecording = function() {};

/**
 * Asynchronously releases the LowLagMediaRecording object and resources used by the media recording operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.LowLagMediaRecording.prototype.finishAsync = function() {};

/**
 * Pauses an ongoing low lag media record operation
 * @param {Windows.Media.Devices.MediaCapturePauseBehavior} behavior A value indicating whether the media capture hardware resources should be preserved or released while recording is paused.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.Media.Capture.LowLagMediaRecording.prototype.pauseAsync = function(behavior) {};

/**
 * Resumes a paused low lag recording operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.Media.Capture.LowLagMediaRecording.prototype.resumeAsync = function() {};

/**
 * Asynchronously starts the low lag media recording.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.LowLagMediaRecording.prototype.startAsync = function() {};

/**
 * Asynchronously stops the low lag media recording.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.LowLagMediaRecording.prototype.stopAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.LowLagPhotoCapture = function() {};

/**
 * Asynchronously captures a low shutter lag photo.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Capture.CapturedPhoto, !Windows.Foundation.IAsyncOperation<!Windows.Media.Capture.CapturedPhoto>>} When this method completes, a CapturedPhoto object is returned which contains the captured photo.
 */
Windows.Media.Capture.LowLagPhotoCapture.prototype.captureAsync = function() {};

/**
 * Asynchronously releases the LowLagPhotoCapture object and resources used by the capture photo operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.LowLagPhotoCapture.prototype.finishAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.LowLagPhotoSequenceCapture = function() {};
 /** @type {function(?): void} */
Windows.Media.Capture.LowLagPhotoSequenceCapture.prototype.onphotocaptured;

/**
 * Asynchronously releases the LowLagPhotoSequenceCapture object and resources used by the photo sequence capture operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.LowLagPhotoSequenceCapture.prototype.finishAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Capture.LowLagPhotoSequenceCapture.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Capture.LowLagPhotoSequenceCapture.prototype.removeEventListener = function(type, listener) {};

/**
 * Asynchronously starts capturing photos.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.LowLagPhotoSequenceCapture.prototype.startAsync = function() {};

/**
 * Asynchronously stops capturing photos.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.LowLagPhotoSequenceCapture.prototype.stopAsync = function() {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the MediaCapture object.
 */
Windows.Media.Capture.MediaCapture = function() {};
 /** @type {!Windows.Media.Devices.AudioDeviceController} */
Windows.Media.Capture.MediaCapture.prototype.audioDeviceController;
 /** @type {Windows.Media.Devices.CameraStreamState} */
Windows.Media.Capture.MediaCapture.prototype.cameraStreamState;
 /** @type {!Windows.Media.Capture.MediaCaptureSettings} */
Windows.Media.Capture.MediaCapture.prototype.mediaCaptureSettings;
 /** @type {function(?): void} */
Windows.Media.Capture.MediaCapture.prototype.oncamerastreamstatechanged;
 /** @type {function(?): void} */
Windows.Media.Capture.MediaCapture.prototype.onfailed;
 /** @type {function(?): void} */
Windows.Media.Capture.MediaCapture.prototype.onfocuschanged;
 /** @type {function(?): void} */
Windows.Media.Capture.MediaCapture.prototype.onphotoconfirmationcaptured;
 /** @type {function(!Windows.WinRTEvent<!Windows.Media.Capture.MediaCapture>): void} */
Windows.Media.Capture.MediaCapture.prototype.onrecordlimitationexceeded;
 /** @type {function(?): void} */
Windows.Media.Capture.MediaCapture.prototype.onthermalstatuschanged;
 /** @type {Windows.Media.Capture.MediaCaptureThermalStatus} */
Windows.Media.Capture.MediaCapture.prototype.thermalStatus;
 /** @type {!Windows.Media.Devices.VideoDeviceController} */
Windows.Media.Capture.MediaCapture.prototype.videoDeviceController;

/**
 * Retrieves the list of all video profiles supported by the specified video capture device.
 * @param {string} videoDeviceId The identifier of the video device for which supported video profiles are queried. For information on getting the video device ID, see DeviceInformation::FindAllAsync .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Capture.MediaCaptureVideoProfile>} The list of video profiles supported by the specified video capture device.
 */
Windows.Media.Capture.MediaCapture.findAllVideoProfiles = function(videoDeviceId) {};

/**
 * Retrieves the list of video profiles supported by the specified video capture device that can be used while another profile is used on a different capture device.
 * @param {string} videoDeviceId The identifier of the video device for which supported video profiles are queried. For information on getting the video device ID, see DeviceInformation::FindAllAsync .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Capture.MediaCaptureVideoProfile>} The list of video profiles supported by the specified video capture device that support concurrency.
 */
Windows.Media.Capture.MediaCapture.findConcurrentProfiles = function(videoDeviceId) {};

/**
 * Retrieves the list of all video profiles supported by the specified video capture device that match the specified KnownVideoProfile value.
 * @param {string} videoDeviceId The identifier of the video device for which supported video profiles are queried. For information on getting the video device ID, see DeviceInformation::FindAllAsync .
 * @param {Windows.Media.Capture.KnownVideoProfile} name A value specifying one of the profile names known by the system.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Capture.MediaCaptureVideoProfile>} The list of video profiles supported by the specified video capture device that match the specified known profile name.
 */
Windows.Media.Capture.MediaCapture.findKnownVideoProfiles = function(videoDeviceId, name) {};

/**
 * Gets a boolean value indicating whether video profiles are supported by the specified video capture device.
 * @param {string} videoDeviceId The identifier of the video device for which supported video profile support is queried. For information on getting the video device ID, see DeviceInformation::FindAllAsync .
 * @return {boolean} True if video profiles are supported; otherwise, false.
 */
Windows.Media.Capture.MediaCapture.isVideoProfileSupported = function(videoDeviceId) {};

/**
 * Adds an audio effect to the capture pipeline.
 * @param {!Windows.Media.Effects.IAudioEffectDefinition} definition The object containing the definition of the effect to be added.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.IMediaExtension, !Windows.Foundation.IAsyncOperation<!Windows.Media.IMediaExtension>>} An asynchronous operation that returns an IMediaExtension upon successful completion.
 */
Windows.Media.Capture.MediaCapture.prototype.addAudioEffectAsync = function(definition) {};

/**
 * Adds an audio or video effect.
 * @param {Windows.Media.Capture.MediaStreamType} mediaStreamType Specifies the streams to which the effect will be applied.
 * @param {string} effectActivationID The class identifier of the activatable runtime class that implements the effect. The runtime class must implement the IMediaExtension interface.
 * @param {!Windows.Foundation.Collections.IPropertySet} effectSettings Configuration parameters for the effect.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Returns an IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.MediaCapture.prototype.addEffectAsync = function(mediaStreamType, effectActivationID, effectSettings) {};

/**
 * Adds a video effect to the capture pipeline.
 * @param {!Windows.Media.Effects.IVideoEffectDefinition} definition The object containing the definition of the effect to be added.
 * @param {Windows.Media.Capture.MediaStreamType} mediaStreamType Specifies the streams to which the effect will be applied.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.IMediaExtension, !Windows.Foundation.IAsyncOperation<!Windows.Media.IMediaExtension>>} An asynchronous operation that returns an IMediaExtension upon successful completion.
 */
Windows.Media.Capture.MediaCapture.prototype.addVideoEffectAsync = function(definition, mediaStreamType) {};

/**
 * Captures a photo to a storage file.
 * @param {!Windows.Media.MediaProperties.ImageEncodingProperties} type The encoding properties for the output image.
 * @param {!Windows.Storage.IStorageFile} file The storage file where the image is saved.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Returns an IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.MediaCapture.prototype.capturePhotoToStorageFileAsync = function(type, file) {};

/**
 * Captures a photo to a random-access stream.
 * @param {!Windows.Media.MediaProperties.ImageEncodingProperties} type The encoding properties for the output image.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} stream The stream where the image data is written.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Returns an IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.MediaCapture.prototype.capturePhotoToStreamAsync = function(type, stream) {};

/**
 * Removes all audio and video effects from a stream.
 * @param {Windows.Media.Capture.MediaStreamType} mediaStreamType The stream from which to remove the effects.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Returns a IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.MediaCapture.prototype.clearEffectsAsync = function(mediaStreamType) {};

/**
 * Closes the media capture object.
 * @return {void}
 */
Windows.Media.Capture.MediaCapture.prototype.close = function() {};

/**
 * Gets the value of an encoding property.
 * @param {Windows.Media.Capture.MediaStreamType} mediaStreamType Specifies the stream to query for the encoding property.
 * @param {string} propertyId The encoding property to retrieve.
 * @return {?} Returns the value of the encoding property.
 */
Windows.Media.Capture.MediaCapture.prototype.getEncoderProperty = function(mediaStreamType, propertyId) {};

/**
 * Gets a preview frame from the capture device.
 * Gets a preview frame from the capture device, copied into the provided destination VideoFrame and converted into the destination frame's format.
 * @param {!Windows.Media.VideoFrame=} destination The video frame into which the preview frame will be copied.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.VideoFrame, !Windows.Foundation.IAsyncOperation<!Windows.Media.VideoFrame>>} An asynchronous operation that returns a VideoFrame on successful completion.
 */
Windows.Media.Capture.MediaCapture.prototype.getPreviewFrameAsync = function(destination) {};

/**
 * Queries whether the video stream is mirrored horizontally.
 * @return {boolean} True if mirroring is enabled; false otherwise.
 */
Windows.Media.Capture.MediaCapture.prototype.getPreviewMirroring = function() {};

/**
 * Gets the rotation of the video preview stream.
 * @return {Windows.Media.Capture.VideoRotation} The amount by which the video preview stream is rotated.
 */
Windows.Media.Capture.MediaCapture.prototype.getPreviewRotation = function() {};

/**
 * Gets the rotation of the recorded video.
 * @return {Windows.Media.Capture.VideoRotation} The amount by which the recorded video is rotated.
 */
Windows.Media.Capture.MediaCapture.prototype.getRecordRotation = function() {};

/**
 * Initializes the MediaCapture object, using default settings.
 * Initializes the MediaCapture object.
 * @param {!Windows.Media.Capture.MediaCaptureInitializationSettings=} mediaCaptureInitializationSettings The initialization settings.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Returns a IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.MediaCapture.prototype.initializeAsync = function(mediaCaptureInitializationSettings) {};

/**
 * @param {string} type
 * @param {function(?): void|function(!Windows.WinRTEvent<!Windows.Media.Capture.MediaCapture>): void} listener
 * @return {void}
 */
Windows.Media.Capture.MediaCapture.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void|function(!Windows.WinRTEvent<!Windows.Media.Capture.MediaCapture>): void} listener
 * @return {void}
 */
Windows.Media.Capture.MediaCapture.prototype.removeEventListener = function(type, listener) {};

/**
 * Pauses an ongoing record operation.
 * @param {Windows.Media.Devices.MediaCapturePauseBehavior} behavior A value indicating whether the media capture hardware resources should be preserved or released while recording is paused.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.Media.Capture.MediaCapture.prototype.pauseRecordAsync = function(behavior) {};

/**
 * Initializes the advanced photo capture and provides the AdvancedPhotoCapture object used to manage the recording.
 * @param {!Windows.Media.MediaProperties.ImageEncodingProperties} encodingProperties The encoding properties used for the resulting image.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Capture.AdvancedPhotoCapture, !Windows.Foundation.IAsyncOperation<!Windows.Media.Capture.AdvancedPhotoCapture>>} An asynchronous operation that returns an AdvancedPhotoCapture object on successful completion.
 */
Windows.Media.Capture.MediaCapture.prototype.prepareAdvancedPhotoCaptureAsync = function(encodingProperties) {};

/**
 * Initializes the low shutter lag photo capture and provides the LowLagPhotoCapture object used to manage the recording.
 * @param {!Windows.Media.MediaProperties.ImageEncodingProperties} type The encoding profile used for the image.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Capture.LowLagPhotoCapture, !Windows.Foundation.IAsyncOperation<!Windows.Media.Capture.LowLagPhotoCapture>>} When this method completes, a LowLagPhotoCapture object is returned which can be used to start the photo capture.
 */
Windows.Media.Capture.MediaCapture.prototype.prepareLowLagPhotoCaptureAsync = function(type) {};

/**
 * Initializes the low shutter lag photo sequence capture and provides the LowLagPhotoSequenceCapture object used to manage the recording.
 * @param {!Windows.Media.MediaProperties.ImageEncodingProperties} type The encoding profile used for the image.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Capture.LowLagPhotoSequenceCapture, !Windows.Foundation.IAsyncOperation<!Windows.Media.Capture.LowLagPhotoSequenceCapture>>} When this method completes, a LowLagPhotoSequenceCapture object is returned which can be used to start the photo sequence capture.
 */
Windows.Media.Capture.MediaCapture.prototype.prepareLowLagPhotoSequenceCaptureAsync = function(type) {};

/**
 * Initializes the low lag recording using the specified custom sink to store the recording. This method provides the LowLagMediaRecording object used to managed the capture.
 * Initializes the low lag recording using the specified custom sink to store the recording. This method provides the LowLagMediaRecording object used to managed the recording.
 * @param {!Windows.Media.MediaProperties.MediaEncodingProfile} encodingProfile The encoding profile to use for the recording.
 * @param {!Windows.Media.IMediaExtension|string} customMediaSink_or_customSinkActivationId The media extension for the custom media sink. / The activatable class ID of the media extension for the custom media sink.
 * @param {!Windows.Foundation.Collections.IPropertySet=} customSinkSettings Contains properties of the media extension.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Capture.LowLagMediaRecording, !Windows.Foundation.IAsyncOperation<!Windows.Media.Capture.LowLagMediaRecording>>} When this method completes, a LowLagMediaRecording object is returned which can be used to start the photo capture.
 */
Windows.Media.Capture.MediaCapture.prototype.prepareLowLagRecordToCustomSinkAsync = function(encodingProfile, customMediaSink_or_customSinkActivationId, customSinkSettings) {};

/**
 * Initializes the low lag recording using the specified file to store the recording. This method provides the LowLagMediaRecording object used to managed the recording.
 * @param {!Windows.Media.MediaProperties.MediaEncodingProfile} encodingProfile The encoding profile for the recording.
 * @param {!Windows.Storage.IStorageFile} file The storage file where the image is saved.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Capture.LowLagMediaRecording, !Windows.Foundation.IAsyncOperation<!Windows.Media.Capture.LowLagMediaRecording>>} When this method completes, a LowLagMediaRecording object is returned which can be used to start the photo capture.
 */
Windows.Media.Capture.MediaCapture.prototype.prepareLowLagRecordToStorageFileAsync = function(encodingProfile, file) {};

/**
 * Initializes the low lag recording using the specified random-access stream to store the recording. This method provides the LowLagMediaRecording object used to managed the recording.
 * @param {!Windows.Media.MediaProperties.MediaEncodingProfile} encodingProfile The encoding profile for the recording.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} stream The stream where the image data is written.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Capture.LowLagMediaRecording, !Windows.Foundation.IAsyncOperation<!Windows.Media.Capture.LowLagMediaRecording>>} When this method completes, a LowLagMediaRecording object is returned which can be used to start the photo capture.
 */
Windows.Media.Capture.MediaCapture.prototype.prepareLowLagRecordToStreamAsync = function(encodingProfile, stream) {};

/**
 * Initializes the variable photo sequence capture and provides the VariablePhotoSequenceCapture object used to manage the recording.
 * @param {!Windows.Media.MediaProperties.ImageEncodingProperties} type The encoding profile used for the image.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Capture.Core.VariablePhotoSequenceCapture, !Windows.Foundation.IAsyncOperation<!Windows.Media.Capture.Core.VariablePhotoSequenceCapture>>} When this method completes, a VariablePhotoSequenceCapture object is returned which can be used to start the photo sequence capture.
 */
Windows.Media.Capture.MediaCapture.prototype.prepareVariablePhotoSequenceCaptureAsync = function(type) {};

/**
 * Resumes a paused recording operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous operation.
 */
Windows.Media.Capture.MediaCapture.prototype.resumeRecordAsync = function() {};

/**
 * Sets an encoding property.
 * @param {Windows.Media.Capture.MediaStreamType} mediaStreamType The type of media data the stream represents, such as video or audio.
 * @param {string} propertyId The encoding property to set.
 * @param {?} propertyValue The new value of the encoding property.
 * @return {void}
 */
Windows.Media.Capture.MediaCapture.prototype.setEncoderProperty = function(mediaStreamType, propertyId, propertyValue) {};

/**
 * Asynchronously sets the media encoding properties.
 * @param {Windows.Media.Capture.MediaStreamType} mediaStreamType The type of media data the stream represents, such as video or audio.
 * @param {!Windows.Media.MediaProperties.IMediaEncodingProperties} mediaEncodingProperties The properties for the media encoding.
 * @param {!Windows.Media.MediaProperties.MediaPropertySet} encoderProperties The properties for the encoder.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.MediaCapture.prototype.setEncodingPropertiesAsync = function(mediaStreamType, mediaEncodingProperties, encoderProperties) {};

/**
 * Enables or disables horizontal mirroring of the video preview stream. This is not the preferred method for mirroring. See the Remarks section below for details.
 * @param {boolean} value True to enable mirroring; false to disable mirroring.
 * @return {void}
 */
Windows.Media.Capture.MediaCapture.prototype.setPreviewMirroring = function(value) {};

/**
 * Rotates the video preview stream.
 * @param {Windows.Media.Capture.VideoRotation} value The amount by which to rotate the video.
 * @return {void}
 */
Windows.Media.Capture.MediaCapture.prototype.setPreviewRotation = function(value) {};

/**
 * Rotates the recorded video.
 * @param {Windows.Media.Capture.VideoRotation} value The amount by which to rotate the video.
 * @return {void}
 */
Windows.Media.Capture.MediaCapture.prototype.setRecordRotation = function(value) {};

/**
 * Start recording to a custom media sink using the specified encoding profile and sink settings.
 * Start recording to a custom media sink using the specified encoding profile.
 * @param {!Windows.Media.MediaProperties.MediaEncodingProfile} encodingProfile The encoding profile to use for the recording.
 * @param {string|!Windows.Media.IMediaExtension} customSinkActivationId_or_customMediaSink The activatable class ID of the media extension for the custom media sink. / The media extension for the custom media sink.
 * @param {!Windows.Foundation.Collections.IPropertySet=} customSinkSettings Contains properties of the media extension.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Anobject that is used to control the asynchronous operation. / An object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.MediaCapture.prototype.startRecordToCustomSinkAsync = function(encodingProfile, customSinkActivationId_or_customMediaSink, customSinkSettings) {};

/**
 * Starts recording asynchronously to a storage file.
 * @param {!Windows.Media.MediaProperties.MediaEncodingProfile} encodingProfile The encoding profile for the recording.
 * @param {!Windows.Storage.IStorageFile} file The storage file where the image is saved.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Returns a IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.MediaCapture.prototype.startRecordToStorageFileAsync = function(encodingProfile, file) {};

/**
 * Starts recording to a random-access stream.
 * @param {!Windows.Media.MediaProperties.MediaEncodingProfile} encodingProfile The encoding profile for the recording.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} stream The stream where the image data is written.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Returns a IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.MediaCapture.prototype.startRecordToStreamAsync = function(encodingProfile, stream) {};

/**
 * Stops recording.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Returns a IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Media.Capture.MediaCapture.prototype.stopRecordAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.MediaCaptureFailedEventArgs = function() {};
 /** @type {number} */
Windows.Media.Capture.MediaCaptureFailedEventArgs.prototype.code;
 /** @type {string} */
Windows.Media.Capture.MediaCaptureFailedEventArgs.prototype.message;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.MediaCaptureFocusChangedEventArgs = function() {};
 /** @type {Windows.Media.Devices.MediaCaptureFocusState} */
Windows.Media.Capture.MediaCaptureFocusChangedEventArgs.prototype.focusState;

/**
 * @constructor
 * @struct
 * Creates a new instance of the MediaCaptureInitializationSettings object.
 */
Windows.Media.Capture.MediaCaptureInitializationSettings = function() {};
 /** @type {string} */
Windows.Media.Capture.MediaCaptureInitializationSettings.prototype.audioDeviceId;
 /** @type {Windows.Media.AudioProcessing} */
Windows.Media.Capture.MediaCaptureInitializationSettings.prototype.audioProcessing;
 /** @type {!Windows.Media.Core.IMediaSource} */
Windows.Media.Capture.MediaCaptureInitializationSettings.prototype.audioSource;
 /** @type {Windows.Media.Capture.MediaCategory} */
Windows.Media.Capture.MediaCaptureInitializationSettings.prototype.mediaCategory;
 /** @type {Windows.Media.Capture.PhotoCaptureSource} */
Windows.Media.Capture.MediaCaptureInitializationSettings.prototype.photoCaptureSource;
 /** @type {!Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription} */
Windows.Media.Capture.MediaCaptureInitializationSettings.prototype.photoMediaDescription;
 /** @type {!Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription} */
Windows.Media.Capture.MediaCaptureInitializationSettings.prototype.previewMediaDescription;
 /** @type {!Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription} */
Windows.Media.Capture.MediaCaptureInitializationSettings.prototype.recordMediaDescription;
 /** @type {Windows.Media.Capture.StreamingCaptureMode} */
Windows.Media.Capture.MediaCaptureInitializationSettings.prototype.streamingCaptureMode;
 /** @type {string} */
Windows.Media.Capture.MediaCaptureInitializationSettings.prototype.videoDeviceId;
 /** @type {!Windows.Media.Capture.MediaCaptureVideoProfile} */
Windows.Media.Capture.MediaCaptureInitializationSettings.prototype.videoProfile;
 /** @type {!Windows.Media.Core.IMediaSource} */
Windows.Media.Capture.MediaCaptureInitializationSettings.prototype.videoSource;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.MediaCaptureSettings = function() {};
 /** @type {string} */
Windows.Media.Capture.MediaCaptureSettings.prototype.audioDeviceId;
 /** @type {Windows.Media.AudioProcessing} */
Windows.Media.Capture.MediaCaptureSettings.prototype.audioProcessing;
 /** @type {boolean} */
Windows.Media.Capture.MediaCaptureSettings.prototype.cameraSoundRequiredForRegion;
 /** @type {boolean} */
Windows.Media.Capture.MediaCaptureSettings.prototype.concurrentRecordAndPhotoSequenceSupported;
 /** @type {boolean} */
Windows.Media.Capture.MediaCaptureSettings.prototype.concurrentRecordAndPhotoSupported;
 /** @type {number} */
Windows.Media.Capture.MediaCaptureSettings.prototype.horizontal35mmEquivalentFocalLength;
 /** @type {Windows.Media.Capture.MediaCategory} */
Windows.Media.Capture.MediaCaptureSettings.prototype.mediaCategory;
 /** @type {Windows.Media.Capture.PhotoCaptureSource} */
Windows.Media.Capture.MediaCaptureSettings.prototype.photoCaptureSource;
 /** @type {number} */
Windows.Media.Capture.MediaCaptureSettings.prototype.pitchOffsetDegrees;
 /** @type {Windows.Media.Capture.StreamingCaptureMode} */
Windows.Media.Capture.MediaCaptureSettings.prototype.streamingCaptureMode;
 /** @type {number} */
Windows.Media.Capture.MediaCaptureSettings.prototype.vertical35mmEquivalentFocalLength;
 /** @type {Windows.Media.Capture.VideoDeviceCharacteristic} */
Windows.Media.Capture.MediaCaptureSettings.prototype.videoDeviceCharacteristic;
 /** @type {string} */
Windows.Media.Capture.MediaCaptureSettings.prototype.videoDeviceId;

/** @const */
Windows.Media.Capture.MediaCaptureThermalStatus = {};
/** @const {number} */
Windows.Media.Capture.MediaCaptureThermalStatus.normal;
/** @const {number} */
Windows.Media.Capture.MediaCaptureThermalStatus.overheated;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.MediaCaptureVideoProfile = function() {};
 /** @type {string} */
Windows.Media.Capture.MediaCaptureVideoProfile.prototype.id;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription>} */
Windows.Media.Capture.MediaCaptureVideoProfile.prototype.supportedPhotoMediaDescription;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription>} */
Windows.Media.Capture.MediaCaptureVideoProfile.prototype.supportedPreviewMediaDescription;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription>} */
Windows.Media.Capture.MediaCaptureVideoProfile.prototype.supportedRecordMediaDescription;
 /** @type {string} */
Windows.Media.Capture.MediaCaptureVideoProfile.prototype.videoDeviceId;

/**
 * Gets the list of MediaCaptureVideoProfile objects that can be used concurrently with this video profile.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Capture.MediaCaptureVideoProfile>} The list of MediaCaptureVideoProfile objects that can be used concurrently with this video profile.
 */
Windows.Media.Capture.MediaCaptureVideoProfile.prototype.getConcurrency = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription = function() {};
 /** @type {number} */
Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription.prototype.frameRate;
 /** @type {number} */
Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription.prototype.height;
 /** @type {boolean} */
Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription.prototype.isHdrVideoSupported;
 /** @type {boolean} */
Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription.prototype.isVariablePhotoSequenceSupported;
 /** @type {number} */
Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription.prototype.width;

/** @const */
Windows.Media.Capture.MediaCategory = {};
/** @const {number} */
Windows.Media.Capture.MediaCategory.other;
/** @const {number} */
Windows.Media.Capture.MediaCategory.communications;
/** @const {number} */
Windows.Media.Capture.MediaCategory.media;
/** @const {number} */
Windows.Media.Capture.MediaCategory.gameChat;
/** @const {number} */
Windows.Media.Capture.MediaCategory.speech;

/** @const */
Windows.Media.Capture.MediaStreamType = {};
/** @const {number} */
Windows.Media.Capture.MediaStreamType.videoPreview;
/** @const {number} */
Windows.Media.Capture.MediaStreamType.videoRecord;
/** @const {number} */
Windows.Media.Capture.MediaStreamType.audio;
/** @const {number} */
Windows.Media.Capture.MediaStreamType.photo;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.OptionalReferencePhotoCapturedEventArgs = function() {};
 /** @type {?} */
Windows.Media.Capture.OptionalReferencePhotoCapturedEventArgs.prototype.context;
 /** @type {!Windows.Media.Capture.CapturedFrame} */
Windows.Media.Capture.OptionalReferencePhotoCapturedEventArgs.prototype.frame;

/** @const */
Windows.Media.Capture.PhotoCaptureSource = {};
/** @const {number} */
Windows.Media.Capture.PhotoCaptureSource.auto;
/** @const {number} */
Windows.Media.Capture.PhotoCaptureSource.videoPreview;
/** @const {number} */
Windows.Media.Capture.PhotoCaptureSource.photo;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.PhotoCapturedEventArgs = function() {};
 /** @type {number} */
Windows.Media.Capture.PhotoCapturedEventArgs.prototype.captureTimeOffset;
 /** @type {!Windows.Media.Capture.CapturedFrame} */
Windows.Media.Capture.PhotoCapturedEventArgs.prototype.frame;
 /** @type {!Windows.Media.Capture.CapturedFrame} */
Windows.Media.Capture.PhotoCapturedEventArgs.prototype.thumbnail;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.PhotoConfirmationCapturedEventArgs = function() {};
 /** @type {number} */
Windows.Media.Capture.PhotoConfirmationCapturedEventArgs.prototype.captureTimeOffset;
 /** @type {!Windows.Media.Capture.CapturedFrame} */
Windows.Media.Capture.PhotoConfirmationCapturedEventArgs.prototype.frame;

/** @const */
Windows.Media.Capture.PowerlineFrequency = {};
/** @const {number} */
Windows.Media.Capture.PowerlineFrequency.disabled;
/** @const {number} */
Windows.Media.Capture.PowerlineFrequency.fiftyHertz;
/** @const {number} */
Windows.Media.Capture.PowerlineFrequency.sixtyHertz;

/** @const */
Windows.Media.Capture.StreamingCaptureMode = {};
/** @const {number} */
Windows.Media.Capture.StreamingCaptureMode.audioAndVideo;
/** @const {number} */
Windows.Media.Capture.StreamingCaptureMode.audio;
/** @const {number} */
Windows.Media.Capture.StreamingCaptureMode.video;

/** @const */
Windows.Media.Capture.VideoDeviceCharacteristic = {};
/** @const {number} */
Windows.Media.Capture.VideoDeviceCharacteristic.allStreamsIndependent;
/** @const {number} */
Windows.Media.Capture.VideoDeviceCharacteristic.previewRecordStreamsIdentical;
/** @const {number} */
Windows.Media.Capture.VideoDeviceCharacteristic.previewPhotoStreamsIdentical;
/** @const {number} */
Windows.Media.Capture.VideoDeviceCharacteristic.recordPhotoStreamsIdentical;
/** @const {number} */
Windows.Media.Capture.VideoDeviceCharacteristic.allStreamsIdentical;

/** @const */
Windows.Media.Capture.VideoRotation = {};
/** @const {number} */
Windows.Media.Capture.VideoRotation.none;
/** @const {number} */
Windows.Media.Capture.VideoRotation.clockwise90Degrees;
/** @const {number} */
Windows.Media.Capture.VideoRotation.clockwise180Degrees;
/** @const {number} */
Windows.Media.Capture.VideoRotation.clockwise270Degrees;
/**
 * @constructor
 * @struct
 */
Windows.Media.Capture.VideoStreamConfiguration = function() {};
 /** @type {!Windows.Media.MediaProperties.VideoEncodingProperties} */
Windows.Media.Capture.VideoStreamConfiguration.prototype.inputProperties;
 /** @type {!Windows.Media.MediaProperties.VideoEncodingProperties} */
Windows.Media.Capture.VideoStreamConfiguration.prototype.outputProperties;
/**
 * @record
 * @struct
 */
Windows.Media.Capture.WhiteBalanceGain = function() {};
 /** @type {number} */
Windows.Media.Capture.WhiteBalanceGain.prototype.b;
 /** @type {number} */
Windows.Media.Capture.WhiteBalanceGain.prototype.g;
 /** @type {number} */
Windows.Media.Capture.WhiteBalanceGain.prototype.r;

/** @typedef {function(?): void} */
Windows.Media.Capture.MediaCaptureFailedEventHandler;

/** @typedef {function(!Windows.WinRTEvent<!Windows.Media.Capture.MediaCapture>): void} */
Windows.Media.Capture.RecordLimitationExceededEventHandler;
/** @const */
Windows.Media.Casting = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Casting.CastingConnection = function() {};
 /** @type {!Windows.Media.Casting.CastingDevice} */
Windows.Media.Casting.CastingConnection.prototype.device;
 /** @type {function(?): void} */
Windows.Media.Casting.CastingConnection.prototype.onerroroccurred;
 /** @type {function(?): void} */
Windows.Media.Casting.CastingConnection.prototype.onstatechanged;
 /** @type {!Windows.Media.Casting.CastingSource} */
Windows.Media.Casting.CastingConnection.prototype.source;
 /** @type {Windows.Media.Casting.CastingConnectionState} */
Windows.Media.Casting.CastingConnection.prototype.state;

/**
 * Closes the casting connection.
 * @return {void}
 */
Windows.Media.Casting.CastingConnection.prototype.close = function() {};

/**
 * Terminates a casting connection. The content that was rendering remotely returns to the local element that you retrieved the casting source from.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Media.Casting.CastingConnectionErrorStatus, !Windows.Foundation.IAsyncOperation<Windows.Media.Casting.CastingConnectionErrorStatus>>} The status of the termination.
 */
Windows.Media.Casting.CastingConnection.prototype.disconnectAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Casting.CastingConnection.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Casting.CastingConnection.prototype.removeEventListener = function(type, listener) {};

/**
 * Starts the process of casting to a casting device. When called, this method pairs the c sting device, if necessary, and verifies access to the casting device with the user. If the user denies the app access to the device, casting fails. Otherwise, a connection is established, and content is sent to the device. During this time, the connection state changes to connecting, then to connected. If a casting source is set, the state changes to rendering once playback begins.
 * @param {!Windows.Media.Casting.CastingSource} value The content to be casted.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Media.Casting.CastingConnectionErrorStatus, !Windows.Foundation.IAsyncOperation<Windows.Media.Casting.CastingConnectionErrorStatus>>} The status of the casting connection request.
 */
Windows.Media.Casting.CastingConnection.prototype.requestStartCastingAsync = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Casting.CastingConnectionErrorOccurredEventArgs = function() {};
 /** @type {Windows.Media.Casting.CastingConnectionErrorStatus} */
Windows.Media.Casting.CastingConnectionErrorOccurredEventArgs.prototype.errorStatus;
 /** @type {string} */
Windows.Media.Casting.CastingConnectionErrorOccurredEventArgs.prototype.message;

/** @const */
Windows.Media.Casting.CastingConnectionErrorStatus = {};
/** @const {number} */
Windows.Media.Casting.CastingConnectionErrorStatus.succeeded;
/** @const {number} */
Windows.Media.Casting.CastingConnectionErrorStatus.deviceDidNotRespond;
/** @const {number} */
Windows.Media.Casting.CastingConnectionErrorStatus.deviceError;
/** @const {number} */
Windows.Media.Casting.CastingConnectionErrorStatus.deviceLocked;
/** @const {number} */
Windows.Media.Casting.CastingConnectionErrorStatus.protectedPlaybackFailed;
/** @const {number} */
Windows.Media.Casting.CastingConnectionErrorStatus.invalidCastingSource;
/** @const {number} */
Windows.Media.Casting.CastingConnectionErrorStatus.unknown;

/** @const */
Windows.Media.Casting.CastingConnectionState = {};
/** @const {number} */
Windows.Media.Casting.CastingConnectionState.disconnected;
/** @const {number} */
Windows.Media.Casting.CastingConnectionState.connected;
/** @const {number} */
Windows.Media.Casting.CastingConnectionState.rendering;
/** @const {number} */
Windows.Media.Casting.CastingConnectionState.disconnecting;
/** @const {number} */
Windows.Media.Casting.CastingConnectionState.connecting;
/**
 * @constructor
 * @struct
 */
Windows.Media.Casting.CastingDevice = function() {};
 /** @type {string} */
Windows.Media.Casting.CastingDevice.prototype.friendlyName;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamWithContentType} */
Windows.Media.Casting.CastingDevice.prototype.icon;
 /** @type {string} */
Windows.Media.Casting.CastingDevice.prototype.id;

/**
 * Indicates whether the given device (a DeviceInformation object) supports casting.
 * @param {!Windows.Devices.Enumeration.DeviceInformation} device The device you want to know about.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} True if the device supports casting; false otherwise.
 */
Windows.Media.Casting.CastingDevice.deviceInfoSupportsCastingAsync = function(device) {};

/**
 * Gets a CastingDevice object for a given a device ID (acquired from a query using the Windows.Devices.Enumeration APIs).
 * @param {string} value The device ID.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Casting.CastingDevice, !Windows.Foundation.IAsyncOperation<!Windows.Media.Casting.CastingDevice>>} The object representing the casting device.
 */
Windows.Media.Casting.CastingDevice.fromIdAsync = function(value) {};

/**
 * Gets an AQS filter string to be used with the Windows.Devices.Enumeration APIs for a given CastingPlaybackTypes .
 * @param {Windows.Media.Casting.CastingPlaybackTypes} type The casting playback type.
 * @return {string} The AQS filter string.
 */
Windows.Media.Casting.CastingDevice.getDeviceSelector = function(type) {};

/**
 * Gets an AQS filter string to be used with the Windows.Devices.Enumeration APIs for a given CastingSource .
 * @param {!Windows.Media.Casting.CastingSource} castingSource The casting source.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} The AQS filter string.
 */
Windows.Media.Casting.CastingDevice.getDeviceSelectorFromCastingSourceAsync = function(castingSource) {};

/**
 * Creates a new CastingConnection object. This method does not establish a connection to the casting device.
 * @return {!Windows.Media.Casting.CastingConnection} The object that represents the casting connection.
 */
Windows.Media.Casting.CastingDevice.prototype.createCastingConnection = function() {};

/**
 * Gets the media types supported by the device. containing
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Media.Casting.CastingPlaybackTypes, !Windows.Foundation.IAsyncOperation<Windows.Media.Casting.CastingPlaybackTypes>>} The media types, CastingPlaybackTypes , supported by the device.
 */
Windows.Media.Casting.CastingDevice.prototype.getSupportedCastingPlaybackTypesAsync = function() {};

/**
 * @constructor
 * @struct
 * Creates a CastingDevicePicker object.
 */
Windows.Media.Casting.CastingDevicePicker = function() {};
 /** @type {!Windows.Devices.Enumeration.DevicePickerAppearance} */
Windows.Media.Casting.CastingDevicePicker.prototype.appearance;
 /** @type {!Windows.Media.Casting.CastingDevicePickerFilter} */
Windows.Media.Casting.CastingDevicePicker.prototype.filter;
 /** @type {function(?): void} */
Windows.Media.Casting.CastingDevicePicker.prototype.oncastingdevicepickerdismissed;
 /** @type {function(?): void} */
Windows.Media.Casting.CastingDevicePicker.prototype.oncastingdeviceselected;

/**
 * Hides the device picker UI.
 * @return {void}
 */
Windows.Media.Casting.CastingDevicePicker.prototype.hide = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Casting.CastingDevicePicker.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Casting.CastingDevicePicker.prototype.removeEventListener = function(type, listener) {};

/**
 * Shows the casting device picker UI, which flies out from the specified edge of the provided rectangle.
 * Shows the casting device picker UI, which flies out from an edge of the provided rectangle.
 * @param {!Windows.Foundation.Rect} selection The rectangle from which the picker should fly out. / The rectangle from which the picker UI should fly out.
 * @param {Windows.UI.Popups.Placement=} preferredPlacement The edge of the rectangle from which the picker should fly out.
 * @return {void}
 */
Windows.Media.Casting.CastingDevicePicker.prototype.show = function(selection, preferredPlacement) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Casting.CastingDevicePickerFilter = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Casting.CastingSource>} */
Windows.Media.Casting.CastingDevicePickerFilter.prototype.supportedCastingSources;
 /** @type {boolean} */
Windows.Media.Casting.CastingDevicePickerFilter.prototype.supportsAudio;
 /** @type {boolean} */
Windows.Media.Casting.CastingDevicePickerFilter.prototype.supportsPictures;
 /** @type {boolean} */
Windows.Media.Casting.CastingDevicePickerFilter.prototype.supportsVideo;
/**
 * @constructor
 * @struct
 */
Windows.Media.Casting.CastingDeviceSelectedEventArgs = function() {};
 /** @type {!Windows.Media.Casting.CastingDevice} */
Windows.Media.Casting.CastingDeviceSelectedEventArgs.prototype.selectedCastingDevice;

/** @const */
Windows.Media.Casting.CastingPlaybackTypes = {};
/** @const {number} */
Windows.Media.Casting.CastingPlaybackTypes.none;
/** @const {number} */
Windows.Media.Casting.CastingPlaybackTypes.audio;
/** @const {number} */
Windows.Media.Casting.CastingPlaybackTypes.video;
/** @const {number} */
Windows.Media.Casting.CastingPlaybackTypes.picture;
/**
 * @constructor
 * @struct
 */
Windows.Media.Casting.CastingSource = function() {};
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Casting.CastingSource.prototype.preferredSourceUri;
/** @const */
Windows.Media.ClosedCaptioning = {};

/** @const */
Windows.Media.ClosedCaptioning.ClosedCaptionColor = {};
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionColor.default;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionColor.white;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionColor.black;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionColor.red;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionColor.green;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionColor.blue;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionColor.yellow;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionColor.magenta;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionColor.cyan;

/** @const */
Windows.Media.ClosedCaptioning.ClosedCaptionEdgeEffect = {};
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionEdgeEffect.default;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionEdgeEffect.none;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionEdgeEffect.raised;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionEdgeEffect.depressed;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionEdgeEffect.uniform;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionEdgeEffect.dropShadow;

/** @const */
Windows.Media.ClosedCaptioning.ClosedCaptionOpacity = {};
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionOpacity.default;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionOpacity.oneHundredPercent;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionOpacity.seventyFivePercent;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionOpacity.twentyFivePercent;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionOpacity.zeroPercent;
/**
 * @constructor
 * @struct
 */
Windows.Media.ClosedCaptioning.ClosedCaptionProperties = function() {};
 /** @type {Windows.Media.ClosedCaptioning.ClosedCaptionColor} */
Windows.Media.ClosedCaptioning.ClosedCaptionProperties.backgroundColor;
 /** @type {Windows.Media.ClosedCaptioning.ClosedCaptionOpacity} */
Windows.Media.ClosedCaptioning.ClosedCaptionProperties.backgroundOpacity;
 /** @type {!Windows.UI.Color} */
Windows.Media.ClosedCaptioning.ClosedCaptionProperties.computedBackgroundColor;
 /** @type {!Windows.UI.Color} */
Windows.Media.ClosedCaptioning.ClosedCaptionProperties.computedFontColor;
 /** @type {!Windows.UI.Color} */
Windows.Media.ClosedCaptioning.ClosedCaptionProperties.computedRegionColor;
 /** @type {Windows.Media.ClosedCaptioning.ClosedCaptionColor} */
Windows.Media.ClosedCaptioning.ClosedCaptionProperties.fontColor;
 /** @type {Windows.Media.ClosedCaptioning.ClosedCaptionEdgeEffect} */
Windows.Media.ClosedCaptioning.ClosedCaptionProperties.fontEffect;
 /** @type {Windows.Media.ClosedCaptioning.ClosedCaptionOpacity} */
Windows.Media.ClosedCaptioning.ClosedCaptionProperties.fontOpacity;
 /** @type {Windows.Media.ClosedCaptioning.ClosedCaptionSize} */
Windows.Media.ClosedCaptioning.ClosedCaptionProperties.fontSize;
 /** @type {Windows.Media.ClosedCaptioning.ClosedCaptionStyle} */
Windows.Media.ClosedCaptioning.ClosedCaptionProperties.fontStyle;
 /** @type {Windows.Media.ClosedCaptioning.ClosedCaptionColor} */
Windows.Media.ClosedCaptioning.ClosedCaptionProperties.regionColor;
 /** @type {Windows.Media.ClosedCaptioning.ClosedCaptionOpacity} */
Windows.Media.ClosedCaptioning.ClosedCaptionProperties.regionOpacity;

/** @const */
Windows.Media.ClosedCaptioning.ClosedCaptionSize = {};
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionSize.default;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionSize.fiftyPercent;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionSize.oneHundredPercent;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionSize.oneHundredFiftyPercent;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionSize.twoHundredPercent;

/** @const */
Windows.Media.ClosedCaptioning.ClosedCaptionStyle = {};
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionStyle.default;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionStyle.monospacedWithSerifs;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionStyle.proportionalWithSerifs;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionStyle.monospacedWithoutSerifs;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionStyle.proportionalWithoutSerifs;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionStyle.casual;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionStyle.cursive;
/** @const {number} */
Windows.Media.ClosedCaptioning.ClosedCaptionStyle.smallCapitals;
/** @const */
Windows.Media.ContentRestrictions = {};

/** @const */
Windows.Media.ContentRestrictions.ContentAccessRestrictionLevel = {};
/** @const {number} */
Windows.Media.ContentRestrictions.ContentAccessRestrictionLevel.allow;
/** @const {number} */
Windows.Media.ContentRestrictions.ContentAccessRestrictionLevel.warn;
/** @const {number} */
Windows.Media.ContentRestrictions.ContentAccessRestrictionLevel.block;
/** @const {number} */
Windows.Media.ContentRestrictions.ContentAccessRestrictionLevel.hide;
/**
 * @constructor
 * @struct
 */
Windows.Media.ContentRestrictions.ContentRestrictionsBrowsePolicy = function() {};
 /** @type {string} */
Windows.Media.ContentRestrictions.ContentRestrictionsBrowsePolicy.prototype.geographicRegion;
 /** @type {number} */
Windows.Media.ContentRestrictions.ContentRestrictionsBrowsePolicy.prototype.maxBrowsableAgeRating;
 /** @type {number} */
Windows.Media.ContentRestrictions.ContentRestrictionsBrowsePolicy.prototype.preferredAgeRating;

/** @const */
Windows.Media.ContentRestrictions.RatedContentCategory = {};
/** @const {number} */
Windows.Media.ContentRestrictions.RatedContentCategory.general;
/** @const {number} */
Windows.Media.ContentRestrictions.RatedContentCategory.application;
/** @const {number} */
Windows.Media.ContentRestrictions.RatedContentCategory.game;
/** @const {number} */
Windows.Media.ContentRestrictions.RatedContentCategory.movie;
/** @const {number} */
Windows.Media.ContentRestrictions.RatedContentCategory.television;
/** @const {number} */
Windows.Media.ContentRestrictions.RatedContentCategory.music;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the RatedContentDescription class.
 * @param {string} id The ID of the content, as specified by the app developer.
 * @param {string} title The title of the content.
 * @param {Windows.Media.ContentRestrictions.RatedContentCategory} category Specifies the type of a piece of content, defined by RatedContentCategory .
 */
Windows.Media.ContentRestrictions.RatedContentDescription = function(id, title, category) {};
 /** @type {Windows.Media.ContentRestrictions.RatedContentCategory} */
Windows.Media.ContentRestrictions.RatedContentDescription.prototype.category;
 /** @type {string} */
Windows.Media.ContentRestrictions.RatedContentDescription.prototype.id;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.Media.ContentRestrictions.RatedContentDescription.prototype.image;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Media.ContentRestrictions.RatedContentDescription.prototype.ratings;
 /** @type {string} */
Windows.Media.ContentRestrictions.RatedContentDescription.prototype.title;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the RatedContentRestrictions class.
 * Initializes a new instance of the RatedContentRestrictions class, with the specified age rating the app uses, to restrict content usage.
 * @param {number=} maxAgeRating The max age rating.
 */
Windows.Media.ContentRestrictions.RatedContentRestrictions = function(maxAgeRating) {};
 /** @type {function(?): void} */
Windows.Media.ContentRestrictions.RatedContentRestrictions.prototype.onrestrictionschanged;

/**
 * Gets information that is used filter an app's content catalog.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.ContentRestrictions.ContentRestrictionsBrowsePolicy, !Windows.Foundation.IAsyncOperation<!Windows.Media.ContentRestrictions.ContentRestrictionsBrowsePolicy>>} Returns a ContentRestrictionsBrowsePolicy object.
 */
Windows.Media.ContentRestrictions.RatedContentRestrictions.prototype.getBrowsePolicyAsync = function() {};

/**
 * Gets the policy that applies to a piece of content, for content browsing and consumption.
 * @param {!Windows.Media.ContentRestrictions.RatedContentDescription} RatedContentDescription The rated content info.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Media.ContentRestrictions.ContentAccessRestrictionLevel, !Windows.Foundation.IAsyncOperation<Windows.Media.ContentRestrictions.ContentAccessRestrictionLevel>>} This method returns these values:
 */
Windows.Media.ContentRestrictions.RatedContentRestrictions.prototype.getRestrictionLevelAsync = function(RatedContentDescription) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.ContentRestrictions.RatedContentRestrictions.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.ContentRestrictions.RatedContentRestrictions.prototype.removeEventListener = function(type, listener) {};

/**
 * Determines whether the user is allowed to consume a piece of content.
 * @param {!Windows.Media.ContentRestrictions.RatedContentDescription} RatedContentDescription The rated content info.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} Returns true, if the user can consume the content. Otherwise, returns false.
 */
Windows.Media.ContentRestrictions.RatedContentRestrictions.prototype.requestContentAccessAsync = function(RatedContentDescription) {};

/**
 * @constructor
 * @struct
 * Creates an instance of AudioStreamDescriptor class using the specified AudioEncodingProperties .
 * @param {!Windows.Media.MediaProperties.AudioEncodingProperties} encodingProperties The encoding properties for the audio stream.
 */
Windows.Media.Core.AudioStreamDescriptor = function(encodingProperties) {};
 /** @type {!Windows.Media.MediaProperties.AudioEncodingProperties} */
Windows.Media.Core.AudioStreamDescriptor.prototype.encodingProperties;
 /** @type {boolean} */
Windows.Media.Core.AudioStreamDescriptor.prototype.isSelected;
 /** @type {string} */
Windows.Media.Core.AudioStreamDescriptor.prototype.language;
 /** @type {string} */
Windows.Media.Core.AudioStreamDescriptor.prototype.name;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.AudioTrack = function() {};
 /** @type {string} */
Windows.Media.Core.AudioTrack.prototype.id;
 /** @type {string} */
Windows.Media.Core.AudioTrack.prototype.label;
 /** @type {string} */
Windows.Media.Core.AudioTrack.prototype.language;
 /** @type {Windows.Media.Core.MediaTrackKind} */
Windows.Media.Core.AudioTrack.prototype.trackKind;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the DataCue class.
 */
Windows.Media.Core.DataCue = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Media.Core.DataCue.prototype.data;
 /** @type {number} */
Windows.Media.Core.DataCue.prototype.duration;
 /** @type {string} */
Windows.Media.Core.DataCue.prototype.id;
 /** @type {number} */
Windows.Media.Core.DataCue.prototype.startTime;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.FaceDetectedEventArgs = function() {};
 /** @type {!Windows.Media.Core.FaceDetectionEffectFrame} */
Windows.Media.Core.FaceDetectedEventArgs.prototype.resultFrame;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.FaceDetectionEffect = function() {};
 /** @type {number} */
Windows.Media.Core.FaceDetectionEffect.prototype.desiredDetectionInterval;
 /** @type {boolean} */
Windows.Media.Core.FaceDetectionEffect.prototype.enabled;
 /** @type {function(?): void} */
Windows.Media.Core.FaceDetectionEffect.prototype.onfacedetected;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.FaceDetectionEffect.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.FaceDetectionEffect.prototype.removeEventListener = function(type, listener) {};

/**
 * Sets properties on the IMediaExtension .
 * @param {!Windows.Foundation.Collections.IPropertySet} configuration The property set.
 * @return {void}
 */
Windows.Media.Core.FaceDetectionEffect.prototype.setProperties = function(configuration) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the FaceDetectionEffectDefinition class.
 */
Windows.Media.Core.FaceDetectionEffectDefinition = function() {};
 /** @type {string} */
Windows.Media.Core.FaceDetectionEffectDefinition.prototype.activatableClassId;
 /** @type {Windows.Media.Core.FaceDetectionMode} */
Windows.Media.Core.FaceDetectionEffectDefinition.prototype.detectionMode;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Core.FaceDetectionEffectDefinition.prototype.properties;
 /** @type {boolean} */
Windows.Media.Core.FaceDetectionEffectDefinition.prototype.synchronousDetectionEnabled;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.FaceDetectionEffectFrame = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.FaceAnalysis.DetectedFace>} */
Windows.Media.Core.FaceDetectionEffectFrame.prototype.detectedFaces;
 /** @type {number} */
Windows.Media.Core.FaceDetectionEffectFrame.prototype.duration;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Core.FaceDetectionEffectFrame.prototype.extendedProperties;
 /** @type {boolean} */
Windows.Media.Core.FaceDetectionEffectFrame.prototype.isDiscontinuous;
 /** @type {boolean} */
Windows.Media.Core.FaceDetectionEffectFrame.prototype.isReadOnly;
 /** @type {number} */
Windows.Media.Core.FaceDetectionEffectFrame.prototype.relativeTime;
 /** @type {number} */
Windows.Media.Core.FaceDetectionEffectFrame.prototype.systemRelativeTime;
 /** @type {string} */
Windows.Media.Core.FaceDetectionEffectFrame.prototype.type;

/**
 * Disposes of the object and associated resources.
 * @return {void}
 */
Windows.Media.Core.FaceDetectionEffectFrame.prototype.close = function() {};

/** @const */
Windows.Media.Core.FaceDetectionMode = {};
/** @const {number} */
Windows.Media.Core.FaceDetectionMode.highPerformance;
/** @const {number} */
Windows.Media.Core.FaceDetectionMode.balanced;
/** @const {number} */
Windows.Media.Core.FaceDetectionMode.highQuality;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.HighDynamicRangeControl = function() {};
 /** @type {boolean} */
Windows.Media.Core.HighDynamicRangeControl.prototype.enabled;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.HighDynamicRangeOutput = function() {};
 /** @type {number} */
Windows.Media.Core.HighDynamicRangeOutput.prototype.certainty;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Devices.Core.FrameController>} */
Windows.Media.Core.HighDynamicRangeOutput.prototype.frameControllers;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the MediaBinder class.
 */
Windows.Media.Core.MediaBinder = function() {};
 /** @type {function(?): void} */
Windows.Media.Core.MediaBinder.prototype.onbinding;
 /** @type {!Windows.Media.Core.MediaSource} */
Windows.Media.Core.MediaBinder.prototype.source;
 /** @type {string} */
Windows.Media.Core.MediaBinder.prototype.token;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.MediaBinder.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.MediaBinder.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaBindingEventArgs = function() {};
 /** @type {!Windows.Media.Core.MediaBinder} */
Windows.Media.Core.MediaBindingEventArgs.prototype.mediaBinder;
 /** @type {function(?): void} */
Windows.Media.Core.MediaBindingEventArgs.prototype.oncanceled;

/**
 * Informs the system that the app might continue to perform work after the Binding event handler returns.
 * @return {!Windows.Foundation.Deferral} The requested deferral.
 */
Windows.Media.Core.MediaBindingEventArgs.prototype.getDeferral = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.MediaBindingEventArgs.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.MediaBindingEventArgs.prototype.removeEventListener = function(type, listener) {};

/**
 * Sets the media content to be bound to the MediaSource .
 * @param {!Windows.Storage.Streams.IRandomAccessStream} stream A stream containing the media content.
 * @param {string} contentType A string specifying the content type of the media content.
 * @return {void}
 */
Windows.Media.Core.MediaBindingEventArgs.prototype.setStream = function(stream, contentType) {};

/**
 * Sets the media content to be bound to the MediaSource .
 * @param {!Windows.Storage.Streams.IRandomAccessStreamReference} stream A stream reference containing the media content to be bound.
 * @param {string} contentType A string specifying the content type of the media content.
 * @return {void}
 */
Windows.Media.Core.MediaBindingEventArgs.prototype.setStreamReference = function(stream, contentType) {};

/**
 * Sets the URI of the media content to be bound to the MediaSource .
 * @param {!Windows.Foundation.Uri} uri The URI of the media content to be bound.
 * @return {void}
 */
Windows.Media.Core.MediaBindingEventArgs.prototype.setUri = function(uri) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaCueEventArgs = function() {};
 /** @type {!Windows.Media.Core.IMediaCue} */
Windows.Media.Core.MediaCueEventArgs.prototype.cue;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaSource = function() {};
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.Media.Core.MediaSource.prototype.customProperties;
 /** @type {number} */
Windows.Media.Core.MediaSource.prototype.duration;
 /** @type {!Windows.Foundation.Collections.IObservableVector<!Windows.Media.Core.TimedMetadataTrack>} */
Windows.Media.Core.MediaSource.prototype.externalTimedMetadataTracks;
 /** @type {!Windows.Foundation.Collections.IObservableVector<!Windows.Media.Core.TimedTextSource>} */
Windows.Media.Core.MediaSource.prototype.externalTimedTextSources;
 /** @type {boolean} */
Windows.Media.Core.MediaSource.prototype.isOpen;
 /** @type {function(?): void} */
Windows.Media.Core.MediaSource.prototype.onopenoperationcompleted;
 /** @type {function(?): void} */
Windows.Media.Core.MediaSource.prototype.onstatechanged;
 /** @type {Windows.Media.Core.MediaSourceState} */
Windows.Media.Core.MediaSource.prototype.state;

/**
 * Creates an instance of MediaSource from the provided AdaptiveMediaSource .
 * @param {!Windows.Media.Streaming.Adaptive.AdaptiveMediaSource} mediaSource The AdaptiveMediaSource from which the MediaSource is created.
 * @return {!Windows.Media.Core.MediaSource} The new media source.
 */
Windows.Media.Core.MediaSource.createFromAdaptiveMediaSource = function(mediaSource) {};

/**
 * Creates an instance of MediaSource from the provided IMediaSource .
 * @param {!Windows.Media.Core.IMediaSource} mediaSource The IMediaSource from which the MediaSource is created.
 * @return {!Windows.Media.Core.MediaSource} The new media source.
 */
Windows.Media.Core.MediaSource.createFromIMediaSource = function(mediaSource) {};

/**
 * Creates an instance of MediaSource from the provided MediaBinder .
 * @param {!Windows.Media.Core.MediaBinder} binder The MediaBinder with which the MediaSource is associated.
 * @return {!Windows.Media.Core.MediaSource} The new media source.
 */
Windows.Media.Core.MediaSource.createFromMediaBinder = function(binder) {};

/**
 * Creates an instance of MediaSource from the provided MediaStreamSource .
 * @param {!Windows.Media.Core.MediaStreamSource} mediaSource The MediaStreamSource from which the MediaSource is created.
 * @return {!Windows.Media.Core.MediaSource} The new media source.
 */
Windows.Media.Core.MediaSource.createFromMediaStreamSource = function(mediaSource) {};

/**
 * Creates an instance of MediaSource from the provided MseStreamSource .
 * @param {!Windows.Media.Core.MseStreamSource} mediaSource The MediaStreamSource from which the MediaSource is created.
 * @return {!Windows.Media.Core.MediaSource} The new media source.
 */
Windows.Media.Core.MediaSource.createFromMseStreamSource = function(mediaSource) {};

/**
 * Creates an instance of MediaSource from the provided IStorageFile .
 * @param {!Windows.Storage.IStorageFile} file The IStorageFile from which the MediaSource is created.
 * @return {!Windows.Media.Core.MediaSource} The new media source.
 */
Windows.Media.Core.MediaSource.createFromStorageFile = function(file) {};

/**
 * Creates an instance of MediaSource from the provided IRandomAccessStream .
 * @param {!Windows.Storage.Streams.IRandomAccessStream} stream The stream from which the MediaSource is created.
 * @param {string} contentType The MIME type of the contents of the stream.
 * @return {!Windows.Media.Core.MediaSource} The new media source.
 */
Windows.Media.Core.MediaSource.createFromStream = function(stream, contentType) {};

/**
 * Creates an instance of MediaSource from the provided IRandomAccessStreamReference .
 * @param {!Windows.Storage.Streams.IRandomAccessStreamReference} stream The stream reference from which the MediaSource is created.
 * @param {string} contentType The MIME type of the contents of the stream.
 * @return {!Windows.Media.Core.MediaSource} The new media source.
 */
Windows.Media.Core.MediaSource.createFromStreamReference = function(stream, contentType) {};

/**
 * Creates an instance of MediaSource from the provided Uri .
 * @param {!Windows.Foundation.Uri} uri The URI from which the MediaSource is created.
 * @return {!Windows.Media.Core.MediaSource} The new media source.
 */
Windows.Media.Core.MediaSource.createFromUri = function(uri) {};

/**
 * Closes the MediaSource .
 * @return {void}
 */
Windows.Media.Core.MediaSource.prototype.close = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.MediaSource.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.MediaSource.prototype.removeEventListener = function(type, listener) {};

/**
 * Resets the internal state of the MediaSource .
 * @return {void}
 */
Windows.Media.Core.MediaSource.prototype.reset = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaSourceError = function() {};
 /** @type {!Windows.WinRTError} */
Windows.Media.Core.MediaSourceError.prototype.extendedError;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaSourceOpenOperationCompletedEventArgs = function() {};
 /** @type {!Windows.Media.Core.MediaSourceError} */
Windows.Media.Core.MediaSourceOpenOperationCompletedEventArgs.prototype.error;

/** @const */
Windows.Media.Core.MediaSourceState = {};
/** @const {number} */
Windows.Media.Core.MediaSourceState.initial;
/** @const {number} */
Windows.Media.Core.MediaSourceState.opening;
/** @const {number} */
Windows.Media.Core.MediaSourceState.opened;
/** @const {number} */
Windows.Media.Core.MediaSourceState.failed;
/** @const {number} */
Windows.Media.Core.MediaSourceState.closed;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaSourceStateChangedEventArgs = function() {};
 /** @type {Windows.Media.Core.MediaSourceState} */
Windows.Media.Core.MediaSourceStateChangedEventArgs.prototype.newState;
 /** @type {Windows.Media.Core.MediaSourceState} */
Windows.Media.Core.MediaSourceStateChangedEventArgs.prototype.oldState;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaStreamSample = function() {};
 /** @type {!Windows.Storage.Streams.Buffer} */
Windows.Media.Core.MediaStreamSample.prototype.buffer;
 /** @type {number} */
Windows.Media.Core.MediaStreamSample.prototype.decodeTimestamp;
 /** @type {boolean} */
Windows.Media.Core.MediaStreamSample.prototype.discontinuous;
 /** @type {number} */
Windows.Media.Core.MediaStreamSample.prototype.duration;
 /** @type {!Windows.Media.Core.MediaStreamSamplePropertySet} */
Windows.Media.Core.MediaStreamSample.prototype.extendedProperties;
 /** @type {boolean} */
Windows.Media.Core.MediaStreamSample.prototype.keyFrame;
 /** @type {function(?): void} */
Windows.Media.Core.MediaStreamSample.prototype.onprocessed;
 /** @type {!Windows.Media.Core.MediaStreamSampleProtectionProperties} */
Windows.Media.Core.MediaStreamSample.prototype.protection;
 /** @type {number} */
Windows.Media.Core.MediaStreamSample.prototype.timestamp;

/**
 * Creates a MediaStreamSample from an IBuffer .
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer that contains the media data used to create the MediaStreamSample .
 * @param {number} timestamp The presentation time of this sample.
 * @return {!Windows.Media.Core.MediaStreamSample} The sample created from the data in buffer.
 */
Windows.Media.Core.MediaStreamSample.createFromBuffer = function(buffer, timestamp) {};

/**
 * Asynchronously creates a MediaStreamSample from an IInputStream .
 * @param {!Windows.Storage.Streams.IInputStream} stream The stream that contains the media data used to create the MediaStreamSample .
 * @param {number} count The length of the data in the sample. This is the number of bytes that will be read from stream.
 * @param {number} timestamp The presentation time of this MediaStreamSample .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Core.MediaStreamSample, !Windows.Foundation.IAsyncOperation<!Windows.Media.Core.MediaStreamSample>>} When this method completes, it returns the new file as a MediaStreamSample .
 */
Windows.Media.Core.MediaStreamSample.createFromStreamAsync = function(stream, count, timestamp) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.MediaStreamSample.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.MediaStreamSample.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaStreamSamplePropertySet = function() {};
 /** @type {number} */
Windows.Media.Core.MediaStreamSamplePropertySet.prototype.size;

/**
 * Removes all items from the property set.
 * @return {void}
 */
Windows.Media.Core.MediaStreamSamplePropertySet.prototype.clear = function() {};

/**
 * Returns an iterator to enumerate the items in the property set.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The iterator. The current position of the iterator is index 0, or the end of the property set if the property set is empty.
 */
Windows.Media.Core.MediaStreamSamplePropertySet.prototype.first = function() {};

/**
 * Gets an immutable view of the property set.
 * @return {!Windows.Foundation.Collections.IMapView<string, ?>} The immutable view.
 */
Windows.Media.Core.MediaStreamSamplePropertySet.prototype.getView = function() {};

/**
 * Indicates if the specified key exists in the property set.
 * @param {string} key The key to check.
 * @return {boolean} true if the key exists; otherwise, false.
 */
Windows.Media.Core.MediaStreamSamplePropertySet.prototype.hasKey = function(key) {};

/**
 * Adds the specified key and value to the property set.
 * @param {string} key The key to add.
 * @param {?} value The value of the key.
 * @return {boolean} True if the method replaces a value that already exists for the key; false if this is a new key.
 */
Windows.Media.Core.MediaStreamSamplePropertySet.prototype.insert = function(key, value) {};

/**
 * Retrieves the value for the specified key.
 * @param {string} key The key to retrieve the value for.
 * @return {?} The value, if an item with the specified key exists; otherwise, null.
 */
Windows.Media.Core.MediaStreamSamplePropertySet.prototype.lookup = function(key) {};

/**
 * Removes an item from the property set.
 * @param {string} key The key to remove.
 * @return {void}
 */
Windows.Media.Core.MediaStreamSamplePropertySet.prototype.remove = function(key) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaStreamSampleProtectionProperties = function() {};

/**
 * Gets the Digital Rights Management (DRM) initialization vector from the MediaStreamSample .
 * @return {!Array<number>} The initialization vector.
 */
Windows.Media.Core.MediaStreamSampleProtectionProperties.prototype.getInitializationVector = function() {};

/**
 * Gets the Digital Rights Management (DRM) key identifier from the MediaStreamSample .
 * @return {!Array<number>} Receives the key identifier used to decrypt the data.
 */
Windows.Media.Core.MediaStreamSampleProtectionProperties.prototype.getKeyIdentifier = function() {};

/**
 * Gets the Digital Rights Management (DRM) sub-sample mapping from the MediaStreamSample .
 * @return {!Array<number>} Receives the sub-sample mapping.
 */
Windows.Media.Core.MediaStreamSampleProtectionProperties.prototype.getSubSampleMapping = function() {};

/**
 * Sets the Digital Rights Management (DRM) initialization vector for the MediaStreamSample .
 * @param {!Array<number>} value The value to set the DRM initialization vector to.
 * @return {void}
 */
Windows.Media.Core.MediaStreamSampleProtectionProperties.prototype.setInitializationVector = function(value) {};

/**
 * Sets the Digital Rights Management (DRM) key identifier for the MediaStreamSample .
 * @param {!Array<number>} value The value to set the DRM key identifier to.
 * @return {void}
 */
Windows.Media.Core.MediaStreamSampleProtectionProperties.prototype.setKeyIdentifier = function(value) {};

/**
 * Sets the Digital Rights Management (DRM) sub-sample mapping for the MediaStreamSample .
 * @param {!Array<number>} value The value to set the DRM sub-sample mapping to.
 * @return {void}
 */
Windows.Media.Core.MediaStreamSampleProtectionProperties.prototype.setSubSampleMapping = function(value) {};

/**
 * @constructor
 * @struct
 * Creates an instance of MediaStreamSource from the specified IMediaStreamDescriptor .
 * Creates an instance of MediaStreamSource from two IMediaStreamDescriptor objects.
 * @param {!Windows.Media.Core.IMediaStreamDescriptor} descriptor The AudioStreamDescriptor or VideoStreamDescriptor to create the MediaStreamSource from. / The first AudioStreamDescriptor or VideoStreamDescriptor to create the MediaStreamSource from.
 * @param {!Windows.Media.Core.IMediaStreamDescriptor=} descriptor2 The second AudioStreamDescriptor or VideoStreamDescriptor to create the MediaStreamSource from.
 */
Windows.Media.Core.MediaStreamSource = function(descriptor, descriptor2) {};
 /** @type {number} */
Windows.Media.Core.MediaStreamSource.prototype.bufferTime;
 /** @type {boolean} */
Windows.Media.Core.MediaStreamSource.prototype.canSeek;
 /** @type {number} */
Windows.Media.Core.MediaStreamSource.prototype.duration;
 /** @type {!Windows.Media.Protection.MediaProtectionManager} */
Windows.Media.Core.MediaStreamSource.prototype.mediaProtectionManager;
 /** @type {!Windows.Storage.FileProperties.MusicProperties} */
Windows.Media.Core.MediaStreamSource.prototype.musicProperties;
 /** @type {function(?): void} */
Windows.Media.Core.MediaStreamSource.prototype.onclosed;
 /** @type {function(?): void} */
Windows.Media.Core.MediaStreamSource.prototype.onpaused;
 /** @type {function(?): void} */
Windows.Media.Core.MediaStreamSource.prototype.onsamplerequested;
 /** @type {function(?): void} */
Windows.Media.Core.MediaStreamSource.prototype.onstarting;
 /** @type {function(?): void} */
Windows.Media.Core.MediaStreamSource.prototype.onswitchstreamsrequested;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.Media.Core.MediaStreamSource.prototype.thumbnail;
 /** @type {!Windows.Storage.FileProperties.VideoProperties} */
Windows.Media.Core.MediaStreamSource.prototype.videoProperties;

/**
 * Adds a Digital Rights Management (DRM) protection key which is used by the MediaProtectionManager to encrypt and decrypt the specified stream.
 * @param {!Windows.Media.Core.IMediaStreamDescriptor} streamDescriptor The stream the key is used to encrypt and decrypt.
 * @param {!Array<number>} keyIdentifier The key used to encrypt and decrypt the stream.
 * @param {!Array<number>} licenseData The DRM licence for the media.
 * @return {void}
 */
Windows.Media.Core.MediaStreamSource.prototype.addProtectionKey = function(streamDescriptor, keyIdentifier, licenseData) {};

/**
 * Adds a new stream descriptor to the MediaStreamSource .
 * @param {!Windows.Media.Core.IMediaStreamDescriptor} descriptor The descriptor to add.
 * @return {void}
 */
Windows.Media.Core.MediaStreamSource.prototype.addStreamDescriptor = function(descriptor) {};

/**
 * Notifies the MediaStreamSource that an error has occurred which is preventing the application from continuing to deliver data to the MediaStreamSource.
 * @param {Windows.Media.Core.MediaStreamSourceErrorStatus} errorStatus The cause of the error.
 * @return {void}
 */
Windows.Media.Core.MediaStreamSource.prototype.notifyError = function(errorStatus) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.MediaStreamSource.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.MediaStreamSource.prototype.removeEventListener = function(type, listener) {};

/**
 * Sets the range of data that the application is currently buffering.
 * @param {number} startOffset The smallest time stamp of a MediaStreamSample buffered by the application.
 * @param {number} endOffset The largest time stamp of a MediaStreamSample buffered by the application.
 * @return {void}
 */
Windows.Media.Core.MediaStreamSource.prototype.setBufferedRange = function(startOffset, endOffset) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaStreamSourceClosedEventArgs = function() {};
 /** @type {!Windows.Media.Core.MediaStreamSourceClosedRequest} */
Windows.Media.Core.MediaStreamSourceClosedEventArgs.prototype.request;

/** @const */
Windows.Media.Core.MediaStreamSourceClosedReason = {};
/** @const {number} */
Windows.Media.Core.MediaStreamSourceClosedReason.done;
/** @const {number} */
Windows.Media.Core.MediaStreamSourceClosedReason.unknownError;
/** @const {number} */
Windows.Media.Core.MediaStreamSourceClosedReason.appReportedError;
/** @const {number} */
Windows.Media.Core.MediaStreamSourceClosedReason.unsupportedProtectionSystem;
/** @const {number} */
Windows.Media.Core.MediaStreamSourceClosedReason.protectionSystemFailure;
/** @const {number} */
Windows.Media.Core.MediaStreamSourceClosedReason.unsupportedEncodingFormat;
/** @const {number} */
Windows.Media.Core.MediaStreamSourceClosedReason.missingSampleRequestedEventHandler;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaStreamSourceClosedRequest = function() {};
 /** @type {Windows.Media.Core.MediaStreamSourceClosedReason} */
Windows.Media.Core.MediaStreamSourceClosedRequest.prototype.reason;

/** @const */
Windows.Media.Core.MediaStreamSourceErrorStatus = {};
/** @const {number} */
Windows.Media.Core.MediaStreamSourceErrorStatus.other;
/** @const {number} */
Windows.Media.Core.MediaStreamSourceErrorStatus.outOfMemory;
/** @const {number} */
Windows.Media.Core.MediaStreamSourceErrorStatus.failedToOpenFile;
/** @const {number} */
Windows.Media.Core.MediaStreamSourceErrorStatus.failedToConnectToServer;
/** @const {number} */
Windows.Media.Core.MediaStreamSourceErrorStatus.connectionToServerLost;
/** @const {number} */
Windows.Media.Core.MediaStreamSourceErrorStatus.unspecifiedNetworkError;
/** @const {number} */
Windows.Media.Core.MediaStreamSourceErrorStatus.decodeError;
/** @const {number} */
Windows.Media.Core.MediaStreamSourceErrorStatus.unsupportedMediaFormat;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaStreamSourceSampleRequest = function() {};
 /** @type {!Windows.Media.Core.MediaStreamSample} */
Windows.Media.Core.MediaStreamSourceSampleRequest.prototype.sample;
 /** @type {!Windows.Media.Core.IMediaStreamDescriptor} */
Windows.Media.Core.MediaStreamSourceSampleRequest.prototype.streamDescriptor;

/**
 * Defers assigning a MediaStreamSample to MediaStreamSourceSampleRequest object.
 * @return {!Windows.Media.Core.MediaStreamSourceSampleRequestDeferral} The deferral.
 */
Windows.Media.Core.MediaStreamSourceSampleRequest.prototype.getDeferral = function() {};

/**
 * Provides a status update to the MediaStreamSource while the application is temporarily unable to deliver a requested MediaStreamSample .
 * @param {number} progress A value between 0 to 100 that indicates the progress towards being able to deliver the requested MediaStreamSample .
 * @return {void}
 */
Windows.Media.Core.MediaStreamSourceSampleRequest.prototype.reportSampleProgress = function(progress) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaStreamSourceSampleRequestDeferral = function() {};

/**
 * Reports that the application has completed retrieving the MediaStreamSample .
 * @return {void}
 */
Windows.Media.Core.MediaStreamSourceSampleRequestDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaStreamSourceSampleRequestedEventArgs = function() {};
 /** @type {!Windows.Media.Core.MediaStreamSourceSampleRequest} */
Windows.Media.Core.MediaStreamSourceSampleRequestedEventArgs.prototype.request;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaStreamSourceStartingEventArgs = function() {};
 /** @type {!Windows.Media.Core.MediaStreamSourceStartingRequest} */
Windows.Media.Core.MediaStreamSourceStartingEventArgs.prototype.request;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaStreamSourceStartingRequest = function() {};
 /** @type {number} */
Windows.Media.Core.MediaStreamSourceStartingRequest.prototype.startPosition;

/**
 * Defers completing the MediaStreamSource.Starting event.
 * @return {!Windows.Media.Core.MediaStreamSourceStartingRequestDeferral} The deferral.
 */
Windows.Media.Core.MediaStreamSourceStartingRequest.prototype.getDeferral = function() {};

/**
 * Specifies the starting position in the media time-line for subsequent MediaStreamSamples that will be delivered to the MediaStreamSource .
 * @param {number} position The actual starting point in the media time-line chosen by the application.
 * @return {void}
 */
Windows.Media.Core.MediaStreamSourceStartingRequest.prototype.setActualStartPosition = function(position) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaStreamSourceStartingRequestDeferral = function() {};

/**
 * Reports that the application has completed processing the Starting event.
 * @return {void}
 */
Windows.Media.Core.MediaStreamSourceStartingRequestDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaStreamSourceSwitchStreamsRequest = function() {};
 /** @type {!Windows.Media.Core.IMediaStreamDescriptor} */
Windows.Media.Core.MediaStreamSourceSwitchStreamsRequest.prototype.newStreamDescriptor;
 /** @type {!Windows.Media.Core.IMediaStreamDescriptor} */
Windows.Media.Core.MediaStreamSourceSwitchStreamsRequest.prototype.oldStreamDescriptor;

/**
 * Defers completing the MediaStreamSource.SwitchStreamsRequested event.
 * @return {!Windows.Media.Core.MediaStreamSourceSwitchStreamsRequestDeferral} The deferral.
 */
Windows.Media.Core.MediaStreamSourceSwitchStreamsRequest.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaStreamSourceSwitchStreamsRequestDeferral = function() {};

/**
 * Reports that the application has completed processing the MediaStreamSource.SwitchStreamsRequested event.
 * @return {void}
 */
Windows.Media.Core.MediaStreamSourceSwitchStreamsRequestDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.MediaStreamSourceSwitchStreamsRequestedEventArgs = function() {};
 /** @type {!Windows.Media.Core.MediaStreamSourceSwitchStreamsRequest} */
Windows.Media.Core.MediaStreamSourceSwitchStreamsRequestedEventArgs.prototype.request;

/** @const */
Windows.Media.Core.MediaTrackKind = {};
/** @const {number} */
Windows.Media.Core.MediaTrackKind.audio;
/** @const {number} */
Windows.Media.Core.MediaTrackKind.video;
/** @const {number} */
Windows.Media.Core.MediaTrackKind.timedMetadata;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.SceneAnalysisEffect = function() {};
 /** @type {number} */
Windows.Media.Core.SceneAnalysisEffect.prototype.desiredAnalysisInterval;
 /** @type {!Windows.Media.Core.HighDynamicRangeControl} */
Windows.Media.Core.SceneAnalysisEffect.prototype.highDynamicRangeAnalyzer;
 /** @type {function(?): void} */
Windows.Media.Core.SceneAnalysisEffect.prototype.onsceneanalyzed;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.SceneAnalysisEffect.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.SceneAnalysisEffect.prototype.removeEventListener = function(type, listener) {};

/**
 * Sets properties on the IMediaExtension .
 * @param {!Windows.Foundation.Collections.IPropertySet} configuration The property set.
 * @return {void}
 */
Windows.Media.Core.SceneAnalysisEffect.prototype.setProperties = function(configuration) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the SceneAnalysisEffectDefinition class.
 */
Windows.Media.Core.SceneAnalysisEffectDefinition = function() {};
 /** @type {string} */
Windows.Media.Core.SceneAnalysisEffectDefinition.prototype.activatableClassId;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Core.SceneAnalysisEffectDefinition.prototype.properties;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.SceneAnalysisEffectFrame = function() {};
 /** @type {number} */
Windows.Media.Core.SceneAnalysisEffectFrame.prototype.duration;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Core.SceneAnalysisEffectFrame.prototype.extendedProperties;
 /** @type {!Windows.Media.Capture.CapturedFrameControlValues} */
Windows.Media.Core.SceneAnalysisEffectFrame.prototype.frameControlValues;
 /** @type {!Windows.Media.Core.HighDynamicRangeOutput} */
Windows.Media.Core.SceneAnalysisEffectFrame.prototype.highDynamicRange;
 /** @type {boolean} */
Windows.Media.Core.SceneAnalysisEffectFrame.prototype.isDiscontinuous;
 /** @type {boolean} */
Windows.Media.Core.SceneAnalysisEffectFrame.prototype.isReadOnly;
 /** @type {number} */
Windows.Media.Core.SceneAnalysisEffectFrame.prototype.relativeTime;
 /** @type {number} */
Windows.Media.Core.SceneAnalysisEffectFrame.prototype.systemRelativeTime;
 /** @type {string} */
Windows.Media.Core.SceneAnalysisEffectFrame.prototype.type;

/**
 * Disposes of the object and associated resources.
 * @return {void}
 */
Windows.Media.Core.SceneAnalysisEffectFrame.prototype.close = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.SceneAnalyzedEventArgs = function() {};
 /** @type {!Windows.Media.Core.SceneAnalysisEffectFrame} */
Windows.Media.Core.SceneAnalyzedEventArgs.prototype.resultFrame;

/** @const */
Windows.Media.Core.TimedMetadataKind = {};
/** @const {number} */
Windows.Media.Core.TimedMetadataKind.caption;
/** @const {number} */
Windows.Media.Core.TimedMetadataKind.chapter;
/** @const {number} */
Windows.Media.Core.TimedMetadataKind.custom;
/** @const {number} */
Windows.Media.Core.TimedMetadataKind.data;
/** @const {number} */
Windows.Media.Core.TimedMetadataKind.description;
/** @const {number} */
Windows.Media.Core.TimedMetadataKind.subtitle;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the TimedMetadataTrack class.
 * @param {string} id An identifier for the new timed metadata track.
 * @param {string} language A string indicating the language of the new timed metadata track.
 * @param {Windows.Media.Core.TimedMetadataKind} kind A value indicating the kind of metadata contained in the new track.
 */
Windows.Media.Core.TimedMetadataTrack = function(id, language, kind) {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Core.IMediaCue>} */
Windows.Media.Core.TimedMetadataTrack.prototype.activeCues;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Core.IMediaCue>} */
Windows.Media.Core.TimedMetadataTrack.prototype.cues;
 /** @type {string} */
Windows.Media.Core.TimedMetadataTrack.prototype.dispatchType;
 /** @type {string} */
Windows.Media.Core.TimedMetadataTrack.prototype.id;
 /** @type {string} */
Windows.Media.Core.TimedMetadataTrack.prototype.label;
 /** @type {string} */
Windows.Media.Core.TimedMetadataTrack.prototype.language;
 /** @type {function(?): void} */
Windows.Media.Core.TimedMetadataTrack.prototype.oncueentered;
 /** @type {function(?): void} */
Windows.Media.Core.TimedMetadataTrack.prototype.oncueexited;
 /** @type {function(?): void} */
Windows.Media.Core.TimedMetadataTrack.prototype.ontrackfailed;
 /** @type {Windows.Media.Core.TimedMetadataKind} */
Windows.Media.Core.TimedMetadataTrack.prototype.timedMetadataKind;
 /** @type {Windows.Media.Core.MediaTrackKind} */
Windows.Media.Core.TimedMetadataTrack.prototype.trackKind;

/**
 * Adds the specified media cue to the TimedMetadataTrack .
 * @param {!Windows.Media.Core.IMediaCue} cue The media cue to add.
 * @return {void}
 */
Windows.Media.Core.TimedMetadataTrack.prototype.addCue = function(cue) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.TimedMetadataTrack.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.TimedMetadataTrack.prototype.removeEventListener = function(type, listener) {};

/**
 * Removes the specified media cue from the TimedMetadataTrack .
 * @param {!Windows.Media.Core.IMediaCue} cue The media cue to remove.
 * @return {void}
 */
Windows.Media.Core.TimedMetadataTrack.prototype.removeCue = function(cue) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.TimedMetadataTrackError = function() {};
 /** @type {Windows.Media.Core.TimedMetadataTrackErrorCode} */
Windows.Media.Core.TimedMetadataTrackError.prototype.errorCode;
 /** @type {!Windows.WinRTError} */
Windows.Media.Core.TimedMetadataTrackError.prototype.extendedError;

/** @const */
Windows.Media.Core.TimedMetadataTrackErrorCode = {};
/** @const {number} */
Windows.Media.Core.TimedMetadataTrackErrorCode.none;
/** @const {number} */
Windows.Media.Core.TimedMetadataTrackErrorCode.dataFormatError;
/** @const {number} */
Windows.Media.Core.TimedMetadataTrackErrorCode.networkError;
/** @const {number} */
Windows.Media.Core.TimedMetadataTrackErrorCode.internalError;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.TimedMetadataTrackFailedEventArgs = function() {};
 /** @type {!Windows.Media.Core.TimedMetadataTrackError} */
Windows.Media.Core.TimedMetadataTrackFailedEventArgs.prototype.error;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the TimedTextCue class.
 */
Windows.Media.Core.TimedTextCue = function() {};
 /** @type {!Windows.Media.Core.TimedTextRegion} */
Windows.Media.Core.TimedTextCue.prototype.cueRegion;
 /** @type {!Windows.Media.Core.TimedTextStyle} */
Windows.Media.Core.TimedTextCue.prototype.cueStyle;
 /** @type {number} */
Windows.Media.Core.TimedTextCue.prototype.duration;
 /** @type {string} */
Windows.Media.Core.TimedTextCue.prototype.id;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Core.TimedTextLine>} */
Windows.Media.Core.TimedTextCue.prototype.lines;
 /** @type {number} */
Windows.Media.Core.TimedTextCue.prototype.startTime;

/** @const */
Windows.Media.Core.TimedTextDisplayAlignment = {};
/** @const {number} */
Windows.Media.Core.TimedTextDisplayAlignment.before;
/** @const {number} */
Windows.Media.Core.TimedTextDisplayAlignment.after;
/** @const {number} */
Windows.Media.Core.TimedTextDisplayAlignment.center;

/** @const */
Windows.Media.Core.TimedTextFlowDirection = {};
/** @const {number} */
Windows.Media.Core.TimedTextFlowDirection.leftToRight;
/** @const {number} */
Windows.Media.Core.TimedTextFlowDirection.rightToLeft;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the TimedTextLine class.
 */
Windows.Media.Core.TimedTextLine = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Core.TimedTextSubformat>} */
Windows.Media.Core.TimedTextLine.prototype.subformats;
 /** @type {string} */
Windows.Media.Core.TimedTextLine.prototype.text;

/** @const */
Windows.Media.Core.TimedTextLineAlignment = {};
/** @const {number} */
Windows.Media.Core.TimedTextLineAlignment.start;
/** @const {number} */
Windows.Media.Core.TimedTextLineAlignment.end;
/** @const {number} */
Windows.Media.Core.TimedTextLineAlignment.center;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the TimedTextRegion class.
 */
Windows.Media.Core.TimedTextRegion = function() {};
 /** @type {!Windows.UI.Color} */
Windows.Media.Core.TimedTextRegion.prototype.background;
 /** @type {Windows.Media.Core.TimedTextDisplayAlignment} */
Windows.Media.Core.TimedTextRegion.prototype.displayAlignment;
 /** @type {!Windows.Media.Core.TimedTextSize} */
Windows.Media.Core.TimedTextRegion.prototype.extent;
 /** @type {boolean} */
Windows.Media.Core.TimedTextRegion.prototype.isOverflowClipped;
 /** @type {!Windows.Media.Core.TimedTextDouble} */
Windows.Media.Core.TimedTextRegion.prototype.lineHeight;
 /** @type {string} */
Windows.Media.Core.TimedTextRegion.prototype.name;
 /** @type {!Windows.Media.Core.TimedTextPadding} */
Windows.Media.Core.TimedTextRegion.prototype.padding;
 /** @type {!Windows.Media.Core.TimedTextPoint} */
Windows.Media.Core.TimedTextRegion.prototype.position;
 /** @type {Windows.Media.Core.TimedTextScrollMode} */
Windows.Media.Core.TimedTextRegion.prototype.scrollMode;
 /** @type {Windows.Media.Core.TimedTextWrapping} */
Windows.Media.Core.TimedTextRegion.prototype.textWrapping;
 /** @type {Windows.Media.Core.TimedTextWritingMode} */
Windows.Media.Core.TimedTextRegion.prototype.writingMode;
 /** @type {number} */
Windows.Media.Core.TimedTextRegion.prototype.zindex;

/** @const */
Windows.Media.Core.TimedTextScrollMode = {};
/** @const {number} */
Windows.Media.Core.TimedTextScrollMode.popon;
/** @const {number} */
Windows.Media.Core.TimedTextScrollMode.rollup;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.TimedTextSource = function() {};
 /** @type {function(?): void} */
Windows.Media.Core.TimedTextSource.prototype.onresolved;

/**
 * Creates a new instance of TimedTextSource from the provided stream.
 * Creates a new instance of TimedTextSource with the specified default language from the provided stream.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} stream The stream from which the timed text source is created.
 * @param {string=} defaultLanguage A string specifying the default language for the timed text source.
 * @return {!Windows.Media.Core.TimedTextSource} The new timed text source.
 */
Windows.Media.Core.TimedTextSource.createFromStream = function(stream, defaultLanguage) {};

/**
 * Creates a new instance of TimedTextSource from the provided URI.
 * Creates a new instance of TimedTextSource with the specified default language from the provided URI.
 * @param {!Windows.Foundation.Uri} uri The URI from which the timed text source is created.
 * @param {string=} defaultLanguage A string specifying the default language for the timed text source.
 * @return {!Windows.Media.Core.TimedTextSource} The new timed text source.
 */
Windows.Media.Core.TimedTextSource.createFromUri = function(uri, defaultLanguage) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.TimedTextSource.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.TimedTextSource.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.TimedTextSourceResolveResultEventArgs = function() {};
 /** @type {!Windows.Media.Core.TimedMetadataTrackError} */
Windows.Media.Core.TimedTextSourceResolveResultEventArgs.prototype.error;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Core.TimedMetadataTrack>} */
Windows.Media.Core.TimedTextSourceResolveResultEventArgs.prototype.tracks;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the TimedTextStyle class.
 */
Windows.Media.Core.TimedTextStyle = function() {};
 /** @type {!Windows.UI.Color} */
Windows.Media.Core.TimedTextStyle.prototype.background;
 /** @type {Windows.Media.Core.TimedTextFlowDirection} */
Windows.Media.Core.TimedTextStyle.prototype.flowDirection;
 /** @type {string} */
Windows.Media.Core.TimedTextStyle.prototype.fontFamily;
 /** @type {!Windows.Media.Core.TimedTextDouble} */
Windows.Media.Core.TimedTextStyle.prototype.fontSize;
 /** @type {Windows.Media.Core.TimedTextWeight} */
Windows.Media.Core.TimedTextStyle.prototype.fontWeight;
 /** @type {!Windows.UI.Color} */
Windows.Media.Core.TimedTextStyle.prototype.foreground;
 /** @type {boolean} */
Windows.Media.Core.TimedTextStyle.prototype.isBackgroundAlwaysShown;
 /** @type {Windows.Media.Core.TimedTextLineAlignment} */
Windows.Media.Core.TimedTextStyle.prototype.lineAlignment;
 /** @type {string} */
Windows.Media.Core.TimedTextStyle.prototype.name;
 /** @type {!Windows.UI.Color} */
Windows.Media.Core.TimedTextStyle.prototype.outlineColor;
 /** @type {!Windows.Media.Core.TimedTextDouble} */
Windows.Media.Core.TimedTextStyle.prototype.outlineRadius;
 /** @type {!Windows.Media.Core.TimedTextDouble} */
Windows.Media.Core.TimedTextStyle.prototype.outlineThickness;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the TimedTextSubformat class.
 */
Windows.Media.Core.TimedTextSubformat = function() {};
 /** @type {number} */
Windows.Media.Core.TimedTextSubformat.prototype.length;
 /** @type {number} */
Windows.Media.Core.TimedTextSubformat.prototype.startIndex;
 /** @type {!Windows.Media.Core.TimedTextStyle} */
Windows.Media.Core.TimedTextSubformat.prototype.subformatStyle;

/** @const */
Windows.Media.Core.TimedTextUnit = {};
/** @const {number} */
Windows.Media.Core.TimedTextUnit.pixels;
/** @const {number} */
Windows.Media.Core.TimedTextUnit.percentage;

/** @const */
Windows.Media.Core.TimedTextWeight = {};
/** @const {number} */
Windows.Media.Core.TimedTextWeight.normal;
/** @const {number} */
Windows.Media.Core.TimedTextWeight.bold;

/** @const */
Windows.Media.Core.TimedTextWrapping = {};
/** @const {number} */
Windows.Media.Core.TimedTextWrapping.noWrap;
/** @const {number} */
Windows.Media.Core.TimedTextWrapping.wrap;

/** @const */
Windows.Media.Core.TimedTextWritingMode = {};
/** @const {number} */
Windows.Media.Core.TimedTextWritingMode.leftRightTopBottom;
/** @const {number} */
Windows.Media.Core.TimedTextWritingMode.rightLeftTopBottom;
/** @const {number} */
Windows.Media.Core.TimedTextWritingMode.topBottomRightLeft;
/** @const {number} */
Windows.Media.Core.TimedTextWritingMode.topBottomLeftRight;
/** @const {number} */
Windows.Media.Core.TimedTextWritingMode.leftRight;
/** @const {number} */
Windows.Media.Core.TimedTextWritingMode.rightLeft;
/** @const {number} */
Windows.Media.Core.TimedTextWritingMode.topBottom;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.VideoStabilizationEffect = function() {};
 /** @type {boolean} */
Windows.Media.Core.VideoStabilizationEffect.prototype.enabled;
 /** @type {function(?): void} */
Windows.Media.Core.VideoStabilizationEffect.prototype.onenabledchanged;

/**
 * Gets the recommended video stream configuration for video stabilization, given the specified video device controller and encoding properties.
 * @param {!Windows.Media.Devices.VideoDeviceController} controller The video device controller.
 * @param {!Windows.Media.MediaProperties.VideoEncodingProperties} desiredProperties The encoding properties.
 * @return {!Windows.Media.Capture.VideoStreamConfiguration} An object representing the optimal video stream configuration for video stabilization.
 */
Windows.Media.Core.VideoStabilizationEffect.prototype.getRecommendedStreamConfiguration = function(controller, desiredProperties) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.VideoStabilizationEffect.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Core.VideoStabilizationEffect.prototype.removeEventListener = function(type, listener) {};

/**
 * Sets properties on the IMediaExtension .
 * @param {!Windows.Foundation.Collections.IPropertySet} configuration The property set.
 * @return {void}
 */
Windows.Media.Core.VideoStabilizationEffect.prototype.setProperties = function(configuration) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the VideoStabilizationEffectDefinition class.
 */
Windows.Media.Core.VideoStabilizationEffectDefinition = function() {};
 /** @type {string} */
Windows.Media.Core.VideoStabilizationEffectDefinition.prototype.activatableClassId;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Core.VideoStabilizationEffectDefinition.prototype.properties;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.VideoStabilizationEffectEnabledChangedEventArgs = function() {};
 /** @type {Windows.Media.Core.VideoStabilizationEffectEnabledChangedReason} */
Windows.Media.Core.VideoStabilizationEffectEnabledChangedEventArgs.prototype.reason;

/** @const */
Windows.Media.Core.VideoStabilizationEffectEnabledChangedReason = {};
/** @const {number} */
Windows.Media.Core.VideoStabilizationEffectEnabledChangedReason.programmatic;
/** @const {number} */
Windows.Media.Core.VideoStabilizationEffectEnabledChangedReason.pixelRateTooHigh;
/** @const {number} */
Windows.Media.Core.VideoStabilizationEffectEnabledChangedReason.runningSlowly;

/**
 * @constructor
 * @struct
 * Creates an instance of the VideoEncodingProperties class using the specified video encoding.
 * @param {!Windows.Media.MediaProperties.VideoEncodingProperties} encodingProperties The encoding properties for the video stream.
 */
Windows.Media.Core.VideoStreamDescriptor = function(encodingProperties) {};
 /** @type {!Windows.Media.MediaProperties.VideoEncodingProperties} */
Windows.Media.Core.VideoStreamDescriptor.prototype.encodingProperties;
 /** @type {boolean} */
Windows.Media.Core.VideoStreamDescriptor.prototype.isSelected;
 /** @type {string} */
Windows.Media.Core.VideoStreamDescriptor.prototype.language;
 /** @type {string} */
Windows.Media.Core.VideoStreamDescriptor.prototype.name;
/**
 * @constructor
 * @struct
 */
Windows.Media.Core.VideoTrack = function() {};
 /** @type {string} */
Windows.Media.Core.VideoTrack.prototype.id;
 /** @type {string} */
Windows.Media.Core.VideoTrack.prototype.label;
 /** @type {string} */
Windows.Media.Core.VideoTrack.prototype.language;
 /** @type {Windows.Media.Core.MediaTrackKind} */
Windows.Media.Core.VideoTrack.prototype.trackKind;
/**
 * @record
 * @struct
 */
Windows.Media.Core.IMediaSource = function() {};
/**
 * @record
 * @struct
 */
Windows.Media.Core.IMediaCue = function() {};
 /** @type {number} */
Windows.Media.Core.IMediaCue.prototype.duration;
 /** @type {string} */
Windows.Media.Core.IMediaCue.prototype.id;
 /** @type {number} */
Windows.Media.Core.IMediaCue.prototype.startTime;
/**
 * @record
 * @struct
 */
Windows.Media.Core.IMediaStreamDescriptor = function() {};
 /** @type {boolean} */
Windows.Media.Core.IMediaStreamDescriptor.prototype.isSelected;
 /** @type {string} */
Windows.Media.Core.IMediaStreamDescriptor.prototype.language;
 /** @type {string} */
Windows.Media.Core.IMediaStreamDescriptor.prototype.name;
/**
 * @record
 * @struct
 */
Windows.Media.Core.TimedTextSize = function() {};
 /** @type {number} */
Windows.Media.Core.TimedTextSize.prototype.height;
 /** @type {Windows.Media.Core.TimedTextUnit} */
Windows.Media.Core.TimedTextSize.prototype.unit;
 /** @type {number} */
Windows.Media.Core.TimedTextSize.prototype.width;
/**
 * @record
 * @struct
 */
Windows.Media.Core.TimedTextDouble = function() {};
 /** @type {Windows.Media.Core.TimedTextUnit} */
Windows.Media.Core.TimedTextDouble.prototype.unit;
 /** @type {number} */
Windows.Media.Core.TimedTextDouble.prototype.value;
/**
 * @record
 * @struct
 */
Windows.Media.Core.TimedTextPadding = function() {};
 /** @type {number} */
Windows.Media.Core.TimedTextPadding.prototype.after;
 /** @type {number} */
Windows.Media.Core.TimedTextPadding.prototype.before;
 /** @type {number} */
Windows.Media.Core.TimedTextPadding.prototype.end;
 /** @type {number} */
Windows.Media.Core.TimedTextPadding.prototype.start;
 /** @type {Windows.Media.Core.TimedTextUnit} */
Windows.Media.Core.TimedTextPadding.prototype.unit;
/**
 * @record
 * @struct
 */
Windows.Media.Core.TimedTextPoint = function() {};
 /** @type {Windows.Media.Core.TimedTextUnit} */
Windows.Media.Core.TimedTextPoint.prototype.unit;
 /** @type {number} */
Windows.Media.Core.TimedTextPoint.prototype.x;
 /** @type {number} */
Windows.Media.Core.TimedTextPoint.prototype.y;
/**
 * @record
 * @struct
 */
Windows.Media.Core.ISingleSelectMediaTrackList = function() {};
 /** @type {number} */
Windows.Media.Core.ISingleSelectMediaTrackList.prototype.selectedIndex;
/** @const */
Windows.Media.Devices = {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the AdvancedPhotoCaptureSettings class.
 */
Windows.Media.Devices.AdvancedPhotoCaptureSettings = function() {};
 /** @type {Windows.Media.Devices.AdvancedPhotoMode} */
Windows.Media.Devices.AdvancedPhotoCaptureSettings.prototype.mode;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.AdvancedPhotoControl = function() {};
 /** @type {Windows.Media.Devices.AdvancedPhotoMode} */
Windows.Media.Devices.AdvancedPhotoControl.prototype.mode;
 /** @type {boolean} */
Windows.Media.Devices.AdvancedPhotoControl.prototype.supported;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.AdvancedPhotoMode>} */
Windows.Media.Devices.AdvancedPhotoControl.prototype.supportedModes;

/**
 * Configures the AdvancedPhotoControl object with the specified settings.
 * @param {!Windows.Media.Devices.AdvancedPhotoCaptureSettings} settings The object defining the configuration settings.
 * @return {void}
 */
Windows.Media.Devices.AdvancedPhotoControl.prototype.configure = function(settings) {};

/** @const */
Windows.Media.Devices.AdvancedPhotoMode = {};
/** @const {number} */
Windows.Media.Devices.AdvancedPhotoMode.auto;
/** @const {number} */
Windows.Media.Devices.AdvancedPhotoMode.standard;
/** @const {number} */
Windows.Media.Devices.AdvancedPhotoMode.hdr;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.AudioDeviceController = function() {};
 /** @type {boolean} */
Windows.Media.Devices.AudioDeviceController.prototype.muted;
 /** @type {number} */
Windows.Media.Devices.AudioDeviceController.prototype.volumePercent;

/**
 * Gets a list of the supported encoding properties for the device.
 * @param {Windows.Media.Capture.MediaStreamType} mediaStreamType The type of media stream for which to get the properties.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Media.MediaProperties.IMediaEncodingProperties>} A list of the supported encoding properties.
 */
Windows.Media.Devices.AudioDeviceController.prototype.getAvailableMediaStreamProperties = function(mediaStreamType) {};

/**
 * Gets the encoding properties for the specified media stream type for the device.
 * @param {Windows.Media.Capture.MediaStreamType} mediaStreamType The type of media stream for which to get the properties.
 * @return {!Windows.Media.MediaProperties.IMediaEncodingProperties} The encoding properties.
 */
Windows.Media.Devices.AudioDeviceController.prototype.getMediaStreamProperties = function(mediaStreamType) {};

/**
 * Sets the encoding properties asynchronously for the specified media stream type for the device.
 * @param {Windows.Media.Capture.MediaStreamType} mediaStreamType The type of media stream for which to set the properties.
 * @param {!Windows.Media.MediaProperties.IMediaEncodingProperties} mediaEncodingProperties The encoding properties to set.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Media.Devices.AudioDeviceController.prototype.setMediaStreamPropertiesAsync = function(mediaStreamType, mediaEncodingProperties) {};

/** @const */
Windows.Media.Devices.AudioDeviceRole = {};
/** @const {number} */
Windows.Media.Devices.AudioDeviceRole.default;
/** @const {number} */
Windows.Media.Devices.AudioDeviceRole.communications;

/** @const */
Windows.Media.Devices.AutoFocusRange = {};
/** @const {number} */
Windows.Media.Devices.AutoFocusRange.fullRange;
/** @const {number} */
Windows.Media.Devices.AutoFocusRange.macro;
/** @const {number} */
Windows.Media.Devices.AutoFocusRange.normal;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.CallControl = function() {};
 /** @type {boolean} */
Windows.Media.Devices.CallControl.prototype.hasRinger;
 /** @type {function(!Windows.WinRTEvent<!Windows.Media.Devices.CallControl>): void} */
Windows.Media.Devices.CallControl.prototype.onanswerrequested;
 /** @type {function(!Windows.WinRTEvent<!Windows.Media.Devices.CallControl>): void} */
Windows.Media.Devices.CallControl.prototype.onaudiotransferrequested;
 /** @type {function(?): void} */
Windows.Media.Devices.CallControl.prototype.ondialrequested;
 /** @type {function(!Windows.WinRTEvent<!Windows.Media.Devices.CallControl>): void} */
Windows.Media.Devices.CallControl.prototype.onhanguprequested;
 /** @type {function(?): void} */
Windows.Media.Devices.CallControl.prototype.onkeypadpressed;
 /** @type {function(?): void} */
Windows.Media.Devices.CallControl.prototype.onredialrequested;

/**
 * Returns a CallControl class that represents the audio communications device specified by the DeviceInformation ID being passed.
 * @param {string} deviceId The DeviceInformation ID of the specified audio communications device.
 * @return {!Windows.Media.Devices.CallControl} A class that represents the specified audio communications device.
 */
Windows.Media.Devices.CallControl.fromId = function(deviceId) {};

/**
 * Returns a CallControl class that represents the default audio communications device.
 * @return {!Windows.Media.Devices.CallControl} A class that represents the default audio communications device.
 */
Windows.Media.Devices.CallControl.getDefault = function() {};

/**
 * Ends the specified call.
 * @param {number} callToken The unique identifier of the specified call.
 * @return {void}
 */
Windows.Media.Devices.CallControl.prototype.endCall = function(callToken) {};

/**
 * Indicates that the specified call is now active.
 * @param {number} callToken The unique identifier of the specified call.
 * @return {void}
 */
Windows.Media.Devices.CallControl.prototype.indicateActiveCall = function(callToken) {};

/**
 * Informs the device that there is an incoming call.
 * @param {boolean} enableRinger Specifies whether the device should activate its built-in ringer.
 * @param {string} callerId A numeric string that specifies the incoming caller ID. This parameter can be null, and often is for many VoIP calls.
 * @return {number} A call token that uniquely identifies this call.
 */
Windows.Media.Devices.CallControl.prototype.indicateNewIncomingCall = function(enableRinger, callerId) {};

/**
 * Updates device indicators to indicate an outgoing call.
 * @return {number} A call token that uniquely identifies this call.
 */
Windows.Media.Devices.CallControl.prototype.indicateNewOutgoingCall = function() {};

/**
 * @param {string} type
 * @param {function(!Windows.WinRTEvent<!Windows.Media.Devices.CallControl>): void|function(?): void} listener
 * @return {void}
 */
Windows.Media.Devices.CallControl.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(!Windows.WinRTEvent<!Windows.Media.Devices.CallControl>): void|function(?): void} listener
 * @return {void}
 */
Windows.Media.Devices.CallControl.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Media.Devices.CameraStreamState = {};
/** @const {number} */
Windows.Media.Devices.CameraStreamState.notStreaming;
/** @const {number} */
Windows.Media.Devices.CameraStreamState.streaming;
/** @const {number} */
Windows.Media.Devices.CameraStreamState.blockedForPrivacy;
/** @const {number} */
Windows.Media.Devices.CameraStreamState.shutdown;

/** @const */
Windows.Media.Devices.CaptureSceneMode = {};
/** @const {number} */
Windows.Media.Devices.CaptureSceneMode.auto;
/** @const {number} */
Windows.Media.Devices.CaptureSceneMode.manual;
/** @const {number} */
Windows.Media.Devices.CaptureSceneMode.macro;
/** @const {number} */
Windows.Media.Devices.CaptureSceneMode.portrait;
/** @const {number} */
Windows.Media.Devices.CaptureSceneMode.sport;
/** @const {number} */
Windows.Media.Devices.CaptureSceneMode.snow;
/** @const {number} */
Windows.Media.Devices.CaptureSceneMode.night;
/** @const {number} */
Windows.Media.Devices.CaptureSceneMode.beach;
/** @const {number} */
Windows.Media.Devices.CaptureSceneMode.sunset;
/** @const {number} */
Windows.Media.Devices.CaptureSceneMode.candlelight;
/** @const {number} */
Windows.Media.Devices.CaptureSceneMode.landscape;
/** @const {number} */
Windows.Media.Devices.CaptureSceneMode.nightPortrait;
/** @const {number} */
Windows.Media.Devices.CaptureSceneMode.backlit;

/** @const */
Windows.Media.Devices.CaptureUse = {};
/** @const {number} */
Windows.Media.Devices.CaptureUse.none;
/** @const {number} */
Windows.Media.Devices.CaptureUse.photo;
/** @const {number} */
Windows.Media.Devices.CaptureUse.video;

/** @const */
Windows.Media.Devices.ColorTemperaturePreset = {};
/** @const {number} */
Windows.Media.Devices.ColorTemperaturePreset.auto;
/** @const {number} */
Windows.Media.Devices.ColorTemperaturePreset.manual;
/** @const {number} */
Windows.Media.Devices.ColorTemperaturePreset.cloudy;
/** @const {number} */
Windows.Media.Devices.ColorTemperaturePreset.daylight;
/** @const {number} */
Windows.Media.Devices.ColorTemperaturePreset.flash;
/** @const {number} */
Windows.Media.Devices.ColorTemperaturePreset.fluorescent;
/** @const {number} */
Windows.Media.Devices.ColorTemperaturePreset.tungsten;
/** @const {number} */
Windows.Media.Devices.ColorTemperaturePreset.candlelight;
/** @const */
Windows.Media.Devices.Core = {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the CameraIntrinsics class.
 * @param {!Windows.Foundation.Numerics.Vector2} focalLength The focal length of the camera.
 * @param {!Windows.Foundation.Numerics.Vector2} principalPoint The principal point of the camera.
 * @param {!Windows.Foundation.Numerics.Vector3} radialDistortion The radial distortion coefficient of the camera.
 * @param {!Windows.Foundation.Numerics.Vector2} tangentialDistortion The tangential distortion coefficient of the camera.
 * @param {number} imageWidth The image width of the camera, in pixels.
 * @param {number} imageHeight The image height of the camera, in pixels.
 */
Windows.Media.Devices.Core.CameraIntrinsics = function(focalLength, principalPoint, radialDistortion, tangentialDistortion, imageWidth, imageHeight) {};
 /** @type {!Windows.Foundation.Numerics.Vector2} */
Windows.Media.Devices.Core.CameraIntrinsics.prototype.focalLength;
 /** @type {number} */
Windows.Media.Devices.Core.CameraIntrinsics.prototype.imageHeight;
 /** @type {number} */
Windows.Media.Devices.Core.CameraIntrinsics.prototype.imageWidth;
 /** @type {!Windows.Foundation.Numerics.Vector2} */
Windows.Media.Devices.Core.CameraIntrinsics.prototype.principalPoint;
 /** @type {!Windows.Foundation.Numerics.Vector3} */
Windows.Media.Devices.Core.CameraIntrinsics.prototype.radialDistortion;
 /** @type {!Windows.Foundation.Numerics.Vector2} */
Windows.Media.Devices.Core.CameraIntrinsics.prototype.tangentialDistortion;

/**
 * Projects an array of camera space points into screen space pixel coordinates.
 * @param {!Windows.Foundation.Numerics.Vector3} coordinates The array of camera space points to project into screen space.
 * @return {!Windows.Foundation.Point} The array of screen space pixel coordinates.
 */
Windows.Media.Devices.Core.CameraIntrinsics.prototype.projectManyOntoFrame = function(coordinates) {};

/**
 * Projects a camera space point into screen space pixel coordinates.
 * @param {!Windows.Foundation.Numerics.Vector3} coordinate The camera space point to project into screen space.
 * @return {!Windows.Foundation.Point} The screen space pixel coordinates.
 */
Windows.Media.Devices.Core.CameraIntrinsics.prototype.projectOntoFrame = function(coordinate) {};

/**
 * Unprojects pixel coordinates into a camera space ray from the camera origin, expressed as a X, Y coordinates on the plane at Z = 1.0.
 * @param {!Windows.Foundation.Point} pixelCoordinate The pixel coordinates to unproject into camera space.
 * @return {!Windows.Foundation.Numerics.Vector2} The X, Y coordinates of the unprojected pixel on the plane at Z = 1.0.
 */
Windows.Media.Devices.Core.CameraIntrinsics.prototype.unprojectAtUnitDepth = function(pixelCoordinate) {};

/**
 * Unprojects an array pixel coordinates into a camera space rays from the camera origin, expressed as a X, Y coordinates on the plane at Z = 1.0.
 * @param {!Windows.Foundation.Point} pixelCoordinates The array of pixel coordinates to unproject into camera space.
 * @return {!Windows.Foundation.Numerics.Vector2} The array of X, Y coordinates of the unprojected pixels on the plane at Z = 1.0.
 */
Windows.Media.Devices.Core.CameraIntrinsics.prototype.unprojectPixelsAtUnitDepth = function(pixelCoordinates) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.Core.FrameControlCapabilities = function() {};
 /** @type {!Windows.Media.Devices.Core.FrameExposureCapabilities} */
Windows.Media.Devices.Core.FrameControlCapabilities.prototype.exposure;
 /** @type {!Windows.Media.Devices.Core.FrameExposureCompensationCapabilities} */
Windows.Media.Devices.Core.FrameControlCapabilities.prototype.exposureCompensation;
 /** @type {!Windows.Media.Devices.Core.FrameFlashCapabilities} */
Windows.Media.Devices.Core.FrameControlCapabilities.prototype.flash;
 /** @type {!Windows.Media.Devices.Core.FrameFocusCapabilities} */
Windows.Media.Devices.Core.FrameControlCapabilities.prototype.focus;
 /** @type {!Windows.Media.Devices.Core.FrameIsoSpeedCapabilities} */
Windows.Media.Devices.Core.FrameControlCapabilities.prototype.isoSpeed;
 /** @type {boolean} */
Windows.Media.Devices.Core.FrameControlCapabilities.prototype.photoConfirmationSupported;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the FrameController class.
 */
Windows.Media.Devices.Core.FrameController = function() {};
 /** @type {!Windows.Media.Devices.Core.FrameExposureCompensationControl} */
Windows.Media.Devices.Core.FrameController.prototype.exposureCompensationControl;
 /** @type {!Windows.Media.Devices.Core.FrameExposureControl} */
Windows.Media.Devices.Core.FrameController.prototype.exposureControl;
 /** @type {!Windows.Media.Devices.Core.FrameFlashControl} */
Windows.Media.Devices.Core.FrameController.prototype.flashControl;
 /** @type {!Windows.Media.Devices.Core.FrameFocusControl} */
Windows.Media.Devices.Core.FrameController.prototype.focusControl;
 /** @type {!Windows.Media.Devices.Core.FrameIsoSpeedControl} */
Windows.Media.Devices.Core.FrameController.prototype.isoSpeedControl;
 /** @type {boolean} */
Windows.Media.Devices.Core.FrameController.prototype.photoConfirmationEnabled;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.Core.FrameExposureCapabilities = function() {};
 /** @type {number} */
Windows.Media.Devices.Core.FrameExposureCapabilities.prototype.max;
 /** @type {number} */
Windows.Media.Devices.Core.FrameExposureCapabilities.prototype.min;
 /** @type {number} */
Windows.Media.Devices.Core.FrameExposureCapabilities.prototype.step;
 /** @type {boolean} */
Windows.Media.Devices.Core.FrameExposureCapabilities.prototype.supported;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.Core.FrameExposureCompensationCapabilities = function() {};
 /** @type {number} */
Windows.Media.Devices.Core.FrameExposureCompensationCapabilities.prototype.max;
 /** @type {number} */
Windows.Media.Devices.Core.FrameExposureCompensationCapabilities.prototype.min;
 /** @type {number} */
Windows.Media.Devices.Core.FrameExposureCompensationCapabilities.prototype.step;
 /** @type {boolean} */
Windows.Media.Devices.Core.FrameExposureCompensationCapabilities.prototype.supported;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.Core.FrameExposureCompensationControl = function() {};
 /** @type {number} */
Windows.Media.Devices.Core.FrameExposureCompensationControl.prototype.value;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.Core.FrameExposureControl = function() {};
 /** @type {boolean} */
Windows.Media.Devices.Core.FrameExposureControl.prototype.auto;
 /** @type {number} */
Windows.Media.Devices.Core.FrameExposureControl.prototype.value;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.Core.FrameFlashCapabilities = function() {};
 /** @type {boolean} */
Windows.Media.Devices.Core.FrameFlashCapabilities.prototype.powerSupported;
 /** @type {boolean} */
Windows.Media.Devices.Core.FrameFlashCapabilities.prototype.redEyeReductionSupported;
 /** @type {boolean} */
Windows.Media.Devices.Core.FrameFlashCapabilities.prototype.supported;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.Core.FrameFlashControl = function() {};
 /** @type {boolean} */
Windows.Media.Devices.Core.FrameFlashControl.prototype.auto;
 /** @type {Windows.Media.Devices.Core.FrameFlashMode} */
Windows.Media.Devices.Core.FrameFlashControl.prototype.mode;
 /** @type {number} */
Windows.Media.Devices.Core.FrameFlashControl.prototype.powerPercent;
 /** @type {boolean} */
Windows.Media.Devices.Core.FrameFlashControl.prototype.redEyeReduction;

/** @const */
Windows.Media.Devices.Core.FrameFlashMode = {};
/** @const {number} */
Windows.Media.Devices.Core.FrameFlashMode.disable;
/** @const {number} */
Windows.Media.Devices.Core.FrameFlashMode.enable;
/** @const {number} */
Windows.Media.Devices.Core.FrameFlashMode.global;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.Core.FrameFocusCapabilities = function() {};
 /** @type {number} */
Windows.Media.Devices.Core.FrameFocusCapabilities.prototype.max;
 /** @type {number} */
Windows.Media.Devices.Core.FrameFocusCapabilities.prototype.min;
 /** @type {number} */
Windows.Media.Devices.Core.FrameFocusCapabilities.prototype.step;
 /** @type {boolean} */
Windows.Media.Devices.Core.FrameFocusCapabilities.prototype.supported;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.Core.FrameFocusControl = function() {};
 /** @type {number} */
Windows.Media.Devices.Core.FrameFocusControl.prototype.value;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.Core.FrameIsoSpeedCapabilities = function() {};
 /** @type {number} */
Windows.Media.Devices.Core.FrameIsoSpeedCapabilities.prototype.max;
 /** @type {number} */
Windows.Media.Devices.Core.FrameIsoSpeedCapabilities.prototype.min;
 /** @type {number} */
Windows.Media.Devices.Core.FrameIsoSpeedCapabilities.prototype.step;
 /** @type {boolean} */
Windows.Media.Devices.Core.FrameIsoSpeedCapabilities.prototype.supported;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.Core.FrameIsoSpeedControl = function() {};
 /** @type {boolean} */
Windows.Media.Devices.Core.FrameIsoSpeedControl.prototype.auto;
 /** @type {number} */
Windows.Media.Devices.Core.FrameIsoSpeedControl.prototype.value;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.Core.VariablePhotoSequenceController = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Devices.Core.FrameController>} */
Windows.Media.Devices.Core.VariablePhotoSequenceController.prototype.desiredFrameControllers;
 /** @type {!Windows.Media.Devices.Core.FrameControlCapabilities} */
Windows.Media.Devices.Core.VariablePhotoSequenceController.prototype.frameCapabilities;
 /** @type {number} */
Windows.Media.Devices.Core.VariablePhotoSequenceController.prototype.maxPhotosPerSecond;
 /** @type {number} */
Windows.Media.Devices.Core.VariablePhotoSequenceController.prototype.photosPerSecondLimit;
 /** @type {boolean} */
Windows.Media.Devices.Core.VariablePhotoSequenceController.prototype.supported;

/**
 * Gets the current frame rate at which pictures can be taken in a variable photo sequence.
 * @return {!Windows.Media.MediaProperties.MediaRatio} The current frame rate at which pictures can be taken in a variable photo sequence.
 */
Windows.Media.Devices.Core.VariablePhotoSequenceController.prototype.getCurrentFrameRate = function() {};

/**
 * Gets the highest frame rate supported when video and a variable photo sequence are being captured concurrently.
 * @param {!Windows.Media.MediaProperties.IMediaEncodingProperties} captureProperties The media encoding properties.
 * @return {!Windows.Media.MediaProperties.MediaRatio} The highest supported concurrent frame rate.
 */
Windows.Media.Devices.Core.VariablePhotoSequenceController.prototype.getHighestConcurrentFrameRate = function(captureProperties) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs = function() {};
 /** @type {string} */
Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs.prototype.id;
 /** @type {Windows.Media.Devices.AudioDeviceRole} */
Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs.prototype.role;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs = function() {};
 /** @type {string} */
Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs.prototype.id;
 /** @type {Windows.Media.Devices.AudioDeviceRole} */
Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs.prototype.role;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.DialRequestedEventArgs = function() {};
 /** @type {?} */
Windows.Media.Devices.DialRequestedEventArgs.prototype.contact;

/**
 * Indicates that the DialRequested event has been handled.
 * @return {void}
 */
Windows.Media.Devices.DialRequestedEventArgs.prototype.handled = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.ExposureCompensationControl = function() {};
 /** @type {number} */
Windows.Media.Devices.ExposureCompensationControl.prototype.max;
 /** @type {number} */
Windows.Media.Devices.ExposureCompensationControl.prototype.min;
 /** @type {number} */
Windows.Media.Devices.ExposureCompensationControl.prototype.step;
 /** @type {boolean} */
Windows.Media.Devices.ExposureCompensationControl.prototype.supported;
 /** @type {number} */
Windows.Media.Devices.ExposureCompensationControl.prototype.value;

/**
 * Asynchronously sets the exposure compensation.
 * @param {number} value The exposure compensation level to set the Value property to. The minimum and maximum values are specified by Min and Max .
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object that is used to control the asynchronous operation.
 */
Windows.Media.Devices.ExposureCompensationControl.prototype.setValueAsync = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.ExposureControl = function() {};
 /** @type {boolean} */
Windows.Media.Devices.ExposureControl.prototype.auto;
 /** @type {number} */
Windows.Media.Devices.ExposureControl.prototype.max;
 /** @type {number} */
Windows.Media.Devices.ExposureControl.prototype.min;
 /** @type {number} */
Windows.Media.Devices.ExposureControl.prototype.step;
 /** @type {boolean} */
Windows.Media.Devices.ExposureControl.prototype.supported;
 /** @type {number} */
Windows.Media.Devices.ExposureControl.prototype.value;

/**
 * Asynchronously enables or disable auto exposure.
 * @param {boolean} value Specifies whether or not to enable or disable auto exposure.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object that is used to control the asynchronous operation.
 */
Windows.Media.Devices.ExposureControl.prototype.setAutoAsync = function(value) {};

/**
 * Asynchronously sets the exposure time.
 * @param {number} shutterDuration The exposure time to set the Value property to. The minimum and maximum values are specified by Min and Max .
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object that is used to control the asynchronous operation.
 */
Windows.Media.Devices.ExposureControl.prototype.setValueAsync = function(shutterDuration) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.ExposurePriorityVideoControl = function() {};
 /** @type {boolean} */
Windows.Media.Devices.ExposurePriorityVideoControl.prototype.enabled;
 /** @type {boolean} */
Windows.Media.Devices.ExposurePriorityVideoControl.prototype.supported;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.FlashControl = function() {};
 /** @type {boolean} */
Windows.Media.Devices.FlashControl.prototype.assistantLightEnabled;
 /** @type {boolean} */
Windows.Media.Devices.FlashControl.prototype.assistantLightSupported;
 /** @type {boolean} */
Windows.Media.Devices.FlashControl.prototype.auto;
 /** @type {boolean} */
Windows.Media.Devices.FlashControl.prototype.enabled;
 /** @type {number} */
Windows.Media.Devices.FlashControl.prototype.powerPercent;
 /** @type {boolean} */
Windows.Media.Devices.FlashControl.prototype.powerSupported;
 /** @type {boolean} */
Windows.Media.Devices.FlashControl.prototype.redEyeReduction;
 /** @type {boolean} */
Windows.Media.Devices.FlashControl.prototype.redEyeReductionSupported;
 /** @type {boolean} */
Windows.Media.Devices.FlashControl.prototype.supported;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.FocusControl = function() {};
 /** @type {boolean} */
Windows.Media.Devices.FocusControl.prototype.focusChangedSupported;
 /** @type {Windows.Media.Devices.MediaCaptureFocusState} */
Windows.Media.Devices.FocusControl.prototype.focusState;
 /** @type {number} */
Windows.Media.Devices.FocusControl.prototype.max;
 /** @type {number} */
Windows.Media.Devices.FocusControl.prototype.min;
 /** @type {Windows.Media.Devices.FocusMode} */
Windows.Media.Devices.FocusControl.prototype.mode;
 /** @type {Windows.Media.Devices.FocusPreset} */
Windows.Media.Devices.FocusControl.prototype.preset;
 /** @type {number} */
Windows.Media.Devices.FocusControl.prototype.step;
 /** @type {boolean} */
Windows.Media.Devices.FocusControl.prototype.supported;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.ManualFocusDistance>} */
Windows.Media.Devices.FocusControl.prototype.supportedFocusDistances;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.FocusMode>} */
Windows.Media.Devices.FocusControl.prototype.supportedFocusModes;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.AutoFocusRange>} */
Windows.Media.Devices.FocusControl.prototype.supportedFocusRanges;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.FocusPreset>} */
Windows.Media.Devices.FocusControl.prototype.supportedPresets;
 /** @type {number} */
Windows.Media.Devices.FocusControl.prototype.value;
 /** @type {boolean} */
Windows.Media.Devices.FocusControl.prototype.waitForFocusSupported;

/**
 * Configures the FocusControl object with values specified in the provided FocusSettings object.
 * @param {!Windows.Media.Devices.FocusSettings} settings The focus settings to use to configure the FocusControl object.
 * @return {void}
 */
Windows.Media.Devices.FocusControl.prototype.configure = function(settings) {};

/**
 * Asynchronously focuses the device.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object that is used to control the asynchronous operation.
 */
Windows.Media.Devices.FocusControl.prototype.focusAsync = function() {};

/**
 * Locks the capture device's focus.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.Media.Devices.FocusControl.prototype.lockAsync = function() {};

/**
 * Asynchronously sets the focus Preset .
 * Asynchronously sets the focus Preset , specifying if the operation must complete before the device is focused.
 * @param {Windows.Media.Devices.FocusPreset} preset The focus preset to set the Preset property to.
 * @param {boolean=} completeBeforeFocus Specifies if the asynchronous operation must complete before the device is focused.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object that is used to control the asynchronous operation.
 */
Windows.Media.Devices.FocusControl.prototype.setPresetAsync = function(preset, completeBeforeFocus) {};

/**
 * Asynchronously sets the focus Value .
 * @param {number} focus The value to set the focus to. The minimum and maximum values are specified by Min and Max .
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object that is used to control the asynchronous operation.
 */
Windows.Media.Devices.FocusControl.prototype.setValueAsync = function(focus) {};

/**
 * Unlocks the capture device's focus if it has previously been locked with a call to LockAsync .
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.Media.Devices.FocusControl.prototype.unlockAsync = function() {};

/** @const */
Windows.Media.Devices.FocusMode = {};
/** @const {number} */
Windows.Media.Devices.FocusMode.auto;
/** @const {number} */
Windows.Media.Devices.FocusMode.single;
/** @const {number} */
Windows.Media.Devices.FocusMode.continuous;
/** @const {number} */
Windows.Media.Devices.FocusMode.manual;

/** @const */
Windows.Media.Devices.FocusPreset = {};
/** @const {number} */
Windows.Media.Devices.FocusPreset.auto;
/** @const {number} */
Windows.Media.Devices.FocusPreset.manual;
/** @const {number} */
Windows.Media.Devices.FocusPreset.autoMacro;
/** @const {number} */
Windows.Media.Devices.FocusPreset.autoNormal;
/** @const {number} */
Windows.Media.Devices.FocusPreset.autoInfinity;
/** @const {number} */
Windows.Media.Devices.FocusPreset.autoHyperfocal;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the FocusSettings class.
 */
Windows.Media.Devices.FocusSettings = function() {};
 /** @type {Windows.Media.Devices.AutoFocusRange} */
Windows.Media.Devices.FocusSettings.prototype.autoFocusRange;
 /** @type {boolean} */
Windows.Media.Devices.FocusSettings.prototype.disableDriverFallback;
 /** @type {Windows.Media.Devices.ManualFocusDistance} */
Windows.Media.Devices.FocusSettings.prototype.distance;
 /** @type {Windows.Media.Devices.FocusMode} */
Windows.Media.Devices.FocusSettings.prototype.mode;
 /** @type {number} */
Windows.Media.Devices.FocusSettings.prototype.value;
 /** @type {boolean} */
Windows.Media.Devices.FocusSettings.prototype.waitForFocus;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.HdrVideoControl = function() {};
 /** @type {Windows.Media.Devices.HdrVideoMode} */
Windows.Media.Devices.HdrVideoControl.prototype.mode;
 /** @type {boolean} */
Windows.Media.Devices.HdrVideoControl.prototype.supported;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.HdrVideoMode>} */
Windows.Media.Devices.HdrVideoControl.prototype.supportedModes;

/** @const */
Windows.Media.Devices.HdrVideoMode = {};
/** @const {number} */
Windows.Media.Devices.HdrVideoMode.off;
/** @const {number} */
Windows.Media.Devices.HdrVideoMode.on;
/** @const {number} */
Windows.Media.Devices.HdrVideoMode.auto;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.IsoSpeedControl = function() {};
 /** @type {boolean} */
Windows.Media.Devices.IsoSpeedControl.prototype.auto;
 /** @type {number} */
Windows.Media.Devices.IsoSpeedControl.prototype.max;
 /** @type {number} */
Windows.Media.Devices.IsoSpeedControl.prototype.min;
 /** @type {Windows.Media.Devices.IsoSpeedPreset} */
Windows.Media.Devices.IsoSpeedControl.prototype.preset;
 /** @type {number} */
Windows.Media.Devices.IsoSpeedControl.prototype.step;
 /** @type {boolean} */
Windows.Media.Devices.IsoSpeedControl.prototype.supported;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.IsoSpeedPreset>} */
Windows.Media.Devices.IsoSpeedControl.prototype.supportedPresets;
 /** @type {number} */
Windows.Media.Devices.IsoSpeedControl.prototype.value;

/**
 * Sets the ISO speed to automatic.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.Media.Devices.IsoSpeedControl.prototype.setAutoAsync = function() {};

/**
 * Asynchronously sets the ISO film speed Preset .
 * @param {Windows.Media.Devices.IsoSpeedPreset} preset The ISO preset value to set the Preset property to.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object that is used to control the asynchronous operation.
 */
Windows.Media.Devices.IsoSpeedControl.prototype.setPresetAsync = function(preset) {};

/**
 * Sets the ISO speed value.
 * @param {number} isoSpeed The ISO speed value.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.Media.Devices.IsoSpeedControl.prototype.setValueAsync = function(isoSpeed) {};

/** @const */
Windows.Media.Devices.IsoSpeedPreset = {};
/** @const {number} */
Windows.Media.Devices.IsoSpeedPreset.auto;
/** @const {number} */
Windows.Media.Devices.IsoSpeedPreset.iso50;
/** @const {number} */
Windows.Media.Devices.IsoSpeedPreset.iso80;
/** @const {number} */
Windows.Media.Devices.IsoSpeedPreset.iso100;
/** @const {number} */
Windows.Media.Devices.IsoSpeedPreset.iso200;
/** @const {number} */
Windows.Media.Devices.IsoSpeedPreset.iso400;
/** @const {number} */
Windows.Media.Devices.IsoSpeedPreset.iso800;
/** @const {number} */
Windows.Media.Devices.IsoSpeedPreset.iso1600;
/** @const {number} */
Windows.Media.Devices.IsoSpeedPreset.iso3200;
/** @const {number} */
Windows.Media.Devices.IsoSpeedPreset.iso6400;
/** @const {number} */
Windows.Media.Devices.IsoSpeedPreset.iso12800;
/** @const {number} */
Windows.Media.Devices.IsoSpeedPreset.iso25600;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.KeypadPressedEventArgs = function() {};
 /** @type {Windows.Media.Devices.TelephonyKey} */
Windows.Media.Devices.KeypadPressedEventArgs.prototype.telephonyKey;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.LowLagPhotoControl = function() {};
 /** @type {number} */
Windows.Media.Devices.LowLagPhotoControl.prototype.desiredThumbnailSize;
 /** @type {number} */
Windows.Media.Devices.LowLagPhotoControl.prototype.hardwareAcceleratedThumbnailSupported;
 /** @type {boolean} */
Windows.Media.Devices.LowLagPhotoControl.prototype.thumbnailEnabled;
 /** @type {Windows.Media.MediaProperties.MediaThumbnailFormat} */
Windows.Media.Devices.LowLagPhotoControl.prototype.thumbnailFormat;

/**
 * Gets the current frame rate at which pictures can be taken.
 * @return {!Windows.Media.MediaProperties.MediaRatio} The current frame rate.
 */
Windows.Media.Devices.LowLagPhotoControl.prototype.getCurrentFrameRate = function() {};

/**
 * Gets the highest frame rate supported when video and photos are being captured concurrently.
 * @param {!Windows.Media.MediaProperties.IMediaEncodingProperties} captureProperties The media encoding properties.
 * @return {!Windows.Media.MediaProperties.MediaRatio} The highest concurrent frames per second.
 */
Windows.Media.Devices.LowLagPhotoControl.prototype.getHighestConcurrentFrameRate = function(captureProperties) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.LowLagPhotoSequenceControl = function() {};
 /** @type {number} */
Windows.Media.Devices.LowLagPhotoSequenceControl.prototype.desiredThumbnailSize;
 /** @type {number} */
Windows.Media.Devices.LowLagPhotoSequenceControl.prototype.hardwareAcceleratedThumbnailSupported;
 /** @type {number} */
Windows.Media.Devices.LowLagPhotoSequenceControl.prototype.maxPastPhotos;
 /** @type {number} */
Windows.Media.Devices.LowLagPhotoSequenceControl.prototype.maxPhotosPerSecond;
 /** @type {number} */
Windows.Media.Devices.LowLagPhotoSequenceControl.prototype.pastPhotoLimit;
 /** @type {number} */
Windows.Media.Devices.LowLagPhotoSequenceControl.prototype.photosPerSecondLimit;
 /** @type {boolean} */
Windows.Media.Devices.LowLagPhotoSequenceControl.prototype.supported;
 /** @type {boolean} */
Windows.Media.Devices.LowLagPhotoSequenceControl.prototype.thumbnailEnabled;
 /** @type {Windows.Media.MediaProperties.MediaThumbnailFormat} */
Windows.Media.Devices.LowLagPhotoSequenceControl.prototype.thumbnailFormat;

/**
 * Gets the current frame rate at which pictures can be taken.
 * @return {!Windows.Media.MediaProperties.MediaRatio} The current frame rate.
 */
Windows.Media.Devices.LowLagPhotoSequenceControl.prototype.getCurrentFrameRate = function() {};

/**
 * Gets the highest frame rate supported when video and photos sequences are being captured concurrently.
 * @param {!Windows.Media.MediaProperties.IMediaEncodingProperties} captureProperties The media encoding properties.
 * @return {!Windows.Media.MediaProperties.MediaRatio} The highest concurrent frames per second.
 */
Windows.Media.Devices.LowLagPhotoSequenceControl.prototype.getHighestConcurrentFrameRate = function(captureProperties) {};

/** @const */
Windows.Media.Devices.ManualFocusDistance = {};
/** @const {number} */
Windows.Media.Devices.ManualFocusDistance.infinity;
/** @const {number} */
Windows.Media.Devices.ManualFocusDistance.hyperfocal;
/** @const {number} */
Windows.Media.Devices.ManualFocusDistance.nearest;

/** @const */
Windows.Media.Devices.MediaCaptureFocusState = {};
/** @const {number} */
Windows.Media.Devices.MediaCaptureFocusState.uninitialized;
/** @const {number} */
Windows.Media.Devices.MediaCaptureFocusState.lost;
/** @const {number} */
Windows.Media.Devices.MediaCaptureFocusState.searching;
/** @const {number} */
Windows.Media.Devices.MediaCaptureFocusState.focused;
/** @const {number} */
Windows.Media.Devices.MediaCaptureFocusState.failed;

/** @const */
Windows.Media.Devices.MediaCaptureOptimization = {};
/** @const {number} */
Windows.Media.Devices.MediaCaptureOptimization.default;
/** @const {number} */
Windows.Media.Devices.MediaCaptureOptimization.quality;
/** @const {number} */
Windows.Media.Devices.MediaCaptureOptimization.latency;
/** @const {number} */
Windows.Media.Devices.MediaCaptureOptimization.power;
/** @const {number} */
Windows.Media.Devices.MediaCaptureOptimization.latencyThenQuality;
/** @const {number} */
Windows.Media.Devices.MediaCaptureOptimization.latencyThenPower;
/** @const {number} */
Windows.Media.Devices.MediaCaptureOptimization.powerAndQuality;

/** @const */
Windows.Media.Devices.MediaCapturePauseBehavior = {};
/** @const {number} */
Windows.Media.Devices.MediaCapturePauseBehavior.retainHardwareResources;
/** @const {number} */
Windows.Media.Devices.MediaCapturePauseBehavior.releaseHardwareResources;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.MediaDevice = function() {};
 /** @type {function(?): void} */
Windows.Media.Devices.MediaDevice.ondefaultaudiocapturedevicechanged;
 /** @type {function(?): void} */
Windows.Media.Devices.MediaDevice.ondefaultaudiorenderdevicechanged;

/**
 * Returns the identifier string of a device for capturing audio.
 * @return {string} The identifier string of the audio capture device.
 */
Windows.Media.Devices.MediaDevice.getAudioCaptureSelector = function() {};

/**
 * Returns the identifier string of a device for rendering audio.
 * @return {string} The identifier string of the audio rendering device.
 */
Windows.Media.Devices.MediaDevice.getAudioRenderSelector = function() {};

/**
 * Returns the identifier string of the default device for capturing audio in the specified role.
 * @param {Windows.Media.Devices.AudioDeviceRole} role The specified audio device role (console, media, or communications).
 * @return {string} The identifier string of the default device.
 */
Windows.Media.Devices.MediaDevice.getDefaultAudioCaptureId = function(role) {};

/**
 * Returns the identifier string of the default device for rendering audio in the specified role.
 * @param {Windows.Media.Devices.AudioDeviceRole} role The specified audio device role (console, media, or communications).
 * @return {string} The identifier string of the default device.
 */
Windows.Media.Devices.MediaDevice.getDefaultAudioRenderId = function(role) {};

/**
 * Returns the identifier string of a device for capturing video.
 * @return {string} The identifier string of the video capture device.
 */
Windows.Media.Devices.MediaDevice.getVideoCaptureSelector = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Devices.MediaDevice.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Devices.MediaDevice.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.MediaDeviceControl = function() {};
 /** @type {!Windows.Media.Devices.MediaDeviceControlCapabilities} */
Windows.Media.Devices.MediaDeviceControl.prototype.capabilities;

/**
 * Indicates whether automatic adjustment of the camera setting is enabled.
 * @return {{value: boolean, returnValue: boolean}}
 */
Windows.Media.Devices.MediaDeviceControl.prototype.tryGetAuto = function() {};

/**
 * Gets the value of the camera setting.
 * @return {{value: number, returnValue: boolean}}
 */
Windows.Media.Devices.MediaDeviceControl.prototype.tryGetValue = function() {};

/**
 * Enables or disables automatic adjustment of the camera setting.
 * @param {boolean} value True to enable automatic adjustment; or false to disable automatic adjustment. If false, call TrySetValue to adjust the setting.
 * @return {boolean} Returns true if the method succeeds, or false otherwise.
 */
Windows.Media.Devices.MediaDeviceControl.prototype.trySetAuto = function(value) {};

/**
 * Sets the camera setting.
 * @param {number} value The new value of the camera setting. The units depend on the setting.
 * @return {boolean} Returns true if the method succeeds, or false otherwise.
 */
Windows.Media.Devices.MediaDeviceControl.prototype.trySetValue = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.MediaDeviceControlCapabilities = function() {};
 /** @type {boolean} */
Windows.Media.Devices.MediaDeviceControlCapabilities.prototype.autoModeSupported;
 /** @type {number} */
Windows.Media.Devices.MediaDeviceControlCapabilities.prototype.default;
 /** @type {number} */
Windows.Media.Devices.MediaDeviceControlCapabilities.prototype.max;
 /** @type {number} */
Windows.Media.Devices.MediaDeviceControlCapabilities.prototype.min;
 /** @type {number} */
Windows.Media.Devices.MediaDeviceControlCapabilities.prototype.step;
 /** @type {boolean} */
Windows.Media.Devices.MediaDeviceControlCapabilities.prototype.supported;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.OpticalImageStabilizationControl = function() {};
 /** @type {Windows.Media.Devices.OpticalImageStabilizationMode} */
Windows.Media.Devices.OpticalImageStabilizationControl.prototype.mode;
 /** @type {boolean} */
Windows.Media.Devices.OpticalImageStabilizationControl.prototype.supported;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.OpticalImageStabilizationMode>} */
Windows.Media.Devices.OpticalImageStabilizationControl.prototype.supportedModes;

/** @const */
Windows.Media.Devices.OpticalImageStabilizationMode = {};
/** @const {number} */
Windows.Media.Devices.OpticalImageStabilizationMode.off;
/** @const {number} */
Windows.Media.Devices.OpticalImageStabilizationMode.on;
/** @const {number} */
Windows.Media.Devices.OpticalImageStabilizationMode.auto;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.PhotoConfirmationControl = function() {};
 /** @type {boolean} */
Windows.Media.Devices.PhotoConfirmationControl.prototype.enabled;
 /** @type {Windows.Media.MediaProperties.MediaPixelFormat} */
Windows.Media.Devices.PhotoConfirmationControl.prototype.pixelFormat;
 /** @type {boolean} */
Windows.Media.Devices.PhotoConfirmationControl.prototype.supported;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.RedialRequestedEventArgs = function() {};

/**
 * Indicates that the RedialRequested event has been handled.
 * @return {void}
 */
Windows.Media.Devices.RedialRequestedEventArgs.prototype.handled = function() {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the RegionOfInterest control.
 */
Windows.Media.Devices.RegionOfInterest = function() {};
 /** @type {boolean} */
Windows.Media.Devices.RegionOfInterest.prototype.autoExposureEnabled;
 /** @type {boolean} */
Windows.Media.Devices.RegionOfInterest.prototype.autoFocusEnabled;
 /** @type {boolean} */
Windows.Media.Devices.RegionOfInterest.prototype.autoWhiteBalanceEnabled;
 /** @type {!Windows.Foundation.Rect} */
Windows.Media.Devices.RegionOfInterest.prototype.bounds;
 /** @type {boolean} */
Windows.Media.Devices.RegionOfInterest.prototype.boundsNormalized;
 /** @type {Windows.Media.Devices.RegionOfInterestType} */
Windows.Media.Devices.RegionOfInterest.prototype.type;
 /** @type {number} */
Windows.Media.Devices.RegionOfInterest.prototype.weight;

/** @const */
Windows.Media.Devices.RegionOfInterestType = {};
/** @const {number} */
Windows.Media.Devices.RegionOfInterestType.unknown;
/** @const {number} */
Windows.Media.Devices.RegionOfInterestType.face;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.RegionsOfInterestControl = function() {};
 /** @type {boolean} */
Windows.Media.Devices.RegionsOfInterestControl.prototype.autoExposureSupported;
 /** @type {boolean} */
Windows.Media.Devices.RegionsOfInterestControl.prototype.autoFocusSupported;
 /** @type {boolean} */
Windows.Media.Devices.RegionsOfInterestControl.prototype.autoWhiteBalanceSupported;
 /** @type {number} */
Windows.Media.Devices.RegionsOfInterestControl.prototype.maxRegions;

/**
 * Asynchronously clears the regions of interests.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object that is used to control the asynchronous operation.
 */
Windows.Media.Devices.RegionsOfInterestControl.prototype.clearRegionsAsync = function() {};

/**
 * Asynchronously sets the regions of interest.
 * Asynchronously sets the regions of interest and specifies if the values should be locked.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Media.Devices.RegionOfInterest>} regions The regions of interest. / The regions of interests.
 * @param {boolean=} lockValues Specifies if the values should be locked.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object that is used to control the asynchronous operation.
 */
Windows.Media.Devices.RegionsOfInterestControl.prototype.setRegionsAsync = function(regions, lockValues) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.SceneModeControl = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.CaptureSceneMode>} */
Windows.Media.Devices.SceneModeControl.prototype.supportedModes;
 /** @type {Windows.Media.Devices.CaptureSceneMode} */
Windows.Media.Devices.SceneModeControl.prototype.value;

/**
 * Asynchronously sets the color temperature Value .
 * @param {Windows.Media.Devices.CaptureSceneMode} sceneMode The scene mode to set the Value property to.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object that is used to control the asynchronous operation.
 */
Windows.Media.Devices.SceneModeControl.prototype.setValueAsync = function(sceneMode) {};

/** @const */
Windows.Media.Devices.TelephonyKey = {};
/** @const {number} */
Windows.Media.Devices.TelephonyKey.d0;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.d1;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.d2;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.d3;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.d4;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.d5;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.d6;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.d7;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.d8;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.d9;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.star;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.pound;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.a;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.b;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.c;
/** @const {number} */
Windows.Media.Devices.TelephonyKey.d;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.TorchControl = function() {};
 /** @type {boolean} */
Windows.Media.Devices.TorchControl.prototype.enabled;
 /** @type {number} */
Windows.Media.Devices.TorchControl.prototype.powerPercent;
 /** @type {boolean} */
Windows.Media.Devices.TorchControl.prototype.powerSupported;
 /** @type {boolean} */
Windows.Media.Devices.TorchControl.prototype.supported;
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.VideoDeviceController = function() {};
 /** @type {!Windows.Media.Devices.AdvancedPhotoControl} */
Windows.Media.Devices.VideoDeviceController.prototype.advancedPhotoControl;
 /** @type {!Windows.Media.Devices.MediaDeviceControl} */
Windows.Media.Devices.VideoDeviceController.prototype.backlightCompensation;
 /** @type {!Windows.Media.Devices.MediaDeviceControl} */
Windows.Media.Devices.VideoDeviceController.prototype.brightness;
 /** @type {!Windows.Media.Devices.MediaDeviceControl} */
Windows.Media.Devices.VideoDeviceController.prototype.contrast;
 /** @type {Windows.Media.Devices.MediaCaptureOptimization} */
Windows.Media.Devices.VideoDeviceController.prototype.desiredOptimization;
 /** @type {!Windows.Media.Devices.MediaDeviceControl} */
Windows.Media.Devices.VideoDeviceController.prototype.exposure;
 /** @type {!Windows.Media.Devices.ExposureCompensationControl} */
Windows.Media.Devices.VideoDeviceController.prototype.exposureCompensationControl;
 /** @type {!Windows.Media.Devices.ExposureControl} */
Windows.Media.Devices.VideoDeviceController.prototype.exposureControl;
 /** @type {!Windows.Media.Devices.ExposurePriorityVideoControl} */
Windows.Media.Devices.VideoDeviceController.prototype.exposurePriorityVideoControl;
 /** @type {!Windows.Media.Devices.FlashControl} */
Windows.Media.Devices.VideoDeviceController.prototype.flashControl;
 /** @type {!Windows.Media.Devices.MediaDeviceControl} */
Windows.Media.Devices.VideoDeviceController.prototype.focus;
 /** @type {!Windows.Media.Devices.FocusControl} */
Windows.Media.Devices.VideoDeviceController.prototype.focusControl;
 /** @type {!Windows.Media.Devices.HdrVideoControl} */
Windows.Media.Devices.VideoDeviceController.prototype.hdrVideoControl;
 /** @type {!Windows.Media.Devices.MediaDeviceControl} */
Windows.Media.Devices.VideoDeviceController.prototype.hue;
 /** @type {!Windows.Media.Devices.IsoSpeedControl} */
Windows.Media.Devices.VideoDeviceController.prototype.isoSpeedControl;
 /** @type {!Windows.Media.Devices.LowLagPhotoControl} */
Windows.Media.Devices.VideoDeviceController.prototype.lowLagPhoto;
 /** @type {!Windows.Media.Devices.LowLagPhotoSequenceControl} */
Windows.Media.Devices.VideoDeviceController.prototype.lowLagPhotoSequence;
 /** @type {!Windows.Media.Devices.OpticalImageStabilizationControl} */
Windows.Media.Devices.VideoDeviceController.prototype.opticalImageStabilizationControl;
 /** @type {!Windows.Media.Devices.MediaDeviceControl} */
Windows.Media.Devices.VideoDeviceController.prototype.pan;
 /** @type {!Windows.Media.Devices.PhotoConfirmationControl} */
Windows.Media.Devices.VideoDeviceController.prototype.photoConfirmationControl;
 /** @type {Windows.Media.Devices.CaptureUse} */
Windows.Media.Devices.VideoDeviceController.prototype.primaryUse;
 /** @type {!Windows.Media.Devices.RegionsOfInterestControl} */
Windows.Media.Devices.VideoDeviceController.prototype.regionsOfInterestControl;
 /** @type {!Windows.Media.Devices.MediaDeviceControl} */
Windows.Media.Devices.VideoDeviceController.prototype.roll;
 /** @type {!Windows.Media.Devices.SceneModeControl} */
Windows.Media.Devices.VideoDeviceController.prototype.sceneModeControl;
 /** @type {!Windows.Media.Devices.MediaDeviceControl} */
Windows.Media.Devices.VideoDeviceController.prototype.tilt;
 /** @type {!Windows.Media.Devices.TorchControl} */
Windows.Media.Devices.VideoDeviceController.prototype.torchControl;
 /** @type {!Windows.Media.Devices.Core.VariablePhotoSequenceController} */
Windows.Media.Devices.VideoDeviceController.prototype.variablePhotoSequenceController;
 /** @type {!Windows.Media.Devices.MediaDeviceControl} */
Windows.Media.Devices.VideoDeviceController.prototype.whiteBalance;
 /** @type {!Windows.Media.Devices.WhiteBalanceControl} */
Windows.Media.Devices.VideoDeviceController.prototype.whiteBalanceControl;
 /** @type {!Windows.Media.Devices.MediaDeviceControl} */
Windows.Media.Devices.VideoDeviceController.prototype.zoom;
 /** @type {!Windows.Media.Devices.ZoomControl} */
Windows.Media.Devices.VideoDeviceController.prototype.zoomControl;

/**
 * Gets a list of the supported encoding properties for the video device.
 * @param {Windows.Media.Capture.MediaStreamType} mediaStreamType The type of media stream for which to get the properties.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Media.MediaProperties.IMediaEncodingProperties>} A list of the supported encoding properties.
 */
Windows.Media.Devices.VideoDeviceController.prototype.getAvailableMediaStreamProperties = function(mediaStreamType) {};

/**
 * Gets a property on the camera. You can use this method to query properties that are specific to a particular camera.
 * @param {string} propertyId The property identifier.
 * @return {?} The property value.
 */
Windows.Media.Devices.VideoDeviceController.prototype.getDeviceProperty = function(propertyId) {};

/**
 * Gets the encoding properties for the specified media stream type for the video device.
 * @param {Windows.Media.Capture.MediaStreamType} mediaStreamType The type of media stream for which to get the properties.
 * @return {!Windows.Media.MediaProperties.IMediaEncodingProperties} The encoding properties.
 */
Windows.Media.Devices.VideoDeviceController.prototype.getMediaStreamProperties = function(mediaStreamType) {};

/**
 * Sets a property on the device. You can use this method to set properties that are specific to a particular device.
 * @param {string} propertyId The property identifier.
 * @param {?} propertyValue The new value of the property.
 * @return {void}
 */
Windows.Media.Devices.VideoDeviceController.prototype.setDeviceProperty = function(propertyId, propertyValue) {};

/**
 * Sets the encoding properties asynchronously for the specified media stream type for the video device.
 * @param {Windows.Media.Capture.MediaStreamType} mediaStreamType The type of media stream for which to set the properties.
 * @param {!Windows.Media.MediaProperties.IMediaEncodingProperties} mediaEncodingProperties The encoding properties to set.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An IAsyncAction object that is used to control the asynchronous operation.
 */
Windows.Media.Devices.VideoDeviceController.prototype.setMediaStreamPropertiesAsync = function(mediaStreamType, mediaEncodingProperties) {};

/**
 * Gets the local power line frequency.
 * @return {{value: Windows.Media.Capture.PowerlineFrequency, returnValue: boolean}}
 */
Windows.Media.Devices.VideoDeviceController.prototype.tryGetPowerlineFrequency = function() {};

/**
 * Sets the local power line frequency.
 * @param {Windows.Media.Capture.PowerlineFrequency} value The power line frequency.
 * @return {boolean} Returns true if the method succeeded, or false otherwise.
 */
Windows.Media.Devices.VideoDeviceController.prototype.trySetPowerlineFrequency = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.WhiteBalanceControl = function() {};
 /** @type {number} */
Windows.Media.Devices.WhiteBalanceControl.prototype.max;
 /** @type {number} */
Windows.Media.Devices.WhiteBalanceControl.prototype.min;
 /** @type {Windows.Media.Devices.ColorTemperaturePreset} */
Windows.Media.Devices.WhiteBalanceControl.prototype.preset;
 /** @type {number} */
Windows.Media.Devices.WhiteBalanceControl.prototype.step;
 /** @type {boolean} */
Windows.Media.Devices.WhiteBalanceControl.prototype.supported;
 /** @type {number} */
Windows.Media.Devices.WhiteBalanceControl.prototype.value;

/**
 * Asynchronously sets the color temperature Preset .
 * @param {Windows.Media.Devices.ColorTemperaturePreset} preset The color temperate preset to set the Preset property to.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object that is used to control the asynchronous operation.
 */
Windows.Media.Devices.WhiteBalanceControl.prototype.setPresetAsync = function(preset) {};

/**
 * Asynchronously sets the color temperature Value .
 * @param {number} temperature The temperature value to set the Value property to.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object that is used to control the asynchronous operation.
 */
Windows.Media.Devices.WhiteBalanceControl.prototype.setValueAsync = function(temperature) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Devices.ZoomControl = function() {};
 /** @type {number} */
Windows.Media.Devices.ZoomControl.prototype.max;
 /** @type {number} */
Windows.Media.Devices.ZoomControl.prototype.min;
 /** @type {Windows.Media.Devices.ZoomTransitionMode} */
Windows.Media.Devices.ZoomControl.prototype.mode;
 /** @type {number} */
Windows.Media.Devices.ZoomControl.prototype.step;
 /** @type {boolean} */
Windows.Media.Devices.ZoomControl.prototype.supported;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.ZoomTransitionMode>} */
Windows.Media.Devices.ZoomControl.prototype.supportedModes;
 /** @type {number} */
Windows.Media.Devices.ZoomControl.prototype.value;

/**
 * Configures the zoom control with the provided zoom settings.
 * @param {!Windows.Media.Devices.ZoomSettings} settings The zoom settings.
 * @return {void}
 */
Windows.Media.Devices.ZoomControl.prototype.configure = function(settings) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the ZoomSettings class.
 */
Windows.Media.Devices.ZoomSettings = function() {};
 /** @type {Windows.Media.Devices.ZoomTransitionMode} */
Windows.Media.Devices.ZoomSettings.prototype.mode;
 /** @type {number} */
Windows.Media.Devices.ZoomSettings.prototype.value;

/** @const */
Windows.Media.Devices.ZoomTransitionMode = {};
/** @const {number} */
Windows.Media.Devices.ZoomTransitionMode.auto;
/** @const {number} */
Windows.Media.Devices.ZoomTransitionMode.direct;
/** @const {number} */
Windows.Media.Devices.ZoomTransitionMode.smooth;

/** @typedef {function(!Windows.WinRTEvent<!Windows.Media.Devices.CallControl>): void} */
Windows.Media.Devices.CallControlEventHandler;

/** @typedef {function(?): void} */
Windows.Media.Devices.DialRequestedEventHandler;

/** @typedef {function(?): void} */
Windows.Media.Devices.KeypadPressedEventHandler;

/** @typedef {function(?): void} */
Windows.Media.Devices.RedialRequestedEventHandler;
/** @const */
Windows.Media.DialProtocol = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.DialProtocol.DialApp = function() {};
 /** @type {string} */
Windows.Media.DialProtocol.DialApp.prototype.appName;

/**
 * Gets the current status of the application on the remote device.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.DialProtocol.DialAppStateDetails, !Windows.Foundation.IAsyncOperation<!Windows.Media.DialProtocol.DialAppStateDetails>>} The app status, a value from DialAppStateDetails .
 */
Windows.Media.DialProtocol.DialApp.prototype.getAppStateAsync = function() {};

/**
 * Initiates the launching of the app on the remote device. When this method is called, the DialDevice is paired if necessary, the user is prompted to allow access to the device, connection is established, app existence is validated on the device, and finally the application is launched with the provided argument.
 * @param {string} appArgument Optional.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Media.DialProtocol.DialAppLaunchResult, !Windows.Foundation.IAsyncOperation<Windows.Media.DialProtocol.DialAppLaunchResult>>} Indicates the result of attempting to launch the app.
 */
Windows.Media.DialProtocol.DialApp.prototype.requestLaunchAsync = function(appArgument) {};

/**
 * Stops the app on the remote device, if the remote device supports this functionality.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Media.DialProtocol.DialAppStopResult, !Windows.Foundation.IAsyncOperation<Windows.Media.DialProtocol.DialAppStopResult>>} The result of sending the request to stop the app.
 */
Windows.Media.DialProtocol.DialApp.prototype.stopAsync = function() {};

/** @const */
Windows.Media.DialProtocol.DialAppLaunchResult = {};
/** @const {number} */
Windows.Media.DialProtocol.DialAppLaunchResult.launched;
/** @const {number} */
Windows.Media.DialProtocol.DialAppLaunchResult.failedToLaunch;
/** @const {number} */
Windows.Media.DialProtocol.DialAppLaunchResult.notFound;
/** @const {number} */
Windows.Media.DialProtocol.DialAppLaunchResult.networkFailure;

/** @const */
Windows.Media.DialProtocol.DialAppState = {};
/** @const {number} */
Windows.Media.DialProtocol.DialAppState.unknown;
/** @const {number} */
Windows.Media.DialProtocol.DialAppState.stopped;
/** @const {number} */
Windows.Media.DialProtocol.DialAppState.running;
/** @const {number} */
Windows.Media.DialProtocol.DialAppState.networkFailure;
/**
 * @constructor
 * @struct
 */
Windows.Media.DialProtocol.DialAppStateDetails = function() {};
 /** @type {string} */
Windows.Media.DialProtocol.DialAppStateDetails.prototype.fullXml;
 /** @type {Windows.Media.DialProtocol.DialAppState} */
Windows.Media.DialProtocol.DialAppStateDetails.prototype.state;

/** @const */
Windows.Media.DialProtocol.DialAppStopResult = {};
/** @const {number} */
Windows.Media.DialProtocol.DialAppStopResult.stopped;
/** @const {number} */
Windows.Media.DialProtocol.DialAppStopResult.stopFailed;
/** @const {number} */
Windows.Media.DialProtocol.DialAppStopResult.operationNotSupported;
/** @const {number} */
Windows.Media.DialProtocol.DialAppStopResult.networkFailure;
/**
 * @constructor
 * @struct
 */
Windows.Media.DialProtocol.DialDevice = function() {};
 /** @type {string} */
Windows.Media.DialProtocol.DialDevice.prototype.friendlyName;
 /** @type {string} */
Windows.Media.DialProtocol.DialDevice.prototype.id;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.Media.DialProtocol.DialDevice.prototype.thumbnail;

/**
 * Indicates whether or not the device supports launching DIAL apps.
 * @param {!Windows.Devices.Enumeration.DeviceInformation} device The device you want to get information for.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} True if app launching is supported; false, otherwise.
 */
Windows.Media.DialProtocol.DialDevice.deviceInfoSupportsDialAsync = function(device) {};

/**
 * Returns a DialDevice object for a given a device ID (acquired from a query using the Windows.Devices.Enumeration APIs).
 * @param {string} value The ID of the device you want a DialDevice object for.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.DialProtocol.DialDevice, !Windows.Foundation.IAsyncOperation<!Windows.Media.DialProtocol.DialDevice>>} The DialDevice object for the given device ID.
 */
Windows.Media.DialProtocol.DialDevice.fromIdAsync = function(value) {};

/**
 * Returns an AQS filter string to be used with the Windows.Devices.Enumeration APIs (such as the CreateWatcher API) for a given Dial app.
 * @param {string} appName The name of the app.
 * @return {string} The AQS filter.
 */
Windows.Media.DialProtocol.DialDevice.getDeviceSelector = function(appName) {};

/**
 * Creates a new DialApp object. This method does not establish a connection to the device or validate that the app exists. That is done when any function is called on the resulting DialApp object.
 * @param {string} appName The name of the app. This becomes the AppName property of the new object.
 * @return {!Windows.Media.DialProtocol.DialApp} The DialApp object for the app.
 */
Windows.Media.DialProtocol.DialDevice.prototype.getDialApp = function(appName) {};

/** @const */
Windows.Media.DialProtocol.DialDeviceDisplayStatus = {};
/** @const {number} */
Windows.Media.DialProtocol.DialDeviceDisplayStatus.none;
/** @const {number} */
Windows.Media.DialProtocol.DialDeviceDisplayStatus.connecting;
/** @const {number} */
Windows.Media.DialProtocol.DialDeviceDisplayStatus.connected;
/** @const {number} */
Windows.Media.DialProtocol.DialDeviceDisplayStatus.disconnecting;
/** @const {number} */
Windows.Media.DialProtocol.DialDeviceDisplayStatus.disconnected;
/** @const {number} */
Windows.Media.DialProtocol.DialDeviceDisplayStatus.error;

/**
 * @constructor
 * @struct
 * Creates a new DialDevicePicker object.
 */
Windows.Media.DialProtocol.DialDevicePicker = function() {};
 /** @type {!Windows.Devices.Enumeration.DevicePickerAppearance} */
Windows.Media.DialProtocol.DialDevicePicker.prototype.appearance;
 /** @type {!Windows.Media.DialProtocol.DialDevicePickerFilter} */
Windows.Media.DialProtocol.DialDevicePicker.prototype.filter;
 /** @type {function(?): void} */
Windows.Media.DialProtocol.DialDevicePicker.prototype.ondialdevicepickerdismissed;
 /** @type {function(?): void} */
Windows.Media.DialProtocol.DialDevicePicker.prototype.ondialdeviceselected;
 /** @type {function(?): void} */
Windows.Media.DialProtocol.DialDevicePicker.prototype.ondisconnectbuttonclicked;

/**
 * Hides the picker.
 * @return {void}
 */
Windows.Media.DialProtocol.DialDevicePicker.prototype.hide = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.DialProtocol.DialDevicePicker.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.DialProtocol.DialDevicePicker.prototype.removeEventListener = function(type, listener) {};

/**
 * Shows the picker. Call this method directly to show to show the picker, instead of showing it in response to an event.
 * Shows the picker. Call this method directly to show to show the picker, instead of showing it in response to an event.
 * @param {!Windows.Foundation.Rect} selection The rectangle from which to show the picker.
 * @param {Windows.UI.Popups.Placement=} preferredPlacement The edge of the rectangle from which to show the picker.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.DialProtocol.DialDevice, !Windows.Foundation.IAsyncOperation<!Windows.Media.DialProtocol.DialDevice>>} The DialDevice object selected. / The device the user selected from the picker.
 */
Windows.Media.DialProtocol.DialDevicePicker.prototype.pickSingleDialDeviceAsync = function(selection, preferredPlacement) {};

/**
 * Updates the picker UI to reflect the status fo a given remote device.
 * @param {!Windows.Media.DialProtocol.DialDevice} device The remote device whose status you want to display.
 * @param {Windows.Media.DialProtocol.DialDeviceDisplayStatus} status The status you want displayed.
 * @return {void}
 */
Windows.Media.DialProtocol.DialDevicePicker.prototype.setDisplayStatus = function(device, status) {};

/**
 * Displays the picker to the user. When called, the picker flies out from the specified edge of the provided rectangle.
 * Displays the picker to the user. When called, the picker flies out from an edge of the provided rectangle.
 * @param {!Windows.Foundation.Rect} selection The rectangle from which you want the picker to show.
 * @param {Windows.UI.Popups.Placement=} preferredPlacement The edge from which you want the picker to show.
 * @return {void}
 */
Windows.Media.DialProtocol.DialDevicePicker.prototype.show = function(selection, preferredPlacement) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.DialProtocol.DialDevicePickerFilter = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Media.DialProtocol.DialDevicePickerFilter.prototype.supportedAppNames;
/**
 * @constructor
 * @struct
 */
Windows.Media.DialProtocol.DialDeviceSelectedEventArgs = function() {};
 /** @type {!Windows.Media.DialProtocol.DialDevice} */
Windows.Media.DialProtocol.DialDeviceSelectedEventArgs.prototype.selectedDialDevice;
/**
 * @constructor
 * @struct
 */
Windows.Media.DialProtocol.DialDisconnectButtonClickedEventArgs = function() {};
 /** @type {!Windows.Media.DialProtocol.DialDevice} */
Windows.Media.DialProtocol.DialDisconnectButtonClickedEventArgs.prototype.device;
/** @const */
Windows.Media.Editing = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Editing.BackgroundAudioTrack = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Effects.IAudioEffectDefinition>} */
Windows.Media.Editing.BackgroundAudioTrack.prototype.audioEffectDefinitions;
 /** @type {number} */
Windows.Media.Editing.BackgroundAudioTrack.prototype.delay;
 /** @type {number} */
Windows.Media.Editing.BackgroundAudioTrack.prototype.originalDuration;
 /** @type {number} */
Windows.Media.Editing.BackgroundAudioTrack.prototype.trimTimeFromEnd;
 /** @type {number} */
Windows.Media.Editing.BackgroundAudioTrack.prototype.trimTimeFromStart;
 /** @type {number} */
Windows.Media.Editing.BackgroundAudioTrack.prototype.trimmedDuration;
 /** @type {!Windows.Foundation.Collections.IMap<string, string>} */
Windows.Media.Editing.BackgroundAudioTrack.prototype.userData;
 /** @type {number} */
Windows.Media.Editing.BackgroundAudioTrack.prototype.volume;

/**
 * Creates a background audio track object with audio content copied from an embedded audio track object.
 * @param {!Windows.Media.Editing.EmbeddedAudioTrack} embeddedAudioTrack An embedded audio track to use as the source audio for the background audio track.
 * @return {!Windows.Media.Editing.BackgroundAudioTrack} A new background audio track object containing audio content copied from the embedded audio track.
 */
Windows.Media.Editing.BackgroundAudioTrack.createFromEmbeddedAudioTrack = function(embeddedAudioTrack) {};

/**
 * Creates a background audio track from an audio file.
 * @param {!Windows.Storage.IStorageFile} file A StorageFile object representing the source audio file.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Editing.BackgroundAudioTrack, !Windows.Foundation.IAsyncOperation<!Windows.Media.Editing.BackgroundAudioTrack>>} A new background audio track object containing the contents of the audio file.
 */
Windows.Media.Editing.BackgroundAudioTrack.createFromFileAsync = function(file) {};

/**
 * Creates a BackgroundAudioTrack object that is identical to this instance.
 * @return {!Windows.Media.Editing.BackgroundAudioTrack} A BackgroundAudioTrack object that is a copy of this instance.
 */
Windows.Media.Editing.BackgroundAudioTrack.prototype.clone = function() {};

/**
 * Gets the AudioEncodingProperties for the background audio track.
 * @return {!Windows.Media.MediaProperties.AudioEncodingProperties} The AudioEncodingProperties for the background audio track.
 */
Windows.Media.Editing.BackgroundAudioTrack.prototype.getAudioEncodingProperties = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Editing.EmbeddedAudioTrack = function() {};

/**
 * Gets the AudioEncodingProperties for the embedded audio track.
 * @return {!Windows.Media.MediaProperties.AudioEncodingProperties} The AudioEncodingProperties for the embedded audio track.
 */
Windows.Media.Editing.EmbeddedAudioTrack.prototype.getAudioEncodingProperties = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Editing.MediaClip = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Effects.IAudioEffectDefinition>} */
Windows.Media.Editing.MediaClip.prototype.audioEffectDefinitions;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Editing.EmbeddedAudioTrack>} */
Windows.Media.Editing.MediaClip.prototype.embeddedAudioTracks;
 /** @type {number} */
Windows.Media.Editing.MediaClip.prototype.endTimeInComposition;
 /** @type {number} */
Windows.Media.Editing.MediaClip.prototype.originalDuration;
 /** @type {number} */
Windows.Media.Editing.MediaClip.prototype.selectedEmbeddedAudioTrackIndex;
 /** @type {number} */
Windows.Media.Editing.MediaClip.prototype.startTimeInComposition;
 /** @type {number} */
Windows.Media.Editing.MediaClip.prototype.trimTimeFromEnd;
 /** @type {number} */
Windows.Media.Editing.MediaClip.prototype.trimTimeFromStart;
 /** @type {number} */
Windows.Media.Editing.MediaClip.prototype.trimmedDuration;
 /** @type {!Windows.Foundation.Collections.IMap<string, string>} */
Windows.Media.Editing.MediaClip.prototype.userData;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Effects.IVideoEffectDefinition>} */
Windows.Media.Editing.MediaClip.prototype.videoEffectDefinitions;
 /** @type {number} */
Windows.Media.Editing.MediaClip.prototype.volume;

/**
 * Creates a solid color video clip that displays a single color for a specified length of time. Solid color video clips are typically used to create an explicit gap between video segments.
 * @param {!Windows.UI.Color} color The color to display in the video clip.
 * @param {number} originalDuration How long to display the color in the video clip.
 * @return {!Windows.Media.Editing.MediaClip} A new media clip object containing the color-based video clip.
 */
Windows.Media.Editing.MediaClip.createFromColor = function(color, originalDuration) {};

/**
 * Creates a video clip from a video file.
 * @param {!Windows.Storage.IStorageFile} file A StorageFile object representing the source video file.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Editing.MediaClip, !Windows.Foundation.IAsyncOperation<!Windows.Media.Editing.MediaClip>>} A new media clip object containing a video clip of the video file.
 */
Windows.Media.Editing.MediaClip.createFromFileAsync = function(file) {};

/**
 * Creates a video clip that displays a single image for a specified length of time.
 * @param {!Windows.Storage.IStorageFile} file A StorageFile object representing the source image file.
 * @param {number} originalDuration How long to display the image in the video clip.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Editing.MediaClip, !Windows.Foundation.IAsyncOperation<!Windows.Media.Editing.MediaClip>>} A new media clip object containing the image-based video clip.
 */
Windows.Media.Editing.MediaClip.createFromImageFileAsync = function(file, originalDuration) {};

/**
 * Creates a video clip from a Direct3D surface.
 * @param {!Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface} surface The Direct3D surface.
 * @param {number} originalDuration The initial duration of the created video clip.
 * @return {!Windows.Media.Editing.MediaClip} A new media clip object containing the video clip.
 */
Windows.Media.Editing.MediaClip.createFromSurface = function(surface, originalDuration) {};

/**
 * Creates a MediaClip object that is identical to this instance.
 * @return {!Windows.Media.Editing.MediaClip} A MediaClip object that is a copy of this instance.
 */
Windows.Media.Editing.MediaClip.prototype.clone = function() {};

/**
 * Gets the VideoEncodingProperties for the media clip.
 * @return {!Windows.Media.MediaProperties.VideoEncodingProperties} The VideoEncodingProperties for the media clip.
 */
Windows.Media.Editing.MediaClip.prototype.getVideoEncodingProperties = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the MediaComposition class.
 */
Windows.Media.Editing.MediaComposition = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Editing.BackgroundAudioTrack>} */
Windows.Media.Editing.MediaComposition.prototype.backgroundAudioTracks;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Editing.MediaClip>} */
Windows.Media.Editing.MediaComposition.prototype.clips;
 /** @type {number} */
Windows.Media.Editing.MediaComposition.prototype.duration;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Editing.MediaOverlayLayer>} */
Windows.Media.Editing.MediaComposition.prototype.overlayLayers;
 /** @type {!Windows.Foundation.Collections.IMap<string, string>} */
Windows.Media.Editing.MediaComposition.prototype.userData;

/**
 * Asynchronously loads a MediaComposition from a StorageFile .
 * @param {!Windows.Storage.StorageFile} file The file from which to load the MediaComposition .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Editing.MediaComposition, !Windows.Foundation.IAsyncOperation<!Windows.Media.Editing.MediaComposition>>} An async operation which can be used to track the success or failure of the operation.
 */
Windows.Media.Editing.MediaComposition.loadAsync = function(file) {};

/**
 * Creates a MediaComposition object that is identical to this instance.
 * @return {!Windows.Media.Editing.MediaComposition} A MediaComposition object that is a copy of this instance.
 */
Windows.Media.Editing.MediaComposition.prototype.clone = function() {};

/**
 * Create a new default media encoding profile which can be modified if necessary.
 * @return {!Windows.Media.MediaProperties.MediaEncodingProfile} The newly created MediaEncodingProfile .
 */
Windows.Media.Editing.MediaComposition.prototype.createDefaultEncodingProfile = function() {};

/**
 * Creates a new MediaStreamSource using the specified MediaEncodingProfile .
 * Creates a new MediaStreamSource .
 * @param {!Windows.Media.MediaProperties.MediaEncodingProfile=} encodingProfile The MediaEncodingProfile used to specify the encoding properties of the new MediaStreamSource .
 * @return {!Windows.Media.Core.MediaStreamSource} The newly created MediaStreamSource .
 */
Windows.Media.Editing.MediaComposition.prototype.generateMediaStreamSource = function(encodingProfile) {};

/**
 * Creates a new MediaStreamSource used to preview the edited media.
 * @param {number} scaledWidth The width of the preview media.
 * @param {number} scaledHeight The height of the preview media.
 * @return {!Windows.Media.Core.MediaStreamSource} The new MediaStreamSource used to preview the edited media.
 */
Windows.Media.Editing.MediaComposition.prototype.generatePreviewMediaStreamSource = function(scaledWidth, scaledHeight) {};

/**
 * Asynchronously gets an image stream that represents a thumbnail of the media composition.
 * @param {number} timeFromStart Specifies the point in the timeline of the MediaComposition from which to render the thumbnail, offset from the start of the MediaComposition.
 * @param {number} scaledWidth Specifies the target width at which to render. The default is 0. scaledWidth and/or scaledHeight can be optional; see Remarks.
 * @param {number} scaledHeight Specifies the target height at which to render. The default is 0. scaledWidth and/or scaledHeight can be optional; see Remarks.
 * @param {Windows.Media.Editing.VideoFramePrecision} framePrecision Specifies the frame precision algorithm to use when retrieving the thumbnail.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Graphics.Imaging.ImageStream, !Windows.Foundation.IAsyncOperation<!Windows.Graphics.Imaging.ImageStream>>} An image stream representing resulting thumbnail.
 */
Windows.Media.Editing.MediaComposition.prototype.getThumbnailAsync = function(timeFromStart, scaledWidth, scaledHeight, framePrecision) {};

/**
 * Asynchronously gets a vector view of thumbnails of the media composition.
 * @param {!Windows.Foundation.Collections.IIterable<number>} timesFromStart Specifies the points in the timeline of the MediaComposition from which to render the thumbnails, offset from the start of the MediaComposition.
 * @param {number} scaledWidth Specifies the target width at which to render. The default is 0. scaledWidth and/or scaledHeight can be optional; see Remarks.
 * @param {number} scaledHeight Specifies the target height at which to render. The default is 0. scaledWidth and/or scaledHeight can be optional; see Remarks.
 * @param {Windows.Media.Editing.VideoFramePrecision} framePrecision Specifies the frame precision algorithm to use when retrieving the thumbnails.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A vector view on the resulting thumbnails.
 */
Windows.Media.Editing.MediaComposition.prototype.getThumbnailsAsync = function(timesFromStart, scaledWidth, scaledHeight, framePrecision) {};

/**
 * Asynchronously renders the MediaComposition to the specified file.
 * Asynchronously renders the MediaComposition to a specified file using the indicated media trimming preference.
 * Asynchronously renders the MediaComposition to a specified file using the indicated media trimming preference and encoding profile.
 * @param {!Windows.Storage.IStorageFile} destination The file to which this MediaComposition is rendered.
 * @param {Windows.Media.Editing.MediaTrimmingPreference=} trimmingPreference Specifies whether to be fast or precise when trimming the media.
 * @param {!Windows.Media.MediaProperties.MediaEncodingProfile=} encodingProfile Specifies the encoding profile to use for rendering the media.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Media.Transcoding.TranscodeFailureReason, !Windows.Foundation.IAsyncOperationWithProgress<Windows.Media.Transcoding.TranscodeFailureReason, number>>} An async operation which can be used to track the success or failure of the operation.
 */
Windows.Media.Editing.MediaComposition.prototype.renderToFileAsync = function(destination, trimmingPreference, encodingProfile) {};

/**
 * Asynchronously serializes the MediaComposition to disk so that it can be loaded and modified in the future.
 * @param {!Windows.Storage.IStorageFile} file The file to which the MediaComposition is saved.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An async action which can be used to track the success or failure of the operation.
 */
Windows.Media.Editing.MediaComposition.prototype.saveAsync = function(file) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the MediaOverlay class.
 * Initializes a new instance of the MediaOverlay class.
 * @param {!Windows.Media.Editing.MediaClip} clip The media clip to be used for the overlay.
 * @param {!Windows.Foundation.Rect=} position The position of the overlay.
 * @param {number=} opacity The opacity of the overlay, in the range of 0.0 to 1.0, where 0.0 is completely transparent and 1.0 is completely opaque.
 */
Windows.Media.Editing.MediaOverlay = function(clip, position, opacity) {};
 /** @type {boolean} */
Windows.Media.Editing.MediaOverlay.prototype.audioEnabled;
 /** @type {!Windows.Media.Editing.MediaClip} */
Windows.Media.Editing.MediaOverlay.prototype.clip;
 /** @type {number} */
Windows.Media.Editing.MediaOverlay.prototype.delay;
 /** @type {number} */
Windows.Media.Editing.MediaOverlay.prototype.opacity;
 /** @type {!Windows.Foundation.Rect} */
Windows.Media.Editing.MediaOverlay.prototype.position;

/**
 * Creates a MediaOverlay object that is identical to this instance.
 * @return {!Windows.Media.Editing.MediaOverlay} A MediaOverlay object that is a copy of this instance.
 */
Windows.Media.Editing.MediaOverlay.prototype.clone = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the MediaOverlayLayer class.
 * Initializes a new instance of the MediaOverlayLayer class.
 * @param {!Windows.Media.Effects.IVideoCompositorDefinition=} compositorDefinition The definition of the custom compositor associated with the media overlay layer.
 */
Windows.Media.Editing.MediaOverlayLayer = function(compositorDefinition) {};
 /** @type {!Windows.Media.Effects.IVideoCompositorDefinition} */
Windows.Media.Editing.MediaOverlayLayer.prototype.customCompositorDefinition;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Editing.MediaOverlay>} */
Windows.Media.Editing.MediaOverlayLayer.prototype.overlays;

/**
 * Creates a MediaOverlayLayer object that is identical to this instance.
 * @return {!Windows.Media.Editing.MediaOverlayLayer} A MediaOverlayLayer object that is a copy of this instance.
 */
Windows.Media.Editing.MediaOverlayLayer.prototype.clone = function() {};

/** @const */
Windows.Media.Editing.MediaTrimmingPreference = {};
/** @const {number} */
Windows.Media.Editing.MediaTrimmingPreference.fast;
/** @const {number} */
Windows.Media.Editing.MediaTrimmingPreference.precise;

/** @const */
Windows.Media.Editing.VideoFramePrecision = {};
/** @const {number} */
Windows.Media.Editing.VideoFramePrecision.nearestFrame;
/** @const {number} */
Windows.Media.Editing.VideoFramePrecision.nearestKeyFrame;
/** @const */
Windows.Media.Effects = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Effects.AudioCaptureEffectsManager = function() {};
 /** @type {function(?): void} */
Windows.Media.Effects.AudioCaptureEffectsManager.prototype.onaudiocaptureeffectschanged;

/**
 * Gets the list of audio effects on the device.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Effects.AudioEffect>} The list of audio effects.
 */
Windows.Media.Effects.AudioCaptureEffectsManager.prototype.getAudioCaptureEffects = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Effects.AudioCaptureEffectsManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Effects.AudioCaptureEffectsManager.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Effects.AudioEffect = function() {};
 /** @type {Windows.Media.Effects.AudioEffectType} */
Windows.Media.Effects.AudioEffect.prototype.audioEffectType;

/**
 * @constructor
 * @struct
 * Creates a new AudioEffectDefinition object with the specified activatable class ID, configuring the object with the specified settings.
 * Creates a new AudioEffectDefinition object with the specified activatable class ID.
 * @param {string} activatableClassId The activatable class ID of the audio effect definition.
 * @param {!Windows.Foundation.Collections.IPropertySet=} props Configuration properties for the specified audio effect definition.
 */
Windows.Media.Effects.AudioEffectDefinition = function(activatableClassId, props) {};
 /** @type {string} */
Windows.Media.Effects.AudioEffectDefinition.prototype.activatableClassId;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Effects.AudioEffectDefinition.prototype.properties;

/** @const */
Windows.Media.Effects.AudioEffectType = {};
/** @const {number} */
Windows.Media.Effects.AudioEffectType.other;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.acousticEchoCancellation;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.noiseSuppression;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.automaticGainControl;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.beamForming;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.constantToneRemoval;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.equalizer;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.loudnessEqualizer;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.bassBoost;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.virtualSurround;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.virtualHeadphones;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.speakerFill;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.roomCorrection;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.bassManagement;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.environmentalEffects;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.speakerProtection;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.speakerCompensation;
/** @const {number} */
Windows.Media.Effects.AudioEffectType.dynamicRangeCompression;
/**
 * @constructor
 * @struct
 */
Windows.Media.Effects.AudioEffectsManager = function() {};

/**
 * Creates a AudioCaptureEffectsManager object for the specified device for a specific media category.
 * Creates a AudioCaptureEffectsManager object for the specified device for a specific media category and audio processing mode.
 * @param {string} deviceId The device id.
 * @param {Windows.Media.Capture.MediaCategory} category The media category.
 * @param {Windows.Media.AudioProcessing=} mode The audio processing mode.
 * @return {!Windows.Media.Effects.AudioCaptureEffectsManager} The new audio capture effects manager.
 */
Windows.Media.Effects.AudioEffectsManager.createAudioCaptureEffectsManager = function(deviceId, category, mode) {};

/**
 * Creates a AudioRenderEffectsManager object for the specified device for a specific media category.
 * Creates a AudioRenderEffectsManager object for the specified device for a specific media category and audio processing mode.
 * @param {string} deviceId The device id.
 * @param {Windows.Media.Render.AudioRenderCategory} category The audio render category.
 * @param {Windows.Media.AudioProcessing=} mode The audio precessing mode.
 * @return {!Windows.Media.Effects.AudioRenderEffectsManager} The new audio render effects manager.
 */
Windows.Media.Effects.AudioEffectsManager.createAudioRenderEffectsManager = function(deviceId, category, mode) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Effects.AudioRenderEffectsManager = function() {};
 /** @type {string} */
Windows.Media.Effects.AudioRenderEffectsManager.prototype.effectsProviderSettingsLabel;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamWithContentType} */
Windows.Media.Effects.AudioRenderEffectsManager.prototype.effectsProviderThumbnail;
 /** @type {function(?): void} */
Windows.Media.Effects.AudioRenderEffectsManager.prototype.onaudiorendereffectschanged;

/**
 * Gets the list of audio effects on the device.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Effects.AudioEffect>} The list of audio effects.
 */
Windows.Media.Effects.AudioRenderEffectsManager.prototype.getAudioRenderEffects = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Effects.AudioRenderEffectsManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Effects.AudioRenderEffectsManager.prototype.removeEventListener = function(type, listener) {};

/**
 * Displays the audio effect settings page.
 * @return {void}
 */
Windows.Media.Effects.AudioRenderEffectsManager.prototype.showSettingsUI = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Effects.CompositeVideoFrameContext = function() {};
 /** @type {!Windows.Media.VideoFrame} */
Windows.Media.Effects.CompositeVideoFrameContext.prototype.backgroundFrame;
 /** @type {!Windows.Media.VideoFrame} */
Windows.Media.Effects.CompositeVideoFrameContext.prototype.outputFrame;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface>} */
Windows.Media.Effects.CompositeVideoFrameContext.prototype.surfacesToOverlay;

/**
 * Gets a MediaOverlay object for the provided Direct3D surface.
 * @param {!Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface} surfaceToOverlay The Direct3D surface.
 * @return {!Windows.Media.Editing.MediaOverlay} The created MediaOverlay object.
 */
Windows.Media.Effects.CompositeVideoFrameContext.prototype.getOverlayForSurface = function(surfaceToOverlay) {};

/** @const */
Windows.Media.Effects.MediaEffectClosedReason = {};
/** @const {number} */
Windows.Media.Effects.MediaEffectClosedReason.done;
/** @const {number} */
Windows.Media.Effects.MediaEffectClosedReason.unknownError;
/** @const {number} */
Windows.Media.Effects.MediaEffectClosedReason.unsupportedEncodingFormat;
/** @const {number} */
Windows.Media.Effects.MediaEffectClosedReason.effectCurrentlyUnloaded;

/** @const */
Windows.Media.Effects.MediaMemoryTypes = {};
/** @const {number} */
Windows.Media.Effects.MediaMemoryTypes.gpu;
/** @const {number} */
Windows.Media.Effects.MediaMemoryTypes.cpu;
/** @const {number} */
Windows.Media.Effects.MediaMemoryTypes.gpuAndCpu;
/**
 * @constructor
 * @struct
 */
Windows.Media.Effects.ProcessAudioFrameContext = function() {};
 /** @type {!Windows.Media.AudioFrame} */
Windows.Media.Effects.ProcessAudioFrameContext.prototype.inputFrame;
 /** @type {!Windows.Media.AudioFrame} */
Windows.Media.Effects.ProcessAudioFrameContext.prototype.outputFrame;
/**
 * @constructor
 * @struct
 */
Windows.Media.Effects.ProcessVideoFrameContext = function() {};
 /** @type {!Windows.Media.VideoFrame} */
Windows.Media.Effects.ProcessVideoFrameContext.prototype.inputFrame;
 /** @type {!Windows.Media.VideoFrame} */
Windows.Media.Effects.ProcessVideoFrameContext.prototype.outputFrame;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the VideoCompositorDefinition class.
 * Initializes a new instance of the VideoCompositorDefinition class.
 * @param {string} activatableClassId The activatable class ID of the video compositor.
 * @param {!Windows.Foundation.Collections.IPropertySet=} props The set of properties for configuring the video compositor object.
 */
Windows.Media.Effects.VideoCompositorDefinition = function(activatableClassId, props) {};
 /** @type {string} */
Windows.Media.Effects.VideoCompositorDefinition.prototype.activatableClassId;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Effects.VideoCompositorDefinition.prototype.properties;

/**
 * @constructor
 * @struct
 * Creates a new VideoEffectDefinition object with the specified activatable class ID, configuring the object with the specified settings.
 * Creates a new VideoEffectDefinition object with the specified activatable class ID.
 * @param {string} activatableClassId The activatable class ID of the video effect definition.
 * @param {!Windows.Foundation.Collections.IPropertySet=} props Configuration properties for the specified video effect definition.
 */
Windows.Media.Effects.VideoEffectDefinition = function(activatableClassId, props) {};
 /** @type {string} */
Windows.Media.Effects.VideoEffectDefinition.prototype.activatableClassId;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Effects.VideoEffectDefinition.prototype.properties;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the VideoTransformEffectDefinition class.
 */
Windows.Media.Effects.VideoTransformEffectDefinition = function() {};
 /** @type {string} */
Windows.Media.Effects.VideoTransformEffectDefinition.prototype.activatableClassId;
 /** @type {!Windows.Foundation.Rect} */
Windows.Media.Effects.VideoTransformEffectDefinition.prototype.cropRectangle;
 /** @type {Windows.Media.MediaProperties.MediaMirroringOptions} */
Windows.Media.Effects.VideoTransformEffectDefinition.prototype.mirror;
 /** @type {!Windows.Foundation.Size} */
Windows.Media.Effects.VideoTransformEffectDefinition.prototype.outputSize;
 /** @type {!Windows.UI.Color} */
Windows.Media.Effects.VideoTransformEffectDefinition.prototype.paddingColor;
 /** @type {Windows.Media.Transcoding.MediaVideoProcessingAlgorithm} */
Windows.Media.Effects.VideoTransformEffectDefinition.prototype.processingAlgorithm;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Effects.VideoTransformEffectDefinition.prototype.properties;
 /** @type {Windows.Media.MediaProperties.MediaRotation} */
Windows.Media.Effects.VideoTransformEffectDefinition.prototype.rotation;
/**
 * @record
 * @struct
 */
Windows.Media.Effects.IAudioEffectDefinition = function() {};
 /** @type {string} */
Windows.Media.Effects.IAudioEffectDefinition.prototype.activatableClassId;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Effects.IAudioEffectDefinition.prototype.properties;
/**
 * @record
 * @struct
 */
Windows.Media.Effects.IVideoEffectDefinition = function() {};
 /** @type {string} */
Windows.Media.Effects.IVideoEffectDefinition.prototype.activatableClassId;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Effects.IVideoEffectDefinition.prototype.properties;
/**
 * @record
 * @struct
 */
Windows.Media.Effects.IVideoCompositorDefinition = function() {};
 /** @type {string} */
Windows.Media.Effects.IVideoCompositorDefinition.prototype.activatableClassId;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Effects.IVideoCompositorDefinition.prototype.properties;
/** @const */
Windows.Media.FaceAnalysis = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.FaceAnalysis.DetectedFace = function() {};
 /** @type {!Windows.Graphics.Imaging.BitmapBounds} */
Windows.Media.FaceAnalysis.DetectedFace.prototype.faceBox;
/**
 * @constructor
 * @struct
 */
Windows.Media.FaceAnalysis.FaceDetector = function() {};
 /** @type {boolean} */
Windows.Media.FaceAnalysis.FaceDetector.isSupported;
 /** @type {!Windows.Graphics.Imaging.BitmapSize} */
Windows.Media.FaceAnalysis.FaceDetector.prototype.maxDetectableFaceSize;
 /** @type {!Windows.Graphics.Imaging.BitmapSize} */
Windows.Media.FaceAnalysis.FaceDetector.prototype.minDetectableFaceSize;

/**
 * Creates a new instance of the FaceDetector class.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.FaceAnalysis.FaceDetector, !Windows.Foundation.IAsyncOperation<!Windows.Media.FaceAnalysis.FaceDetector>>} An asynchronous operation that returns a FaceDetector instance upon successful completion.
 */
Windows.Media.FaceAnalysis.FaceDetector.createAsync = function() {};

/**
 * Returns a list of the bitmap pixels formats supported by the FaceDetector on the current device.
 * @return {!Windows.Foundation.Collections.IVectorView<Windows.Graphics.Imaging.BitmapPixelFormat>} A list of the bitmap pixels formats supported by the FaceDetector on the current device.
 */
Windows.Media.FaceAnalysis.FaceDetector.getSupportedBitmapPixelFormats = function() {};

/**
 * Queries whether the specified bitmap pixel format is supported by the FaceDetector on the current device.
 * @param {Windows.Graphics.Imaging.BitmapPixelFormat} bitmapPixelFormat The bitmap pixel format for which support is queried.
 * @return {boolean} True if the specified bitmap pixel format is supported; otherwise, false.
 */
Windows.Media.FaceAnalysis.FaceDetector.isBitmapPixelFormatSupported = function(bitmapPixelFormat) {};

/**
 * Asynchronously detects faces in the provided SoftwareBitmap .
 * Asynchronously detects faces in the provided SoftwareBitmap within the specified search area.
 * @param {!Windows.Graphics.Imaging.SoftwareBitmap} image The image data to be processed for face detection.
 * @param {!Windows.Graphics.Imaging.BitmapBounds=} searchArea The bounds within the SoftwareBitmap in which face detection will be performed.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVector<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVector<?>>>} An asynchronous operation that returns a list of DetectedFace objects upon successful completion.
 */
Windows.Media.FaceAnalysis.FaceDetector.prototype.detectFacesAsync = function(image, searchArea) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.FaceAnalysis.FaceTracker = function() {};
 /** @type {boolean} */
Windows.Media.FaceAnalysis.FaceTracker.isSupported;
 /** @type {!Windows.Graphics.Imaging.BitmapSize} */
Windows.Media.FaceAnalysis.FaceTracker.prototype.maxDetectableFaceSize;
 /** @type {!Windows.Graphics.Imaging.BitmapSize} */
Windows.Media.FaceAnalysis.FaceTracker.prototype.minDetectableFaceSize;

/**
 * Creates a new instance of the FaceTracker class.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.FaceAnalysis.FaceTracker, !Windows.Foundation.IAsyncOperation<!Windows.Media.FaceAnalysis.FaceTracker>>} An asynchronous operation that returns a FaceTracker instance upon successful completion.
 */
Windows.Media.FaceAnalysis.FaceTracker.createAsync = function() {};

/**
 * Returns a list of the bitmap pixels formats supported by the FaceTracker on the current device.
 * @return {!Windows.Foundation.Collections.IVectorView<Windows.Graphics.Imaging.BitmapPixelFormat>} A list of the bitmap pixels formats supported by the FaceTracker on the current device.
 */
Windows.Media.FaceAnalysis.FaceTracker.getSupportedBitmapPixelFormats = function() {};

/**
 * Queries whether the specified bitmap pixel format is supported by the FaceTracker on the current device.
 * @param {Windows.Graphics.Imaging.BitmapPixelFormat} bitmapPixelFormat The bitmap pixel format for which support is queried.
 * @return {boolean} True if the specified bitmap pixel format is supported; otherwise, false.
 */
Windows.Media.FaceAnalysis.FaceTracker.isBitmapPixelFormatSupported = function(bitmapPixelFormat) {};

/**
 * Asynchronously processes a VideoFrame for face detection.
 * @param {!Windows.Media.VideoFrame} videoFrame The VideoFrame in which faces are detected or tracked.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVector<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVector<?>>>} An asynchronous operation that returns a list of DetectedFace objects upon successful completion.
 */
Windows.Media.FaceAnalysis.FaceTracker.prototype.processNextFrameAsync = function(videoFrame) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.ImageDisplayProperties = function() {};
 /** @type {string} */
Windows.Media.ImageDisplayProperties.prototype.subtitle;
 /** @type {string} */
Windows.Media.ImageDisplayProperties.prototype.title;
/** @const */
Windows.Media.Import = {};

/** @const */
Windows.Media.Import.PhotoImportAccessMode = {};
/** @const {number} */
Windows.Media.Import.PhotoImportAccessMode.readWrite;
/** @const {number} */
Windows.Media.Import.PhotoImportAccessMode.readOnly;
/** @const {number} */
Windows.Media.Import.PhotoImportAccessMode.readAndDelete;

/** @const */
Windows.Media.Import.PhotoImportConnectionTransport = {};
/** @const {number} */
Windows.Media.Import.PhotoImportConnectionTransport.unknown;
/** @const {number} */
Windows.Media.Import.PhotoImportConnectionTransport.usb;
/** @const {number} */
Windows.Media.Import.PhotoImportConnectionTransport.ip;
/** @const {number} */
Windows.Media.Import.PhotoImportConnectionTransport.bluetooth;

/** @const */
Windows.Media.Import.PhotoImportContentType = {};
/** @const {number} */
Windows.Media.Import.PhotoImportContentType.unknown;
/** @const {number} */
Windows.Media.Import.PhotoImportContentType.image;
/** @const {number} */
Windows.Media.Import.PhotoImportContentType.video;

/** @const */
Windows.Media.Import.PhotoImportContentTypeFilter = {};
/** @const {number} */
Windows.Media.Import.PhotoImportContentTypeFilter.onlyImages;
/** @const {number} */
Windows.Media.Import.PhotoImportContentTypeFilter.onlyVideos;
/** @const {number} */
Windows.Media.Import.PhotoImportContentTypeFilter.imagesAndVideos;
/**
 * @constructor
 * @struct
 */
Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Import.PhotoImportItem>} */
Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult.prototype.deletedItems;
 /** @type {boolean} */
Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult.prototype.hasSucceeded;
 /** @type {number} */
Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult.prototype.photosCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult.prototype.photosSizeInBytes;
 /** @type {!Windows.Media.Import.PhotoImportSession} */
Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult.prototype.session;
 /** @type {number} */
Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult.prototype.siblingsCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult.prototype.siblingsSizeInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult.prototype.sidecarsCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult.prototype.sidecarsSizeInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult.prototype.totalCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult.prototype.totalSizeInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult.prototype.videosCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult.prototype.videosSizeInBytes;
/**
 * @constructor
 * @struct
 */
Windows.Media.Import.PhotoImportFindItemsResult = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Import.PhotoImportItem>} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.foundItems;
 /** @type {boolean} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.hasSucceeded;
 /** @type {Windows.Media.Import.PhotoImportImportMode} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.importMode;
 /** @type {function(?): void} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.onitemimported;
 /** @type {function(?): void} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.onselectionchanged;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.photosCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.photosSizeInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.selectedPhotosCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.selectedPhotosSizeInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.selectedSiblingsCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.selectedSiblingsSizeInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.selectedSidecarsCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.selectedSidecarsSizeInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.selectedTotalCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.selectedTotalSizeInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.selectedVideosCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.selectedVideosSizeInBytes;
 /** @type {!Windows.Media.Import.PhotoImportSession} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.session;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.siblingsCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.siblingsSizeInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.sidecarsCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.sidecarsSizeInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.totalCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.totalSizeInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.videosCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.videosSizeInBytes;

/**
 * Asynchronously imports the selected items from the source.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Import.PhotoImportImportItemsResult, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Media.Import.PhotoImportImportItemsResult, !Windows.Media.Import.PhotoImportProgress>>} An asynchronous operation that returns a PhotoImportImportItemsResult on successful completion.
 */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.importItemsAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.removeEventListener = function(type, listener) {};

/**
 * Selects all items found on the source to be included in the ImportItemsAsync operation.
 * @return {void}
 */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.selectAll = function() {};

/**
 * Selects all new items found on the source to be included in the ImportItemsAsync operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous operation.
 */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.selectNewAsync = function() {};

/**
 * Deselects all items found on the source, preventing them from being included in the ImportItemsAsync operation.
 * @return {void}
 */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.selectNone = function() {};

/**
 * Sets the photo import mode that determines which types of files are included in the ImportItemsAsync operation.
 * @param {Windows.Media.Import.PhotoImportImportMode} value The photo import mode.
 * @return {void}
 */
Windows.Media.Import.PhotoImportFindItemsResult.prototype.setImportMode = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Import.PhotoImportImportItemsResult = function() {};
 /** @type {boolean} */
Windows.Media.Import.PhotoImportImportItemsResult.prototype.hasSucceeded;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Import.PhotoImportItem>} */
Windows.Media.Import.PhotoImportImportItemsResult.prototype.importedItems;
 /** @type {number} */
Windows.Media.Import.PhotoImportImportItemsResult.prototype.photosCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportImportItemsResult.prototype.photosSizeInBytes;
 /** @type {!Windows.Media.Import.PhotoImportSession} */
Windows.Media.Import.PhotoImportImportItemsResult.prototype.session;
 /** @type {number} */
Windows.Media.Import.PhotoImportImportItemsResult.prototype.siblingsCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportImportItemsResult.prototype.siblingsSizeInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportImportItemsResult.prototype.sidecarsCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportImportItemsResult.prototype.sidecarsSizeInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportImportItemsResult.prototype.totalCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportImportItemsResult.prototype.totalSizeInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportImportItemsResult.prototype.videosCount;
 /** @type {number} */
Windows.Media.Import.PhotoImportImportItemsResult.prototype.videosSizeInBytes;

/**
 * Asynchronously deletes the items that were imported from the source.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult, number>>} An asynchronous operation that returns a PhotoImportDeleteImportedItemsFromSourceResult on successful completion.
 */
Windows.Media.Import.PhotoImportImportItemsResult.prototype.deleteImportedItemsFromSourceAsync = function() {};

/** @const */
Windows.Media.Import.PhotoImportImportMode = {};
/** @const {number} */
Windows.Media.Import.PhotoImportImportMode.importEverything;
/** @const {number} */
Windows.Media.Import.PhotoImportImportMode.ignoreSidecars;
/** @const {number} */
Windows.Media.Import.PhotoImportImportMode.ignoreSiblings;
/** @const {number} */
Windows.Media.Import.PhotoImportImportMode.ignoreSidecarsAndSiblings;
/**
 * @constructor
 * @struct
 */
Windows.Media.Import.PhotoImportItem = function() {};
 /** @type {Windows.Media.Import.PhotoImportContentType} */
Windows.Media.Import.PhotoImportItem.prototype.contentType;
 /** @type {!Date} */
Windows.Media.Import.PhotoImportItem.prototype.date;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Media.Import.PhotoImportItem.prototype.deletedFileNames;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Media.Import.PhotoImportItem.prototype.importedFileNames;
 /** @type {boolean} */
Windows.Media.Import.PhotoImportItem.prototype.isSelected;
 /** @type {number} */
Windows.Media.Import.PhotoImportItem.prototype.itemKey;
 /** @type {string} */
Windows.Media.Import.PhotoImportItem.prototype.name;
 /** @type {!Windows.Media.Import.PhotoImportSidecar} */
Windows.Media.Import.PhotoImportItem.prototype.sibling;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Import.PhotoImportSidecar>} */
Windows.Media.Import.PhotoImportItem.prototype.sidecars;
 /** @type {number} */
Windows.Media.Import.PhotoImportItem.prototype.sizeInBytes;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.Media.Import.PhotoImportItem.prototype.thumbnail;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Import.PhotoImportVideoSegment>} */
Windows.Media.Import.PhotoImportItem.prototype.videoSegments;
/**
 * @constructor
 * @struct
 */
Windows.Media.Import.PhotoImportItemImportedEventArgs = function() {};
 /** @type {!Windows.Media.Import.PhotoImportItem} */
Windows.Media.Import.PhotoImportItemImportedEventArgs.prototype.importedItem;

/** @const */
Windows.Media.Import.PhotoImportItemSelectionMode = {};
/** @const {number} */
Windows.Media.Import.PhotoImportItemSelectionMode.selectAll;
/** @const {number} */
Windows.Media.Import.PhotoImportItemSelectionMode.selectNone;
/** @const {number} */
Windows.Media.Import.PhotoImportItemSelectionMode.selectNew;
/**
 * @constructor
 * @struct
 */
Windows.Media.Import.PhotoImportManager = function() {};

/**
 * Finds all currently available sources from which photos can be imported.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation that returns a list of available sources on successful completion.
 */
Windows.Media.Import.PhotoImportManager.findAllSourcesAsync = function() {};

/**
 * Gets the list of all pending photo import operations.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Import.PhotoImportOperation>} The list of all pending photo operations.
 */
Windows.Media.Import.PhotoImportManager.getPendingOperations = function() {};

/**
 * Gets a value indicating if photo import is supported on the current device.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An asynchronous operation that returns true if photo import is supported. Otherwise, returns false.
 */
Windows.Media.Import.PhotoImportManager.isSupportedAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Import.PhotoImportOperation = function() {};
 /** @type {!Windows.Foundation.IAsyncOperationWithProgress<!Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult, number>} */
Windows.Media.Import.PhotoImportOperation.prototype.continueDeletingImportedItemsFromSourceAsync;
 /** @type {!Windows.Foundation.IAsyncOperationWithProgress<!Windows.Media.Import.PhotoImportFindItemsResult, number>} */
Windows.Media.Import.PhotoImportOperation.prototype.continueFindingItemsAsync;
 /** @type {!Windows.Foundation.IAsyncOperationWithProgress<!Windows.Media.Import.PhotoImportImportItemsResult, !Windows.Media.Import.PhotoImportProgress>} */
Windows.Media.Import.PhotoImportOperation.prototype.continueImportingItemsAsync;
 /** @type {!Windows.Media.Import.PhotoImportSession} */
Windows.Media.Import.PhotoImportOperation.prototype.session;
 /** @type {Windows.Media.Import.PhotoImportStage} */
Windows.Media.Import.PhotoImportOperation.prototype.stage;

/** @const */
Windows.Media.Import.PhotoImportPowerSource = {};
/** @const {number} */
Windows.Media.Import.PhotoImportPowerSource.unknown;
/** @const {number} */
Windows.Media.Import.PhotoImportPowerSource.battery;
/** @const {number} */
Windows.Media.Import.PhotoImportPowerSource.external;
/**
 * @constructor
 * @struct
 */
Windows.Media.Import.PhotoImportSelectionChangedEventArgs = function() {};
 /** @type {boolean} */
Windows.Media.Import.PhotoImportSelectionChangedEventArgs.prototype.isSelectionEmpty;
/**
 * @constructor
 * @struct
 */
Windows.Media.Import.PhotoImportSession = function() {};
 /** @type {boolean} */
Windows.Media.Import.PhotoImportSession.prototype.appendSessionDateToDestinationFolder;
 /** @type {string} */
Windows.Media.Import.PhotoImportSession.prototype.destinationFileNamePrefix;
 /** @type {!Windows.Storage.IStorageFolder} */
Windows.Media.Import.PhotoImportSession.prototype.destinationFolder;
 /** @type {string} */
Windows.Media.Import.PhotoImportSession.prototype.sessionId;
 /** @type {!Windows.Media.Import.PhotoImportSource} */
Windows.Media.Import.PhotoImportSession.prototype.source;
 /** @type {Windows.Media.Import.PhotoImportSubfolderCreationMode} */
Windows.Media.Import.PhotoImportSession.prototype.subfolderCreationMode;

/**
 * Closes the photo import session and releases associated resources.
 * @return {void}
 */
Windows.Media.Import.PhotoImportSession.prototype.close = function() {};

/**
 * Asynchronously finds items on the source device that are available for import.
 * @param {Windows.Media.Import.PhotoImportContentTypeFilter} contentTypeFilter A value indicating whether the find operation includes images, videos, or both in the results.
 * @param {Windows.Media.Import.PhotoImportItemSelectionMode} itemSelectionMode A value indicating whether all items, no items, or only new items in the results are initially marked as selected.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Import.PhotoImportFindItemsResult, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Media.Import.PhotoImportFindItemsResult, number>>} An asynchronous operation that returns a PhotoImportFindItemsResult on successful completion.
 */
Windows.Media.Import.PhotoImportSession.prototype.findItemsAsync = function(contentTypeFilter, itemSelectionMode) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Import.PhotoImportSidecar = function() {};
 /** @type {!Date} */
Windows.Media.Import.PhotoImportSidecar.prototype.date;
 /** @type {string} */
Windows.Media.Import.PhotoImportSidecar.prototype.name;
 /** @type {number} */
Windows.Media.Import.PhotoImportSidecar.prototype.sizeInBytes;
/**
 * @constructor
 * @struct
 */
Windows.Media.Import.PhotoImportSource = function() {};
 /** @type {number} */
Windows.Media.Import.PhotoImportSource.prototype.batteryLevelPercent;
 /** @type {string} */
Windows.Media.Import.PhotoImportSource.prototype.connectionProtocol;
 /** @type {Windows.Media.Import.PhotoImportConnectionTransport} */
Windows.Media.Import.PhotoImportSource.prototype.connectionTransport;
 /** @type {!Date} */
Windows.Media.Import.PhotoImportSource.prototype.dateTime;
 /** @type {string} */
Windows.Media.Import.PhotoImportSource.prototype.description;
 /** @type {string} */
Windows.Media.Import.PhotoImportSource.prototype.displayName;
 /** @type {string} */
Windows.Media.Import.PhotoImportSource.prototype.id;
 /** @type {boolean} */
Windows.Media.Import.PhotoImportSource.prototype.isLocked;
 /** @type {boolean} */
Windows.Media.Import.PhotoImportSource.prototype.isMassStorage;
 /** @type {string} */
Windows.Media.Import.PhotoImportSource.prototype.manufacturer;
 /** @type {string} */
Windows.Media.Import.PhotoImportSource.prototype.model;
 /** @type {Windows.Media.Import.PhotoImportPowerSource} */
Windows.Media.Import.PhotoImportSource.prototype.powerSource;
 /** @type {string} */
Windows.Media.Import.PhotoImportSource.prototype.serialNumber;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Import.PhotoImportStorageMedium>} */
Windows.Media.Import.PhotoImportSource.prototype.storageMedia;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.Media.Import.PhotoImportSource.prototype.thumbnail;
 /** @type {Windows.Media.Import.PhotoImportSourceType} */
Windows.Media.Import.PhotoImportSource.prototype.type;

/**
 * Creates a new instance of PhotoImportSource from the specified root folder.
 * @param {!Windows.Storage.IStorageFolder} sourceRootFolder The root folder from which the photo import source is created.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Import.PhotoImportSource, !Windows.Foundation.IAsyncOperation<!Windows.Media.Import.PhotoImportSource>>} An asynchronous operation that returns a PhotoImportSource upon successful completion.
 */
Windows.Media.Import.PhotoImportSource.fromFolderAsync = function(sourceRootFolder) {};

/**
 * Creates a new instance of PhotoImportSource from the specified device ID.
 * @param {string} sourceId The root folder from which the photo import source is created.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Import.PhotoImportSource, !Windows.Foundation.IAsyncOperation<!Windows.Media.Import.PhotoImportSource>>} An asynchronous operation that returns a PhotoImportSource upon successful completion.
 */
Windows.Media.Import.PhotoImportSource.fromIdAsync = function(sourceId) {};

/**
 * Creates a new photo import session.
 * @return {!Windows.Media.Import.PhotoImportSession} The new PhotoImportSession object.
 */
Windows.Media.Import.PhotoImportSource.prototype.createImportSession = function() {};

/** @const */
Windows.Media.Import.PhotoImportSourceType = {};
/** @const {number} */
Windows.Media.Import.PhotoImportSourceType.generic;
/** @const {number} */
Windows.Media.Import.PhotoImportSourceType.camera;
/** @const {number} */
Windows.Media.Import.PhotoImportSourceType.mediaPlayer;
/** @const {number} */
Windows.Media.Import.PhotoImportSourceType.phone;
/** @const {number} */
Windows.Media.Import.PhotoImportSourceType.video;
/** @const {number} */
Windows.Media.Import.PhotoImportSourceType.personalInfoManager;
/** @const {number} */
Windows.Media.Import.PhotoImportSourceType.audioRecorder;

/** @const */
Windows.Media.Import.PhotoImportStage = {};
/** @const {number} */
Windows.Media.Import.PhotoImportStage.notStarted;
/** @const {number} */
Windows.Media.Import.PhotoImportStage.findingItems;
/** @const {number} */
Windows.Media.Import.PhotoImportStage.importingItems;
/** @const {number} */
Windows.Media.Import.PhotoImportStage.deletingImportedItemsFromSource;
/**
 * @constructor
 * @struct
 */
Windows.Media.Import.PhotoImportStorageMedium = function() {};
 /** @type {number} */
Windows.Media.Import.PhotoImportStorageMedium.prototype.availableSpaceInBytes;
 /** @type {number} */
Windows.Media.Import.PhotoImportStorageMedium.prototype.capacityInBytes;
 /** @type {string} */
Windows.Media.Import.PhotoImportStorageMedium.prototype.description;
 /** @type {string} */
Windows.Media.Import.PhotoImportStorageMedium.prototype.name;
 /** @type {string} */
Windows.Media.Import.PhotoImportStorageMedium.prototype.serialNumber;
 /** @type {Windows.Media.Import.PhotoImportStorageMediumType} */
Windows.Media.Import.PhotoImportStorageMedium.prototype.storageMediumType;
 /** @type {Windows.Media.Import.PhotoImportAccessMode} */
Windows.Media.Import.PhotoImportStorageMedium.prototype.supportedAccessMode;

/**
 * Refreshes the information about the storage medium.
 * @return {void}
 */
Windows.Media.Import.PhotoImportStorageMedium.prototype.refresh = function() {};

/** @const */
Windows.Media.Import.PhotoImportStorageMediumType = {};
/** @const {number} */
Windows.Media.Import.PhotoImportStorageMediumType.undefined;
/** @const {number} */
Windows.Media.Import.PhotoImportStorageMediumType.fixed;
/** @const {number} */
Windows.Media.Import.PhotoImportStorageMediumType.removable;

/** @const */
Windows.Media.Import.PhotoImportSubfolderCreationMode = {};
/** @const {number} */
Windows.Media.Import.PhotoImportSubfolderCreationMode.doNotCreateSubfolders;
/** @const {number} */
Windows.Media.Import.PhotoImportSubfolderCreationMode.createSubfoldersFromFileDate;
/** @const {number} */
Windows.Media.Import.PhotoImportSubfolderCreationMode.createSubfoldersFromExifDate;
/** @const {number} */
Windows.Media.Import.PhotoImportSubfolderCreationMode.keepOriginalFolderStructure;
/**
 * @constructor
 * @struct
 */
Windows.Media.Import.PhotoImportVideoSegment = function() {};
 /** @type {!Date} */
Windows.Media.Import.PhotoImportVideoSegment.prototype.date;
 /** @type {string} */
Windows.Media.Import.PhotoImportVideoSegment.prototype.name;
 /** @type {!Windows.Media.Import.PhotoImportSidecar} */
Windows.Media.Import.PhotoImportVideoSegment.prototype.sibling;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Import.PhotoImportSidecar>} */
Windows.Media.Import.PhotoImportVideoSegment.prototype.sidecars;
 /** @type {number} */
Windows.Media.Import.PhotoImportVideoSegment.prototype.sizeInBytes;
/**
 * @record
 * @struct
 */
Windows.Media.Import.PhotoImportProgress = function() {};
 /** @type {number} */
Windows.Media.Import.PhotoImportProgress.prototype.bytesImported;
 /** @type {number} */
Windows.Media.Import.PhotoImportProgress.prototype.importProgress;
 /** @type {number} */
Windows.Media.Import.PhotoImportProgress.prototype.itemsImported;
 /** @type {number} */
Windows.Media.Import.PhotoImportProgress.prototype.totalBytesToImport;
 /** @type {number} */
Windows.Media.Import.PhotoImportProgress.prototype.totalItemsToImport;
/**
 * @constructor
 * @struct
 */
Windows.Media.MediaControl = function() {};
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.MediaControl.albumArt;
 /** @type {string} */
Windows.Media.MediaControl.artistName;
 /** @type {boolean} */
Windows.Media.MediaControl.isPlaying;
 /** @type {function(?): void} */
Windows.Media.MediaControl.onchanneldownpressed;
 /** @type {function(?): void} */
Windows.Media.MediaControl.onchanneluppressed;
 /** @type {function(?): void} */
Windows.Media.MediaControl.onfastforwardpressed;
 /** @type {function(?): void} */
Windows.Media.MediaControl.onnexttrackpressed;
 /** @type {function(?): void} */
Windows.Media.MediaControl.onpausepressed;
 /** @type {function(?): void} */
Windows.Media.MediaControl.onplaypausetogglepressed;
 /** @type {function(?): void} */
Windows.Media.MediaControl.onplaypressed;
 /** @type {function(?): void} */
Windows.Media.MediaControl.onprevioustrackpressed;
 /** @type {function(?): void} */
Windows.Media.MediaControl.onrecordpressed;
 /** @type {function(?): void} */
Windows.Media.MediaControl.onrewindpressed;
 /** @type {function(?): void} */
Windows.Media.MediaControl.onsoundlevelchanged;
 /** @type {function(?): void} */
Windows.Media.MediaControl.onstoppressed;
 /** @type {Windows.Media.SoundLevel} */
Windows.Media.MediaControl.soundLevel;
 /** @type {string} */
Windows.Media.MediaControl.trackName;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.MediaControl.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.MediaControl.removeEventListener = function(type, listener) {};

/**
 * @constructor
 * @struct
 * Creates a new MediaExtensionManager object that is used to register a media parser or codec.
 */
Windows.Media.MediaExtensionManager = function() {};

/**
 * Registers an audio decoder for the specified input and output media types.
 * Registers an audio decoder for the specified input and output media types with an optional configuration parameter.
 * @param {string} activatableClassId The class identifier of the activatable runtime class of the audio decoder. The runtime class must implement the IMediaExtension interface.
 * @param {string} inputSubtype The guid identifier of the media type that the audio decoder accepts as input.
 * @param {string} outputSubtype The guid identifier of the media type that is output by the audio decoder.
 * @param {!Windows.Foundation.Collections.IPropertySet=} configuration An optional parameter that contains the configuration properties to be passed to the audio decoder.
 * @return {void}
 */
Windows.Media.MediaExtensionManager.prototype.registerAudioDecoder = function(activatableClassId, inputSubtype, outputSubtype, configuration) {};

/**
 * Registers an audio encoder for the specified input and output media types with an optional configuration parameter.
 * Registers an audio encoder for the specified input and output media types.
 * @param {string} activatableClassId The class identifier of the activatable runtime class of the audio encoder. The runtime class must implement the IMediaExtension interface.
 * @param {string} inputSubtype The guid identifier of the media type that the audio encoder accepts as input.
 * @param {string} outputSubtype The guid identifier of the media type that is output by the audio encoder.
 * @param {!Windows.Foundation.Collections.IPropertySet=} configuration An optional parameter that contains the configuration properties to be passed to the audio encoder.
 * @return {void}
 */
Windows.Media.MediaExtensionManager.prototype.registerAudioEncoder = function(activatableClassId, inputSubtype, outputSubtype, configuration) {};

/**
 * Registers a byte-stream handler by file name extension and MIME type.
 * Registers a byte-stream handler by file name extension and MIME type, with an optional configuration parameter.
 * @param {string} activatableClassId The class identifier of the activatable runtime class of the byte-stream handler. The runtime class must implement the IMediaExtension interface.
 * @param {string} fileExtension The file name extension that is registered for this byte-stream handler.
 * @param {string} mimeType The MIME type that is registered for this byte-stream handler.
 * @param {!Windows.Foundation.Collections.IPropertySet=} configuration An optional parameter that contains configuration properties for the byte-stream handler.
 * @return {void}
 */
Windows.Media.MediaExtensionManager.prototype.registerByteStreamHandler = function(activatableClassId, fileExtension, mimeType, configuration) {};

/**
 * Registers a scheme handler for the specified URL scheme with an optional configuration parameter.
 * Registers a scheme handler for the specified URL scheme.
 * @param {string} activatableClassId The class identifier of the activatable runtime class of the scheme handler. The runtime class must implement the IMediaExtension interface.
 * @param {string} scheme The URL scheme that will be recognized to invoke the scheme handler. For example, "myscheme://".
 * @param {!Windows.Foundation.Collections.IPropertySet=} configuration An optional parameter that contains configuration properties for the scheme handler.
 * @return {void}
 */
Windows.Media.MediaExtensionManager.prototype.registerSchemeHandler = function(activatableClassId, scheme, configuration) {};

/**
 * Registers an video decoder for the specified input and output media types.
 * Registers a video decoder for the specified input and output media types with an optional configuration parameter.
 * @param {string} activatableClassId The class identifier of the activatable runtime class of the video decoder. The runtime class must implement the IMediaExtension interface.
 * @param {string} inputSubtype The guid identifier of the media type that the video decoder accepts as input.
 * @param {string} outputSubtype The guid identifier of the media type that is output by the video decoder.
 * @param {!Windows.Foundation.Collections.IPropertySet=} configuration An optional parameter that contains the configuration properties to be passed to the video decoder.
 * @return {void}
 */
Windows.Media.MediaExtensionManager.prototype.registerVideoDecoder = function(activatableClassId, inputSubtype, outputSubtype, configuration) {};

/**
 * Registers a video encoder for the specified input and output media types.
 * Registers a video encoder for the specified input and output media types with an optional configuration parameter.
 * @param {string} activatableClassId The class identifier of the activatable runtime class of the video encoder. The runtime class must implement the IMediaExtension interface.
 * @param {string} inputSubtype The guid identifier of the media type that the video encoder accepts as input.
 * @param {string} outputSubtype The guid identifier of the media type that is output by the video encoder.
 * @param {!Windows.Foundation.Collections.IPropertySet=} configuration An optional parameter that contains the configuration properties to be passed to the video encoder.
 * @return {void}
 */
Windows.Media.MediaExtensionManager.prototype.registerVideoEncoder = function(activatableClassId, inputSubtype, outputSubtype, configuration) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.MediaMarkerTypes = function() {};
 /** @type {string} */
Windows.Media.MediaMarkerTypes.bookmark;

/** @const */
Windows.Media.MediaPlaybackAutoRepeatMode = {};
/** @const {number} */
Windows.Media.MediaPlaybackAutoRepeatMode.none;
/** @const {number} */
Windows.Media.MediaPlaybackAutoRepeatMode.track;
/** @const {number} */
Windows.Media.MediaPlaybackAutoRepeatMode.list;

/** @const */
Windows.Media.MediaPlaybackStatus = {};
/** @const {number} */
Windows.Media.MediaPlaybackStatus.closed;
/** @const {number} */
Windows.Media.MediaPlaybackStatus.changing;
/** @const {number} */
Windows.Media.MediaPlaybackStatus.stopped;
/** @const {number} */
Windows.Media.MediaPlaybackStatus.playing;
/** @const {number} */
Windows.Media.MediaPlaybackStatus.paused;

/** @const */
Windows.Media.MediaPlaybackType = {};
/** @const {number} */
Windows.Media.MediaPlaybackType.unknown;
/** @const {number} */
Windows.Media.MediaPlaybackType.music;
/** @const {number} */
Windows.Media.MediaPlaybackType.video;
/** @const {number} */
Windows.Media.MediaPlaybackType.image;
/**
 * @constructor
 * @struct
 */
Windows.Media.MediaProcessingTriggerDetails = function() {};
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.Media.MediaProcessingTriggerDetails.prototype.arguments;
/** @const */
Windows.Media.MediaProperties = {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the AudioEncodingProperties class.
 */
Windows.Media.MediaProperties.AudioEncodingProperties = function() {};
 /** @type {number} */
Windows.Media.MediaProperties.AudioEncodingProperties.prototype.bitrate;
 /** @type {number} */
Windows.Media.MediaProperties.AudioEncodingProperties.prototype.bitsPerSample;
 /** @type {number} */
Windows.Media.MediaProperties.AudioEncodingProperties.prototype.channelCount;
 /** @type {!Windows.Media.MediaProperties.MediaPropertySet} */
Windows.Media.MediaProperties.AudioEncodingProperties.prototype.properties;
 /** @type {number} */
Windows.Media.MediaProperties.AudioEncodingProperties.prototype.sampleRate;
 /** @type {string} */
Windows.Media.MediaProperties.AudioEncodingProperties.prototype.subtype;
 /** @type {string} */
Windows.Media.MediaProperties.AudioEncodingProperties.prototype.type;

/**
 * Creates an instance of AudioEncodingProperties for Advanced Audio Coding (AAC) audio.
 * @param {number} sampleRate The audio sampling rate.
 * @param {number} channelCount The number of audio channels.
 * @param {number} bitrate The audio bit rate.
 * @return {!Windows.Media.MediaProperties.AudioEncodingProperties} The audio encoding properties.
 */
Windows.Media.MediaProperties.AudioEncodingProperties.createAac = function(sampleRate, channelCount, bitrate) {};

/**
 * Creates an instance of AudioEncodingProperties for Advanced Audio Coding (AAC) audio in Audio Data Transport Stream (ADTS) format.
 * @param {number} sampleRate The audio sampling rate.
 * @param {number} channelCount The number of audio channels.
 * @param {number} bitrate The audio bit rate.
 * @return {!Windows.Media.MediaProperties.AudioEncodingProperties} The audio encoding properties.
 */
Windows.Media.MediaProperties.AudioEncodingProperties.createAacAdts = function(sampleRate, channelCount, bitrate) {};

/**
 * Creates an instance of AudioEncodingProperties for MPEG Audio Layer-3 (MP3) audio.
 * @param {number} sampleRate The audio sampling rate.
 * @param {number} channelCount The number of audio channels.
 * @param {number} bitrate The audio bit rate.
 * @return {!Windows.Media.MediaProperties.AudioEncodingProperties} The audio encoding properties.
 */
Windows.Media.MediaProperties.AudioEncodingProperties.createMp3 = function(sampleRate, channelCount, bitrate) {};

/**
 * Creates an instance of AudioEncodingProperties for Pulse Code Modulation (PCM) audio.
 * @param {number} sampleRate The audio sampling rate.
 * @param {number} channelCount The number of audio channels.
 * @param {number} bitsPerSample The audio bit depth.
 * @return {!Windows.Media.MediaProperties.AudioEncodingProperties} The audio encoding properties.
 */
Windows.Media.MediaProperties.AudioEncodingProperties.createPcm = function(sampleRate, channelCount, bitsPerSample) {};

/**
 * Creates an instance of AudioEncodingProperties for Windows Media Audio (WMA).
 * @param {number} sampleRate The audio sampling rate.
 * @param {number} channelCount The number of audio channels.
 * @param {number} bitrate The audio bit rate.
 * @return {!Windows.Media.MediaProperties.AudioEncodingProperties} The audio encoding properties.
 */
Windows.Media.MediaProperties.AudioEncodingProperties.createWma = function(sampleRate, channelCount, bitrate) {};

/**
 * Gets the media format user data.
 * @return {!Array<number>} Receives the media format data.
 */
Windows.Media.MediaProperties.AudioEncodingProperties.prototype.getFormatUserData = function() {};

/**
 * Sets the media format user data.
 * @param {!Array<number>} value The media data to set.
 * @return {void}
 */
Windows.Media.MediaProperties.AudioEncodingProperties.prototype.setFormatUserData = function(value) {};

/** @const */
Windows.Media.MediaProperties.AudioEncodingQuality = {};
/** @const {number} */
Windows.Media.MediaProperties.AudioEncodingQuality.auto;
/** @const {number} */
Windows.Media.MediaProperties.AudioEncodingQuality.high;
/** @const {number} */
Windows.Media.MediaProperties.AudioEncodingQuality.medium;
/** @const {number} */
Windows.Media.MediaProperties.AudioEncodingQuality.low;

/**
 * @constructor
 * @struct
 * Creates a new instance of the ContainerEncodingProperties class.
 */
Windows.Media.MediaProperties.ContainerEncodingProperties = function() {};
 /** @type {!Windows.Media.MediaProperties.MediaPropertySet} */
Windows.Media.MediaProperties.ContainerEncodingProperties.prototype.properties;
 /** @type {string} */
Windows.Media.MediaProperties.ContainerEncodingProperties.prototype.subtype;
 /** @type {string} */
Windows.Media.MediaProperties.ContainerEncodingProperties.prototype.type;
/**
 * @constructor
 * @struct
 */
Windows.Media.MediaProperties.H264ProfileIds = function() {};
 /** @type {number} */
Windows.Media.MediaProperties.H264ProfileIds.baseline;
 /** @type {number} */
Windows.Media.MediaProperties.H264ProfileIds.constrainedBaseline;
 /** @type {number} */
Windows.Media.MediaProperties.H264ProfileIds.extended;
 /** @type {number} */
Windows.Media.MediaProperties.H264ProfileIds.high;
 /** @type {number} */
Windows.Media.MediaProperties.H264ProfileIds.high10;
 /** @type {number} */
Windows.Media.MediaProperties.H264ProfileIds.high422;
 /** @type {number} */
Windows.Media.MediaProperties.H264ProfileIds.high444;
 /** @type {number} */
Windows.Media.MediaProperties.H264ProfileIds.main;
 /** @type {number} */
Windows.Media.MediaProperties.H264ProfileIds.multiviewHigh;
 /** @type {number} */
Windows.Media.MediaProperties.H264ProfileIds.stereoHigh;

/**
 * @constructor
 * @struct
 * Creates a new instance of the ImageEncodingProperties class.
 */
Windows.Media.MediaProperties.ImageEncodingProperties = function() {};
 /** @type {number} */
Windows.Media.MediaProperties.ImageEncodingProperties.prototype.height;
 /** @type {!Windows.Media.MediaProperties.MediaPropertySet} */
Windows.Media.MediaProperties.ImageEncodingProperties.prototype.properties;
 /** @type {string} */
Windows.Media.MediaProperties.ImageEncodingProperties.prototype.subtype;
 /** @type {string} */
Windows.Media.MediaProperties.ImageEncodingProperties.prototype.type;
 /** @type {number} */
Windows.Media.MediaProperties.ImageEncodingProperties.prototype.width;

/**
 * Creates an instance of ImageEncodingProperties for a BMP image.
 * @return {!Windows.Media.MediaProperties.ImageEncodingProperties} The image encoding properties.
 */
Windows.Media.MediaProperties.ImageEncodingProperties.createBmp = function() {};

/**
 * Creates an instance of ImageEncodingProperties for a JPEG image.
 * @return {!Windows.Media.MediaProperties.ImageEncodingProperties} The properties for the image stream.
 */
Windows.Media.MediaProperties.ImageEncodingProperties.createJpeg = function() {};

/**
 * Creates an instance of ImageEncodingProperties for a JPEG XR image.
 * @return {!Windows.Media.MediaProperties.ImageEncodingProperties} The properties for the image stream.
 */
Windows.Media.MediaProperties.ImageEncodingProperties.createJpegXR = function() {};

/**
 * Creates an instance of ImageEncodingProperties for a PNG image.
 * @return {!Windows.Media.MediaProperties.ImageEncodingProperties} The properties for the image stream.
 */
Windows.Media.MediaProperties.ImageEncodingProperties.createPng = function() {};

/**
 * Creates an instance of ImageEncodingProperties for an uncompressed image.
 * @param {Windows.Media.MediaProperties.MediaPixelFormat} format The media pixel format.
 * @return {!Windows.Media.MediaProperties.ImageEncodingProperties} The image encoding properties.
 */
Windows.Media.MediaProperties.ImageEncodingProperties.createUncompressed = function(format) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the MediaEncodingProfile class.
 */
Windows.Media.MediaProperties.MediaEncodingProfile = function() {};
 /** @type {!Windows.Media.MediaProperties.AudioEncodingProperties} */
Windows.Media.MediaProperties.MediaEncodingProfile.prototype.audio;
 /** @type {!Windows.Media.MediaProperties.ContainerEncodingProperties} */
Windows.Media.MediaProperties.MediaEncodingProfile.prototype.container;
 /** @type {!Windows.Media.MediaProperties.VideoEncodingProperties} */
Windows.Media.MediaProperties.MediaEncodingProfile.prototype.video;

/**
 * Creates an instance of MediaEncodingProfile for AVI.
 * @param {Windows.Media.MediaProperties.VideoEncodingQuality} quality The video quality.
 * @return {!Windows.Media.MediaProperties.MediaEncodingProfile} The media encoding profile.
 */
Windows.Media.MediaProperties.MediaEncodingProfile.createAvi = function(quality) {};

/**
 * Creates an encoding profile from an existing media file.
 * @param {!Windows.Storage.IStorageFile} file The media file from which to create the profile.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.MediaProperties.MediaEncodingProfile, !Windows.Foundation.IAsyncOperation<!Windows.Media.MediaProperties.MediaEncodingProfile>>} An object that is used to control the asynchronous operation.
 */
Windows.Media.MediaProperties.MediaEncodingProfile.createFromFileAsync = function(file) {};

/**
 * Creates an encoding profile from a stream that contains media data.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} stream The media stream from which to create the profile.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.MediaProperties.MediaEncodingProfile, !Windows.Foundation.IAsyncOperation<!Windows.Media.MediaProperties.MediaEncodingProfile>>} An object that is used to control the asynchronous operation.
 */
Windows.Media.MediaProperties.MediaEncodingProfile.createFromStreamAsync = function(stream) {};

/**
 * Creates an encoding profile for AAC audio.
 * @param {Windows.Media.MediaProperties.AudioEncodingQuality} quality Specifies whether to create a profile with a low bit rate, medium bit rate, or high bit rate.
 * @return {!Windows.Media.MediaProperties.MediaEncodingProfile} Returns a media encoding profile.
 */
Windows.Media.MediaProperties.MediaEncodingProfile.createM4a = function(quality) {};

/**
 * Creates an encoding profile for MP3 (MPEG-1 layer 3) audio.
 * @param {Windows.Media.MediaProperties.AudioEncodingQuality} quality Specifies whether to create a profile with a low bit rate, medium bit rate, or high bit rate.
 * @return {!Windows.Media.MediaProperties.MediaEncodingProfile} Returns a media encoding profile.
 */
Windows.Media.MediaProperties.MediaEncodingProfile.createMp3 = function(quality) {};

/**
 * Creates an encoding profile for H.264 video.
 * @param {Windows.Media.MediaProperties.VideoEncodingQuality} quality Specifies the video resolution of the profile.
 * @return {!Windows.Media.MediaProperties.MediaEncodingProfile} Returns a media encoding profile.
 */
Windows.Media.MediaProperties.MediaEncodingProfile.createMp4 = function(quality) {};

/**
 * Creates an instance of MediaEncodingProfile for WAV
 * @param {Windows.Media.MediaProperties.AudioEncodingQuality} quality The audio encoding quality.
 * @return {!Windows.Media.MediaProperties.MediaEncodingProfile} The media encoding profile.
 */
Windows.Media.MediaProperties.MediaEncodingProfile.createWav = function(quality) {};

/**
 * Creates an encoding profile for Windows Media Audio (WMA).
 * @param {Windows.Media.MediaProperties.AudioEncodingQuality} quality Specifies whether to create a profile with a low bit rate, medium bit rate, or high bit rate.
 * @return {!Windows.Media.MediaProperties.MediaEncodingProfile} Returns a media encoding profile.
 */
Windows.Media.MediaProperties.MediaEncodingProfile.createWma = function(quality) {};

/**
 * Creates an encoding profile for Windows Media Video (WMV).
 * @param {Windows.Media.MediaProperties.VideoEncodingQuality} quality Specifies the video resolution of the profile.
 * @return {!Windows.Media.MediaProperties.MediaEncodingProfile} Returns a media encoding profile.
 */
Windows.Media.MediaProperties.MediaEncodingProfile.createWmv = function(quality) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.MediaProperties.MediaEncodingSubtypes = function() {};
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.aac;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.aacAdts;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.ac3;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.amrNb;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.amrWb;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.argb32;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.asf;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.avi;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.bgra8;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.bmp;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.eac3;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.float;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.gif;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.h263;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.h264;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.h264Es;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.hevc;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.hevcEs;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.iyuv;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.jpeg;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.jpegXr;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.mjpg;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.mp3;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.mpeg;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.mpeg1;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.mpeg2;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.mpeg4;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.nv12;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.pcm;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.png;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.rgb24;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.rgb32;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.tiff;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.wave;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.wma8;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.wma9;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.wmv3;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.wvc1;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.yuy2;
 /** @type {string} */
Windows.Media.MediaProperties.MediaEncodingSubtypes.yv12;

/** @const */
Windows.Media.MediaProperties.MediaMirroringOptions = {};
/** @const {number} */
Windows.Media.MediaProperties.MediaMirroringOptions.none;
/** @const {number} */
Windows.Media.MediaProperties.MediaMirroringOptions.horizontal;
/** @const {number} */
Windows.Media.MediaProperties.MediaMirroringOptions.vertical;

/** @const */
Windows.Media.MediaProperties.MediaPixelFormat = {};
/** @const {number} */
Windows.Media.MediaProperties.MediaPixelFormat.nv12;
/** @const {number} */
Windows.Media.MediaProperties.MediaPixelFormat.bgra8;

/**
 * @constructor
 * @struct
 * Creates an instance for MediaPropertySet .
 */
Windows.Media.MediaProperties.MediaPropertySet = function() {};
 /** @type {number} */
Windows.Media.MediaProperties.MediaPropertySet.prototype.size;

/**
 * Removes all items from the property set.
 * @return {void}
 */
Windows.Media.MediaProperties.MediaPropertySet.prototype.clear = function() {};

/**
 * Returns an iterator to enumerate the items in the property set.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The iterator. The current position of the iterator is index 0, or the end of the property set if the property set is empty.
 */
Windows.Media.MediaProperties.MediaPropertySet.prototype.first = function() {};

/**
 * Returns an immutable view of the property set.
 * @return {!Windows.Foundation.Collections.IMapView<string, ?>} The immutable view.
 */
Windows.Media.MediaProperties.MediaPropertySet.prototype.getView = function() {};

/**
 * Indicates whether the property set has an item with the specified key.
 * @param {string} key The key.
 * @return {boolean} True if the property set has an item with the specified key; otherwise, false.
 */
Windows.Media.MediaProperties.MediaPropertySet.prototype.hasKey = function(key) {};

/**
 * Adds an item to the property set.
 * @param {string} key The key of the item to insert.
 * @param {?} value The value of the item to insert.
 * @return {boolean} True if the method replaced a value that already existed for the key; false if this is a new key.
 */
Windows.Media.MediaProperties.MediaPropertySet.prototype.insert = function(key, value) {};

/**
 * Retrieves the value for the specified key.
 * @param {string} key The key.
 * @return {?} The value, if an item with the specified key exists. Otherwise, null.
 */
Windows.Media.MediaProperties.MediaPropertySet.prototype.lookup = function(key) {};

/**
 * Removes an item from the property set.
 * Removes a specific item from the MediaPropertySet .
 * @param {string} key The key of the item to remove.
 * @return {void|boolean} true if the item was removed, otherwise false.
 */
Windows.Media.MediaProperties.MediaPropertySet.prototype.remove = function(key) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.MediaProperties.MediaRatio = function() {};
 /** @type {number} */
Windows.Media.MediaProperties.MediaRatio.prototype.denominator;
 /** @type {number} */
Windows.Media.MediaProperties.MediaRatio.prototype.numerator;

/** @const */
Windows.Media.MediaProperties.MediaRotation = {};
/** @const {number} */
Windows.Media.MediaProperties.MediaRotation.none;
/** @const {number} */
Windows.Media.MediaProperties.MediaRotation.clockwise90Degrees;
/** @const {number} */
Windows.Media.MediaProperties.MediaRotation.clockwise180Degrees;
/** @const {number} */
Windows.Media.MediaProperties.MediaRotation.clockwise270Degrees;

/** @const */
Windows.Media.MediaProperties.MediaThumbnailFormat = {};
/** @const {number} */
Windows.Media.MediaProperties.MediaThumbnailFormat.bmp;
/** @const {number} */
Windows.Media.MediaProperties.MediaThumbnailFormat.bgra8;
/**
 * @constructor
 * @struct
 */
Windows.Media.MediaProperties.Mpeg2ProfileIds = function() {};
 /** @type {number} */
Windows.Media.MediaProperties.Mpeg2ProfileIds.high;
 /** @type {number} */
Windows.Media.MediaProperties.Mpeg2ProfileIds.main;
 /** @type {number} */
Windows.Media.MediaProperties.Mpeg2ProfileIds.signalNoiseRatioScalable;
 /** @type {number} */
Windows.Media.MediaProperties.Mpeg2ProfileIds.simple;
 /** @type {number} */
Windows.Media.MediaProperties.Mpeg2ProfileIds.spatiallyScalable;

/**
 * @constructor
 * @struct
 * Creates a new instance of the VideoEncodingProperties class.
 */
Windows.Media.MediaProperties.VideoEncodingProperties = function() {};
 /** @type {number} */
Windows.Media.MediaProperties.VideoEncodingProperties.prototype.bitrate;
 /** @type {!Windows.Media.MediaProperties.MediaRatio} */
Windows.Media.MediaProperties.VideoEncodingProperties.prototype.frameRate;
 /** @type {number} */
Windows.Media.MediaProperties.VideoEncodingProperties.prototype.height;
 /** @type {!Windows.Media.MediaProperties.MediaRatio} */
Windows.Media.MediaProperties.VideoEncodingProperties.prototype.pixelAspectRatio;
 /** @type {number} */
Windows.Media.MediaProperties.VideoEncodingProperties.prototype.profileId;
 /** @type {!Windows.Media.MediaProperties.MediaPropertySet} */
Windows.Media.MediaProperties.VideoEncodingProperties.prototype.properties;
 /** @type {string} */
Windows.Media.MediaProperties.VideoEncodingProperties.prototype.subtype;
 /** @type {string} */
Windows.Media.MediaProperties.VideoEncodingProperties.prototype.type;
 /** @type {number} */
Windows.Media.MediaProperties.VideoEncodingProperties.prototype.width;

/**
 * Creates an instance of VideoEncodingProperties for a H.263 video.
 * @return {!Windows.Media.MediaProperties.VideoEncodingProperties} The video encoding properties.
 */
Windows.Media.MediaProperties.VideoEncodingProperties.createH264 = function() {};

/**
 * Creates an instance of VideoEncodingProperties for a MPEG-2 video.
 * @return {!Windows.Media.MediaProperties.VideoEncodingProperties} The video encoding properties.
 */
Windows.Media.MediaProperties.VideoEncodingProperties.createMpeg2 = function() {};

/**
 * Creates an instance of VideoEncodingProperties for a uncompressed video.
 * @param {string} subtype The media subtype of the format.
 * @param {number} width The video image width.
 * @param {number} height The video image height.
 * @return {!Windows.Media.MediaProperties.VideoEncodingProperties} The video encoding properties.
 */
Windows.Media.MediaProperties.VideoEncodingProperties.createUncompressed = function(subtype, width, height) {};

/**
 * Gets the media format user data.
 * @return {!Array<number>} Receives the media format data.
 */
Windows.Media.MediaProperties.VideoEncodingProperties.prototype.getFormatUserData = function() {};

/**
 * Sets the media format user data.
 * @param {!Array<number>} value The media data to set.
 * @return {void}
 */
Windows.Media.MediaProperties.VideoEncodingProperties.prototype.setFormatUserData = function(value) {};

/** @const */
Windows.Media.MediaProperties.VideoEncodingQuality = {};
/** @const {number} */
Windows.Media.MediaProperties.VideoEncodingQuality.auto;
/** @const {number} */
Windows.Media.MediaProperties.VideoEncodingQuality.hd1080p;
/** @const {number} */
Windows.Media.MediaProperties.VideoEncodingQuality.hd720p;
/** @const {number} */
Windows.Media.MediaProperties.VideoEncodingQuality.wvga;
/** @const {number} */
Windows.Media.MediaProperties.VideoEncodingQuality.ntsc;
/** @const {number} */
Windows.Media.MediaProperties.VideoEncodingQuality.pal;
/** @const {number} */
Windows.Media.MediaProperties.VideoEncodingQuality.vga;
/** @const {number} */
Windows.Media.MediaProperties.VideoEncodingQuality.qvga;
/**
 * @record
 * @struct
 */
Windows.Media.MediaProperties.IMediaEncodingProperties = function() {};
 /** @type {!Windows.Media.MediaProperties.MediaPropertySet} */
Windows.Media.MediaProperties.IMediaEncodingProperties.prototype.properties;
 /** @type {string} */
Windows.Media.MediaProperties.IMediaEncodingProperties.prototype.subtype;
 /** @type {string} */
Windows.Media.MediaProperties.IMediaEncodingProperties.prototype.type;
/**
 * @constructor
 * @struct
 */
Windows.Media.MusicDisplayProperties = function() {};
 /** @type {string} */
Windows.Media.MusicDisplayProperties.prototype.albumArtist;
 /** @type {string} */
Windows.Media.MusicDisplayProperties.prototype.albumTitle;
 /** @type {string} */
Windows.Media.MusicDisplayProperties.prototype.artist;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Media.MusicDisplayProperties.prototype.genres;
 /** @type {string} */
Windows.Media.MusicDisplayProperties.prototype.title;
 /** @type {number} */
Windows.Media.MusicDisplayProperties.prototype.trackNumber;
/** @const */
Windows.Media.Ocr = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Ocr.OcrEngine = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Globalization.Language>} */
Windows.Media.Ocr.OcrEngine.availableRecognizerLanguages;
 /** @type {number} */
Windows.Media.Ocr.OcrEngine.maxImageDimension;
 /** @type {!Windows.Globalization.Language} */
Windows.Media.Ocr.OcrEngine.prototype.recognizerLanguage;

/**
 * Returns true if a specified language can be resolved to any of the available OCR languages. See language matching for a further explanation of language resolving.
 * @param {!Windows.Globalization.Language} language The language being used for text recognition.
 * @return {boolean} TRUE, if the specified language can be resolved to any of the available OCR languages; otherwise, FALSE.
 */
Windows.Media.Ocr.OcrEngine.isLanguageSupported = function(language) {};

/**
 * Creates a new instance of the OcrEngine class.
 * @param {!Windows.Globalization.Language} language The language being used for text recognition.
 * @return {!Windows.Media.Ocr.OcrEngine} If the specified language can be resolved to any of the OCR languages available on the device, returns new instance of OcrEngine class, otherwise returns null. See language matching for a further explanation of language resolving.
 */
Windows.Media.Ocr.OcrEngine.tryCreateFromLanguage = function(language) {};

/**
 * Creates a new instance of the OcrEngine class.
 * @return {!Windows.Media.Ocr.OcrEngine} If any language from GlobalizationPreferences.Languages can be resolved to any of the available OCR languages returns new instance of OcrEngine class, otherwise returns null.
 */
Windows.Media.Ocr.OcrEngine.tryCreateFromUserProfileLanguages = function() {};

/**
 * Scans the specified image for text in the language specified by the RecognizerLanguage property.
 * @param {!Windows.Graphics.Imaging.SoftwareBitmap} bitmap Represents an uncompressed bitmap.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Ocr.OcrResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Ocr.OcrResult>>} The result of the OCR that was initiated by the OcrEngine object.
 */
Windows.Media.Ocr.OcrEngine.prototype.recognizeAsync = function(bitmap) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Ocr.OcrLine = function() {};
 /** @type {string} */
Windows.Media.Ocr.OcrLine.prototype.text;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Ocr.OcrWord>} */
Windows.Media.Ocr.OcrLine.prototype.words;
/**
 * @constructor
 * @struct
 */
Windows.Media.Ocr.OcrResult = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Ocr.OcrLine>} */
Windows.Media.Ocr.OcrResult.prototype.lines;
 /** @type {string} */
Windows.Media.Ocr.OcrResult.prototype.text;
 /** @type {number} */
Windows.Media.Ocr.OcrResult.prototype.textAngle;
/**
 * @constructor
 * @struct
 */
Windows.Media.Ocr.OcrWord = function() {};
 /** @type {!Windows.Foundation.Rect} */
Windows.Media.Ocr.OcrWord.prototype.boundingRect;
 /** @type {string} */
Windows.Media.Ocr.OcrWord.prototype.text;
/** @const */
Windows.Media.PlayTo = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs = function() {};
 /** @type {number} */
Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs.prototype.time;
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.MuteChangeRequestedEventArgs = function() {};
 /** @type {boolean} */
Windows.Media.PlayTo.MuteChangeRequestedEventArgs.prototype.mute;
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.PlayToConnection = function() {};
 /** @type {function(?): void} */
Windows.Media.PlayTo.PlayToConnection.prototype.onerror;
 /** @type {function(?): void} */
Windows.Media.PlayTo.PlayToConnection.prototype.onstatechanged;
 /** @type {function(?): void} */
Windows.Media.PlayTo.PlayToConnection.prototype.ontransferred;
 /** @type {Windows.Media.PlayTo.PlayToConnectionState} */
Windows.Media.PlayTo.PlayToConnection.prototype.state;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.PlayTo.PlayToConnection.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.PlayTo.PlayToConnection.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Media.PlayTo.PlayToConnectionError = {};
/** @const {number} */
Windows.Media.PlayTo.PlayToConnectionError.none;
/** @const {number} */
Windows.Media.PlayTo.PlayToConnectionError.deviceNotResponding;
/** @const {number} */
Windows.Media.PlayTo.PlayToConnectionError.deviceError;
/** @const {number} */
Windows.Media.PlayTo.PlayToConnectionError.deviceLocked;
/** @const {number} */
Windows.Media.PlayTo.PlayToConnectionError.protectedPlaybackFailed;
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.PlayToConnectionErrorEventArgs = function() {};
 /** @type {Windows.Media.PlayTo.PlayToConnectionError} */
Windows.Media.PlayTo.PlayToConnectionErrorEventArgs.prototype.code;
 /** @type {string} */
Windows.Media.PlayTo.PlayToConnectionErrorEventArgs.prototype.message;

/** @const */
Windows.Media.PlayTo.PlayToConnectionState = {};
/** @const {number} */
Windows.Media.PlayTo.PlayToConnectionState.disconnected;
/** @const {number} */
Windows.Media.PlayTo.PlayToConnectionState.connected;
/** @const {number} */
Windows.Media.PlayTo.PlayToConnectionState.rendering;
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs = function() {};
 /** @type {Windows.Media.PlayTo.PlayToConnectionState} */
Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs.prototype.currentState;
 /** @type {Windows.Media.PlayTo.PlayToConnectionState} */
Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs.prototype.previousState;
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs = function() {};
 /** @type {!Windows.Media.PlayTo.PlayToSource} */
Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs.prototype.currentSource;
 /** @type {!Windows.Media.PlayTo.PlayToSource} */
Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs.prototype.previousSource;
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.PlayToManager = function() {};
 /** @type {boolean} */
Windows.Media.PlayTo.PlayToManager.prototype.defaultSourceSelection;
 /** @type {function(?): void} */
Windows.Media.PlayTo.PlayToManager.prototype.onsourcerequested;
 /** @type {function(?): void} */
Windows.Media.PlayTo.PlayToManager.prototype.onsourceselected;

/**
 * Gets the Play To manager for the current view.
 * @return {!Windows.Media.PlayTo.PlayToManager} The Play To manager for the current view.
 */
Windows.Media.PlayTo.PlayToManager.getForCurrentView = function() {};

/**
 * Displays the Play To UI.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToManager.showPlayToUI = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.PlayTo.PlayToManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.PlayTo.PlayToManager.prototype.removeEventListener = function(type, listener) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of a Play To receiver.
 */
Windows.Media.PlayTo.PlayToReceiver = function() {};
 /** @type {string} */
Windows.Media.PlayTo.PlayToReceiver.prototype.friendlyName;
 /** @type {function(?): void} */
Windows.Media.PlayTo.PlayToReceiver.prototype.oncurrenttimechangerequested;
 /** @type {function(?): void} */
Windows.Media.PlayTo.PlayToReceiver.prototype.onmutechangerequested;
 /** @type {function(?): void} */
Windows.Media.PlayTo.PlayToReceiver.prototype.onpauserequested;
 /** @type {function(?): void} */
Windows.Media.PlayTo.PlayToReceiver.prototype.onplaybackratechangerequested;
 /** @type {function(?): void} */
Windows.Media.PlayTo.PlayToReceiver.prototype.onplayrequested;
 /** @type {function(?): void} */
Windows.Media.PlayTo.PlayToReceiver.prototype.onsourcechangerequested;
 /** @type {function(?): void} */
Windows.Media.PlayTo.PlayToReceiver.prototype.onstoprequested;
 /** @type {function(?): void} */
Windows.Media.PlayTo.PlayToReceiver.prototype.ontimeupdaterequested;
 /** @type {function(?): void} */
Windows.Media.PlayTo.PlayToReceiver.prototype.onvolumechangerequested;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.PlayTo.PlayToReceiver.prototype.properties;
 /** @type {boolean} */
Windows.Media.PlayTo.PlayToReceiver.prototype.supportsAudio;
 /** @type {boolean} */
Windows.Media.PlayTo.PlayToReceiver.prototype.supportsImage;
 /** @type {boolean} */
Windows.Media.PlayTo.PlayToReceiver.prototype.supportsVideo;

/**
 * Notifies the Play To receiver that the duration of the audio or video playback has changed.
 * @param {number} duration The new duration of the audio or video media.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.notifyDurationChange = function(duration) {};

/**
 * Notifies the Play To receiver that the audio or video playback has ended.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.notifyEnded = function() {};

/**
 * Notifies the Play To receiver that an error has occurred in displaying or playing the media.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.notifyError = function() {};

/**
 * Notifies the Play To receiver that metadata for the media has finished loading.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.notifyLoadedMetadata = function() {};

/**
 * Notifies the Play To receiver that the audio or video playback has been paused.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.notifyPaused = function() {};

/**
 * Notifies the Play To receiver that the audio or video playback has started.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.notifyPlaying = function() {};

/**
 * Notifies the Play To receiver that the rate of the audio or video playback has changed.
 * @param {number} rate The new value of the playback rate.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.notifyRateChange = function(rate) {};

/**
 * Notifies the Play To receiver that the audio or video playback element has started at a new playback location.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.notifySeeked = function() {};

/**
 * Notifies the Play To receiver that the audio or video playback element is seeking a new playback location.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.notifySeeking = function() {};

/**
 * Notifies the Play To receiver that the audio or video playback has stopped.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.notifyStopped = function() {};

/**
 * Notifies the Play To receiver that the time location of the audio or video playback has changed.
 * @param {number} currentTime The new time location of the playback.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.notifyTimeUpdate = function(currentTime) {};

/**
 * Notifies the Play To receiver that the volume of the audio or video playback has changed.
 * @param {number} volume The new value for the volume.
 * @param {boolean} mute True if the volume was muted; otherwise false.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.notifyVolumeChange = function(volume, mute) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.removeEventListener = function(type, listener) {};

/**
 * Start receiving Play To commands.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous handler that's called when the start operation is complete.
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.startAsync = function() {};

/**
 * Stop receiving Play To commands.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous handler that's called when the stop operation is complete.
 */
Windows.Media.PlayTo.PlayToReceiver.prototype.stopAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.PlayToSource = function() {};
 /** @type {!Windows.Media.PlayTo.PlayToConnection} */
Windows.Media.PlayTo.PlayToSource.prototype.connection;
 /** @type {!Windows.Media.PlayTo.PlayToSource} */
Windows.Media.PlayTo.PlayToSource.prototype.next;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.PlayTo.PlayToSource.prototype.preferredSourceUri;

/**
 * Connects the next Play To source element to the Play To target.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToSource.prototype.playNext = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.PlayToSourceDeferral = function() {};

/**
 * Ends the deferral.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToSourceDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.PlayToSourceRequest = function() {};
 /** @type {!Date} */
Windows.Media.PlayTo.PlayToSourceRequest.prototype.deadline;

/**
 * Displays an error message in the Play To UI.
 * @param {string} errorString The error message to display in the Play To UI.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToSourceRequest.prototype.displayErrorString = function(errorString) {};

/**
 * Defers connecting a media source to a Play To target.
 * @return {!Windows.Media.PlayTo.PlayToSourceDeferral} A deferral object that you can use to identify when the deferral is complete.
 */
Windows.Media.PlayTo.PlayToSourceRequest.prototype.getDeferral = function() {};

/**
 * Sets the source element to connect to the Play To target.
 * @param {!Windows.Media.PlayTo.PlayToSource} value The source element to connect to the Play To target.
 * @return {void}
 */
Windows.Media.PlayTo.PlayToSourceRequest.prototype.setSource = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.PlayToSourceRequestedEventArgs = function() {};
 /** @type {!Windows.Media.PlayTo.PlayToSourceRequest} */
Windows.Media.PlayTo.PlayToSourceRequestedEventArgs.prototype.sourceRequest;
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.PlayToSourceSelectedEventArgs = function() {};
 /** @type {string} */
Windows.Media.PlayTo.PlayToSourceSelectedEventArgs.prototype.friendlyName;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamWithContentType} */
Windows.Media.PlayTo.PlayToSourceSelectedEventArgs.prototype.icon;
 /** @type {boolean} */
Windows.Media.PlayTo.PlayToSourceSelectedEventArgs.prototype.supportsAudio;
 /** @type {boolean} */
Windows.Media.PlayTo.PlayToSourceSelectedEventArgs.prototype.supportsImage;
 /** @type {boolean} */
Windows.Media.PlayTo.PlayToSourceSelectedEventArgs.prototype.supportsVideo;
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs = function() {};
 /** @type {number} */
Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs.prototype.rate;
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.SourceChangeRequestedEventArgs = function() {};
 /** @type {string} */
Windows.Media.PlayTo.SourceChangeRequestedEventArgs.prototype.album;
 /** @type {string} */
Windows.Media.PlayTo.SourceChangeRequestedEventArgs.prototype.author;
 /** @type {!Date} */
Windows.Media.PlayTo.SourceChangeRequestedEventArgs.prototype.date;
 /** @type {string} */
Windows.Media.PlayTo.SourceChangeRequestedEventArgs.prototype.description;
 /** @type {string} */
Windows.Media.PlayTo.SourceChangeRequestedEventArgs.prototype.genre;
 /** @type {!Windows.Foundation.Collections.IMapView<string, ?>} */
Windows.Media.PlayTo.SourceChangeRequestedEventArgs.prototype.properties;
 /** @type {number} */
Windows.Media.PlayTo.SourceChangeRequestedEventArgs.prototype.rating;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamWithContentType} */
Windows.Media.PlayTo.SourceChangeRequestedEventArgs.prototype.stream;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.Media.PlayTo.SourceChangeRequestedEventArgs.prototype.thumbnail;
 /** @type {string} */
Windows.Media.PlayTo.SourceChangeRequestedEventArgs.prototype.title;
/**
 * @constructor
 * @struct
 */
Windows.Media.PlayTo.VolumeChangeRequestedEventArgs = function() {};
 /** @type {number} */
Windows.Media.PlayTo.VolumeChangeRequestedEventArgs.prototype.volume;
/** @const */
Windows.Media.Playback = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Playback.BackgroundMediaPlayer = function() {};
 /** @type {!Windows.Media.Playback.MediaPlayer} */
Windows.Media.Playback.BackgroundMediaPlayer.current;
 /** @type {function(?): void} */
Windows.Media.Playback.BackgroundMediaPlayer.onmessagereceivedfrombackground;
 /** @type {function(?): void} */
Windows.Media.Playback.BackgroundMediaPlayer.onmessagereceivedfromforeground;

/**
 * Returns a Boolean value indicating if other media is currently playing on the device.
 * @return {boolean} Boolean value indicating if other media is currently playing on the device.
 */
Windows.Media.Playback.BackgroundMediaPlayer.isMediaPlaying = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Playback.BackgroundMediaPlayer.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Playback.BackgroundMediaPlayer.removeEventListener = function(type, listener) {};

/**
 * Sends a message to the background media player.
 * @param {!Windows.Foundation.Collections.ValueSet} value Set of values representing the message.
 * @return {void}
 */
Windows.Media.Playback.BackgroundMediaPlayer.sendMessageToBackground = function(value) {};

/**
 * Sends a message to the foreground task.
 * @param {!Windows.Foundation.Collections.ValueSet} value Set of values representing the message.
 * @return {void}
 */
Windows.Media.Playback.BackgroundMediaPlayer.sendMessageToForeground = function(value) {};

/**
 * Shuts down the current background media player.
 * @return {void}
 */
Windows.Media.Playback.BackgroundMediaPlayer.shutdown = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Playback.CurrentMediaPlaybackItemChangedEventArgs = function() {};
 /** @type {!Windows.Media.Playback.MediaPlaybackItem} */
Windows.Media.Playback.CurrentMediaPlaybackItemChangedEventArgs.prototype.newItem;
 /** @type {!Windows.Media.Playback.MediaPlaybackItem} */
Windows.Media.Playback.CurrentMediaPlaybackItemChangedEventArgs.prototype.oldItem;
/**
 * @constructor
 * @struct
 */
Windows.Media.Playback.MediaPlaybackAudioTrackList = function() {};
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlaybackAudioTrackList.prototype.onselectedindexchanged;
 /** @type {number} */
Windows.Media.Playback.MediaPlaybackAudioTrackList.prototype.selectedIndex;
 /** @type {number} */
Windows.Media.Playback.MediaPlaybackAudioTrackList.prototype.size;

/**
 * Returns an iterator that iterates over the items in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Media.Core.AudioTrack>} The iterator.
 */
Windows.Media.Playback.MediaPlaybackAudioTrackList.prototype.first = function() {};

/**
 * Returns the audio track at the specified index.
 * @param {number} index The zero-based index of the audio track.
 * @return {!Windows.Media.Core.AudioTrack} The audio track at the specified index.
 */
Windows.Media.Playback.MediaPlaybackAudioTrackList.prototype.getAt = function(index) {};

/**
 * Retrieves the audio tracks that start at the specified index in the list.
 * @param {number} startIndex The zero-based index of the start of the audio tracks in the list.
 * @return {{items: !Windows.Media.Core.AudioTrack, returnValue: number}}
 */
Windows.Media.Playback.MediaPlaybackAudioTrackList.prototype.getMany = function(startIndex) {};

/**
 * Retrieves the index of a specified audio track in the list.
 * @param {!Windows.Media.Core.AudioTrack} value_or_searchElement The audio track to find in the vector view.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Media.Playback.MediaPlaybackAudioTrackList.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Playback.MediaPlaybackAudioTrackList.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Playback.MediaPlaybackAudioTrackList.prototype.removeEventListener = function(type, listener) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the MediaPlaybackItem class.
 * @param {!Windows.Media.Core.MediaSource} source The media source from which the MediaPlaybackItem is created.
 */
Windows.Media.Playback.MediaPlaybackItem = function(source) {};
 /** @type {?} */
Windows.Media.Playback.MediaPlaybackItem.findFromMediaSource;
 /** @type {!Windows.Media.Playback.MediaPlaybackAudioTrackList} */
Windows.Media.Playback.MediaPlaybackItem.prototype.audioTracks;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlaybackItem.prototype.onaudiotrackschanged;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlaybackItem.prototype.ontimedmetadatatrackschanged;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlaybackItem.prototype.onvideotrackschanged;
 /** @type {!Windows.Media.Core.MediaSource} */
Windows.Media.Playback.MediaPlaybackItem.prototype.source;
 /** @type {!Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList} */
Windows.Media.Playback.MediaPlaybackItem.prototype.timedMetadataTracks;
 /** @type {!Windows.Media.Playback.MediaPlaybackVideoTrackList} */
Windows.Media.Playback.MediaPlaybackItem.prototype.videoTracks;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Playback.MediaPlaybackItem.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Playback.MediaPlaybackItem.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Playback.MediaPlaybackItemError = function() {};
 /** @type {Windows.Media.Playback.MediaPlaybackItemErrorCode} */
Windows.Media.Playback.MediaPlaybackItemError.prototype.errorCode;
 /** @type {!Windows.WinRTError} */
Windows.Media.Playback.MediaPlaybackItemError.prototype.extendedError;

/** @const */
Windows.Media.Playback.MediaPlaybackItemErrorCode = {};
/** @const {number} */
Windows.Media.Playback.MediaPlaybackItemErrorCode.none;
/** @const {number} */
Windows.Media.Playback.MediaPlaybackItemErrorCode.aborted;
/** @const {number} */
Windows.Media.Playback.MediaPlaybackItemErrorCode.networkError;
/** @const {number} */
Windows.Media.Playback.MediaPlaybackItemErrorCode.decodeError;
/** @const {number} */
Windows.Media.Playback.MediaPlaybackItemErrorCode.sourceNotSupportedError;
/** @const {number} */
Windows.Media.Playback.MediaPlaybackItemErrorCode.encryptionError;
/**
 * @constructor
 * @struct
 */
Windows.Media.Playback.MediaPlaybackItemFailedEventArgs = function() {};
 /** @type {!Windows.Media.Playback.MediaPlaybackItemError} */
Windows.Media.Playback.MediaPlaybackItemFailedEventArgs.prototype.error;
 /** @type {!Windows.Media.Playback.MediaPlaybackItem} */
Windows.Media.Playback.MediaPlaybackItemFailedEventArgs.prototype.item;
/**
 * @constructor
 * @struct
 */
Windows.Media.Playback.MediaPlaybackItemOpenedEventArgs = function() {};
 /** @type {!Windows.Media.Playback.MediaPlaybackItem} */
Windows.Media.Playback.MediaPlaybackItemOpenedEventArgs.prototype.item;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the MediaPlaybackList class.
 */
Windows.Media.Playback.MediaPlaybackList = function() {};
 /** @type {boolean} */
Windows.Media.Playback.MediaPlaybackList.prototype.autoRepeatEnabled;
 /** @type {!Windows.Media.Playback.MediaPlaybackItem} */
Windows.Media.Playback.MediaPlaybackList.prototype.currentItem;
 /** @type {number} */
Windows.Media.Playback.MediaPlaybackList.prototype.currentItemIndex;
 /** @type {!Windows.Foundation.Collections.IObservableVector<!Windows.Media.Playback.MediaPlaybackItem>} */
Windows.Media.Playback.MediaPlaybackList.prototype.items;
 /** @type {number} */
Windows.Media.Playback.MediaPlaybackList.prototype.maxPrefetchTime;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlaybackList.prototype.oncurrentitemchanged;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlaybackList.prototype.onitemfailed;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlaybackList.prototype.onitemopened;
 /** @type {boolean} */
Windows.Media.Playback.MediaPlaybackList.prototype.shuffleEnabled;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.Playback.MediaPlaybackItem>} */
Windows.Media.Playback.MediaPlaybackList.prototype.shuffledItems;
 /** @type {!Windows.Media.Playback.MediaPlaybackItem} */
Windows.Media.Playback.MediaPlaybackList.prototype.startingItem;

/**
 * Changes the current item of the MediaPlaybackList to the next item in the list.
 * @return {!Windows.Media.Playback.MediaPlaybackItem} The new current MediaPlaybackItem .
 */
Windows.Media.Playback.MediaPlaybackList.prototype.moveNext = function() {};

/**
 * Changes the current item of the MediaPlaybackList to the previous item in the list.
 * @return {!Windows.Media.Playback.MediaPlaybackItem} The new current MediaPlaybackItem .
 */
Windows.Media.Playback.MediaPlaybackList.prototype.movePrevious = function() {};

/**
 * Changes the current item of the MediaPlaybackList to the item with the specified index.
 * @param {number} itemIndex The index of the item to make current.
 * @return {!Windows.Media.Playback.MediaPlaybackItem} The new current MediaPlaybackItem .
 */
Windows.Media.Playback.MediaPlaybackList.prototype.moveTo = function(itemIndex) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Playback.MediaPlaybackList.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Playback.MediaPlaybackList.prototype.removeEventListener = function(type, listener) {};

/**
 * Sets the list of MediaPlaybackItem objects that will be played in shuffle mode, in the order in which they will be played.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Media.Playback.MediaPlaybackItem>} value The list of MediaPlaybackItem objects that will be played in shuffle mode.
 * @return {void}
 */
Windows.Media.Playback.MediaPlaybackList.prototype.setShuffledItems = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList = function() {};
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList.prototype.onpresentationmodechanged;
 /** @type {number} */
Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList.prototype.size;

/**
 * Returns an iterator that iterates over the items in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Media.Core.TimedMetadataTrack>} The iterator.
 */
Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList.prototype.first = function() {};

/**
 * Returns the timed metadata track at the specified index.
 * @param {number} index The zero-based index of the timed metadata track.
 * @return {!Windows.Media.Core.TimedMetadataTrack} The timed metadata track at the specified index.
 */
Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList.prototype.getAt = function(index) {};

/**
 * Retrieves the timed metadata tracks that start at the specified index in the list.
 * @param {number} startIndex The zero-based index of the start of the timed metadata tracks in the list.
 * @return {{items: !Windows.Media.Core.TimedMetadataTrack, returnValue: number}}
 */
Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList.prototype.getMany = function(startIndex) {};

/**
 * Gets the presentation mode of the timed metadata track with the specified index.
 * @param {number} index The index of the timed metadata track for which the presentation mode is queried.
 * @return {Windows.Media.Playback.TimedMetadataTrackPresentationMode} The presentation mode.
 */
Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList.prototype.getPresentationMode = function(index) {};

/**
 * Retrieves the index of a specified timed metadata track in the list.
 * @param {!Windows.Media.Core.TimedMetadataTrack} value_or_searchElement The timed metadata track to find in the vector view.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList.prototype.removeEventListener = function(type, listener) {};

/**
 * Sets the presentation mode of the timed metadata track with the specified index.
 * @param {number} index The index of the timed metadata track for which the presentation mode is set.
 * @param {Windows.Media.Playback.TimedMetadataTrackPresentationMode} value The presentation mode to set.
 * @return {void}
 */
Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList.prototype.setPresentationMode = function(index, value) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Playback.MediaPlaybackVideoTrackList = function() {};
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlaybackVideoTrackList.prototype.onselectedindexchanged;
 /** @type {number} */
Windows.Media.Playback.MediaPlaybackVideoTrackList.prototype.selectedIndex;
 /** @type {number} */
Windows.Media.Playback.MediaPlaybackVideoTrackList.prototype.size;

/**
 * Returns an iterator that iterates over the items in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Media.Core.VideoTrack>} The iterator.
 */
Windows.Media.Playback.MediaPlaybackVideoTrackList.prototype.first = function() {};

/**
 * Returns the video track at the specified index.
 * @param {number} index The zero-based index of the video track.
 * @return {!Windows.Media.Core.VideoTrack} The video track at the specified index.
 */
Windows.Media.Playback.MediaPlaybackVideoTrackList.prototype.getAt = function(index) {};

/**
 * Retrieves the video tracks that start at the specified index in the list.
 * @param {number} startIndex The zero-based index of the start of the video tracks in the list.
 * @return {{items: !Windows.Media.Core.VideoTrack, returnValue: number}}
 */
Windows.Media.Playback.MediaPlaybackVideoTrackList.prototype.getMany = function(startIndex) {};

/**
 * Retrieves the index of a specified video track in the list.
 * @param {!Windows.Media.Core.VideoTrack} value_or_searchElement The video track to find in the vector view.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Media.Playback.MediaPlaybackVideoTrackList.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Playback.MediaPlaybackVideoTrackList.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Playback.MediaPlaybackVideoTrackList.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Playback.MediaPlayer = function() {};
 /** @type {Windows.Media.Playback.MediaPlayerAudioCategory} */
Windows.Media.Playback.MediaPlayer.prototype.audioCategory;
 /** @type {Windows.Media.Playback.MediaPlayerAudioDeviceType} */
Windows.Media.Playback.MediaPlayer.prototype.audioDeviceType;
 /** @type {boolean} */
Windows.Media.Playback.MediaPlayer.prototype.autoPlay;
 /** @type {number} */
Windows.Media.Playback.MediaPlayer.prototype.bufferingProgress;
 /** @type {boolean} */
Windows.Media.Playback.MediaPlayer.prototype.canPause;
 /** @type {boolean} */
Windows.Media.Playback.MediaPlayer.prototype.canSeek;
 /** @type {Windows.Media.Playback.MediaPlayerState} */
Windows.Media.Playback.MediaPlayer.prototype.currentState;
 /** @type {boolean} */
Windows.Media.Playback.MediaPlayer.prototype.isLoopingEnabled;
 /** @type {boolean} */
Windows.Media.Playback.MediaPlayer.prototype.isMuted;
 /** @type {boolean} */
Windows.Media.Playback.MediaPlayer.prototype.isProtected;
 /** @type {number} */
Windows.Media.Playback.MediaPlayer.prototype.naturalDuration;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlayer.prototype.onbufferingended;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlayer.prototype.onbufferingstarted;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlayer.prototype.oncurrentstatechanged;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlayer.prototype.onmediaended;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlayer.prototype.onmediafailed;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlayer.prototype.onmediaopened;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlayer.prototype.onmediaplayerratechanged;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlayer.prototype.onplaybackmediamarkerreached;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlayer.prototype.onseekcompleted;
 /** @type {function(?): void} */
Windows.Media.Playback.MediaPlayer.prototype.onvolumechanged;
 /** @type {!Windows.Media.Playback.PlaybackMediaMarkerSequence} */
Windows.Media.Playback.MediaPlayer.prototype.playbackMediaMarkers;
 /** @type {number} */
Windows.Media.Playback.MediaPlayer.prototype.playbackRate;
 /** @type {number} */
Windows.Media.Playback.MediaPlayer.prototype.position;
 /** @type {!Windows.Media.Protection.MediaProtectionManager} */
Windows.Media.Playback.MediaPlayer.prototype.protectionManager;
 /** @type {!Windows.Media.Playback.IMediaPlaybackSource} */
Windows.Media.Playback.MediaPlayer.prototype.source;
 /** @type {!Windows.Media.SystemMediaTransportControls} */
Windows.Media.Playback.MediaPlayer.prototype.systemMediaTransportControls;
 /** @type {number} */
Windows.Media.Playback.MediaPlayer.prototype.volume;

/**
 * Adds an audio effect to the playback stream of the MediaPlayer .
 * @param {string} activatableClassId The activatable class ID of the audio effect to add to the playback stream.
 * @param {boolean} effectOptional A value indicating whether the effect is optional.
 * @param {!Windows.Foundation.Collections.IPropertySet} configuration A property set containing configuration settings for the specified audio effect.
 * @return {void}
 */
Windows.Media.Playback.MediaPlayer.prototype.addAudioEffect = function(activatableClassId, effectOptional, configuration) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Playback.MediaPlayer.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Playback.MediaPlayer.prototype.removeEventListener = function(type, listener) {};

/**
 * Pauses media playback.
 * @return {void}
 */
Windows.Media.Playback.MediaPlayer.prototype.pause = function() {};

/**
 * Starts media playback.
 * @return {void}
 */
Windows.Media.Playback.MediaPlayer.prototype.play = function() {};

/**
 * Removes all effects from the playback stream of the MediaPlayer .
 * @return {void}
 */
Windows.Media.Playback.MediaPlayer.prototype.removeAllEffects = function() {};

/**
 * Set the media source to a file.
 * @param {!Windows.Storage.IStorageFile} file The media source file.
 * @return {void}
 */
Windows.Media.Playback.MediaPlayer.prototype.setFileSource = function(file) {};

/**
 * Sets the media source for playback.
 * @param {!Windows.Media.Core.IMediaSource} source The media source for playback.
 * @return {void}
 */
Windows.Media.Playback.MediaPlayer.prototype.setMediaSource = function(source) {};

/**
 * Sets the media source to a stream.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} stream The media source stream.
 * @return {void}
 */
Windows.Media.Playback.MediaPlayer.prototype.setStreamSource = function(stream) {};

/**
 * Sets the path to the media.
 * @param {!Windows.Foundation.Uri} value The path to the media.
 * @return {void}
 */
Windows.Media.Playback.MediaPlayer.prototype.setUriSource = function(value) {};

/** @const */
Windows.Media.Playback.MediaPlayerAudioCategory = {};
/** @const {number} */
Windows.Media.Playback.MediaPlayerAudioCategory.other;
/** @const {number} */
Windows.Media.Playback.MediaPlayerAudioCategory.communications;
/** @const {number} */
Windows.Media.Playback.MediaPlayerAudioCategory.alerts;
/** @const {number} */
Windows.Media.Playback.MediaPlayerAudioCategory.soundEffects;
/** @const {number} */
Windows.Media.Playback.MediaPlayerAudioCategory.gameEffects;
/** @const {number} */
Windows.Media.Playback.MediaPlayerAudioCategory.gameMedia;
/** @const {number} */
Windows.Media.Playback.MediaPlayerAudioCategory.gameChat;
/** @const {number} */
Windows.Media.Playback.MediaPlayerAudioCategory.speech;
/** @const {number} */
Windows.Media.Playback.MediaPlayerAudioCategory.movie;
/** @const {number} */
Windows.Media.Playback.MediaPlayerAudioCategory.media;

/** @const */
Windows.Media.Playback.MediaPlayerAudioDeviceType = {};
/** @const {number} */
Windows.Media.Playback.MediaPlayerAudioDeviceType.console;
/** @const {number} */
Windows.Media.Playback.MediaPlayerAudioDeviceType.multimedia;
/** @const {number} */
Windows.Media.Playback.MediaPlayerAudioDeviceType.communications;
/**
 * @constructor
 * @struct
 */
Windows.Media.Playback.MediaPlayerDataReceivedEventArgs = function() {};
 /** @type {!Windows.Foundation.Collections.IMap<string, string>} */
Windows.Media.Playback.MediaPlayerDataReceivedEventArgs.prototype.data;

/** @const */
Windows.Media.Playback.MediaPlayerError = {};
/** @const {number} */
Windows.Media.Playback.MediaPlayerError.unknown;
/** @const {number} */
Windows.Media.Playback.MediaPlayerError.aborted;
/** @const {number} */
Windows.Media.Playback.MediaPlayerError.networkError;
/** @const {number} */
Windows.Media.Playback.MediaPlayerError.decodingError;
/** @const {number} */
Windows.Media.Playback.MediaPlayerError.sourceNotSupported;
/**
 * @constructor
 * @struct
 */
Windows.Media.Playback.MediaPlayerFailedEventArgs = function() {};
 /** @type {Windows.Media.Playback.MediaPlayerError} */
Windows.Media.Playback.MediaPlayerFailedEventArgs.prototype.error;
 /** @type {string} */
Windows.Media.Playback.MediaPlayerFailedEventArgs.prototype.errorMessage;
 /** @type {!Windows.WinRTError} */
Windows.Media.Playback.MediaPlayerFailedEventArgs.prototype.extendedErrorCode;
/**
 * @constructor
 * @struct
 */
Windows.Media.Playback.MediaPlayerRateChangedEventArgs = function() {};
 /** @type {number} */
Windows.Media.Playback.MediaPlayerRateChangedEventArgs.prototype.newRate;

/** @const */
Windows.Media.Playback.MediaPlayerState = {};
/** @const {number} */
Windows.Media.Playback.MediaPlayerState.closed;
/** @const {number} */
Windows.Media.Playback.MediaPlayerState.opening;
/** @const {number} */
Windows.Media.Playback.MediaPlayerState.buffering;
/** @const {number} */
Windows.Media.Playback.MediaPlayerState.playing;
/** @const {number} */
Windows.Media.Playback.MediaPlayerState.paused;
/** @const {number} */
Windows.Media.Playback.MediaPlayerState.stopped;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlaybackMediaMarker class with the specified offset into the media timeline, type string, and text.
 * Initializes a new instance of the PlaybackMediaMarker class with the specified offset into the media timeline.
 * @param {number} value The media marker's offset into the media timeline.
 * @param {string=} mediaMarketType The type of the media marker.
 * @param {string=} text The text of the media marker.
 */
Windows.Media.Playback.PlaybackMediaMarker = function(value, mediaMarketType, text) {};
 /** @type {string} */
Windows.Media.Playback.PlaybackMediaMarker.prototype.mediaMarkerType;
 /** @type {string} */
Windows.Media.Playback.PlaybackMediaMarker.prototype.text;
 /** @type {number} */
Windows.Media.Playback.PlaybackMediaMarker.prototype.time;
/**
 * @constructor
 * @struct
 */
Windows.Media.Playback.PlaybackMediaMarkerReachedEventArgs = function() {};
 /** @type {!Windows.Media.Playback.PlaybackMediaMarker} */
Windows.Media.Playback.PlaybackMediaMarkerReachedEventArgs.prototype.playbackMediaMarker;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlaybackMediaMarkerSequence class.
 */
Windows.Media.Playback.PlaybackMediaMarkerSequence = function() {};
 /** @type {number} */
Windows.Media.Playback.PlaybackMediaMarkerSequence.prototype.size;

/**
 * Removes all elements from the sequence.
 * @return {void}
 */
Windows.Media.Playback.PlaybackMediaMarkerSequence.prototype.clear = function() {};

/**
 * Gets an IIterator pointing at the first PlaybackMediaMarker in the sequence.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Media.Playback.PlaybackMediaMarker>} Iterator pointing at the first media marker in the sequence.
 */
Windows.Media.Playback.PlaybackMediaMarkerSequence.prototype.first = function() {};

/**
 * Adds a PlaybackMediaMarker to the sequence in it's ordered position.
 * @param {!Windows.Media.Playback.PlaybackMediaMarker} value The media marker to insert into the sequence.
 * @return {void}
 */
Windows.Media.Playback.PlaybackMediaMarkerSequence.prototype.insert = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Playback.TimedMetadataPresentationModeChangedEventArgs = function() {};
 /** @type {Windows.Media.Playback.TimedMetadataTrackPresentationMode} */
Windows.Media.Playback.TimedMetadataPresentationModeChangedEventArgs.prototype.newPresentationMode;
 /** @type {Windows.Media.Playback.TimedMetadataTrackPresentationMode} */
Windows.Media.Playback.TimedMetadataPresentationModeChangedEventArgs.prototype.oldPresentationMode;
 /** @type {!Windows.Media.Core.TimedMetadataTrack} */
Windows.Media.Playback.TimedMetadataPresentationModeChangedEventArgs.prototype.track;

/** @const */
Windows.Media.Playback.TimedMetadataTrackPresentationMode = {};
/** @const {number} */
Windows.Media.Playback.TimedMetadataTrackPresentationMode.disabled;
/** @const {number} */
Windows.Media.Playback.TimedMetadataTrackPresentationMode.hidden;
/** @const {number} */
Windows.Media.Playback.TimedMetadataTrackPresentationMode.applicationPresented;
/** @const {number} */
Windows.Media.Playback.TimedMetadataTrackPresentationMode.platformPresented;
 /** @type {?} */
Windows.Media.Playback.ateChangeRequestedEventArgs;
 /** @type {?} */
Windows.Media.Playback.ositionChangeRequestedEventArgs;
/**
 * @record
 * @struct
 */
Windows.Media.Playback.IMediaPlaybackSource = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.PlaybackPositionChangeRequestedEventArgs = function() {};
 /** @type {number} */
Windows.Media.PlaybackPositionChangeRequestedEventArgs.prototype.requestedPlaybackPosition;
/**
 * @constructor
 * @struct
 */
Windows.Media.PlaybackRateChangeRequestedEventArgs = function() {};
 /** @type {number} */
Windows.Media.PlaybackRateChangeRequestedEventArgs.prototype.requestedPlaybackRate;
/** @const */
Windows.Media.Playlists = {};

/**
 * @constructor
 * @struct
 * Creates a new instance of a Playlist object.
 */
Windows.Media.Playlists.Playlist = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Storage.StorageFile>} */
Windows.Media.Playlists.Playlist.prototype.files;

/**
 * Asynchronously loads files into a playlist.
 * @param {!Windows.Storage.IStorageFile} file Represents the files to load.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Playlists.Playlist, !Windows.Foundation.IAsyncOperation<!Windows.Media.Playlists.Playlist>>} Represents the asynchronous operation for loading the playlist. The GetResults method of this IAsyncOperation object returns the playlist.
 */
Windows.Media.Playlists.Playlist.loadAsync = function(file) {};

/**
 * Asynchronously saves the playlist to a specified file and folder, in a specified format.
 * Asynchronously saves the playlist to a specified file and folder.
 * @param {!Windows.Storage.IStorageFolder} saveLocation The folder in which to save the playlist.
 * @param {string} desiredName The name of the playlist to save.
 * @param {Windows.Storage.NameCollisionOption} option The action to take if the playlist is saved to an existing file. One of the values of the NameCollisionOption enumeration.
 * @param {Windows.Media.Playlists.PlaylistFormat=} playlistFormat The playlist format. One of the values of the PlaylistFormat enumeration.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} Represents the asynchronous operation to save the playlist to a specified file and folder.
 */
Windows.Media.Playlists.Playlist.prototype.saveAsAsync = function(saveLocation, desiredName, option, playlistFormat) {};

/**
 * Asynchronously saves the playlist.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Represents the asynchronous action to save the playlist.
 */
Windows.Media.Playlists.Playlist.prototype.saveAsync = function() {};

/** @const */
Windows.Media.Playlists.PlaylistFormat = {};
/** @const {number} */
Windows.Media.Playlists.PlaylistFormat.windowsMedia;
/** @const {number} */
Windows.Media.Playlists.PlaylistFormat.zune;
/** @const {number} */
Windows.Media.Playlists.PlaylistFormat.m3u;
/** @const */
Windows.Media.Protection = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.ComponentLoadFailedEventArgs = function() {};
 /** @type {!Windows.Media.Protection.MediaProtectionServiceCompletion} */
Windows.Media.Protection.ComponentLoadFailedEventArgs.prototype.completion;
 /** @type {!Windows.Media.Protection.RevocationAndRenewalInformation} */
Windows.Media.Protection.ComponentLoadFailedEventArgs.prototype.information;
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.ComponentRenewal = function() {};

/**
 * Initiates updating of critical content protection components after prompting the user.
 * @param {!Windows.Media.Protection.RevocationAndRenewalInformation} information Revocation and renewal information.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Media.Protection.RenewalStatus, !Windows.Foundation.IAsyncOperationWithProgress<Windows.Media.Protection.RenewalStatus, number>>} An object that is used to control the asynchronous operation.
 */
Windows.Media.Protection.ComponentRenewal.renewSystemComponentsAsync = function(information) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the MediaProtectionManager class.
 */
Windows.Media.Protection.MediaProtectionManager = function() {};
 /** @type {function(?): void} */
Windows.Media.Protection.MediaProtectionManager.prototype.oncomponentloadfailed;
 /** @type {function(!Windows.WinRTEvent<!Windows.Media.Protection.MediaProtectionManager>): void} */
Windows.Media.Protection.MediaProtectionManager.prototype.onrebootneeded;
 /** @type {function(?): void} */
Windows.Media.Protection.MediaProtectionManager.prototype.onservicerequested;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Protection.MediaProtectionManager.prototype.properties;

/**
 * @param {string} type
 * @param {function(?): void|function(!Windows.WinRTEvent<!Windows.Media.Protection.MediaProtectionManager>): void} listener
 * @return {void}
 */
Windows.Media.Protection.MediaProtectionManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void|function(!Windows.WinRTEvent<!Windows.Media.Protection.MediaProtectionManager>): void} listener
 * @return {void}
 */
Windows.Media.Protection.MediaProtectionManager.prototype.removeEventListener = function(type, listener) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the MediaProtectionPMPServer class with the specified properties.
 * @param {!Windows.Foundation.Collections.IPropertySet} pProperties The set of properties used to initialize the server.
 */
Windows.Media.Protection.MediaProtectionPMPServer = function(pProperties) {};
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Protection.MediaProtectionPMPServer.prototype.properties;
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.MediaProtectionServiceCompletion = function() {};

/**
 * Indicates whether a protection service has completed successfully.
 * @param {boolean} success Indicates the successful completion of a protection service.
 * @return {void}
 */
Windows.Media.Protection.MediaProtectionServiceCompletion.prototype.complete = function(success) {};
/** @const */
Windows.Media.Protection.PlayReady = {};

/** @const */
Windows.Media.Protection.PlayReady.NDCertificateFeature = {};
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateFeature.transmitter;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateFeature.receiver;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateFeature.sharedCertificate;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateFeature.secureClock;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateFeature.antiRollBackClock;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateFeature.crls;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateFeature.playReady3Features;

/** @const */
Windows.Media.Protection.PlayReady.NDCertificatePlatformID = {};
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificatePlatformID.windows;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificatePlatformID.osx;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificatePlatformID.windowsOnARM;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificatePlatformID.windowsMobile7;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificatePlatformID.iOSOnARM;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificatePlatformID.xboxOnPPC;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificatePlatformID.windowsPhone8OnARM;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificatePlatformID.windowsPhone8OnX86;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificatePlatformID.xboxOne;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificatePlatformID.androidOnARM;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificatePlatformID.windowsPhone81OnARM;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificatePlatformID.windowsPhone81OnX86;

/** @const */
Windows.Media.Protection.PlayReady.NDCertificateType = {};
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateType.unknown;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateType.pc;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateType.device;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateType.domain;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateType.issuer;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateType.crlSigner;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateType.service;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateType.silverlight;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateType.application;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateType.metering;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateType.keyFileSigner;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateType.server;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDCertificateType.licenseSigner;

/**
 * @constructor
 * @struct
 * Creates a new instance of the NDClient class.
 * @param {!Windows.Media.Protection.PlayReady.INDDownloadEngine} downloadEngine The download engine used to stream protected media content from a transmitter.
 * @param {!Windows.Media.Protection.PlayReady.INDStreamParser} streamParser The stream parser used to parse data from a media stream.
 * @param {!Windows.Media.Protection.PlayReady.INDMessenger} pMessenger The messenger used to send messages between the PlayReady-ND receiver and transmitter.
 */
Windows.Media.Protection.PlayReady.NDClient = function(downloadEngine, streamParser, pMessenger) {};
 /** @type {function(?): void} */
Windows.Media.Protection.PlayReady.NDClient.prototype.onclosedcaptiondatareceived;
 /** @type {function(?): void} */
Windows.Media.Protection.PlayReady.NDClient.prototype.onlicensefetchcompleted;
 /** @type {function(?): void} */
Windows.Media.Protection.PlayReady.NDClient.prototype.onproximitydetectioncompleted;
 /** @type {function(?): void} */
Windows.Media.Protection.PlayReady.NDClient.prototype.onregistrationcompleted;
 /** @type {function(?): void} */
Windows.Media.Protection.PlayReady.NDClient.prototype.onreregistrationneeded;

/**
 * Closes the current playback session regardless of whether it is in the registration, proximity detection, license fetch, or play state.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.NDClient.prototype.close = function() {};

/**
 * Performs a license fetch between a client receiver and a transmitter.
 * @param {!Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor} licenseFetchDescriptor Descriptor for the license being fetched.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Protection.PlayReady.INDLicenseFetchResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Protection.PlayReady.INDLicenseFetchResult>>} The result of the asynchronous license fetch call.
 */
Windows.Media.Protection.PlayReady.NDClient.prototype.licenseFetchAsync = function(licenseFetchDescriptor) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Protection.PlayReady.NDClient.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Protection.PlayReady.NDClient.prototype.removeEventListener = function(type, listener) {};

/**
 * Performs a proximity detection and reregistration between a client receiver and a transmitter.
 * @param {!Windows.Media.Protection.PlayReady.INDCustomData} registrationCustomData Custom data for the registration request.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The result of the asynchronous reregistration call.
 */
Windows.Media.Protection.PlayReady.NDClient.prototype.reRegistrationAsync = function(registrationCustomData) {};

/**
 * Starts the registration, proximity detection, and license fetch procedures between a client receiver and a transmitter.
 * @param {!Windows.Foundation.Uri} contentUrl The URL of the streamed content.
 * @param {number} startAsyncOptions The asynchronous start options. See the NDStartAsyncOptions enumeration for a detailed description of these options.
 * @param {!Windows.Media.Protection.PlayReady.INDCustomData} registrationCustomData The custom data type identifier that is used for registration with the transmitter.
 * @param {!Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor} licenseFetchDescriptor The descriptor used for license fetching.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Protection.PlayReady.INDStartResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Protection.PlayReady.INDStartResult>>} The result of the asynchronous start call.
 */
Windows.Media.Protection.PlayReady.NDClient.prototype.startAsync = function(contentUrl, startAsyncOptions, registrationCustomData, licenseFetchDescriptor) {};

/** @const */
Windows.Media.Protection.PlayReady.NDClosedCaptionFormat = {};
/** @const {number} */
Windows.Media.Protection.PlayReady.NDClosedCaptionFormat.atsc;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDClosedCaptionFormat.scte20;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDClosedCaptionFormat.unknown;

/** @const */
Windows.Media.Protection.PlayReady.NDContentIDType = {};
/** @const {number} */
Windows.Media.Protection.PlayReady.NDContentIDType.keyID;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDContentIDType.playReadyObject;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDContentIDType.custom;

/**
 * @constructor
 * @struct
 * Creates a new instance of the NDCustomData class.
 * @param {!Array<number>} customDataTypeIDBytes The type identifier for the custom data. Only a type identifier that is exactly 16 bytes in size is supported.
 * @param {!Array<number>} customDataBytes The custom data.
 */
Windows.Media.Protection.PlayReady.NDCustomData = function(customDataTypeIDBytes, customDataBytes) {};
 /** @type {number} */
Windows.Media.Protection.PlayReady.NDCustomData.prototype.customData;
 /** @type {number} */
Windows.Media.Protection.PlayReady.NDCustomData.prototype.customDataTypeID;

/**
 * @constructor
 * @struct
 * Creates a new instance of the NDDownloadEngineNotifier class.
 */
Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier = function() {};

/**
 * Called by the download engine when a content identifier is received.
 * @param {!Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor} licenseFetchDescriptor The license from which the download engine receives the content identifier.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier.prototype.onContentIDReceived = function(licenseFetchDescriptor) {};

/**
 * Called by the download engine when it receives data.
 * @param {!Array<number>} dataBytes The byte array that holds the data.
 * @param {number} bytesReceived The number of bytes received from the data stream.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier.prototype.onDataReceived = function(dataBytes, bytesReceived) {};

/**
 * Called by the download engine when it reaches the end of a PlayReady-ND media stream.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier.prototype.onEndOfStream = function() {};

/**
 * Called by the download engine if an error occurs during downloading.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier.prototype.onNetworkError = function() {};

/**
 * Called by the download engine once a PlayReady object is received.
 * @param {!Array<number>} dataBytes The byte array that holds the PlayReady object.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier.prototype.onPlayReadyObjectReceived = function(dataBytes) {};

/**
 * Called by the download engine when a stream is opened.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier.prototype.onStreamOpened = function() {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the NDLicenseFetchDescriptor class.
 * @param {Windows.Media.Protection.PlayReady.NDContentIDType} contentIDType The type of the content identifier.
 * @param {!Array<number>} contentIDBytes The content identifier.
 * @param {!Windows.Media.Protection.PlayReady.INDCustomData} licenseFetchChallengeCustomData The license fetch challenge custom data.
 */
Windows.Media.Protection.PlayReady.NDLicenseFetchDescriptor = function(contentIDType, contentIDBytes, licenseFetchChallengeCustomData) {};
 /** @type {number} */
Windows.Media.Protection.PlayReady.NDLicenseFetchDescriptor.prototype.contentID;
 /** @type {Windows.Media.Protection.PlayReady.NDContentIDType} */
Windows.Media.Protection.PlayReady.NDLicenseFetchDescriptor.prototype.contentIDType;
 /** @type {!Windows.Media.Protection.PlayReady.INDCustomData} */
Windows.Media.Protection.PlayReady.NDLicenseFetchDescriptor.prototype.licenseFetchChallengeCustomData;

/** @const */
Windows.Media.Protection.PlayReady.NDMediaStreamType = {};
/** @const {number} */
Windows.Media.Protection.PlayReady.NDMediaStreamType.audio;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDMediaStreamType.video;

/** @const */
Windows.Media.Protection.PlayReady.NDProximityDetectionType = {};
/** @const {number} */
Windows.Media.Protection.PlayReady.NDProximityDetectionType.udp;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDProximityDetectionType.tcp;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDProximityDetectionType.transportAgnostic;

/** @const */
Windows.Media.Protection.PlayReady.NDStartAsyncOptions = {};
/** @const {number} */
Windows.Media.Protection.PlayReady.NDStartAsyncOptions.mutualAuthentication;
/** @const {number} */
Windows.Media.Protection.PlayReady.NDStartAsyncOptions.waitForLicenseDescriptor;

/**
 * @constructor
 * @struct
 * Creates a new instance of the NDStorageFileHelper class.
 */
Windows.Media.Protection.PlayReady.NDStorageFileHelper = function() {};

/**
 * Gets transmitter settings from the URLs associated with a StorageFile object if the URLs contain PlayReady-ND metadata.
 * @param {!Windows.Storage.IStorageFile} file A storage file object that a media server has discovered.
 * @return {!Windows.Foundation.Collections.IVector<string>} The transmitter settings found in the storage file.
 */
Windows.Media.Protection.PlayReady.NDStorageFileHelper.prototype.getFileURLs = function(file) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the NDStreamParserNotifier class.
 */
Windows.Media.Protection.PlayReady.NDStreamParserNotifier = function() {};

/**
 * Called by the stream parser when it requests a setup decryptor.
 * @param {!Windows.Media.Core.IMediaStreamDescriptor} descriptor The descriptor of the media stream being decrypted.
 * @param {string} keyID The key identifier used for decryption.
 * @param {!Array<number>} proBytes The data for the setup decryptor.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.NDStreamParserNotifier.prototype.onBeginSetupDecryptor = function(descriptor, keyID, proBytes) {};

/**
 * Called by a stream parser when it receives the content identifier.
 * @param {!Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor} licenseFetchDescriptor The license fetch descriptor containing the content identifier.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.NDStreamParserNotifier.prototype.onContentIDReceived = function(licenseFetchDescriptor) {};

/**
 * Called by the stream parser when the media stream descriptor is created.
 * @param {!Windows.Foundation.Collections.IVector<!Windows.Media.Core.AudioStreamDescriptor>} audioStreamDescriptors An array of audio stream descriptors that are part of the media stream descriptor.
 * @param {!Windows.Foundation.Collections.IVector<!Windows.Media.Core.VideoStreamDescriptor>} videoStreamDescriptors An array of video stream descriptors that are part of the media stream descriptor.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.NDStreamParserNotifier.prototype.onMediaStreamDescriptorCreated = function(audioStreamDescriptors, videoStreamDescriptors) {};

/**
 * Called when the stream parser parses a sample from the media stream.
 * @param {number} streamID The identifier for the media stream that is being parsed.
 * @param {Windows.Media.Protection.PlayReady.NDMediaStreamType} streamType The type of the media stream. This value can be Audio or Video.
 * @param {!Windows.Media.Core.MediaStreamSample} streamSample The array of stream samples.
 * @param {number} pts The presentation timestamp that indicates when to play the sample, in milliseconds. This value is relative to previous samples in the presentation. For example, if a given sample has a presentation time stamp of 1000 and some later sample has a presentation time stamp of 2000, the later sample occurs one second (1000ms) after the given sample.
 * @param {Windows.Media.Protection.PlayReady.NDClosedCaptionFormat} ccFormat The closed caption format. This value can be ATSC, SCTE20, or Unknown.
 * @param {!Array<number>} ccDataBytes An array that contains the closed caption data.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.NDStreamParserNotifier.prototype.onSampleParsed = function(streamID, streamType, streamSample, pts, ccFormat, ccDataBytes) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the NDTCPMessenger class.
 * @param {string} remoteHostName The IP address of the remote host that will receive messages. The format is either an IPv4 address in dotted-decimal notation or an IPv6 address in colon-hex notation.
 * @param {number} remoteHostPort The TCP port of the remote host that will receive messages.
 */
Windows.Media.Protection.PlayReady.NDTCPMessenger = function(remoteHostName, remoteHostPort) {};

/**
 * Sends the specified data in an asynchronous license fetch request message.
 * @param {!Array<number>} sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param {!Array<number>} challengeDataBytes The data for the challenge message.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Protection.PlayReady.INDSendResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Protection.PlayReady.INDSendResult>>} The result of the license fetch request.
 */
Windows.Media.Protection.PlayReady.NDTCPMessenger.prototype.sendLicenseFetchRequestAsync = function(sessionIDBytes, challengeDataBytes) {};

/**
 * Sends the specified data in an asynchronous proximity detection response message.
 * @param {Windows.Media.Protection.PlayReady.NDProximityDetectionType} pdType The type of proximity detection operation. This value can be UDP, TCP, or Transport-Agnostic.
 * @param {!Array<number>} transmitterChannelBytes The transmitter channel data.
 * @param {!Array<number>} sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param {!Array<number>} responseDataBytes The data for the response message.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Protection.PlayReady.INDSendResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Protection.PlayReady.INDSendResult>>} The result of the proximity detection response operation.
 */
Windows.Media.Protection.PlayReady.NDTCPMessenger.prototype.sendProximityDetectionResponseAsync = function(pdType, transmitterChannelBytes, sessionIDBytes, responseDataBytes) {};

/**
 * Sends the specified data in an asynchronous proximity detection start message.
 * @param {Windows.Media.Protection.PlayReady.NDProximityDetectionType} pdType The type of proximity detection operation. This value can be UDP, TCP, or Transport-Agnostic.
 * @param {!Array<number>} transmitterChannelBytes The transmitter channel data.
 * @param {!Array<number>} sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param {!Array<number>} challengeDataBytes The data for the challenge message.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Protection.PlayReady.INDSendResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Protection.PlayReady.INDSendResult>>} The result of the proximity detection start operation.
 */
Windows.Media.Protection.PlayReady.NDTCPMessenger.prototype.sendProximityDetectionStartAsync = function(pdType, transmitterChannelBytes, sessionIDBytes, challengeDataBytes) {};

/**
 * Sends the specified data in an asynchronous registration request message.
 * @param {!Array<number>} sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param {!Array<number>} challengeDataBytes The data for the challenge message.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Protection.PlayReady.INDSendResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Protection.PlayReady.INDSendResult>>} The result of the registration request.
 */
Windows.Media.Protection.PlayReady.NDTCPMessenger.prototype.sendRegistrationRequestAsync = function(sessionIDBytes, challengeDataBytes) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlayReadyContentHeader class.
 * Initializes a new instance of the PlayReadyContentHeader class.
 * Initializes a new instance of the PlayReadyContentHeader class.
 * Initializes a new instance of the PlayReadyContentHeader class.
 * @param {string|!Array<number>|number} contentKeyId_or_headerBytes_or_dwFlags Identifier of the content encryption key. / Raw data bytes representing a legacy WMDRM header. / Reserved. Set to 0. / Raw data bytes representing a PlayReady content header.
 * @param {string|!Windows.Foundation.Uri|!Array<string>=} contentKeyIdString_or_licenseAcquisitionUrl_or_contentKeyIds String representation of the content key. If the contentKeyId parameter is specified, then this parameter is ignored. / The URL for the silent (no user interaction) license acquisition Web service. / Identifiers of the content encryption keys.
 * @param {Windows.Media.Protection.PlayReady.PlayReadyEncryptionAlgorithm|!Windows.Foundation.Uri|!Array<string>=} contentEncryptionAlgorithm_or_licenseAcquisitionUserInterfaceUrl_or_contentKeyIdStrings Encryption algorithm type used to encrypt the content. / The URL for a non-silent license acquisition Web page. / String representations of the content keys. Each string must be a Base-64 encoded 16 byte value.
 * @param {!Windows.Foundation.Uri|string|Windows.Media.Protection.PlayReady.PlayReadyEncryptionAlgorithm=} licenseAcquisitionUrl_or_customAttributes_or_contentEncryptionAlgorithm The URL for the silent (no user interaction) license acquisition Web service. / Contains custom data used by the content provider. The content author can add arbitrary XML inside this element. Microsoft code does not act on any data contained inside this element. / Encryption algorithm type used to encrypt the content.
 * @param {!Windows.Foundation.Uri|string=} licenseAcquisitionUserInterfaceUrl_or_domainServiceId_or_licenseAcquisitionUrl The URL for a non-silent license acquisition Web page. / Service identifier for the domain service. / The URL for the silent (no user interaction) license acquisition Web service.
 * @param {string|!Windows.Foundation.Uri=} customAttributes_or_licenseAcquisitionUserInterfaceUrl Contains custom data used by the content provider. The content author can add arbitrary XML inside this element. Microsoft code does not act on any data contained inside this element. / The URL for a non-silent license acquisition Web page.
 * @param {string=} domainServiceId_or_customAttributes Service identifier for the domain service. / Contains custom data used by the content provider. The content author can add arbitrary XML inside this element. Microsoft code does not act on any data contained inside this element.
 * @param {string=} domainServiceId Service identifier for the domain service.
 */
Windows.Media.Protection.PlayReady.PlayReadyContentHeader = function(contentKeyId_or_headerBytes_or_dwFlags, contentKeyIdString_or_licenseAcquisitionUrl_or_contentKeyIds, contentEncryptionAlgorithm_or_licenseAcquisitionUserInterfaceUrl_or_contentKeyIdStrings, licenseAcquisitionUrl_or_customAttributes_or_contentEncryptionAlgorithm, licenseAcquisitionUserInterfaceUrl_or_domainServiceId_or_licenseAcquisitionUrl, customAttributes_or_licenseAcquisitionUserInterfaceUrl, domainServiceId_or_customAttributes, domainServiceId) {};
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyContentHeader.prototype.customAttributes;
 /** @type {Windows.Media.Protection.PlayReady.PlayReadyDecryptorSetup} */
Windows.Media.Protection.PlayReady.PlayReadyContentHeader.prototype.decryptorSetup;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyContentHeader.prototype.domainServiceId;
 /** @type {Windows.Media.Protection.PlayReady.PlayReadyEncryptionAlgorithm} */
Windows.Media.Protection.PlayReady.PlayReadyContentHeader.prototype.encryptionType;
 /** @type {!Windows.Media.Protection.PlayReady.PlayReadyContentHeader} */
Windows.Media.Protection.PlayReady.PlayReadyContentHeader.prototype.headerWithEmbeddedUpdates;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyContentHeader.prototype.keyId;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyContentHeader.prototype.keyIdString;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyContentHeader.prototype.keyIdStrings;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyContentHeader.prototype.keyIds;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Protection.PlayReady.PlayReadyContentHeader.prototype.licenseAcquisitionUrl;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Protection.PlayReady.PlayReadyContentHeader.prototype.licenseAcquisitionUserInterfaceUrl;

/**
 * Retrieves the full PlayReady object as a byte array.
 * @return {!Array<number>} The header containing the full PlayReady object.
 */
Windows.Media.Protection.PlayReady.PlayReadyContentHeader.prototype.getSerializedHeader = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.PlayReady.PlayReadyContentResolver = function() {};

/**
 * Proactively initiates the service request chain for a given content header.
 * @param {!Windows.Media.Protection.PlayReady.PlayReadyContentHeader} contentHeader Content header for the content the app wants to resolve all necessary service request operations.
 * @return {!Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest} The first service request operation required to resolve the content.
 */
Windows.Media.Protection.PlayReady.PlayReadyContentResolver.serviceRequest = function(contentHeader) {};

/** @const */
Windows.Media.Protection.PlayReady.PlayReadyDecryptorSetup = {};
/** @const {number} */
Windows.Media.Protection.PlayReady.PlayReadyDecryptorSetup.uninitialized;
/** @const {number} */
Windows.Media.Protection.PlayReady.PlayReadyDecryptorSetup.onDemand;
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.PlayReady.PlayReadyDomain = function() {};
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomain.prototype.accountId;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Protection.PlayReady.PlayReadyDomain.prototype.domainJoinUrl;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomain.prototype.friendlyName;
 /** @type {number} */
Windows.Media.Protection.PlayReady.PlayReadyDomain.prototype.revision;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomain.prototype.serviceId;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlayReadyDomainIterable class using the domain account identifier.
 * @param {string} domainAccountId The domain account identifier.
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainIterable = function(domainAccountId) {};

/**
 * Returns an iterator that iterates over the items in the PlayReady domain collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Media.Protection.PlayReady.IPlayReadyDomain>} The PlayReady domain iterator.
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainIterable.prototype.first = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainIterator = function() {};
 /** @type {!Windows.Media.Protection.PlayReady.IPlayReadyDomain} */
Windows.Media.Protection.PlayReady.PlayReadyDomainIterator.prototype.current;
 /** @type {boolean} */
Windows.Media.Protection.PlayReady.PlayReadyDomainIterator.prototype.hasCurrent;

/**
 * Retrieves all items in the PlayReady domain collection.
 * @return {{items: !Windows.Media.Protection.PlayReady.IPlayReadyDomain, returnValue: number}}
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainIterator.prototype.getMany = function() {};

/**
 * Advances the enumerator to the next item in the collection.
 * @return {boolean} true if the iterator refers to a valid item that is in the collection or false if the iterator is at the end of the collection.
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainIterator.prototype.moveNext = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlayReadyDomainJoinServiceRequest class.
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest = function() {};
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest.prototype.challengeCustomData;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest.prototype.domainAccountId;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest.prototype.domainFriendlyName;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest.prototype.domainServiceId;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest.prototype.protectionSystem;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest.prototype.responseCustomData;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest.prototype.type;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest.prototype.uri;

/**
 * Begins an asynchronous service request operation.
 * @return {!Windows.Foundation.IAsyncAction} The asynchronous service action.
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest.prototype.beginServiceRequest = function() {};

/**
 * Begins the process of manually enabling.
 * @return {!Windows.Media.Protection.PlayReady.PlayReadySoapMessage} The SOAP message to be used in a manual license acquisition challenge request.
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest.prototype.generateManualEnablingChallenge = function() {};

/**
 * Returns a new service request interface.
 * @return {!Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest} The new service request interface.
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest.prototype.nextServiceRequest = function() {};

/**
 * Process the raw binary result of a manual enabling challenge.
 * @param {!Array<number>} responseBytes The response result to be processed.
 * @return {!Windows.WinRTError} If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainJoinServiceRequest.prototype.processManualEnablingResponse = function(responseBytes) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlayReadyDomainLeaveServiceRequest class.
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest = function() {};
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest.prototype.challengeCustomData;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest.prototype.domainAccountId;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest.prototype.domainServiceId;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest.prototype.protectionSystem;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest.prototype.responseCustomData;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest.prototype.type;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest.prototype.uri;

/**
 * Begins an asynchronous service request operation.
 * @return {!Windows.Foundation.IAsyncAction} The asynchronous service action.
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest.prototype.beginServiceRequest = function() {};

/**
 * Begins the process of manually enabling.
 * @return {!Windows.Media.Protection.PlayReady.PlayReadySoapMessage} The SOAP message to be used in a manual license acquisition challenge request.
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest.prototype.generateManualEnablingChallenge = function() {};

/**
 * Returns a new service request interface.
 * @return {!Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest} The new service request interface.
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest.prototype.nextServiceRequest = function() {};

/**
 * Process the raw binary result of a manual enabling challenge.
 * @param {!Array<number>} responseBytes The response result to be processed.
 * @return {!Windows.WinRTError} If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
 */
Windows.Media.Protection.PlayReady.PlayReadyDomainLeaveServiceRequest.prototype.processManualEnablingResponse = function(responseBytes) {};

/** @const */
Windows.Media.Protection.PlayReady.PlayReadyEncryptionAlgorithm = {};
/** @const {number} */
Windows.Media.Protection.PlayReady.PlayReadyEncryptionAlgorithm.unprotected;
/** @const {number} */
Windows.Media.Protection.PlayReady.PlayReadyEncryptionAlgorithm.aes128Ctr;
/** @const {number} */
Windows.Media.Protection.PlayReady.PlayReadyEncryptionAlgorithm.cocktail;
/** @const {number} */
Windows.Media.Protection.PlayReady.PlayReadyEncryptionAlgorithm.uninitialized;

/** @const */
Windows.Media.Protection.PlayReady.PlayReadyHardwareDRMFeatures = {};
/** @const {number} */
Windows.Media.Protection.PlayReady.PlayReadyHardwareDRMFeatures.hardwareDRM;
/** @const {number} */
Windows.Media.Protection.PlayReady.PlayReadyHardwareDRMFeatures.hevc;

/** @const */
Windows.Media.Protection.PlayReady.PlayReadyITADataFormat = {};
/** @const {number} */
Windows.Media.Protection.PlayReady.PlayReadyITADataFormat.serializedProperties;
/** @const {number} */
Windows.Media.Protection.PlayReady.PlayReadyITADataFormat.serializedProperties_WithContentProtectionWrapper;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlayReadyITADataGenerator class.
 */
Windows.Media.Protection.PlayReady.PlayReadyITADataGenerator = function() {};

/**
 * Returns a serialized blob of the specified IPropertySet data that the PlayReady ITA can consume if wrapped in a content protection instantiation format.
 * @param {string} guidCPSystemId The content protection system GUID.
 * @param {number} countOfStreams The stream count.
 * @param {!Windows.Foundation.Collections.IPropertySet} configuration The data to be returned as a serialized blob.
 * @param {Windows.Media.Protection.PlayReady.PlayReadyITADataFormat} format The format for the ITA serialized data.
 * @return {!Array<number>} The serialized blob. See Remarks.
 */
Windows.Media.Protection.PlayReady.PlayReadyITADataGenerator.prototype.generateData = function(guidCPSystemId, countOfStreams, configuration, format) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlayReadyIndividualizationServiceRequest class.
 */
Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest = function() {};
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest.prototype.challengeCustomData;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest.prototype.protectionSystem;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest.prototype.responseCustomData;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest.prototype.type;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest.prototype.uri;

/**
 * Begins an asynchronous service request operation.
 * @return {!Windows.Foundation.IAsyncAction} The asynchronous service action.
 */
Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest.prototype.beginServiceRequest = function() {};

/**
 * Begins the process of manually enabling. This method is not supported in this class.
 * @return {!Windows.Media.Protection.PlayReady.PlayReadySoapMessage} This method always returns 0x80070032 (the request is not supported).
 */
Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest.prototype.generateManualEnablingChallenge = function() {};

/**
 * Returns a new service request interface.
 * @return {!Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest} The new service request interface.
 */
Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest.prototype.nextServiceRequest = function() {};

/**
 * Process the raw binary result of a manual enabling challenge. This method is not supported in this class.
 * @param {!Array<number>} responseBytes The response result to be processed.
 * @return {!Windows.WinRTError} This method always returns 0x80070032 (the request is not supported).
 */
Windows.Media.Protection.PlayReady.PlayReadyIndividualizationServiceRequest.prototype.processManualEnablingResponse = function(responseBytes) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.PlayReady.PlayReadyLicense = function() {};
 /** @type {number} */
Windows.Media.Protection.PlayReady.PlayReadyLicense.prototype.chainDepth;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyLicense.prototype.domainAccountID;
 /** @type {!Date} */
Windows.Media.Protection.PlayReady.PlayReadyLicense.prototype.expirationDate;
 /** @type {number} */
Windows.Media.Protection.PlayReady.PlayReadyLicense.prototype.expireAfterFirstPlay;
 /** @type {boolean} */
Windows.Media.Protection.PlayReady.PlayReadyLicense.prototype.fullyEvaluated;
 /** @type {boolean} */
Windows.Media.Protection.PlayReady.PlayReadyLicense.prototype.usableForPlay;

/**
 * Gets the key identifier (KID) of the license at the specified chain depth.
 * @param {number} chainDepth The depth of the license in the chain for which to retrieve the KID. This value is a 0-based index.
 * @return {string} The KID of the license. This return value is sensitive to the underlying platform's endianness. Carefully test your app on all platforms you intend to support to ensure that correct endianness is used on each platform.
 */
Windows.Media.Protection.PlayReady.PlayReadyLicense.prototype.getKIDAtChainDepth = function(chainDepth) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlayReadyLicenseAcquisitionServiceRequest class.
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest = function() {};
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest.prototype.challengeCustomData;
 /** @type {!Windows.Media.Protection.PlayReady.PlayReadyContentHeader} */
Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest.prototype.contentHeader;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest.prototype.domainServiceId;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest.prototype.protectionSystem;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest.prototype.responseCustomData;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest.prototype.type;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest.prototype.uri;

/**
 * Begins an asynchronous service request operation.
 * @return {!Windows.Foundation.IAsyncAction} The asynchronous service action.
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest.prototype.beginServiceRequest = function() {};

/**
 * Begins the process of manually enabling.
 * @return {!Windows.Media.Protection.PlayReady.PlayReadySoapMessage} The SOAP message to be used in a manual license acquisition challenge request.
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest.prototype.generateManualEnablingChallenge = function() {};

/**
 * Returns a new service request interface.
 * @return {!Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest} The new service request interface.
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest.prototype.nextServiceRequest = function() {};

/**
 * Process the raw binary result of a manual enabling challenge.
 * @param {!Array<number>} responseBytes The response result to be processed.
 * @return {!Windows.WinRTError} If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseAcquisitionServiceRequest.prototype.processManualEnablingResponse = function(responseBytes) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlayReadyLicenseIterable class.
 * Initializes a new instance of the PlayReadyLicenseIterable class.
 * @param {!Windows.Media.Protection.PlayReady.PlayReadyContentHeader=} contentHeader The content header used to locate associated licenses.
 * @param {boolean=} fullyEvaluated Indicates whether evaluated license chains should be enumerated or if all licenses (including those that are unusable) should be enumerated. This parameter is true if evaluated license chains should be enumerated, or false if all licenses should be enumerated.
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseIterable = function(contentHeader, fullyEvaluated) {};

/**
 * Returns an iterator that iterates over the items in the PlayReady license collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Media.Protection.PlayReady.IPlayReadyLicense>} The PlayReady license iterator.
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseIterable.prototype.first = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseIterator = function() {};
 /** @type {!Windows.Media.Protection.PlayReady.IPlayReadyLicense} */
Windows.Media.Protection.PlayReady.PlayReadyLicenseIterator.prototype.current;
 /** @type {boolean} */
Windows.Media.Protection.PlayReady.PlayReadyLicenseIterator.prototype.hasCurrent;

/**
 * Retrieves all items in the PlayReady license collection.
 * @return {{items: !Windows.Media.Protection.PlayReady.IPlayReadyLicense, returnValue: number}}
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseIterator.prototype.getMany = function() {};

/**
 * Advances the enumerator to the next item in the collection.
 * @return {boolean} true if the iterator refers to a valid item that is in the collection or false if the iterator is at the end of the collection.
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseIterator.prototype.moveNext = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseManagement = function() {};

/**
 * Deletes licenses that match the specified content header.
 * @param {!Windows.Media.Protection.PlayReady.PlayReadyContentHeader} contentHeader Content header with a key identifier with which to match licenses.
 * @return {!Windows.Foundation.IAsyncAction} The asynchronous operation performing the deletion.
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseManagement.deleteLicenses = function(contentHeader) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlayReadyLicenseSession class.
 * @param {!Windows.Foundation.Collections.IPropertySet} configuration The configuration data for the license session.
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseSession = function(configuration) {};

/**
 * Updates the media protection manger with the appropriate settings so the media foundation can be used for playback.
 * @param {!Windows.Media.Protection.MediaProtectionManager} mpm The media protection manager to be updated.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseSession.prototype.configureMediaProtectionManager = function(mpm) {};

/**
 * Creates a license acquisition service request whose license will be tied to the media session.
 * @return {!Windows.Media.Protection.PlayReady.IPlayReadyLicenseAcquisitionServiceRequest} The license acquisition service request.
 */
Windows.Media.Protection.PlayReady.PlayReadyLicenseSession.prototype.createLAServiceRequest = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlayReadyMeteringReportServiceRequest class.
 */
Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest = function() {};
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest.prototype.challengeCustomData;
 /** @type {number} */
Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest.prototype.meteringCertificate;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest.prototype.protectionSystem;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest.prototype.responseCustomData;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest.prototype.type;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest.prototype.uri;

/**
 * Begins an asynchronous service request operation.
 * @return {!Windows.Foundation.IAsyncAction} The asynchronous service action.
 */
Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest.prototype.beginServiceRequest = function() {};

/**
 * Begins the process of manually enabling.
 * @return {!Windows.Media.Protection.PlayReady.PlayReadySoapMessage} The SOAP message to be used in a manual license acquisition challenge request.
 */
Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest.prototype.generateManualEnablingChallenge = function() {};

/**
 * Returns a new service request interface.
 * @return {!Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest} The new service request interface.
 */
Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest.prototype.nextServiceRequest = function() {};

/**
 * Process the raw binary result of a manual enabling challenge.
 * @param {!Array<number>} responseBytes The response result to be processed.
 * @return {!Windows.WinRTError} If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
 */
Windows.Media.Protection.PlayReady.PlayReadyMeteringReportServiceRequest.prototype.processManualEnablingResponse = function(responseBytes) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlayReadyRevocationServiceRequest class.
 */
Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest = function() {};
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest.prototype.challengeCustomData;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest.prototype.protectionSystem;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest.prototype.responseCustomData;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest.prototype.type;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest.prototype.uri;

/**
 * Begins an asynchronous service request operation.
 * @return {!Windows.Foundation.IAsyncAction} The asynchronous service action.
 */
Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest.prototype.beginServiceRequest = function() {};

/**
 * Begins the process of manually enabling. This method is not supported in this class.
 * @return {!Windows.Media.Protection.PlayReady.PlayReadySoapMessage} This method always returns 0x80070032 (the request is not supported).
 */
Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest.prototype.generateManualEnablingChallenge = function() {};

/**
 * Returns a new service request interface.
 * @return {!Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest} The new service request interface.
 */
Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest.prototype.nextServiceRequest = function() {};

/**
 * Process the raw binary result of a manual enabling challenge. This method is not supported in this class.
 * @param {!Array<number>} responseBytes The response result to be processed.
 * @return {!Windows.WinRTError} This method always returns 0x80070032 (the request is not supported).
 */
Windows.Media.Protection.PlayReady.PlayReadyRevocationServiceRequest.prototype.processManualEnablingResponse = function(responseBytes) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlayReadySecureStopIterable class.
 * @param {!Array<number>} publisherCertBytes The raw binary body of the publisher certificate.
 */
Windows.Media.Protection.PlayReady.PlayReadySecureStopIterable = function(publisherCertBytes) {};

/**
 * Returns an iterator that iterates over the items in the PlayReady secure stop collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest>} The PlayReady secure stop iterator.
 */
Windows.Media.Protection.PlayReady.PlayReadySecureStopIterable.prototype.first = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.PlayReady.PlayReadySecureStopIterator = function() {};
 /** @type {!Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest} */
Windows.Media.Protection.PlayReady.PlayReadySecureStopIterator.prototype.current;
 /** @type {boolean} */
Windows.Media.Protection.PlayReady.PlayReadySecureStopIterator.prototype.hasCurrent;

/**
 * Retrieves all items in the PlayReady secure stop collection.
 * @return {{items: !Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest, returnValue: number}}
 */
Windows.Media.Protection.PlayReady.PlayReadySecureStopIterator.prototype.getMany = function() {};

/**
 * Advances the enumerator to the next item in the collection.
 * @return {boolean} true if the iterator refers to a valid item that is in the collection or false if the iterator is at the end of the collection.
 */
Windows.Media.Protection.PlayReady.PlayReadySecureStopIterator.prototype.moveNext = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the PlayReadySecureStopServiceRequest class for the specified secure stop session.
 * Initializes a new instance of the PlayReadySecureStopServiceRequest class to include all secure stop sessions.
 * @param {string|!Array<number>} sessionID_or_publisherCertBytes The secure stop session identifier. / The raw binary body of the publisher certificate.
 * @param {!Array<number>=} publisherCertBytes The raw binary body of the publisher certificate.
 */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest = function(sessionID_or_publisherCertBytes, publisherCertBytes) {};
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest.prototype.challengeCustomData;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest.prototype.protectionSystem;
 /** @type {number} */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest.prototype.publisherCertificate;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest.prototype.responseCustomData;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest.prototype.sessionID;
 /** @type {!Date} */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest.prototype.startTime;
 /** @type {boolean} */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest.prototype.stopped;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest.prototype.type;
 /** @type {!Date} */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest.prototype.updateTime;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest.prototype.uri;

/**
 * Begins an asynchronous service request operation.
 * @return {!Windows.Foundation.IAsyncAction} The asynchronous service action.
 */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest.prototype.beginServiceRequest = function() {};

/**
 * Begins the process of manually enabling.
 * @return {!Windows.Media.Protection.PlayReady.PlayReadySoapMessage} The SOAP message to be used in a manual license acquisition challenge request.
 */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest.prototype.generateManualEnablingChallenge = function() {};

/**
 * Returns a new service request interface.
 * @return {!Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest} The new service request interface.
 */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest.prototype.nextServiceRequest = function() {};

/**
 * Process the raw binary result of a manual enabling challenge.
 * @param {!Array<number>} responseBytes The response result to be processed.
 * @return {!Windows.WinRTError} If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
 */
Windows.Media.Protection.PlayReady.PlayReadySecureStopServiceRequest.prototype.processManualEnablingResponse = function(responseBytes) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.PlayReady.PlayReadySoapMessage = function() {};
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.Protection.PlayReady.PlayReadySoapMessage.prototype.messageHeaders;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Protection.PlayReady.PlayReadySoapMessage.prototype.uri;

/**
 * Retrieves the contents of the SOAP message.
 * @return {!Array<number>} The contents of the SOAP message.
 */
Windows.Media.Protection.PlayReady.PlayReadySoapMessage.prototype.getMessageBody = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.PlayReady.PlayReadyStatics = function() {};
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyStatics.domainJoinServiceRequestType;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyStatics.domainLeaveServiceRequestType;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyStatics.individualizationServiceRequestType;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyStatics.licenseAcquirerServiceRequestType;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyStatics.mediaProtectionSystemId;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyStatics.meteringReportServiceRequestType;
 /** @type {number} */
Windows.Media.Protection.PlayReady.PlayReadyStatics.playReadyCertificateSecurityLevel;
 /** @type {number} */
Windows.Media.Protection.PlayReady.PlayReadyStatics.playReadySecurityVersion;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyStatics.revocationServiceRequestType;
 /** @type {string} */
Windows.Media.Protection.PlayReady.PlayReadyStatics.secureStopServiceRequestType;

/**
 * Queries whether the specified hardware digital rights management (DRM) feature is supported on the system.
 * @param {Windows.Media.Protection.PlayReady.PlayReadyHardwareDRMFeatures} hwdrmFeature The hardware DRM feature to query.
 * @return {boolean} true if the hardware DRM feature is supported, otherwise false.
 */
Windows.Media.Protection.PlayReady.PlayReadyStatics.checkSupportedHardware = function(hwdrmFeature) {};
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor = function() {};
 /** @type {number} */
Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor.prototype.contentID;
 /** @type {Windows.Media.Protection.PlayReady.NDContentIDType} */
Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor.prototype.contentIDType;
 /** @type {!Windows.Media.Protection.PlayReady.INDCustomData} */
Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor.prototype.licenseFetchChallengeCustomData;
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.INDLicenseFetchResult = function() {};
 /** @type {!Windows.Media.Protection.PlayReady.INDCustomData} */
Windows.Media.Protection.PlayReady.INDLicenseFetchResult.prototype.responseCustomData;
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.INDClosedCaptionDataReceivedEventArgs = function() {};
 /** @type {number} */
Windows.Media.Protection.PlayReady.INDClosedCaptionDataReceivedEventArgs.prototype.closedCaptionData;
 /** @type {Windows.Media.Protection.PlayReady.NDClosedCaptionFormat} */
Windows.Media.Protection.PlayReady.INDClosedCaptionDataReceivedEventArgs.prototype.closedCaptionDataFormat;
 /** @type {number} */
Windows.Media.Protection.PlayReady.INDClosedCaptionDataReceivedEventArgs.prototype.presentationTimestamp;
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.INDLicenseFetchCompletedEventArgs = function() {};
 /** @type {!Windows.Media.Protection.PlayReady.INDCustomData} */
Windows.Media.Protection.PlayReady.INDLicenseFetchCompletedEventArgs.prototype.responseCustomData;
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.INDProximityDetectionCompletedEventArgs = function() {};
 /** @type {number} */
Windows.Media.Protection.PlayReady.INDProximityDetectionCompletedEventArgs.prototype.proximityDetectionRetryCount;
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs = function() {};
 /** @type {!Windows.Media.Protection.PlayReady.INDCustomData} */
Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs.prototype.responseCustomData;
 /** @type {boolean} */
Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs.prototype.transmitterCertificateAccepted;
 /** @type {!Windows.Media.Protection.PlayReady.INDTransmitterProperties} */
Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs.prototype.transmitterProperties;
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.INDCustomData = function() {};
 /** @type {number} */
Windows.Media.Protection.PlayReady.INDCustomData.prototype.customData;
 /** @type {number} */
Windows.Media.Protection.PlayReady.INDCustomData.prototype.customDataTypeID;
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.INDStartResult = function() {};
 /** @type {!Windows.Media.Core.MediaStreamSource} */
Windows.Media.Protection.PlayReady.INDStartResult.prototype.mediaStreamSource;
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.INDDownloadEngine = function() {};
 /** @type {number} */
Windows.Media.Protection.PlayReady.INDDownloadEngine.prototype.bufferFullMaxThresholdInSamples;
 /** @type {number} */
Windows.Media.Protection.PlayReady.INDDownloadEngine.prototype.bufferFullMinThresholdInSamples;
 /** @type {boolean} */
Windows.Media.Protection.PlayReady.INDDownloadEngine.prototype.canSeek;
 /** @type {!Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier} */
Windows.Media.Protection.PlayReady.INDDownloadEngine.prototype.notifier;

/**
 * Notifies the download engine to stop downloading and disconnect from the remote server.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.INDDownloadEngine.prototype.close = function() {};

/**
 * Notifies the download engine to open the content specified by a URL.
 * @param {!Windows.Foundation.Uri} uri The URI from which the download engine gets content.
 * @param {!Array<number>} sessionIDBytes The session identifier used to identify the session. The session identifier must be 16 bytes.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.INDDownloadEngine.prototype.open = function(uri, sessionIDBytes) {};

/**
 * Notifies the download engine to pause downloading.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.INDDownloadEngine.prototype.pause = function() {};

/**
 * Notifies the download engine to resume a paused download.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.INDDownloadEngine.prototype.resume = function() {};

/**
 * Notifies the download engine to go to a specified time position in the media stream.
 * @param {number} startPosition The position within the media stream to which to seek.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.INDDownloadEngine.prototype.seek = function(startPosition) {};
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.INDStreamParser = function() {};
 /** @type {!Windows.Media.Protection.PlayReady.NDStreamParserNotifier} */
Windows.Media.Protection.PlayReady.INDStreamParser.prototype.notifier;

/**
 * Notifies a PlayReady-ND stream parser to be ready for the beginning of a new media stream.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.INDStreamParser.prototype.beginOfStream = function() {};

/**
 * Notifies a PlayReady-ND stream parser that the end of a media stream has been reached.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.INDStreamParser.prototype.endOfStream = function() {};

/**
 * Retrieves the stream type (audio or video) and stream identifier of the media stream descriptor.
 * @param {!Windows.Media.Core.IMediaStreamDescriptor} descriptor The media stream from which this method gets information.
 * @return {{streamType: Windows.Media.Protection.PlayReady.NDMediaStreamType, returnValue: number}}
 */
Windows.Media.Protection.PlayReady.INDStreamParser.prototype.getStreamInformation = function(descriptor) {};

/**
 * Parses samples from a PlayReady-ND media stream.
 * @param {!Array<number>} dataBytes The data to be parsed.
 * @return {void}
 */
Windows.Media.Protection.PlayReady.INDStreamParser.prototype.parseData = function(dataBytes) {};
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.INDMessenger = function() {};

/**
 * Sends the specified data in an asynchronous license fetch request message.
 * @param {!Array<number>} sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param {!Array<number>} challengeDataBytes The data for the challenge message.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Protection.PlayReady.INDSendResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Protection.PlayReady.INDSendResult>>} The result of the license fetch request.
 */
Windows.Media.Protection.PlayReady.INDMessenger.prototype.sendLicenseFetchRequestAsync = function(sessionIDBytes, challengeDataBytes) {};

/**
 * Sends the specified data in an asynchronous proximity detection response message.
 * @param {Windows.Media.Protection.PlayReady.NDProximityDetectionType} pdType The type of proximity detection operation. This value can be UDP, TCP, or Transport-Agnostic.
 * @param {!Array<number>} transmitterChannelBytes The transmitter channel data.
 * @param {!Array<number>} sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param {!Array<number>} responseDataBytes The data for the response message.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Protection.PlayReady.INDSendResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Protection.PlayReady.INDSendResult>>} The result of the proximity detection response operation.
 */
Windows.Media.Protection.PlayReady.INDMessenger.prototype.sendProximityDetectionResponseAsync = function(pdType, transmitterChannelBytes, sessionIDBytes, responseDataBytes) {};

/**
 * Sends the specified data in an asynchronous proximity detection start message.
 * @param {Windows.Media.Protection.PlayReady.NDProximityDetectionType} pdType The type of proximity detection operation. This value can be UDP, TCP, or Transport-Agnostic.
 * @param {!Array<number>} transmitterChannelBytes The transmitter channel data.
 * @param {!Array<number>} sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param {!Array<number>} challengeDataBytes The data for the challenge message.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Protection.PlayReady.INDSendResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Protection.PlayReady.INDSendResult>>} The result of the proximity detection start operation.
 */
Windows.Media.Protection.PlayReady.INDMessenger.prototype.sendProximityDetectionStartAsync = function(pdType, transmitterChannelBytes, sessionIDBytes, challengeDataBytes) {};

/**
 * Sends the specified data in an asynchronous registration request message.
 * @param {!Array<number>} sessionIDBytes The session identifier. The session identifier must be 16 bytes.
 * @param {!Array<number>} challengeDataBytes The data for the challenge message.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Protection.PlayReady.INDSendResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Protection.PlayReady.INDSendResult>>} The result of the license fetch request.
 */
Windows.Media.Protection.PlayReady.INDMessenger.prototype.sendRegistrationRequestAsync = function(sessionIDBytes, challengeDataBytes) {};
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.INDSendResult = function() {};
 /** @type {number} */
Windows.Media.Protection.PlayReady.INDSendResult.prototype.response;
/**
 * @extends {Windows.Media.Protection.IMediaProtectionServiceRequest}
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest = function() {};
 /** @type {string} */
Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest.prototype.challengeCustomData;
 /** @type {string} */
Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest.prototype.responseCustomData;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest.prototype.uri;

/**
 * Begins an asynchronous service request operation.
 * @return {!Windows.Foundation.IAsyncAction} The asynchronous service action.
 */
Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest.prototype.beginServiceRequest = function() {};

/**
 * Begins the process of manually enabling.
 * @return {!Windows.Media.Protection.PlayReady.PlayReadySoapMessage} Begins the process of manually enabling.
 */
Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest.prototype.generateManualEnablingChallenge = function() {};

/**
 * Returns a new service request interface.
 * @return {!Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest} The new service request interface.
 */
Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest.prototype.nextServiceRequest = function() {};

/**
 * Processes the raw binary result of a manual enabling challenge.
 * @param {!Array<number>} responseBytes The response result to be processed.
 * @return {!Windows.WinRTError} If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
 */
Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest.prototype.processManualEnablingResponse = function(responseBytes) {};
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.IPlayReadyDomain = function() {};
 /** @type {string} */
Windows.Media.Protection.PlayReady.IPlayReadyDomain.prototype.accountId;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Protection.PlayReady.IPlayReadyDomain.prototype.domainJoinUrl;
 /** @type {string} */
Windows.Media.Protection.PlayReady.IPlayReadyDomain.prototype.friendlyName;
 /** @type {number} */
Windows.Media.Protection.PlayReady.IPlayReadyDomain.prototype.revision;
 /** @type {string} */
Windows.Media.Protection.PlayReady.IPlayReadyDomain.prototype.serviceId;
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.IPlayReadyLicense = function() {};
 /** @type {number} */
Windows.Media.Protection.PlayReady.IPlayReadyLicense.prototype.chainDepth;
 /** @type {string} */
Windows.Media.Protection.PlayReady.IPlayReadyLicense.prototype.domainAccountID;
 /** @type {!Date} */
Windows.Media.Protection.PlayReady.IPlayReadyLicense.prototype.expirationDate;
 /** @type {number} */
Windows.Media.Protection.PlayReady.IPlayReadyLicense.prototype.expireAfterFirstPlay;
 /** @type {boolean} */
Windows.Media.Protection.PlayReady.IPlayReadyLicense.prototype.fullyEvaluated;
 /** @type {boolean} */
Windows.Media.Protection.PlayReady.IPlayReadyLicense.prototype.usableForPlay;

/**
 * Gets the key identifier (KID) of the license at the specified chain depth.
 * @param {number} chainDepth The depth of the license in the chain for which to retrieve the KID. This value is a 0-based index.
 * @return {string} The KID of the license. This return value is sensitive to the underlying platform's endianness. Carefully test your app on all platforms you intend to support to ensure that correct endianness is used on each platform.
 */
Windows.Media.Protection.PlayReady.IPlayReadyLicense.prototype.getKIDAtChainDepth = function(chainDepth) {};
/**
 * @extends {Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest}
 * @extends {Windows.Media.Protection.IMediaProtectionServiceRequest}
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.IPlayReadyLicenseAcquisitionServiceRequest = function() {};
 /** @type {!Windows.Media.Protection.PlayReady.PlayReadyContentHeader} */
Windows.Media.Protection.PlayReady.IPlayReadyLicenseAcquisitionServiceRequest.prototype.contentHeader;
 /** @type {string} */
Windows.Media.Protection.PlayReady.IPlayReadyLicenseAcquisitionServiceRequest.prototype.domainServiceId;
/**
 * @extends {Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest}
 * @extends {Windows.Media.Protection.IMediaProtectionServiceRequest}
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest = function() {};
 /** @type {number} */
Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest.prototype.publisherCertificate;
 /** @type {string} */
Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest.prototype.sessionID;
 /** @type {!Date} */
Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest.prototype.startTime;
 /** @type {boolean} */
Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest.prototype.stopped;
 /** @type {!Date} */
Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest.prototype.updateTime;
/**
 * @record
 * @struct
 */
Windows.Media.Protection.PlayReady.INDTransmitterProperties = function() {};
 /** @type {Windows.Media.Protection.PlayReady.NDCertificateType} */
Windows.Media.Protection.PlayReady.INDTransmitterProperties.prototype.certificateType;
 /** @type {number} */
Windows.Media.Protection.PlayReady.INDTransmitterProperties.prototype.clientID;
 /** @type {!Date} */
Windows.Media.Protection.PlayReady.INDTransmitterProperties.prototype.expirationDate;
 /** @type {number} */
Windows.Media.Protection.PlayReady.INDTransmitterProperties.prototype.modelDigest;
 /** @type {string} */
Windows.Media.Protection.PlayReady.INDTransmitterProperties.prototype.modelManufacturerName;
 /** @type {string} */
Windows.Media.Protection.PlayReady.INDTransmitterProperties.prototype.modelName;
 /** @type {string} */
Windows.Media.Protection.PlayReady.INDTransmitterProperties.prototype.modelNumber;
 /** @type {Windows.Media.Protection.PlayReady.NDCertificatePlatformID} */
Windows.Media.Protection.PlayReady.INDTransmitterProperties.prototype.platformIdentifier;
 /** @type {number} */
Windows.Media.Protection.PlayReady.INDTransmitterProperties.prototype.securityLevel;
 /** @type {number} */
Windows.Media.Protection.PlayReady.INDTransmitterProperties.prototype.securityVersion;
 /** @type {Windows.Media.Protection.PlayReady.NDCertificateFeature} */
Windows.Media.Protection.PlayReady.INDTransmitterProperties.prototype.supportedFeatures;
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.ProtectionCapabilities = function() {};
 /** @type {?} */
Windows.Media.Protection.ProtectionCapabilities.prototype.isTypeSupported;
/** @const */
Windows.Media.Protection.ProtectionCapabilityResult = {};
 /** @type {?} */
Windows.Media.Protection.ProtectionCapabilityResult.notSupported;
 /** @type {?} */
Windows.Media.Protection.ProtectionCapabilityResult.maybe;
 /** @type {?} */
Windows.Media.Protection.ProtectionCapabilityResult.probably;

/** @const */
Windows.Media.Protection.RenewalStatus = {};
/** @const {number} */
Windows.Media.Protection.RenewalStatus.notStarted;
/** @const {number} */
Windows.Media.Protection.RenewalStatus.updatesInProgress;
/** @const {number} */
Windows.Media.Protection.RenewalStatus.userCancelled;
/** @const {number} */
Windows.Media.Protection.RenewalStatus.appComponentsMayNeedUpdating;
/** @const {number} */
Windows.Media.Protection.RenewalStatus.noComponentsFound;
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.RevocationAndRenewalInformation = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.Protection.RevocationAndRenewalItem>} */
Windows.Media.Protection.RevocationAndRenewalInformation.prototype.items;
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.RevocationAndRenewalItem = function() {};
 /** @type {string} */
Windows.Media.Protection.RevocationAndRenewalItem.prototype.headerHash;
 /** @type {string} */
Windows.Media.Protection.RevocationAndRenewalItem.prototype.name;
 /** @type {string} */
Windows.Media.Protection.RevocationAndRenewalItem.prototype.publicKeyHash;
 /** @type {Windows.Media.Protection.RevocationAndRenewalReasons} */
Windows.Media.Protection.RevocationAndRenewalItem.prototype.reasons;
 /** @type {string} */
Windows.Media.Protection.RevocationAndRenewalItem.prototype.renewalId;

/** @const */
Windows.Media.Protection.RevocationAndRenewalReasons = {};
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.userModeComponentLoad;
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.kernelModeComponentLoad;
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.appComponent;
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.globalRevocationListLoadFailed;
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.invalidGlobalRevocationListSignature;
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.globalRevocationListAbsent;
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.componentRevoked;
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.invalidComponentCertificateExtendedKeyUse;
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.componentCertificateRevoked;
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.invalidComponentCertificateRoot;
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.componentHighSecurityCertificateRevoked;
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.componentLowSecurityCertificateRevoked;
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.bootDriverVerificationFailed;
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.componentSignedWithTestCertificate;
/** @const {number} */
Windows.Media.Protection.RevocationAndRenewalReasons.encryptionFailure;
/**
 * @constructor
 * @struct
 */
Windows.Media.Protection.ServiceRequestedEventArgs = function() {};
 /** @type {!Windows.Media.Protection.MediaProtectionServiceCompletion} */
Windows.Media.Protection.ServiceRequestedEventArgs.prototype.completion;
 /** @type {!Windows.Media.Playback.MediaPlaybackItem} */
Windows.Media.Protection.ServiceRequestedEventArgs.prototype.mediaPlaybackItem;
 /** @type {!Windows.Media.Protection.IMediaProtectionServiceRequest} */
Windows.Media.Protection.ServiceRequestedEventArgs.prototype.request;

/** @typedef {function(?): void} */
Windows.Media.Protection.ComponentLoadFailedEventHandler;

/** @typedef {function(!Windows.WinRTEvent<!Windows.Media.Protection.MediaProtectionManager>): void} */
Windows.Media.Protection.RebootNeededEventHandler;

/** @typedef {function(?): void} */
Windows.Media.Protection.ServiceRequestedEventHandler;
/**
 * @record
 * @struct
 */
Windows.Media.Protection.IMediaProtectionServiceRequest = function() {};
 /** @type {string} */
Windows.Media.Protection.IMediaProtectionServiceRequest.prototype.protectionSystem;
 /** @type {string} */
Windows.Media.Protection.IMediaProtectionServiceRequest.prototype.type;
/** @const */
Windows.Media.Render = {};

/** @const */
Windows.Media.Render.AudioRenderCategory = {};
/** @const {number} */
Windows.Media.Render.AudioRenderCategory.other;
/** @const {number} */
Windows.Media.Render.AudioRenderCategory.foregroundOnlyMedia;
/** @const {number} */
Windows.Media.Render.AudioRenderCategory.backgroundCapableMedia;
/** @const {number} */
Windows.Media.Render.AudioRenderCategory.communications;
/** @const {number} */
Windows.Media.Render.AudioRenderCategory.alerts;
/** @const {number} */
Windows.Media.Render.AudioRenderCategory.soundEffects;
/** @const {number} */
Windows.Media.Render.AudioRenderCategory.gameEffects;
/** @const {number} */
Windows.Media.Render.AudioRenderCategory.gameMedia;
/** @const {number} */
Windows.Media.Render.AudioRenderCategory.gameChat;
/** @const {number} */
Windows.Media.Render.AudioRenderCategory.speech;
/** @const {number} */
Windows.Media.Render.AudioRenderCategory.movie;
/** @const {number} */
Windows.Media.Render.AudioRenderCategory.media;
/**
 * @constructor
 * @struct
 */
Windows.Media.ShuffleEnabledChangeRequestedEventArgs = function() {};
 /** @type {boolean} */
Windows.Media.ShuffleEnabledChangeRequestedEventArgs.prototype.requestedShuffleEnabled;

/** @const */
Windows.Media.SoundLevel = {};
/** @const {number} */
Windows.Media.SoundLevel.muted;
/** @const {number} */
Windows.Media.SoundLevel.low;
/** @const {number} */
Windows.Media.SoundLevel.full;
/** @const */
Windows.Media.SpeechRecognition = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs = function() {};
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus} */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs.prototype.status;

/** @const */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionMode = {};
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionMode.default;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionMode.pauseOnRecognition;
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionResultGeneratedEventArgs = function() {};
 /** @type {!Windows.Media.SpeechRecognition.SpeechRecognitionResult} */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionResultGeneratedEventArgs.prototype.result;
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession = function() {};
 /** @type {number} */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession.prototype.autoStopSilenceTimeout;
 /** @type {function(?): void} */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession.prototype.oncompleted;
 /** @type {function(?): void} */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession.prototype.onresultgenerated;

/**
 * Asynchronously cancel the continuous speech recognition session and discard all pending recognition results.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous handler called when the operation is complete.
 */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession.prototype.cancelAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession.prototype.removeEventListener = function(type, listener) {};

/**
 * Asynchronously pause a continuous speech recognition session.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous handler called when the operation is complete.
 */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession.prototype.pauseAsync = function() {};

/**
 * Resumes a continuous speech recognition session, if paused.
 * @return {void}
 */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession.prototype.resume = function() {};

/**
 * Overload
 * Overload
 * @param {Windows.Media.SpeechRecognition.SpeechContinuousRecognitionMode=} mode The speech recognition behavior.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous handler called when the operation is complete.
 */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession.prototype.startAsync = function(mode) {};

/**
 * Asynchronously end a continuous speech recognition session and pass all pending recognition results to the ResultGenerated event.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous handler called when the operation is complete.
 */
Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession.prototype.stopAsync = function() {};

/** @const */
Windows.Media.SpeechRecognition.SpeechRecognitionAudioProblem = {};
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionAudioProblem.none;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionAudioProblem.tooNoisy;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionAudioProblem.noSignal;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionAudioProblem.tooLoud;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionAudioProblem.tooQuiet;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionAudioProblem.tooFast;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionAudioProblem.tooSlow;
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult = function() {};
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus} */
Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult.prototype.status;

/** @const */
Windows.Media.SpeechRecognition.SpeechRecognitionConfidence = {};
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionConfidence.high;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionConfidence.medium;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionConfidence.low;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionConfidence.rejected;

/** @const */
Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability = {};
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability.default;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability.min;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability.max;

/** @const */
Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType = {};
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType.topic;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType.list;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType.grammar;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType.voiceCommandDefinition;

/**
 * @constructor
 * @struct
 * Creates an instance of the SpeechRecognitionGrammarFileConstraint class from a file object.
 * Creates an instance of the SpeechRecognitionGrammarFileConstraint class from a file object and a tag.
 * @param {!Windows.Storage.StorageFile} file An object representing a SRGS grammar file.
 * @param {string=} tag The tag to assign to the constraint.
 */
Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint = function(file, tag) {};
 /** @type {!Windows.Storage.StorageFile} */
Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint.prototype.grammarFile;
 /** @type {boolean} */
Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint.prototype.isEnabled;
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability} */
Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint.prototype.probability;
 /** @type {string} */
Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint.prototype.tag;
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType} */
Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint.prototype.type;
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechRecognition.SpeechRecognitionHypothesis = function() {};
 /** @type {string} */
Windows.Media.SpeechRecognition.SpeechRecognitionHypothesis.prototype.text;
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechRecognition.SpeechRecognitionHypothesisGeneratedEventArgs = function() {};
 /** @type {!Windows.Media.SpeechRecognition.SpeechRecognitionHypothesis} */
Windows.Media.SpeechRecognition.SpeechRecognitionHypothesisGeneratedEventArgs.prototype.hypothesis;

/**
 * @constructor
 * @struct
 * Creates an instance of the SpeechRecognitionListConstraint class from an array of words or phrases.
 * Creates an instance of the SpeechRecognitionListConstraint class from an array of words or phrases and a tag.
 * @param {!Windows.Foundation.Collections.IIterable<string>} commands A string array of words or phrases that make up the constraint.
 * @param {string=} tag The tag to assign to the constraint.
 */
Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint = function(commands, tag) {};
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint.prototype.commands;
 /** @type {boolean} */
Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint.prototype.isEnabled;
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability} */
Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint.prototype.probability;
 /** @type {string} */
Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint.prototype.tag;
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType} */
Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint.prototype.type;
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechRecognition.SpeechRecognitionQualityDegradingEventArgs = function() {};
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionAudioProblem} */
Windows.Media.SpeechRecognition.SpeechRecognitionQualityDegradingEventArgs.prototype.problem;
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechRecognition.SpeechRecognitionResult = function() {};
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionConfidence} */
Windows.Media.SpeechRecognition.SpeechRecognitionResult.prototype.confidence;
 /** @type {!Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint} */
Windows.Media.SpeechRecognition.SpeechRecognitionResult.prototype.constraint;
 /** @type {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionResult.prototype.phraseDuration;
 /** @type {!Date} */
Windows.Media.SpeechRecognition.SpeechRecognitionResult.prototype.phraseStartTime;
 /** @type {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionResult.prototype.rawConfidence;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Media.SpeechRecognition.SpeechRecognitionResult.prototype.rulePath;
 /** @type {!Windows.Media.SpeechRecognition.SpeechRecognitionSemanticInterpretation} */
Windows.Media.SpeechRecognition.SpeechRecognitionResult.prototype.semanticInterpretation;
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus} */
Windows.Media.SpeechRecognition.SpeechRecognitionResult.prototype.status;
 /** @type {string} */
Windows.Media.SpeechRecognition.SpeechRecognitionResult.prototype.text;

/**
 * Gets a collection of recognition result alternatives, ordered by RawConfidence from most likely to least likely. The first item in the collection is the recognition result indicated by the parent object.
 * @param {number} maxAlternates The maximum number of speech recognition results to return in the collection.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Media.SpeechRecognition.SpeechRecognitionResult>} A collection of speech recognition results, ordered by confidence from most likely to least likely.
 */
Windows.Media.SpeechRecognition.SpeechRecognitionResult.prototype.getAlternates = function(maxAlternates) {};

/** @const */
Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus = {};
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus.success;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus.topicLanguageNotSupported;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus.grammarLanguageMismatch;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus.grammarCompilationFailure;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus.audioQualityFailure;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus.userCanceled;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus.unknown;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus.timeoutExceeded;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus.pauseLimitExceeded;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus.networkFailure;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus.microphoneUnavailable;

/** @const */
Windows.Media.SpeechRecognition.SpeechRecognitionScenario = {};
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionScenario.webSearch;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionScenario.dictation;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognitionScenario.formFilling;
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechRecognition.SpeechRecognitionSemanticInterpretation = function() {};
 /** @type {!Windows.Foundation.Collections.IMapView<string, !Windows.Foundation.Collections.IVectorView<?>>} */
Windows.Media.SpeechRecognition.SpeechRecognitionSemanticInterpretation.prototype.properties;

/**
 * @constructor
 * @struct
 * Creates an instance of the SpeechRecognitionTopicConstraint class by using a pre-defined scenario type, context, and an identifier.
 * Creates an instance of the SpeechRecognitionTopicConstraint class by using a pre-defined scenario type and context.
 * @param {Windows.Media.SpeechRecognition.SpeechRecognitionScenario} scenario A predefined scenario type.
 * @param {string} topicHint A subject, or context hint, used to optimize recognition.
 * @param {string=} tag Identifier for the constraint.
 */
Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint = function(scenario, topicHint, tag) {};
 /** @type {boolean} */
Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint.prototype.isEnabled;
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability} */
Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint.prototype.probability;
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionScenario} */
Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint.prototype.scenario;
 /** @type {string} */
Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint.prototype.tag;
 /** @type {string} */
Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint.prototype.topicHint;
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType} */
Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint.prototype.type;
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint = function() {};
 /** @type {boolean} */
Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint.prototype.isEnabled;
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability} */
Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint.prototype.probability;
 /** @type {string} */
Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint.prototype.tag;
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType} */
Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint.prototype.type;

/**
 * @constructor
 * @struct
 * Creates a new instance of the SpeechRecognizer class.
 * Creates a new instance of the SpeechRecognizer class with a language specifier.
 * @param {!Windows.Globalization.Language=} language The spoken language to use for recognition.
 */
Windows.Media.SpeechRecognition.SpeechRecognizer = function(language) {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Globalization.Language>} */
Windows.Media.SpeechRecognition.SpeechRecognizer.supportedGrammarLanguages;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Globalization.Language>} */
Windows.Media.SpeechRecognition.SpeechRecognizer.supportedTopicLanguages;
 /** @type {!Windows.Globalization.Language} */
Windows.Media.SpeechRecognition.SpeechRecognizer.systemSpeechLanguage;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint>} */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.constraints;
 /** @type {!Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession} */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.continuousRecognitionSession;
 /** @type {!Windows.Globalization.Language} */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.currentLanguage;
 /** @type {function(?): void} */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.onhypothesisgenerated;
 /** @type {function(?): void} */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.onrecognitionqualitydegrading;
 /** @type {function(?): void} */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.onstatechanged;
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognizerState} */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.state;
 /** @type {!Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts} */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.timeouts;
 /** @type {!Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions} */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.uiOptions;

/**
 * Disposes the speech recognizer by freeing, releasing, or resetting allocated resources.
 * @return {void}
 */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.close = function() {};

/**
 * Asynchronously compile all constraints specified by the Constraints property.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult>>} The result of the constraints compilation as a SpeechRecognitionCompilationResult object.
 */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.compileConstraintsAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.removeEventListener = function(type, listener) {};

/**
 * Begins a speech recognition session for a SpeechRecognizer object.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.SpeechRecognition.SpeechRecognitionResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.SpeechRecognition.SpeechRecognitionResult>>} The result of the speech recognition session that was initiated by the SpeechRecognizer object.
 */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.recognizeAsync = function() {};

/**
 * Asynchronously starts a speech recognition session that includes additional UI mechanisms, including prompts, examples, text-to-speech (TTS), and confirmations.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.SpeechRecognition.SpeechRecognitionResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.SpeechRecognition.SpeechRecognitionResult>>} The result of the speech recognition session as a SpeechRecognitionResult object.
 */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.recognizeWithUIAsync = function() {};

/**
 * Asynchronously ends the speech recognition session.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Media.SpeechRecognition.SpeechRecognizer.prototype.stopRecognitionAsync = function() {};

/** @const */
Windows.Media.SpeechRecognition.SpeechRecognizerState = {};
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognizerState.idle;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognizerState.capturing;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognizerState.processing;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognizerState.soundStarted;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognizerState.soundEnded;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognizerState.speechDetected;
/** @const {number} */
Windows.Media.SpeechRecognition.SpeechRecognizerState.paused;
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechRecognition.SpeechRecognizerStateChangedEventArgs = function() {};
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognizerState} */
Windows.Media.SpeechRecognition.SpeechRecognizerStateChangedEventArgs.prototype.state;
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts = function() {};
 /** @type {number} */
Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts.prototype.babbleTimeout;
 /** @type {number} */
Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts.prototype.endSilenceTimeout;
 /** @type {number} */
Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts.prototype.initialSilenceTimeout;
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions = function() {};
 /** @type {string} */
Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions.prototype.audiblePrompt;
 /** @type {string} */
Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions.prototype.exampleText;
 /** @type {boolean} */
Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions.prototype.isReadBackEnabled;
 /** @type {boolean} */
Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions.prototype.showConfirmation;
/**
 * @record
 * @struct
 */
Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint = function() {};
 /** @type {boolean} */
Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint.prototype.isEnabled;
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability} */
Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint.prototype.probability;
 /** @type {string} */
Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint.prototype.tag;
 /** @type {Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType} */
Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint.prototype.type;
/** @const */
Windows.Media.SpeechSynthesis = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream = function() {};
 /** @type {boolean} */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream.prototype.canRead;
 /** @type {boolean} */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream.prototype.canWrite;
 /** @type {string} */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream.prototype.contentType;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.IMediaMarker>} */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream.prototype.markers;
 /** @type {number} */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream.prototype.position;
 /** @type {number} */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream.prototype.size;

/**
 * Creates a copy of SpeechSynthesisStream that references the same bytes as the original stream.
 * @return {!Windows.Storage.Streams.IRandomAccessStream} The new stream.
 */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream.prototype.cloneStream = function() {};

/**
 * Releases system resources that are exposed by SpeechSynthesisStream .
 * @return {void}
 */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream.prototype.close = function() {};

/**
 * Flushes data asynchronously in a sequential stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An asynchronous operation. For more information, see FlushAsync method.
 */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream.prototype.flushAsync = function() {};

/**
 * Retrieves an input stream at a specified location in SpeechSynthesisStream .
 * @param {number} position The location in the stream at which to begin.
 * @return {!Windows.Storage.Streams.IInputStream} The input stream.
 */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream.prototype.getInputStreamAt = function(position) {};

/**
 * Retrieves an output stream at a specified location in SpeechSynthesisStream .
 * @param {number} position The location in the stream at which to begin.
 * @return {!Windows.Storage.Streams.IOutputStream} The output stream.
 */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream.prototype.getOutputStreamAt = function(position) {};

/**
 * Reads data asynchronously in a sequential stream.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param {number} count The number of bytes to read that is less than or equal to the Capacity value.
 * @param {Windows.Storage.Streams.InputStreamOptions} options Specifies the type of the asynchronous read operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} An asynchronous operation that includes progress updates. For more information, see ReadAsync method.
 */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream.prototype.readAsync = function(buffer, count, options) {};

/**
 * Goes to the specified position within SpeechSynthesisStream .
 * @param {number} position The desired position within the stream.
 * @return {void}
 */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream.prototype.seek = function(position) {};

/**
 * Writes data asynchronously in a sequential stream.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous writer operation places the bytes to write.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} An asynchronous operation that includes progress updates. For more information, see WriteAsync method.
 */
Windows.Media.SpeechSynthesis.SpeechSynthesisStream.prototype.writeAsync = function(buffer) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of a SpeechSynthesizer object.
 */
Windows.Media.SpeechSynthesis.SpeechSynthesizer = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Media.SpeechSynthesis.VoiceInformation>} */
Windows.Media.SpeechSynthesis.SpeechSynthesizer.allVoices;
 /** @type {!Windows.Media.SpeechSynthesis.VoiceInformation} */
Windows.Media.SpeechSynthesis.SpeechSynthesizer.defaultVoice;
 /** @type {!Windows.Media.SpeechSynthesis.VoiceInformation} */
Windows.Media.SpeechSynthesis.SpeechSynthesizer.prototype.voice;

/**
 * Closes the SpeechSynthesizer and releases system resources.
 * @return {void}
 */
Windows.Media.SpeechSynthesis.SpeechSynthesizer.prototype.close = function() {};

/**
 * Asynchronously generate speech output from a string containing Speech Synthesis Markup Language (SSML).
 * @param {string} Ssml The SSML-modified text to speak.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.SpeechSynthesis.SpeechSynthesisStream, !Windows.Foundation.IAsyncOperation<!Windows.Media.SpeechSynthesis.SpeechSynthesisStream>>} A SpeechSynthesisStream that represents the speech generated from the Speech Synthesis Markup Language (SSML).
 */
Windows.Media.SpeechSynthesis.SpeechSynthesizer.prototype.synthesizeSsmlToStreamAsync = function(Ssml) {};

/**
 * Asynchronously generate speech output from a string.
 * @param {string} text The text to speak.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.SpeechSynthesis.SpeechSynthesisStream, !Windows.Foundation.IAsyncOperation<!Windows.Media.SpeechSynthesis.SpeechSynthesisStream>>} A SpeechSynthesisStream that represents the speech generated from the text.
 */
Windows.Media.SpeechSynthesis.SpeechSynthesizer.prototype.synthesizeTextToStreamAsync = function(text) {};

/** @const */
Windows.Media.SpeechSynthesis.VoiceGender = {};
/** @const {number} */
Windows.Media.SpeechSynthesis.VoiceGender.male;
/** @const {number} */
Windows.Media.SpeechSynthesis.VoiceGender.female;
/**
 * @constructor
 * @struct
 */
Windows.Media.SpeechSynthesis.VoiceInformation = function() {};
 /** @type {string} */
Windows.Media.SpeechSynthesis.VoiceInformation.prototype.description;
 /** @type {string} */
Windows.Media.SpeechSynthesis.VoiceInformation.prototype.displayName;
 /** @type {Windows.Media.SpeechSynthesis.VoiceGender} */
Windows.Media.SpeechSynthesis.VoiceInformation.prototype.gender;
 /** @type {string} */
Windows.Media.SpeechSynthesis.VoiceInformation.prototype.id;
 /** @type {string} */
Windows.Media.SpeechSynthesis.VoiceInformation.prototype.language;
/** @const */
Windows.Media.Streaming = {};
/** @const */
Windows.Media.Streaming.Adaptive = {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource = function() {};
 /** @type {?} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.advancedSettings;
 /** @type {boolean} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.audioOnlyPlayback;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.availableBitrates;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.currentDownloadBitrate;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.currentPlaybackBitrate;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.desiredLiveOffset;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.desiredMaxBitrate;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.desiredMinBitrate;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.inboundBitsPerSecond;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.inboundBitsPerSecondWindow;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.initialBitrate;
 /** @type {boolean} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.isLive;
 /** @type {function(?): void} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.ondownloadbitratechanged;
 /** @type {function(?): void} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.ondownloadcompleted;
 /** @type {function(?): void} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.ondownloadfailed;
 /** @type {function(?): void} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.ondownloadrequested;
 /** @type {function(?): void} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.onplaybackbitratechanged;

/**
 * Asynchronously creates a AdaptiveMediaSource object from the provided input stream.
 * Asynchronously creates a AdaptiveMediaSource object from the provided input stream.
 * @param {!Windows.Storage.Streams.IInputStream} stream The input stream from which the AdaptiveMediaSource is created.
 * @param {!Windows.Foundation.Uri} uri The URI of the source. This is used by the AdaptiveMediaSource to resolve relative URIs.
 * @param {string} contentType A string that identifies the MIME content type of the source. This can be an Http Live Streaming (HLS) or a Dynamic Adaptive Streaming over HTTP (DASH) content type.
 * @param {!Windows.Web.Http.HttpClient=} httpClient The HttpClient instance that the AdaptiveMediaSource should use for downloading resources. This allows you to specify custom HTTP headers for the requests.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult>>} Returns an AdaptiveMediaSourceCreationResult upon successful completion.
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.createFromStreamAsync = function(stream, uri, contentType, httpClient) {};

/**
 * Asynchronously creates a AdaptiveMediaSource object from the Uniform Resource Identifier (URI) of the source.
 * Asynchronously creates a AdaptiveMediaSource object from the Uniform Resource Identifier (URI) of the source.
 * @param {!Windows.Foundation.Uri} uri T he URI of the source.
 * @param {!Windows.Web.Http.HttpClient=} httpClient The HttpClient instance that the AdaptiveMediaSource should use for downloading resources. This allows you to specify custom HTTP headers for the requests.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult>>} Returns an AdaptiveMediaSourceCreationResult upon successful completion.
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.createFromUriAsync = function(uri, httpClient) {};

/**
 * Determines whether the content type of the source is supported.
 * @param {string} contentType A string that identifies the content type of the source. Can be a Http Live Streaming (HLS) or Dynamic Adaptive Streaming over HTTP (DASH) content type.
 * @return {boolean} Returns a value that indicates whether the content type of the source is supported. true if supported; otherwise, false.
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.isContentTypeSupported = function(contentType) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSource.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceAdvancedSettings = function() {};
 /** @type {?} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceAdvancedSettings.prototype.allSegmentsIndependent;
 /** @type {?} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceAdvancedSettings.prototype.bitrateDowngradeTriggerRatio;
 /** @type {?} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceAdvancedSettings.prototype.desiredBitrateHeadroomRatio;
/**
 * @constructor
 * @struct
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult = function() {};
 /** @type {!Windows.Web.Http.HttpResponseMessage} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult.prototype.httpResponseMessage;
 /** @type {!Windows.Media.Streaming.Adaptive.AdaptiveMediaSource} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult.prototype.mediaSource;
 /** @type {Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationStatus} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult.prototype.status;

/** @const */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationStatus = {};
/** @const {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationStatus.success;
/** @const {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationStatus.manifestDownloadFailure;
/** @const {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationStatus.manifestParseFailure;
/** @const {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationStatus.unsupportedManifestContentType;
/** @const {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationStatus.unsupportedManifestVersion;
/** @const {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationStatus.unsupportedManifestProfile;
/** @const {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationStatus.unknownFailure;
/**
 * @constructor
 * @struct
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadBitrateChangedEventArgs = function() {};
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadBitrateChangedEventArgs.prototype.newValue;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadBitrateChangedEventArgs.prototype.oldValue;
/**
 * @constructor
 * @struct
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs = function() {};
 /** @type {!Windows.Web.Http.HttpResponseMessage} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs.prototype.httpResponseMessage;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs.prototype.resourceByteRangeLength;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs.prototype.resourceByteRangeOffset;
 /** @type {Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceResourceType} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs.prototype.resourceType;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs.prototype.resourceUri;
/**
 * @constructor
 * @struct
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs = function() {};
 /** @type {!Windows.Web.Http.HttpResponseMessage} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs.prototype.httpResponseMessage;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs.prototype.resourceByteRangeLength;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs.prototype.resourceByteRangeOffset;
 /** @type {Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceResourceType} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs.prototype.resourceType;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs.prototype.resourceUri;
/**
 * @constructor
 * @struct
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedDeferral = function() {};

/**
 * Informs the system that an asynchronous operation associated with a DownloadRequested event has finished.
 * @return {void}
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs = function() {};
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs.prototype.resourceByteRangeLength;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs.prototype.resourceByteRangeOffset;
 /** @type {Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceResourceType} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs.prototype.resourceType;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs.prototype.resourceUri;
 /** @type {!Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs.prototype.result;

/**
 * Gets a deferral that can be used to defer the completion of the DownloadRequested event so that the app can asynchronously download media content.
 * @return {!Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedDeferral} A deferral that can be used to defer the completion of the DownloadRequested event.
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult.prototype.buffer;
 /** @type {string} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult.prototype.contentType;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult.prototype.extendedStatus;
 /** @type {!Windows.Storage.Streams.IInputStream} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult.prototype.inputStream;
 /** @type {!Windows.Foundation.Uri} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult.prototype.resourceUri;
/**
 * @constructor
 * @struct
 */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs = function() {};
 /** @type {boolean} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs.prototype.audioOnly;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs.prototype.newValue;
 /** @type {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs.prototype.oldValue;

/** @const */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceResourceType = {};
/** @const {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceResourceType.manifest;
/** @const {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceResourceType.initializationSegment;
/** @const {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceResourceType.mediaSegment;
/** @const {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceResourceType.key;
/** @const {number} */
Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceResourceType.initializationVector;
/**
 * @constructor
 * @struct
 */
Windows.Media.SystemMediaTransportControls = function() {};
 /** @type {Windows.Media.MediaPlaybackAutoRepeatMode} */
Windows.Media.SystemMediaTransportControls.prototype.autoRepeatMode;
 /** @type {!Windows.Media.SystemMediaTransportControlsDisplayUpdater} */
Windows.Media.SystemMediaTransportControls.prototype.displayUpdater;
 /** @type {boolean} */
Windows.Media.SystemMediaTransportControls.prototype.isChannelDownEnabled;
 /** @type {boolean} */
Windows.Media.SystemMediaTransportControls.prototype.isChannelUpEnabled;
 /** @type {boolean} */
Windows.Media.SystemMediaTransportControls.prototype.isEnabled;
 /** @type {boolean} */
Windows.Media.SystemMediaTransportControls.prototype.isFastForwardEnabled;
 /** @type {boolean} */
Windows.Media.SystemMediaTransportControls.prototype.isNextEnabled;
 /** @type {boolean} */
Windows.Media.SystemMediaTransportControls.prototype.isPauseEnabled;
 /** @type {boolean} */
Windows.Media.SystemMediaTransportControls.prototype.isPlayEnabled;
 /** @type {boolean} */
Windows.Media.SystemMediaTransportControls.prototype.isPreviousEnabled;
 /** @type {boolean} */
Windows.Media.SystemMediaTransportControls.prototype.isRecordEnabled;
 /** @type {boolean} */
Windows.Media.SystemMediaTransportControls.prototype.isRewindEnabled;
 /** @type {boolean} */
Windows.Media.SystemMediaTransportControls.prototype.isStopEnabled;
 /** @type {function(?): void} */
Windows.Media.SystemMediaTransportControls.prototype.onautorepeatmodechangerequested;
 /** @type {function(?): void} */
Windows.Media.SystemMediaTransportControls.prototype.onbuttonpressed;
 /** @type {function(?): void} */
Windows.Media.SystemMediaTransportControls.prototype.onplaybackpositionchangerequested;
 /** @type {function(?): void} */
Windows.Media.SystemMediaTransportControls.prototype.onplaybackratechangerequested;
 /** @type {function(?): void} */
Windows.Media.SystemMediaTransportControls.prototype.onpropertychanged;
 /** @type {function(?): void} */
Windows.Media.SystemMediaTransportControls.prototype.onshuffleenabledchangerequested;
 /** @type {number} */
Windows.Media.SystemMediaTransportControls.prototype.playbackRate;
 /** @type {Windows.Media.MediaPlaybackStatus} */
Windows.Media.SystemMediaTransportControls.prototype.playbackStatus;
 /** @type {boolean} */
Windows.Media.SystemMediaTransportControls.prototype.shuffleEnabled;
 /** @type {Windows.Media.SoundLevel} */
Windows.Media.SystemMediaTransportControls.prototype.soundLevel;

/**
 * The system transport controls for the current view.
 * @return {!Windows.Media.SystemMediaTransportControls} The system transport controls for the current view.
 */
Windows.Media.SystemMediaTransportControls.getForCurrentView = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.SystemMediaTransportControls.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Media.SystemMediaTransportControls.prototype.removeEventListener = function(type, listener) {};

/**
 * Updates the SystemMediaTransportControls timeline properties with the values in the provided object.
 * @param {!Windows.Media.SystemMediaTransportControlsTimelineProperties} timelineProperties The object representing the new timeline property values.
 * @return {void}
 */
Windows.Media.SystemMediaTransportControls.prototype.updateTimelineProperties = function(timelineProperties) {};

/** @const */
Windows.Media.SystemMediaTransportControlsButton = {};
/** @const {number} */
Windows.Media.SystemMediaTransportControlsButton.play;
/** @const {number} */
Windows.Media.SystemMediaTransportControlsButton.pause;
/** @const {number} */
Windows.Media.SystemMediaTransportControlsButton.stop;
/** @const {number} */
Windows.Media.SystemMediaTransportControlsButton.record;
/** @const {number} */
Windows.Media.SystemMediaTransportControlsButton.fastForward;
/** @const {number} */
Windows.Media.SystemMediaTransportControlsButton.rewind;
/** @const {number} */
Windows.Media.SystemMediaTransportControlsButton.next;
/** @const {number} */
Windows.Media.SystemMediaTransportControlsButton.previous;
/** @const {number} */
Windows.Media.SystemMediaTransportControlsButton.channelUp;
/** @const {number} */
Windows.Media.SystemMediaTransportControlsButton.channelDown;
/**
 * @constructor
 * @struct
 */
Windows.Media.SystemMediaTransportControlsButtonPressedEventArgs = function() {};
 /** @type {Windows.Media.SystemMediaTransportControlsButton} */
Windows.Media.SystemMediaTransportControlsButtonPressedEventArgs.prototype.button;
/**
 * @constructor
 * @struct
 */
Windows.Media.SystemMediaTransportControlsDisplayUpdater = function() {};
 /** @type {string} */
Windows.Media.SystemMediaTransportControlsDisplayUpdater.prototype.appMediaId;
 /** @type {!Windows.Media.ImageDisplayProperties} */
Windows.Media.SystemMediaTransportControlsDisplayUpdater.prototype.imageProperties;
 /** @type {!Windows.Media.MusicDisplayProperties} */
Windows.Media.SystemMediaTransportControlsDisplayUpdater.prototype.musicProperties;
 /** @type {!Windows.Storage.Streams.RandomAccessStreamReference} */
Windows.Media.SystemMediaTransportControlsDisplayUpdater.prototype.thumbnail;
 /** @type {Windows.Media.MediaPlaybackType} */
Windows.Media.SystemMediaTransportControlsDisplayUpdater.prototype.type;
 /** @type {!Windows.Media.VideoDisplayProperties} */
Windows.Media.SystemMediaTransportControlsDisplayUpdater.prototype.videoProperties;

/**
 * Clears out all of the media metadata.
 * @return {void}
 */
Windows.Media.SystemMediaTransportControlsDisplayUpdater.prototype.clearAll = function() {};

/**
 * Initialize the media properties using the specified file.
 * @param {Windows.Media.MediaPlaybackType} type The type of media.
 * @param {!Windows.Storage.StorageFile} source The file to initialize the media properties.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} When this method completes, it returns a boolean value that indicates true if the operation succeeded; otherwise, false.
 */
Windows.Media.SystemMediaTransportControlsDisplayUpdater.prototype.copyFromFileAsync = function(type, source) {};

/**
 * Updates the metadata for the currently playing media.
 * @return {void}
 */
Windows.Media.SystemMediaTransportControlsDisplayUpdater.prototype.update = function() {};

/** @const */
Windows.Media.SystemMediaTransportControlsProperty = {};
/** @const {number} */
Windows.Media.SystemMediaTransportControlsProperty.soundLevel;
/**
 * @constructor
 * @struct
 */
Windows.Media.SystemMediaTransportControlsPropertyChangedEventArgs = function() {};
 /** @type {Windows.Media.SystemMediaTransportControlsProperty} */
Windows.Media.SystemMediaTransportControlsPropertyChangedEventArgs.prototype.property;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the SystemMediaTransportControlsTimelineProperties class.
 */
Windows.Media.SystemMediaTransportControlsTimelineProperties = function() {};
 /** @type {number} */
Windows.Media.SystemMediaTransportControlsTimelineProperties.prototype.endTime;
 /** @type {number} */
Windows.Media.SystemMediaTransportControlsTimelineProperties.prototype.maxSeekTime;
 /** @type {number} */
Windows.Media.SystemMediaTransportControlsTimelineProperties.prototype.minSeekTime;
 /** @type {number} */
Windows.Media.SystemMediaTransportControlsTimelineProperties.prototype.position;
 /** @type {number} */
Windows.Media.SystemMediaTransportControlsTimelineProperties.prototype.startTime;
/** @const */
Windows.Media.Transcoding = {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the MediaTranscoder class.
 */
Windows.Media.Transcoding.MediaTranscoder = function() {};
 /** @type {boolean} */
Windows.Media.Transcoding.MediaTranscoder.prototype.alwaysReencode;
 /** @type {boolean} */
Windows.Media.Transcoding.MediaTranscoder.prototype.hardwareAccelerationEnabled;
 /** @type {number} */
Windows.Media.Transcoding.MediaTranscoder.prototype.trimStartTime;
 /** @type {number} */
Windows.Media.Transcoding.MediaTranscoder.prototype.trimStopTime;
 /** @type {Windows.Media.Transcoding.MediaVideoProcessingAlgorithm} */
Windows.Media.Transcoding.MediaTranscoder.prototype.videoProcessingAlgorithm;

/**
 * Adds the specified audio effect with configuration properties, and indicates whether the effect is required.
 * Adds the specified audio effect.
 * @param {string} activatableClassId The identifier of the audio effect.
 * @param {boolean=} effectRequired Indicates whether the audio effect is required.
 * @param {!Windows.Foundation.Collections.IPropertySet=} configuration Configuration properties for the audio effect.
 * @return {void}
 */
Windows.Media.Transcoding.MediaTranscoder.prototype.addAudioEffect = function(activatableClassId, effectRequired, configuration) {};

/**
 * Adds the specified video effect.
 * Adds the specified video effect with configuration properties and indicates whether the effect is required.
 * @param {string} activatableClassId The identifier of the video effect.
 * @param {boolean=} effectRequired Indicates whether the video effect is required.
 * @param {!Windows.Foundation.Collections.IPropertySet=} configuration Configuration properties for the video effect.
 * @return {void}
 */
Windows.Media.Transcoding.MediaTranscoder.prototype.addVideoEffect = function(activatableClassId, effectRequired, configuration) {};

/**
 * Removes all audio and video effects from the transcode session.
 * @return {void}
 */
Windows.Media.Transcoding.MediaTranscoder.prototype.clearEffects = function() {};

/**
 * Asynchronously initializes the trancode operation on the specified file and returns a PrepareTranscodeResult object which can be used to start the transcode operation.
 * @param {!Windows.Storage.IStorageFile} source The source file.
 * @param {!Windows.Storage.IStorageFile} destination The destination file.
 * @param {!Windows.Media.MediaProperties.MediaEncodingProfile} profile The profile to use for the operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Transcoding.PrepareTranscodeResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Transcoding.PrepareTranscodeResult>>} When this method completes, a PrepareTranscodeResult object is returned which can be used to start the transcode.
 */
Windows.Media.Transcoding.MediaTranscoder.prototype.prepareFileTranscodeAsync = function(source, destination, profile) {};

/**
 * Asynchronously initializes the trancode operation on the specified media source and returns a PrepareTranscodeResult object which can be used to start the transcode operation.
 * @param {!Windows.Media.Core.IMediaSource} source The media source to perform the transcode operation on.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} destination The destination stream for the transcoded media data.
 * @param {!Windows.Media.MediaProperties.MediaEncodingProfile} profile The profile to use for the operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Transcoding.PrepareTranscodeResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Transcoding.PrepareTranscodeResult>>} When this method completes, a PrepareTranscodeResult object is returned which can be used to start the transcode.
 */
Windows.Media.Transcoding.MediaTranscoder.prototype.prepareMediaStreamSourceTranscodeAsync = function(source, destination, profile) {};

/**
 * Asynchronously initializes the trancode operation on the specified stream and returns a PrepareTranscodeResult object which can be used to start the transcode operation.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} source The source stream.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} destination The destination stream.
 * @param {!Windows.Media.MediaProperties.MediaEncodingProfile} profile The profile to use for the operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Media.Transcoding.PrepareTranscodeResult, !Windows.Foundation.IAsyncOperation<!Windows.Media.Transcoding.PrepareTranscodeResult>>} When this method completes, a PrepareTranscodeResult object is returned which can be used to start the transcode.
 */
Windows.Media.Transcoding.MediaTranscoder.prototype.prepareStreamTranscodeAsync = function(source, destination, profile) {};

/** @const */
Windows.Media.Transcoding.MediaVideoProcessingAlgorithm = {};
/** @const {number} */
Windows.Media.Transcoding.MediaVideoProcessingAlgorithm.default;
/** @const {number} */
Windows.Media.Transcoding.MediaVideoProcessingAlgorithm.mrfCrf444;
/**
 * @constructor
 * @struct
 */
Windows.Media.Transcoding.PrepareTranscodeResult = function() {};
 /** @type {boolean} */
Windows.Media.Transcoding.PrepareTranscodeResult.prototype.canTranscode;
 /** @type {Windows.Media.Transcoding.TranscodeFailureReason} */
Windows.Media.Transcoding.PrepareTranscodeResult.prototype.failureReason;

/**
 * Creates an object to perform an asynchronous media transcode operation on media data.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncActionWithProgress<number>>} An object that is used to control the asynchronous operation.
 */
Windows.Media.Transcoding.PrepareTranscodeResult.prototype.transcodeAsync = function() {};

/** @const */
Windows.Media.Transcoding.TranscodeFailureReason = {};
/** @const {number} */
Windows.Media.Transcoding.TranscodeFailureReason.none;
/** @const {number} */
Windows.Media.Transcoding.TranscodeFailureReason.unknown;
/** @const {number} */
Windows.Media.Transcoding.TranscodeFailureReason.invalidProfile;
/** @const {number} */
Windows.Media.Transcoding.TranscodeFailureReason.codecNotFound;
/**
 * @constructor
 * @struct
 */
Windows.Media.VideoDisplayProperties = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Media.VideoDisplayProperties.prototype.genres;
 /** @type {string} */
Windows.Media.VideoDisplayProperties.prototype.subtitle;
 /** @type {string} */
Windows.Media.VideoDisplayProperties.prototype.title;
/**
 * @constructor
 * @struct
 */
Windows.Media.VideoEffects = function() {};
 /** @type {string} */
Windows.Media.VideoEffects.videoStabilization;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the VideoFrame class.
 * Initializes a new instance of the VideoFrame class.
 * @param {Windows.Graphics.Imaging.BitmapPixelFormat} format The pixel format of the video frame.
 * @param {number} width The width of the video frame, in pixels.
 * @param {number} height The height of the video frame, in pixels.
 * @param {Windows.Graphics.Imaging.BitmapAlphaMode=} alpha The alpha mode of the video frame.
 */
Windows.Media.VideoFrame = function(format, width, height, alpha) {};
 /** @type {!Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface} */
Windows.Media.VideoFrame.prototype.direct3DSurface;
 /** @type {number} */
Windows.Media.VideoFrame.prototype.duration;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Media.VideoFrame.prototype.extendedProperties;
 /** @type {boolean} */
Windows.Media.VideoFrame.prototype.isDiscontinuous;
 /** @type {boolean} */
Windows.Media.VideoFrame.prototype.isReadOnly;
 /** @type {number} */
Windows.Media.VideoFrame.prototype.relativeTime;
 /** @type {!Windows.Graphics.Imaging.SoftwareBitmap} */
Windows.Media.VideoFrame.prototype.softwareBitmap;
 /** @type {number} */
Windows.Media.VideoFrame.prototype.systemRelativeTime;
 /** @type {string} */
Windows.Media.VideoFrame.prototype.type;

/**
 * Disposes of the object and associated resources.
 * @return {void}
 */
Windows.Media.VideoFrame.prototype.close = function() {};

/**
 * Copies the current VideoFrame into a provided VideoFrame object.
 * @param {!Windows.Media.VideoFrame} frame The target video frame into which the current frame will be copied.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.Media.VideoFrame.prototype.copyToAsync = function(frame) {};
/**
 * @record
 * @struct
 */
Windows.Media.IMediaExtension = function() {};

/**
 * Sets the configuration properties that were supplied when the media parser or codec was registered.
 * @param {!Windows.Foundation.Collections.IPropertySet} configuration The configuration properties for the media parser or codec.
 * @return {void}
 */
Windows.Media.IMediaExtension.prototype.setProperties = function(configuration) {};
/**
 * @record
 * @struct
 */
Windows.Media.IMediaMarker = function() {};
 /** @type {string} */
Windows.Media.IMediaMarker.prototype.mediaMarkerType;
 /** @type {string} */
Windows.Media.IMediaMarker.prototype.text;
 /** @type {number} */
Windows.Media.IMediaMarker.prototype.time;
/** @const */
Windows.Networking.BackgroundTransfer = {};

/**
 * @constructor
 * @struct
 * Creates a new BackgroundDownloader object.
 * Creates a new BackgroundDownloader object with a BackgroundTransferCompletionGroup .
 * @param {!Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup=} completionGroup The completion group to associate with this BackgroundDownloader object.
 */
Windows.Networking.BackgroundTransfer.BackgroundDownloader = function(completionGroup) {};
 /** @type {!Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup} */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.prototype.completionGroup;
 /** @type {Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy} */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.prototype.costPolicy;
 /** @type {!Windows.UI.Notifications.TileNotification} */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.prototype.failureTileNotification;
 /** @type {!Windows.UI.Notifications.ToastNotification} */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.prototype.failureToastNotification;
 /** @type {string} */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.prototype.group;
 /** @type {string} */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.prototype.method;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.prototype.proxyCredential;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.prototype.serverCredential;
 /** @type {!Windows.UI.Notifications.TileNotification} */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.prototype.successTileNotification;
 /** @type {!Windows.UI.Notifications.ToastNotification} */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.prototype.successToastNotification;
 /** @type {!Windows.Networking.BackgroundTransfer.BackgroundTransferGroup} */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.prototype.transferGroup;

/**
 * Returns a collection of pending downloads that are not associated with a group.
 * Returns a collection of pending downloads for a specific Group .
 * @param {string=} group A string indicating a specific group of transfers.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A collection of pending downloads for the current application instance. / A collection of pending downloads for the specific group.
 */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.getCurrentDownloadsAsync = function(group) {};

/**
 * Gets all downloads associated with the provided BackgroundTransferGroup .
 * @param {!Windows.Networking.BackgroundTransfer.BackgroundTransferGroup} group Contains information used to identify a group of downloads.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A list of downloads currently associated with the specified group.
 */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.getCurrentDownloadsForTransferGroupAsync = function(group) {};

/**
 * Used to request an unconstrained download operation. When this method is called the user is provided with a UI prompt that they can use to indicate their consent for an unconstrained operation.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Networking.BackgroundTransfer.DownloadOperation>} operations The download operation to run unconstrained.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.BackgroundTransfer.UnconstrainedTransferRequestResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.BackgroundTransfer.UnconstrainedTransferRequestResult>>} Indicates if the operations will run unconstrained.
 */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.requestUnconstrainedDownloadsAsync = function(operations) {};

/**
 * Initializes a DownloadOperation object that contains the specified Uri and the file that the response is written to.
 * Initializes a DownloadOperation object with the resource Uri , the file that the response is written to, and the request entity body.
 * @param {!Windows.Foundation.Uri} uri The location of the resource.
 * @param {!Windows.Storage.IStorageFile} resultFile The file that the response will be written to.
 * @param {!Windows.Storage.IStorageFile=} requestBodyFile A file that represents the request entity body, which contains additional data the server requires before the download can begin. The file this object points to must be valid for the duration of the download.
 * @return {!Windows.Networking.BackgroundTransfer.DownloadOperation} The resultant download operation.
 */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.prototype.createDownload = function(uri, resultFile, requestBodyFile) {};

/**
 * Creates an asynchronous download operation that includes a URI, the file that the response will be written to, and the IInputStream object from which the file contents are read.
 * @param {!Windows.Foundation.Uri} uri The location of the resource.
 * @param {!Windows.Storage.IStorageFile} resultFile Represents the file that the response will be written to.
 * @param {!Windows.Storage.Streams.IInputStream} requestBodyStream A stream that represents the request entity body.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.BackgroundTransfer.DownloadOperation, !Windows.Foundation.IAsyncOperation<!Windows.Networking.BackgroundTransfer.DownloadOperation>>} The resultant asynchronous download operation.
 */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.prototype.createDownloadAsync = function(uri, resultFile, requestBodyStream) {};

/**
 * Used to set an HTTP request header.
 * @param {string} headerName The header name.
 * @param {string} headerValue The header value.
 * @return {void}
 */
Windows.Networking.BackgroundTransfer.BackgroundDownloader.prototype.setRequestHeader = function(headerName, headerValue) {};

/** @const */
Windows.Networking.BackgroundTransfer.BackgroundTransferBehavior = {};
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferBehavior.parallel;
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferBehavior.serialized;

/**
 * @constructor
 * @struct
 * Creates a new BackgroundTransferCompletionGroup object.
 */
Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup = function() {};
 /** @type {boolean} */
Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup.prototype.isEnabled;
 /** @type {!Windows.ApplicationModel.Background.IBackgroundTrigger} */
Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup.prototype.trigger;

/**
 * Indicates that the BackgroundTransferCompletionGroup is complete and no more background transfer operations ( DownloadOperation or UploadOperation objects) will be added t the completion group.
 * @return {void}
 */
Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup.prototype.enable = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroupTriggerDetails = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.BackgroundTransfer.DownloadOperation>} */
Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroupTriggerDetails.prototype.downloads;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.BackgroundTransfer.UploadOperation>} */
Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroupTriggerDetails.prototype.uploads;

/**
 * @constructor
 * @struct
 * Creates a BackgroundTransferContentPart object.
 * Creates a BackgroundTransferContentPart object that identifies the file content and the name of the file that it represents.
 * Creates a BackgroundTransferContentPart object that identifies the content it represents.
 * @param {string=} name Identifies the content.
 * @param {string=} fileName The fully qualified file name, including the local path.
 */
Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart = function(name, fileName) {};

/**
 * Sets the source file for a BackgroundTransferContentPart containing the file for upload.
 * @param {!Windows.Storage.IStorageFile} value The source file.
 * @return {void}
 */
Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart.prototype.setFile = function(value) {};

/**
 * Sets content disposition header values that indicate the nature of the information that this BackgroundTransferContentPart represents.
 * @param {string} headerName The header name.
 * @param {string} headerValue The header value.
 * @return {void}
 */
Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart.prototype.setHeader = function(headerName, headerValue) {};

/**
 * Use this method to set text information that the BackgroundTransferContentPart represents.
 * @param {string} value A string value used to represent text information. (e.g. api_sig, api_key, auth_token, etc...)
 * @return {void}
 */
Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart.prototype.setText = function(value) {};

/** @const */
Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy = {};
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy.default;
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy.unrestrictedOnly;
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy.always;
/**
 * @constructor
 * @struct
 */
Windows.Networking.BackgroundTransfer.BackgroundTransferError = function() {};

/**
 * Gets the specific error using the returned HRESULT value. Possible values are defined by WebErrorStatus .
 * @param {number} hresult An HRESULT returned during the operation.
 * @return {Windows.Web.WebErrorStatus} The error encountered.
 */
Windows.Networking.BackgroundTransfer.BackgroundTransferError.getStatus = function(hresult) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.BackgroundTransfer.BackgroundTransferGroup = function() {};
 /** @type {string} */
Windows.Networking.BackgroundTransfer.BackgroundTransferGroup.prototype.name;
 /** @type {Windows.Networking.BackgroundTransfer.BackgroundTransferBehavior} */
Windows.Networking.BackgroundTransfer.BackgroundTransferGroup.prototype.transferBehavior;

/**
 * Creates a transfer group using the provided group name.
 * @param {string} name The name of the group. If a group with the this name already exists, this method will return a reference to the existing group object.
 * @return {!Windows.Networking.BackgroundTransfer.BackgroundTransferGroup} The new BackgroundTransferGroup .
 */
Windows.Networking.BackgroundTransfer.BackgroundTransferGroup.createGroup = function(name) {};

/** @const */
Windows.Networking.BackgroundTransfer.BackgroundTransferPriority = {};
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferPriority.default;
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferPriority.high;

/** @const */
Windows.Networking.BackgroundTransfer.BackgroundTransferStatus = {};
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferStatus.idle;
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferStatus.running;
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferStatus.pausedByApplication;
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferStatus.pausedCostedNetwork;
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferStatus.pausedNoNetwork;
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferStatus.completed;
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferStatus.canceled;
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferStatus.error;
/** @const {number} */
Windows.Networking.BackgroundTransfer.BackgroundTransferStatus.pausedSystemPolicy;

/**
 * @constructor
 * @struct
 * Instantiates a new BackgroundUploader object.
 * Instantiates a new BackgroundUploader object as a member of a completion group.
 * @param {!Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup=} completionGroup The completion group that the created BackgroundUploader instance is to be a member of.
 */
Windows.Networking.BackgroundTransfer.BackgroundUploader = function(completionGroup) {};
 /** @type {!Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup} */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.completionGroup;
 /** @type {Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy} */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.costPolicy;
 /** @type {!Windows.UI.Notifications.TileNotification} */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.failureTileNotification;
 /** @type {!Windows.UI.Notifications.ToastNotification} */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.failureToastNotification;
 /** @type {string} */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.group;
 /** @type {string} */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.method;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.proxyCredential;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.serverCredential;
 /** @type {!Windows.UI.Notifications.TileNotification} */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.successTileNotification;
 /** @type {!Windows.UI.Notifications.ToastNotification} */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.successToastNotification;
 /** @type {!Windows.Networking.BackgroundTransfer.BackgroundTransferGroup} */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.transferGroup;

/**
 * Returns a collection of pending uploads for a specific Group .
 * Returns a collection of pending uploads that are not associated with a group.
 * @param {string=} group A string indicating a specific group of uploads.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A collection of pending uploads for the specific group. / A collection of pending uploads for the current application instance.
 */
Windows.Networking.BackgroundTransfer.BackgroundUploader.getCurrentUploadsAsync = function(group) {};

/**
 * Gets all uploads associated with the provided BackgroundTransferGroup .
 * @param {!Windows.Networking.BackgroundTransfer.BackgroundTransferGroup} group Contains information used to identify a group of uploads.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A list of uploads currently associated with the specified group.
 */
Windows.Networking.BackgroundTransfer.BackgroundUploader.getCurrentUploadsForTransferGroupAsync = function(group) {};

/**
 * Used to request an unconstrained upload operation. When this method is called the user is provided with a UI prompt that they can use to indicate their consent for an unconstrained operation.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Networking.BackgroundTransfer.UploadOperation>} operations The upload operation to run unconstrained.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.BackgroundTransfer.UnconstrainedTransferRequestResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.BackgroundTransfer.UnconstrainedTransferRequestResult>>} Indicates if the operations will run unconstrained.
 */
Windows.Networking.BackgroundTransfer.BackgroundUploader.requestUnconstrainedUploadsAsync = function(operations) {};

/**
 * Initializes an UploadOperation that indicates the location for and file for upload.
 * @param {!Windows.Foundation.Uri} uri The location for the upload.
 * @param {!Windows.Storage.IStorageFile} sourceFile The file for upload.
 * @return {!Windows.Networking.BackgroundTransfer.UploadOperation} The resultant upload operation.
 */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.createUpload = function(uri, sourceFile) {};

/**
 * Returns an asynchronous operation that, on completion, returns an UploadOperation with the specified URI and one or more BackgroundTransferContentPart objects.
 * Returns an asynchronous operation that, on completion, returns an UploadOperation with the specified URI, multipart subtype, one or more BackgroundTransferContentPart objects, and the delimiter boundary value used to separate each part.
 * Returns an asynchronous operation that, on completion, returns an UploadOperation with the specified URI, one or more BackgroundTransferContentPart objects, and the multipart subtype.
 * @param {!Windows.Foundation.Uri} uri The location for the upload.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>} parts One or more BackgroundTransferContentPart objects.
 * @param {string=} subType The multipart subtype. For example, "related" for content of type "multipart/ related".
 * @param {string=} boundary A string that is used to identify the delimiter used to indicate separation between provided content parts.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.BackgroundTransfer.UploadOperation, !Windows.Foundation.IAsyncOperation<!Windows.Networking.BackgroundTransfer.UploadOperation>>} The resultant asynchronous UploadOperation / The resultant asynchronous UploadOperation .
 */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.createUploadAsync = function(uri, parts, subType, boundary) {};

/**
 * Returns an asynchronous operation that, on completion, returns an UploadOperation with the specified URI and the source stream.
 * @param {!Windows.Foundation.Uri} uri The URI associated with the resource.
 * @param {!Windows.Storage.Streams.IInputStream} sourceStream Represents the source stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.BackgroundTransfer.UploadOperation, !Windows.Foundation.IAsyncOperation<!Windows.Networking.BackgroundTransfer.UploadOperation>>} The resultant asynchronous upload operation.
 */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.createUploadFromStreamAsync = function(uri, sourceStream) {};

/**
 * Used to set an HTTP request header.
 * @param {string} headerName The header name.
 * @param {string} headerValue The header value.
 * @return {void}
 */
Windows.Networking.BackgroundTransfer.BackgroundUploader.prototype.setRequestHeader = function(headerName, headerValue) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.BackgroundTransfer.ContentPrefetcher = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Foundation.Uri>} */
Windows.Networking.BackgroundTransfer.ContentPrefetcher.contentUris;
 /** @type {!Windows.Foundation.Uri} */
Windows.Networking.BackgroundTransfer.ContentPrefetcher.indirectContentUri;
 /** @type {!Date} */
Windows.Networking.BackgroundTransfer.ContentPrefetcher.lastSuccessfulPrefetchTime;
/**
 * @constructor
 * @struct
 */
Windows.Networking.BackgroundTransfer.DownloadOperation = function() {};
 /** @type {Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy} */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.costPolicy;
 /** @type {string} */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.group;
 /** @type {string} */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.guid;
 /** @type {string} */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.method;
 /** @type {Windows.Networking.BackgroundTransfer.BackgroundTransferPriority} */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.priority;
 /** @type {!Windows.Networking.BackgroundTransfer.BackgroundDownloadProgress} */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.progress;
 /** @type {!Windows.Foundation.Uri} */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.requestedUri;
 /** @type {!Windows.Storage.IStorageFile} */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.resultFile;
 /** @type {!Windows.Networking.BackgroundTransfer.BackgroundTransferGroup} */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.transferGroup;

/**
 * Returns an asynchronous operation that can be used to monitor progress and completion of the attached download. Calling this method allows an app to attach download operations that were started in a previous app instance.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.BackgroundTransfer.DownloadOperation, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Networking.BackgroundTransfer.DownloadOperation, !Windows.Networking.BackgroundTransfer.DownloadOperation>>} Download operation with callback.
 */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.attachAsync = function() {};

/**
 * Gets the response information.
 * @return {!Windows.Networking.BackgroundTransfer.ResponseInformation} Contains the data returned by a server response.
 */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.getResponseInformation = function() {};

/**
 * Gets the partially downloaded response at the specified position.
 * @param {number} position The position at which to start reading.
 * @return {!Windows.Storage.Streams.IInputStream} The result stream.
 */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.getResultStreamAt = function(position) {};

/**
 * Pauses a download operation.
 * @return {void}
 */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.pause = function() {};

/**
 * Resumes a paused download operation.
 * @return {void}
 */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.resume = function() {};

/**
 * Starts an asynchronous download operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.BackgroundTransfer.DownloadOperation, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Networking.BackgroundTransfer.DownloadOperation, !Windows.Networking.BackgroundTransfer.DownloadOperation>>} An asynchronous download operation that includes progress updates.
 */
Windows.Networking.BackgroundTransfer.DownloadOperation.prototype.startAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.BackgroundTransfer.ResponseInformation = function() {};
 /** @type {!Windows.Foundation.Uri} */
Windows.Networking.BackgroundTransfer.ResponseInformation.prototype.actualUri;
 /** @type {!Windows.Foundation.Collections.IMapView<string, string>} */
Windows.Networking.BackgroundTransfer.ResponseInformation.prototype.headers;
 /** @type {boolean} */
Windows.Networking.BackgroundTransfer.ResponseInformation.prototype.isResumable;
 /** @type {number} */
Windows.Networking.BackgroundTransfer.ResponseInformation.prototype.statusCode;
/**
 * @constructor
 * @struct
 */
Windows.Networking.BackgroundTransfer.UnconstrainedTransferRequestResult = function() {};
 /** @type {boolean} */
Windows.Networking.BackgroundTransfer.UnconstrainedTransferRequestResult.prototype.isUnconstrained;
/**
 * @constructor
 * @struct
 */
Windows.Networking.BackgroundTransfer.UploadOperation = function() {};
 /** @type {Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy} */
Windows.Networking.BackgroundTransfer.UploadOperation.prototype.costPolicy;
 /** @type {string} */
Windows.Networking.BackgroundTransfer.UploadOperation.prototype.group;
 /** @type {string} */
Windows.Networking.BackgroundTransfer.UploadOperation.prototype.guid;
 /** @type {string} */
Windows.Networking.BackgroundTransfer.UploadOperation.prototype.method;
 /** @type {Windows.Networking.BackgroundTransfer.BackgroundTransferPriority} */
Windows.Networking.BackgroundTransfer.UploadOperation.prototype.priority;
 /** @type {!Windows.Networking.BackgroundTransfer.BackgroundUploadProgress} */
Windows.Networking.BackgroundTransfer.UploadOperation.prototype.progress;
 /** @type {!Windows.Foundation.Uri} */
Windows.Networking.BackgroundTransfer.UploadOperation.prototype.requestedUri;
 /** @type {!Windows.Storage.IStorageFile} */
Windows.Networking.BackgroundTransfer.UploadOperation.prototype.sourceFile;
 /** @type {!Windows.Networking.BackgroundTransfer.BackgroundTransferGroup} */
Windows.Networking.BackgroundTransfer.UploadOperation.prototype.transferGroup;

/**
 * Returns an asynchronous operation that can be used to monitor progress and completion of the attached upload. Calling this method allows an app to attach upload operations that were started in a previous app instance.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.BackgroundTransfer.UploadOperation, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Networking.BackgroundTransfer.UploadOperation, !Windows.Networking.BackgroundTransfer.UploadOperation>>} Upload operation with callback.
 */
Windows.Networking.BackgroundTransfer.UploadOperation.prototype.attachAsync = function() {};

/**
 * Gets the response information.
 * @return {!Windows.Networking.BackgroundTransfer.ResponseInformation} Contains the data returned by a server response.
 */
Windows.Networking.BackgroundTransfer.UploadOperation.prototype.getResponseInformation = function() {};

/**
 * Gets the partially uploaded response at the specified location.
 * @param {number} position The position at which to start reading.
 * @return {!Windows.Storage.Streams.IInputStream} The result stream.
 */
Windows.Networking.BackgroundTransfer.UploadOperation.prototype.getResultStreamAt = function(position) {};

/**
 * Starts an asynchronous upload operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.BackgroundTransfer.UploadOperation, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Networking.BackgroundTransfer.UploadOperation, !Windows.Networking.BackgroundTransfer.UploadOperation>>} An asynchronous upload operation that includes progress updates.
 */
Windows.Networking.BackgroundTransfer.UploadOperation.prototype.startAsync = function() {};
/**
 * @record
 * @struct
 */
Windows.Networking.BackgroundTransfer.BackgroundDownloadProgress = function() {};
 /** @type {number} */
Windows.Networking.BackgroundTransfer.BackgroundDownloadProgress.prototype.bytesReceived;
 /** @type {boolean} */
Windows.Networking.BackgroundTransfer.BackgroundDownloadProgress.prototype.hasResponseChanged;
 /** @type {boolean} */
Windows.Networking.BackgroundTransfer.BackgroundDownloadProgress.prototype.hasRestarted;
 /** @type {Windows.Networking.BackgroundTransfer.BackgroundTransferStatus} */
Windows.Networking.BackgroundTransfer.BackgroundDownloadProgress.prototype.status;
 /** @type {number} */
Windows.Networking.BackgroundTransfer.BackgroundDownloadProgress.prototype.totalBytesToReceive;
/**
 * @record
 * @struct
 */
Windows.Networking.BackgroundTransfer.BackgroundUploadProgress = function() {};
 /** @type {number} */
Windows.Networking.BackgroundTransfer.BackgroundUploadProgress.prototype.bytesReceived;
 /** @type {number} */
Windows.Networking.BackgroundTransfer.BackgroundUploadProgress.prototype.bytesSent;
 /** @type {boolean} */
Windows.Networking.BackgroundTransfer.BackgroundUploadProgress.prototype.hasResponseChanged;
 /** @type {boolean} */
Windows.Networking.BackgroundTransfer.BackgroundUploadProgress.prototype.hasRestarted;
 /** @type {Windows.Networking.BackgroundTransfer.BackgroundTransferStatus} */
Windows.Networking.BackgroundTransfer.BackgroundUploadProgress.prototype.status;
 /** @type {number} */
Windows.Networking.BackgroundTransfer.BackgroundUploadProgress.prototype.totalBytesToReceive;
 /** @type {number} */
Windows.Networking.BackgroundTransfer.BackgroundUploadProgress.prototype.totalBytesToSend;
/** @const */
Windows.Networking.Connectivity = {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.AttributedNetworkUsage = function() {};
 /** @type {string} */
Windows.Networking.Connectivity.AttributedNetworkUsage.prototype.attributionId;
 /** @type {string} */
Windows.Networking.Connectivity.AttributedNetworkUsage.prototype.attributionName;
 /** @type {!Windows.Storage.Streams.IRandomAccessStreamReference} */
Windows.Networking.Connectivity.AttributedNetworkUsage.prototype.attributionThumbnail;
 /** @type {number} */
Windows.Networking.Connectivity.AttributedNetworkUsage.prototype.bytesReceived;
 /** @type {number} */
Windows.Networking.Connectivity.AttributedNetworkUsage.prototype.bytesSent;

/** @const */
Windows.Networking.Connectivity.CellularApnAuthenticationType = {};
/** @const {number} */
Windows.Networking.Connectivity.CellularApnAuthenticationType.none;
/** @const {number} */
Windows.Networking.Connectivity.CellularApnAuthenticationType.pap;
/** @const {number} */
Windows.Networking.Connectivity.CellularApnAuthenticationType.chap;
/** @const {number} */
Windows.Networking.Connectivity.CellularApnAuthenticationType.mschapv2;

/**
 * @constructor
 * @struct
 * Creates an instance of CellularApnContext .
 */
Windows.Networking.Connectivity.CellularApnContext = function() {};
 /** @type {string} */
Windows.Networking.Connectivity.CellularApnContext.prototype.accessPointName;
 /** @type {Windows.Networking.Connectivity.CellularApnAuthenticationType} */
Windows.Networking.Connectivity.CellularApnContext.prototype.authenticationType;
 /** @type {boolean} */
Windows.Networking.Connectivity.CellularApnContext.prototype.isCompressionEnabled;
 /** @type {string} */
Windows.Networking.Connectivity.CellularApnContext.prototype.password;
 /** @type {string} */
Windows.Networking.Connectivity.CellularApnContext.prototype.providerId;
 /** @type {string} */
Windows.Networking.Connectivity.CellularApnContext.prototype.userName;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.ConnectionCost = function() {};
 /** @type {boolean} */
Windows.Networking.Connectivity.ConnectionCost.prototype.approachingDataLimit;
 /** @type {boolean} */
Windows.Networking.Connectivity.ConnectionCost.prototype.backgroundDataUsageRestricted;
 /** @type {Windows.Networking.Connectivity.NetworkCostType} */
Windows.Networking.Connectivity.ConnectionCost.prototype.networkCostType;
 /** @type {boolean} */
Windows.Networking.Connectivity.ConnectionCost.prototype.overDataLimit;
 /** @type {boolean} */
Windows.Networking.Connectivity.ConnectionCost.prototype.roaming;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.ConnectionProfile = function() {};
 /** @type {boolean} */
Windows.Networking.Connectivity.ConnectionProfile.prototype.isWlanConnectionProfile;
 /** @type {boolean} */
Windows.Networking.Connectivity.ConnectionProfile.prototype.isWwanConnectionProfile;
 /** @type {!Windows.Networking.Connectivity.NetworkAdapter} */
Windows.Networking.Connectivity.ConnectionProfile.prototype.networkAdapter;
 /** @type {!Windows.Networking.Connectivity.NetworkSecuritySettings} */
Windows.Networking.Connectivity.ConnectionProfile.prototype.networkSecuritySettings;
 /** @type {string} */
Windows.Networking.Connectivity.ConnectionProfile.prototype.profileName;
 /** @type {string} */
Windows.Networking.Connectivity.ConnectionProfile.prototype.serviceProviderGuid;
 /** @type {!Windows.Networking.Connectivity.WlanConnectionProfileDetails} */
Windows.Networking.Connectivity.ConnectionProfile.prototype.wlanConnectionProfileDetails;
 /** @type {!Windows.Networking.Connectivity.WwanConnectionProfileDetails} */
Windows.Networking.Connectivity.ConnectionProfile.prototype.wwanConnectionProfileDetails;

/**
 * Gets network usage data for each individual application. This method is only supported in a Windows Phone Store app.
 * @param {!Date} startTime The start time of the usage window.
 * @param {!Date} endTime The end time of the usage window.
 * @param {!Windows.Networking.Connectivity.NetworkUsageStates} states The state of the connection profile for which usage data should be returned.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When the method completes, it returns a list of AttributedNetworkUsage objects, which indicate the sent and received values, in bytes, and the total amount of time the app was connected during the corresponding time interval.
 */
Windows.Networking.Connectivity.ConnectionProfile.prototype.getAttributedNetworkUsageAsync = function(startTime, endTime, states) {};

/**
 * Gets the cost information for the connection.
 * @return {!Windows.Networking.Connectivity.ConnectionCost} The cost information for the connection.
 */
Windows.Networking.Connectivity.ConnectionProfile.prototype.getConnectionCost = function() {};

/**
 * Gets a list of ConnectivityInterval objects, which indicate the timestamp for when the network connection began, and a time-span for the duration of that connection.
 * @param {!Date} startTime The start time over which to retrieve data. Can be no more than 60 days prior to the current time.
 * @param {!Date} endTime The end time over which to retrieve data.
 * @param {!Windows.Networking.Connectivity.NetworkUsageStates} states The state of the connection profile for which usage data should be returned.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When the method completes, it returns a list of ConnectivityInterval objects, which indicate the start time and duration for the current or prior connections.
 */
Windows.Networking.Connectivity.ConnectionProfile.prototype.getConnectivityIntervalsAsync = function(startTime, endTime, states) {};

/**
 * Gets the current status of the data plan associated with the connection.
 * @return {!Windows.Networking.Connectivity.DataPlanStatus} Current data plan status information.
 */
Windows.Networking.Connectivity.ConnectionProfile.prototype.getDataPlanStatus = function() {};

/**
 * Gets the current domain authentication status for a network connection. Possible values are defined by DomainConnectivityLevel .
 * @return {Windows.Networking.Connectivity.DomainConnectivityLevel} A value indicating the authentication status for a connection to a network domain.
 */
Windows.Networking.Connectivity.ConnectionProfile.prototype.getDomainConnectivityLevel = function() {};

/**
 * Gets the estimated data usage for a connection over a specific period of time and roaming state.
 * Gets the estimated data usage for a connection during over a specific period of time.
 * @param {!Date} StartTime The start date/time for the usage data request.
 * @param {!Date} EndTime The end date/time for the usage data request.
 * @param {Windows.Networking.Connectivity.RoamingStates=} States The roaming state to scope the request to.
 * @return {!Windows.Networking.Connectivity.DataUsage} The requested local data usage information.
 */
Windows.Networking.Connectivity.ConnectionProfile.prototype.getLocalUsage = function(StartTime, EndTime, States) {};

/**
 * Gets the network connectivity level for this connection. This value indicates what network resources, if any, are currently available.
 * @return {Windows.Networking.Connectivity.NetworkConnectivityLevel} The level of network connectivity.
 */
Windows.Networking.Connectivity.ConnectionProfile.prototype.getNetworkConnectivityLevel = function() {};

/**
 * Retrieves names associated with the network with which the connection is currently established.
 * @return {!Windows.Foundation.Collections.IVectorView<string>} An array of string values representing friendly names used to identify the local endpoint.
 */
Windows.Networking.Connectivity.ConnectionProfile.prototype.getNetworkNames = function() {};

/**
 * Gets a list of the estimated data traffic and connection duration over a specified period of time, for a specific network usage state.
 * @param {!Date} startTime The start time over which to retrieve data. Can be no more than 60 days prior to the current time. If the specified granularity is PerMinute, the start time can be no more than 120 minutes prior to the current time.
 * @param {!Date} endTime The end time over which to retrieve data.
 * @param {Windows.Networking.Connectivity.DataUsageGranularity} granularity The desired granularity of the returned usage statistics. Each elements in the list corresponds to the network usage per the specified granularity, e.g., usage per hour.
 * @param {!Windows.Networking.Connectivity.NetworkUsageStates} states The state of the connection profile for which usage data should be returned.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When the method completes, it returns a list of NetworkUsage objects, which indicate the sent and received values, in bytes, and the total amount of time the profile was connected during the corresponding time interval.
 */
Windows.Networking.Connectivity.ConnectionProfile.prototype.getNetworkUsageAsync = function(startTime, endTime, granularity, states) {};

/**
 * Gets a value that indicates the current number of signal bars displayed by the Windows UI for the connection.
 * @return {number} An integer value within a range of 0-5 that corresponds to the number of signal bars displayed by the UI.
 */
Windows.Networking.Connectivity.ConnectionProfile.prototype.getSignalBars = function() {};

/**
 * @constructor
 * @struct
 * Creates an instance of ConnectionProfileFilter , which contains a set of properties that are used to improve the relevance of FindConnectionProfilesAsync results.
 */
Windows.Networking.Connectivity.ConnectionProfileFilter = function() {};
 /** @type {boolean} */
Windows.Networking.Connectivity.ConnectionProfileFilter.prototype.isBackgroundDataUsageRestricted;
 /** @type {boolean} */
Windows.Networking.Connectivity.ConnectionProfileFilter.prototype.isConnected;
 /** @type {boolean} */
Windows.Networking.Connectivity.ConnectionProfileFilter.prototype.isOverDataLimit;
 /** @type {boolean} */
Windows.Networking.Connectivity.ConnectionProfileFilter.prototype.isRoaming;
 /** @type {boolean} */
Windows.Networking.Connectivity.ConnectionProfileFilter.prototype.isWlanConnectionProfile;
 /** @type {boolean} */
Windows.Networking.Connectivity.ConnectionProfileFilter.prototype.isWwanConnectionProfile;
 /** @type {Windows.Networking.Connectivity.NetworkCostType} */
Windows.Networking.Connectivity.ConnectionProfileFilter.prototype.networkCostType;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Networking.Connectivity.ConnectionProfileFilter.prototype.rawData;
 /** @type {string} */
Windows.Networking.Connectivity.ConnectionProfileFilter.prototype.serviceProviderGuid;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.ConnectionSession = function() {};
 /** @type {!Windows.Networking.Connectivity.ConnectionProfile} */
Windows.Networking.Connectivity.ConnectionSession.prototype.connectionProfile;

/**
 * Closes the connection to the access point.
 * @return {void}
 */
Windows.Networking.Connectivity.ConnectionSession.prototype.close = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.ConnectivityInterval = function() {};
 /** @type {number} */
Windows.Networking.Connectivity.ConnectivityInterval.prototype.connectionDuration;
 /** @type {!Date} */
Windows.Networking.Connectivity.ConnectivityInterval.prototype.startTime;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.ConnectivityManager = function() {};

/**
 * Establishes a connection to a specific access point on a network. The request is defined using a CellularApnContext object.
 * @param {!Windows.Networking.Connectivity.CellularApnContext} CellularApnContext Provides specific details about the APN.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.Connectivity.ConnectionSession, !Windows.Foundation.IAsyncOperation<!Windows.Networking.Connectivity.ConnectionSession>>} The established APN connection.
 */
Windows.Networking.Connectivity.ConnectivityManager.acquireConnectionAsync = function(CellularApnContext) {};

/**
 * Specifies a RoutePolicy that the Http stack (WinInet) will follow when routing traffic.
 * @param {!Windows.Networking.Connectivity.RoutePolicy} RoutePolicy Indicates the policy for traffic routing.
 * @return {void}
 */
Windows.Networking.Connectivity.ConnectivityManager.addHttpRoutePolicy = function(RoutePolicy) {};

/**
 * Removes a previously specified RoutePolicy from the Http stack (WinInet).
 * @param {!Windows.Networking.Connectivity.RoutePolicy} RoutePolicy The RoutePolicy to remove.
 * @return {void}
 */
Windows.Networking.Connectivity.ConnectivityManager.removeHttpRoutePolicy = function(RoutePolicy) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.DataPlanStatus = function() {};
 /** @type {number} */
Windows.Networking.Connectivity.DataPlanStatus.prototype.dataLimitInMegabytes;
 /** @type {!Windows.Networking.Connectivity.DataPlanUsage} */
Windows.Networking.Connectivity.DataPlanStatus.prototype.dataPlanUsage;
 /** @type {number} */
Windows.Networking.Connectivity.DataPlanStatus.prototype.inboundBitsPerSecond;
 /** @type {number} */
Windows.Networking.Connectivity.DataPlanStatus.prototype.maxTransferSizeInMegabytes;
 /** @type {!Date} */
Windows.Networking.Connectivity.DataPlanStatus.prototype.nextBillingCycle;
 /** @type {number} */
Windows.Networking.Connectivity.DataPlanStatus.prototype.outboundBitsPerSecond;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.DataPlanUsage = function() {};
 /** @type {!Date} */
Windows.Networking.Connectivity.DataPlanUsage.prototype.lastSyncTime;
 /** @type {number} */
Windows.Networking.Connectivity.DataPlanUsage.prototype.megabytesUsed;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.DataUsage = function() {};
 /** @type {number} */
Windows.Networking.Connectivity.DataUsage.prototype.bytesReceived;
 /** @type {number} */
Windows.Networking.Connectivity.DataUsage.prototype.bytesSent;

/** @const */
Windows.Networking.Connectivity.DataUsageGranularity = {};
/** @const {number} */
Windows.Networking.Connectivity.DataUsageGranularity.perMinute;
/** @const {number} */
Windows.Networking.Connectivity.DataUsageGranularity.perHour;
/** @const {number} */
Windows.Networking.Connectivity.DataUsageGranularity.perDay;
/** @const {number} */
Windows.Networking.Connectivity.DataUsageGranularity.total;

/** @const */
Windows.Networking.Connectivity.DomainConnectivityLevel = {};
/** @const {number} */
Windows.Networking.Connectivity.DomainConnectivityLevel.none;
/** @const {number} */
Windows.Networking.Connectivity.DomainConnectivityLevel.unauthenticated;
/** @const {number} */
Windows.Networking.Connectivity.DomainConnectivityLevel.authenticated;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.IPInformation = function() {};
 /** @type {!Windows.Networking.Connectivity.NetworkAdapter} */
Windows.Networking.Connectivity.IPInformation.prototype.networkAdapter;
 /** @type {number} */
Windows.Networking.Connectivity.IPInformation.prototype.prefixLength;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.LanIdentifier = function() {};
 /** @type {!Windows.Networking.Connectivity.LanIdentifierData} */
Windows.Networking.Connectivity.LanIdentifier.prototype.infrastructureId;
 /** @type {string} */
Windows.Networking.Connectivity.LanIdentifier.prototype.networkAdapterId;
 /** @type {!Windows.Networking.Connectivity.LanIdentifierData} */
Windows.Networking.Connectivity.LanIdentifier.prototype.portId;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.LanIdentifierData = function() {};
 /** @type {number} */
Windows.Networking.Connectivity.LanIdentifierData.prototype.type;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.Connectivity.LanIdentifierData.prototype.value;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.NetworkAdapter = function() {};
 /** @type {number} */
Windows.Networking.Connectivity.NetworkAdapter.prototype.ianaInterfaceType;
 /** @type {number} */
Windows.Networking.Connectivity.NetworkAdapter.prototype.inboundMaxBitsPerSecond;
 /** @type {string} */
Windows.Networking.Connectivity.NetworkAdapter.prototype.networkAdapterId;
 /** @type {!Windows.Networking.Connectivity.NetworkItem} */
Windows.Networking.Connectivity.NetworkAdapter.prototype.networkItem;
 /** @type {number} */
Windows.Networking.Connectivity.NetworkAdapter.prototype.outboundMaxBitsPerSecond;

/**
 * Gets the connection profile currently associated with the network adapter.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.Connectivity.ConnectionProfile, !Windows.Foundation.IAsyncOperation<!Windows.Networking.Connectivity.ConnectionProfile>>} The connection profile associated with this network adapter.
 */
Windows.Networking.Connectivity.NetworkAdapter.prototype.getConnectedProfileAsync = function() {};

/** @const */
Windows.Networking.Connectivity.NetworkAuthenticationType = {};
/** @const {number} */
Windows.Networking.Connectivity.NetworkAuthenticationType.none;
/** @const {number} */
Windows.Networking.Connectivity.NetworkAuthenticationType.unknown;
/** @const {number} */
Windows.Networking.Connectivity.NetworkAuthenticationType.open80211;
/** @const {number} */
Windows.Networking.Connectivity.NetworkAuthenticationType.sharedKey80211;
/** @const {number} */
Windows.Networking.Connectivity.NetworkAuthenticationType.wpa;
/** @const {number} */
Windows.Networking.Connectivity.NetworkAuthenticationType.wpaPsk;
/** @const {number} */
Windows.Networking.Connectivity.NetworkAuthenticationType.wpaNone;
/** @const {number} */
Windows.Networking.Connectivity.NetworkAuthenticationType.rsna;
/** @const {number} */
Windows.Networking.Connectivity.NetworkAuthenticationType.rsnaPsk;
/** @const {number} */
Windows.Networking.Connectivity.NetworkAuthenticationType.ihv;

/** @const */
Windows.Networking.Connectivity.NetworkConnectivityLevel = {};
/** @const {number} */
Windows.Networking.Connectivity.NetworkConnectivityLevel.none;
/** @const {number} */
Windows.Networking.Connectivity.NetworkConnectivityLevel.localAccess;
/** @const {number} */
Windows.Networking.Connectivity.NetworkConnectivityLevel.constrainedInternetAccess;
/** @const {number} */
Windows.Networking.Connectivity.NetworkConnectivityLevel.internetAccess;

/** @const */
Windows.Networking.Connectivity.NetworkCostType = {};
/** @const {number} */
Windows.Networking.Connectivity.NetworkCostType.unknown;
/** @const {number} */
Windows.Networking.Connectivity.NetworkCostType.unrestricted;
/** @const {number} */
Windows.Networking.Connectivity.NetworkCostType.fixed;
/** @const {number} */
Windows.Networking.Connectivity.NetworkCostType.variable;

/** @const */
Windows.Networking.Connectivity.NetworkEncryptionType = {};
/** @const {number} */
Windows.Networking.Connectivity.NetworkEncryptionType.none;
/** @const {number} */
Windows.Networking.Connectivity.NetworkEncryptionType.unknown;
/** @const {number} */
Windows.Networking.Connectivity.NetworkEncryptionType.wep;
/** @const {number} */
Windows.Networking.Connectivity.NetworkEncryptionType.wep40;
/** @const {number} */
Windows.Networking.Connectivity.NetworkEncryptionType.wep104;
/** @const {number} */
Windows.Networking.Connectivity.NetworkEncryptionType.tkip;
/** @const {number} */
Windows.Networking.Connectivity.NetworkEncryptionType.ccmp;
/** @const {number} */
Windows.Networking.Connectivity.NetworkEncryptionType.wpaUseGroup;
/** @const {number} */
Windows.Networking.Connectivity.NetworkEncryptionType.rsnUseGroup;
/** @const {number} */
Windows.Networking.Connectivity.NetworkEncryptionType.ihv;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.NetworkInformation = function() {};
 /** @type {function(!Windows.WinRTEvent<?>): void} */
Windows.Networking.Connectivity.NetworkInformation.onnetworkstatuschanged;

/**
 * Returns an array of ConnectionProfile objects that match the filtering criteria defined by ConnectionProfileFilter .
 * @param {!Windows.Networking.Connectivity.ConnectionProfileFilter} pProfileFilter Provides the filtering criteria.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An array of ConnectionProfile objects.
 */
Windows.Networking.Connectivity.NetworkInformation.findConnectionProfilesAsync = function(pProfileFilter) {};

/**
 * Gets a list of profiles for connections, active or otherwise, on the local machine.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.Connectivity.ConnectionProfile>} An array of ConnectionProfile objects.
 */
Windows.Networking.Connectivity.NetworkInformation.getConnectionProfiles = function() {};

/**
 * Gets a list of host names associated with the local machine.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.HostName>} An array of host names for the local machine.
 */
Windows.Networking.Connectivity.NetworkInformation.getHostNames = function() {};

/**
 * Gets the connection profile associated with the internet connection currently used by the local machine.
 * @return {!Windows.Networking.Connectivity.ConnectionProfile} The profile for the connection currently used to connect the machine to the Internet, or null if there is no connection profile with a suitable connection.
 */
Windows.Networking.Connectivity.NetworkInformation.getInternetConnectionProfile = function() {};

/**
 * Gets an array of LanIdentifier objects that contain locality information for each NetworkAdapter object that currently connected to a network.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.Connectivity.LanIdentifier>} An array of LanIdentifier objects.
 */
Windows.Networking.Connectivity.NetworkInformation.getLanIdentifiers = function() {};

/**
 * Gets proxy configuration for a connection using the specified URI.
 * @param {!Windows.Foundation.Uri} uri The proxy configuration URI.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.Connectivity.ProxyConfiguration, !Windows.Foundation.IAsyncOperation<!Windows.Networking.Connectivity.ProxyConfiguration>>} Information about the connection proxy.
 */
Windows.Networking.Connectivity.NetworkInformation.getProxyConfigurationAsync = function(uri) {};

/**
 * Gets a sorted list of EndpointPair objects.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Networking.EndpointPair>} destinationList A list of EndpointPair objects to be sorted.
 * @param {Windows.Networking.HostNameSortOptions} sortOptions Indicates sorting options for the returned array.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.EndpointPair>} A sorted array of EndpointPair objects.
 */
Windows.Networking.Connectivity.NetworkInformation.getSortedEndpointPairs = function(destinationList, sortOptions) {};

/**
 * @param {string} type
 * @param {function(!Windows.WinRTEvent<?>): void|function(?): void} listener
 * @return {void}
 */
Windows.Networking.Connectivity.NetworkInformation.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(!Windows.WinRTEvent<?>): void|function(?): void} listener
 * @return {void}
 */
Windows.Networking.Connectivity.NetworkInformation.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.NetworkItem = function() {};
 /** @type {string} */
Windows.Networking.Connectivity.NetworkItem.prototype.networkId;

/**
 * Gets a NetworkTypes value indicating the network type for a NetworkItem .
 * @return {Windows.Networking.Connectivity.NetworkTypes} The type of a network.
 */
Windows.Networking.Connectivity.NetworkItem.prototype.getNetworkTypes = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.NetworkSecuritySettings = function() {};
 /** @type {Windows.Networking.Connectivity.NetworkAuthenticationType} */
Windows.Networking.Connectivity.NetworkSecuritySettings.prototype.networkAuthenticationType;
 /** @type {Windows.Networking.Connectivity.NetworkEncryptionType} */
Windows.Networking.Connectivity.NetworkSecuritySettings.prototype.networkEncryptionType;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.NetworkStateChangeEventDetails = function() {};
 /** @type {boolean} */
Windows.Networking.Connectivity.NetworkStateChangeEventDetails.prototype.hasNewConnectionCost;
 /** @type {boolean} */
Windows.Networking.Connectivity.NetworkStateChangeEventDetails.prototype.hasNewDomainConnectivityLevel;
 /** @type {boolean} */
Windows.Networking.Connectivity.NetworkStateChangeEventDetails.prototype.hasNewHostNameList;
 /** @type {boolean} */
Windows.Networking.Connectivity.NetworkStateChangeEventDetails.prototype.hasNewInternetConnectionProfile;
 /** @type {boolean} */
Windows.Networking.Connectivity.NetworkStateChangeEventDetails.prototype.hasNewNetworkConnectivityLevel;
 /** @type {boolean} */
Windows.Networking.Connectivity.NetworkStateChangeEventDetails.prototype.hasNewTetheringClientCount;
 /** @type {boolean} */
Windows.Networking.Connectivity.NetworkStateChangeEventDetails.prototype.hasNewTetheringOperationalState;
 /** @type {boolean} */
Windows.Networking.Connectivity.NetworkStateChangeEventDetails.prototype.hasNewWwanRegistrationState;

/** @const */
Windows.Networking.Connectivity.NetworkTypes = {};
/** @const {number} */
Windows.Networking.Connectivity.NetworkTypes.none;
/** @const {number} */
Windows.Networking.Connectivity.NetworkTypes.internet;
/** @const {number} */
Windows.Networking.Connectivity.NetworkTypes.privateNetwork;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.NetworkUsage = function() {};
 /** @type {number} */
Windows.Networking.Connectivity.NetworkUsage.prototype.bytesReceived;
 /** @type {number} */
Windows.Networking.Connectivity.NetworkUsage.prototype.bytesSent;
 /** @type {number} */
Windows.Networking.Connectivity.NetworkUsage.prototype.connectionDuration;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.ProxyConfiguration = function() {};
 /** @type {boolean} */
Windows.Networking.Connectivity.ProxyConfiguration.prototype.canConnectDirectly;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Foundation.Uri>} */
Windows.Networking.Connectivity.ProxyConfiguration.prototype.proxyUris;

/** @const */
Windows.Networking.Connectivity.RoamingStates = {};
/** @const {number} */
Windows.Networking.Connectivity.RoamingStates.none;
/** @const {number} */
Windows.Networking.Connectivity.RoamingStates.notRoaming;
/** @const {number} */
Windows.Networking.Connectivity.RoamingStates.roaming;

/**
 * @constructor
 * @struct
 * Creates an instance of RoutePolicy using the defined connection profile and host name values.
 * @param {!Windows.Networking.Connectivity.ConnectionProfile} connectionProfile The connection profile
 * @param {!Windows.Networking.HostName} hostName The host name for the route policy to the special PDP context.
 * @param {Windows.Networking.DomainNameType} type The domain type of hostName when the HostNameType value indicates a domain name.
 */
Windows.Networking.Connectivity.RoutePolicy = function(connectionProfile, hostName, type) {};
 /** @type {!Windows.Networking.Connectivity.ConnectionProfile} */
Windows.Networking.Connectivity.RoutePolicy.prototype.connectionProfile;
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.Connectivity.RoutePolicy.prototype.hostName;
 /** @type {Windows.Networking.DomainNameType} */
Windows.Networking.Connectivity.RoutePolicy.prototype.hostNameType;

/** @const */
Windows.Networking.Connectivity.TriStates = {};
/** @const {number} */
Windows.Networking.Connectivity.TriStates.doNotCare;
/** @const {number} */
Windows.Networking.Connectivity.TriStates.no;
/** @const {number} */
Windows.Networking.Connectivity.TriStates.yes;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.WlanConnectionProfileDetails = function() {};

/**
 * Retrieves the Service Set Identifier (SSID) for a WLAN connection.
 * @return {string} The service set identifier (SSID).
 */
Windows.Networking.Connectivity.WlanConnectionProfileDetails.prototype.getConnectedSsid = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.Connectivity.WwanConnectionProfileDetails = function() {};
 /** @type {string} */
Windows.Networking.Connectivity.WwanConnectionProfileDetails.prototype.accessPointName;
 /** @type {string} */
Windows.Networking.Connectivity.WwanConnectionProfileDetails.prototype.homeProviderId;

/**
 * Indicates the class of data service offered by the network currently in use for the WWAN connection.
 * @return {Windows.Networking.Connectivity.WwanDataClass} The class of data service currently provided.
 */
Windows.Networking.Connectivity.WwanConnectionProfileDetails.prototype.getCurrentDataClass = function() {};

/**
 * Retrieves the current network registration state for the WWAN connection.
 * @return {Windows.Networking.Connectivity.WwanNetworkRegistrationState} The current network registration state.
 */
Windows.Networking.Connectivity.WwanConnectionProfileDetails.prototype.getNetworkRegistrationState = function() {};

/** @const */
Windows.Networking.Connectivity.WwanDataClass = {};
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.none;
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.gprs;
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.edge;
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.umts;
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.hsdpa;
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.hsupa;
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.lteAdvanced;
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.cdma1xRtt;
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.cdma1xEvdo;
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.cdma1xEvdoRevA;
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.cdma1xEvdv;
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.cdma3xRtt;
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.cdma1xEvdoRevB;
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.cdmaUmb;
/** @const {number} */
Windows.Networking.Connectivity.WwanDataClass.custom;

/** @const */
Windows.Networking.Connectivity.WwanNetworkRegistrationState = {};
/** @const {number} */
Windows.Networking.Connectivity.WwanNetworkRegistrationState.none;
/** @const {number} */
Windows.Networking.Connectivity.WwanNetworkRegistrationState.deregistered;
/** @const {number} */
Windows.Networking.Connectivity.WwanNetworkRegistrationState.searching;
/** @const {number} */
Windows.Networking.Connectivity.WwanNetworkRegistrationState.home;
/** @const {number} */
Windows.Networking.Connectivity.WwanNetworkRegistrationState.roaming;
/** @const {number} */
Windows.Networking.Connectivity.WwanNetworkRegistrationState.partner;
/** @const {number} */
Windows.Networking.Connectivity.WwanNetworkRegistrationState.denied;
/**
 * @record
 * @struct
 */
Windows.Networking.Connectivity.NetworkUsageStates = function() {};
 /** @type {Windows.Networking.Connectivity.TriStates} */
Windows.Networking.Connectivity.NetworkUsageStates.prototype.roaming;
 /** @type {Windows.Networking.Connectivity.TriStates} */
Windows.Networking.Connectivity.NetworkUsageStates.prototype.shared;

/** @typedef {function(!Windows.WinRTEvent<?>): void} */
Windows.Networking.Connectivity.NetworkStatusChangedEventHandler;

/** @const */
Windows.Networking.DomainNameType = {};
/** @const {number} */
Windows.Networking.DomainNameType.suffix;
/** @const {number} */
Windows.Networking.DomainNameType.fullyQualified;

/**
 * @constructor
 * @struct
 * Creates a new EndpointPair object.
 * @param {!Windows.Networking.HostName} localHostName The local hostname or IP address for the EndpointPair object.
 * @param {string} localServiceName The local service name or the local TCP or UDP port number for the EndpointPair object.
 * @param {!Windows.Networking.HostName} remoteHostName The remote hostname or IP address for the EndpointPair object.
 * @param {string} remoteServiceName The remote service name or the remote TCP or UDP port number for the EndpointPair object.
 */
Windows.Networking.EndpointPair = function(localHostName, localServiceName, remoteHostName, remoteServiceName) {};
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.EndpointPair.prototype.localHostName;
 /** @type {string} */
Windows.Networking.EndpointPair.prototype.localServiceName;
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.EndpointPair.prototype.remoteHostName;
 /** @type {string} */
Windows.Networking.EndpointPair.prototype.remoteServiceName;

/**
 * @constructor
 * @struct
 * Creates a new HostName object from a string that contains a hostname or an IP address.
 * @param {string} hostName A string that contains a hostname or an IP address.
 */
Windows.Networking.HostName = function(hostName) {};
 /** @type {string} */
Windows.Networking.HostName.prototype.canonicalName;
 /** @type {string} */
Windows.Networking.HostName.prototype.displayName;
 /** @type {!Windows.Networking.Connectivity.IPInformation} */
Windows.Networking.HostName.prototype.ipInformation;
 /** @type {string} */
Windows.Networking.HostName.prototype.rawName;
 /** @type {Windows.Networking.HostNameType} */
Windows.Networking.HostName.prototype.type;

/**
 * Compares two strings to determine if they represent the same hostname.
 * @param {string} value1 A hostname or IP address.
 * @param {string} value2 A hostname or IP address.
 * @return {number} The return value indicates the lexicographic relation of value1 to value2. If the two parameters represent the same canonical hostname, then zero is returned. If value1 is less than value2, the return value is less than zero. If value1 is greater than value2, the return vale is greater than zero.
 */
Windows.Networking.HostName.compare = function(value1, value2) {};

/**
 * Determines whether the specified HostName object has an equivalent value to the current HostName object.
 * @param {!Windows.Networking.HostName} hostName A HostName object that is compared with the current HostName.
 * @return {boolean} A Boolean value that indicates whether the specified HostName object is equal to the current HostName object.
 */
Windows.Networking.HostName.prototype.isEqual = function(hostName) {};

/** @const */
Windows.Networking.HostNameSortOptions = {};
/** @const {number} */
Windows.Networking.HostNameSortOptions.none;
/** @const {number} */
Windows.Networking.HostNameSortOptions.optimizeForLongConnections;

/** @const */
Windows.Networking.HostNameType = {};
/** @const {number} */
Windows.Networking.HostNameType.domainName;
/** @const {number} */
Windows.Networking.HostNameType.ipv4;
/** @const {number} */
Windows.Networking.HostNameType.ipv6;
/** @const {number} */
Windows.Networking.HostNameType.bluetooth;
/** @const */
Windows.Networking.NetworkOperators = {};

/** @const */
Windows.Networking.NetworkOperators.DataClasses = {};
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.none;
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.gprs;
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.edge;
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.umts;
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.hsdpa;
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.hsupa;
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.lteAdvanced;
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.cdma1xRtt;
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.cdma1xEvdo;
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.cdma1xEvdoRevA;
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.cdma1xEvdv;
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.cdma3xRtt;
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.cdma1xEvdoRevB;
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.cdmaUmb;
/** @const {number} */
Windows.Networking.NetworkOperators.DataClasses.custom;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.HotspotAuthenticationContext = function() {};
 /** @type {!Windows.Foundation.Uri} */
Windows.Networking.NetworkOperators.HotspotAuthenticationContext.prototype.authenticationUrl;
 /** @type {!Windows.Networking.Connectivity.NetworkAdapter} */
Windows.Networking.NetworkOperators.HotspotAuthenticationContext.prototype.networkAdapter;
 /** @type {!Windows.Foundation.Uri} */
Windows.Networking.NetworkOperators.HotspotAuthenticationContext.prototype.redirectMessageUrl;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Networking.NetworkOperators.HotspotAuthenticationContext.prototype.redirectMessageXml;
 /** @type {number} */
Windows.Networking.NetworkOperators.HotspotAuthenticationContext.prototype.wirelessNetworkId;

/**
 * Gets the context of an authentication attempt.
 * @param {string} evenToken The event token retrieved from the network operator hotspot authentication event . The token is a GUID in string format.
 * @return {{context: !Windows.Networking.NetworkOperators.HotspotAuthenticationContext, returnValue: boolean}}
 */
Windows.Networking.NetworkOperators.HotspotAuthenticationContext.tryGetAuthenticationContext = function(evenToken) {};

/**
 * Aborts the current authentication attempt and disconnects the WLAN interface from the hotspot.
 * @param {boolean} markAsManual If true, Windows disables the auto-connect property for the corresponding WLAN profile and avoids future auto-connects to this hotspot. Otherwise, false.
 * @return {void}
 */
Windows.Networking.NetworkOperators.HotspotAuthenticationContext.prototype.abortAuthentication = function(markAsManual) {};

/**
 * Provides credentials to Windows for hotspot authentication
 * @param {string} userName The UserName parameter of the Wireless Internet Service Provider roaming (WISPr) authentication protocol. IssueCredentials performs URL encoding before submitting the value to the server. If this string is empty, the corresponding authentication parameter is skipped.
 * @param {string} password The Password parameter of the WISPr authentication protocol. IssueCredentials performs URL encoding before submitting the value to the server. If this string is empty, the corresponding authentication parameter is skipped.
 * @param {string} extraParameters Additional parameters to be appended to the authentication string. IssueCredentials appends this parameter after an "&" character to the HTTP POST string as is without any encoding. This can be used to add multiple parameters. The default for this parameter is an empty string.
 * @param {boolean} markAsManualConnectOnFailure If true, an application permanently disables the auto-connect property on a connection. If authentication fails, the connection will be disconnected and not retried in the current user session. Otherwise, false.
 * @return {void}
 */
Windows.Networking.NetworkOperators.HotspotAuthenticationContext.prototype.issueCredentials = function(userName, password, extraParameters, markAsManualConnectOnFailure) {};

/**
 * Asynchronously provides credentials to Windows for hotspot authentication Windows does not cache these credentials and another authentication event will be raised when the system connects to the same hotspot again.
 * @param {string} userName The UserName parameter of the Wireless Internet Service Provider roaming (WISPr) authentication protocol. IssueCredentials performs URL encoding before submitting the value to the server. If this string is empty, the corresponding authentication parameter is skipped.
 * @param {string} password The Password parameter of the WISPr authentication protocol. IssueCredentials performs URL encoding before submitting the value to the server. If this string is empty, the corresponding authentication parameter is skipped.
 * @param {string} extraParameters Additional parameters to be appended to the authentication string. IssueCredentials appends this parameter after an "&" character to the HTTP POST string as is without any encoding. This can be used to add multiple parameters. The default for this parameter is an empty string.
 * @param {boolean} markAsManualConnectOnFailure If true, an application permanently disables the auto-connect property on a connection. If authentication fails, the connection will be disconnected and not retried in the current user session. Otherwise, false.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult>>} Results of the Hotspot authentication request.
 */
Windows.Networking.NetworkOperators.HotspotAuthenticationContext.prototype.issueCredentialsAsync = function(userName, password, extraParameters, markAsManualConnectOnFailure) {};

/**
 * Skips Wireless Internet Service Provider roaming (WISPr) Windows authentication.
 * @return {void}
 */
Windows.Networking.NetworkOperators.HotspotAuthenticationContext.prototype.skipAuthentication = function() {};

/**
 * Called by a background task handler to launch the foreground application when there is an authentication attempt to complete.
 * @param {string} packageRelativeApplicationId The foreground application ID within its application package. The application must belong to the same package as the background task handler.
 * @param {string} applicationParameters Optional command line parameters that are passed to the application at launch.
 * @return {void}
 */
Windows.Networking.NetworkOperators.HotspotAuthenticationContext.prototype.triggerAttentionRequired = function(packageRelativeApplicationId, applicationParameters) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.HotspotAuthenticationEventDetails = function() {};
 /** @type {string} */
Windows.Networking.NetworkOperators.HotspotAuthenticationEventDetails.prototype.eventToken;

/** @const */
Windows.Networking.NetworkOperators.HotspotAuthenticationResponseCode = {};
/** @const {number} */
Windows.Networking.NetworkOperators.HotspotAuthenticationResponseCode.noError;
/** @const {number} */
Windows.Networking.NetworkOperators.HotspotAuthenticationResponseCode.loginSucceeded;
/** @const {number} */
Windows.Networking.NetworkOperators.HotspotAuthenticationResponseCode.loginFailed;
/** @const {number} */
Windows.Networking.NetworkOperators.HotspotAuthenticationResponseCode.radiusServerError;
/** @const {number} */
Windows.Networking.NetworkOperators.HotspotAuthenticationResponseCode.networkAdministratorError;
/** @const {number} */
Windows.Networking.NetworkOperators.HotspotAuthenticationResponseCode.loginAborted;
/** @const {number} */
Windows.Networking.NetworkOperators.HotspotAuthenticationResponseCode.accessGatewayInternalError;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult = function() {};
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult.prototype.authenticationReplyXml;
 /** @type {boolean} */
Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult.prototype.hasNetworkErrorOccurred;
 /** @type {!Windows.Foundation.Uri} */
Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult.prototype.logoffUrl;
 /** @type {Windows.Networking.NetworkOperators.HotspotAuthenticationResponseCode} */
Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult.prototype.responseCode;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.KnownCSimFilePaths = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownCSimFilePaths.efSpn;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownCSimFilePaths.gid1;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownCSimFilePaths.gid2;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.KnownRuimFilePaths = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownRuimFilePaths.efSpn;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownRuimFilePaths.gid1;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownRuimFilePaths.gid2;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.KnownSimFilePaths = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownSimFilePaths.efOns;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownSimFilePaths.efSpn;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownSimFilePaths.gid1;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownSimFilePaths.gid2;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.KnownUSimFilePaths = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownUSimFilePaths.efOpl;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownUSimFilePaths.efPnn;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownUSimFilePaths.efSpn;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownUSimFilePaths.gid1;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.KnownUSimFilePaths.gid2;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandAccount = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Networking.NetworkOperators.MobileBroadbandAccount.availableNetworkAccountIds;
 /** @type {!Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation} */
Windows.Networking.NetworkOperators.MobileBroadbandAccount.prototype.currentDeviceInformation;
 /** @type {!Windows.Networking.NetworkOperators.MobileBroadbandNetwork} */
Windows.Networking.NetworkOperators.MobileBroadbandAccount.prototype.currentNetwork;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandAccount.prototype.networkAccountId;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandAccount.prototype.serviceProviderGuid;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandAccount.prototype.serviceProviderName;

/**
 * Creates a mobile broadband account for the mobile device associated with the supplied network account ID.
 * @param {string} networkAccountId The network account ID to use to select the corresponding mobile broadband device to use for the account.
 * @return {!Windows.Networking.NetworkOperators.MobileBroadbandAccount} A mobile broadband account for the mobile device associated with the supplied network account ID.
 */
Windows.Networking.NetworkOperators.MobileBroadbandAccount.createFromNetworkAccountId = function(networkAccountId) {};

/**
 * Retrieves an array of ConnectionProfile objects that represent connections associated with the Mobile Broadband account.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.Connectivity.ConnectionProfile>} An array of ConnectionProfile objects.
 */
Windows.Networking.NetworkOperators.MobileBroadbandAccount.prototype.getConnectionProfiles = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs = function() {};
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs.prototype.networkAccountId;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs = function() {};
 /** @type {boolean} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs.prototype.hasDeviceInformationChanged;
 /** @type {boolean} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs.prototype.hasNetworkChanged;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs.prototype.networkAccountId;

/**
 * @constructor
 * @struct
 * Creates a new instance of a MobileBroadbandAccountWatcher .
 */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher = function() {};
 /** @type {function(?): void} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher.prototype.onaccountadded;
 /** @type {function(?): void} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher.prototype.onaccountremoved;
 /** @type {function(?): void} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher.prototype.onaccountupdated;
 /** @type {function(?): void} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher.prototype.onenumerationcompleted;
 /** @type {function(?): void} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher.prototype.onstopped;
 /** @type {Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcherStatus} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher.prototype.removeEventListener = function(type, listener) {};

/**
 * Starts the account watcher.
 * @return {void}
 */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher.prototype.start = function() {};

/**
 * Stops the account watcher.
 * @return {void}
 */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher.prototype.stop = function() {};

/** @const */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcherStatus = {};
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcherStatus.created;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcherStatus.started;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcherStatus.enumerationCompleted;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcherStatus.stopped;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcherStatus.aborted;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation = function() {};
 /** @type {Windows.Devices.Sms.CellularClass} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.cellularClass;
 /** @type {Windows.Networking.NetworkOperators.MobileBroadbandRadioState} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.currentRadioState;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.customDataClass;
 /** @type {Windows.Networking.NetworkOperators.DataClasses} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.dataClasses;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.deviceId;
 /** @type {Windows.Networking.NetworkOperators.MobileBroadbandDeviceType} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.deviceType;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.firmwareInformation;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.manufacturer;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.mobileEquipmentId;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.model;
 /** @type {Windows.Networking.NetworkOperators.NetworkDeviceStatus} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.networkDeviceStatus;
 /** @type {!Windows.Networking.NetworkOperators.MobileBroadbandPinManager} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.pinManager;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.revision;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.serialNumber;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.simIccId;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.subscriberId;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation.prototype.telephoneNumbers;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceService = function() {};
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceService.prototype.deviceServiceId;
 /** @type {!Windows.Foundation.Collections.IVectorView<number>} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceService.prototype.supportedCommands;

/**
 * Opens a new MobileBroadbandDeviceServiceCommandSession for the mobile broadband device service.
 * @return {!Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandSession} A new command session for the mobile broadband device service.
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceService.prototype.openCommandSession = function() {};

/**
 * Opens a new MobileBroadbandDeviceServiceDataSession for the mobile broadband device service.
 * @return {!Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession} A new data session for the Mobile Broadband device service.
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceService.prototype.openDataSession = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandResult = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandResult.prototype.responseData;
 /** @type {number} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandResult.prototype.statusCode;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandSession = function() {};

/**
 * Closes the command session on a mobile broadband device service.
 * @return {void}
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandSession.prototype.closeSession = function() {};

/**
 * Starts an asynchronous operation on a mobile broadband device service to send a query command to the command session.
 * @param {number} commandId The command identifier for the query command to be executed.
 * @param {!Windows.Storage.Streams.IBuffer} data The data to be submitted as part of the command.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandResult>>} An asynchronous operation that returns the result of the command.
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandSession.prototype.sendQueryCommandAsync = function(commandId, data) {};

/**
 * Starts an asynchronous operation on a mobile broadband device service to send a set command to the command session.
 * @param {number} commandId The command identifier for the set command to be executed.
 * @param {!Windows.Storage.Streams.IBuffer} data The data to be submitted as part of the command.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandResult>>} An asynchronous operation that returns the result of the command.
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandSession.prototype.sendSetCommandAsync = function(commandId, data) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataReceivedEventArgs = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataReceivedEventArgs.prototype.receivedData;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession = function() {};
 /** @type {function(?): void} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession.prototype.ondatareceived;

/**
 * Closes the data session on a mobile broadband device service.
 * @return {void}
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession.prototype.closeSession = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession.prototype.removeEventListener = function(type, listener) {};

/**
 * Starts an asynchronous operation on a mobile broadband device service to write data to the data session.
 * @param {!Windows.Storage.Streams.IBuffer} value The data to be submitted as part of the write operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous operation that returns the result of the write operation.
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession.prototype.writeDataAsync = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceInformation = function() {};
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceInformation.prototype.deviceServiceId;
 /** @type {boolean} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceInformation.prototype.isDataReadSupported;
 /** @type {boolean} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceInformation.prototype.isDataWriteSupported;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceTriggerDetails = function() {};
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceTriggerDetails.prototype.deviceId;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceTriggerDetails.prototype.deviceServiceId;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceTriggerDetails.prototype.receivedData;

/** @const */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceType = {};
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceType.unknown;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceType.embedded;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceType.removable;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandDeviceType.remote;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandModem = function() {};
 /** @type {!Windows.Networking.NetworkOperators.MobileBroadbandAccount} */
Windows.Networking.NetworkOperators.MobileBroadbandModem.prototype.currentAccount;
 /** @type {!Windows.Networking.NetworkOperators.MobileBroadbandNetwork} */
Windows.Networking.NetworkOperators.MobileBroadbandModem.prototype.currentNetwork;
 /** @type {!Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation} */
Windows.Networking.NetworkOperators.MobileBroadbandModem.prototype.deviceInformation;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceInformation>} */
Windows.Networking.NetworkOperators.MobileBroadbandModem.prototype.deviceServices;
 /** @type {boolean} */
Windows.Networking.NetworkOperators.MobileBroadbandModem.prototype.isResetSupported;
 /** @type {number} */
Windows.Networking.NetworkOperators.MobileBroadbandModem.prototype.maxDeviceServiceCommandSizeInBytes;
 /** @type {number} */
Windows.Networking.NetworkOperators.MobileBroadbandModem.prototype.maxDeviceServiceDataSizeInBytes;

/**
 * Determine if a mobile broadband device is a Wireless WAN device.
 * @param {string} deviceId The mobile broadband device ID
 * @return {!Windows.Networking.NetworkOperators.MobileBroadbandModem} The mobile broadband modem.
 */
Windows.Networking.NetworkOperators.MobileBroadbandModem.fromId = function(deviceId) {};

/**
 * Determines the default mobile broadband modem.
 * @return {!Windows.Networking.NetworkOperators.MobileBroadbandModem} The mobile broadband modem.
 */
Windows.Networking.NetworkOperators.MobileBroadbandModem.getDefault = function() {};

/**
 * Gets a device selector for the mobile broadband modem.
 * @return {string} A device selector for the mobile broadband modem.
 */
Windows.Networking.NetworkOperators.MobileBroadbandModem.getDeviceSelector = function() {};

/**
 * Asynchronously retrieves mobile broadband modem configuration information.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration>>} An asynchronous retrieval operation. On successful completion, contains a MobileBroadbandModemConfiguration object representing the current configuration.
 */
Windows.Networking.NetworkOperators.MobileBroadbandModem.prototype.getCurrentConfigurationAsync = function() {};

/**
 * Gets a specific device service for the mobile broadband modem.
 * @param {string} deviceServiceId The unique device service identifier for the device service to be retrieved.
 * @return {!Windows.Networking.NetworkOperators.MobileBroadbandDeviceService} The mobile broadband device service retrieved.
 */
Windows.Networking.NetworkOperators.MobileBroadbandModem.prototype.getDeviceService = function(deviceServiceId) {};

/**
 * Asynchronously performs a reset operation on the mobile broadband modem.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous reset operation.
 */
Windows.Networking.NetworkOperators.MobileBroadbandModem.prototype.resetAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration = function() {};
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration.prototype.homeProviderId;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration.prototype.homeProviderName;
 /** @type {!Windows.Networking.NetworkOperators.MobileBroadbandUicc} */
Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration.prototype.uicc;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandNetwork = function() {};
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandNetwork.prototype.accessPointName;
 /** @type {number} */
Windows.Networking.NetworkOperators.MobileBroadbandNetwork.prototype.activationNetworkError;
 /** @type {!Windows.Networking.Connectivity.NetworkAdapter} */
Windows.Networking.NetworkOperators.MobileBroadbandNetwork.prototype.networkAdapter;
 /** @type {Windows.Networking.NetworkOperators.NetworkRegistrationState} */
Windows.Networking.NetworkOperators.MobileBroadbandNetwork.prototype.networkRegistrationState;
 /** @type {number} */
Windows.Networking.NetworkOperators.MobileBroadbandNetwork.prototype.packetAttachNetworkError;
 /** @type {Windows.Networking.NetworkOperators.DataClasses} */
Windows.Networking.NetworkOperators.MobileBroadbandNetwork.prototype.registeredDataClass;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandNetwork.prototype.registeredProviderId;
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandNetwork.prototype.registeredProviderName;
 /** @type {number} */
Windows.Networking.NetworkOperators.MobileBroadbandNetwork.prototype.registrationNetworkError;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.NetworkOperators.MobileBroadbandUiccApp>} */
Windows.Networking.NetworkOperators.MobileBroadbandNetwork.prototype.registrationUiccApps;

/**
 * Asynchronously retrieves a value indicating whether this network currently supports voice calls.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An asynchronous retrieval operation. On successful completion, contains a value indicating whether the network supports voice calls (if true) or not.
 */
Windows.Networking.NetworkOperators.MobileBroadbandNetwork.prototype.getVoiceCallSupportAsync = function() {};

/**
 * Displays the connect UI for a specific mobile network.
 * @return {void}
 */
Windows.Networking.NetworkOperators.MobileBroadbandNetwork.prototype.showConnectionUI = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandNetworkRegistrationStateChange = function() {};
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandNetworkRegistrationStateChange.prototype.deviceId;
 /** @type {!Windows.Networking.NetworkOperators.MobileBroadbandNetwork} */
Windows.Networking.NetworkOperators.MobileBroadbandNetworkRegistrationStateChange.prototype.network;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandNetworkRegistrationStateChangeTriggerDetails = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.NetworkOperators.MobileBroadbandNetworkRegistrationStateChange>} */
Windows.Networking.NetworkOperators.MobileBroadbandNetworkRegistrationStateChangeTriggerDetails.prototype.networkRegistrationStateChanges;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandPin = function() {};
 /** @type {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPin.prototype.attemptsRemaining;
 /** @type {boolean} */
Windows.Networking.NetworkOperators.MobileBroadbandPin.prototype.enabled;
 /** @type {Windows.Networking.NetworkOperators.MobileBroadbandPinFormat} */
Windows.Networking.NetworkOperators.MobileBroadbandPin.prototype.format;
 /** @type {Windows.Networking.NetworkOperators.MobileBroadbandPinLockState} */
Windows.Networking.NetworkOperators.MobileBroadbandPin.prototype.lockState;
 /** @type {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPin.prototype.maxLength;
 /** @type {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPin.prototype.minLength;
 /** @type {Windows.Networking.NetworkOperators.MobileBroadbandPinType} */
Windows.Networking.NetworkOperators.MobileBroadbandPin.prototype.type;

/**
 * Starts an asynchronous operation to change an already-enabled mobile broadband PIN.
 * @param {string} currentPin The current mobile broadband PIN.
 * @param {string} newPin The new mobile broadband PIN.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult>>} An asynchronous operation that returns the result.
 */
Windows.Networking.NetworkOperators.MobileBroadbandPin.prototype.changeAsync = function(currentPin, newPin) {};

/**
 * Starts an asynchronous operation to disable a previously-enabled mobile broadband PIN.
 * @param {string} currentPin The current mobile broadband PIN.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult>>} An asynchronous operation that returns the result.
 */
Windows.Networking.NetworkOperators.MobileBroadbandPin.prototype.disableAsync = function(currentPin) {};

/**
 * Starts an asynchronous operation to enable a previously-disabled mobile broadband PIN.
 * @param {string} currentPin The current mobile broadband PIN.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult>>} An asynchronous operation that returns the result.
 */
Windows.Networking.NetworkOperators.MobileBroadbandPin.prototype.enableAsync = function(currentPin) {};

/**
 * Starts an asynchronous operation to get the current mobile broadband PIN from the user.
 * @param {string} currentPin The current mobile broadband PIN.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult>>} An asynchronous operation that returns the result.
 */
Windows.Networking.NetworkOperators.MobileBroadbandPin.prototype.enterAsync = function(currentPin) {};

/**
 * Starts an asynchronous operation to unblock a previously-blocked mobile broadband PIN using a PIN unlock key (PUK).
 * @param {string} pinUnblockKey The PIN unblock key.
 * @param {string} newPin The new mobile broadband PIN.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult>>} An asynchronous operation that returns the result.
 */
Windows.Networking.NetworkOperators.MobileBroadbandPin.prototype.unblockAsync = function(pinUnblockKey, newPin) {};

/** @const */
Windows.Networking.NetworkOperators.MobileBroadbandPinFormat = {};
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinFormat.unknown;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinFormat.numeric;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinFormat.alphanumeric;

/** @const */
Windows.Networking.NetworkOperators.MobileBroadbandPinLockState = {};
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinLockState.unknown;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinLockState.unlocked;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinLockState.pinRequired;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinLockState.pinUnblockKeyRequired;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChange = function() {};
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChange.prototype.deviceId;
 /** @type {Windows.Networking.NetworkOperators.MobileBroadbandPinLockState} */
Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChange.prototype.pinLockState;
 /** @type {Windows.Networking.NetworkOperators.MobileBroadbandPinType} */
Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChange.prototype.pinType;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChangeTriggerDetails = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChange>} */
Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChangeTriggerDetails.prototype.pinLockStateChanges;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandPinManager = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Networking.NetworkOperators.MobileBroadbandPinType>} */
Windows.Networking.NetworkOperators.MobileBroadbandPinManager.prototype.supportedPins;

/**
 * Gets the mobile broadband PIN of a specific PIN type.
 * @param {Windows.Networking.NetworkOperators.MobileBroadbandPinType} pinType The mobile broadband PIN type.
 * @return {!Windows.Networking.NetworkOperators.MobileBroadbandPin} The mobile broadband PIN returned. This value is either provided by the end user or from a cache if allowed. .
 */
Windows.Networking.NetworkOperators.MobileBroadbandPinManager.prototype.getPin = function(pinType) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult = function() {};
 /** @type {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult.prototype.attemptsRemaining;
 /** @type {boolean} */
Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult.prototype.isSuccessful;

/** @const */
Windows.Networking.NetworkOperators.MobileBroadbandPinType = {};
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinType.none;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinType.custom;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinType.pin1;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinType.pin2;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinType.simPin;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinType.firstSimPin;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinType.networkPin;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinType.networkSubsetPin;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinType.serviceProviderPin;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinType.corporatePin;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandPinType.subsidyLock;

/** @const */
Windows.Networking.NetworkOperators.MobileBroadbandRadioState = {};
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandRadioState.off;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandRadioState.on;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandRadioStateChange = function() {};
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandRadioStateChange.prototype.deviceId;
 /** @type {Windows.Networking.NetworkOperators.MobileBroadbandRadioState} */
Windows.Networking.NetworkOperators.MobileBroadbandRadioStateChange.prototype.radioState;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandRadioStateChangeTriggerDetails = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.NetworkOperators.MobileBroadbandRadioStateChange>} */
Windows.Networking.NetworkOperators.MobileBroadbandRadioStateChangeTriggerDetails.prototype.radioStateChanges;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandUicc = function() {};
 /** @type {string} */
Windows.Networking.NetworkOperators.MobileBroadbandUicc.prototype.simIccId;

/**
 * Asynchronously retrieves a list of mobile broadband UICC (SIM card) applications.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.MobileBroadbandUiccAppsResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.MobileBroadbandUiccAppsResult>>} An asynchronous retrieval operation. On successful completion, returns an object with the results of the retrieval operation.
 */
Windows.Networking.NetworkOperators.MobileBroadbandUicc.prototype.getUiccAppsAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandUiccApp = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccApp.prototype.id;
 /** @type {Windows.Networking.NetworkOperators.UiccAppKind} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccApp.prototype.kind;

/**
 * Asynchronously retrieves details about a UICC application.
 * @param {!Windows.Foundation.Collections.IIterable<number>} uiccFilePath A sequence of characters specifying the UICC file path of the application. Use the MobileBroadbandUiccApp.Id property value of this instance, to get app record details for this application.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult>>} An asynchronous retrieval operation. On successful completion, returns a MobileBroadbandUiccAppRecordDetailsResult instance initialized for the specified application's details.
 */
Windows.Networking.NetworkOperators.MobileBroadbandUiccApp.prototype.getRecordDetailsAsync = function(uiccFilePath) {};

/**
 * Asynchronously reads a UICC application record.
 * @param {!Windows.Foundation.Collections.IIterable<number>} uiccFilePath A sequence of characters specifying the path to the UICC application.
 * @param {number} recordIndex The record index within the UICC application's records.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.MobileBroadbandUiccAppReadRecordResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.MobileBroadbandUiccAppReadRecordResult>>} An asynchronous retrieval operation. On successful completion, returns a MobileBroadbandUiccAppReadRecordResult with the result of the operation.
 */
Windows.Networking.NetworkOperators.MobileBroadbandUiccApp.prototype.readRecordAsync = function(uiccFilePath, recordIndex) {};

/** @const */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppOperationStatus = {};
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppOperationStatus.success;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppOperationStatus.invalidUiccFilePath;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppOperationStatus.accessConditionNotHeld;
/** @const {number} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppOperationStatus.uiccBusy;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppReadRecordResult = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppReadRecordResult.prototype.data;
 /** @type {Windows.Networking.NetworkOperators.MobileBroadbandUiccAppOperationStatus} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppReadRecordResult.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult = function() {};
 /** @type {Windows.Networking.NetworkOperators.UiccAppRecordKind} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult.prototype.kind;
 /** @type {Windows.Networking.NetworkOperators.UiccAccessCondition} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult.prototype.readAccessCondition;
 /** @type {number} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult.prototype.recordCount;
 /** @type {number} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult.prototype.recordSize;
 /** @type {Windows.Networking.NetworkOperators.MobileBroadbandUiccAppOperationStatus} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult.prototype.status;
 /** @type {Windows.Networking.NetworkOperators.UiccAccessCondition} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult.prototype.writeAccessCondition;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppsResult = function() {};
 /** @type {Windows.Networking.NetworkOperators.MobileBroadbandUiccAppOperationStatus} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppsResult.prototype.status;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.NetworkOperators.MobileBroadbandUiccApp>} */
Windows.Networking.NetworkOperators.MobileBroadbandUiccAppsResult.prototype.uiccApps;

/** @const */
Windows.Networking.NetworkOperators.NetworkDeviceStatus = {};
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkDeviceStatus.deviceNotReady;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkDeviceStatus.deviceReady;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkDeviceStatus.simNotInserted;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkDeviceStatus.badSim;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkDeviceStatus.deviceHardwareFailure;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkDeviceStatus.accountNotActivated;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkDeviceStatus.deviceLocked;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkDeviceStatus.deviceBlocked;

/** @const */
Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType = {};
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType.gsm;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType.cdma;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType.ussd;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType.dataPlanThresholdReached;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType.dataPlanReset;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType.dataPlanDeleted;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType.profileConnected;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType.profileDisconnected;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType.registeredRoaming;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType.registeredHome;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType.tetheringEntitlementCheck;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType.tetheringOperationalStateChanged;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType.tetheringNumberOfClientsChanged;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails = function() {};
 /** @type {number} */
Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails.prototype.encodingType;
 /** @type {string} */
Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails.prototype.message;
 /** @type {string} */
Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails.prototype.networkAccountId;
 /** @type {Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType} */
Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails.prototype.notificationType;
 /** @type {string} */
Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails.prototype.ruleId;
 /** @type {!Windows.Devices.Sms.ISmsMessage} */
Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails.prototype.smsMessage;

/**
 * Used to indicate if tethering is permitted for a device. If it is not, a reason can be provided.
 * @param {boolean} allow true if tethering is permitted; otherwise, false.
 * @param {string} entitlementFailureReason The reason tethering is not permitted.
 * @return {void}
 */
Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails.prototype.authorizeTethering = function(allow, entitlementFailureReason) {};

/**
 * @constructor
 * @struct
 * Creates an instance of the NetworkOperatorTetheringAccessPointConfiguration .
 */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration = function() {};
 /** @type {string} */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration.prototype.passphrase;
 /** @type {string} */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration.prototype.ssid;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringClient = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.HostName>} */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringClient.prototype.hostNames;
 /** @type {string} */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringClient.prototype.macAddress;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager = function() {};
 /** @type {number} */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager.prototype.clientCount;
 /** @type {number} */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager.prototype.maxClientCount;
 /** @type {Windows.Networking.NetworkOperators.TetheringOperationalState} */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager.prototype.tetheringOperationalState;

/**
 * Creates a NetworkOperatorTetheringManager using the given profile.
 * @param {!Windows.Networking.Connectivity.ConnectionProfile} profile Connection profile to be used.
 * @return {!Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager} The resulting manager object.
 */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager.createFromConnectionProfile = function(profile) {};

/**
 * Creates an instance of NetworkOperatorTetheringManager for a specific network account using the provided network account ID for the mobile broadband device.
 * @param {string} networkAccountId The network account ID.
 * @return {!Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager} A NetworkOperatorTetheringManager object.
 */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager.createFromNetworkAccountId = function(networkAccountId) {};

/**
 * Indicates if a device is capable of creating a tethering network. Possible values are defined by TetheringCapability .
 * @param {string} networkAccountId The network account ID.
 * @return {Windows.Networking.NetworkOperators.TetheringCapability} The tethering capabilities of a network account.
 */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager.getTetheringCapability = function(networkAccountId) {};

/**
 * Gets tethering capabilities, based on the given connection profile.
 * @param {!Windows.Networking.Connectivity.ConnectionProfile} profile Connection profile to be checked.
 * @return {Windows.Networking.NetworkOperators.TetheringCapability} Tethering capabilities of the connection profile.
 */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager.getTetheringCapabilityFromConnectionProfile = function(profile) {};

/**
 * Use this method to provide tethering network configuration details for the tethering network.
 * @param {!Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration} configuration Provides a network account ID (SSID) and specifies the passphrase used for authentication when establishing a tethered network connection.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The asynchronous action.
 */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager.prototype.configureAccessPointAsync = function(configuration) {};

/**
 * Gets the current access point configuration for a network account as defined by a NetworkOperatorTetheringAccessPointConfiguration object.
 * @return {!Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration} Indicates the network account id and specifies the pass-phrase used for authentication when establishing a connection over the tethering network.
 */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager.prototype.getCurrentAccessPointConfiguration = function() {};

/**
 * Retrieves a list of tethering clients for this NetworkOperatorTetheringManager .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.NetworkOperators.NetworkOperatorTetheringClient>} A list of clients.
 */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager.prototype.getTetheringClients = function() {};

/**
 * Establishes the tethering network.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult>>} The result of the tethering network operation.
 */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager.prototype.startTetheringAsync = function() {};

/**
 * Shuts down the tethering network.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult>>} The result of the tethering network operation.
 */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager.prototype.stopTetheringAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult = function() {};
 /** @type {string} */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult.prototype.additionalErrorMessage;
 /** @type {Windows.Networking.NetworkOperators.TetheringOperationStatus} */
Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult.prototype.status;

/** @const */
Windows.Networking.NetworkOperators.NetworkRegistrationState = {};
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkRegistrationState.none;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkRegistrationState.deregistered;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkRegistrationState.searching;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkRegistrationState.home;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkRegistrationState.roaming;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkRegistrationState.partner;
/** @const {number} */
Windows.Networking.NetworkOperators.NetworkRegistrationState.denied;

/** @const */
Windows.Networking.NetworkOperators.ProfileMediaType = {};
/** @const {number} */
Windows.Networking.NetworkOperators.ProfileMediaType.wlan;
/** @const {number} */
Windows.Networking.NetworkOperators.ProfileMediaType.wwan;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.ProvisionFromXmlDocumentResults = function() {};
 /** @type {boolean} */
Windows.Networking.NetworkOperators.ProvisionFromXmlDocumentResults.prototype.allElementsProvisioned;
 /** @type {string} */
Windows.Networking.NetworkOperators.ProvisionFromXmlDocumentResults.prototype.provisionResultsXml;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.ProvisionedProfile = function() {};

/**
 * Called by the application to update the cost for a specific profile.
 * @param {Windows.Networking.Connectivity.NetworkCostType} value Updates the cost for the profile.
 * @return {void}
 */
Windows.Networking.NetworkOperators.ProvisionedProfile.prototype.updateCost = function(value) {};

/**
 * Called by the application to update the usage for a specific profile.
 * @param {!Windows.Networking.NetworkOperators.ProfileUsage} value Updates the usage for a profile.
 * @return {void}
 */
Windows.Networking.NetworkOperators.ProvisionedProfile.prototype.updateUsage = function(value) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of a ProvisioningAgent .
 */
Windows.Networking.NetworkOperators.ProvisioningAgent = function() {};

/**
 * Creates a provisioning agent for the mobile device associated with the supplied network account ID.
 * @param {string} networkAccountId The network account ID to use to select the corresponding mobile broadband device to use for the provisioning agent.
 * @return {!Windows.Networking.NetworkOperators.ProvisioningAgent} The provisioning agent for the mobile device associated with the supplied network account ID.
 */
Windows.Networking.NetworkOperators.ProvisioningAgent.createFromNetworkAccountId = function(networkAccountId) {};

/**
 * Retrieves cost and plan information associated with the mobile broadband profile.
 * @param {Windows.Networking.NetworkOperators.ProfileMediaType} mediaType The media type that the profile belongs to.
 * @param {string} profileName The name of the profile that the cost will be applied to.
 * @return {!Windows.Networking.NetworkOperators.ProvisionedProfile} The profile.
 */
Windows.Networking.NetworkOperators.ProvisioningAgent.prototype.getProvisionedProfile = function(mediaType, profileName) {};

/**
 * Provisions a device for network connectivity asynchronously, based on the supplied XML document.
 * @param {string} provisioningXmlDocument An instance of CarrierControlSchema that contains the network connectivity provisioning information.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.ProvisionFromXmlDocumentResults, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.ProvisionFromXmlDocumentResults>>} An asynchronous handler to start the provisioning attempt and track its completion.
 */
Windows.Networking.NetworkOperators.ProvisioningAgent.prototype.provisionFromXmlDocumentAsync = function(provisioningXmlDocument) {};

/** @const */
Windows.Networking.NetworkOperators.TetheringCapability = {};
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringCapability.enabled;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringCapability.disabledByGroupPolicy;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringCapability.disabledByHardwareLimitation;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringCapability.disabledByOperator;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringCapability.disabledBySku;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringCapability.disabledByRequiredAppNotInstalled;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringCapability.disabledDueToUnknownCause;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringCapability.disabledBySystemCapability;

/** @const */
Windows.Networking.NetworkOperators.TetheringOperationStatus = {};
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringOperationStatus.success;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringOperationStatus.unknown;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringOperationStatus.mobileBroadbandDeviceOff;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringOperationStatus.wiFiDeviceOff;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringOperationStatus.entitlementCheckTimeout;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringOperationStatus.entitlementCheckFailure;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringOperationStatus.operationInProgress;

/** @const */
Windows.Networking.NetworkOperators.TetheringOperationalState = {};
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringOperationalState.unknown;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringOperationalState.on;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringOperationalState.off;
/** @const {number} */
Windows.Networking.NetworkOperators.TetheringOperationalState.inTransition;

/** @const */
Windows.Networking.NetworkOperators.UiccAccessCondition = {};
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAccessCondition.alwaysAllowed;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAccessCondition.pin1;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAccessCondition.pin2;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAccessCondition.pin3;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAccessCondition.pin4;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAccessCondition.administrative5;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAccessCondition.administrative6;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAccessCondition.neverAllowed;

/** @const */
Windows.Networking.NetworkOperators.UiccAppKind = {};
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAppKind.unknown;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAppKind.mf;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAppKind.mfSim;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAppKind.mfRuim;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAppKind.usim;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAppKind.csim;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAppKind.isim;

/** @const */
Windows.Networking.NetworkOperators.UiccAppRecordKind = {};
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAppRecordKind.unknown;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAppRecordKind.transparent;
/** @const {number} */
Windows.Networking.NetworkOperators.UiccAppRecordKind.recordOriented;

/**
 * @constructor
 * @struct
 * Creates a new instance of a UssdMessage and encodes the supplied string into the message payload.
 * @param {string} messageText The payload for the UssdMessage.
 */
Windows.Networking.NetworkOperators.UssdMessage = function(messageText) {};
 /** @type {number} */
Windows.Networking.NetworkOperators.UssdMessage.prototype.dataCodingScheme;
 /** @type {string} */
Windows.Networking.NetworkOperators.UssdMessage.prototype.payloadAsText;

/**
 * Gets the raw payload of this UssdMessage .
 * @return {!Array<number>} The raw payload of this UssdMessage .
 */
Windows.Networking.NetworkOperators.UssdMessage.prototype.getPayload = function() {};

/**
 * Sets the raw payload of this UssdMessage .
 * @param {!Array<number>} value The raw payload of this UssdMessage .
 * @return {void}
 */
Windows.Networking.NetworkOperators.UssdMessage.prototype.setPayload = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.UssdReply = function() {};
 /** @type {!Windows.Networking.NetworkOperators.UssdMessage} */
Windows.Networking.NetworkOperators.UssdReply.prototype.message;
 /** @type {Windows.Networking.NetworkOperators.UssdResultCode} */
Windows.Networking.NetworkOperators.UssdReply.prototype.resultCode;

/** @const */
Windows.Networking.NetworkOperators.UssdResultCode = {};
/** @const {number} */
Windows.Networking.NetworkOperators.UssdResultCode.noActionRequired;
/** @const {number} */
Windows.Networking.NetworkOperators.UssdResultCode.actionRequired;
/** @const {number} */
Windows.Networking.NetworkOperators.UssdResultCode.terminated;
/** @const {number} */
Windows.Networking.NetworkOperators.UssdResultCode.otherLocalClient;
/** @const {number} */
Windows.Networking.NetworkOperators.UssdResultCode.operationNotSupported;
/** @const {number} */
Windows.Networking.NetworkOperators.UssdResultCode.networkTimeout;
/**
 * @constructor
 * @struct
 */
Windows.Networking.NetworkOperators.UssdSession = function() {};

/**
 * Creates a USSD session for the mobile device associated with the supplied network account ID.
 * @param {string} networkAccountId The network account ID to use to select the corresponding mobile broadband device to use for the USSD session.
 * @return {!Windows.Networking.NetworkOperators.UssdSession} The USSD session for the mobile device associated with the supplied network account ID.
 */
Windows.Networking.NetworkOperators.UssdSession.createFromNetworkAccountId = function(networkAccountId) {};

/**
 * Creates a USSD session for the mobile device associated with the supplied network interface ID.
 * @param {string} networkInterfaceId The network interface ID to use to select the corresponding mobile broadband device to use for the USSD session.
 * @return {!Windows.Networking.NetworkOperators.UssdSession} The USSD session for the mobile device associated with the supplied network interface ID.
 */
Windows.Networking.NetworkOperators.UssdSession.createFromNetworkInterfaceId = function(networkInterfaceId) {};

/**
 * Closes the USSD session with the network.
 * @return {void}
 */
Windows.Networking.NetworkOperators.UssdSession.prototype.close = function() {};

/**
 * Sends a message to a USSD session and returns a handler to retrieve the reply asynchronously.
 * @param {!Windows.Networking.NetworkOperators.UssdMessage} message The message to send to the USSD session.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.NetworkOperators.UssdReply, !Windows.Foundation.IAsyncOperation<!Windows.Networking.NetworkOperators.UssdReply>>} An asynchronous handler to retrieve the USSD response to the sent message.
 */
Windows.Networking.NetworkOperators.UssdSession.prototype.sendMessageAndGetReplyAsync = function(message) {};
/**
 * @record
 * @struct
 */
Windows.Networking.NetworkOperators.ProfileUsage = function() {};
 /** @type {!Date} */
Windows.Networking.NetworkOperators.ProfileUsage.prototype.lastSyncTime;
 /** @type {number} */
Windows.Networking.NetworkOperators.ProfileUsage.prototype.usageInMegabytes;
/** @const */
Windows.Networking.Proximity = {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.Proximity.ConnectionRequestedEventArgs = function() {};
 /** @type {!Windows.Networking.Proximity.PeerInformation} */
Windows.Networking.Proximity.ConnectionRequestedEventArgs.prototype.peerInformation;

/** @const */
Windows.Networking.Proximity.PeerDiscoveryTypes = {};
/** @const {number} */
Windows.Networking.Proximity.PeerDiscoveryTypes.none;
/** @const {number} */
Windows.Networking.Proximity.PeerDiscoveryTypes.browse;
/** @const {number} */
Windows.Networking.Proximity.PeerDiscoveryTypes.triggered;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Proximity.PeerFinder = function() {};
 /** @type {boolean} */
Windows.Networking.Proximity.PeerFinder.allowBluetooth;
 /** @type {boolean} */
Windows.Networking.Proximity.PeerFinder.allowInfrastructure;
 /** @type {boolean} */
Windows.Networking.Proximity.PeerFinder.allowWiFiDirect;
 /** @type {!Windows.Foundation.Collections.IMap<string, string>} */
Windows.Networking.Proximity.PeerFinder.alternateIdentities;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Networking.Proximity.PeerFinder.discoveryData;
 /** @type {string} */
Windows.Networking.Proximity.PeerFinder.displayName;
 /** @type {function(?): void} */
Windows.Networking.Proximity.PeerFinder.onconnectionrequested;
 /** @type {function(?): void} */
Windows.Networking.Proximity.PeerFinder.ontriggeredconnectionstatechanged;
 /** @type {Windows.Networking.Proximity.PeerRole} */
Windows.Networking.Proximity.PeerFinder.role;
 /** @type {Windows.Networking.Proximity.PeerDiscoveryTypes} */
Windows.Networking.Proximity.PeerFinder.supportedDiscoveryTypes;

/**
 * Connects to a peer discovered by a call to the FindAllPeersAsync method.
 * @param {!Windows.Networking.Proximity.PeerInformation} peerInformation A peer information object representing the peer to connect to.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.Sockets.StreamSocket, !Windows.Foundation.IAsyncOperation<!Windows.Networking.Sockets.StreamSocket>>} An asynchronous operation for connecting to a remote peer using the supplied StreamSocket object.
 */
Windows.Networking.Proximity.PeerFinder.connectAsync = function(peerInformation) {};

/**
 * Creates a new instance of a PeerWatcher object for dynamic discovery of peer apps.
 * @return {!Windows.Networking.Proximity.PeerWatcher} An instance of a PeerWatcher object for dynamic discovery of peer apps.
 */
Windows.Networking.Proximity.PeerFinder.createWatcher = function() {};

/**
 * Asynchronously browses for peer devices that are running the same app within wireless range.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The asynchronous operation for browsing for peer devices that are running your app.
 */
Windows.Networking.Proximity.PeerFinder.findAllPeersAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.Proximity.PeerFinder.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.Proximity.PeerFinder.removeEventListener = function(type, listener) {};

/**
 * Makes an app discoverable to remote peers.
 * Makes an app discoverable to remote peers.
 * @param {string=} peerMessage The message to deliver to the proximate device.
 * @return {void}
 */
Windows.Networking.Proximity.PeerFinder.start = function(peerMessage) {};

/**
 * Stops advertising for a peer connection.
 * @return {void}
 */
Windows.Networking.Proximity.PeerFinder.stop = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.Proximity.PeerInformation = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Networking.Proximity.PeerInformation.prototype.discoveryData;
 /** @type {string} */
Windows.Networking.Proximity.PeerInformation.prototype.displayName;
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.Proximity.PeerInformation.prototype.hostName;
 /** @type {string} */
Windows.Networking.Proximity.PeerInformation.prototype.id;
 /** @type {string} */
Windows.Networking.Proximity.PeerInformation.prototype.serviceName;

/** @const */
Windows.Networking.Proximity.PeerRole = {};
/** @const {number} */
Windows.Networking.Proximity.PeerRole.peer;
/** @const {number} */
Windows.Networking.Proximity.PeerRole.host;
/** @const {number} */
Windows.Networking.Proximity.PeerRole.client;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Proximity.PeerWatcher = function() {};
 /** @type {function(?): void} */
Windows.Networking.Proximity.PeerWatcher.prototype.onadded;
 /** @type {function(?): void} */
Windows.Networking.Proximity.PeerWatcher.prototype.onenumerationcompleted;
 /** @type {function(?): void} */
Windows.Networking.Proximity.PeerWatcher.prototype.onremoved;
 /** @type {function(?): void} */
Windows.Networking.Proximity.PeerWatcher.prototype.onstopped;
 /** @type {function(?): void} */
Windows.Networking.Proximity.PeerWatcher.prototype.onupdated;
 /** @type {Windows.Networking.Proximity.PeerWatcherStatus} */
Windows.Networking.Proximity.PeerWatcher.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.Proximity.PeerWatcher.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.Proximity.PeerWatcher.prototype.removeEventListener = function(type, listener) {};

/**
 * Begin dynamically searching for peer apps within wireless range.
 * @return {void}
 */
Windows.Networking.Proximity.PeerWatcher.prototype.start = function() {};

/**
 * Stop dynamically searching for peer apps within wireless range.
 * @return {void}
 */
Windows.Networking.Proximity.PeerWatcher.prototype.stop = function() {};

/** @const */
Windows.Networking.Proximity.PeerWatcherStatus = {};
/** @const {number} */
Windows.Networking.Proximity.PeerWatcherStatus.created;
/** @const {number} */
Windows.Networking.Proximity.PeerWatcherStatus.started;
/** @const {number} */
Windows.Networking.Proximity.PeerWatcherStatus.enumerationCompleted;
/** @const {number} */
Windows.Networking.Proximity.PeerWatcherStatus.stopping;
/** @const {number} */
Windows.Networking.Proximity.PeerWatcherStatus.stopped;
/** @const {number} */
Windows.Networking.Proximity.PeerWatcherStatus.aborted;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Proximity.ProximityDevice = function() {};
 /** @type {number} */
Windows.Networking.Proximity.ProximityDevice.prototype.bitsPerSecond;
 /** @type {string} */
Windows.Networking.Proximity.ProximityDevice.prototype.deviceId;
 /** @type {number} */
Windows.Networking.Proximity.ProximityDevice.prototype.maxMessageBytes;
 /** @type {function(!Windows.WinRTEvent<!Windows.Networking.Proximity.ProximityDevice>): void} */
Windows.Networking.Proximity.ProximityDevice.prototype.ondevicearrived;
 /** @type {function(!Windows.WinRTEvent<!Windows.Networking.Proximity.ProximityDevice>): void} */
Windows.Networking.Proximity.ProximityDevice.prototype.ondevicedeparted;

/**
 * Creates an instance of a ProximityDevice class and activates the specified proximity device interface.
 * @param {string} deviceId The DeviceInformation Id of a proximity device.
 * @return {!Windows.Networking.Proximity.ProximityDevice} A new ProximityDevice that uses the specified proximity device interface. Throws a System.IO.FileNotFoundException exception if the specified proximity device interface isunavailable.
 */
Windows.Networking.Proximity.ProximityDevice.fromId = function(deviceId) {};

/**
 * Creates an instance of a ProximityDevice class and activates the default proximity provider.
 * @return {!Windows.Networking.Proximity.ProximityDevice} A new proximity device that uses the default proximity provider. Returns NULL if no proximity devices are installed.
 */
Windows.Networking.Proximity.ProximityDevice.getDefault = function() {};

/**
 * Returns the class selection string that you can use to enumerate proximity devices.
 * @return {string} The class selection string for proximity devices.
 */
Windows.Networking.Proximity.ProximityDevice.getDeviceSelector = function() {};

/**
 * @param {string} type
 * @param {function(!Windows.WinRTEvent<!Windows.Networking.Proximity.ProximityDevice>): void|function(?): void} listener
 * @return {void}
 */
Windows.Networking.Proximity.ProximityDevice.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(!Windows.WinRTEvent<!Windows.Networking.Proximity.ProximityDevice>): void|function(?): void} listener
 * @return {void}
 */
Windows.Networking.Proximity.ProximityDevice.prototype.removeEventListener = function(type, listener) {};

/**
 * Publishes a message that contains binary data to subscribers of the specified message type.
 * Publishes a message that contains binary data to subscribers of the specified message type. The specified handler is called when the message has been transmitted.
 * @param {string} messageType The type of message to deliver to subscribers.
 * @param {!Windows.Storage.Streams.IBuffer} message The binary message data to deliver to subscribers.
 * @param {function(!Windows.Networking.Proximity.ProximityDevice, number): void=} messageTransmittedHandler The handler to call when the message has been transmitted.
 * @return {number} A unique publication ID for the published message.
 */
Windows.Networking.Proximity.ProximityDevice.prototype.publishBinaryMessage = function(messageType, message, messageTransmittedHandler) {};

/**
 * Publishes a message to subscribers of the specified message type.
 * Publishes a message to subscribers of the specified message type. The specified handler is called when the message has been transmitted.
 * @param {string} messageType The type of message to deliver to subscribers.
 * @param {string} message The message to deliver to subscribers.
 * @param {function(!Windows.Networking.Proximity.ProximityDevice, number): void=} messageTransmittedHandler The handler to call when the message has been transmitted.
 * @return {number} A unique publication ID for the published message. Pass this value to the StopPublishingMessage method to stop publishing the message. / A unique publication ID for the published message.
 */
Windows.Networking.Proximity.ProximityDevice.prototype.publishMessage = function(messageType, message, messageTransmittedHandler) {};

/**
 * Publishes a Uniform Resource Identifier (URI) to a proximate device. The specified handler is called when the message has been transmitted.
 * Publishes a Uniform Resource Identifier (URI) to a proximate device.
 * @param {!Windows.Foundation.Uri} message The URI to publish.
 * @param {function(!Windows.Networking.Proximity.ProximityDevice, number): void=} messageTransmittedHandler The handler to call when the message has been transmitted.
 * @return {number} The publication ID of the message.
 */
Windows.Networking.Proximity.ProximityDevice.prototype.publishUriMessage = function(message, messageTransmittedHandler) {};

/**
 * Stops publishing a message.
 * @param {number} messageId The publication ID for the message.
 * @return {void}
 */
Windows.Networking.Proximity.ProximityDevice.prototype.stopPublishingMessage = function(messageId) {};

/**
 * Cancels a message subscription.
 * @param {number} subscriptionId The subscription ID for the message.
 * @return {void}
 */
Windows.Networking.Proximity.ProximityDevice.prototype.stopSubscribingForMessage = function(subscriptionId) {};

/**
 * Creates a subscription for a specified message type.
 * @param {string} messageType The type of message to deliver to this subscription.
 * @param {function(!Windows.Networking.Proximity.ProximityDevice, !Windows.Networking.Proximity.ProximityMessage): void} messageReceivedHandler The handler that the proximity provider will call when it delivers a message.
 * @return {number} A unique ID for the subscription.
 */
Windows.Networking.Proximity.ProximityDevice.prototype.subscribeForMessage = function(messageType, messageReceivedHandler) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.Proximity.ProximityMessage = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Networking.Proximity.ProximityMessage.prototype.data;
 /** @type {string} */
Windows.Networking.Proximity.ProximityMessage.prototype.dataAsString;
 /** @type {string} */
Windows.Networking.Proximity.ProximityMessage.prototype.messageType;
 /** @type {number} */
Windows.Networking.Proximity.ProximityMessage.prototype.subscriptionId;

/** @const */
Windows.Networking.Proximity.TriggeredConnectState = {};
/** @const {number} */
Windows.Networking.Proximity.TriggeredConnectState.peerFound;
/** @const {number} */
Windows.Networking.Proximity.TriggeredConnectState.listening;
/** @const {number} */
Windows.Networking.Proximity.TriggeredConnectState.connecting;
/** @const {number} */
Windows.Networking.Proximity.TriggeredConnectState.completed;
/** @const {number} */
Windows.Networking.Proximity.TriggeredConnectState.canceled;
/** @const {number} */
Windows.Networking.Proximity.TriggeredConnectState.failed;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Proximity.TriggeredConnectionStateChangedEventArgs = function() {};
 /** @type {number} */
Windows.Networking.Proximity.TriggeredConnectionStateChangedEventArgs.prototype.id;
 /** @type {!Windows.Networking.Sockets.StreamSocket} */
Windows.Networking.Proximity.TriggeredConnectionStateChangedEventArgs.prototype.socket;
 /** @type {Windows.Networking.Proximity.TriggeredConnectState} */
Windows.Networking.Proximity.TriggeredConnectionStateChangedEventArgs.prototype.state;

/** @typedef {function(!Windows.WinRTEvent<!Windows.Networking.Proximity.ProximityDevice>): void} */
Windows.Networking.Proximity.DeviceArrivedEventHandler;

/** @typedef {function(!Windows.WinRTEvent<!Windows.Networking.Proximity.ProximityDevice>): void} */
Windows.Networking.Proximity.DeviceDepartedEventHandler;

/** @typedef {function(!Windows.Networking.Proximity.ProximityDevice, number): void} */
Windows.Networking.Proximity.MessageTransmittedHandler;

/** @typedef {function(!Windows.Networking.Proximity.ProximityDevice, !Windows.Networking.Proximity.ProximityMessage): void} */
Windows.Networking.Proximity.MessageReceivedHandler;
/** @const */
Windows.Networking.PushNotifications = {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.PushNotifications.PushNotificationChannel = function() {};
 /** @type {!Date} */
Windows.Networking.PushNotifications.PushNotificationChannel.prototype.expirationTime;
 /** @type {function(?): void} */
Windows.Networking.PushNotifications.PushNotificationChannel.prototype.onpushnotificationreceived;
 /** @type {string} */
Windows.Networking.PushNotifications.PushNotificationChannel.prototype.uri;

/**
 * Explicitly invalidates this channel. Any notifications pushed to this channel after this method is called are not delivered.
 * @return {void}
 */
Windows.Networking.PushNotifications.PushNotificationChannel.prototype.close = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.PushNotifications.PushNotificationChannel.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.PushNotifications.PushNotificationChannel.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.PushNotifications.PushNotificationChannelManager = function() {};

/**
 * Creates an object, bound to a specified app, through which you retrieve a push notification channel from Windows Push Notification Services (WNS). The specified app must be in the same package as the calling app.
 * Creates an object, bound to the calling app, through which you retrieve a push notification channel from Windows Push Notification Services (WNS).
 * @param {string=} applicationId The Package Relative Application ID (PRAID) of the app to bind to the push notification channel.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.PushNotifications.PushNotificationChannel, !Windows.Foundation.IAsyncOperation<!Windows.Networking.PushNotifications.PushNotificationChannel>>} The object, bound to the app specified in applicationId, that is used to request a PushNotificationChannel from the WNS. / The object, bound to the calling app, that is used to request a PushNotificationChannel from the WNS.
 */
Windows.Networking.PushNotifications.PushNotificationChannelManager.createPushNotificationChannelForApplicationAsync = function(applicationId) {};

/**
 * Creates an object, bound to a secondary tile , through which you retrieve a push notification channel from Windows Push Notification Services (WNS). The tile can be a secondary tile of the calling app or any other app in the same package.
 * @param {string} tileId The ID of the secondary tile to bind to the push notification channel.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.PushNotifications.PushNotificationChannel, !Windows.Foundation.IAsyncOperation<!Windows.Networking.PushNotifications.PushNotificationChannel>>} The object, bound to the secondary tile, that is used to request a PushNotificationChannel from the WNS.
 */
Windows.Networking.PushNotifications.PushNotificationChannelManager.createPushNotificationChannelForSecondaryTileAsync = function(tileId) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs = function() {};
 /** @type {!Windows.UI.Notifications.BadgeNotification} */
Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs.prototype.badgeNotification;
 /** @type {boolean} */
Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs.prototype.cancel;
 /** @type {Windows.Networking.PushNotifications.PushNotificationType} */
Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs.prototype.notificationType;
 /** @type {?} */
Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs.prototype.rawNotification;
 /** @type {!Windows.UI.Notifications.TileNotification} */
Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs.prototype.tileNotification;
 /** @type {!Windows.UI.Notifications.ToastNotification} */
Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs.prototype.toastNotification;

/** @const */
Windows.Networking.PushNotifications.PushNotificationType = {};
/** @const {number} */
Windows.Networking.PushNotifications.PushNotificationType.toast;
/** @const {number} */
Windows.Networking.PushNotifications.PushNotificationType.tile;
/** @const {number} */
Windows.Networking.PushNotifications.PushNotificationType.badge;
/** @const {number} */
Windows.Networking.PushNotifications.PushNotificationType.raw;
/** @const {number} */
Windows.Networking.PushNotifications.PushNotificationType.tileFlyout;
/**
 * @constructor
 * @struct
 */
Windows.Networking.PushNotifications.RawNotification = function() {};
 /** @type {string} */
Windows.Networking.PushNotifications.RawNotification.prototype.content;
/** @const */
Windows.Networking.ServiceDiscovery = {};
/** @const */
Windows.Networking.ServiceDiscovery.Dnssd = {};

/**
 * @constructor
 * @struct
 * Constructor.
 */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationResult = function() {};
 /** @type {boolean} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationResult.prototype.hasInstanceNameChanged;
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationResult.prototype.ipAddress;
 /** @type {Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationStatus} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationResult.prototype.status;

/** @const */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationStatus = {};
/** @const {number} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationStatus.success;
/** @const {number} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationStatus.invalidServiceName;
/** @const {number} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationStatus.serverError;
/** @const {number} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationStatus.securityError;

/**
 * @constructor
 * @struct
 * Creates a new DnssdServiceInstance object with the specified instance name, host name, and port.
 * @param {string} DnssdServiceInstanceName The service instance name for the service instance being created.
 * @param {!Windows.Networking.HostName} hostName The hostname for the service instance being created.
 * @param {number} port The port number for the service instance being created.
 */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance = function(DnssdServiceInstanceName, hostName, port) {};
 /** @type {string} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance.prototype.dnssdServiceInstanceName;
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance.prototype.hostName;
 /** @type {number} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance.prototype.port;
 /** @type {number} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance.prototype.priority;
 /** @type {!Windows.Foundation.Collections.IMap<string, string>} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance.prototype.textAttributes;
 /** @type {number} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance.prototype.weight;

/**
 * Asynchronously registers a datagram (UDP) socket listener for the service, on a given socket and network adapter.
 * Asynchronously registers a datagram (UDP) socket listener for the service, on a given socket.
 * @param {!Windows.Networking.Sockets.DatagramSocket} socket Describes the socket that this service instance uses to listen for new service clients.
 * @param {!Windows.Networking.Connectivity.NetworkAdapter=} adapter Specifies the network adapter this service uses to listen for new service clients.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationResult>>} On successful completion of the asynchronous operation, returns an object describing the results of registration.
 */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance.prototype.registerDatagramSocketAsync = function(socket, adapter) {};

/**
 * Asynchronously registers a stream (TCP) socket listener for the service, on the given socket and network adapter.
 * Asynchronously registers a stream (TCP) socket listener for the service, on the given socket.
 * @param {!Windows.Networking.Sockets.StreamSocketListener} socket Describes the socket that this service instance uses to listen for new service clients.
 * @param {!Windows.Networking.Connectivity.NetworkAdapter=} adapter Specifies the network adapter this service uses to listen for new service clients.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationResult>>} On successful completion of the asynchronous operation, returns an object describing the results of registration.
 */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance.prototype.registerStreamSocketListenerAsync = function(socket, adapter) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstanceCollection = function() {};
 /** @type {number} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstanceCollection.prototype.size;

/**
 * Gets an iterator that is initialized to refer to the first item in the instance collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance>} Gets an iterator instance initialized to the first item in the service instance collection. Your code can use this iterator to enumerate all members of the collection.
 */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstanceCollection.prototype.first = function() {};

/**
 * Gets the DnssdServiceInstance at a given index into the DnssdServiceInstanceCollection .
 * @param {number} index The index of the instance to be retrieved. Indices are 0-based. If your code specifies an index that is out of bounds, an exception is thrown. The maximum valid index is equal to one less than the DnssdServiceInstanceCollection.Size value.
 * @return {!Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance} The DnssdServiceInstance at the given index in the collection.
 */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstanceCollection.prototype.getAt = function(index) {};

/**
 * Gets multiple DnssdServiceInstance objects from a DNS-SD service instance collection.
 * @param {number} startIndex Index of the first collection item to be retrieved.
 * @return {{items: !Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance, returnValue: number}}
 */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstanceCollection.prototype.getMany = function(startIndex) {};

/**
 * Gets a value indicating whether a given DnssdServiceInstance is at the specified index in this service instance collection.
 * @param {!Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance} value_or_searchElement The DnssdServiceInstance to get the index of.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstanceCollection.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher = function() {};
 /** @type {function(?): void} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher.prototype.onadded;
 /** @type {function(?): void} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher.prototype.onenumerationcompleted;
 /** @type {function(?): void} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher.prototype.onstopped;
 /** @type {Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcherStatus} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher.prototype.removeEventListener = function(type, listener) {};

/**
 * Starts an enumeration of the network for available DNS Service Discovery (DNS-SD) service instances.
 * @return {void}
 */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher.prototype.start = function() {};

/**
 * Stops an in-progress enumeration of available DNS Service Discovery (DNS-SD) service instances.
 * @return {void}
 */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher.prototype.stop = function() {};

/** @const */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcherStatus = {};
/** @const {number} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcherStatus.created;
/** @const {number} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcherStatus.started;
/** @const {number} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcherStatus.enumerationCompleted;
/** @const {number} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcherStatus.stopping;
/** @const {number} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcherStatus.stopped;
/** @const {number} */
Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcherStatus.aborted;

/**
 * @constructor
 * @struct
 * Creates a new DatagramSocket object.
 */
Windows.Networking.Sockets.DatagramSocket = function() {};
 /** @type {!Windows.Networking.Sockets.DatagramSocketControl} */
Windows.Networking.Sockets.DatagramSocket.prototype.control;
 /** @type {!Windows.Networking.Sockets.DatagramSocketInformation} */
Windows.Networking.Sockets.DatagramSocket.prototype.information;
 /** @type {function(?): void} */
Windows.Networking.Sockets.DatagramSocket.prototype.onmessagereceived;
 /** @type {!Windows.Storage.Streams.IOutputStream} */
Windows.Networking.Sockets.DatagramSocket.prototype.outputStream;

/**
 * Gets a list of EndpointPair objects based on a remote hostname and remote service name and the sort order to be used.
 * Gets a list of EndpointPair objects based on a remote hostname and remote service name that can be used to send datagrams to a remote network destination.
 * @param {!Windows.Networking.HostName} remoteHostName The remote hostname or IP address.
 * @param {string} remoteServiceName The remote service name or UDP port.
 * @param {Windows.Networking.HostNameSortOptions=} sortOptions The sort order to use when returning the list.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} A list of EndpointPair objects.
 */
Windows.Networking.Sockets.DatagramSocket.getEndpointPairsAsync = function(remoteHostName, remoteServiceName, sortOptions) {};

/**
 * Starts a bind operation on a DatagramSocket to a local hostname and a local service name.
 * @param {!Windows.Networking.HostName} localHostName The local hostname or IP address on which to bind the DatagramSocket object.
 * @param {string} localServiceName The local service name or UDP port on which to bind the DatagramSocket object.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous bind operation on a DatagramSocket object.
 */
Windows.Networking.Sockets.DatagramSocket.prototype.bindEndpointAsync = function(localHostName, localServiceName) {};

/**
 * Starts a bind operation on a DatagramSocket to a local service name.
 * Starts a bind operation on a DatagramSocket to a local service name and specific network interface.
 * @param {string} localServiceName The local service name or UDP port on which to bind the DatagramSocket object.
 * @param {!Windows.Networking.Connectivity.NetworkAdapter=} adapter The network adapter on which to bind the DatagramSocket object.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous bind operation on a DatagramSocket object.
 */
Windows.Networking.Sockets.DatagramSocket.prototype.bindServiceNameAsync = function(localServiceName, adapter) {};

/**
 * Cancels pending reads and writes over a DatagramSocket object.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous cancel operation on a DatagramSocket object.
 */
Windows.Networking.Sockets.DatagramSocket.prototype.cancelIOAsync = function() {};

/**
 * Closes the DatagramSocket object and aborts any pending operation on the DatagramSocket.
 * @return {void}
 */
Windows.Networking.Sockets.DatagramSocket.prototype.close = function() {};

/**
 * Starts a connect operation on a DatagramSocket to a remote destination specified by a remote hostname and a remote service name.
 * Starts a connect operation on a DatagramSocket to a remote network destination specified as an EndpointPair object.
 * @param {!Windows.Networking.HostName|!Windows.Networking.EndpointPair} remoteHostName_or_endpointPair The hostname or IP address of the remote network destination. / An EndpointPair object that specifies local hostname or IP address, local service name or UDP port, the remote hostname or remote IP address, and the remote service name or remote UDP port for the remote network destination.
 * @param {string=} remoteServiceName The service name or UDP port of the remote network destination.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous connect operation on a DatagramSocket object.
 */
Windows.Networking.Sockets.DatagramSocket.prototype.connectAsync = function(remoteHostName_or_endpointPair, remoteServiceName) {};

/**
 * Enables your app's background task to be triggered by the socket broker when traffic for this DatagramSocket arrives while the app is not active.
 * Enables your app's background task to be triggered by the socket broker when traffic for this DatagramSocket arrives while the system is in connected standby.
 * @param {string} taskId The IBackgroundTaskRegistration.TaskId of the background task that will be triggered by the socket broker when traffic arrives for this DatagramSocket .
 * @param {Windows.Networking.Sockets.SocketActivityConnectedStandbyAction=} connectedStandbyAction Specifies whether to enable or disable the activation of the background task when traffic arrives.
 * @return {void}
 */
Windows.Networking.Sockets.DatagramSocket.prototype.enableTransferOwnership = function(taskId, connectedStandbyAction) {};

/**
 * Starts an operation to get an IOutputStream to a remote destination specified by a remote hostname and a remote service name that can then be used to send network data.
 * Starts an operation to get an IOutputStream to a remote network destination specified by an EndpointPair object that can then be used to send network data.
 * @param {!Windows.Networking.HostName|!Windows.Networking.EndpointPair} remoteHostName_or_endpointPair The remote hostname or remote IP address. / An endpoint pair that represents the local hostname or local IP address, the local service name or local UDP port, the remote hostname or remote IP address, and the remote service name or remote UDP port.
 * @param {string=} remoteServiceName The remote service name or remote UDP port.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IOutputStream, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IOutputStream>>} An IOutputStream that representing the asynchronous operation. / An IOutputStream that represents the asynchronous operation.
 */
Windows.Networking.Sockets.DatagramSocket.prototype.getOutputStreamAsync = function(remoteHostName_or_endpointPair, remoteServiceName) {};

/**
 * Joins a DatagramSocket object to a multicast group.
 * @param {!Windows.Networking.HostName} host The hostname or IP address for the multicast group.
 * @return {void}
 */
Windows.Networking.Sockets.DatagramSocket.prototype.joinMulticastGroup = function(host) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.Sockets.DatagramSocket.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.Sockets.DatagramSocket.prototype.removeEventListener = function(type, listener) {};

/**
 * Transfers ownership of the DatagramSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
 * Transfers ownership of the DatagramSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
 * Transfers ownership of the DatagramSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
 * @param {string} socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
 * @param {!Windows.Networking.Sockets.SocketActivityContext=} data Use the SocketActivityContext to pass context information through the socket broker. When your app is notified by the broker of activity, this SocketActivityContext will be provided to your app to help establish the context in which you should handle the notification.
 * @param {number=} keepAliveTime How long the socket brokering service should monitor the socket for activity.
 * @return {void}
 */
Windows.Networking.Sockets.DatagramSocket.prototype.transferOwnership = function(socketId, data, keepAliveTime) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.DatagramSocketControl = function() {};
 /** @type {boolean} */
Windows.Networking.Sockets.DatagramSocketControl.prototype.dontFragment;
 /** @type {number} */
Windows.Networking.Sockets.DatagramSocketControl.prototype.inboundBufferSizeInBytes;
 /** @type {boolean} */
Windows.Networking.Sockets.DatagramSocketControl.prototype.multicastOnly;
 /** @type {number} */
Windows.Networking.Sockets.DatagramSocketControl.prototype.outboundUnicastHopLimit;
 /** @type {Windows.Networking.Sockets.SocketQualityOfService} */
Windows.Networking.Sockets.DatagramSocketControl.prototype.qualityOfService;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.DatagramSocketInformation = function() {};
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.Sockets.DatagramSocketInformation.prototype.localAddress;
 /** @type {string} */
Windows.Networking.Sockets.DatagramSocketInformation.prototype.localPort;
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.Sockets.DatagramSocketInformation.prototype.remoteAddress;
 /** @type {string} */
Windows.Networking.Sockets.DatagramSocketInformation.prototype.remotePort;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs = function() {};
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs.prototype.localAddress;
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs.prototype.remoteAddress;
 /** @type {string} */
Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs.prototype.remotePort;

/**
 * Gets a DataReader object to read incoming data received from the remote network destination on a DatagramSocket object.
 * @return {!Windows.Storage.Streams.DataReader} A DataReader object to read incoming data received from the remote network destination on a DatagramSocket object.
 */
Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs.prototype.getDataReader = function() {};

/**
 * Gets an IInputStream object that represents a sequential stream of bytes to be read as a message from the remote network destination on a DatagramSocket object.
 * @return {!Windows.Storage.Streams.IInputStream} An IInputStream object that represents a sequential stream of bytes to be read as a message.
 */
Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs.prototype.getDataStream = function() {};

/**
 * @constructor
 * @struct
 * Creates a new MessageWebSocket object.
 */
Windows.Networking.Sockets.MessageWebSocket = function() {};
 /** @type {!Windows.Networking.Sockets.MessageWebSocketControl} */
Windows.Networking.Sockets.MessageWebSocket.prototype.control;
 /** @type {!Windows.Networking.Sockets.MessageWebSocketInformation} */
Windows.Networking.Sockets.MessageWebSocket.prototype.information;
 /** @type {function(?): void} */
Windows.Networking.Sockets.MessageWebSocket.prototype.onclosed;
 /** @type {function(?): void} */
Windows.Networking.Sockets.MessageWebSocket.prototype.onmessagereceived;
 /** @type {!Windows.Storage.Streams.IOutputStream} */
Windows.Networking.Sockets.MessageWebSocket.prototype.outputStream;

/**
 * Closes the MessageWebSocket object and sends an empty close frame to the server.
 * Closes the MessageWebSocket object and indicates a reason for the closure.
 * @param {number=} code Status code indicating the reason for closure.
 * @param {string=} reason Optional UTF-8-encoded data with additional information about the closure.
 * @return {void}
 */
Windows.Networking.Sockets.MessageWebSocket.prototype.close = function(code, reason) {};

/**
 * Starts an asynchronous operation to connect to a remote network destination on a MessageWebSocket object.
 * @param {!Windows.Foundation.Uri} uri An absolute Uri for the server to connect to.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous connect operation on a MessageWebSocket object.
 */
Windows.Networking.Sockets.MessageWebSocket.prototype.connectAsync = function(uri) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.Sockets.MessageWebSocket.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.Sockets.MessageWebSocket.prototype.removeEventListener = function(type, listener) {};

/**
 * Adds an HTTP request header to the HTTP request message used in the WebSocket protocol handshake by the MessageWebSocket object.
 * @param {string} headerName The name of the request header.
 * @param {string} headerValue The value of the request header.
 * @return {void}
 */
Windows.Networking.Sockets.MessageWebSocket.prototype.setRequestHeader = function(headerName, headerValue) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.MessageWebSocketControl = function() {};
 /** @type {number} */
Windows.Networking.Sockets.MessageWebSocketControl.prototype.maxMessageSize;
 /** @type {Windows.Networking.Sockets.SocketMessageType} */
Windows.Networking.Sockets.MessageWebSocketControl.prototype.messageType;
 /** @type {number} */
Windows.Networking.Sockets.MessageWebSocketControl.prototype.outboundBufferSizeInBytes;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Networking.Sockets.MessageWebSocketControl.prototype.proxyCredential;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Networking.Sockets.MessageWebSocketControl.prototype.serverCredential;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Networking.Sockets.MessageWebSocketControl.prototype.supportedProtocols;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.MessageWebSocketInformation = function() {};
 /** @type {!Windows.Networking.Sockets.BandwidthStatistics} */
Windows.Networking.Sockets.MessageWebSocketInformation.prototype.bandwidthStatistics;
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.Sockets.MessageWebSocketInformation.prototype.localAddress;
 /** @type {string} */
Windows.Networking.Sockets.MessageWebSocketInformation.prototype.protocol;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs = function() {};
 /** @type {Windows.Networking.Sockets.SocketMessageType} */
Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs.prototype.messageType;

/**
 * Gets a DataReader object to read incoming data received from the remote network destination on a MessageWebSocket .
 * @return {!Windows.Storage.Streams.DataReader} A DataReader object to read incoming data received from the remote network destination on a MessageWebSocket .
 */
Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs.prototype.getDataReader = function() {};

/**
 * Gets an IInputStream object (a message represented as a sequential stream of bytes) from the remote network destination on a MessageWebSocket object.
 * @return {!Windows.Storage.Streams.IInputStream} A message represented as a sequential stream of bytes.
 */
Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs.prototype.getDataStream = function() {};

/** @const */
Windows.Networking.Sockets.SocketActivityConnectedStandbyAction = {};
/** @const {number} */
Windows.Networking.Sockets.SocketActivityConnectedStandbyAction.doNotWake;
/** @const {number} */
Windows.Networking.Sockets.SocketActivityConnectedStandbyAction.wake;

/**
 * @constructor
 * @struct
 * Constructs a new SocketActivityContext object with given context data.
 * @param {!Windows.Storage.Streams.IBuffer} data Context data to be used when the socket broker notifies the app of socket activity.
 */
Windows.Networking.Sockets.SocketActivityContext = function(data) {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Networking.Sockets.SocketActivityContext.prototype.data;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.SocketActivityInformation = function() {};
 /** @type {!Windows.Foundation.Collections.IMapView<string, !Windows.Networking.Sockets.SocketActivityInformation>} */
Windows.Networking.Sockets.SocketActivityInformation.allSockets;
 /** @type {!Windows.Networking.Sockets.SocketActivityContext} */
Windows.Networking.Sockets.SocketActivityInformation.prototype.context;
 /** @type {!Windows.Networking.Sockets.DatagramSocket} */
Windows.Networking.Sockets.SocketActivityInformation.prototype.datagramSocket;
 /** @type {string} */
Windows.Networking.Sockets.SocketActivityInformation.prototype.id;
 /** @type {Windows.Networking.Sockets.SocketActivityKind} */
Windows.Networking.Sockets.SocketActivityInformation.prototype.socketKind;
 /** @type {!Windows.Networking.Sockets.StreamSocket} */
Windows.Networking.Sockets.SocketActivityInformation.prototype.streamSocket;
 /** @type {!Windows.Networking.Sockets.StreamSocketListener} */
Windows.Networking.Sockets.SocketActivityInformation.prototype.streamSocketListener;
 /** @type {string} */
Windows.Networking.Sockets.SocketActivityInformation.prototype.taskId;

/** @const */
Windows.Networking.Sockets.SocketActivityKind = {};
/** @const {number} */
Windows.Networking.Sockets.SocketActivityKind.none;
/** @const {number} */
Windows.Networking.Sockets.SocketActivityKind.streamSocketListener;
/** @const {number} */
Windows.Networking.Sockets.SocketActivityKind.datagramSocket;
/** @const {number} */
Windows.Networking.Sockets.SocketActivityKind.streamSocket;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.SocketActivityTriggerDetails = function() {};
 /** @type {Windows.Networking.Sockets.SocketActivityTriggerReason} */
Windows.Networking.Sockets.SocketActivityTriggerDetails.prototype.reason;
 /** @type {!Windows.Networking.Sockets.SocketActivityInformation} */
Windows.Networking.Sockets.SocketActivityTriggerDetails.prototype.socketInformation;

/** @const */
Windows.Networking.Sockets.SocketActivityTriggerReason = {};
/** @const {number} */
Windows.Networking.Sockets.SocketActivityTriggerReason.none;
/** @const {number} */
Windows.Networking.Sockets.SocketActivityTriggerReason.socketActivity;
/** @const {number} */
Windows.Networking.Sockets.SocketActivityTriggerReason.connectionAccepted;
/** @const {number} */
Windows.Networking.Sockets.SocketActivityTriggerReason.keepAliveTimerExpired;
/** @const {number} */
Windows.Networking.Sockets.SocketActivityTriggerReason.socketClosed;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.SocketError = function() {};

/**
 * Gets a SocketErrorStatus value based on an error encountered by a socket operation.
 * @param {number} hresult The error encountered by a socket operation represented as an HRESULT.
 * @return {Windows.Networking.Sockets.SocketErrorStatus} The socket error status value for a socket operation.
 */
Windows.Networking.Sockets.SocketError.getStatus = function(hresult) {};

/** @const */
Windows.Networking.Sockets.SocketErrorStatus = {};
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.unknown;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.operationAborted;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.httpInvalidServerResponse;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.connectionTimedOut;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.addressFamilyNotSupported;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.socketTypeNotSupported;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.hostNotFound;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.noDataRecordOfRequestedType;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.nonAuthoritativeHostNotFound;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.classTypeNotFound;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.addressAlreadyInUse;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.cannotAssignRequestedAddress;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.connectionRefused;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.networkIsUnreachable;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.unreachableHost;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.networkIsDown;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.networkDroppedConnectionOnReset;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.softwareCausedConnectionAbort;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.connectionResetByPeer;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.hostIsDown;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.noAddressesFound;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.tooManyOpenFiles;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.messageTooLong;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.certificateExpired;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.certificateUntrustedRoot;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.certificateCommonNameIsIncorrect;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.certificateWrongUsage;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.certificateRevoked;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.certificateNoRevocationCheck;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.certificateRevocationServerOffline;
/** @const {number} */
Windows.Networking.Sockets.SocketErrorStatus.certificateIsInvalid;

/** @const */
Windows.Networking.Sockets.SocketMessageType = {};
/** @const {number} */
Windows.Networking.Sockets.SocketMessageType.binary;
/** @const {number} */
Windows.Networking.Sockets.SocketMessageType.utf8;

/** @const */
Windows.Networking.Sockets.SocketProtectionLevel = {};
/** @const {number} */
Windows.Networking.Sockets.SocketProtectionLevel.plainSocket;
/** @const {number} */
Windows.Networking.Sockets.SocketProtectionLevel.ssl;
/** @const {number} */
Windows.Networking.Sockets.SocketProtectionLevel.sslAllowNullEncryption;
/** @const {number} */
Windows.Networking.Sockets.SocketProtectionLevel.bluetoothEncryptionAllowNullAuthentication;
/** @const {number} */
Windows.Networking.Sockets.SocketProtectionLevel.bluetoothEncryptionWithAuthentication;
/** @const {number} */
Windows.Networking.Sockets.SocketProtectionLevel.ssl3AllowWeakEncryption;
/** @const {number} */
Windows.Networking.Sockets.SocketProtectionLevel.tls10;
/** @const {number} */
Windows.Networking.Sockets.SocketProtectionLevel.tls11;
/** @const {number} */
Windows.Networking.Sockets.SocketProtectionLevel.tls12;

/** @const */
Windows.Networking.Sockets.SocketQualityOfService = {};
/** @const {number} */
Windows.Networking.Sockets.SocketQualityOfService.normal;
/** @const {number} */
Windows.Networking.Sockets.SocketQualityOfService.lowLatency;

/** @const */
Windows.Networking.Sockets.SocketSslErrorSeverity = {};
/** @const {number} */
Windows.Networking.Sockets.SocketSslErrorSeverity.none;
/** @const {number} */
Windows.Networking.Sockets.SocketSslErrorSeverity.ignorable;
/** @const {number} */
Windows.Networking.Sockets.SocketSslErrorSeverity.fatal;

/**
 * @constructor
 * @struct
 * Creates a new StreamSocket object.
 */
Windows.Networking.Sockets.StreamSocket = function() {};
 /** @type {!Windows.Networking.Sockets.StreamSocketControl} */
Windows.Networking.Sockets.StreamSocket.prototype.control;
 /** @type {!Windows.Networking.Sockets.StreamSocketInformation} */
Windows.Networking.Sockets.StreamSocket.prototype.information;
 /** @type {!Windows.Storage.Streams.IInputStream} */
Windows.Networking.Sockets.StreamSocket.prototype.inputStream;
 /** @type {!Windows.Storage.Streams.IOutputStream} */
Windows.Networking.Sockets.StreamSocket.prototype.outputStream;

/**
 * Cancels pending reads and writes over a StreamSocket object.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous cancel operation on a StreamSocket object.
 */
Windows.Networking.Sockets.StreamSocket.prototype.cancelIOAsync = function() {};

/**
 * Closes the StreamSocket object.
 * @return {void}
 */
Windows.Networking.Sockets.StreamSocket.prototype.close = function() {};

/**
 * Starts an asynchronous operation on a StreamSocket object to connect to a remote network destination specified by a remote hostname and a remote service name.
 * Starts an asynchronous operation on a StreamSocket object to connect to a remote destination specified by a remote hostname, a remote service name, and a SocketProtectionLevel .
 * Starts an asynchronous operation on a StreamSocket object to connect to a remote network destination specified as an EndpointPair object and a SocketProtectionLevel enumeration. This method is not callable from JavaScript.
 * Starts an asynchronous operation on a StreamSocket object to connect to a remote network destination specified as an EndpointPair object.
 * Starts an asynchronous operation on a StreamSocket object on a specified local network adapter to connect to a remote destination specified by a remote hostname, a remote service name, and a SocketProtectionLevel .
 * @param {!Windows.Networking.HostName|!Windows.Networking.EndpointPair} remoteHostName_or_endpointPair The hostname or IP address of the remote network destination. For Bluetooth RFCOMM, this is a MAC address. / An EndpointPair object that specifies local hostname or IP address, local service name or TCP port, the remote hostname or remote IP address, and the remote service name or remote TCP port for the remote network destination. / An EndpointPair object that specifies the local hostname or IP address, the local service name or TCP port, the remote hostname or remote IP address, and the remote service name or remote TCP port for the remote network destination.
 * @param {string|Windows.Networking.Sockets.SocketProtectionLevel=} remoteServiceName_or_protectionLevel The service name or TCP port number of the remote network destination. For Bluetooth RFCOMM, this is the Bluetooth address. / The protection level that represents the integrity and encryption for a StreamSocket object.
 * @param {Windows.Networking.Sockets.SocketProtectionLevel=} protectionLevel The protection level that represents the integrity and encryption for the StreamSocket object.
 * @param {!Windows.Networking.Connectivity.NetworkAdapter=} adapter The local network adapter to use for the connect operation on the StreamSocket object.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous connect operation on a StreamSocket object.
 */
Windows.Networking.Sockets.StreamSocket.prototype.connectAsync = function(remoteHostName_or_endpointPair, remoteServiceName_or_protectionLevel, protectionLevel, adapter) {};

/**
 * Enables your app's background task to be triggered by the socket broker when traffic for this StreamSocket arrives while the app is not active.
 * Enables or disables the ability of your app's background task to be triggered by the socket broker when traffic for this StreamSocket arrives while the system is in connected standby.
 * @param {string} taskId The IBackgroundTaskRegistration.TaskId of the background task that will be triggered by the socket broker when traffic arrives for this StreamSocket . / The IBackgroundTaskRegistration.TaskId of the background task being enabled or disabled.
 * @param {Windows.Networking.Sockets.SocketActivityConnectedStandbyAction=} connectedStandbyAction Specifies whether to enable or disable the activation of the background task when traffic arrives.
 * @return {void}
 */
Windows.Networking.Sockets.StreamSocket.prototype.enableTransferOwnership = function(taskId, connectedStandbyAction) {};

/**
 * Transfers ownership of the StreamSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
 * Transfers ownership of the StreamSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity. Specifies a new SocketActivityContext for the socket.
 * Transfers ownership of the StreamSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity. Specifies a new SocketActivityContext and a keep alive time for the socket.
 * @param {string} socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
 * @param {!Windows.Networking.Sockets.SocketActivityContext=} data Use the SocketActivityContext to pass context information through the socket broker. When your app is notified by the broker of activity, this SocketActivityContext will be provided to your app to help establish the context in which you should handle the notification.
 * @param {number=} keepAliveTime How long the socket brokering service should monitor the socket for activity.
 * @return {void}
 */
Windows.Networking.Sockets.StreamSocket.prototype.transferOwnership = function(socketId, data, keepAliveTime) {};

/**
 * Starts an asynchronous operation to upgrade a connected socket to use SSL on a StreamSocket object.
 * @param {Windows.Networking.Sockets.SocketProtectionLevel} protectionLevel The protection level that represents the integrity and encryption on the StreamSocket object.
 * @param {!Windows.Networking.HostName} validationHostName The hostname of the remote network destination that is used for validation when upgrading to SSL.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous operation to upgrade to use SSL on a StreamSocket object.
 */
Windows.Networking.Sockets.StreamSocket.prototype.upgradeToSslAsync = function(protectionLevel, validationHostName) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.StreamSocketControl = function() {};
 /** @type {!Windows.Security.Cryptography.Certificates.Certificate} */
Windows.Networking.Sockets.StreamSocketControl.prototype.clientCertificate;
 /** @type {!Windows.Foundation.Collections.IVector<Windows.Security.Cryptography.Certificates.ChainValidationResult>} */
Windows.Networking.Sockets.StreamSocketControl.prototype.ignorableServerCertificateErrors;
 /** @type {boolean} */
Windows.Networking.Sockets.StreamSocketControl.prototype.keepAlive;
 /** @type {boolean} */
Windows.Networking.Sockets.StreamSocketControl.prototype.noDelay;
 /** @type {number} */
Windows.Networking.Sockets.StreamSocketControl.prototype.outboundBufferSizeInBytes;
 /** @type {number} */
Windows.Networking.Sockets.StreamSocketControl.prototype.outboundUnicastHopLimit;
 /** @type {Windows.Networking.Sockets.SocketQualityOfService} */
Windows.Networking.Sockets.StreamSocketControl.prototype.qualityOfService;
 /** @type {boolean} */
Windows.Networking.Sockets.StreamSocketControl.prototype.serializeConnectionAttempts;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.StreamSocketInformation = function() {};
 /** @type {!Windows.Networking.Sockets.BandwidthStatistics} */
Windows.Networking.Sockets.StreamSocketInformation.prototype.bandwidthStatistics;
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.Sockets.StreamSocketInformation.prototype.localAddress;
 /** @type {string} */
Windows.Networking.Sockets.StreamSocketInformation.prototype.localPort;
 /** @type {Windows.Networking.Sockets.SocketProtectionLevel} */
Windows.Networking.Sockets.StreamSocketInformation.prototype.protectionLevel;
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.Sockets.StreamSocketInformation.prototype.remoteAddress;
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.Sockets.StreamSocketInformation.prototype.remoteHostName;
 /** @type {string} */
Windows.Networking.Sockets.StreamSocketInformation.prototype.remotePort;
 /** @type {string} */
Windows.Networking.Sockets.StreamSocketInformation.prototype.remoteServiceName;
 /** @type {!Windows.Networking.Sockets.RoundTripTimeStatistics} */
Windows.Networking.Sockets.StreamSocketInformation.prototype.roundTripTimeStatistics;
 /** @type {!Windows.Security.Cryptography.Certificates.Certificate} */
Windows.Networking.Sockets.StreamSocketInformation.prototype.serverCertificate;
 /** @type {Windows.Networking.Sockets.SocketSslErrorSeverity} */
Windows.Networking.Sockets.StreamSocketInformation.prototype.serverCertificateErrorSeverity;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.ChainValidationResult>} */
Windows.Networking.Sockets.StreamSocketInformation.prototype.serverCertificateErrors;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Cryptography.Certificates.Certificate>} */
Windows.Networking.Sockets.StreamSocketInformation.prototype.serverIntermediateCertificates;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Networking.Sockets.StreamSocketInformation.prototype.sessionKey;

/**
 * @constructor
 * @struct
 * Creates a new StreamSocketListener object.
 */
Windows.Networking.Sockets.StreamSocketListener = function() {};
 /** @type {!Windows.Networking.Sockets.StreamSocketListenerControl} */
Windows.Networking.Sockets.StreamSocketListener.prototype.control;
 /** @type {!Windows.Networking.Sockets.StreamSocketListenerInformation} */
Windows.Networking.Sockets.StreamSocketListener.prototype.information;
 /** @type {function(?): void} */
Windows.Networking.Sockets.StreamSocketListener.prototype.onconnectionreceived;

/**
 * Starts a bind operation on a StreamSocketListener to a local hostname and a local service name.
 * @param {!Windows.Networking.HostName} localHostName The local hostname or IP address on which to bind the StreamSocketListener object.
 * @param {string} localServiceName The local service name or TCP port on which to bind the StreamSocketListener object.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous bind operation on a StreamSocketListener object.
 */
Windows.Networking.Sockets.StreamSocketListener.prototype.bindEndpointAsync = function(localHostName, localServiceName) {};

/**
 * Starts a bind operation on a StreamSocketListener to a local service name.
 * Starts a socket bind operation on a StreamSocketListener to a local service name on a specified network adapter with a specified SocketProtectionLevel to set on any bound sockets.
 * Starts a bind operation on a StreamSocketListener to a local service name with a specified SocketProtectionLevel to set on any bound sockets.
 * @param {string} localServiceName The local service name or TCP port on which to bind the StreamSocketListener object. For Bluetooth RFCOMM, this parameter is the Bluetooth Service ID.
 * @param {Windows.Networking.Sockets.SocketProtectionLevel=} protectionLevel The protection level for encryption to set on any bound sockets.
 * @param {!Windows.Networking.Connectivity.NetworkAdapter=} adapter The network adapter on which to bind the StreamSocketListener object.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The asynchronous bind operation on a StreamSocketListener object.
 */
Windows.Networking.Sockets.StreamSocketListener.prototype.bindServiceNameAsync = function(localServiceName, protectionLevel, adapter) {};

/**
 * Cancels pending reads and writes over a StreamSocketListener object.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous cancel operation on a StreamSocketListener object.
 */
Windows.Networking.Sockets.StreamSocketListener.prototype.cancelIOAsync = function() {};

/**
 * Closes the StreamSocketListener object.
 * @return {void}
 */
Windows.Networking.Sockets.StreamSocketListener.prototype.close = function() {};

/**
 * Enables your app's background task to be triggered by the socket broker when traffic for this StreamSocketListener arrives while the app is not active.
 * Enables your app's background task to be triggered by the socket broker when traffic for this StreamSocketListener arrives while the system is in connected standby.
 * @param {string} taskId The IBackgroundTaskRegistration.TaskId of the background task that will be triggered by the socket broker when traffic arrives for this StreamSocketListener .
 * @param {Windows.Networking.Sockets.SocketActivityConnectedStandbyAction=} connectedStandbyAction Specifies whether to enable or disable the activation of the background task when traffic arrives.
 * @return {void}
 */
Windows.Networking.Sockets.StreamSocketListener.prototype.enableTransferOwnership = function(taskId, connectedStandbyAction) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.Sockets.StreamSocketListener.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.Sockets.StreamSocketListener.prototype.removeEventListener = function(type, listener) {};

/**
 * Transfers ownership of the StreamSocketListener to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
 * Transfers ownership of the StreamSocketListener to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
 * @param {string} socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
 * @param {!Windows.Networking.Sockets.SocketActivityContext=} data Use the SocketActivityContext to pass context information through the socket broker. When your app is notified by the broker of activity, this SocketActivityContext will be provided to your app to help establish the context in which you should handle the notification.
 * @return {void}
 */
Windows.Networking.Sockets.StreamSocketListener.prototype.transferOwnership = function(socketId, data) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs = function() {};
 /** @type {!Windows.Networking.Sockets.StreamSocket} */
Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs.prototype.socket;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.StreamSocketListenerControl = function() {};
 /** @type {boolean} */
Windows.Networking.Sockets.StreamSocketListenerControl.prototype.keepAlive;
 /** @type {boolean} */
Windows.Networking.Sockets.StreamSocketListenerControl.prototype.noDelay;
 /** @type {number} */
Windows.Networking.Sockets.StreamSocketListenerControl.prototype.outboundBufferSizeInBytes;
 /** @type {number} */
Windows.Networking.Sockets.StreamSocketListenerControl.prototype.outboundUnicastHopLimit;
 /** @type {Windows.Networking.Sockets.SocketQualityOfService} */
Windows.Networking.Sockets.StreamSocketListenerControl.prototype.qualityOfService;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.StreamSocketListenerInformation = function() {};
 /** @type {string} */
Windows.Networking.Sockets.StreamSocketListenerInformation.prototype.localPort;

/**
 * @constructor
 * @struct
 * Creates a new StreamWebSocket object.
 */
Windows.Networking.Sockets.StreamWebSocket = function() {};
 /** @type {!Windows.Networking.Sockets.StreamWebSocketControl} */
Windows.Networking.Sockets.StreamWebSocket.prototype.control;
 /** @type {!Windows.Networking.Sockets.StreamWebSocketInformation} */
Windows.Networking.Sockets.StreamWebSocket.prototype.information;
 /** @type {!Windows.Storage.Streams.IInputStream} */
Windows.Networking.Sockets.StreamWebSocket.prototype.inputStream;
 /** @type {function(?): void} */
Windows.Networking.Sockets.StreamWebSocket.prototype.onclosed;
 /** @type {!Windows.Storage.Streams.IOutputStream} */
Windows.Networking.Sockets.StreamWebSocket.prototype.outputStream;

/**
 * Closes the StreamWebSocket and sends an empty close frame to the server.
 * Closes the StreamWebSocket and indicates a reason for the closure.
 * @param {number=} code Status code indicating the reason for closure.
 * @param {string=} reason Optional UTF-8-encoded data with additional information about the closure.
 * @return {void}
 */
Windows.Networking.Sockets.StreamWebSocket.prototype.close = function(code, reason) {};

/**
 * Starts an asynchronous operation to connect to a remote network destination on a StreamWebSocket object.
 * @param {!Windows.Foundation.Uri} uri An absolute Uri for the server to connect to.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous connect operation on a StreamWebSocket object.
 */
Windows.Networking.Sockets.StreamWebSocket.prototype.connectAsync = function(uri) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.Sockets.StreamWebSocket.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.Sockets.StreamWebSocket.prototype.removeEventListener = function(type, listener) {};

/**
 * Adds an HTTP request header to the HTTP request message used in the WebSocket protocol handshake by the StreamWebSocket object.
 * @param {string} headerName The name of the request header.
 * @param {string} headerValue The value of the request header.
 * @return {void}
 */
Windows.Networking.Sockets.StreamWebSocket.prototype.setRequestHeader = function(headerName, headerValue) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.StreamWebSocketControl = function() {};
 /** @type {boolean} */
Windows.Networking.Sockets.StreamWebSocketControl.prototype.noDelay;
 /** @type {number} */
Windows.Networking.Sockets.StreamWebSocketControl.prototype.outboundBufferSizeInBytes;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Networking.Sockets.StreamWebSocketControl.prototype.proxyCredential;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Networking.Sockets.StreamWebSocketControl.prototype.serverCredential;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Networking.Sockets.StreamWebSocketControl.prototype.supportedProtocols;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.StreamWebSocketInformation = function() {};
 /** @type {!Windows.Networking.Sockets.BandwidthStatistics} */
Windows.Networking.Sockets.StreamWebSocketInformation.prototype.bandwidthStatistics;
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.Sockets.StreamWebSocketInformation.prototype.localAddress;
 /** @type {string} */
Windows.Networking.Sockets.StreamWebSocketInformation.prototype.protocol;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.WebSocketClosedEventArgs = function() {};
 /** @type {number} */
Windows.Networking.Sockets.WebSocketClosedEventArgs.prototype.code;
 /** @type {string} */
Windows.Networking.Sockets.WebSocketClosedEventArgs.prototype.reason;
/**
 * @constructor
 * @struct
 */
Windows.Networking.Sockets.WebSocketError = function() {};

/**
 * Gets a WebErrorStatus value based on an error encountered by a WebSocket operation.
 * @param {number} hresult The error encountered by a WebSocket operation represented as an HRESULT.
 * @return {Windows.Web.WebErrorStatus} The socket error status value for a WebSocket operation.
 */
Windows.Networking.Sockets.WebSocketError.getStatus = function(hresult) {};
 /** @type {!Windows.Storage.Streams.IOutputStream} */
Windows.Networking.Sockets.IWebSocket.prototype.outputStream;

/**
 * Closes the IWebSocket .
 * @param {number} code Status code indicating the reason for closure.
 * @param {string} reason Optional UTF-8-encoded data with additional information about the closure.
 * @return {void}
 */
Windows.Networking.Sockets.IWebSocket.prototype.close = function(code, reason) {};

/**
 * Starts an asynchronous operation to connect to a remote network destination on a IWebSocket object.
 * @param {!Windows.Foundation.Uri} uri An absolute Uri for the server to connect to.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous connect operation on a IWebSocket object.
 */
Windows.Networking.Sockets.IWebSocket.prototype.connectAsync = function(uri) {};

/**
 * Adds an HTTP request header to the HTTP request message used in the WebSocket protocol handshake by the IWebSocket object.
 * @param {string} headerName The name of the request header.
 * @param {string} headerValue The value of the request header.
 * @return {void}
 */
Windows.Networking.Sockets.IWebSocket.prototype.setRequestHeader = function(headerName, headerValue) {};
/**
 * @record
 * @struct
 */
Windows.Networking.Sockets.BandwidthStatistics = function() {};
/**
 * @record
 * @struct
 */
Windows.Networking.Sockets.RoundTripTimeStatistics = function() {};
/** @const */
Windows.Networking.Vpn = {};

/** @const */
Windows.Networking.Vpn.VpnAppIdType = {};
/** @const {number} */
Windows.Networking.Vpn.VpnAppIdType.packageFamilyName;
/** @const {number} */
Windows.Networking.Vpn.VpnAppIdType.fullyQualifiedBinaryName;
/** @const {number} */
Windows.Networking.Vpn.VpnAppIdType.filePath;

/** @const */
Windows.Networking.Vpn.VpnAuthenticationMethod = {};
/** @const {number} */
Windows.Networking.Vpn.VpnAuthenticationMethod.mschapv2;
/** @const {number} */
Windows.Networking.Vpn.VpnAuthenticationMethod.eap;
/** @const {number} */
Windows.Networking.Vpn.VpnAuthenticationMethod.certificate;
/** @const {number} */
Windows.Networking.Vpn.VpnAuthenticationMethod.presharedKey;

/** @const */
Windows.Networking.Vpn.VpnChannelActivityEventType = {};
/** @const {number} */
Windows.Networking.Vpn.VpnChannelActivityEventType.idle;
/** @const {number} */
Windows.Networking.Vpn.VpnChannelActivityEventType.active;

/** @const */
Windows.Networking.Vpn.VpnChannelRequestCredentialsOptions = {};
/** @const {number} */
Windows.Networking.Vpn.VpnChannelRequestCredentialsOptions.none;
/** @const {number} */
Windows.Networking.Vpn.VpnChannelRequestCredentialsOptions.retrying;
/** @const {number} */
Windows.Networking.Vpn.VpnChannelRequestCredentialsOptions.useForSingleSignIn;

/** @const */
Windows.Networking.Vpn.VpnCredentialType = {};
/** @const {number} */
Windows.Networking.Vpn.VpnCredentialType.usernamePassword;
/** @const {number} */
Windows.Networking.Vpn.VpnCredentialType.usernameOtpPin;
/** @const {number} */
Windows.Networking.Vpn.VpnCredentialType.usernamePasswordAndPin;
/** @const {number} */
Windows.Networking.Vpn.VpnCredentialType.usernamePasswordChange;
/** @const {number} */
Windows.Networking.Vpn.VpnCredentialType.smartCard;
/** @const {number} */
Windows.Networking.Vpn.VpnCredentialType.protectedCertificate;
/** @const {number} */
Windows.Networking.Vpn.VpnCredentialType.unProtectedCertificate;

/** @const */
Windows.Networking.Vpn.VpnDataPathType = {};
/** @const {number} */
Windows.Networking.Vpn.VpnDataPathType.send;
/** @const {number} */
Windows.Networking.Vpn.VpnDataPathType.receive;

/** @const */
Windows.Networking.Vpn.VpnDomainNameType = {};
/** @const {number} */
Windows.Networking.Vpn.VpnDomainNameType.suffix;
/** @const {number} */
Windows.Networking.Vpn.VpnDomainNameType.fullyQualified;
/** @const {number} */
Windows.Networking.Vpn.VpnDomainNameType.reserved;

/** @const */
Windows.Networking.Vpn.VpnIPProtocol = {};
/** @const {number} */
Windows.Networking.Vpn.VpnIPProtocol.none;
/** @const {number} */
Windows.Networking.Vpn.VpnIPProtocol.tcp;
/** @const {number} */
Windows.Networking.Vpn.VpnIPProtocol.udp;
/** @const {number} */
Windows.Networking.Vpn.VpnIPProtocol.icmp;
/** @const {number} */
Windows.Networking.Vpn.VpnIPProtocol.ipv6Icmp;
/** @const {number} */
Windows.Networking.Vpn.VpnIPProtocol.igmp;
/** @const {number} */
Windows.Networking.Vpn.VpnIPProtocol.pgm;

/** @const */
Windows.Networking.Vpn.VpnManagementErrorStatus = {};
/** @const {number} */
Windows.Networking.Vpn.VpnManagementErrorStatus.ok;
/** @const {number} */
Windows.Networking.Vpn.VpnManagementErrorStatus.other;
/** @const {number} */
Windows.Networking.Vpn.VpnManagementErrorStatus.invalidXmlSyntax;
/** @const {number} */
Windows.Networking.Vpn.VpnManagementErrorStatus.profileNameTooLong;
/** @const {number} */
Windows.Networking.Vpn.VpnManagementErrorStatus.profileInvalidAppId;
/** @const {number} */
Windows.Networking.Vpn.VpnManagementErrorStatus.accessDenied;

/** @const */
Windows.Networking.Vpn.VpnNativeProtocolType = {};
/** @const {number} */
Windows.Networking.Vpn.VpnNativeProtocolType.pptp;
/** @const {number} */
Windows.Networking.Vpn.VpnNativeProtocolType.l2tp;
/** @const {number} */
Windows.Networking.Vpn.VpnNativeProtocolType.ipsecIkev2;

/** @const */
Windows.Networking.Vpn.VpnPacketBufferStatus = {};
/** @const {number} */
Windows.Networking.Vpn.VpnPacketBufferStatus.ok;
/** @const {number} */
Windows.Networking.Vpn.VpnPacketBufferStatus.invalidBufferSize;

/** @const */
Windows.Networking.Vpn.VpnRoutingPolicyType = {};
/** @const {number} */
Windows.Networking.Vpn.VpnRoutingPolicyType.splitRouting;
/** @const {number} */
Windows.Networking.Vpn.VpnRoutingPolicyType.forceAllTrafficOverVpn;
/** @const */
Windows.Networking.XboxLive = {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.XboxLive.XboxLiveDeviceAddress = function() {};
 /** @type {number} */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.maxSnapshotBytesSize;
 /** @type {boolean} */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.prototype.isLocal;
 /** @type {boolean} */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.prototype.isValid;
 /** @type {Windows.Networking.XboxLive.XboxLiveNetworkAccessKind} */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.prototype.networkAccessKind;
 /** @type {function(?): void} */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.prototype.onsnapshotchanged;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {string} base64 This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Networking.XboxLive.XboxLiveDeviceAddress} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.createFromSnapshotBase64 = function(base64) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Storage.Streams.IBuffer} buffer This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Networking.XboxLive.XboxLiveDeviceAddress} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.createFromSnapshotBuffer = function(buffer) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Array<number>} buffer This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Networking.XboxLive.XboxLiveDeviceAddress} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.createFromSnapshotBytes = function(buffer) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Networking.XboxLive.XboxLiveDeviceAddress} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.getLocal = function() {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Networking.XboxLive.XboxLiveDeviceAddress} otherDeviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {number} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.prototype.compare = function(otherDeviceAddress) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {string} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.prototype.getSnapshotAsBase64 = function() {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Storage.Streams.IBuffer} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.prototype.getSnapshotAsBuffer = function() {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {{buffer: !Array<number>, bytesWritten: number}}
 */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.prototype.getSnapshotAsBytes = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.XboxLive.XboxLiveDeviceAddress.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.XboxLive.XboxLiveEndpointPair = function() {};
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.XboxLive.XboxLiveEndpointPair.prototype.localHostName;
 /** @type {string} */
Windows.Networking.XboxLive.XboxLiveEndpointPair.prototype.localPort;
 /** @type {function(?): void} */
Windows.Networking.XboxLive.XboxLiveEndpointPair.prototype.onstatechanged;
 /** @type {!Windows.Networking.XboxLive.XboxLiveDeviceAddress} */
Windows.Networking.XboxLive.XboxLiveEndpointPair.prototype.remoteDeviceAddress;
 /** @type {!Windows.Networking.HostName} */
Windows.Networking.XboxLive.XboxLiveEndpointPair.prototype.remoteHostName;
 /** @type {string} */
Windows.Networking.XboxLive.XboxLiveEndpointPair.prototype.remotePort;
 /** @type {Windows.Networking.XboxLive.XboxLiveEndpointPairState} */
Windows.Networking.XboxLive.XboxLiveEndpointPair.prototype.state;
 /** @type {!Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate} */
Windows.Networking.XboxLive.XboxLiveEndpointPair.prototype.template;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Networking.HostName} localHostName This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {string} localPort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Networking.HostName} remoteHostName This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {string} remotePort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Networking.XboxLive.XboxLiveEndpointPair} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveEndpointPair.findEndpointPairByHostNamesAndPorts = function(localHostName, localPort, remoteHostName, remotePort) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Array<number>} localSocketAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Array<number>} remoteSocketAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Networking.XboxLive.XboxLiveEndpointPair} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveEndpointPair.findEndpointPairBySocketAddressBytes = function(localSocketAddress, remoteSocketAddress) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveEndpointPair.prototype.deleteAsync = function() {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Array<number>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveEndpointPair.prototype.getLocalSocketAddressBytes = function() {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Array<number>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveEndpointPair.prototype.getRemoteSocketAddressBytes = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.XboxLive.XboxLiveEndpointPair.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.XboxLive.XboxLiveEndpointPair.prototype.removeEventListener = function(type, listener) {};

/** @const */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationBehaviors = {};
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationBehaviors.none;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationBehaviors.reevaluatePath;
/**
 * @constructor
 * @struct
 */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult = function() {};
 /** @type {!Windows.Networking.XboxLive.XboxLiveDeviceAddress} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult.prototype.deviceAddress;
 /** @type {!Windows.Networking.XboxLive.XboxLiveEndpointPair} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult.prototype.endpointPair;
 /** @type {boolean} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult.prototype.isExistingPathEvaluation;
 /** @type {Windows.Networking.XboxLive.XboxLiveEndpointPairCreationStatus} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult.prototype.status;

/** @const */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationStatus = {};
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationStatus.succeeded;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationStatus.noLocalNetworks;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationStatus.noCompatibleNetworkPaths;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationStatus.localSystemNotAuthorized;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationStatus.canceled;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationStatus.timedOut;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationStatus.remoteSystemNotAuthorized;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationStatus.refusedDueToConfiguration;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairCreationStatus.unexpectedInternalError;

/** @const */
Windows.Networking.XboxLive.XboxLiveEndpointPairState = {};
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairState.invalid;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairState.creatingOutbound;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairState.creatingInbound;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairState.ready;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairState.deletingLocally;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairState.remoteEndpointTerminating;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairState.deleted;
/**
 * @constructor
 * @struct
 */
Windows.Networking.XboxLive.XboxLiveEndpointPairStateChangedEventArgs = function() {};
 /** @type {Windows.Networking.XboxLive.XboxLiveEndpointPairState} */
Windows.Networking.XboxLive.XboxLiveEndpointPairStateChangedEventArgs.prototype.newState;
 /** @type {Windows.Networking.XboxLive.XboxLiveEndpointPairState} */
Windows.Networking.XboxLive.XboxLiveEndpointPairStateChangedEventArgs.prototype.oldState;
/**
 * @constructor
 * @struct
 */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate>} */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate.templates;
 /** @type {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate.prototype.acceptorBoundPortRangeLower;
 /** @type {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate.prototype.acceptorBoundPortRangeUpper;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.XboxLive.XboxLiveEndpointPair>} */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate.prototype.endpointPairs;
 /** @type {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate.prototype.initiatorBoundPortRangeLower;
 /** @type {number} */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate.prototype.initiatorBoundPortRangeUpper;
 /** @type {string} */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate.prototype.name;
 /** @type {function(?): void} */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate.prototype.oninboundendpointpaircreated;
 /** @type {Windows.Networking.XboxLive.XboxLiveSocketKind} */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate.prototype.socketKind;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {string} name This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate.getTemplateByName = function(name) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Networking.XboxLive.XboxLiveDeviceAddress} deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {Windows.Networking.XboxLive.XboxLiveEndpointPairCreationBehaviors=} behaviors This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult>>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate.prototype.createEndpointPairAsync = function(deviceAddress, behaviors) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Networking.XboxLive.XboxLiveDeviceAddress} deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {string} initiatorPort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {string} acceptorPort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {Windows.Networking.XboxLive.XboxLiveEndpointPairCreationBehaviors=} behaviors This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult, !Windows.Foundation.IAsyncOperation<!Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult>>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate.prototype.createEndpointPairForPortsAsync = function(deviceAddress, initiatorPort, acceptorPort, behaviors) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Networking.XboxLive.XboxLiveInboundEndpointPairCreatedEventArgs = function() {};
 /** @type {!Windows.Networking.XboxLive.XboxLiveEndpointPair} */
Windows.Networking.XboxLive.XboxLiveInboundEndpointPairCreatedEventArgs.prototype.endpointPair;

/** @const */
Windows.Networking.XboxLive.XboxLiveNetworkAccessKind = {};
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveNetworkAccessKind.open;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveNetworkAccessKind.moderate;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveNetworkAccessKind.strict;

/**
 * @constructor
 * @struct
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement = function() {};
 /** @type {boolean} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.isSystemInboundBandwidthConstrained;
 /** @type {boolean} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.isSystemOutboundBandwidthConstrained;
 /** @type {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.maxPrivatePayloadSize;
 /** @type {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.maxSimultaneousProbeConnections;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.publishedPrivatePayload;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Networking.XboxLive.XboxLiveDeviceAddress>} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.prototype.deviceAddresses;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult>} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.prototype.metricResults;
 /** @type {!Windows.Foundation.Collections.IVector<Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric>} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.prototype.metrics;
 /** @type {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.prototype.numberOfProbesToAttempt;
 /** @type {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.prototype.numberOfResultsPending;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.XboxLive.XboxLiveQualityOfServicePrivatePayloadResult>} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.prototype.privatePayloadResults;
 /** @type {boolean} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.prototype.shouldRequestPrivatePayloads;
 /** @type {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.prototype.timeoutInMilliseconds;

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {void}
 */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.clearPrivatePayload = function() {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Array<number>} payload This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {void}
 */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.publishPrivatePayloadBytes = function(payload) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Networking.XboxLive.XboxLiveDeviceAddress} deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric} metric This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.prototype.getMetricResult = function(deviceAddress, metric) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Networking.XboxLive.XboxLiveDeviceAddress} deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.prototype.getMetricResultsForDevice = function(deviceAddress) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric} metric This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.prototype.getMetricResultsForMetric = function(metric) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @param {!Windows.Networking.XboxLive.XboxLiveDeviceAddress} deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Networking.XboxLive.XboxLiveQualityOfServicePrivatePayloadResult} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.prototype.getPrivatePayloadResult = function(deviceAddress) {};

/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
 */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement.prototype.measureAsync = function() {};

/** @const */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus = {};
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus.notStarted;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus.inProgress;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus.inProgressWithProvisionalResults;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus.succeeded;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus.noLocalNetworks;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus.noCompatibleNetworkPaths;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus.localSystemNotAuthorized;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus.canceled;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus.timedOut;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus.remoteSystemNotAuthorized;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus.refusedDueToConfiguration;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus.unexpectedInternalError;

/** @const */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric = {};
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric.averageLatencyInMilliseconds;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric.minLatencyInMilliseconds;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric.maxLatencyInMilliseconds;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric.averageOutboundBitsPerSecond;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric.minOutboundBitsPerSecond;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric.maxOutboundBitsPerSecond;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric.averageInboundBitsPerSecond;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric.minInboundBitsPerSecond;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric.maxInboundBitsPerSecond;
/**
 * @constructor
 * @struct
 */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult = function() {};
 /** @type {!Windows.Networking.XboxLive.XboxLiveDeviceAddress} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult.prototype.deviceAddress;
 /** @type {Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult.prototype.metric;
 /** @type {Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult.prototype.status;
 /** @type {number} */
Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult.prototype.value;
/**
 * @constructor
 * @struct
 */
Windows.Networking.XboxLive.XboxLiveQualityOfServicePrivatePayloadResult = function() {};
 /** @type {!Windows.Networking.XboxLive.XboxLiveDeviceAddress} */
Windows.Networking.XboxLive.XboxLiveQualityOfServicePrivatePayloadResult.prototype.deviceAddress;
 /** @type {Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus} */
Windows.Networking.XboxLive.XboxLiveQualityOfServicePrivatePayloadResult.prototype.status;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Networking.XboxLive.XboxLiveQualityOfServicePrivatePayloadResult.prototype.value;

/** @const */
Windows.Networking.XboxLive.XboxLiveSocketKind = {};
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveSocketKind.none;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveSocketKind.datagram;
/** @const {number} */
Windows.Networking.XboxLive.XboxLiveSocketKind.stream;
/** @const */
Windows.Perception = {};
/** @const */
Windows.Perception.People = {};
/**
 * @constructor
 * @struct
 */
Windows.Perception.People.HeadPose = function() {};
 /** @type {?} */
Windows.Perception.People.HeadPose.prototype.forwardDirection;
 /** @type {?} */
Windows.Perception.People.HeadPose.prototype.position;
 /** @type {?} */
Windows.Perception.People.HeadPose.prototype.upDirection;
/**
 * @constructor
 * @struct
 */
Windows.Perception.PerceptionTimestamp = function() {};
 /** @type {?} */
Windows.Perception.PerceptionTimestamp.prototype.predictionAmount;
 /** @type {?} */
Windows.Perception.PerceptionTimestamp.prototype.targetTime;
/**
 * @constructor
 * @struct
 */
Windows.Perception.PerceptionTimestampHelper = function() {};
 /** @type {?} */
Windows.Perception.PerceptionTimestampHelper.fromHistoricalTargetTime;
/** @const */
Windows.Perception.Spatial = {};
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.SpatialAnchor = function() {};
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchor.tryCreateRelativeTo;
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchor.prototype.addEventListener;
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchor.prototype.coordinateSystem;
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchor.prototype.onrawcoordinatesystemadjusted;
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchor.prototype.rawCoordinateSystem;
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchor.prototype.removeEventListener;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.SpatialAnchorManager = function() {};
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchorManager.requestStoreAsync;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.SpatialAnchorRawCoordinateSystemAdjustedEventArgs = function() {};
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchorRawCoordinateSystemAdjustedEventArgs.prototype.oldRawCoordinateSystemToNewRawCoordinateSystemTransform;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.SpatialAnchorStore = function() {};
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchorStore.prototype.clear;
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchorStore.prototype.getAllSavedAnchors;
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchorStore.prototype.remove;
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchorStore.prototype.trySave;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.SpatialAnchorTransferManager = function() {};
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchorTransferManager.requestAccessAsync;
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchorTransferManager.tryExportAnchorsAsync;
 /** @type {?} */
Windows.Perception.Spatial.SpatialAnchorTransferManager.tryImportAnchorsAsync;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.SpatialBoundingVolume = function() {};
 /** @type {?} */
Windows.Perception.Spatial.SpatialBoundingVolume.fromBox;
 /** @type {?} */
Windows.Perception.Spatial.SpatialBoundingVolume.fromFrustum;
 /** @type {?} */
Windows.Perception.Spatial.SpatialBoundingVolume.fromOrientedBox;
 /** @type {?} */
Windows.Perception.Spatial.SpatialBoundingVolume.fromSphere;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.SpatialCoordinateSystem = function() {};
 /** @type {?} */
Windows.Perception.Spatial.SpatialCoordinateSystem.prototype.tryGetTransformTo;
/** @const */
Windows.Perception.Spatial.SpatialLocatability = {};
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocatability.unavailable;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocatability.orientationOnly;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocatability.positionalTrackingActivating;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocatability.positionalTrackingActive;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocatability.positionalTrackingInhibited;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.SpatialLocation = function() {};
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocation.prototype.absoluteAngularAcceleration;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocation.prototype.absoluteAngularVelocity;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocation.prototype.absoluteLinearAcceleration;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocation.prototype.absoluteLinearVelocity;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocation.prototype.orientation;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocation.prototype.position;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.SpatialLocator = function() {};
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocator.getDefault;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocator.prototype.addEventListener;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocator.prototype.createAttachedFrameOfReferenceAtCurrentHeading;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocator.prototype.createStationaryFrameOfReferenceAtCurrentLocation;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocator.prototype.locatability;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocator.prototype.onlocatabilitychanged;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocator.prototype.onpositionaltrackingdeactivating;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocator.prototype.removeEventListener;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocator.prototype.tryLocateAtTimestamp;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.SpatialLocatorAttachedFrameOfReference = function() {};
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocatorAttachedFrameOfReference.prototype.adjustHeading;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocatorAttachedFrameOfReference.prototype.getStationaryCoordinateSystemAtTimestamp;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocatorAttachedFrameOfReference.prototype.relativeOrientation;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocatorAttachedFrameOfReference.prototype.relativePosition;
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocatorAttachedFrameOfReference.prototype.tryGetRelativeHeadingAtTimestamp;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.SpatialLocatorPositionalTrackingDeactivatingEventArgs = function() {};
 /** @type {?} */
Windows.Perception.Spatial.SpatialLocatorPositionalTrackingDeactivatingEventArgs.prototype.canceled;
/** @const */
Windows.Perception.Spatial.SpatialPerceptionAccessStatus = {};
 /** @type {?} */
Windows.Perception.Spatial.SpatialPerceptionAccessStatus.unspecified;
 /** @type {?} */
Windows.Perception.Spatial.SpatialPerceptionAccessStatus.allowed;
 /** @type {?} */
Windows.Perception.Spatial.SpatialPerceptionAccessStatus.deniedByUser;
 /** @type {?} */
Windows.Perception.Spatial.SpatialPerceptionAccessStatus.deniedBySystem;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.SpatialStationaryFrameOfReference = function() {};
 /** @type {?} */
Windows.Perception.Spatial.SpatialStationaryFrameOfReference.prototype.coordinateSystem;
/** @const */
Windows.Perception.Spatial.Surfaces = {};
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceInfo = function() {};
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceInfo.prototype.id;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceInfo.prototype.tryComputeLatestMeshAsync;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceInfo.prototype.tryGetBounds;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceInfo.prototype.updateTime;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMesh = function() {};
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMesh.prototype.coordinateSystem;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMesh.prototype.surfaceInfo;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMesh.prototype.triangleIndices;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMesh.prototype.vertexNormals;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMesh.prototype.vertexPositionScale;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMesh.prototype.vertexPositions;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMeshBuffer = function() {};
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMeshBuffer.prototype.data;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMeshBuffer.prototype.elementCount;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMeshBuffer.prototype.format;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMeshBuffer.prototype.stride;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMeshOptions = function() {};
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMeshOptions.supportedTriangleIndexFormats;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMeshOptions.supportedVertexNormalFormats;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMeshOptions.supportedVertexPositionFormats;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMeshOptions.prototype.includeVertexNormals;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMeshOptions.prototype.triangleIndexFormat;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMeshOptions.prototype.vertexNormalFormat;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceMeshOptions.prototype.vertexPositionFormat;
/**
 * @constructor
 * @struct
 */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceObserver = function() {};
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceObserver.requestAccessAsync;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceObserver.prototype.addEventListener;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceObserver.prototype.getObservedSurfaces;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceObserver.prototype.onobservedsurfaceschanged;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceObserver.prototype.removeEventListener;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceObserver.prototype.setBoundingVolume;
 /** @type {?} */
Windows.Perception.Spatial.Surfaces.SpatialSurfaceObserver.prototype.setBoundingVolumes;
/** @const */
Windows.Security = {};
/** @const */
Windows.Security.Authentication = {};
/** @const */
Windows.Security.Authentication.OnlineId = {};

/** @const */
Windows.Security.Authentication.OnlineId.CredentialPromptType = {};
/** @const {number} */
Windows.Security.Authentication.OnlineId.CredentialPromptType.promptIfNeeded;
/** @const {number} */
Windows.Security.Authentication.OnlineId.CredentialPromptType.retypeCredentials;
/** @const {number} */
Windows.Security.Authentication.OnlineId.CredentialPromptType.doNotPrompt;

/**
 * @constructor
 * @struct
 * Creates an instance of the OnlineIdAuthenticator .
 */
Windows.Security.Authentication.OnlineId.OnlineIdAuthenticator = function() {};
 /** @type {string} */
Windows.Security.Authentication.OnlineId.OnlineIdAuthenticator.prototype.applicationId;
 /** @type {string} */
Windows.Security.Authentication.OnlineId.OnlineIdAuthenticator.prototype.authenticatedSafeCustomerId;
 /** @type {boolean} */
Windows.Security.Authentication.OnlineId.OnlineIdAuthenticator.prototype.canSignOut;

/**
 * Starts the async authentication request with one OnlineIdServiceTicketRequest . If a user is signed into a Windows 8 system with a Microsoft account, this user will be used for the authentication request.
 * Starts the async authentication request with multiple OnlineIdServiceTicketRequests and provides the ability to control the user experience by setting the CredentialPromptType to get the tickets. If a user is signed into a Windows 8 system with a Microsoft account, this user will be used for the authentication request.
 * @param {!Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest|!Windows.Foundation.Collections.IIterable<!Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest>} request_or_requests A request object that provides the ability for an app to specify the service and policy used to authenticate a Live user to obtain identity properties and tickets. / A collection of requests.
 * @param {Windows.Security.Authentication.OnlineId.CredentialPromptType=} credentialPromptType The type of credentials.
 * @return {!Windows.Foundation.IPromiseWithOperation<?, !Windows.Security.Authentication.OnlineId.UserAuthenticationOperation>} An object representing the authentication operation.
 */
Windows.Security.Authentication.OnlineId.OnlineIdAuthenticator.prototype.authenticateUserAsync = function(request_or_requests, credentialPromptType) {};

/**
 * Allows users to sign out of your app.
 * @return {!Windows.Foundation.IPromiseWithOperation<?, !Windows.Security.Authentication.OnlineId.SignOutUserOperation>} An object that contains additional information about the why the user signed out.
 */
Windows.Security.Authentication.OnlineId.OnlineIdAuthenticator.prototype.signOutUserAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.OnlineId.OnlineIdServiceTicket = function() {};
 /** @type {number} */
Windows.Security.Authentication.OnlineId.OnlineIdServiceTicket.prototype.errorCode;
 /** @type {!Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest} */
Windows.Security.Authentication.OnlineId.OnlineIdServiceTicket.prototype.request;
 /** @type {string} */
Windows.Security.Authentication.OnlineId.OnlineIdServiceTicket.prototype.value;

/**
 * @constructor
 * @struct
 * Creates an instance of the OnlineIdServiceTicketRequest class.
 * Creates an instance of the OnlineIdServiceTicketRequest class.
 * @param {string} service The service for the request.
 * @param {string=} policy The policy for the request.
 */
Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest = function(service, policy) {};
 /** @type {string} */
Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest.prototype.policy;
 /** @type {string} */
Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest.prototype.service;
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.OnlineId.SignOutUserOperation = function() {};
 /** @type {function(!Windows.Foundation.IAsyncAction, Windows.Foundation.AsyncStatus): void} */
Windows.Security.Authentication.OnlineId.SignOutUserOperation.prototype.completed;
 /** @type {!Windows.WinRTError} */
Windows.Security.Authentication.OnlineId.SignOutUserOperation.prototype.errorCode;
 /** @type {number} */
Windows.Security.Authentication.OnlineId.SignOutUserOperation.prototype.id;
 /** @type {Windows.Foundation.AsyncStatus} */
Windows.Security.Authentication.OnlineId.SignOutUserOperation.prototype.status;

/**
 * Requests the cancellation of the operation.
 * @return {void}
 */
Windows.Security.Authentication.OnlineId.SignOutUserOperation.prototype.cancel = function() {};

/**
 * Requests that work associated with the operation should terminate.
 * @return {void}
 */
Windows.Security.Authentication.OnlineId.SignOutUserOperation.prototype.close = function() {};

/**
 * Returns the results of the operation. For this class, there are no results to return if the operation succeeds.
 * @return {void}
 */
Windows.Security.Authentication.OnlineId.SignOutUserOperation.prototype.getResults = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.OnlineId.UserAuthenticationOperation = function() {};
 /** @type {function(!Windows.Foundation.IAsyncOperation<!Windows.Security.Authentication.OnlineId.UserIdentity>, Windows.Foundation.AsyncStatus): void} */
Windows.Security.Authentication.OnlineId.UserAuthenticationOperation.prototype.completed;
 /** @type {!Windows.WinRTError} */
Windows.Security.Authentication.OnlineId.UserAuthenticationOperation.prototype.errorCode;
 /** @type {number} */
Windows.Security.Authentication.OnlineId.UserAuthenticationOperation.prototype.id;
 /** @type {Windows.Foundation.AsyncStatus} */
Windows.Security.Authentication.OnlineId.UserAuthenticationOperation.prototype.status;

/**
 * Requests the cancellation of the operation.
 * @return {void}
 */
Windows.Security.Authentication.OnlineId.UserAuthenticationOperation.prototype.cancel = function() {};

/**
 * Requests that work associated with the operation should terminate.
 * @return {void}
 */
Windows.Security.Authentication.OnlineId.UserAuthenticationOperation.prototype.close = function() {};

/**
 * Returns a UserIdentity object that contains information about the user.
 * @return {!Windows.Security.Authentication.OnlineId.UserIdentity} An object containing information about the user's identity.
 */
Windows.Security.Authentication.OnlineId.UserAuthenticationOperation.prototype.getResults = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.OnlineId.UserIdentity = function() {};
 /** @type {string} */
Windows.Security.Authentication.OnlineId.UserIdentity.prototype.firstName;
 /** @type {string} */
Windows.Security.Authentication.OnlineId.UserIdentity.prototype.id;
 /** @type {boolean} */
Windows.Security.Authentication.OnlineId.UserIdentity.prototype.isBetaAccount;
 /** @type {boolean} */
Windows.Security.Authentication.OnlineId.UserIdentity.prototype.isConfirmedPC;
 /** @type {string} */
Windows.Security.Authentication.OnlineId.UserIdentity.prototype.lastName;
 /** @type {string} */
Windows.Security.Authentication.OnlineId.UserIdentity.prototype.safeCustomerId;
 /** @type {string} */
Windows.Security.Authentication.OnlineId.UserIdentity.prototype.signInName;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Authentication.OnlineId.OnlineIdServiceTicket>} */
Windows.Security.Authentication.OnlineId.UserIdentity.prototype.tickets;
/** @const */
Windows.Security.Authentication.Web = {};
/** @const */
Windows.Security.Authentication.Web.Core = {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.Web.Core.WebAuthenticationCoreManager = function() {};

/**
 * Finds a web account asynchronously.
 * @param {!Windows.Security.Credentials.WebAccountProvider} provider The web account provider for the web account.
 * @param {string} webAccountId The Id of the web account.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Credentials.WebAccount, !Windows.Foundation.IAsyncOperation<!Windows.Security.Credentials.WebAccount>>} When this method completes successfully, it returns the found web account.
 */
Windows.Security.Authentication.Web.Core.WebAuthenticationCoreManager.findAccountAsync = function(provider, webAccountId) {};

/**
 * Finds a web account provider asynchronously with one input.
 * Finds a web account provider asynchronously with three inputs.
 * Finds a web account provider asynchronously with two inputs.
 * @param {string} webAccountProviderId The Id of the web account provider to find.
 * @param {string=} authority The authority of the web account provider to find.
 * @param {!Windows.System.User=} user The user associated with the web account provider to find.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Credentials.WebAccountProvider, !Windows.Foundation.IAsyncOperation<!Windows.Security.Credentials.WebAccountProvider>>} When this method completes successfully, it returns the found web account provider.
 */
Windows.Security.Authentication.Web.Core.WebAuthenticationCoreManager.findAccountProviderAsync = function(webAccountProviderId, authority, user) {};

/**
 * Attempts to get a token without showing any UI using one input. The user will never be prompted to enter their credentials.
 * Attempts to get a token without showing any UI using two inputs. The user will never be prompted to enter their credentials.
 * @param {!Windows.Security.Authentication.Web.Core.WebTokenRequest} request The web token request.
 * @param {!Windows.Security.Credentials.WebAccount=} webAccount The web account.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Authentication.Web.Core.WebTokenRequestResult, !Windows.Foundation.IAsyncOperation<!Windows.Security.Authentication.Web.Core.WebTokenRequestResult>>} When this method completes successfully, it returns the result of the web token request.
 */
Windows.Security.Authentication.Web.Core.WebAuthenticationCoreManager.getTokenSilentlyAsync = function(request, webAccount) {};

/**
 * Requests a token from a web account provider asynchronously. If needed, the user may be prompted to enter their credentials.
 * Requests a token from a web account provider asynchronously. If needed, the user may be prompted to enter their credentials.
 * @param {!Windows.Security.Authentication.Web.Core.WebTokenRequest} request The web token request.
 * @param {!Windows.Security.Credentials.WebAccount=} webAccount The web account for the request.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Authentication.Web.Core.WebTokenRequestResult, !Windows.Foundation.IAsyncOperation<!Windows.Security.Authentication.Web.Core.WebTokenRequestResult>>} When this method completes successfully, it returns the results of the web token request.
 */
Windows.Security.Authentication.Web.Core.WebAuthenticationCoreManager.requestTokenAsync = function(request, webAccount) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the WebProviderError class.
 * @param {number} errorCode The error code.
 * @param {string} errorMessage The error message.
 */
Windows.Security.Authentication.Web.Core.WebProviderError = function(errorCode, errorMessage) {};
 /** @type {number} */
Windows.Security.Authentication.Web.Core.WebProviderError.prototype.errorCode;
 /** @type {string} */
Windows.Security.Authentication.Web.Core.WebProviderError.prototype.errorMessage;
 /** @type {!Windows.Foundation.Collections.IMap<string, string>} */
Windows.Security.Authentication.Web.Core.WebProviderError.prototype.properties;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the WebTokenRequest class with two inputs.
 * Initializes a new instance of the WebTokenRequest class with four inputs.
 * Initializes a new instance of the WebTokenRequest class with one inputs.
 * Initializes a new instance of the WebTokenRequest class with three inputs.
 * @param {!Windows.Security.Credentials.WebAccountProvider} provider The web account provider the request is for.
 * @param {string=} scope The scope of the request.
 * @param {string=} clientId The client Id.
 * @param {Windows.Security.Authentication.Web.Core.WebTokenRequestPromptType=} promptType The request prompt type.
 */
Windows.Security.Authentication.Web.Core.WebTokenRequest = function(provider, scope, clientId, promptType) {};
 /** @type {?} */
Windows.Security.Authentication.Web.Core.WebTokenRequest.prototype.appProperties;
 /** @type {string} */
Windows.Security.Authentication.Web.Core.WebTokenRequest.prototype.clientId;
 /** @type {Windows.Security.Authentication.Web.Core.WebTokenRequestPromptType} */
Windows.Security.Authentication.Web.Core.WebTokenRequest.prototype.promptType;
 /** @type {!Windows.Foundation.Collections.IMap<string, string>} */
Windows.Security.Authentication.Web.Core.WebTokenRequest.prototype.properties;
 /** @type {string} */
Windows.Security.Authentication.Web.Core.WebTokenRequest.prototype.scope;
 /** @type {!Windows.Security.Credentials.WebAccountProvider} */
Windows.Security.Authentication.Web.Core.WebTokenRequest.prototype.webAccountProvider;

/** @const */
Windows.Security.Authentication.Web.Core.WebTokenRequestPromptType = {};
/** @const {number} */
Windows.Security.Authentication.Web.Core.WebTokenRequestPromptType.default;
/** @const {number} */
Windows.Security.Authentication.Web.Core.WebTokenRequestPromptType.forceAuthentication;
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.Web.Core.WebTokenRequestResult = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Authentication.Web.Core.WebTokenResponse>} */
Windows.Security.Authentication.Web.Core.WebTokenRequestResult.prototype.responseData;
 /** @type {!Windows.Security.Authentication.Web.Core.WebProviderError} */
Windows.Security.Authentication.Web.Core.WebTokenRequestResult.prototype.responseError;
 /** @type {Windows.Security.Authentication.Web.Core.WebTokenRequestStatus} */
Windows.Security.Authentication.Web.Core.WebTokenRequestResult.prototype.responseStatus;

/**
 * Invalidates the current cached WebTokenRequestResult . Use this method if an access denied error is returned when trying to use a token.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return an object or value.
 */
Windows.Security.Authentication.Web.Core.WebTokenRequestResult.prototype.invalidateCacheAsync = function() {};

/** @const */
Windows.Security.Authentication.Web.Core.WebTokenRequestStatus = {};
/** @const {number} */
Windows.Security.Authentication.Web.Core.WebTokenRequestStatus.success;
/** @const {number} */
Windows.Security.Authentication.Web.Core.WebTokenRequestStatus.userCancel;
/** @const {number} */
Windows.Security.Authentication.Web.Core.WebTokenRequestStatus.accountSwitch;
/** @const {number} */
Windows.Security.Authentication.Web.Core.WebTokenRequestStatus.userInteractionRequired;
/** @const {number} */
Windows.Security.Authentication.Web.Core.WebTokenRequestStatus.accountProviderNotAvailable;
/** @const {number} */
Windows.Security.Authentication.Web.Core.WebTokenRequestStatus.providerError;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the WebTokenResponse class.
 * Initializes a new instance of the WebTokenResponse class with two inputs.
 * Initializes a new instance of the WebTokenResponse class with three inputs.
 * Initializes a new instance of the WebTokenResponse class with one input.
 * @param {string=} token The token.
 * @param {!Windows.Security.Credentials.WebAccount=} webAccount The WebAccount .
 * @param {!Windows.Security.Authentication.Web.Core.WebProviderError=} error The web provider error.
 */
Windows.Security.Authentication.Web.Core.WebTokenResponse = function(token, webAccount, error) {};
 /** @type {!Windows.Foundation.Collections.IMap<string, string>} */
Windows.Security.Authentication.Web.Core.WebTokenResponse.prototype.properties;
 /** @type {!Windows.Security.Authentication.Web.Core.WebProviderError} */
Windows.Security.Authentication.Web.Core.WebTokenResponse.prototype.providerError;
 /** @type {string} */
Windows.Security.Authentication.Web.Core.WebTokenResponse.prototype.token;
 /** @type {!Windows.Security.Credentials.WebAccount} */
Windows.Security.Authentication.Web.Core.WebTokenResponse.prototype.webAccount;
/** @const */
Windows.Security.Authentication.Web.Provider = {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the WebAccountClientView class.
 * Creates a new instance of the WebAccountClientView class.
 * @param {Windows.Security.Authentication.Web.Provider.WebAccountClientViewType} viewType The client view type.
 * @param {!Windows.Foundation.Uri} applicationCallbackUri The callback URI that indicates the completion of the operation.
 * @param {string=} accountPairwiseId The account pairwise Id.
 */
Windows.Security.Authentication.Web.Provider.WebAccountClientView = function(viewType, applicationCallbackUri, accountPairwiseId) {};
 /** @type {string} */
Windows.Security.Authentication.Web.Provider.WebAccountClientView.prototype.accountPairwiseId;
 /** @type {!Windows.Foundation.Uri} */
Windows.Security.Authentication.Web.Provider.WebAccountClientView.prototype.applicationCallbackUri;
 /** @type {Windows.Security.Authentication.Web.Provider.WebAccountClientViewType} */
Windows.Security.Authentication.Web.Provider.WebAccountClientView.prototype.type;

/** @const */
Windows.Security.Authentication.Web.Provider.WebAccountClientViewType = {};
/** @const {number} */
Windows.Security.Authentication.Web.Provider.WebAccountClientViewType.idOnly;
/** @const {number} */
Windows.Security.Authentication.Web.Provider.WebAccountClientViewType.idAndProperties;
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.Web.Provider.WebAccountManager = function() {};

/**
 * Adds a new web account asynchronously with three inputs.
 * Adds a new web account asynchronously with four inputs.
 * @param {string} webAccountId The Id for the web account.
 * @param {string} webAccountUserName The user name for the web account.
 * @param {!Windows.Foundation.Collections.IMapView<string, string>} props Properties for the web account.
 * @param {Windows.Security.Authentication.Web.Provider.WebAccountScope=} scope The scope of the web account.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Credentials.WebAccount, !Windows.Foundation.IAsyncOperation<!Windows.Security.Credentials.WebAccount>>} When this method completes, it returns the new web account.
 */
Windows.Security.Authentication.Web.Provider.WebAccountManager.addWebAccountAsync = function(webAccountId, webAccountUserName, props, scope) {};

/**
 * Clears the view for a web account.
 * @param {!Windows.Security.Credentials.WebAccount} webAccount The web account to clear the view for.
 * @param {!Windows.Foundation.Uri} applicationCallbackUri The callback Uri that indicates the completion of the operation. The broker matches this Uri against every Uri that it is about to navigate to. The broker never navigates to this Uri, instead the broker returns the control back to the application when the user clicks a link or a web server redirection is made.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Authentication.Web.Provider.WebAccountManager.clearViewAsync = function(webAccount, applicationCallbackUri) {};

/**
 * Clears a web account picture asynchronously.
 * @param {!Windows.Security.Credentials.WebAccount} webAccount The web account to clear the picture from.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Authentication.Web.Provider.WebAccountManager.clearWebAccountPictureAsync = function(webAccount) {};

/**
 * Deletes a web account asynchronously.
 * @param {!Windows.Security.Credentials.WebAccount} webAccount The WebAccount to delete.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Authentication.Web.Provider.WebAccountManager.deleteWebAccountAsync = function(webAccount) {};

/**
 * Finds all provider web accounts asynchronously.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes, it returns all provider web accounts.
 */
Windows.Security.Authentication.Web.Provider.WebAccountManager.findAllProviderWebAccountsAsync = function() {};

/**
 * Gets the scope of the web account.
 * @param {!Windows.Security.Credentials.WebAccount} webAccount The web account to get scope for.
 * @return {Windows.Security.Authentication.Web.Provider.WebAccountScope} The scope of the web account.
 */
Windows.Security.Authentication.Web.Provider.WebAccountManager.getScope = function(webAccount) {};

/**
 * Gets the views for a web account asynchronously.
 * @param {!Windows.Security.Credentials.WebAccount} webAccount The web account to get views for.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes, it returns the views for the web account.
 */
Windows.Security.Authentication.Web.Provider.WebAccountManager.getViewsAsync = function(webAccount) {};

/**
 * Pulls cookies asynchronously. Use this to enable single sign-on in an app after a user has entered their credentials into a web browser.
 * @param {string} uriString The Uri to pull cookies from.
 * @param {string} callerPFN The caller's package family name.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Authentication.Web.Provider.WebAccountManager.pullCookiesAsync = function(uriString, callerPFN) {};

/**
 * Pushes cookies asynchronously. Use this to enable single sign-on for a web account in a browser after the user has entered their credentials into the app.
 * @param {!Windows.Foundation.Uri} uri The Uri to push the cookies to.
 * @param {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Http.HttpCookie>} cookies The cookies to push.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Authentication.Web.Provider.WebAccountManager.pushCookiesAsync = function(uri, cookies) {};

/**
 * Sets the scope of a web account asynchronously.
 * @param {!Windows.Security.Credentials.WebAccount} webAccount The web account to set scope for.
 * @param {Windows.Security.Authentication.Web.Provider.WebAccountScope} scope The scope to set.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Authentication.Web.Provider.WebAccountManager.setScopeAsync = function(webAccount, scope) {};

/**
 * Sets the view for a web account asynchronously.
 * @param {!Windows.Security.Credentials.WebAccount} webAccount The web account to set the view for.
 * @param {!Windows.Security.Authentication.Web.Provider.WebAccountClientView} view The view to set.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Authentication.Web.Provider.WebAccountManager.setViewAsync = function(webAccount, view) {};

/**
 * Sets the picture of a web account asynchronously.
 * @param {!Windows.Security.Credentials.WebAccount} webAccount The web account to set the picture for.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} webAccountPicture The picture to set.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Authentication.Web.Provider.WebAccountManager.setWebAccountPictureAsync = function(webAccount, webAccountPicture) {};

/**
 * Updates the properties of a web account asynchronously.
 * @param {!Windows.Security.Credentials.WebAccount} webAccount The web account to update.
 * @param {string} webAccountUserName The username to update.
 * @param {!Windows.Foundation.Collections.IMapView<string, string>} additionalProperties The properties to update.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Authentication.Web.Provider.WebAccountManager.updateWebAccountPropertiesAsync = function(webAccount, webAccountUserName, additionalProperties) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderAddAccountOperation = function() {};
 /** @type {Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderAddAccountOperation.prototype.kind;

/**
 * Informs the activating app that the operation completed successfully.
 * @return {void}
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderAddAccountOperation.prototype.reportCompleted = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderDeleteAccountOperation = function() {};
 /** @type {Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderDeleteAccountOperation.prototype.kind;
 /** @type {!Windows.Security.Credentials.WebAccount} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderDeleteAccountOperation.prototype.webAccount;

/**
 * Informs the activating app that the operation completed successfully.
 * @return {void}
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderDeleteAccountOperation.prototype.reportCompleted = function() {};

/**
 * Informs the activating app that the operation encountered an error.
 * @param {!Windows.Security.Authentication.Web.Core.WebProviderError} value The type of error encountered.
 * @return {void}
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderDeleteAccountOperation.prototype.reportError = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderGetTokenSilentOperation = function() {};
 /** @type {!Date} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderGetTokenSilentOperation.prototype.cacheExpirationTime;
 /** @type {Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderGetTokenSilentOperation.prototype.kind;
 /** @type {!Windows.Security.Authentication.Web.Provider.WebProviderTokenRequest} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderGetTokenSilentOperation.prototype.providerRequest;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Security.Authentication.Web.Provider.WebProviderTokenResponse>} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderGetTokenSilentOperation.prototype.providerResponses;

/**
 * Informs the activating app that the operation completed successfully.
 * @return {void}
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderGetTokenSilentOperation.prototype.reportCompleted = function() {};

/**
 * Informs the activating app that the operation encountered an error.
 * @param {!Windows.Security.Authentication.Web.Core.WebProviderError} value The type of error encountered.
 * @return {void}
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderGetTokenSilentOperation.prototype.reportError = function(value) {};

/**
 * Informs the activating app that user interaction is required to continue the operation.
 * Informs the activating app that an error has occurred and user interaction is required to continue the operation.
 * @param {!Windows.Security.Authentication.Web.Core.WebProviderError=} value The error that has occurred.
 * @return {void}
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderGetTokenSilentOperation.prototype.reportUserInteractionRequired = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderManageAccountOperation = function() {};
 /** @type {Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderManageAccountOperation.prototype.kind;
 /** @type {!Windows.Security.Credentials.WebAccount} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderManageAccountOperation.prototype.webAccount;

/**
 * Informs the activating application that the operation completed successfully.
 * @return {void}
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderManageAccountOperation.prototype.reportCompleted = function() {};

/** @const */
Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind = {};
/** @const {number} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind.requestToken;
/** @const {number} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind.getTokenSilently;
/** @const {number} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind.addAccount;
/** @const {number} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind.manageAccount;
/** @const {number} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind.deleteAccount;
/** @const {number} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind.retrieveCookies;
/** @const {number} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind.signOutAccount;
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRequestTokenOperation = function() {};
 /** @type {!Date} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRequestTokenOperation.prototype.cacheExpirationTime;
 /** @type {Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRequestTokenOperation.prototype.kind;
 /** @type {!Windows.Security.Authentication.Web.Provider.WebProviderTokenRequest} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRequestTokenOperation.prototype.providerRequest;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Security.Authentication.Web.Provider.WebProviderTokenResponse>} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRequestTokenOperation.prototype.providerResponses;

/**
 * Informs the activating app that the operation completed successfully.
 * @return {void}
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRequestTokenOperation.prototype.reportCompleted = function() {};

/**
 * Informs the activating app that the operation encountered an error.
 * @param {!Windows.Security.Authentication.Web.Core.WebProviderError} value The type of error encountered.
 * @return {void}
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRequestTokenOperation.prototype.reportError = function(value) {};

/**
 * Informs the activating app that the user cancelled the operation.
 * @return {void}
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRequestTokenOperation.prototype.reportUserCanceled = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRetrieveCookiesOperation = function() {};
 /** @type {!Windows.Foundation.Uri} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRetrieveCookiesOperation.prototype.applicationCallbackUri;
 /** @type {!Windows.Foundation.Uri} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRetrieveCookiesOperation.prototype.context;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Http.HttpCookie>} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRetrieveCookiesOperation.prototype.cookies;
 /** @type {Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRetrieveCookiesOperation.prototype.kind;
 /** @type {!Windows.Foundation.Uri} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRetrieveCookiesOperation.prototype.uri;

/**
 * Informs the activating app that the operation completed successfully.
 * @return {void}
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRetrieveCookiesOperation.prototype.reportCompleted = function() {};

/**
 * Informs the activating app that the operation encountered an error.
 * @param {!Windows.Security.Authentication.Web.Core.WebProviderError} value The type of error encountered.
 * @return {void}
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderRetrieveCookiesOperation.prototype.reportError = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderSignOutAccountOperation = function() {};
 /** @type {!Windows.Foundation.Uri} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderSignOutAccountOperation.prototype.applicationCallbackUri;
 /** @type {string} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderSignOutAccountOperation.prototype.clientId;
 /** @type {Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderSignOutAccountOperation.prototype.kind;
 /** @type {!Windows.Security.Credentials.WebAccount} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderSignOutAccountOperation.prototype.webAccount;

/**
 * Informs the activating app that the operation completed successfully.
 * @return {void}
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderSignOutAccountOperation.prototype.reportCompleted = function() {};

/**
 * Informs the activating app that the operation encountered an error.
 * @param {!Windows.Security.Authentication.Web.Core.WebProviderError} value The type of error encountered.
 * @return {void}
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderSignOutAccountOperation.prototype.reportError = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.Web.Provider.WebAccountProviderTriggerDetails = function() {};
 /** @type {!Windows.Security.Authentication.Web.Provider.IWebAccountProviderOperation} */
Windows.Security.Authentication.Web.Provider.WebAccountProviderTriggerDetails.prototype.operation;

/** @const */
Windows.Security.Authentication.Web.Provider.WebAccountScope = {};
/** @const {number} */
Windows.Security.Authentication.Web.Provider.WebAccountScope.perUser;
/** @const {number} */
Windows.Security.Authentication.Web.Provider.WebAccountScope.perApplication;

/** @const */
Windows.Security.Authentication.Web.Provider.WebAccountSelectionOptions = {};
/** @const {number} */
Windows.Security.Authentication.Web.Provider.WebAccountSelectionOptions.default;
/** @const {number} */
Windows.Security.Authentication.Web.Provider.WebAccountSelectionOptions.new;
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.Web.Provider.WebProviderTokenRequest = function() {};
 /** @type {!Windows.Foundation.Uri} */
Windows.Security.Authentication.Web.Provider.WebProviderTokenRequest.prototype.applicationCallbackUri;
 /** @type {!Windows.Security.Authentication.Web.Core.WebTokenRequest} */
Windows.Security.Authentication.Web.Provider.WebProviderTokenRequest.prototype.clientRequest;
 /** @type {Windows.Security.Authentication.Web.Provider.WebAccountSelectionOptions} */
Windows.Security.Authentication.Web.Provider.WebProviderTokenRequest.prototype.webAccountSelectionOptions;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Credentials.WebAccount>} */
Windows.Security.Authentication.Web.Provider.WebProviderTokenRequest.prototype.webAccounts;

/**
 * Gets a token binding key for the app asynchronously.
 * @param {Windows.Security.Authentication.Web.TokenBindingKeyType} keyType The type of key to get.
 * @param {!Windows.Foundation.Uri} target The target Uri.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Cryptography.Core.CryptographicKey, !Windows.Foundation.IAsyncOperation<!Windows.Security.Cryptography.Core.CryptographicKey>>} When this method completes, it returns a cryptographic key.
 */
Windows.Security.Authentication.Web.Provider.WebProviderTokenRequest.prototype.getApplicationTokenBindingKeyAsync = function(keyType, target) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the WebProviderTokenResponse class.
 * @param {!Windows.Security.Authentication.Web.Core.WebTokenResponse} webTokenResponse The web token response from the client.
 */
Windows.Security.Authentication.Web.Provider.WebProviderTokenResponse = function(webTokenResponse) {};
 /** @type {!Windows.Security.Authentication.Web.Core.WebTokenResponse} */
Windows.Security.Authentication.Web.Provider.WebProviderTokenResponse.prototype.clientResponse;
/**
 * @record
 * @struct
 */
Windows.Security.Authentication.Web.Provider.IWebAccountProviderOperation = function() {};
 /** @type {Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind} */
Windows.Security.Authentication.Web.Provider.IWebAccountProviderOperation.prototype.kind;

/** @const */
Windows.Security.Authentication.Web.TokenBindingKeyType = {};
/** @const {number} */
Windows.Security.Authentication.Web.TokenBindingKeyType.rsa2048;
/** @const {number} */
Windows.Security.Authentication.Web.TokenBindingKeyType.ecdsaP256;
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.Web.WebAuthenticationBroker = function() {};

/**
 * Starts the authentication operation with two inputs.
 * Starts the authentication operation with one input.
 * Starts the authentication operation with four inputs.
 * @param {!Windows.Foundation.Uri} requestUri The starting URI of the web service. This URI must be a secure address of https://.
 * @param {!Windows.Foundation.Uri=} callbackUri The callback URI that indicates the completion of the web authentication. The broker matches this URI against every URI that it is about to navigate to. The broker never navigates to this URI, instead the broker returns the control back to the application when the user clicks a link or a web server redirection is made.
 * @param {!Windows.Foundation.Collections.ValueSet=} continuationData Continuation data to be passed as part of the authentication operation.
 * @param {Windows.Security.Authentication.Web.WebAuthenticationOptions=} options The options for the authentication operation.
 * @return {void}
 */
Windows.Security.Authentication.Web.WebAuthenticationBroker.authenticateAndContinue = function(requestUri, callbackUri, continuationData, options) {};

/**
 * Starts the asynchronous authentication operation with three inputs. You can call this method multiple times in a single application or across multiple applications at the same time.
 * Starts the asynchronous authentication operation with two inputs. You can call this method multiple times in a single application or across multiple applications at the same time.
 * @param {Windows.Security.Authentication.Web.WebAuthenticationOptions} options The options for the authentication operation.
 * @param {!Windows.Foundation.Uri} requestUri The starting URI of the web service. This URI must be a secure address of https://.
 * @param {!Windows.Foundation.Uri=} callbackUri The callback URI that indicates the completion of the web authentication. The broker matches this URI against every URI that it is about to navigate to. The broker never navigates to this URI, instead the broker returns the control back to the application when the user clicks a link or a web server redirection is made.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Authentication.Web.WebAuthenticationResult, !Windows.Foundation.IAsyncOperation<!Windows.Security.Authentication.Web.WebAuthenticationResult>>} The way to query the status and get the results of the authentication operation. If you are getting an invalid parameter error, the most common cause is that you are not using HTTPS for the requestUri parameter.
 */
Windows.Security.Authentication.Web.WebAuthenticationBroker.authenticateAsync = function(options, requestUri, callbackUri) {};

/**
 * Starts the asynchronous authentication operation silently (no UI will be shown) with two inputs. You can call this method multiple times in a single application or across multiple applications at the same time.
 * Starts the asynchronous authentication operation silently (no UI will be shown) with one input. You can call this method multiple times in a single application or across multiple applications at the same time.
 * @param {!Windows.Foundation.Uri} requestUri The starting URI of the web service. This URI must be a secure address of https://.
 * @param {Windows.Security.Authentication.Web.WebAuthenticationOptions=} options The options for the authentication operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Authentication.Web.WebAuthenticationResult, !Windows.Foundation.IAsyncOperation<!Windows.Security.Authentication.Web.WebAuthenticationResult>>} The way to query the status and get the results of the authentication operation. If you are getting an invalid parameter error, the most common cause is that you are not using HTTPS for the requestUri parameter.
 */
Windows.Security.Authentication.Web.WebAuthenticationBroker.authenticateSilentlyAsync = function(requestUri, options) {};

/**
 * Gets the current application callback URI.
 * @return {!Windows.Foundation.Uri} The URI of the current application.
 */
Windows.Security.Authentication.Web.WebAuthenticationBroker.getCurrentApplicationCallbackUri = function() {};

/** @const */
Windows.Security.Authentication.Web.WebAuthenticationOptions = {};
/** @const {number} */
Windows.Security.Authentication.Web.WebAuthenticationOptions.none;
/** @const {number} */
Windows.Security.Authentication.Web.WebAuthenticationOptions.silentMode;
/** @const {number} */
Windows.Security.Authentication.Web.WebAuthenticationOptions.useTitle;
/** @const {number} */
Windows.Security.Authentication.Web.WebAuthenticationOptions.useHttpPost;
/** @const {number} */
Windows.Security.Authentication.Web.WebAuthenticationOptions.useCorporateNetwork;
/**
 * @constructor
 * @struct
 */
Windows.Security.Authentication.Web.WebAuthenticationResult = function() {};
 /** @type {string} */
Windows.Security.Authentication.Web.WebAuthenticationResult.prototype.responseData;
 /** @type {number} */
Windows.Security.Authentication.Web.WebAuthenticationResult.prototype.responseErrorDetail;
 /** @type {Windows.Security.Authentication.Web.WebAuthenticationStatus} */
Windows.Security.Authentication.Web.WebAuthenticationResult.prototype.responseStatus;

/** @const */
Windows.Security.Authentication.Web.WebAuthenticationStatus = {};
/** @const {number} */
Windows.Security.Authentication.Web.WebAuthenticationStatus.success;
/** @const {number} */
Windows.Security.Authentication.Web.WebAuthenticationStatus.userCancel;
/** @const {number} */
Windows.Security.Authentication.Web.WebAuthenticationStatus.errorHttp;
/** @const */
Windows.Security.Credentials = {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Credentials.KeyCredential = function() {};
 /** @type {string} */
Windows.Security.Credentials.KeyCredential.prototype.name;

/**
 * Gets an attestation for a key credential. Call this method after provisioning a key credential for the current user and application.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Credentials.KeyCredentialAttestationResult, !Windows.Foundation.IAsyncOperation<!Windows.Security.Credentials.KeyCredentialAttestationResult>>} When this method completes, it returns a key credential attestation result.
 */
Windows.Security.Credentials.KeyCredential.prototype.getAttestationAsync = function() {};

/**
 * Prompts the user to cryptographcally sign data using their key credential.
 * @param {!Windows.Storage.Streams.IBuffer} data The data to cryptographically sign.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Credentials.KeyCredentialOperationResult, !Windows.Foundation.IAsyncOperation<!Windows.Security.Credentials.KeyCredentialOperationResult>>} When this method completes, it returns a key credential operation result.
 */
Windows.Security.Credentials.KeyCredential.prototype.requestSignAsync = function(data) {};

/**
 * Gets the public portion of the asymmetric KeyCredential .
 * Gets the public portion of the asymmetric KeyCredential .
 * @param {Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType=} blobType The blob type of the public key to retrieve.
 * @return {!Windows.Storage.Streams.IBuffer} The public portion of the asymmetric key credential.
 */
Windows.Security.Credentials.KeyCredential.prototype.retrievePublicKey = function(blobType) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Credentials.KeyCredentialAttestationResult = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Security.Credentials.KeyCredentialAttestationResult.prototype.attestationBuffer;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Security.Credentials.KeyCredentialAttestationResult.prototype.certificateChainBuffer;
 /** @type {Windows.Security.Credentials.KeyCredentialAttestationStatus} */
Windows.Security.Credentials.KeyCredentialAttestationResult.prototype.status;

/** @const */
Windows.Security.Credentials.KeyCredentialAttestationStatus = {};
/** @const {number} */
Windows.Security.Credentials.KeyCredentialAttestationStatus.success;
/** @const {number} */
Windows.Security.Credentials.KeyCredentialAttestationStatus.unknownError;
/** @const {number} */
Windows.Security.Credentials.KeyCredentialAttestationStatus.notSupported;
/** @const {number} */
Windows.Security.Credentials.KeyCredentialAttestationStatus.temporaryFailure;

/** @const */
Windows.Security.Credentials.KeyCredentialCreationOption = {};
/** @const {number} */
Windows.Security.Credentials.KeyCredentialCreationOption.replaceExisting;
/** @const {number} */
Windows.Security.Credentials.KeyCredentialCreationOption.failIfExists;
/**
 * @constructor
 * @struct
 */
Windows.Security.Credentials.KeyCredentialManager = function() {};

/**
 * Deletes a previously provisioned user identity key for the current user and application.
 * @param {string} name The name of the key to delete.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Credentials.KeyCredentialManager.deleteAsync = function(name) {};

/**
 * Determines if the current device and user is capable of provisioning a key credential.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} When this method completes, it returns true if the current device and user is capable of provisioning a key credential. Otherwise, it returns false.
 */
Windows.Security.Credentials.KeyCredentialManager.isSupportedAsync = function() {};

/**
 * Retrieves a key credential for the current user and application.
 * @param {string} name The name of the key credential to open.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Credentials.KeyCredentialRetrievalResult, !Windows.Foundation.IAsyncOperation<!Windows.Security.Credentials.KeyCredentialRetrievalResult>>} When this method completes, it returns the results of the key credential retrieval.
 */
Windows.Security.Credentials.KeyCredentialManager.openAsync = function(name) {};

/**
 * Renews an attestation for a key credential.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Credentials.KeyCredentialManager.renewAttestationAsync = function() {};

/**
 * Creates a new key credential for the current user and application.
 * @param {string} name The name of the key credential to create.
 * @param {Windows.Security.Credentials.KeyCredentialCreationOption} option Options for the creation operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Credentials.KeyCredentialRetrievalResult, !Windows.Foundation.IAsyncOperation<!Windows.Security.Credentials.KeyCredentialRetrievalResult>>} When this method completes, it returns the results of the key credential creation.
 */
Windows.Security.Credentials.KeyCredentialManager.requestCreateAsync = function(name, option) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Credentials.KeyCredentialOperationResult = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Security.Credentials.KeyCredentialOperationResult.prototype.result;
 /** @type {Windows.Security.Credentials.KeyCredentialStatus} */
Windows.Security.Credentials.KeyCredentialOperationResult.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Security.Credentials.KeyCredentialRetrievalResult = function() {};
 /** @type {!Windows.Security.Credentials.KeyCredential} */
Windows.Security.Credentials.KeyCredentialRetrievalResult.prototype.credential;
 /** @type {Windows.Security.Credentials.KeyCredentialStatus} */
Windows.Security.Credentials.KeyCredentialRetrievalResult.prototype.status;

/** @const */
Windows.Security.Credentials.KeyCredentialStatus = {};
/** @const {number} */
Windows.Security.Credentials.KeyCredentialStatus.success;
/** @const {number} */
Windows.Security.Credentials.KeyCredentialStatus.unknownError;
/** @const {number} */
Windows.Security.Credentials.KeyCredentialStatus.notFound;
/** @const {number} */
Windows.Security.Credentials.KeyCredentialStatus.userCanceled;
/** @const {number} */
Windows.Security.Credentials.KeyCredentialStatus.userPrefersPassword;
/** @const {number} */
Windows.Security.Credentials.KeyCredentialStatus.credentialAlreadyExists;
/** @const {number} */
Windows.Security.Credentials.KeyCredentialStatus.securityDeviceLocked;

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the PasswordCredential object that contains the provided credential data.
 * Creates and initializes a new, empty instance of the PasswordCredential object.
 * @param {string=} resource The resource for which the credentials are used.
 * @param {string=} userName The user name that must be present in the credentials.
 * @param {string=} password The password for the created credentials.
 */
Windows.Security.Credentials.PasswordCredential = function(resource, userName, password) {};
 /** @type {string} */
Windows.Security.Credentials.PasswordCredential.prototype.password;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Security.Credentials.PasswordCredential.prototype.properties;
 /** @type {string} */
Windows.Security.Credentials.PasswordCredential.prototype.resource;
 /** @type {string} */
Windows.Security.Credentials.PasswordCredential.prototype.userName;

/**
 * Populates the password for the credential. After the operation returns successfully, you can get the password from the Password property.
 * @return {void}
 */
Windows.Security.Credentials.PasswordCredential.prototype.retrievePassword = function() {};

/**
 * @constructor
 * @struct
 * This method is reserved for internal use and is not intended to be used in your code.
 */
Windows.Security.Credentials.PasswordCredentialPropertyStore = function() {};
 /** @type {function(?): void} */
Windows.Security.Credentials.PasswordCredentialPropertyStore.prototype.onmapchanged;
 /** @type {number} */
Windows.Security.Credentials.PasswordCredentialPropertyStore.prototype.size;

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 * @return {void}
 */
Windows.Security.Credentials.PasswordCredentialPropertyStore.prototype.clear = function() {};

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 * @return {?}
 */
Windows.Security.Credentials.PasswordCredentialPropertyStore.prototype.first = function() {};

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 * @return {?}
 */
Windows.Security.Credentials.PasswordCredentialPropertyStore.prototype.getView = function() {};

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 * @param {string} key Reserved.
 * @return {?}
 */
Windows.Security.Credentials.PasswordCredentialPropertyStore.prototype.hasKey = function(key) {};

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 * @param {string} key Reserved.
 * @param {?} value Reserved.
 * @return {?}
 */
Windows.Security.Credentials.PasswordCredentialPropertyStore.prototype.insert = function(key, value) {};

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 * @param {string} key Reserved.
 * @return {?}
 */
Windows.Security.Credentials.PasswordCredentialPropertyStore.prototype.lookup = function(key) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Security.Credentials.PasswordCredentialPropertyStore.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Security.Credentials.PasswordCredentialPropertyStore.prototype.removeEventListener = function(type, listener) {};

/**
 * This method is reserved for internal use and is not intended to be used in your code.
 * @param {string} key Reserved.
 * @return {void}
 */
Windows.Security.Credentials.PasswordCredentialPropertyStore.prototype.remove = function(key) {};

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the PasswordVault object.
 */
Windows.Security.Credentials.PasswordVault = function() {};

/**
 * Adds a credential to the Credential Locker.
 * @param {!Windows.Security.Credentials.PasswordCredential} credential The credential to be added.
 * @return {void}
 */
Windows.Security.Credentials.PasswordVault.prototype.add = function(credential) {};

/**
 * Searches the Credential Locker for credentials matching the resource specified.
 * @param {string} resource The resource to be searched for.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Credentials.PasswordCredential>} When this method returns, contains an IVectorView of credential objects that match the search criteria.
 */
Windows.Security.Credentials.PasswordVault.prototype.findAllByResource = function(resource) {};

/**
 * Searches the Credential Locker for credentials that match the user name specified.
 * @param {string} userName The user name to be searched for.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Credentials.PasswordCredential>} When this method returns, contains an IVectorView of credential objects that match the search criteria.
 */
Windows.Security.Credentials.PasswordVault.prototype.findAllByUserName = function(userName) {};

/**
 * Removes a credential from the Credential Locker.
 * @param {!Windows.Security.Credentials.PasswordCredential} credential The credential to be removed.
 * @return {void}
 */
Windows.Security.Credentials.PasswordVault.prototype.remove = function(credential) {};

/**
 * Reads a credential from the Credential Locker.
 * @param {string} resource The resource for which the credential is used.
 * @param {string} userName The user name that must be present in the credential.
 * @return {!Windows.Security.Credentials.PasswordCredential} The returned credential that contains all the data.
 */
Windows.Security.Credentials.PasswordVault.prototype.retrieve = function(resource, userName) {};

/**
 * Retrieves all of the credentials stored in the Credential Locker.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Credentials.PasswordCredential>} When this method returns, contains an IVectorView output of credential objects that match the search criteria. This output is a snapshot and not dynamic. If the results are used for updating or deleting credentials, those changes won't be reflected in the previous output.
 */
Windows.Security.Credentials.PasswordVault.prototype.retrieveAll = function() {};
/** @const */
Windows.Security.Credentials.UI = {};

/** @const */
Windows.Security.Credentials.UI.AuthenticationProtocol = {};
/** @const {number} */
Windows.Security.Credentials.UI.AuthenticationProtocol.basic;
/** @const {number} */
Windows.Security.Credentials.UI.AuthenticationProtocol.digest;
/** @const {number} */
Windows.Security.Credentials.UI.AuthenticationProtocol.ntlm;
/** @const {number} */
Windows.Security.Credentials.UI.AuthenticationProtocol.kerberos;
/** @const {number} */
Windows.Security.Credentials.UI.AuthenticationProtocol.negotiate;
/** @const {number} */
Windows.Security.Credentials.UI.AuthenticationProtocol.credSsp;
/** @const {number} */
Windows.Security.Credentials.UI.AuthenticationProtocol.custom;
/**
 * @constructor
 * @struct
 */
Windows.Security.Credentials.UI.CredentialPicker = function() {};

/**
 * Constructor used to initiate asynchronous prompting operations using three inputs.
 * Constructor used to initiate asynchronous prompting operations using two inputs.
 * Displays a dialog box to the user and collects credentials from the user.
 * @param {string|!Windows.Security.Credentials.UI.CredentialPickerOptions} targetName_or_options The target name to display. / The options on displaying and collecting the credential box.
 * @param {string=} message The message to display in the dialog box.
 * @param {string=} caption The caption to display in the dialog box.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Credentials.UI.CredentialPickerResults, !Windows.Foundation.IAsyncOperation<!Windows.Security.Credentials.UI.CredentialPickerResults>>} The credential and options from the user.
 */
Windows.Security.Credentials.UI.CredentialPicker.pickAsync = function(targetName_or_options, message, caption) {};

/**
 * @constructor
 * @struct
 * Creates and initializes a new, empty instance of the CredentialPickerOptions object.
 */
Windows.Security.Credentials.UI.CredentialPickerOptions = function() {};
 /** @type {boolean} */
Windows.Security.Credentials.UI.CredentialPickerOptions.prototype.alwaysDisplayDialog;
 /** @type {Windows.Security.Credentials.UI.AuthenticationProtocol} */
Windows.Security.Credentials.UI.CredentialPickerOptions.prototype.authenticationProtocol;
 /** @type {boolean} */
Windows.Security.Credentials.UI.CredentialPickerOptions.prototype.callerSavesCredential;
 /** @type {string} */
Windows.Security.Credentials.UI.CredentialPickerOptions.prototype.caption;
 /** @type {Windows.Security.Credentials.UI.CredentialSaveOption} */
Windows.Security.Credentials.UI.CredentialPickerOptions.prototype.credentialSaveOption;
 /** @type {string} */
Windows.Security.Credentials.UI.CredentialPickerOptions.prototype.customAuthenticationProtocol;
 /** @type {number} */
Windows.Security.Credentials.UI.CredentialPickerOptions.prototype.errorCode;
 /** @type {string} */
Windows.Security.Credentials.UI.CredentialPickerOptions.prototype.message;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Security.Credentials.UI.CredentialPickerOptions.prototype.previousCredential;
 /** @type {string} */
Windows.Security.Credentials.UI.CredentialPickerOptions.prototype.targetName;
/**
 * @constructor
 * @struct
 */
Windows.Security.Credentials.UI.CredentialPickerResults = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Security.Credentials.UI.CredentialPickerResults.prototype.credential;
 /** @type {string} */
Windows.Security.Credentials.UI.CredentialPickerResults.prototype.credentialDomainName;
 /** @type {string} */
Windows.Security.Credentials.UI.CredentialPickerResults.prototype.credentialPassword;
 /** @type {Windows.Security.Credentials.UI.CredentialSaveOption} */
Windows.Security.Credentials.UI.CredentialPickerResults.prototype.credentialSaveOption;
 /** @type {boolean} */
Windows.Security.Credentials.UI.CredentialPickerResults.prototype.credentialSaved;
 /** @type {string} */
Windows.Security.Credentials.UI.CredentialPickerResults.prototype.credentialUserName;
 /** @type {number} */
Windows.Security.Credentials.UI.CredentialPickerResults.prototype.errorCode;

/** @const */
Windows.Security.Credentials.UI.CredentialSaveOption = {};
/** @const {number} */
Windows.Security.Credentials.UI.CredentialSaveOption.unselected;
/** @const {number} */
Windows.Security.Credentials.UI.CredentialSaveOption.selected;
/** @const {number} */
Windows.Security.Credentials.UI.CredentialSaveOption.hidden;

/** @const */
Windows.Security.Credentials.UI.UserConsentVerificationResult = {};
/** @const {number} */
Windows.Security.Credentials.UI.UserConsentVerificationResult.verified;
/** @const {number} */
Windows.Security.Credentials.UI.UserConsentVerificationResult.deviceNotPresent;
/** @const {number} */
Windows.Security.Credentials.UI.UserConsentVerificationResult.notConfiguredForUser;
/** @const {number} */
Windows.Security.Credentials.UI.UserConsentVerificationResult.disabledByPolicy;
/** @const {number} */
Windows.Security.Credentials.UI.UserConsentVerificationResult.deviceBusy;
/** @const {number} */
Windows.Security.Credentials.UI.UserConsentVerificationResult.retriesExhausted;
/** @const {number} */
Windows.Security.Credentials.UI.UserConsentVerificationResult.canceled;
/**
 * @constructor
 * @struct
 */
Windows.Security.Credentials.UI.UserConsentVerifier = function() {};

/**
 * Checks to see whether a biometric (fingerprint) verifier device is available.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Security.Credentials.UI.UserConsentVerifierAvailability, !Windows.Foundation.IAsyncOperation<Windows.Security.Credentials.UI.UserConsentVerifierAvailability>>} A UserConsentVerifierAvailability value that describes the result of the availability check operation.
 */
Windows.Security.Credentials.UI.UserConsentVerifier.checkAvailabilityAsync = function() {};

/**
 * Performs a fingerprint (biometric) verification.
 * @param {string} message A message to display to the user for this biometric verification request.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Security.Credentials.UI.UserConsentVerificationResult, !Windows.Foundation.IAsyncOperation<Windows.Security.Credentials.UI.UserConsentVerificationResult>>} A UserConsentVerificationResult value that describes the result of the biometric verification.
 */
Windows.Security.Credentials.UI.UserConsentVerifier.requestVerificationAsync = function(message) {};

/** @const */
Windows.Security.Credentials.UI.UserConsentVerifierAvailability = {};
/** @const {number} */
Windows.Security.Credentials.UI.UserConsentVerifierAvailability.available;
/** @const {number} */
Windows.Security.Credentials.UI.UserConsentVerifierAvailability.deviceNotPresent;
/** @const {number} */
Windows.Security.Credentials.UI.UserConsentVerifierAvailability.notConfiguredForUser;
/** @const {number} */
Windows.Security.Credentials.UI.UserConsentVerifierAvailability.disabledByPolicy;
/** @const {number} */
Windows.Security.Credentials.UI.UserConsentVerifierAvailability.deviceBusy;

/**
 * @constructor
 * @struct
 * Creates an instance of the WebAccount class.
 * @param {!Windows.Security.Credentials.WebAccountProvider} webAccountProvider The web account provider associated with the web account.
 * @param {string} userName The user name of the web account.
 * @param {Windows.Security.Credentials.WebAccountState} state The state of the web account.
 */
Windows.Security.Credentials.WebAccount = function(webAccountProvider, userName, state) {};
 /** @type {string} */
Windows.Security.Credentials.WebAccount.prototype.id;
 /** @type {!Windows.Foundation.Collections.IMapView<string, string>} */
Windows.Security.Credentials.WebAccount.prototype.properties;
 /** @type {Windows.Security.Credentials.WebAccountState} */
Windows.Security.Credentials.WebAccount.prototype.state;
 /** @type {string} */
Windows.Security.Credentials.WebAccount.prototype.userName;
 /** @type {!Windows.Security.Credentials.WebAccountProvider} */
Windows.Security.Credentials.WebAccount.prototype.webAccountProvider;

/**
 * Gets the web account's picture asynchronously.
 * @param {Windows.Security.Credentials.WebAccountPictureSize} desizedSize The desired size of the web account picture.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStream, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStream>>} When this method completes, it returns the web account's picture.
 */
Windows.Security.Credentials.WebAccount.prototype.getPictureAsync = function(desizedSize) {};

/**
 * Signs the web account out asynchronously. This clears all cached tokens associated with the account, and tells the provider to invalidate any tokens associated with the account for this app.
 * Signs the web account out asynchronously. This clears all cached tokens associated with the account, and tells the provider to invalidate any tokens associated with the account for this app.
 * @param {string=} clientId The Id of the client.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Credentials.WebAccount.prototype.signOutAsync = function(clientId) {};

/** @const */
Windows.Security.Credentials.WebAccountPictureSize = {};
/** @const {number} */
Windows.Security.Credentials.WebAccountPictureSize.size64x64;
/** @const {number} */
Windows.Security.Credentials.WebAccountPictureSize.size208x208;
/** @const {number} */
Windows.Security.Credentials.WebAccountPictureSize.size424x424;
/** @const {number} */
Windows.Security.Credentials.WebAccountPictureSize.size1080x1080;

/**
 * @constructor
 * @struct
 * Creates an instance of the WebAccountProvider class.
 * @param {string} id The web account provider id.
 * @param {string} displayName The display name for the web account provider.
 * @param {!Windows.Foundation.Uri} iconUri The Uri of the icon image to display for the web account provider.
 */
Windows.Security.Credentials.WebAccountProvider = function(id, displayName, iconUri) {};
 /** @type {string} */
Windows.Security.Credentials.WebAccountProvider.prototype.authority;
 /** @type {string} */
Windows.Security.Credentials.WebAccountProvider.prototype.displayName;
 /** @type {string} */
Windows.Security.Credentials.WebAccountProvider.prototype.displayPurpose;
 /** @type {!Windows.Foundation.Uri} */
Windows.Security.Credentials.WebAccountProvider.prototype.iconUri;
 /** @type {string} */
Windows.Security.Credentials.WebAccountProvider.prototype.id;
 /** @type {!Windows.System.User} */
Windows.Security.Credentials.WebAccountProvider.prototype.user;

/** @const */
Windows.Security.Credentials.WebAccountState = {};
/** @const {number} */
Windows.Security.Credentials.WebAccountState.none;
/** @const {number} */
Windows.Security.Credentials.WebAccountState.connected;
/** @const {number} */
Windows.Security.Credentials.WebAccountState.error;
/** @const */
Windows.Security.Cryptography = {};

/** @const */
Windows.Security.Cryptography.BinaryStringEncoding = {};
/** @const {number} */
Windows.Security.Cryptography.BinaryStringEncoding.utf8;
/** @const {number} */
Windows.Security.Cryptography.BinaryStringEncoding.utf16LE;
/** @const {number} */
Windows.Security.Cryptography.BinaryStringEncoding.utf16BE;
/** @const */
Windows.Security.Cryptography.Certificates = {};

/**
 * @constructor
 * @struct
 * Create a new instance of the Certificate class using the specified certificate data.
 * @param {!Windows.Storage.Streams.IBuffer} certBlob The certificate data as an ASN.1 DER encoded certificate blob (.cer or .p7b).
 */
Windows.Security.Cryptography.Certificates.Certificate = function(certBlob) {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.enhancedKeyUsages;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.friendlyName;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.hasPrivateKey;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.isSecurityDeviceBound;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.isStronglyProtected;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.issuer;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.keyAlgorithmName;
 /** @type {!Windows.Security.Cryptography.Certificates.CertificateKeyUsages} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.keyUsages;
 /** @type {number} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.serialNumber;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.signatureAlgorithmName;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.signatureHashAlgorithmName;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.subject;
 /** @type {!Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.subjectAlternativeName;
 /** @type {!Date} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.validFrom;
 /** @type {!Date} */
Windows.Security.Cryptography.Certificates.Certificate.prototype.validTo;

/**
 * Build a certificate chain for the specified certificates starting from the end entity certificate to the root using the specified chain building parameters.
 * Build a certificate chain for the specified certificates starting from the end entity certificate to the root.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Security.Cryptography.Certificates.Certificate>} certificates The intermediate certificates to use when building the certificate chain.
 * @param {!Windows.Security.Cryptography.Certificates.ChainBuildingParameters=} parameters The chain building paramaters to use when building the certificate chain.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Cryptography.Certificates.CertificateChain, !Windows.Foundation.IAsyncOperation<!Windows.Security.Cryptography.Certificates.CertificateChain>>} An asynchronous operation to retrieve the CertificateChain object that contains the entire certificate chain.
 */
Windows.Security.Cryptography.Certificates.Certificate.prototype.buildChainAsync = function(certificates, parameters) {};

/**
 * Gets the ASN.1 DER encoded certificate blob.
 * @return {!Windows.Storage.Streams.IBuffer} The ASN.1 DER encoded certificate blob.
 */
Windows.Security.Cryptography.Certificates.Certificate.prototype.getCertificateBlob = function() {};

/**
 * Gets the hash value for the certificate for a specified algorithm.
 * Gets the SHA1 hash value for the certificate.
 * @param {string=} hashAlgorithmName The hash algorithm to use for the hash value of the certificate. Only values of "SHA1" or "SHA256" are supported.
 * @return {!Array<number>} The hash value of the certificate. / The SHA1 hash value for the certificate.
 */
Windows.Security.Cryptography.Certificates.Certificate.prototype.getHashValue = function(hashAlgorithmName) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Certificates.CertificateChain = function() {};

/**
 * Gets the list of certificates from the certificate chain.
 * @param {boolean} includeRoot True to include the root certificate in the results; otherwise false.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Cryptography.Certificates.Certificate>} The list of certificates from the certificate chain.
 */
Windows.Security.Cryptography.Certificates.CertificateChain.prototype.getCertificates = function(includeRoot) {};

/**
 * Verifies whether or not the certificate chain is valid.
 * Verifies whether or not the certificate chain is valid using the specified validation parameters.
 * @param {!Windows.Security.Cryptography.Certificates.ChainValidationParameters=} parameter The validation parameters to use when verifying the certificate chain.
 * @return {Windows.Security.Cryptography.Certificates.ChainValidationResult} The result of the certificate chain verification operation.
 */
Windows.Security.Cryptography.Certificates.CertificateChain.prototype.validate = function(parameter) {};

/** @const */
Windows.Security.Cryptography.Certificates.CertificateChainPolicy = {};
/** @const {number} */
Windows.Security.Cryptography.Certificates.CertificateChainPolicy.base;
/** @const {number} */
Windows.Security.Cryptography.Certificates.CertificateChainPolicy.ssl;
/** @const {number} */
Windows.Security.Cryptography.Certificates.CertificateChainPolicy.ntAuthentication;
/** @const {number} */
Windows.Security.Cryptography.Certificates.CertificateChainPolicy.microsoftRoot;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager = function() {};
 /** @type {!Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager} */
Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager.userCertificateEnrollmentManager;

/**
 * Asynchronously creates a PKCS #10 certificate request based on properties specified in a CertificateRequestProperties object.
 * @param {!Windows.Security.Cryptography.Certificates.CertificateRequestProperties} request A CertificateRequestProperties object that contains the property values used to create the certificate request.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} This method returns a string that contains the base64 encoded PKCS #10 certificate request.
 */
Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager.createRequestAsync = function(request) {};

/**
 * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message.
 * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message using the specified key storage provider.
 * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message using import parameters.
 * @param {string} pfxData Base64-encoded PFX message.
 * @param {string} password The password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet.
 * @param {Windows.Security.Cryptography.Certificates.ExportOption|!Windows.Security.Cryptography.Certificates.PfxImportParameters} exportable_or_pfxImportParameters A value of the ExportOption enumeration that specifies whether the key can be exported. / The PFX import parameters.
 * @param {Windows.Security.Cryptography.Certificates.KeyProtectionLevel=} keyProtectionLevel A value of the KeyProtectionLevel enumeration that specifies the strength of the key protection. The default is NoConsent.
 * @param {Windows.Security.Cryptography.Certificates.InstallOptions=} installOption An InstallOptions enumeration value that specifies the certificate installation option.
 * @param {string=} friendlyName The display name of the enrolled certificate. This value overwrites the FriendlyName property inside the PFX message.
 * @param {string=} keyStorageProvider The name of the key storage provider to use when importing the certificate.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager.importPfxDataAsync = function(pfxData, password, exportable_or_pfxImportParameters, keyProtectionLevel, installOption, friendlyName, keyStorageProvider) {};

/**
 * Asynchronously Installs a certificate chain into the app container on the local computer.
 * @param {string} certificate The encoded certificate. The certificate is encoded by using Distinguished Encoding Rules (DER) as defined by the Abstract Syntax Notation One (ASN.1) standard.
 * @param {Windows.Security.Cryptography.Certificates.InstallOptions} installOption An InstallOptions enumeration value that specifies the certificate installation option.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager.installCertificateAsync = function(certificate, installOption) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the CertificateKeyUsages class.
 */
Windows.Security.Cryptography.Certificates.CertificateKeyUsages = function() {};
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.CertificateKeyUsages.prototype.crlSign;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.CertificateKeyUsages.prototype.dataEncipherment;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.CertificateKeyUsages.prototype.digitalSignature;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.CertificateKeyUsages.prototype.encipherOnly;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.CertificateKeyUsages.prototype.keyAgreement;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.CertificateKeyUsages.prototype.keyCertificateSign;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.CertificateKeyUsages.prototype.keyEncipherment;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.CertificateKeyUsages.prototype.nonRepudiation;

/**
 * @constructor
 * @struct
 * Creates a new instance of a certificate query.
 */
Windows.Security.Cryptography.Certificates.CertificateQuery = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Security.Cryptography.Certificates.CertificateQuery.prototype.enhancedKeyUsages;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.CertificateQuery.prototype.friendlyName;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.CertificateQuery.prototype.hardwareOnly;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.CertificateQuery.prototype.includeDuplicates;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.CertificateQuery.prototype.includeExpiredCertificates;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.CertificateQuery.prototype.issuerName;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.CertificateQuery.prototype.storeName;
 /** @type {number} */
Windows.Security.Cryptography.Certificates.CertificateQuery.prototype.thumbprint;

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the CertificateRequestProperties .
 */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties = function() {};
 /** @type {!Windows.Security.Cryptography.Certificates.Certificate} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.attestationCredentialCertificate;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.containerName;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.containerNamePrefix;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.curveName;
 /** @type {number} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.curveParameters;
 /** @type {Windows.Security.Cryptography.Certificates.ExportOption} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.exportable;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.friendlyName;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.hashAlgorithmName;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.keyAlgorithmName;
 /** @type {Windows.Security.Cryptography.Certificates.KeyProtectionLevel} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.keyProtectionLevel;
 /** @type {number} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.keySize;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.keyStorageProviderName;
 /** @type {Windows.Security.Cryptography.Certificates.EnrollKeyUsages} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.keyUsages;
 /** @type {!Windows.Security.Cryptography.Certificates.Certificate} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.signingCertificate;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.smartcardReaderName;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.subject;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.CertificateRequestProperties.prototype.useExistingKey;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Certificates.CertificateStore = function() {};
 /** @type {string} */
Windows.Security.Cryptography.Certificates.CertificateStore.prototype.name;

/**
 * Adds a certificate to the certificate store.
 * @param {!Windows.Security.Cryptography.Certificates.Certificate} certificate The certificate to add to the certificate store.
 * @return {void}
 */
Windows.Security.Cryptography.Certificates.CertificateStore.prototype.add = function(certificate) {};

/**
 * Deletes a certificate from the certificate store.
 * @param {!Windows.Security.Cryptography.Certificates.Certificate} certificate The certificate to delete from the certificate store.
 * @return {void}
 */
Windows.Security.Cryptography.Certificates.CertificateStore.prototype.delete = function(certificate) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Certificates.CertificateStores = function() {};
 /** @type {!Windows.Security.Cryptography.Certificates.CertificateStore} */
Windows.Security.Cryptography.Certificates.CertificateStores.intermediateCertificationAuthorities;
 /** @type {!Windows.Security.Cryptography.Certificates.CertificateStore} */
Windows.Security.Cryptography.Certificates.CertificateStores.trustedRootCertificationAuthorities;

/**
 * Get all certificates from the certificate stores that match the specified query parameters.
 * Get all certificates from the certificate stores.
 * @param {!Windows.Security.Cryptography.Certificates.CertificateQuery=} query The certificate values to search for.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An asynchronous operation to retrieve the list of certificates.
 */
Windows.Security.Cryptography.Certificates.CertificateStores.findAllAsync = function(query) {};

/**
 * Gets a certificate store from the collection of certificate stores by name.
 * @param {string} storeName The name of the certificate store to return. The storeName parameter value cannot be "MY".
 * @return {!Windows.Security.Cryptography.Certificates.CertificateStore} The requested certificate store.
 */
Windows.Security.Cryptography.Certificates.CertificateStores.getStoreByName = function(storeName) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the ChainBuildingParameters class.
 */
Windows.Security.Cryptography.Certificates.ChainBuildingParameters = function() {};
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.ChainBuildingParameters.prototype.authorityInformationAccessEnabled;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.ChainBuildingParameters.prototype.currentTimeValidationEnabled;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Security.Cryptography.Certificates.ChainBuildingParameters.prototype.enhancedKeyUsages;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Security.Cryptography.Certificates.Certificate>} */
Windows.Security.Cryptography.Certificates.ChainBuildingParameters.prototype.exclusiveTrustRoots;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.ChainBuildingParameters.prototype.networkRetrievalEnabled;
 /** @type {boolean} */
Windows.Security.Cryptography.Certificates.ChainBuildingParameters.prototype.revocationCheckEnabled;
 /** @type {!Date} */
Windows.Security.Cryptography.Certificates.ChainBuildingParameters.prototype.validationTimestamp;

/**
 * @constructor
 * @struct
 * Creates a new instance of the ChainValidationParameters class.
 */
Windows.Security.Cryptography.Certificates.ChainValidationParameters = function() {};
 /** @type {Windows.Security.Cryptography.Certificates.CertificateChainPolicy} */
Windows.Security.Cryptography.Certificates.ChainValidationParameters.prototype.certificateChainPolicy;
 /** @type {!Windows.Networking.HostName} */
Windows.Security.Cryptography.Certificates.ChainValidationParameters.prototype.serverDnsName;

/** @const */
Windows.Security.Cryptography.Certificates.ChainValidationResult = {};
/** @const {number} */
Windows.Security.Cryptography.Certificates.ChainValidationResult.success;
/** @const {number} */
Windows.Security.Cryptography.Certificates.ChainValidationResult.untrusted;
/** @const {number} */
Windows.Security.Cryptography.Certificates.ChainValidationResult.revoked;
/** @const {number} */
Windows.Security.Cryptography.Certificates.ChainValidationResult.expired;
/** @const {number} */
Windows.Security.Cryptography.Certificates.ChainValidationResult.incompleteChain;
/** @const {number} */
Windows.Security.Cryptography.Certificates.ChainValidationResult.invalidSignature;
/** @const {number} */
Windows.Security.Cryptography.Certificates.ChainValidationResult.wrongUsage;
/** @const {number} */
Windows.Security.Cryptography.Certificates.ChainValidationResult.invalidName;
/** @const {number} */
Windows.Security.Cryptography.Certificates.ChainValidationResult.invalidCertificateAuthorityPolicy;
/** @const {number} */
Windows.Security.Cryptography.Certificates.ChainValidationResult.basicConstraintsError;
/** @const {number} */
Windows.Security.Cryptography.Certificates.ChainValidationResult.unknownCriticalExtension;
/** @const {number} */
Windows.Security.Cryptography.Certificates.ChainValidationResult.revocationInformationMissing;
/** @const {number} */
Windows.Security.Cryptography.Certificates.ChainValidationResult.revocationFailure;
/** @const {number} */
Windows.Security.Cryptography.Certificates.ChainValidationResult.otherErrors;

/**
 * @constructor
 * @struct
 * Creates a new instance of the CmsAttachedSignature class for the specified signed CMS message.
 * @param {!Windows.Storage.Streams.IBuffer} inputBlob A signed CMS message blob.
 */
Windows.Security.Cryptography.Certificates.CmsAttachedSignature = function(inputBlob) {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Cryptography.Certificates.Certificate>} */
Windows.Security.Cryptography.Certificates.CmsAttachedSignature.prototype.certificates;
 /** @type {number} */
Windows.Security.Cryptography.Certificates.CmsAttachedSignature.prototype.content;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Cryptography.Certificates.CmsSignerInfo>} */
Windows.Security.Cryptography.Certificates.CmsAttachedSignature.prototype.signers;

/**
 * Signs the specified input data using the specified signer information and creates an attached signed CMS message.
 * @param {!Windows.Storage.Streams.IBuffer} data The input data to be signed.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Security.Cryptography.Certificates.CmsSignerInfo>} signers The signer information used to compute the signature.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Security.Cryptography.Certificates.Certificate>} certificates The list of certificates to build the chain for the signer certificates.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} An asynchronous operation to retrieve the attached signed CMS message.
 */
Windows.Security.Cryptography.Certificates.CmsAttachedSignature.generateSignatureAsync = function(data, signers, certificates) {};

/**
 * Verifies the signature contained in the signed CMS message.
 * @return {Windows.Security.Cryptography.Certificates.SignatureValidationResult} The result of the signature verification operation.
 */
Windows.Security.Cryptography.Certificates.CmsAttachedSignature.prototype.verifySignature = function() {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the CmsDetachedSignature class for the specified signed CMS message.
 * @param {!Windows.Storage.Streams.IBuffer} inputBlob A signed CMS message blob.
 */
Windows.Security.Cryptography.Certificates.CmsDetachedSignature = function(inputBlob) {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Cryptography.Certificates.Certificate>} */
Windows.Security.Cryptography.Certificates.CmsDetachedSignature.prototype.certificates;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Cryptography.Certificates.CmsSignerInfo>} */
Windows.Security.Cryptography.Certificates.CmsDetachedSignature.prototype.signers;

/**
 * Signs the specified input data using the specified signer information and creates a detached signed CMS message.
 * @param {!Windows.Storage.Streams.IInputStream} data The input data to be signed.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Security.Cryptography.Certificates.CmsSignerInfo>} signers The signer information used to compute the signature.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Security.Cryptography.Certificates.Certificate>} certificates The list of certificates to build the chain for the signer certificates.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} An asynchronous operation to retrieve the detached signed CMS message.
 */
Windows.Security.Cryptography.Certificates.CmsDetachedSignature.generateSignatureAsync = function(data, signers, certificates) {};

/**
 * Verifies a signed CMS message against the original streaming input.
 * @param {!Windows.Storage.Streams.IInputStream} data The original input stream for the signed CMS message.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Security.Cryptography.Certificates.SignatureValidationResult, !Windows.Foundation.IAsyncOperation<Windows.Security.Cryptography.Certificates.SignatureValidationResult>>} An asynchronous operation to retrieve the result of the signature validation operation.
 */
Windows.Security.Cryptography.Certificates.CmsDetachedSignature.prototype.verifySignatureAsync = function(data) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the CmsSignerInfo class.
 */
Windows.Security.Cryptography.Certificates.CmsSignerInfo = function() {};
 /** @type {!Windows.Security.Cryptography.Certificates.Certificate} */
Windows.Security.Cryptography.Certificates.CmsSignerInfo.prototype.certificate;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.CmsSignerInfo.prototype.hashAlgorithmName;
 /** @type {!Windows.Security.Cryptography.Certificates.CmsTimestampInfo} */
Windows.Security.Cryptography.Certificates.CmsSignerInfo.prototype.timestampInfo;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Certificates.CmsTimestampInfo = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Cryptography.Certificates.Certificate>} */
Windows.Security.Cryptography.Certificates.CmsTimestampInfo.prototype.certificates;
 /** @type {!Windows.Security.Cryptography.Certificates.Certificate} */
Windows.Security.Cryptography.Certificates.CmsTimestampInfo.prototype.signingCertificate;
 /** @type {!Date} */
Windows.Security.Cryptography.Certificates.CmsTimestampInfo.prototype.timestamp;

/** @const */
Windows.Security.Cryptography.Certificates.EnrollKeyUsages = {};
/** @const {number} */
Windows.Security.Cryptography.Certificates.EnrollKeyUsages.none;
/** @const {number} */
Windows.Security.Cryptography.Certificates.EnrollKeyUsages.decryption;
/** @const {number} */
Windows.Security.Cryptography.Certificates.EnrollKeyUsages.signing;
/** @const {number} */
Windows.Security.Cryptography.Certificates.EnrollKeyUsages.keyAgreement;
/** @const {number} */
Windows.Security.Cryptography.Certificates.EnrollKeyUsages.all;

/** @const */
Windows.Security.Cryptography.Certificates.ExportOption = {};
/** @const {number} */
Windows.Security.Cryptography.Certificates.ExportOption.notExportable;
/** @const {number} */
Windows.Security.Cryptography.Certificates.ExportOption.exportable;

/** @const */
Windows.Security.Cryptography.Certificates.InstallOptions = {};
/** @const {number} */
Windows.Security.Cryptography.Certificates.InstallOptions.none;
/** @const {number} */
Windows.Security.Cryptography.Certificates.InstallOptions.deleteExpired;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Certificates.KeyAlgorithmNames = function() {};
 /** @type {string} */
Windows.Security.Cryptography.Certificates.KeyAlgorithmNames.dsa;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.KeyAlgorithmNames.ecdh;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.KeyAlgorithmNames.ecdh256;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.KeyAlgorithmNames.ecdh384;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.KeyAlgorithmNames.ecdh521;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.KeyAlgorithmNames.ecdsa;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.KeyAlgorithmNames.ecdsa256;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.KeyAlgorithmNames.ecdsa384;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.KeyAlgorithmNames.ecdsa521;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.KeyAlgorithmNames.rsa;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Certificates.KeyAttestationHelper = function() {};

/**
 * Decrypts a TPM key attestation credential.
 * Decrypts a TPM key attestation credential.
 * @param {string} credential The TPM key attestation credential to decrypt.
 * @param {string=} containerName The container name of the credential.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} When this method completes, it returns the decrypted TPM key attestation credential.
 */
Windows.Security.Cryptography.Certificates.KeyAttestationHelper.decryptTpmAttestationCredentialAsync = function(credential, containerName) {};

/**
 * Gets the credential ID from a TPM key attestation credential.
 * @param {string} credential The TPM key attestation credential to get the credential ID from.
 * @return {string} The credential ID from the TPM key attestation credential.
 */
Windows.Security.Cryptography.Certificates.KeyAttestationHelper.getTpmAttestationCredentialId = function(credential) {};

/** @const */
Windows.Security.Cryptography.Certificates.KeyProtectionLevel = {};
/** @const {number} */
Windows.Security.Cryptography.Certificates.KeyProtectionLevel.noConsent;
/** @const {number} */
Windows.Security.Cryptography.Certificates.KeyProtectionLevel.consentOnly;
/** @const {number} */
Windows.Security.Cryptography.Certificates.KeyProtectionLevel.consentWithPassword;
/** @const {number} */
Windows.Security.Cryptography.Certificates.KeyProtectionLevel.consentWithFingerprint;

/** @const */
Windows.Security.Cryptography.Certificates.KeySize = {};
/** @const {number} */
Windows.Security.Cryptography.Certificates.KeySize.invalid;
/** @const {number} */
Windows.Security.Cryptography.Certificates.KeySize.rsa2048;
/** @const {number} */
Windows.Security.Cryptography.Certificates.KeySize.rsa4096;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Certificates.KeyStorageProviderNames = function() {};
 /** @type {string} */
Windows.Security.Cryptography.Certificates.KeyStorageProviderNames.passportKeyStorageProvider;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.KeyStorageProviderNames.platformKeyStorageProvider;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.KeyStorageProviderNames.smartcardKeyStorageProvider;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.KeyStorageProviderNames.softwareKeyStorageProvider;

/**
 * @constructor
 * @struct
 * Creates a new instance of the PfxImportParameters class.
 */
Windows.Security.Cryptography.Certificates.PfxImportParameters = function() {};
 /** @type {string} */
Windows.Security.Cryptography.Certificates.PfxImportParameters.prototype.containerNamePrefix;
 /** @type {Windows.Security.Cryptography.Certificates.ExportOption} */
Windows.Security.Cryptography.Certificates.PfxImportParameters.prototype.exportable;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.PfxImportParameters.prototype.friendlyName;
 /** @type {Windows.Security.Cryptography.Certificates.InstallOptions} */
Windows.Security.Cryptography.Certificates.PfxImportParameters.prototype.installOptions;
 /** @type {Windows.Security.Cryptography.Certificates.KeyProtectionLevel} */
Windows.Security.Cryptography.Certificates.PfxImportParameters.prototype.keyProtectionLevel;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.PfxImportParameters.prototype.keyStorageProviderName;
 /** @type {string} */
Windows.Security.Cryptography.Certificates.PfxImportParameters.prototype.readerName;

/** @const */
Windows.Security.Cryptography.Certificates.SignatureValidationResult = {};
/** @const {number} */
Windows.Security.Cryptography.Certificates.SignatureValidationResult.success;
/** @const {number} */
Windows.Security.Cryptography.Certificates.SignatureValidationResult.invalidParameter;
/** @const {number} */
Windows.Security.Cryptography.Certificates.SignatureValidationResult.badMessage;
/** @const {number} */
Windows.Security.Cryptography.Certificates.SignatureValidationResult.invalidSignature;
/** @const {number} */
Windows.Security.Cryptography.Certificates.SignatureValidationResult.otherErrors;

/**
 * @constructor
 * @struct
 * Creates a new instance of the SubjectAlternativeNameInfo class.
 */
Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo.prototype.distinguishedName;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo.prototype.dnsName;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo.prototype.emailName;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo.prototype.ipAddress;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo.prototype.principalName;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo.prototype.url;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager = function() {};

/**
 * Asynchronously creates a PKCS #10 certificate request based on properties specified in a CertificateRequestProperties object.
 * @param {!Windows.Security.Cryptography.Certificates.CertificateRequestProperties} request A CertificateRequestProperties object that contains the property values used to create the certificate request.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} An asynchronous operation to retrieve the base64 encoded PKCS #10 certificate request.
 */
Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager.prototype.createRequestAsync = function(request) {};

/**
 * Asynchronously imports a user certificate from a Personal Information Exchange (PFX) message.
 * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message using the specified key storage provider.
 * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message using the specified import parameters.
 * @param {string} pfxData Base64-encoded PFX message.
 * @param {string} password The password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet. / he password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet.
 * @param {Windows.Security.Cryptography.Certificates.ExportOption|!Windows.Security.Cryptography.Certificates.PfxImportParameters} exportable_or_pfxImportParameters A value of the ExportOption enumeration that specifies whether the key can be exported. / The import parameters.
 * @param {Windows.Security.Cryptography.Certificates.KeyProtectionLevel=} keyProtectionLevel A value of the KeyProtectionLevel enumeration that specifies the strength of the key protection. The default is NoConsent.
 * @param {Windows.Security.Cryptography.Certificates.InstallOptions=} installOption An InstallOptions enumeration value that specifies the certificate installation option.
 * @param {string=} friendlyName The display name of the enrolled certificate. This value overwrites the FriendlyName property inside the PFX message.
 * @param {string=} keyStorageProvider The name of the key storage provider to use when importing the certificate.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager.prototype.importPfxDataAsync = function(pfxData, password, exportable_or_pfxImportParameters, keyProtectionLevel, installOption, friendlyName, keyStorageProvider) {};

/**
 * Asynchronously installs a certificate chain into the app container on the local computer.
 * @param {string} certificate The encoded certificate. The certificate is encoded by using Distinguished Encoding Rules (DER) as defined by the Abstract Syntax Notation One (ASN.1) standard.
 * @param {Windows.Security.Cryptography.Certificates.InstallOptions} installOption An InstallOptions enumeration value that specifies the certificate installation option.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} This method does not return a value.
 */
Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager.prototype.installCertificateAsync = function(certificate, installOption) {};
/** @const */
Windows.Security.Cryptography.Core = {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames = function() {};
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.dsaSha1;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.dsaSha256;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.ecdsaP256Sha256;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.ecdsaP384Sha384;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.ecdsaP521Sha512;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.ecdsaSha256;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.ecdsaSha384;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.ecdsaSha512;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.rsaOaepSha1;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.rsaOaepSha256;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.rsaOaepSha384;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.rsaOaepSha512;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.rsaPkcs1;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.rsaSignPkcs1Sha1;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.rsaSignPkcs1Sha256;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.rsaSignPkcs1Sha384;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.rsaSignPkcs1Sha512;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.rsaSignPssSha1;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.rsaSignPssSha256;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.rsaSignPssSha384;
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames.rsaSignPssSha512;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider = function() {};
 /** @type {string} */
Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider.prototype.algorithmName;

/**
 * Creates an instance of the AsymmetricKeyAlgorithmProvider class and opens the specified algorithm for use.
 * @param {string} algorithm Algorithm name.
 * @return {!Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider} Represents a public key algorithm provider.
 */
Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider.openAlgorithm = function(algorithm) {};

/**
 * Creates a public/private key pair.
 * @param {number} keySize Size, in bits, of the key. Typical key sizes are 512, 1024, 2048, or 4096 bits.
 * @return {!Windows.Security.Cryptography.Core.CryptographicKey} Represents the asymmetric key pair.
 */
Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider.prototype.createKeyPair = function(keySize) {};

/**
 * Creates a public/private key pair using a curve name.
 * @param {string} curveName The name of the curve.
 * @return {!Windows.Security.Cryptography.Core.CryptographicKey} Represents the asymmetric key pair.
 */
Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider.prototype.createKeyPairWithCurveName = function(curveName) {};

/**
 * Creates a public/private key pair using curve parameters.
 * @param {!Array<number>} parameters The curve parameters.
 * @return {!Windows.Security.Cryptography.Core.CryptographicKey} Represents the asymmetric key pair.
 */
Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider.prototype.createKeyPairWithCurveParameters = function(parameters) {};

/**
 * Imports a public/private key pair from a buffer.
 * Imports a public/private key pair from a buffer in the specified format.
 * @param {!Windows.Storage.Streams.IBuffer} keyBlob Buffer that contains the key pair to import.
 * @param {Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType=} BlobType A CryptographicPrivateKeyBlobType enumeration value that specifies information about the private key contained in the keyBlob buffer. The default value is Pkcs8RawPrivateKeyInfo.
 * @return {!Windows.Security.Cryptography.Core.CryptographicKey} Represents the imported key pair.
 */
Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider.prototype.importKeyPair = function(keyBlob, BlobType) {};

/**
 * Imports a public key into a buffer.
 * Imports a public key into a buffer for a specified format.
 * @param {!Windows.Storage.Streams.IBuffer} keyBlob Buffer that contains the key to import.
 * @param {Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType=} BlobType A CryptographicPublicKeyBlobType enumeration value that specifies the format of the public key contained in the keyBlob buffer. The default value is X509SubjectPublicKeyInfo.
 * @return {!Windows.Security.Cryptography.Core.CryptographicKey} Represents the imported key.
 */
Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider.prototype.importPublicKey = function(keyBlob, BlobType) {};

/** @const */
Windows.Security.Cryptography.Core.Capi1KdfTargetAlgorithm = {};
/** @const {number} */
Windows.Security.Cryptography.Core.Capi1KdfTargetAlgorithm.notAes;
/** @const {number} */
Windows.Security.Cryptography.Core.Capi1KdfTargetAlgorithm.aes;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.CryptographicEngine = function() {};

/**
 * Decrypts content that was previously encrypted by using a symmetric or asymmetric algorithm.
 * @param {!Windows.Security.Cryptography.Core.CryptographicKey} key Cryptographic key to use for decryption. This can be an asymmetric or a symmetric key. For more information, see AsymmetricKeyAlgorithmProvider and SymmetricKeyAlgorithmProvider .
 * @param {!Windows.Storage.Streams.IBuffer} data Buffer that contains the encrypted data.
 * @param {!Windows.Storage.Streams.IBuffer} iv Buffer that contains the initialization vector. If an initialization vector (IV) was used to encrypt the data, you must use the same IV to decrypt the data. For more information, see Encrypt .
 * @return {!Windows.Storage.Streams.IBuffer} Decrypted data.
 */
Windows.Security.Cryptography.Core.CryptographicEngine.decrypt = function(key, data, iv) {};

/**
 * Decrypts and authenticates data. For more information and a complete code sample, see EncryptedAndAuthenticatedData .
 * @param {!Windows.Security.Cryptography.Core.CryptographicKey} key Symmetric key to use.
 * @param {!Windows.Storage.Streams.IBuffer} data Data to be decrypted and authenticated.
 * @param {!Windows.Storage.Streams.IBuffer} nonce Nonce to be used. This must be the same nonce used by the EncryptAndAuthenticate method.
 * @param {!Windows.Storage.Streams.IBuffer} authenticationTag Authentication tag.
 * @param {!Windows.Storage.Streams.IBuffer} authenticatedData Authenticated data. This can be Null.
 * @return {!Windows.Storage.Streams.IBuffer} A buffer that contains the decrypted data.
 */
Windows.Security.Cryptography.Core.CryptographicEngine.decryptAndAuthenticate = function(key, data, nonce, authenticationTag, authenticatedData) {};

/**
 * Decrypts the encrypted input data using the supplied key.
 * @param {!Windows.Security.Cryptography.Core.CryptographicKey} key The key to use to decrypt the encrypted input data.
 * @param {!Windows.Storage.Streams.IBuffer} data The encrypted data to decrypt.
 * @param {!Windows.Storage.Streams.IBuffer} iv The initial vector for a symmetric key. For an asymmetric key, set this value to null.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} The decrypted data.
 */
Windows.Security.Cryptography.Core.CryptographicEngine.decryptAsync = function(key, data, iv) {};

/**
 * Derives a key from another key by using a key derivation function. For more information, see the KeyDerivationAlgorithmProvider and KeyDerivationParameters classes.
 * @param {!Windows.Security.Cryptography.Core.CryptographicKey} key The symmetric or secret key used for derivation.
 * @param {!Windows.Security.Cryptography.Core.KeyDerivationParameters} parameters Derivation parameters. The parameters vary depending on the type of KDF algorithm used.
 * @param {number} desiredKeySize Requested size, in bytes, of the derived key.
 * @return {!Windows.Storage.Streams.IBuffer} Buffer that contains the derived key.
 */
Windows.Security.Cryptography.Core.CryptographicEngine.deriveKeyMaterial = function(key, parameters, desiredKeySize) {};

/**
 * Encrypts data by using a symmetric or asymmetric algorithm.
 * @param {!Windows.Security.Cryptography.Core.CryptographicKey} key Cryptographic key to use for encryption. This can be an asymmetric or a symmetric key. For more information, see AsymmetricKeyAlgorithmProvider and SymmetricKeyAlgorithmProvider .
 * @param {!Windows.Storage.Streams.IBuffer} data Data to encrypt.
 * @param {!Windows.Storage.Streams.IBuffer} iv Buffer that contains the initialization vector. This can be null for a symmetric algorithm and should always be null for an asymmetric algorithm. If an initialization vector (IV) was used to encrypt the data, you must use the same IV to decrypt the data. You can use the GenerateRandom method to create an IV that contains random data. Other IVs, such as nonce-generated vectors, require custom implementation. For more information, see Cryptographic keys.
 * @return {!Windows.Storage.Streams.IBuffer} Encrypted data.
 */
Windows.Security.Cryptography.Core.CryptographicEngine.encrypt = function(key, data, iv) {};

/**
 * Performs authenticated encryption.
 * @param {!Windows.Security.Cryptography.Core.CryptographicKey} key Symmetric key to use for encryption.
 * @param {!Windows.Storage.Streams.IBuffer} data Data to be encrypted and authenticated.
 * @param {!Windows.Storage.Streams.IBuffer} nonce Nonce to be used. A nonce is a variable that has minimal chance of repeating. For example, you can use a random value that is newly generated for each use, a time stamp, a sequence number, or some combination of these. The Microsoft GCM implementation requires a 12-byte nonce. The CCM implementation requires a 7- to 13- byte nonce.
 * @param {!Windows.Storage.Streams.IBuffer} authenticatedData Authenticated data. This can be Null.
 * @return {!Windows.Security.Cryptography.Core.EncryptedAndAuthenticatedData} The encrypted and authenticated data.
 */
Windows.Security.Cryptography.Core.CryptographicEngine.encryptAndAuthenticate = function(key, data, nonce, authenticatedData) {};

/**
 * Signs digital content. For more information, see MACs, hashes, and signatures.
 * @param {!Windows.Security.Cryptography.Core.CryptographicKey} key Key used for signing.
 * @param {!Windows.Storage.Streams.IBuffer} data Data to be signed.
 * @return {!Windows.Storage.Streams.IBuffer} The data's signature.
 */
Windows.Security.Cryptography.Core.CryptographicEngine.sign = function(key, data) {};

/**
 * Computes a hash for the supplied input data, and then signs the computed hash using the specified key.
 * @param {!Windows.Security.Cryptography.Core.CryptographicKey} key The key to use to compute and sign the hash.
 * @param {!Windows.Storage.Streams.IBuffer} data The raw input data to sign. The data is not hashed.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} An asynchronous operation to retrieve the hashed and signed data.
 */
Windows.Security.Cryptography.Core.CryptographicEngine.signAsync = function(key, data) {};

/**
 * Signs the hashed input data using the specified key.
 * @param {!Windows.Security.Cryptography.Core.CryptographicKey} key The key to use to sign the hash. This key must be an asymmetric key obtained from a PersistedKeyProvider or AsymmetricKeyAlgorithmProvider .
 * @param {!Windows.Storage.Streams.IBuffer} data The input data to sign. The data is a hashed value which can be obtained through incremental hash.
 * @return {!Windows.Storage.Streams.IBuffer} The signed data.
 */
Windows.Security.Cryptography.Core.CryptographicEngine.signHashedData = function(key, data) {};

/**
 * Signs the hashed input data using the specified key.
 * @param {!Windows.Security.Cryptography.Core.CryptographicKey} key The key to use to sign the hash. This key must be an asymmetric key obtained from a PersistedKeyProvider or AsymmetricKeyAlgorithmProvider .
 * @param {!Windows.Storage.Streams.IBuffer} data The input data to sign. The data is a hashed value which can be obtained through incremental hash.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} An asynchronous operation to retrieve the signed data.
 */
Windows.Security.Cryptography.Core.CryptographicEngine.signHashedDataAsync = function(key, data) {};

/**
 * Verifies a message signature.
 * @param {!Windows.Security.Cryptography.Core.CryptographicKey} key Key used for verification. This must be the same key previously used to sign the message.
 * @param {!Windows.Storage.Streams.IBuffer} data Message to be verified.
 * @param {!Windows.Storage.Streams.IBuffer} signature Signature previously computed over the message to be verified.
 * @return {boolean} true if the message is verified.
 */
Windows.Security.Cryptography.Core.CryptographicEngine.verifySignature = function(key, data, signature) {};

/**
 * Verifies the signature of the specified input data against a known signature.
 * @param {!Windows.Security.Cryptography.Core.CryptographicKey} key The key to use to retrieve the signature from the input data. This key must be an asymmetric key obtained from a PersistedKeyProvider or AsymmetricKeyAlgorithmProvider .
 * @param {!Windows.Storage.Streams.IBuffer} data The data to be verified. The data is a hashed value of raw data.
 * @param {!Windows.Storage.Streams.IBuffer} signature The known signature to use to verify the signature of the input data.
 * @return {boolean} True if the signature is verified; otherwise false.
 */
Windows.Security.Cryptography.Core.CryptographicEngine.verifySignatureWithHashInput = function(key, data, signature) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.CryptographicHash = function() {};

/**
 * Appends a binary encoded string to the data stored in the CryptographicHash object.
 * @param {!Windows.Storage.Streams.IBuffer} data Data to append.
 * @return {void}
 */
Windows.Security.Cryptography.Core.CryptographicHash.prototype.append = function(data) {};

/**
 * Gets hashed data from the CryptographicHash object and resets the object.
 * @return {!Windows.Storage.Streams.IBuffer} Hashed data.
 */
Windows.Security.Cryptography.Core.CryptographicHash.prototype.getValueAndReset = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.CryptographicKey = function() {};
 /** @type {number} */
Windows.Security.Cryptography.Core.CryptographicKey.prototype.keySize;

/**
 * Exports the key pair to a buffer.
 * Exports the key pair to a buffer given a specified format.
 * @param {Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType=} BlobType A CryptographicPrivateKeyBlobType enumeration value that specifies the format of the key in the buffer. The default value is Pkcs8RawPrivateKeyInfo.
 * @return {!Windows.Storage.Streams.IBuffer} Buffer that contains the key pair.
 */
Windows.Security.Cryptography.Core.CryptographicKey.prototype.export = function(BlobType) {};

/**
 * Exports a public key to a buffer.
 * Exports a public key to a buffer given a specified format.
 * @param {Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType=} BlobType A CryptographicPublicKeyBlobType enumeration value that specifies the format of the key in the buffer. The default value is X509SubjectPublicKeyInfo.
 * @return {!Windows.Storage.Streams.IBuffer} Buffer that contains the public key.
 */
Windows.Security.Cryptography.Core.CryptographicKey.prototype.exportPublicKey = function(BlobType) {};

/** @const */
Windows.Security.Cryptography.Core.CryptographicPadding = {};
/** @const {number} */
Windows.Security.Cryptography.Core.CryptographicPadding.none;
/** @const {number} */
Windows.Security.Cryptography.Core.CryptographicPadding.rsaOaep;
/** @const {number} */
Windows.Security.Cryptography.Core.CryptographicPadding.rsaPkcs1V15;
/** @const {number} */
Windows.Security.Cryptography.Core.CryptographicPadding.rsaPss;

/** @const */
Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType = {};
/** @const {number} */
Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType.pkcs8RawPrivateKeyInfo;
/** @const {number} */
Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType.pkcs1RsaPrivateKey;
/** @const {number} */
Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType.bcryptPrivateKey;
/** @const {number} */
Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType.capi1PrivateKey;
/** @const {number} */
Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType.bcryptEccFullPrivateKey;

/** @const */
Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType = {};
/** @const {number} */
Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType.x509SubjectPublicKeyInfo;
/** @const {number} */
Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType.pkcs1RsaPublicKey;
/** @const {number} */
Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType.bcryptPublicKey;
/** @const {number} */
Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType.capi1PublicKey;
/** @const {number} */
Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType.bcryptEccFullPublicKey;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.EccCurveNames = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Security.Cryptography.Core.EccCurveNames.allEccCurveNames;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.brainpoolP160r1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.brainpoolP160t1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.brainpoolP192r1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.brainpoolP192t1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.brainpoolP224r1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.brainpoolP224t1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.brainpoolP256r1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.brainpoolP256t1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.brainpoolP320r1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.brainpoolP320t1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.brainpoolP384r1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.brainpoolP384t1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.brainpoolP512r1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.brainpoolP512t1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.curve25519;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.ec192wapi;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.nistP192;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.nistP224;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.nistP256;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.nistP384;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.nistP521;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.numsP256t1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.numsP384t1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.numsP512t1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.secP160k1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.secP160r1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.secP160r2;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.secP192k1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.secP192r1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.secP224k1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.secP224r1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.secP256k1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.secP256r1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.secP384r1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.secP521r1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.wtls12;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.wtls7;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.wtls9;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.x962P192v1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.x962P192v2;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.x962P192v3;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.x962P239v1;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.x962P239v2;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.x962P239v3;
 /** @type {string} */
Windows.Security.Cryptography.Core.EccCurveNames.x962P256v1;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.EncryptedAndAuthenticatedData = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Security.Cryptography.Core.EncryptedAndAuthenticatedData.prototype.authenticationTag;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Security.Cryptography.Core.EncryptedAndAuthenticatedData.prototype.encryptedData;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.HashAlgorithmNames = function() {};
 /** @type {string} */
Windows.Security.Cryptography.Core.HashAlgorithmNames.md5;
 /** @type {string} */
Windows.Security.Cryptography.Core.HashAlgorithmNames.sha1;
 /** @type {string} */
Windows.Security.Cryptography.Core.HashAlgorithmNames.sha256;
 /** @type {string} */
Windows.Security.Cryptography.Core.HashAlgorithmNames.sha384;
 /** @type {string} */
Windows.Security.Cryptography.Core.HashAlgorithmNames.sha512;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.HashAlgorithmProvider = function() {};
 /** @type {string} */
Windows.Security.Cryptography.Core.HashAlgorithmProvider.prototype.algorithmName;
 /** @type {number} */
Windows.Security.Cryptography.Core.HashAlgorithmProvider.prototype.hashLength;

/**
 * Creates a HashAlgorithmProvider object and opens the specified algorithm for use.
 * @param {string} algorithm Algorithm name.
 * @return {!Windows.Security.Cryptography.Core.HashAlgorithmProvider} Represents a provider that implements hash algorithms.
 */
Windows.Security.Cryptography.Core.HashAlgorithmProvider.openAlgorithm = function(algorithm) {};

/**
 * Creates a reusable CryptographicHash object.
 * @return {!Windows.Security.Cryptography.Core.CryptographicHash} Reusable hash object.
 */
Windows.Security.Cryptography.Core.HashAlgorithmProvider.prototype.createHash = function() {};

/**
 * Hashes binary data.
 * @param {!Windows.Storage.Streams.IBuffer} data Data to be hashed.
 * @return {!Windows.Storage.Streams.IBuffer} Hashed data.
 */
Windows.Security.Cryptography.Core.HashAlgorithmProvider.prototype.hashData = function(data) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames = function() {};
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.capiKdfMd5;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.capiKdfSha1;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.capiKdfSha256;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.capiKdfSha384;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.capiKdfSha512;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.pbkdf2Md5;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.pbkdf2Sha1;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.pbkdf2Sha256;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.pbkdf2Sha384;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.pbkdf2Sha512;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.sp800108CtrHmacMd5;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.sp800108CtrHmacSha1;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.sp800108CtrHmacSha256;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.sp800108CtrHmacSha384;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.sp800108CtrHmacSha512;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.sp80056aConcatMd5;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.sp80056aConcatSha1;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.sp80056aConcatSha256;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.sp80056aConcatSha384;
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames.sp80056aConcatSha512;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider = function() {};
 /** @type {string} */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider.prototype.algorithmName;

/**
 * Creates an instance of the KeyDerivationAlgorithmProvider class and opens the specified algorithm for use.
 * @param {string} algorithm Represents a KDF algorithm provider.
 * @return {!Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider} The algorithm provider.
 */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider.openAlgorithm = function(algorithm) {};

/**
 * Creates a KDF key.
 * @param {!Windows.Storage.Streams.IBuffer} keyMaterial Data used to create the key.
 * @return {!Windows.Security.Cryptography.Core.CryptographicKey} Represents the KDF key.
 */
Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider.prototype.createKey = function(keyMaterial) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.KeyDerivationParameters = function() {};
 /** @type {Windows.Security.Cryptography.Core.Capi1KdfTargetAlgorithm} */
Windows.Security.Cryptography.Core.KeyDerivationParameters.prototype.capi1KdfTargetAlgorithm;
 /** @type {number} */
Windows.Security.Cryptography.Core.KeyDerivationParameters.prototype.iterationCount;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Security.Cryptography.Core.KeyDerivationParameters.prototype.kdfGenericBinary;

/**
 * Creates a KeyDerivationParameters object for use in the target algorithm.
 * @param {Windows.Security.Cryptography.Core.Capi1KdfTargetAlgorithm} capi1KdfTargetAlgorithm The target algorithm.
 * @return {!Windows.Security.Cryptography.Core.KeyDerivationParameters} Refers to the parameters used during key derivation.
 */
Windows.Security.Cryptography.Core.KeyDerivationParameters.buildForCapi1Kdf = function(capi1KdfTargetAlgorithm) {};

/**
 * Creates a KeyDerivationParameters object for use in the password-based key derivation function 2 (PBKDF2).
 * @param {!Windows.Storage.Streams.IBuffer} pbkdf2Salt The salt, a random or pseudorandom value to be combined with the password in multiple iterations. A salt is used to increase entropy above what can be obtained from using a password alone.
 * @param {number} iterationCount Number of iterations to be used to derive a key.
 * @return {!Windows.Security.Cryptography.Core.KeyDerivationParameters} Refers to the parameters used during key derivation.
 */
Windows.Security.Cryptography.Core.KeyDerivationParameters.buildForPbkdf2 = function(pbkdf2Salt, iterationCount) {};

/**
 * Creates a KeyDerivationParameters object for use in a counter mode, hash-based message authentication code (HMAC) key derivation function.
 * @param {!Windows.Storage.Streams.IBuffer} label Buffer that specifies the purpose for the derived keying material.
 * @param {!Windows.Storage.Streams.IBuffer} context Buffer that specifies information related to the derived keying material. For example, the context can identify the parties who are deriving the keying material and, optionally, a nonce known by the parties.
 * @return {!Windows.Security.Cryptography.Core.KeyDerivationParameters} Refers to the parameters used during key derivation.
 */
Windows.Security.Cryptography.Core.KeyDerivationParameters.buildForSP800108 = function(label, context) {};

/**
 * Creates a KeyDerivationParameters object for use in the SP800-56A key derivation function.
 * @param {!Windows.Storage.Streams.IBuffer} algorithmId Specifies the intended purpose of the derived key.
 * @param {!Windows.Storage.Streams.IBuffer} partyUInfo Contains public information contributed by the initiator.
 * @param {!Windows.Storage.Streams.IBuffer} partyVInfo Contains public information contributed by the responder.
 * @param {!Windows.Storage.Streams.IBuffer} suppPubInfo Contains public information known to both initiator and responder.
 * @param {!Windows.Storage.Streams.IBuffer} suppPrivInfo Contains private information known to both initiator and responder, such as a shared secret.
 * @return {!Windows.Security.Cryptography.Core.KeyDerivationParameters} Refers to the parameters used during key derivation.
 */
Windows.Security.Cryptography.Core.KeyDerivationParameters.buildForSP80056a = function(algorithmId, partyUInfo, partyVInfo, suppPubInfo, suppPrivInfo) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.MacAlgorithmNames = function() {};
 /** @type {string} */
Windows.Security.Cryptography.Core.MacAlgorithmNames.aesCmac;
 /** @type {string} */
Windows.Security.Cryptography.Core.MacAlgorithmNames.hmacMd5;
 /** @type {string} */
Windows.Security.Cryptography.Core.MacAlgorithmNames.hmacSha1;
 /** @type {string} */
Windows.Security.Cryptography.Core.MacAlgorithmNames.hmacSha256;
 /** @type {string} */
Windows.Security.Cryptography.Core.MacAlgorithmNames.hmacSha384;
 /** @type {string} */
Windows.Security.Cryptography.Core.MacAlgorithmNames.hmacSha512;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.MacAlgorithmProvider = function() {};
 /** @type {string} */
Windows.Security.Cryptography.Core.MacAlgorithmProvider.prototype.algorithmName;
 /** @type {number} */
Windows.Security.Cryptography.Core.MacAlgorithmProvider.prototype.macLength;

/**
 * Creates a MacAlgorithmProvider object and opens the specified algorithm for use.
 * @param {string} algorithm Algorithm name.
 * @return {!Windows.Security.Cryptography.Core.MacAlgorithmProvider} Represents a provider that implements MAC algorithms.
 */
Windows.Security.Cryptography.Core.MacAlgorithmProvider.openAlgorithm = function(algorithm) {};

/**
 * Creates a CryptographicHash object that supports incremental hash operations.
 * @param {!Windows.Storage.Streams.IBuffer} keyMaterial Random data used to help generate the hash. You can call the GenerateRandom method to create the random data.
 * @return {!Windows.Security.Cryptography.Core.CryptographicHash} A CryptographicHash object that supports incremental hash operations.
 */
Windows.Security.Cryptography.Core.MacAlgorithmProvider.prototype.createHash = function(keyMaterial) {};

/**
 * Creates a symmetric key that can be used to create the MAC value.
 * @param {!Windows.Storage.Streams.IBuffer} keyMaterial Random data used to help generate the key. You can call the GenerateRandom method to create the random data.
 * @return {!Windows.Security.Cryptography.Core.CryptographicKey} Symmetric key.
 */
Windows.Security.Cryptography.Core.MacAlgorithmProvider.prototype.createKey = function(keyMaterial) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.PersistedKeyProvider = function() {};

/**
 * Opens the persisted private key from the specified Certificate object.
 * @param {!Windows.Security.Cryptography.Certificates.Certificate} certificate The certificate that is associated with the private key.
 * @param {string} hashAlgorithmName The hash algorithm for signature operations. For encryption, the hash algorithm is ignored.
 * @param {Windows.Security.Cryptography.Core.CryptographicPadding} padding The padding mode for asymmetric algorithm signature or encryption operations.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.Cryptography.Core.CryptographicKey, !Windows.Foundation.IAsyncOperation<!Windows.Security.Cryptography.Core.CryptographicKey>>} An asynchronous operation for retrieving a private key from the supplied Certificate object.
 */
Windows.Security.Cryptography.Core.PersistedKeyProvider.openKeyPairFromCertificateAsync = function(certificate, hashAlgorithmName, padding) {};

/**
 * Opens the persisted public key from the specified Certificate object.
 * @param {!Windows.Security.Cryptography.Certificates.Certificate} certificate The certificate that contains the public key.
 * @param {string} hashAlgorithmName The has algorithm for signature operations.
 * @param {Windows.Security.Cryptography.Core.CryptographicPadding} padding The padding mode for asymmetric algorithm signature or encryption operations.
 * @return {!Windows.Security.Cryptography.Core.CryptographicKey} The public key retrieved from the supplied Certificate object.
 */
Windows.Security.Cryptography.Core.PersistedKeyProvider.openPublicKeyFromCertificate = function(certificate, hashAlgorithmName, padding) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames = function() {};
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.aesCbc;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.aesCbcPkcs7;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.aesCcm;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.aesEcb;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.aesEcbPkcs7;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.aesGcm;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.desCbc;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.desCbcPkcs7;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.desEcb;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.desEcbPkcs7;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.rc2Cbc;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.rc2CbcPkcs7;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.rc2Ecb;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.rc2EcbPkcs7;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.rc4;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.tripleDesCbc;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.tripleDesCbcPkcs7;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.tripleDesEcb;
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricAlgorithmNames.tripleDesEcbPkcs7;
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider = function() {};
 /** @type {string} */
Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider.prototype.algorithmName;
 /** @type {number} */
Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider.prototype.blockLength;

/**
 * Creates an instance of the SymmetricKeyAlgorithmProvider class and opens the specified algorithm for use.
 * @param {string} algorithm Algorithm name.
 * @return {!Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider} Represents a symmetric key algorithm provider.
 */
Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider.openAlgorithm = function(algorithm) {};

/**
 * Creates a symmetric key.
 * @param {!Windows.Storage.Streams.IBuffer} keyMaterial Data used to generate the key. You can call the GenerateRandom method to create random key material.
 * @return {!Windows.Security.Cryptography.Core.CryptographicKey} Symmetric key.
 */
Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider.prototype.createSymmetricKey = function(keyMaterial) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.Cryptography.CryptographicBuffer = function() {};

/**
 * Compares two IBuffer objects.
 * @param {!Windows.Storage.Streams.IBuffer} object1 Buffer to be used for comparison.
 * @param {!Windows.Storage.Streams.IBuffer} object2 Buffer to be used for comparison.
 * @return {boolean} True specifies that the buffers are equal. Two buffers are equal if each code point in one matches the corresponding code point in the other.
 */
Windows.Security.Cryptography.CryptographicBuffer.compare = function(object1, object2) {};

/**
 * Converts a buffer to an encoded string.
 * @param {Windows.Security.Cryptography.BinaryStringEncoding} encoding Encoding format.
 * @param {!Windows.Storage.Streams.IBuffer} buffer Data to be encoded.
 * @return {string} A string that contains the encoded data.
 */
Windows.Security.Cryptography.CryptographicBuffer.convertBinaryToString = function(encoding, buffer) {};

/**
 * Converts a string to an encoded buffer.
 * @param {string} value String to be encoded.
 * @param {Windows.Security.Cryptography.BinaryStringEncoding} encoding Encoding format.
 * @return {!Windows.Storage.Streams.IBuffer} Encoded buffer.
 */
Windows.Security.Cryptography.CryptographicBuffer.convertStringToBinary = function(value, encoding) {};

/**
 * Copies a buffer to an array of bytes.
 * @param {!Windows.Storage.Streams.IBuffer} buffer Input buffer.
 * @return {!Array<number>} An array of bytes that contains the values copied from the input buffer. You must declare the array before calling this method and pass it by using the ref keyword. If the buffer for the input parameter is empty, then the value parameter will be returned as NULL.
 */
Windows.Security.Cryptography.CryptographicBuffer.copyToByteArray = function(buffer) {};

/**
 * Creates a buffer from an input byte array.
 * @param {!Array<number>} value An array of bytes used to create the buffer.
 * @return {!Windows.Storage.Streams.IBuffer} Output buffer.
 */
Windows.Security.Cryptography.CryptographicBuffer.createFromByteArray = function(value) {};

/**
 * Decodes a string that has been base64 encoded.
 * @param {string} value Base64 encoded input string.
 * @return {!Windows.Storage.Streams.IBuffer} Output buffer that contains the decoded string.
 */
Windows.Security.Cryptography.CryptographicBuffer.decodeFromBase64String = function(value) {};

/**
 * Decodes a string that has been hexadecimal encoded.
 * @param {string} value Encoded input string.
 * @return {!Windows.Storage.Streams.IBuffer} Output buffer that contains the decoded string.
 */
Windows.Security.Cryptography.CryptographicBuffer.decodeFromHexString = function(value) {};

/**
 * Encodes a buffer to a base64 string.
 * @param {!Windows.Storage.Streams.IBuffer} buffer Input buffer.
 * @return {string} Base64-encoded output string.
 */
Windows.Security.Cryptography.CryptographicBuffer.encodeToBase64String = function(buffer) {};

/**
 * Encodes a buffer to a hexadecimal string.
 * @param {!Windows.Storage.Streams.IBuffer} buffer Input buffer.
 * @return {string} Hexadecimal encoded output string.
 */
Windows.Security.Cryptography.CryptographicBuffer.encodeToHexString = function(buffer) {};

/**
 * Creates a buffer that contains random data.
 * @param {number} length Length, in bytes, of the buffer to create.
 * @return {!Windows.Storage.Streams.IBuffer} Output buffer that contains the random data.
 */
Windows.Security.Cryptography.CryptographicBuffer.generateRandom = function(length) {};

/**
 * Creates a random number.
 * @return {number} Integer that contains the random data.
 */
Windows.Security.Cryptography.CryptographicBuffer.generateRandomNumber = function() {};
/** @const */
Windows.Security.Cryptography.DataProtection = {};

/**
 * @constructor
 * @struct
 * Constructor used for encryption operations. Use this constructor before calling the ProtectAsync or ProtectStreamAsync methods.
 * Constructor used for decryption operations. Use this constructor before calling the UnprotectAsync or UnprotectStreamAsync methods.
 * @param {string=} protectionDescriptor Contains the protection descriptor that determines the entity to which the data will be encrypted. For more information, see Remarks.
 */
Windows.Security.Cryptography.DataProtection.DataProtectionProvider = function(protectionDescriptor) {};

/**
 * Asynchronously protects static data.
 * @param {!Windows.Storage.Streams.IBuffer} data Data to protect.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} Represents an asynchronous operation.
 */
Windows.Security.Cryptography.DataProtection.DataProtectionProvider.prototype.protectAsync = function(data) {};

/**
 * Asynchronously protects a data stream.
 * @param {!Windows.Storage.Streams.IInputStream} src Stream to be protected.
 * @param {!Windows.Storage.Streams.IOutputStream} dest Protected stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Represents an asynchronous action.
 */
Windows.Security.Cryptography.DataProtection.DataProtectionProvider.prototype.protectStreamAsync = function(src, dest) {};

/**
 * Asynchronously decrypts static data.
 * @param {!Windows.Storage.Streams.IBuffer} data Data to decrypt.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} Represents an asynchronous operation.
 */
Windows.Security.Cryptography.DataProtection.DataProtectionProvider.prototype.unprotectAsync = function(data) {};

/**
 * Asynchronously decrypts a data stream.
 * @param {!Windows.Storage.Streams.IInputStream} src Stream to decrypt.
 * @param {!Windows.Storage.Streams.IOutputStream} dest Decrypted stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Represents an asynchronous action.
 */
Windows.Security.Cryptography.DataProtection.DataProtectionProvider.prototype.unprotectStreamAsync = function(src, dest) {};
/** @const */
Windows.Security.EnterpriseData = {};
/**
 * @constructor
 * @struct
 */
Windows.Security.EnterpriseData.BufferProtectUnprotectResult = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Security.EnterpriseData.BufferProtectUnprotectResult.prototype.buffer;
 /** @type {!Windows.Security.EnterpriseData.DataProtectionInfo} */
Windows.Security.EnterpriseData.BufferProtectUnprotectResult.prototype.protectionInfo;
/**
 * @constructor
 * @struct
 */
Windows.Security.EnterpriseData.DataProtectionInfo = function() {};
 /** @type {string} */
Windows.Security.EnterpriseData.DataProtectionInfo.prototype.identity;
 /** @type {Windows.Security.EnterpriseData.DataProtectionStatus} */
Windows.Security.EnterpriseData.DataProtectionInfo.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Security.EnterpriseData.DataProtectionManager = function() {};

/**
 * Get the status of an enterprise protected buffer.
 * @param {!Windows.Storage.Streams.IBuffer} protectedData The buffer for which protection status is being queried.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.EnterpriseData.DataProtectionInfo, !Windows.Foundation.IAsyncOperation<!Windows.Security.EnterpriseData.DataProtectionInfo>>} When the call to this method completes successfully, it returns a DataProtectionInfo object that contains the status of the buffer.
 */
Windows.Security.EnterpriseData.DataProtectionManager.getProtectionInfoAsync = function(protectedData) {};

/**
 * Get the status of an enterprise protected stream.
 * @param {!Windows.Storage.Streams.IInputStream} protectedStream The stream for which protection status is being queried.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.EnterpriseData.DataProtectionInfo, !Windows.Foundation.IAsyncOperation<!Windows.Security.EnterpriseData.DataProtectionInfo>>} When the call to this method completes successfully, it returns a DataProtectionInfo object that contains the status of the stream.
 */
Windows.Security.EnterpriseData.DataProtectionManager.getStreamProtectionInfoAsync = function(protectedStream) {};

/**
 * Protect the data in a buffer to an enterprise identity.
 * @param {!Windows.Storage.Streams.IBuffer} data The buffer to be protected.
 * @param {string} identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.EnterpriseData.BufferProtectUnprotectResult, !Windows.Foundation.IAsyncOperation<!Windows.Security.EnterpriseData.BufferProtectUnprotectResult>>} When the call to this method completes successfully, it returns a BufferProtectUnprotectResult object that contains the status of the newly protected buffer.
 */
Windows.Security.EnterpriseData.DataProtectionManager.protectAsync = function(data, identity) {};

/**
 * Protect a stream of data to an enterprise identity.
 * @param {!Windows.Storage.Streams.IInputStream} unprotectedStream The input, unprotected stream.
 * @param {string} identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @param {!Windows.Storage.Streams.IOutputStream} protectedStream The output, protected stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.EnterpriseData.DataProtectionInfo, !Windows.Foundation.IAsyncOperation<!Windows.Security.EnterpriseData.DataProtectionInfo>>} When the call to this method completes successfully, it returns a DataProtectionInfo object that contains the status of the protected stream.
 */
Windows.Security.EnterpriseData.DataProtectionManager.protectStreamAsync = function(unprotectedStream, identity, protectedStream) {};

/**
 * Removes the protection to an enterprise identity from a buffer.
 * @param {!Windows.Storage.Streams.IBuffer} data The buffer to be unprotected.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.EnterpriseData.BufferProtectUnprotectResult, !Windows.Foundation.IAsyncOperation<!Windows.Security.EnterpriseData.BufferProtectUnprotectResult>>} When the call to this method completes successfully, it returns a BufferProtectUnprotectResult object that contains the status of the unprotected buffer.
 */
Windows.Security.EnterpriseData.DataProtectionManager.unprotectAsync = function(data) {};

/**
 * Removes the protection to an enterprise identity from a stream of data.
 * @param {!Windows.Storage.Streams.IInputStream} protectedStream The input, protected stream.
 * @param {!Windows.Storage.Streams.IOutputStream} unprotectedStream The output, unprotected stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.EnterpriseData.DataProtectionInfo, !Windows.Foundation.IAsyncOperation<!Windows.Security.EnterpriseData.DataProtectionInfo>>} When the call to this method completes successfully, it returns a DataProtectionInfo object that contains the status of the unprotected stream.
 */
Windows.Security.EnterpriseData.DataProtectionManager.unprotectStreamAsync = function(protectedStream, unprotectedStream) {};

/** @const */
Windows.Security.EnterpriseData.DataProtectionStatus = {};
/** @const {number} */
Windows.Security.EnterpriseData.DataProtectionStatus.protectedToOtherIdentity;
/** @const {number} */
Windows.Security.EnterpriseData.DataProtectionStatus.protected;
/** @const {number} */
Windows.Security.EnterpriseData.DataProtectionStatus.revoked;
/** @const {number} */
Windows.Security.EnterpriseData.DataProtectionStatus.unprotected;
/** @const {number} */
Windows.Security.EnterpriseData.DataProtectionStatus.licenseExpired;
/** @const {number} */
Windows.Security.EnterpriseData.DataProtectionStatus.accessSuspended;

/** @const */
Windows.Security.EnterpriseData.EnforcementLevel = {};
/** @const {number} */
Windows.Security.EnterpriseData.EnforcementLevel.noProtection;
/** @const {number} */
Windows.Security.EnterpriseData.EnforcementLevel.silent;
/** @const {number} */
Windows.Security.EnterpriseData.EnforcementLevel.override;
/** @const {number} */
Windows.Security.EnterpriseData.EnforcementLevel.block;
/**
 * @constructor
 * @struct
 */
Windows.Security.EnterpriseData.FileProtectionInfo = function() {};
 /** @type {string} */
Windows.Security.EnterpriseData.FileProtectionInfo.prototype.identity;
 /** @type {boolean} */
Windows.Security.EnterpriseData.FileProtectionInfo.prototype.isRoamable;
 /** @type {Windows.Security.EnterpriseData.FileProtectionStatus} */
Windows.Security.EnterpriseData.FileProtectionInfo.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Security.EnterpriseData.FileProtectionManager = function() {};
 /** @type {?} */
Windows.Security.EnterpriseData.FileProtectionManager.isContainerAsync;

/**
 * Replicate the file protection of one file onto another file.
 * @param {!Windows.Storage.IStorageItem} source The source file, from which file protection is being copied.
 * @param {!Windows.Storage.IStorageItem} target The target file, to which file protection is being copied.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} When the call to this method completes successfully, it returns true if the file protection was copied, or false if there was an error.
 */
Windows.Security.EnterpriseData.FileProtectionManager.copyProtectionAsync = function(source, target) {};

/**
 * Create an enterprise-protected file.
 * @param {!Windows.Storage.IStorageFolder} parentFolder The folder into which to create the enterprise protected file.
 * @param {string} desiredName The desired name of the new enterprise protected file.
 * @param {string} identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @param {Windows.Storage.CreationCollisionOption} collisionOption A CreationCollisionOption value that specifies what to do if desiredName already exists.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.EnterpriseData.ProtectedFileCreateResult, !Windows.Foundation.IAsyncOperation<!Windows.Security.EnterpriseData.ProtectedFileCreateResult>>} When the call to this method completes successfully, it returns a ProtectedFileCreateResult object representing the newly created protected file.
 */
Windows.Security.EnterpriseData.FileProtectionManager.createProtectedAndOpenAsync = function(parentFolder, desiredName, identity, collisionOption) {};

/**
 * Get the status of an enterprise-protected file.
 * @param {!Windows.Storage.IStorageItem} source The file or folder for which protection status is being queried.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.EnterpriseData.FileProtectionInfo, !Windows.Foundation.IAsyncOperation<!Windows.Security.EnterpriseData.FileProtectionInfo>>} When the call to this method completes successfully, it returns a FileProtectionInfo object that contains the status of the file.
 */
Windows.Security.EnterpriseData.FileProtectionManager.getProtectionInfoAsync = function(source) {};

/**
 * Create an enterprise-protected file, and load it from a container file.
 * Create an enterprise-protected file in a specified storage item (such as a folder), and load it from a container file.
 * Create an enterprise-protected file in a specified storage item (such as a folder), and load it from a container file.
 * @param {!Windows.Storage.IStorageFile} containerFile The enterprise protected file to be created and loaded.
 * @param {!Windows.Storage.IStorageItem=} target The storage item into which to create the enterprise protected file.
 * @param {Windows.Storage.NameCollisionOption=} collisionOption The enum value that determines how Windows responds if the created file has the same name as an existing item in the container's location.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.EnterpriseData.ProtectedContainerImportResult, !Windows.Foundation.IAsyncOperation<!Windows.Security.EnterpriseData.ProtectedContainerImportResult>>} When the call to this method completes successfully, it returns a ProtectedContainerImportResult object representing the newly created protected file.
 */
Windows.Security.EnterpriseData.FileProtectionManager.loadFileFromContainerAsync = function(containerFile, target, collisionOption) {};

/**
 * Protect the data in a file to an enterprise identity. The app can then use standard APIs to read or write from the file.
 * @param {!Windows.Storage.IStorageItem} target The file to be protected.
 * @param {string} identity The enterprise identity. This is an email address or domain that is managed. Use ProtectionPolicyManager.IsIdentityManaged to confirm that an email address or domain is managed before using the identity to protect a file.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.EnterpriseData.FileProtectionInfo, !Windows.Foundation.IAsyncOperation<!Windows.Security.EnterpriseData.FileProtectionInfo>>} When the call to this method completes successfully, it returns a FileProtectionInfo object that contains the status of the newly protected file.
 */
Windows.Security.EnterpriseData.FileProtectionManager.protectAsync = function(target, identity) {};

/**
 * Save an enterprise-protected file as a containerized version.
 * Save an enterprise-protected file as a containerized version, and share it with a specified list of user identities.
 * @param {!Windows.Storage.IStorageFile} protectedFile The protected source file being copied.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} sharedWithIdentities A collection of strings representing the user identities to share the containerized file with. For example, email recipients.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.EnterpriseData.ProtectedContainerExportResult, !Windows.Foundation.IAsyncOperation<!Windows.Security.EnterpriseData.ProtectedContainerExportResult>>} When the call to this method completes successfully, it returns a ProtectedContainerExportResult object representing the newly created container file.
 */
Windows.Security.EnterpriseData.FileProtectionManager.saveFileAsContainerAsync = function(protectedFile, sharedWithIdentities) {};

/** @const */
Windows.Security.EnterpriseData.FileProtectionStatus = {};
/** @const {number} */
Windows.Security.EnterpriseData.FileProtectionStatus.undetermined;
/** @const {number} */
Windows.Security.EnterpriseData.FileProtectionStatus.unknown;
/** @const {number} */
Windows.Security.EnterpriseData.FileProtectionStatus.unprotected;
/** @const {number} */
Windows.Security.EnterpriseData.FileProtectionStatus.revoked;
/** @const {number} */
Windows.Security.EnterpriseData.FileProtectionStatus.protected;
/** @const {number} */
Windows.Security.EnterpriseData.FileProtectionStatus.protectedByOtherUser;
/** @const {number} */
Windows.Security.EnterpriseData.FileProtectionStatus.protectedToOtherEnterprise;
/** @const {number} */
Windows.Security.EnterpriseData.FileProtectionStatus.notProtectable;
/** @const {number} */
Windows.Security.EnterpriseData.FileProtectionStatus.protectedToOtherIdentity;
/** @const {number} */
Windows.Security.EnterpriseData.FileProtectionStatus.licenseExpired;
/** @const {number} */
Windows.Security.EnterpriseData.FileProtectionStatus.accessSuspended;
/**
 * @constructor
 * @struct
 */
Windows.Security.EnterpriseData.FileRevocationManager = function() {};

/**
 * Copy the selective wipe protection state of a file or folder to a new file or folder.
 * @param {!Windows.Storage.IStorageItem} sourceStorageItem The source item to copy the selective wipe protection status from.
 * @param {!Windows.Storage.IStorageItem} targetStorageItem The target item to copy the selective wipe protection status to.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} True if the copy operation was successful; otherwise false.
 */
Windows.Security.EnterpriseData.FileRevocationManager.copyProtectionAsync = function(sourceStorageItem, targetStorageItem) {};

/**
 * Gets the selective wipe protection status for a file or folder.
 * @param {!Windows.Storage.IStorageItem} storageItem The file or folder to get the selective wipe protection status for.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Security.EnterpriseData.FileProtectionStatus, !Windows.Foundation.IAsyncOperation<Windows.Security.EnterpriseData.FileProtectionStatus>>} An aysnchronous operation that retrieves the selective wipe protection status for the storageItem.
 */
Windows.Security.EnterpriseData.FileRevocationManager.getStatusAsync = function(storageItem) {};

/**
 * Protects a file or folder for selective wipe.
 * @param {!Windows.Storage.IStorageItem} storageItem The file or folder to protect for selective wipe.
 * @param {string} enterpriseIdentity The enterprise id that the file or folder is protected for. The enterpriseIdentity value must be formatted as an Internationalized Domain Name (IDN) and cannot contain spaces. For example, contoso.com.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Security.EnterpriseData.FileProtectionStatus, !Windows.Foundation.IAsyncOperation<Windows.Security.EnterpriseData.FileProtectionStatus>>} An asynchronous operation that retrieves the selective wipe protection status for the storageItem.
 */
Windows.Security.EnterpriseData.FileRevocationManager.protectAsync = function(storageItem, enterpriseIdentity) {};

/**
 * Revokes all files and folders protected for selective wipe for a specified enterprise id.
 * @param {string} enterpriseIdentity Revoke all files and folders protected by selective wipe for this enterprise id. The enterpriseIdentity value must be formatted as an Internationalized Domain Name (IDN) and cannot contain spaces. For example, contoso.com.
 * @return {void}
 */
Windows.Security.EnterpriseData.FileRevocationManager.revoke = function(enterpriseIdentity) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.EnterpriseData.ProtectedAccessResumedEventArgs = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Security.EnterpriseData.ProtectedAccessResumedEventArgs.prototype.identities;
/**
 * @constructor
 * @struct
 */
Windows.Security.EnterpriseData.ProtectedAccessSuspendingEventArgs = function() {};
 /** @type {!Date} */
Windows.Security.EnterpriseData.ProtectedAccessSuspendingEventArgs.prototype.deadline;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Security.EnterpriseData.ProtectedAccessSuspendingEventArgs.prototype.identities;

/**
 * Gets the Deferral object that manages the protection suspension. The app must call Deferral.Complete before it returns from the event handler.
 * @return {!Windows.Foundation.Deferral} The Deferral object.
 */
Windows.Security.EnterpriseData.ProtectedAccessSuspendingEventArgs.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Security.EnterpriseData.ProtectedContainerExportResult = function() {};
 /** @type {!Windows.Storage.StorageFile} */
Windows.Security.EnterpriseData.ProtectedContainerExportResult.prototype.file;
 /** @type {Windows.Security.EnterpriseData.ProtectedImportExportStatus} */
Windows.Security.EnterpriseData.ProtectedContainerExportResult.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Security.EnterpriseData.ProtectedContainerImportResult = function() {};
 /** @type {!Windows.Storage.StorageFile} */
Windows.Security.EnterpriseData.ProtectedContainerImportResult.prototype.file;
 /** @type {Windows.Security.EnterpriseData.ProtectedImportExportStatus} */
Windows.Security.EnterpriseData.ProtectedContainerImportResult.prototype.status;
/**
 * @constructor
 * @struct
 */
Windows.Security.EnterpriseData.ProtectedContentRevokedEventArgs = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Security.EnterpriseData.ProtectedContentRevokedEventArgs.prototype.identities;
/**
 * @constructor
 * @struct
 */
Windows.Security.EnterpriseData.ProtectedFileCreateResult = function() {};
 /** @type {!Windows.Storage.StorageFile} */
Windows.Security.EnterpriseData.ProtectedFileCreateResult.prototype.file;
 /** @type {!Windows.Security.EnterpriseData.FileProtectionInfo} */
Windows.Security.EnterpriseData.ProtectedFileCreateResult.prototype.protectionInfo;
 /** @type {!Windows.Storage.Streams.IRandomAccessStream} */
Windows.Security.EnterpriseData.ProtectedFileCreateResult.prototype.stream;

/** @const */
Windows.Security.EnterpriseData.ProtectedImportExportStatus = {};
/** @const {number} */
Windows.Security.EnterpriseData.ProtectedImportExportStatus.ok;
/** @const {number} */
Windows.Security.EnterpriseData.ProtectedImportExportStatus.undetermined;
/** @const {number} */
Windows.Security.EnterpriseData.ProtectedImportExportStatus.unprotected;
/** @const {number} */
Windows.Security.EnterpriseData.ProtectedImportExportStatus.revoked;
/** @const {number} */
Windows.Security.EnterpriseData.ProtectedImportExportStatus.notRoamable;
/** @const {number} */
Windows.Security.EnterpriseData.ProtectedImportExportStatus.protectedToOtherIdentity;
/** @const {number} */
Windows.Security.EnterpriseData.ProtectedImportExportStatus.licenseExpired;
/** @const {number} */
Windows.Security.EnterpriseData.ProtectedImportExportStatus.accessSuspended;

/** @const */
Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult = {};
/** @const {number} */
Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult.allowed;
/** @const {number} */
Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult.blocked;
/** @const {number} */
Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult.consentRequired;
/**
 * @constructor
 * @struct
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager = function() {};
 /** @type {boolean} */
Windows.Security.EnterpriseData.ProtectionPolicyManager.isProtectionEnabled;
 /** @type {function(?): void} */
Windows.Security.EnterpriseData.ProtectionPolicyManager.onpolicychanged;
 /** @type {function(?): void} */
Windows.Security.EnterpriseData.ProtectionPolicyManager.onprotectedaccessresumed;
 /** @type {function(?): void} */
Windows.Security.EnterpriseData.ProtectionPolicyManager.onprotectedaccesssuspending;
 /** @type {function(?): void} */
Windows.Security.EnterpriseData.ProtectionPolicyManager.onprotectedcontentrevoked;
 /** @type {string} */
Windows.Security.EnterpriseData.ProtectionPolicyManager.prototype.identity;

/**
 * Request if access to enterprise-protected content is available to an identity.
 * @param {string} sourceIdentity The source enterprise identity of the app. This is an email address or domain that is managed. Your app should use IsIdentityManaged to check if an email address or domain is managed.
 * @param {string} targetIdentity The enterprise identity you want to check has access to the protected content.
 * @return {Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult} A value of the ProtectionPolicyEvaluationResult enumeration that is the result of the query.
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.checkAccess = function(sourceIdentity, targetIdentity) {};

/**
 * Perform enterprise-protection policy evaluation for a data transfer between your app and a specific target app.
 * @param {string} sourceIdentity The source enterprise identity of the app. This is an email address or domain that is managed. Your app should use IsIdentityManaged to check if an email address or domain is managed.
 * @param {string} appPackageFamilyName The package family name of the app you want to check has access to the protected content.
 * @return {Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult} A value of the ProtectionPolicyEvaluationResult enumeration that is the result of the query.
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.checkAccessForApp = function(sourceIdentity, appPackageFamilyName) {};

/**
 * Clear UI policy enforcement for an enterprise identity. The app calls this method before it displays non-enterprise-protected content.
 * @return {void}
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.clearProcessUIPolicy = function() {};

/**
 * Creates a ThreadNetworkContext protected to an enterprise identity. The creation of the context tags all network connections made thereafter on the current thread with the identity, and allows access to enterprise resources that are access controlled by the enterprise's policy.
 * @param {string} identity The enterprise identity. This is an email address or domain that is managed. This may be returned from GetPrimaryManagedIdentityForNetworkEndpoint ; otherwise your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @return {!Windows.Security.EnterpriseData.ThreadNetworkContext} The protected network context. The app must call ThreadNetworkContext.Close after access to the resource is completed.
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.createCurrentThreadNetworkContext = function(identity) {};

/**
 * You can use this method to determine the current enterprise data protection (EDP) enforcement level. EDP enforcement level is one aspect of mobile device management (MDM) policy configuration.
 * @param {string} identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @return {Windows.Security.EnterpriseData.EnforcementLevel} A value of the EnforcementLevel enumeration.
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.getEnforcementLevel = function(identity) {};

/**
 * Returns the ProtectionPolicyManager object associated with the current app window.
 * @return {!Windows.Security.EnterpriseData.ProtectionPolicyManager} The ProtectionPolicyManager object associated with the current app window.
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.getForCurrentView = function() {};

/**
 * Returns the enterprise identity of a network resource if the resource is on an enterprise-policy-managed endpoint.
 * @param {!Windows.Networking.HostName} endpointHost The host name or IP address of the network resource.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} The enterprise identity.
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.getPrimaryManagedIdentityForNetworkEndpointAsync = function(endpointHost) {};

/**
 * Use this method to check whether access to protected data has been revoked since a specified date and time, or is still accessible.
 * @param {string} identity The enterprise identity protecting the data. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @param {!Date} since The date and time from which point forward you want to include in the check.
 * @return {boolean} true if access has been revoked since the specified date and time, otherwise false.
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.hasContentBeenRevokedSince = function(identity, since) {};

/**
 * Determines if an enterprise entity is managed by an enterprise policy.
 * @param {string} identity The enterprise identity. This is an email address or domain.
 * @return {boolean} true if the enterprise identity is managed, or false if it is not.
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.isIdentityManaged = function(identity) {};

/**
 * Use this property to determine the value of the ProtectionUnderLockConfigRequired enterprise data protection (EDP) policy.
 * @param {string} identity The enterprise identity you want to check has ProtectionUnderLockConfigRequired policy set.
 * @return {boolean} true if ProtectionUnderLockConfigRequired policy is set for the identity, otherwise false.
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.isProtectionUnderLockRequired = function(identity) {};

/**
 * Use this property to determine whether decryption of files protected by enterprise data protection (EDP) is allowed.
 * @param {string} identity The enterprise identity you want to check has access to the protected content.
 * @return {boolean} true if decryption of files protected by EDP is allowed, otherwise false.
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.isUserDecryptionAllowed = function(identity) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.removeEventListener = function(type, listener) {};

/**
 * Request access to enterprise protected content for an identity.
 * @param {string} sourceIdentity The source enterprise identity of the app. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @param {string} targetIdentity The target enterprise identity to which the content is protected.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult, !Windows.Foundation.IAsyncOperation<Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>>} A value of the ProtectionPolicyEvaluationResult enumeration that is the result of the request.
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.requestAccessAsync = function(sourceIdentity, targetIdentity) {};

/**
 * Request access to enterprise-protected content for a specific target app.
 * @param {string} sourceIdentity The source enterprise identity of the app. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @param {string} appPackageFamilyName The package family name of the app you want to check has access to the protected content.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult, !Windows.Foundation.IAsyncOperation<Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>>} A value of the ProtectionPolicyEvaluationResult enumeration that is the result of the query.
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.requestAccessForAppAsync = function(sourceIdentity, appPackageFamilyName) {};

/**
 * Revoke the keys required to access all content protected to the specified enterprise identity.
 * @param {string} identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @return {void}
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.revokeContent = function(identity) {};

/**
 * Enables UI policy enforcement for an enterprise identity. When an app is about to display a protected file (such as a PDF) or resource (buffer or stream) on its UI, it must enable UI policy enforcement based on the identity the file is protected to. A call to TryApplyProcessUIPolicy ensures that the OS knows about the current context of the app.
 * @param {string} identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
 * @return {boolean} true if the identity is being managed by an enterprise policy, or false if it is not.
 */
Windows.Security.EnterpriseData.ProtectionPolicyManager.tryApplyProcessUIPolicy = function(identity) {};
/**
 * @constructor
 * @struct
 */
Windows.Security.EnterpriseData.ThreadNetworkContext = function() {};

/**
 * Closes the protected network context. The app must call Close after access to the protected resource is completed.
 * @return {void}
 */
Windows.Security.EnterpriseData.ThreadNetworkContext.prototype.close = function() {};
/** @const */
Windows.Security.ExchangeActiveSyncProvisioning = {};

/**
 * @constructor
 * @struct
 * Creates an instance of an object that allows the caller app to retrieve device information from the local device.
 */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientDeviceInformation = function() {};
 /** @type {string} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientDeviceInformation.prototype.friendlyName;
 /** @type {string} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientDeviceInformation.prototype.id;
 /** @type {string} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientDeviceInformation.prototype.operatingSystem;
 /** @type {string} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientDeviceInformation.prototype.systemFirmwareVersion;
 /** @type {string} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientDeviceInformation.prototype.systemHardwareVersion;
 /** @type {string} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientDeviceInformation.prototype.systemManufacturer;
 /** @type {string} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientDeviceInformation.prototype.systemProductName;
 /** @type {string} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientDeviceInformation.prototype.systemSku;

/**
 * @constructor
 * @struct
 * Creates an instance of an object that allows the caller app to set policies received from the Exchange server for evaluation or application.
 */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientSecurityPolicy = function() {};
 /** @type {boolean} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientSecurityPolicy.prototype.disallowConvenienceLogon;
 /** @type {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientSecurityPolicy.prototype.maxInactivityTimeLock;
 /** @type {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientSecurityPolicy.prototype.maxPasswordFailedAttempts;
 /** @type {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientSecurityPolicy.prototype.minPasswordComplexCharacters;
 /** @type {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientSecurityPolicy.prototype.minPasswordLength;
 /** @type {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientSecurityPolicy.prototype.passwordExpiration;
 /** @type {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientSecurityPolicy.prototype.passwordHistory;
 /** @type {boolean} */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientSecurityPolicy.prototype.requireEncryption;

/**
 * Applies the EAS policies in asynchronous mode once the user consents. ApplyAsync is called by a Windows Store app for mail any time the app wants to make the local computer compliant.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults, !Windows.Foundation.IAsyncOperation<!Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults>>} Returns the evaluation of the callback results, in asynchronous mode, back to the calling app.
 */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientSecurityPolicy.prototype.applyAsync = function() {};

/**
 * Evaluates the EAS policies. CheckCompliance is called by a Windows Store app for mail any time the app wants to evaluate whether the local computer is compliant to the given EAS policies. Because this call doesn't involve any UI interactions, it is a synchronous call.
 * @return {!Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults} Returns the results of the compliance check, in synchronous mode.
 */
Windows.Security.ExchangeActiveSyncProvisioning.EasClientSecurityPolicy.prototype.checkCompliance = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults = function() {};
 /** @type {boolean} */
Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults.prototype.compliant;
 /** @type {Windows.Security.ExchangeActiveSyncProvisioning.EasDisallowConvenienceLogonResult} */
Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults.prototype.disallowConvenienceLogonResult;
 /** @type {Windows.Security.ExchangeActiveSyncProvisioning.EasEncryptionProviderType} */
Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults.prototype.encryptionProviderType;
 /** @type {Windows.Security.ExchangeActiveSyncProvisioning.EasMaxInactivityTimeLockResult} */
Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults.prototype.maxInactivityTimeLockResult;
 /** @type {Windows.Security.ExchangeActiveSyncProvisioning.EasMaxPasswordFailedAttemptsResult} */
Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults.prototype.maxPasswordFailedAttemptsResult;
 /** @type {Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult} */
Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults.prototype.minPasswordComplexCharactersResult;
 /** @type {Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult} */
Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults.prototype.minPasswordLengthResult;
 /** @type {Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult} */
Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults.prototype.passwordExpirationResult;
 /** @type {Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordHistoryResult} */
Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults.prototype.passwordHistoryResult;
 /** @type {Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult} */
Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults.prototype.requireEncryptionResult;

/** @const */
Windows.Security.ExchangeActiveSyncProvisioning.EasDisallowConvenienceLogonResult = {};
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasDisallowConvenienceLogonResult.notEvaluated;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasDisallowConvenienceLogonResult.compliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasDisallowConvenienceLogonResult.canBeCompliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasDisallowConvenienceLogonResult.requestedPolicyIsStricter;

/** @const */
Windows.Security.ExchangeActiveSyncProvisioning.EasEncryptionProviderType = {};
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasEncryptionProviderType.notEvaluated;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasEncryptionProviderType.windowsEncryption;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasEncryptionProviderType.otherEncryption;

/** @const */
Windows.Security.ExchangeActiveSyncProvisioning.EasMaxInactivityTimeLockResult = {};
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMaxInactivityTimeLockResult.notEvaluated;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMaxInactivityTimeLockResult.compliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMaxInactivityTimeLockResult.canBeCompliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMaxInactivityTimeLockResult.requestedPolicyIsStricter;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMaxInactivityTimeLockResult.invalidParameter;

/** @const */
Windows.Security.ExchangeActiveSyncProvisioning.EasMaxPasswordFailedAttemptsResult = {};
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMaxPasswordFailedAttemptsResult.notEvaluated;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMaxPasswordFailedAttemptsResult.compliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMaxPasswordFailedAttemptsResult.canBeCompliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMaxPasswordFailedAttemptsResult.requestedPolicyIsStricter;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMaxPasswordFailedAttemptsResult.invalidParameter;

/** @const */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult = {};
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.notEvaluated;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.compliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.canBeCompliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.requestedPolicyIsStricter;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.requestedPolicyNotEnforceable;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.invalidParameter;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.currentUserHasBlankPassword;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.adminsHaveBlankPassword;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.userCannotChangePassword;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.adminsCannotChangePassword;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.localControlledUsersCannotChangePassword;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.connectedAdminsProviderPolicyIsWeak;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.connectedUserProviderPolicyIsWeak;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.changeConnectedAdminsPassword;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult.changeConnectedUserPassword;

/** @const */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult = {};
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.notEvaluated;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.compliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.canBeCompliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.requestedPolicyIsStricter;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.requestedPolicyNotEnforceable;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.invalidParameter;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.currentUserHasBlankPassword;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.adminsHaveBlankPassword;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.userCannotChangePassword;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.adminsCannotChangePassword;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.localControlledUsersCannotChangePassword;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.connectedAdminsProviderPolicyIsWeak;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.connectedUserProviderPolicyIsWeak;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.changeConnectedAdminsPassword;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult.changeConnectedUserPassword;

/** @const */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult = {};
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult.notEvaluated;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult.compliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult.canBeCompliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult.requestedPolicyIsStricter;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult.requestedExpirationIncompatible;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult.invalidParameter;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult.userCannotChangePassword;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult.adminsCannotChangePassword;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult.localControlledUsersCannotChangePassword;

/** @const */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordHistoryResult = {};
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordHistoryResult.notEvaluated;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordHistoryResult.compliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordHistoryResult.canBeCompliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordHistoryResult.requestedPolicyIsStricter;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordHistoryResult.invalidParameter;

/** @const */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult = {};
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.notEvaluated;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.compliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.canBeCompliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.notProvisionedOnAllVolumes;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.deFixedDataNotSupported;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.fixedDataNotSupported;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.deHardwareNotCompliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.hardwareNotCompliant;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.deWinReNotConfigured;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.lockNotConfigured;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.deProtectionSuspended;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.protectionSuspended;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.deOsVolumeNotProtected;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.osVolumeNotProtected;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.deProtectionNotYetEnabled;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.protectionNotYetEnabled;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.noFeatureLicense;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.osNotProtected;
/** @const {number} */
Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult.unexpectedFailure;
/** @const */
Windows.Services = {};
/** @const */
Windows.Services.Maps = {};
/** @const */
Windows.Services.Maps.Guidance = {};

/** @const */
Windows.Services.Maps.Guidance.GuidanceLaneMarkers = {};
/** @const {number} */
Windows.Services.Maps.Guidance.GuidanceLaneMarkers.none;
/** @const {number} */
Windows.Services.Maps.Guidance.GuidanceLaneMarkers.lightRight;
/** @const {number} */
Windows.Services.Maps.Guidance.GuidanceLaneMarkers.right;
/** @const {number} */
Windows.Services.Maps.Guidance.GuidanceLaneMarkers.hardRight;
/** @const {number} */
Windows.Services.Maps.Guidance.GuidanceLaneMarkers.straight;
/** @const {number} */
Windows.Services.Maps.Guidance.GuidanceLaneMarkers.uturnLeft;
/** @const {number} */
Windows.Services.Maps.Guidance.GuidanceLaneMarkers.hardLeft;
/** @const {number} */
Windows.Services.Maps.Guidance.GuidanceLaneMarkers.left;
/** @const {number} */
Windows.Services.Maps.Guidance.GuidanceLaneMarkers.lightLeft;
/** @const {number} */
Windows.Services.Maps.Guidance.GuidanceLaneMarkers.uturnRight;
/** @const {number} */
Windows.Services.Maps.Guidance.GuidanceLaneMarkers.unknown;
/** @const */
Windows.Services.Maps.LocalSearch = {};
/** @const */
Windows.Storage = {};
/** @const */
Windows.Storage.AccessCache = {};

/** @const */
Windows.Storage.AccessCache.AccessCacheOptions = {};
/** @const {number} */
Windows.Storage.AccessCache.AccessCacheOptions.none;
/** @const {number} */
Windows.Storage.AccessCache.AccessCacheOptions.disallowUserInput;
/** @const {number} */
Windows.Storage.AccessCache.AccessCacheOptions.fastLocationsOnly;
/** @const {number} */
Windows.Storage.AccessCache.AccessCacheOptions.useReadOnlyCachedCopy;
/** @const {number} */
Windows.Storage.AccessCache.AccessCacheOptions.suppressAccessTimeUpdate;
/**
 * @constructor
 * @struct
 */
Windows.Storage.AccessCache.AccessListEntryView = function() {};
 /** @type {number} */
Windows.Storage.AccessCache.AccessListEntryView.prototype.size;

/**
 * Retrieves the first storage item from the access list or most recently used (MRU) list.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Storage.AccessCache.AccessListEntry>} The first item.
 */
Windows.Storage.AccessCache.AccessListEntryView.prototype.first = function() {};

/**
 * Retrieves the storage item at the specified index in the access list or most recently used (MRU) list.
 * @param {number} index The zero-based index of the storage item to retrieve.
 * @return {!Windows.Storage.AccessCache.AccessListEntry} The storage item.
 */
Windows.Storage.AccessCache.AccessListEntryView.prototype.getAt = function(index) {};

/**
 * Retrieves the storage items that start at the specified index in the access list or most recently used (MRU) list.
 * @param {number} startIndex The zero-based index of the start of the items in the collection to retrieve.
 * @return {{items: !Windows.Storage.AccessCache.AccessListEntry, returnValue: number}}
 */
Windows.Storage.AccessCache.AccessListEntryView.prototype.getMany = function(startIndex) {};

/**
 * Retrieves the index of the specified storage item in the access list or most recently used (MRU) list.
 * @param {!Windows.Storage.AccessCache.AccessListEntry} value_or_searchElement The storage item.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Storage.AccessCache.AccessListEntryView.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.AccessCache.ItemRemovedEventArgs = function() {};
 /** @type {!Windows.Storage.AccessCache.AccessListEntry} */
Windows.Storage.AccessCache.ItemRemovedEventArgs.prototype.removedEntry;

/** @const */
Windows.Storage.AccessCache.RecentStorageItemVisibility = {};
/** @const {number} */
Windows.Storage.AccessCache.RecentStorageItemVisibility.appOnly;
/** @const {number} */
Windows.Storage.AccessCache.RecentStorageItemVisibility.appAndSystem;
/**
 * @constructor
 * @struct
 */
Windows.Storage.AccessCache.StorageApplicationPermissions = function() {};
 /** @type {!Windows.Storage.AccessCache.StorageItemAccessList} */
Windows.Storage.AccessCache.StorageApplicationPermissions.futureAccessList;
 /** @type {!Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList} */
Windows.Storage.AccessCache.StorageApplicationPermissions.mostRecentlyUsedList;
/**
 * @constructor
 * @struct
 */
Windows.Storage.AccessCache.StorageItemAccessList = function() {};
 /** @type {!Windows.Storage.AccessCache.AccessListEntryView} */
Windows.Storage.AccessCache.StorageItemAccessList.prototype.entries;
 /** @type {number} */
Windows.Storage.AccessCache.StorageItemAccessList.prototype.maximumItemsAllowed;

/**
 * Adds a new storage item and accompanying metadata to the access list.
 * Adds a new storage item to the access list.
 * @param {!Windows.Storage.IStorageItem} file The storage item to add.
 * @param {string=} metadata Optional metadata to associate with the storage item.
 * @return {string} A token that the app can use later to retrieve the storage item.
 */
Windows.Storage.AccessCache.StorageItemAccessList.prototype.add = function(file, metadata) {};

/**
 * Adds a new storage item and accompanying metadata to the access list, or replaces the specified item if it already exists in the list.
 * Adds a new storage item to the access list, or replaces the specified item if it already exists in the list.
 * @param {string} token A token that the app can use later to retrieve this storage item. / The token associated with the new storage item. If the access list already contains a storage item that has this token, the new item replaces the existing one.
 * @param {!Windows.Storage.IStorageItem} file The storage item to add or replace.
 * @param {string=} metadata Optional metadata to associate with the storage item.
 * @return {void}
 */
Windows.Storage.AccessCache.StorageItemAccessList.prototype.addOrReplace = function(token, file, metadata) {};

/**
 * Determines whether the app has access to the specified storage item in the access list.
 * @param {!Windows.Storage.IStorageItem} file The storage item to check for access.
 * @return {boolean} True if the app can access the storage item; otherwise false.
 */
Windows.Storage.AccessCache.StorageItemAccessList.prototype.checkAccess = function(file) {};

/**
 * Removes all storage items from the access list.
 * @return {void}
 */
Windows.Storage.AccessCache.StorageItemAccessList.prototype.clear = function() {};

/**
 * Determines whether the access list contains the specified storage item.
 * @param {string} token The token of the storage item to look for.
 * @return {boolean} True if the access list contains the specified storage item; false otherwise.
 */
Windows.Storage.AccessCache.StorageItemAccessList.prototype.containsItem = function(token) {};

/**
 * Retrieves the specified StorageFile from the list.
 * Retrieves the StorageFile from the list using the specified options.
 * @param {string} token The token of the StorageFile to retrieve.
 * @param {Windows.Storage.AccessCache.AccessCacheOptions=} options The enum value that describes the behavior to use when the app accesses the item.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes successfully, it returns the StorageFile that is associated with the specified token.
 */
Windows.Storage.AccessCache.StorageItemAccessList.prototype.getFileAsync = function(token, options) {};

/**
 * Retrieves the specified StorageFolder from the list using the specified options.
 * Retrieves the specified StorageFolder from the list.
 * @param {string} token The token of the StorageFolder to retrieve.
 * @param {Windows.Storage.AccessCache.AccessCacheOptions=} options The enum value that describes the behavior to use when the app accesses the item.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes successfully, it returns the StorageFolder that is associated with the specified token.
 */
Windows.Storage.AccessCache.StorageItemAccessList.prototype.getFolderAsync = function(token, options) {};

/**
 * Retrieves the specified item (like a file or folder) from the most recently used (MRU) list.
 * Retrieves the specified item (like a file or folder) from the list using the specified options.
 * @param {string} token The token of the item to retrieve.
 * @param {Windows.Storage.AccessCache.AccessCacheOptions=} options The enum value that describes the behavior to use when the app accesses the item.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.IStorageItem, !Windows.Foundation.IAsyncOperation<!Windows.Storage.IStorageItem>>} When this method completes successfully, it returns the item (type IStorageItem ) that is associated with the specified token.
 */
Windows.Storage.AccessCache.StorageItemAccessList.prototype.getItemAsync = function(token, options) {};

/**
 * Removes the specified storage item from the access list.
 * @param {string} token The token of the storage item to remove.
 * @return {void}
 */
Windows.Storage.AccessCache.StorageItemAccessList.prototype.remove = function(token) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList = function() {};
 /** @type {!Windows.Storage.AccessCache.AccessListEntryView} */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList.prototype.entries;
 /** @type {number} */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList.prototype.maximumItemsAllowed;
 /** @type {function(?): void} */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList.prototype.onitemremoved;

/**
 * Adds a new storage item and accompanying metadata to the most recently used (MRU) list.
 * Adds a new storage item to the most recently used (MRU) list.
 * Adds a new storage item and accompanying metadata to the most recently used (MRU) list, specifying the extent of its visibility in the list.
 * @param {!Windows.Storage.IStorageItem} file The storage item to add.
 * @param {string=} metadata Optional metadata to associate with the storage item.
 * @param {Windows.Storage.AccessCache.RecentStorageItemVisibility=} visibility The extent of the visibility of the storage item in the list.
 * @return {string} A token that the app can use later to retrieve the storage item.
 */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList.prototype.add = function(file, metadata, visibility) {};

/**
 * Adds a new storage item to the most recently used (MRU) list, or replaces the specified item if it already exists in the list.
 * Adds a new storage item and accompanying metadata to the most recently used (MRU) list, or replaces the specified item if it already exists in the list.
 * Adds a new storage item and accompanying metadata to the most recently used (MRU) list, or replaces the specified item if it already exists in the list. Also specifies the extent of its visibility in the list.
 * @param {string} token The token associated with the new storage item. If the access list already contains a storage item that has this token, the new item replaces the existing one.
 * @param {!Windows.Storage.IStorageItem} file The storage item to add or replace.
 * @param {string=} metadata Optional metadata to associate with the storage item.
 * @param {Windows.Storage.AccessCache.RecentStorageItemVisibility=} visibility The extent of the visibility of the storage item in the list.
 * @return {void}
 */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList.prototype.addOrReplace = function(token, file, metadata, visibility) {};

/**
 * Determines whether the app has access to the specified storage item in the most recently used (MRU) list.
 * @param {!Windows.Storage.IStorageItem} file The storage item to check for access.
 * @return {boolean} True if the app can access the storage item; otherwise false.
 */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList.prototype.checkAccess = function(file) {};

/**
 * Removes all storage items from the most recently used (MRU) list.
 * @return {void}
 */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList.prototype.clear = function() {};

/**
 * Determines whether the most recently used (MRU) list contains the specified storage item.
 * @param {string} token The token of the storage item to look for.
 * @return {boolean} True if the MRU list contains the specified storage item; false otherwise.
 */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList.prototype.containsItem = function(token) {};

/**
 * Retrieves the specified storageFile from the most recently used (MRU) list using the specified options.
 * Retrieves the specified storageFile from the most recently used (MRU) list.
 * @param {string} token The token of the storageFile to retrieve.
 * @param {Windows.Storage.AccessCache.AccessCacheOptions=} options The enum value that describes the behavior to use when the app accesses the item.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes successfully, it returns the storageFile that is associated with the specified token.
 */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList.prototype.getFileAsync = function(token, options) {};

/**
 * Retrieves the specified StorageFolder from the most recently used (MRU) list.
 * Retrieves the specified StorageFolder from the most recently used (MRU) list using the specified options.
 * @param {string} token The token of the StorageFolder to retrieve.
 * @param {Windows.Storage.AccessCache.AccessCacheOptions=} options The enum value that describes the behavior to use when the app accesses the item.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes successfully, it returns the StorageFolder that is associated with the specified token.
 */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList.prototype.getFolderAsync = function(token, options) {};

/**
 * Retrieves the specified item (like a file or folder) from the most recently used (MRU) list using the specified options.
 * Retrieves the specified item (like a file or folder) from the most recently used (MRU) list.
 * @param {string} token The token of the item to retrieve.
 * @param {Windows.Storage.AccessCache.AccessCacheOptions=} options The enum value that describes the behavior to use when the app accesses the item.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.IStorageItem, !Windows.Foundation.IAsyncOperation<!Windows.Storage.IStorageItem>>} When this method completes successfully, it returns the item (type IStorageItem ) that is associated with the specified token.
 */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList.prototype.getItemAsync = function(token, options) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList.prototype.removeEventListener = function(type, listener) {};

/**
 * Removes the specified storage item from the most recently used (MRU) list.
 * @param {string} token The token of the storage item to remove.
 * @return {void}
 */
Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList.prototype.remove = function(token) {};
/**
 * @record
 * @struct
 */
Windows.Storage.AccessCache.AccessListEntry = function() {};
 /** @type {string} */
Windows.Storage.AccessCache.AccessListEntry.prototype.metadata;
 /** @type {string} */
Windows.Storage.AccessCache.AccessListEntry.prototype.token;
/**
 * @constructor
 * @struct
 */
Windows.Storage.ApplicationData = function() {};
 /** @type {!Windows.Storage.ApplicationData} */
Windows.Storage.ApplicationData.current;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.ApplicationData.prototype.localCacheFolder;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.ApplicationData.prototype.localFolder;
 /** @type {!Windows.Storage.ApplicationDataContainer} */
Windows.Storage.ApplicationData.prototype.localSettings;
 /** @type {function(?): void} */
Windows.Storage.ApplicationData.prototype.ondatachanged;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.ApplicationData.prototype.roamingFolder;
 /** @type {!Windows.Storage.ApplicationDataContainer} */
Windows.Storage.ApplicationData.prototype.roamingSettings;
 /** @type {number} */
Windows.Storage.ApplicationData.prototype.roamingStorageQuota;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.ApplicationData.prototype.sharedLocalFolder;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.ApplicationData.prototype.temporaryFolder;
 /** @type {number} */
Windows.Storage.ApplicationData.prototype.version;

/**
 * Static method that returns the ApplicationData for a User .
 * @param {!Windows.System.User} user The User for which the ApplicationData is returned.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.ApplicationData, !Windows.Foundation.IAsyncOperation<!Windows.Storage.ApplicationData>>} When this method completes, it returns the requested ApplicationData object.
 */
Windows.Storage.ApplicationData.getForUserAsync = function(user) {};

/**
 * Removes all application data from the local, roaming, and temporary app data stores.
 * Removes all application data from the specified app data store.
 * @param {Windows.Storage.ApplicationDataLocality=} locality One of the enumeration values.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An object that is used to manage the asynchronous clear operation.
 */
Windows.Storage.ApplicationData.prototype.clearAsync = function(locality) {};

/**
 * Clears the files and subfolders from the specified subfolder of the shared storage folder for the publisher of the current app.
 * @param {string} folderName The subfolder of the shared storage folder for the publisher of the current app from which to clear the files and subfolders.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Represents an asynchronous action that does not return a result and does not have progress notifications. You can use this value to get the results of the operation, or to specify a method to run when the operation completes - for example, to repopulate the shared storage folder with new data.
 */
Windows.Storage.ApplicationData.prototype.clearPublisherCacheFolderAsync = function(folderName) {};

/**
 * Gets the specified subfolder of the shared storage folder for the publisher of the current app.
 * @param {string} folderName The subfolder to get from the shared storage folder for the publisher of the current app.
 * @return {!Windows.Storage.StorageFolder} The specified subfolder.
 */
Windows.Storage.ApplicationData.prototype.getPublisherCacheFolder = function(folderName) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.ApplicationData.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.ApplicationData.prototype.removeEventListener = function(type, listener) {};

/**
 * Sets the version number of the application data in the app data store.
 * @param {number} desiredVersion The new version number.
 * @param {function(!Windows.Storage.SetVersionRequest): void} handler The set version event handler.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An object that is used to manage the asynchronous set version operation.
 */
Windows.Storage.ApplicationData.prototype.setVersionAsync = function(desiredVersion, handler) {};

/**
 * Sends a DataChanged | datachanged event to all registered event handlers.
 * @return {void}
 */
Windows.Storage.ApplicationData.prototype.signalDataChanged = function() {};

/**
 * @constructor
 * @struct
 * Creates and initializes a new, initially empty, instance of the object.
 */
Windows.Storage.ApplicationDataCompositeValue = function() {};
 /** @type {function(?): void} */
Windows.Storage.ApplicationDataCompositeValue.prototype.onmapchanged;
 /** @type {number} */
Windows.Storage.ApplicationDataCompositeValue.prototype.size;

/**
 * Removes all application settings previously inserted into the composite value object, returning the object to its empty state.
 * @return {void}
 */
Windows.Storage.ApplicationDataCompositeValue.prototype.clear = function() {};

/**
 * Retrieves an iterator to enumerate the settings in the composite value.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The iterator.
 */
Windows.Storage.ApplicationDataCompositeValue.prototype.first = function() {};

/**
 * Returns a read-only snapshot of the contents of the composite value.
 * @return {!Windows.Foundation.Collections.IMapView<string, ?>} The view of the composite value.
 */
Windows.Storage.ApplicationDataCompositeValue.prototype.getView = function() {};

/**
 * Determines whether there is an application setting with the specified key.
 * @param {string} key The key.
 * @return {boolean} True if the key is found; otherwise false.
 */
Windows.Storage.ApplicationDataCompositeValue.prototype.hasKey = function(key) {};

/**
 * Creates or replaces an application setting.
 * @param {string} key The key of the setting to insert or replace.
 * @param {?} value The setting value.
 * @return {boolean} True if an item with the specified key is an existing item and was replaced; otherwise, false.
 */
Windows.Storage.ApplicationDataCompositeValue.prototype.insert = function(key, value) {};

/**
 * Retrieves the specified application setting.
 * @param {string} key The key of the setting.
 * @return {?} The application setting.
 */
Windows.Storage.ApplicationDataCompositeValue.prototype.lookup = function(key) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.ApplicationDataCompositeValue.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.ApplicationDataCompositeValue.prototype.removeEventListener = function(type, listener) {};

/**
 * Removes the value with the specified key.
 * Removes a specific item from the ApplicationDataCompositeValue .
 * @param {string} key The key of the value to remove. / The key of the item to remove.
 * @return {void|boolean} true if the item was removed, otherwise false.
 */
Windows.Storage.ApplicationDataCompositeValue.prototype.remove = function(key) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.ApplicationDataContainer = function() {};
 /** @type {!Windows.Foundation.Collections.IMapView<string, !Windows.Storage.ApplicationDataContainer>} */
Windows.Storage.ApplicationDataContainer.prototype.containers;
 /** @type {Windows.Storage.ApplicationDataLocality} */
Windows.Storage.ApplicationDataContainer.prototype.locality;
 /** @type {string} */
Windows.Storage.ApplicationDataContainer.prototype.name;
 /** @type {!Windows.Foundation.Collections.IPropertySet} */
Windows.Storage.ApplicationDataContainer.prototype.values;

/**
 * Creates or opens the specified settings container in the current settings container.
 * @param {string} name The name of the container.
 * @param {Windows.Storage.ApplicationDataCreateDisposition} disposition One of the enumeration values.
 * @return {!Windows.Storage.ApplicationDataContainer} The settings container.
 */
Windows.Storage.ApplicationDataContainer.prototype.createContainer = function(name, disposition) {};

/**
 * Deletes the specified settings container, its subcontainers, and all application settings in the hierarchy.
 * @param {string} name The name of the settings container.
 * @return {void}
 */
Windows.Storage.ApplicationDataContainer.prototype.deleteContainer = function(name) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.ApplicationDataContainerSettings = function() {};
 /** @type {function(?): void} */
Windows.Storage.ApplicationDataContainerSettings.prototype.onmapchanged;
 /** @type {number} */
Windows.Storage.ApplicationDataContainerSettings.prototype.size;

/**
 * Removes all related application settings.
 * @return {void}
 */
Windows.Storage.ApplicationDataContainerSettings.prototype.clear = function() {};

/**
 * Retrieves an iterator to enumerate the settings in the settings container.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The iterator.
 */
Windows.Storage.ApplicationDataContainerSettings.prototype.first = function() {};

/**
 * Returns a read-only snapshot of the contents of the settings container.
 * @return {!Windows.Foundation.Collections.IMapView<string, ?>} The view of the settings container.
 */
Windows.Storage.ApplicationDataContainerSettings.prototype.getView = function() {};

/**
 * Determines whether there is an application setting with the specified key.
 * @param {string} key The key.
 * @return {boolean} True if the key is found; otherwise false.
 */
Windows.Storage.ApplicationDataContainerSettings.prototype.hasKey = function(key) {};

/**
 * Inserts or replaces an application setting.
 * @param {string} key The key of the setting to insert or replace.
 * @param {?} value The setting value.
 * @return {boolean} True if an item with the specified key is an existing item and was replaced; otherwise, false.
 */
Windows.Storage.ApplicationDataContainerSettings.prototype.insert = function(key, value) {};

/**
 * Retrieves the specified application setting.
 * @param {string} key The key of the setting.
 * @return {?} The application setting.
 */
Windows.Storage.ApplicationDataContainerSettings.prototype.lookup = function(key) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.ApplicationDataContainerSettings.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.ApplicationDataContainerSettings.prototype.removeEventListener = function(type, listener) {};

/**
 * Removes the specified application setting.
 * Removes a specific item from the ApplicationDataContainerSettings .
 * @param {string} key The key of the setting. / The key of the item to remove.
 * @return {void|boolean} true if the item was removed, otherwise false.
 */
Windows.Storage.ApplicationDataContainerSettings.prototype.remove = function(key) {};

/** @const */
Windows.Storage.ApplicationDataCreateDisposition = {};
/** @const {number} */
Windows.Storage.ApplicationDataCreateDisposition.always;
/** @const {number} */
Windows.Storage.ApplicationDataCreateDisposition.existing;

/** @const */
Windows.Storage.ApplicationDataLocality = {};
/** @const {number} */
Windows.Storage.ApplicationDataLocality.local;
/** @const {number} */
Windows.Storage.ApplicationDataLocality.roaming;
/** @const {number} */
Windows.Storage.ApplicationDataLocality.temporary;
/** @const {number} */
Windows.Storage.ApplicationDataLocality.localCache;
/** @const */
Windows.Storage.BulkAccess = {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.BulkAccess.FileInformation = function() {};
 /** @type {Windows.Storage.FileAttributes} */
Windows.Storage.BulkAccess.FileInformation.prototype.attributes;
 /** @type {!Windows.Storage.FileProperties.BasicProperties} */
Windows.Storage.BulkAccess.FileInformation.prototype.basicProperties;
 /** @type {string} */
Windows.Storage.BulkAccess.FileInformation.prototype.contentType;
 /** @type {!Date} */
Windows.Storage.BulkAccess.FileInformation.prototype.dateCreated;
 /** @type {string} */
Windows.Storage.BulkAccess.FileInformation.prototype.displayName;
 /** @type {string} */
Windows.Storage.BulkAccess.FileInformation.prototype.displayType;
 /** @type {!Windows.Storage.FileProperties.DocumentProperties} */
Windows.Storage.BulkAccess.FileInformation.prototype.documentProperties;
 /** @type {string} */
Windows.Storage.BulkAccess.FileInformation.prototype.fileType;
 /** @type {string} */
Windows.Storage.BulkAccess.FileInformation.prototype.folderRelativeId;
 /** @type {!Windows.Storage.FileProperties.ImageProperties} */
Windows.Storage.BulkAccess.FileInformation.prototype.imageProperties;
 /** @type {boolean} */
Windows.Storage.BulkAccess.FileInformation.prototype.isAvailable;
 /** @type {!Windows.Storage.FileProperties.MusicProperties} */
Windows.Storage.BulkAccess.FileInformation.prototype.musicProperties;
 /** @type {string} */
Windows.Storage.BulkAccess.FileInformation.prototype.name;
 /** @type {function(?): void} */
Windows.Storage.BulkAccess.FileInformation.prototype.onpropertiesupdated;
 /** @type {function(?): void} */
Windows.Storage.BulkAccess.FileInformation.prototype.onthumbnailupdated;
 /** @type {string} */
Windows.Storage.BulkAccess.FileInformation.prototype.path;
 /** @type {!Windows.Storage.FileProperties.StorageItemContentProperties} */
Windows.Storage.BulkAccess.FileInformation.prototype.properties;
 /** @type {!Windows.Storage.StorageProvider} */
Windows.Storage.BulkAccess.FileInformation.prototype.provider;
 /** @type {!Windows.Storage.FileProperties.StorageItemThumbnail} */
Windows.Storage.BulkAccess.FileInformation.prototype.thumbnail;
 /** @type {!Windows.Storage.FileProperties.VideoProperties} */
Windows.Storage.BulkAccess.FileInformation.prototype.videoProperties;

/**
 * Replaces the specified StorageFile with a copy of the current file.
 * @param {!Windows.Storage.IStorageFile} fileToReplace The StorageFile to be replaced.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.BulkAccess.FileInformation.prototype.copyAndReplaceAsync = function(fileToReplace) {};

/**
 * Creates a copy of the StorageFile , gives it the specified file name, and stores it in the specified StorageFolder .
 * Creates a copy of the StorageFile , gives it the specified file name, and stores it in the specified StorageFolder . The method also specifies what to do if a file with the same name already exists in the specified folder.
 * Creates a copy of the StorageFile and stores it in the specified StorageFolder .
 * @param {!Windows.Storage.IStorageFolder} destinationFolder The folder in which to store the copied file.
 * @param {string=} desiredNewName The name of the new copy.
 * @param {Windows.Storage.NameCollisionOption=} option A value that indicates what to do if the file name already exists in the destination folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes successfully, it returns the copy as a StorageFile object.
 */
Windows.Storage.BulkAccess.FileInformation.prototype.copyAsync = function(destinationFolder, desiredNewName, option) {};

/**
 * Deletes a file.
 * Deletes a file, optionally moving the deleted file to the recycle bin.
 * @param {Windows.Storage.StorageDeleteOption=} option A value that specifies whether the deleted file is moved to the recycle bin.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.BulkAccess.FileInformation.prototype.deleteAsync = function(option) {};

/**
 * Retrieves the basic properties of the StorageFile .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.BasicProperties, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.BasicProperties>>} When this method completes successfully, it returns a BasicProperties object.
 */
Windows.Storage.BulkAccess.FileInformation.prototype.getBasicPropertiesAsync = function() {};

/**
 * Gets the parent folder of the current file.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes, it returns the parent folder as a StorageFolder .
 */
Windows.Storage.BulkAccess.FileInformation.prototype.getParentAsync = function() {};

/**
 * Retrieves the thumbnail that is associated with the StorageFile .
 * Retrieves the thumbnail that is associated with the StorageFile , scaling it to the specified size.
 * Retrieves the thumbnail that is associated with the StorageFile , based on the specified options.
 * @param {Windows.Storage.FileProperties.ThumbnailMode} mode The thumbnail mode to retrieve.
 * @param {number=} requestedSize The requested size in pixels of thumbnail to retrieve.
 * @param {Windows.Storage.FileProperties.ThumbnailOptions=} options The thumbnail retrieval options.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.StorageItemThumbnail, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.StorageItemThumbnail>>} When this method completes successfully, it returns the thumbnail image as a StorageItemThumbnail object.
 */
Windows.Storage.BulkAccess.FileInformation.prototype.getThumbnailAsync = function(mode, requestedSize, options) {};

/**
 * Indicates whether the current file is the same as the specified storage item.
 * @param {!Windows.Storage.IStorageItem} item The IStorageItem object that represents a storage item to compare against.
 * @return {boolean} Returns true if the current storage item is the same as the specified storage item; otherwise false.
 */
Windows.Storage.BulkAccess.FileInformation.prototype.isEqual = function(item) {};

/**
 * Determines whether the loaded StorageFile is the specified type.
 * @param {Windows.Storage.StorageItemTypes} type The type of item to check against.
 * @return {boolean} True if the loaded StorageFile is the specified type; otherwise false.
 */
Windows.Storage.BulkAccess.FileInformation.prototype.isOfType = function(type) {};

/**
 * Moves the current StorageFile from its location and uses it to replace the specified StorageFile.
 * @param {!Windows.Storage.IStorageFile} fileToReplace The StorageFile to be replaced.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An object for managing the asynchronous move and replace operation.
 */
Windows.Storage.BulkAccess.FileInformation.prototype.moveAndReplaceAsync = function(fileToReplace) {};

/**
 * Moves the StorageFile to the specified StorageFolder .
 * Moves the StorageFile to the specified folder and gives it the specified file name. The method also specifies what to do if a file with the same name already exists in the specified folder.
 * Moves the StorageFile to the specified folder, and gives the file the specified file name.
 * @param {!Windows.Storage.IStorageFolder} destinationFolder The destination folder.
 * @param {string=} desiredNewName The new file name.
 * @param {Windows.Storage.NameCollisionOption=} option A value that indicates what to do if the file name already exists in the destination folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.BulkAccess.FileInformation.prototype.moveAsync = function(destinationFolder, desiredNewName, option) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.BulkAccess.FileInformation.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.BulkAccess.FileInformation.prototype.removeEventListener = function(type, listener) {};

/**
 * Opens a random-access stream with the specified options over the specified file.
 * Opens a random-access stream with the specified options over the specified file.
 * @param {Windows.Storage.FileAccessMode} accessMode One of the enumeration values that specifies the type of access to allow.
 * @param {Windows.Storage.StorageOpenOptions=} options A bitwise combination of the enumeration values that specify options for opening the stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStream, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStream>>} When this method completes, it returns an IRandomAccessStream that contains the requested random-access stream.
 */
Windows.Storage.BulkAccess.FileInformation.prototype.openAsync = function(accessMode, options) {};

/**
 * Opens a read-only, random-access stream over the StorageFile .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType>>} When this method completes successfully, it returns a read-only, random-access stream (type IRandomAccessStreamWithContentType ).
 */
Windows.Storage.BulkAccess.FileInformation.prototype.openReadAsync = function() {};

/**
 * Opens a read-only, sequential-access stream over the StorageFile .
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IInputStream, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IInputStream>>} When this method completes successfully, it returns a read-only, sequential-access stream (type IInputStream ).
 */
Windows.Storage.BulkAccess.FileInformation.prototype.openSequentialReadAsync = function() {};

/**
 * Opens a random-access stream to the file that can be used for transacted-write operations.
 * Opens a random-access stream to the file that can be used for transacted-write operations with the specified options.
 * @param {Windows.Storage.StorageOpenOptions=} options A bitwise combination of the enumeration values that specify options for opening the stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageStreamTransaction, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageStreamTransaction>>} When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
 */
Windows.Storage.BulkAccess.FileInformation.prototype.openTransactedWriteAsync = function(options) {};

/**
 * Renames the StorageFile .
 * Renames the StorageFile , and specifies what to do if a file with the same name already exists in the current folder.
 * @param {string} desiredName The new name.
 * @param {Windows.Storage.NameCollisionOption=} option A value that indicates what to do if the file name already exists in the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.BulkAccess.FileInformation.prototype.renameAsync = function(desiredName, option) {};

/**
 * @constructor
 * @struct
 * Creates a new FileInformationFactory object that retrieves information about the StorageFile and StorageFolder objects in the specified query result, specifies the requested size and options for thumbnails that are retrieved for the objects, and indicates whether to delay loading information.
 * Creates a new FileInformationFactory object that retrieves information about the StorageFile and StorageFolder objects in the specified query result, and that specifies the requested size and options for thumbnails that are retrieved for the objects.
 * Creates a new FileInformationFactory object that retrieves information about the StorageFile and StorageFolder objects in the specified query result and that specifies the requested size for thumbnails that are retrieved for the objects.
 * Creates a new FileInformationFactory object that retrieves information about the StorageFile and StorageFolder objects in the specified query result.
 * @param {!Windows.Storage.Search.IStorageQueryResultBase} queryResult The result of a query of files and folders on the system.
 * @param {Windows.Storage.FileProperties.ThumbnailMode} mode A value that indicates the type of thumbnail view to retrieve for the StorageFile and StorageFolder .
 * @param {number=} requestedThumbnailSize The requested minimum size, in pixels, of the StorageFile and StorageFolder thumbnails.
 * @param {Windows.Storage.FileProperties.ThumbnailOptions=} thumbnailOptions The thumbnail retrieval options.
 * @param {boolean=} delayLoad True to delay loading information; otherwise false. By default, this option is false and delay loading is not used.
 */
Windows.Storage.BulkAccess.FileInformationFactory = function(queryResult, mode, requestedThumbnailSize, thumbnailOptions, delayLoad) {};

/**
 * Retrieves a collection of FileInformation objects that contain information about a range of StorageFile objects in a collection.
 * Retrieves a collection of FileInformation objects that contain information about all StorageFile objects in a collection.
 * @param {number=} startIndex The zero-based index of the first StorageFile in the range.
 * @param {number=} maxItemsToRetrieve The maximum number of StorageFile objects to retrieve information for.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns the list (type IVectorView ) of FileInformation objects.
 */
Windows.Storage.BulkAccess.FileInformationFactory.prototype.getFilesAsync = function(startIndex, maxItemsToRetrieve) {};

/**
 * Retrieves a collection of FolderInformation objects that contain information about a range of StorageFolder objects in a collection.
 * Retrieves a collection of FolderInformation objects that contain information about all StorageFolder objects in a collection.
 * @param {number=} startIndex The zero-based index of the first StorageFolder in the range.
 * @param {number=} maxItemsToRetrieve The maximum number of StorageFolder objects to retrieve information for.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns the list (type IVectorView ) of FolderInformation objects.
 */
Windows.Storage.BulkAccess.FileInformationFactory.prototype.getFoldersAsync = function(startIndex, maxItemsToRetrieve) {};

/**
 * Retrieves a collection of IStorageItemInformation objects that contain information about all the items in the collection.
 * Retrieves a collection of IStorageItemInformation objects that contain information about a range of items in a collection.
 * @param {number=} startIndex The zero-based index of the first item in the range.
 * @param {number=} maxItemsToRetrieve The maximum number of items to retrieve information for.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns the list (type IVectorView ) of FileInformation and FolderInformation objects.
 */
Windows.Storage.BulkAccess.FileInformationFactory.prototype.getItemsAsync = function(startIndex, maxItemsToRetrieve) {};

/**
 * Gets a virtualized vector of IStorageItemInformation objects that can be bound to ListView or GridView controls in C#, C++, and VB.
 * @return {?} The virtualized vector of IStorageItemInformation objects.
 */
Windows.Storage.BulkAccess.FileInformationFactory.prototype.getVirtualizedFilesVector = function() {};

/**
 * Gets a virtualized vector of IStorageItemInformation objects that can be bound to ListView or GridView controls in C#, C++, and VB.
 * @return {?} The virtualized vector of IStorageItemInformation objects.
 */
Windows.Storage.BulkAccess.FileInformationFactory.prototype.getVirtualizedFoldersVector = function() {};

/**
 * Gets a virtualized vector of IStorageItemInformation objects that can be bound to ListView or GridView controls in C#, C++, and VB.
 * @return {?} The virtualized vector of IStorageItemInformation objects.
 */
Windows.Storage.BulkAccess.FileInformationFactory.prototype.getVirtualizedItemsVector = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.BulkAccess.FolderInformation = function() {};
 /** @type {Windows.Storage.FileAttributes} */
Windows.Storage.BulkAccess.FolderInformation.prototype.attributes;
 /** @type {!Windows.Storage.FileProperties.BasicProperties} */
Windows.Storage.BulkAccess.FolderInformation.prototype.basicProperties;
 /** @type {!Date} */
Windows.Storage.BulkAccess.FolderInformation.prototype.dateCreated;
 /** @type {string} */
Windows.Storage.BulkAccess.FolderInformation.prototype.displayName;
 /** @type {string} */
Windows.Storage.BulkAccess.FolderInformation.prototype.displayType;
 /** @type {!Windows.Storage.FileProperties.DocumentProperties} */
Windows.Storage.BulkAccess.FolderInformation.prototype.documentProperties;
 /** @type {string} */
Windows.Storage.BulkAccess.FolderInformation.prototype.folderRelativeId;
 /** @type {!Windows.Storage.FileProperties.ImageProperties} */
Windows.Storage.BulkAccess.FolderInformation.prototype.imageProperties;
 /** @type {!Windows.Storage.FileProperties.MusicProperties} */
Windows.Storage.BulkAccess.FolderInformation.prototype.musicProperties;
 /** @type {string} */
Windows.Storage.BulkAccess.FolderInformation.prototype.name;
 /** @type {function(?): void} */
Windows.Storage.BulkAccess.FolderInformation.prototype.onpropertiesupdated;
 /** @type {function(?): void} */
Windows.Storage.BulkAccess.FolderInformation.prototype.onthumbnailupdated;
 /** @type {string} */
Windows.Storage.BulkAccess.FolderInformation.prototype.path;
 /** @type {!Windows.Storage.FileProperties.StorageItemContentProperties} */
Windows.Storage.BulkAccess.FolderInformation.prototype.properties;
 /** @type {!Windows.Storage.StorageProvider} */
Windows.Storage.BulkAccess.FolderInformation.prototype.provider;
 /** @type {!Windows.Storage.FileProperties.StorageItemThumbnail} */
Windows.Storage.BulkAccess.FolderInformation.prototype.thumbnail;
 /** @type {!Windows.Storage.FileProperties.VideoProperties} */
Windows.Storage.BulkAccess.FolderInformation.prototype.videoProperties;

/**
 * Retrieves a value that indicates whether the folder supports the specified search query options.
 * @param {!Windows.Storage.Search.QueryOptions} queryOptions The search query options to test.
 * @return {boolean} True if the folder supports the specified search query options; otherwise false.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.areQueryOptionsSupported = function(queryOptions) {};

/**
 * Creates a new file in the current folder.
 * Creates a new file in the current folder, and specifies what to do if a file with the same name already exists in the current folder.
 * @param {string} desiredName The name of the new file.
 * @param {Windows.Storage.CreationCollisionOption=} options A value that indicates what to do if the file name already exists in the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes successfully, it returns a StorageFile that represents the new file.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.createFileAsync = function(desiredName, options) {};

/**
 * Creates an object for performing filtered search queries for StorageFile in the current folder.
 * Creates an object for performing filtered search queries for StorageFile objects in the current folder. Search results are grouped based on the specified file attribute.
 * @param {Windows.Storage.Search.CommonFileQuery=} query A value that specifies the folder attribute to use to group the search results.
 * @return {!Windows.Storage.Search.StorageFileQueryResult} An object for managing the search queries and accessing the results.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.createFileQuery = function(query) {};

/**
 * Creates an object used to perform filtered search queries for StorageFile objects in the folder. The object is initialized with the specified query options.
 * @param {!Windows.Storage.Search.QueryOptions} queryOptions The initial query options.
 * @return {!Windows.Storage.Search.StorageFileQueryResult} An object for managing the search queries and accessing the results.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.createFileQueryWithOptions = function(queryOptions) {};

/**
 * Creates a new child folder of the current folder, and specifies what to do if a folder with the same name already exists in the current folder.
 * Creates a new child folder of the current folder.
 * @param {string} desiredName The name of the new folder.
 * @param {Windows.Storage.CreationCollisionOption=} options A value that indicates what to do if the child folder already exists in the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes successfully, it returns a StorageFolder that represents the new file.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.createFolderAsync = function(desiredName, options) {};

/**
 * Creates an object for performing filtered search queries for child StorageFolder objects of the current folder.
 * Creates an object for performing filtered search queries for child StorageFolder objects of the current folder. Search results are grouped based on the specified folder attribute.
 * @param {Windows.Storage.Search.CommonFolderQuery=} query A value that specifies the folder attribute to use to group the search results.
 * @return {!Windows.Storage.Search.StorageFolderQueryResult} An object for managing the search queries and accessing the results.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.createFolderQuery = function(query) {};

/**
 * Creates an object used to perform filtered search queries for child StorageFolder objects of the current folder. The object is initialized with the specified query options.
 * @param {!Windows.Storage.Search.QueryOptions} queryOptions The initial query options.
 * @return {!Windows.Storage.Search.StorageFolderQueryResult} An object for managing the search queries and accessing the results.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.createFolderQueryWithOptions = function(queryOptions) {};

/**
 * Creates an object used to perform filtered search queries for items in the folder.
 * @return {!Windows.Storage.Search.StorageItemQueryResult} An object for managing the search queries and accessing the results.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.createItemQuery = function() {};

/**
 * Creates an object used to perform filtered search queries for items in the folder. The object is initialized with the specified query options.
 * @param {!Windows.Storage.Search.QueryOptions} queryOptions The initial query options.
 * @return {!Windows.Storage.Search.StorageItemQueryResult} An object for managing the search queries and accessing the results.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.createItemQueryWithOptions = function(queryOptions) {};

/**
 * Deletes the current folder.
 * Deletes the current folder, optionally moving the deleted folder to the recycle bin.
 * @param {Windows.Storage.StorageDeleteOption=} option A value that specifies whether to move the deleted folder to the recycle bin.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.deleteAsync = function(option) {};

/**
 * Retrieves the basic properties of the StorageFolder object.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.BasicProperties, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.BasicProperties>>} When this method completes successfully, it returns a BasicProperties object.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.getBasicPropertiesAsync = function() {};

/**
 * Retrieves a file from the current folder.
 * @param {string} name The name of the file to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes successfully, it returns a StorageFile .
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.getFileAsync = function(name) {};

/**
 * Retrieves all files from the current folder.
 * Retrieves files from the current folder based on a common folder query.
 * Retrieves a range of files from the current folder based on a common file query.
 * @param {Windows.Storage.Search.CommonFileQuery=} query The common file query.
 * @param {number=} startIndex The zero-based index of the first file in the range.
 * @param {number=} maxItemsToRetrieve The maximum number of files to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns the list (type IVectorView ) of StorageFile objects in the folder.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.getFilesAsync = function(query, startIndex, maxItemsToRetrieve) {};

/**
 * Retrieves the specified child folder from the current folder.
 * @param {string} name The name of the child folder to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes successfully, it returns a StorageFolder that represents the specified child folder.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.getFolderAsync = function(name) {};

/**
 * Retrieves all child folders from the current folder.
 * Retrieves a range of child folders from the current folder based on a common folder query.
 * Retrieves child folders from the current folder based on a common folder query.
 * @param {Windows.Storage.Search.CommonFolderQuery=} query The common folder query.
 * @param {number=} startIndex The zero-based index of the first child folder in the range.
 * @param {number=} maxItemsToRetrieve The maximum number of child folders to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns the list (type IVectorView ) of child folders. Each child folder in this list is represented by a StorageFolder object.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.getFoldersAsync = function(query, startIndex, maxItemsToRetrieve) {};

/**
 * Retrieves the indexed state of the folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Storage.Search.IndexedState, !Windows.Foundation.IAsyncOperation<Windows.Storage.Search.IndexedState>>} When this method completes successfully, it returns an IndexedState enumeration value.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.getIndexedStateAsync = function() {};

/**
 * Retrieves an item from the folder.
 * @param {string} name The name of the item to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.IStorageItem, !Windows.Foundation.IAsyncOperation<!Windows.Storage.IStorageItem>>} When this method completes successfully, it returns the item (type IStorageItem ).
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.getItemAsync = function(name) {};

/**
 * Retrieves all items from the current folder.
 * Retrieves a range of items from the current folder.
 * @param {number=} startIndex The zero-based index of the first item in the range.
 * @param {number=} maxItemsToRetrieve The maximum number of items to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns the list (type IVectorView ) of items.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.getItemsAsync = function(startIndex, maxItemsToRetrieve) {};

/**
 * Gets the parent folder of the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes, it returns the parent folder as a StorageFolder .
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.getParentAsync = function() {};

/**
 * Retrieves the thumbnail that is associated with the StorageFolder , scaling it to the specified size.
 * Retrieves the thumbnail that is associated with the StorageFolder .
 * Retrieves the thumbnail that is associated with the StorageFolder , based on the specified options.
 * @param {Windows.Storage.FileProperties.ThumbnailMode} mode The thumbnail mode to retrieve.
 * @param {number=} requestedSize The requested size in pixels of thumbnail to retrieve.
 * @param {Windows.Storage.FileProperties.ThumbnailOptions=} options The thumbnail retrieval options.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.StorageItemThumbnail, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.StorageItemThumbnail>>} When this method completes successfully, it returns the thumbnail image as a StorageItemThumbnail object.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.getThumbnailAsync = function(mode, requestedSize, options) {};

/**
 * Retrieves a value that indicates whether the current folder supports the specified common file query.
 * @param {Windows.Storage.Search.CommonFileQuery} query The common file query to test.
 * @return {boolean} True if the folder supports the specified common file query; otherwise false.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.isCommonFileQuerySupported = function(query) {};

/**
 * Retrieves a value that indicates whether the current folder supports the specified common folder query.
 * @param {Windows.Storage.Search.CommonFolderQuery} query The common folder query to test.
 * @return {boolean} True if the folder supports the specified common folder query; otherwise false.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.isCommonFolderQuerySupported = function(query) {};

/**
 * Indicates whether the current folder is equal to the specified folder.
 * @param {!Windows.Storage.IStorageItem} item The IStorageItem object that represents the folder to compare against.
 * @return {boolean} Returns true if the current folder is equal to the specified folder; otherwise false.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.isEqual = function(item) {};

/**
 * Determines whether the loaded StorageFolder is the specified type.
 * @param {Windows.Storage.StorageItemTypes} type The type of item to check against.
 * @return {boolean} True if the loaded StorageFolder is the specified type; otherwise false.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.isOfType = function(type) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.removeEventListener = function(type, listener) {};

/**
 * Renames the StorageFolder .
 * Renames the StorageFolder , and specifies what to do if a folder with the same name already exists.
 * @param {string} desiredName The new name.
 * @param {Windows.Storage.NameCollisionOption=} option A value that indicates what to do if a folder with desiredName already exists.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.renameAsync = function(desiredName, option) {};

/**
 * Try to get a specific file or sub-folder from the current folder using the name of the file or folder to get.
 * @param {string} name The name (or path relative to the current folder) of the file or sub-folder to try to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.IStorageItem, !Windows.Foundation.IAsyncOperation<!Windows.Storage.IStorageItem>>} When this method completes successfully, it returns the file or folder (type IStorageItem ).
 */
Windows.Storage.BulkAccess.FolderInformation.prototype.tryGetItemAsync = function(name) {};
/**
 * @record
 * @struct
 */
Windows.Storage.BulkAccess.IStorageItemInformation = function() {};
 /** @type {!Windows.Storage.FileProperties.BasicProperties} */
Windows.Storage.BulkAccess.IStorageItemInformation.prototype.basicProperties;
 /** @type {!Windows.Storage.FileProperties.DocumentProperties} */
Windows.Storage.BulkAccess.IStorageItemInformation.prototype.documentProperties;
 /** @type {!Windows.Storage.FileProperties.ImageProperties} */
Windows.Storage.BulkAccess.IStorageItemInformation.prototype.imageProperties;
 /** @type {!Windows.Storage.FileProperties.MusicProperties} */
Windows.Storage.BulkAccess.IStorageItemInformation.prototype.musicProperties;
 /** @type {!Windows.Storage.FileProperties.StorageItemThumbnail} */
Windows.Storage.BulkAccess.IStorageItemInformation.prototype.thumbnail;
 /** @type {!Windows.Storage.FileProperties.VideoProperties} */
Windows.Storage.BulkAccess.IStorageItemInformation.prototype.videoProperties;
/**
 * @constructor
 * @struct
 */
Windows.Storage.CachedFileManager = function() {};

/**
 * Initiates updates for the specified file. This method contacts the app that provided the file to perform the updates.
 * @param {!Windows.Storage.IStorageFile} file The file to update.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Storage.Provider.FileUpdateStatus, !Windows.Foundation.IAsyncOperation<Windows.Storage.Provider.FileUpdateStatus>>} When this method completes, it returns a FileUpdateStatus enum value that describes the status of the updates to the file.
 */
Windows.Storage.CachedFileManager.completeUpdatesAsync = function(file) {};

/**
 * Lets apps defer real-time updates for a specified file.
 * @param {!Windows.Storage.IStorageFile} file The file to defer updates for.
 * @return {void}
 */
Windows.Storage.CachedFileManager.deferUpdates = function(file) {};
/** @const */
Windows.Storage.Compression = {};

/** @const */
Windows.Storage.Compression.CompressAlgorithm = {};
/** @const {number} */
Windows.Storage.Compression.CompressAlgorithm.invalidAlgorithm;
/** @const {number} */
Windows.Storage.Compression.CompressAlgorithm.nullAlgorithm;
/** @const {number} */
Windows.Storage.Compression.CompressAlgorithm.mszip;
/** @const {number} */
Windows.Storage.Compression.CompressAlgorithm.xpress;
/** @const {number} */
Windows.Storage.Compression.CompressAlgorithm.xpressHuff;
/** @const {number} */
Windows.Storage.Compression.CompressAlgorithm.lzms;

/**
 * @constructor
 * @struct
 * Creates an instance of a compressor.
 * Creates an instance of a compressor.
 * @param {!Windows.Storage.Streams.IOutputStream} underlyingStream The stream of compressed information to be written by the compressor.
 * @param {Windows.Storage.Compression.CompressAlgorithm=} algorithm The compression algorithm used by the compressor to write underlyingStream.
 * @param {number=} blockSize Size in bytes of the intermediate buffer used by the compression algorithm. A value of 0 specifies that the compression algorithm will use its default block size. Valid non-zero values for this parameter are 32Kb to 64Mb.
 */
Windows.Storage.Compression.Compressor = function(underlyingStream, algorithm, blockSize) {};

/**
 * Closes a Compressor object and synchronously discards any information in buffers. This will close the underlying stream as well unless the Compressor.Detach method has been used to detach the stream from the object. Subsequent calls on a closed object, except for Compressor.Close, will fail.
 * @return {void}
 */
Windows.Storage.Compression.Compressor.prototype.close = function() {};

/**
 * Detaches the underlying stream from the Compressor object so that the object can be closed using the Compressor.Close method without also closing the underlying stream.
 * @return {!Windows.Storage.Streams.IOutputStream} The stream of information.
 */
Windows.Storage.Compression.Compressor.prototype.detachStream = function() {};

/**
 * Finishes writing the compression stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The asynchronous operation.
 */
Windows.Storage.Compression.Compressor.prototype.finishAsync = function() {};

/**
 * Flushes the compression stream asynchronously.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The asynchronous operation.
 */
Windows.Storage.Compression.Compressor.prototype.flushAsync = function() {};

/**
 * Writes information to the compression stream asynchronously.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer that contains the information to be written to the stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The asynchronous operation.
 */
Windows.Storage.Compression.Compressor.prototype.writeAsync = function(buffer) {};

/**
 * @constructor
 * @struct
 * This method creates an instance of a decompressor.
 * @param {!Windows.Storage.Streams.IInputStream} underlyingStream The stream of compressed information to be read and decompressed by the decompressor.
 */
Windows.Storage.Compression.Decompressor = function(underlyingStream) {};

/**
 * Closes a Decompressor object and synchronously discards any information in buffers. This will close the underlying stream as well unless the Decompressor.Detach method has been used to detach the stream from the object. Subsequent calls on a closed object, except Decompressor.Close, will fail.
 * @return {void}
 */
Windows.Storage.Compression.Decompressor.prototype.close = function() {};

/**
 * Detaches the underlying stream from the Decompressor object so that the object can be closed using the Decompressor.Close method without also closing the underlying stream.
 * @return {!Windows.Storage.Streams.IInputStream} The stream of information.
 */
Windows.Storage.Compression.Decompressor.prototype.detachStream = function() {};

/**
 * Reads from the compression stream asynchronously.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer that contains the information to be read from the stream.
 * @param {number} count The number of bytes to read.
 * @param {Windows.Storage.Streams.InputStreamOptions} options Read options
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The asynchronous operation.
 */
Windows.Storage.Compression.Decompressor.prototype.readAsync = function(buffer, count, options) {};

/** @const */
Windows.Storage.CreationCollisionOption = {};
/** @const {number} */
Windows.Storage.CreationCollisionOption.generateUniqueName;
/** @const {number} */
Windows.Storage.CreationCollisionOption.replaceExisting;
/** @const {number} */
Windows.Storage.CreationCollisionOption.failIfExists;
/** @const {number} */
Windows.Storage.CreationCollisionOption.openIfExists;
/**
 * @constructor
 * @struct
 */
Windows.Storage.DownloadsFolder = function() {};

/**
 * Creates a new file inside the Downloads folder.
 * Creates a new file in the Downloads folder, and specifies what to do if a file with the same name already exists in the Downloads folder.
 * @param {string} desiredName The desired name of the file to create.
 * @param {Windows.Storage.CreationCollisionOption=} option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing file in the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns the new file as a StorageFile object.
 */
Windows.Storage.DownloadsFolder.createFileAsync = function(desiredName, option) {};

/**
 * Creates a new file inside the Downloads folder of a specific User .
 * Creates a new file in the Downloads folder of a specific User , and specifies what to do if a file with the same name already exists in the Downloads folder.
 * @param {!Windows.System.User} user The User for which the file is created.
 * @param {string} desiredName The desired name of the file to create.
 * @param {Windows.Storage.CreationCollisionOption=} option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing file in the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns the new file as a StorageFile object.
 */
Windows.Storage.DownloadsFolder.createFileForUserAsync = function(user, desiredName, option) {};

/**
 * Creates a new subfolder in the Downloads folder.
 * Creates a new subfolder in the Downloads folder, and specifies what to do if a subfolder with the same name already exists in the Downloads folder.
 * @param {string} desiredName The desired name of the subfolder to create.
 * @param {Windows.Storage.CreationCollisionOption=} option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing subfolder in the Downloads folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes, it returns the new subfolder as a StorageFolder .
 */
Windows.Storage.DownloadsFolder.createFolderAsync = function(desiredName, option) {};

/**
 * Creates a new subfolder inside the Downloads folder of a specific User .
 * Creates a new subfolder in the Downloads folder of a specific User , and specifies what to do if a subfolder with the same name already exists in the Downloads folder.
 * @param {!Windows.System.User} user The User for which the folder is created.
 * @param {string} desiredName The desired name of the subfolder to create.
 * @param {Windows.Storage.CreationCollisionOption=} option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing subfolder in the Downloads folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes, it returns the new subfolder as a StorageFolder .
 */
Windows.Storage.DownloadsFolder.createFolderForUserAsync = function(user, desiredName, option) {};

/** @const */
Windows.Storage.FileAccessMode = {};
/** @const {number} */
Windows.Storage.FileAccessMode.read;
/** @const {number} */
Windows.Storage.FileAccessMode.readWrite;

/** @const */
Windows.Storage.FileAttributes = {};
/** @const {number} */
Windows.Storage.FileAttributes.normal;
/** @const {number} */
Windows.Storage.FileAttributes.readOnly;
/** @const {number} */
Windows.Storage.FileAttributes.directory;
/** @const {number} */
Windows.Storage.FileAttributes.archive;
/** @const {number} */
Windows.Storage.FileAttributes.temporary;
/** @const {number} */
Windows.Storage.FileAttributes.locallyIncomplete;
/**
 * @constructor
 * @struct
 */
Windows.Storage.FileIO = function() {};

/**
 * Appends lines of text to the specified file.
 * Appends lines of text to the specified file using the specified character encoding.
 * @param {!Windows.Storage.IStorageFile} file The file that the lines are appended to.
 * @param {!Windows.Foundation.Collections.IIterable<string>} lines The list of text strings to append as lines.
 * @param {Windows.Storage.Streams.UnicodeEncoding=} encoding The character encoding of the file.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.FileIO.appendLinesAsync = function(file, lines, encoding) {};

/**
 * Appends text to the specified file.
 * Appends text to the specified file using the specified character encoding.
 * @param {!Windows.Storage.IStorageFile} file The file that the text is appended to.
 * @param {string} contents The text to append.
 * @param {Windows.Storage.Streams.UnicodeEncoding=} encoding The character encoding of the file.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.FileIO.appendTextAsync = function(file, contents, encoding) {};

/**
 * Reads the contents of the specified file and returns a buffer.
 * @param {!Windows.Storage.IStorageFile} file The file to read.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} When this method completes, it returns an object (type IBuffer ) that represents the contents of the file.
 */
Windows.Storage.FileIO.readBufferAsync = function(file) {};

/**
 * Reads the contents of the specified file and returns lines of text.
 * Reads the contents of the specified file using the specified character encoding and returns lines of text.
 * @param {!Windows.Storage.IStorageFile} file The file to read.
 * @param {Windows.Storage.Streams.UnicodeEncoding=} encoding The character encoding to use.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVector<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVector<?>>>} When this method completes successfully, it returns the contents of the file as a list (type IVector ) of lines of text. Each line of text in the list is represented by a String object.
 */
Windows.Storage.FileIO.readLinesAsync = function(file, encoding) {};

/**
 * Reads the contents of the specified file and returns text.
 * Reads the contents of the specified file using the specified character encoding and returns text.
 * @param {!Windows.Storage.IStorageFile} file The file to read.
 * @param {Windows.Storage.Streams.UnicodeEncoding=} encoding The character encoding to use.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} When this method completes successfully, it returns the contents of the file as a text string.
 */
Windows.Storage.FileIO.readTextAsync = function(file, encoding) {};

/**
 * Writes data from a buffer to the specified file.
 * @param {!Windows.Storage.IStorageFile} file The file that the buffer of data is written to.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer that contains the data to write.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.FileIO.writeBufferAsync = function(file, buffer) {};

/**
 * Writes an array of bytes of data to the specified file.
 * @param {!Windows.Storage.IStorageFile} file The file that the byte is written to.
 * @param {!Array<number>} buffer The array of bytes to write.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.FileIO.writeBytesAsync = function(file, buffer) {};

/**
 * Writes lines of text to the specified file.
 * Writes lines of text to the specified file using the specified character encoding.
 * @param {!Windows.Storage.IStorageFile} file The file that the lines are written to.
 * @param {!Windows.Foundation.Collections.IIterable<string>} lines The list of text strings to write as lines.
 * @param {Windows.Storage.Streams.UnicodeEncoding=} encoding The character encoding of the file.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.FileIO.writeLinesAsync = function(file, lines, encoding) {};

/**
 * Writes text to the specified file.
 * Writes text to the specified file using the specified character encoding.
 * @param {!Windows.Storage.IStorageFile} file The file that the text is written to.
 * @param {string} contents The text to write.
 * @param {Windows.Storage.Streams.UnicodeEncoding=} encoding The character encoding of the file.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.FileIO.writeTextAsync = function(file, contents, encoding) {};
/** @const */
Windows.Storage.FileProperties = {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.FileProperties.BasicProperties = function() {};
 /** @type {!Date} */
Windows.Storage.FileProperties.BasicProperties.prototype.dateModified;
 /** @type {!Date} */
Windows.Storage.FileProperties.BasicProperties.prototype.itemDate;
 /** @type {number} */
Windows.Storage.FileProperties.BasicProperties.prototype.size;

/**
 * Retrieves the specified properties associated with the item.
 * @param {!Windows.Foundation.Collections.IIterable<string>} propertiesToRetrieve A collection that contains the names of the properties to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IMap<?, ?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IMap<?, ?>>>} When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs.
 */
Windows.Storage.FileProperties.BasicProperties.prototype.retrievePropertiesAsync = function(propertiesToRetrieve) {};

/**
 * Saves the specified properties and values associated with the item.
 * Saves all properties associated with the item.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>=} propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.FileProperties.BasicProperties.prototype.savePropertiesAsync = function(propertiesToSave) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.FileProperties.DocumentProperties = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.FileProperties.DocumentProperties.prototype.author;
 /** @type {string} */
Windows.Storage.FileProperties.DocumentProperties.prototype.comment;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.FileProperties.DocumentProperties.prototype.keywords;
 /** @type {string} */
Windows.Storage.FileProperties.DocumentProperties.prototype.title;

/**
 * Retrieves the specified properties associated with the item.
 * @param {!Windows.Foundation.Collections.IIterable<string>} propertiesToRetrieve A collection that contains the names of the properties to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IMap<?, ?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IMap<?, ?>>>} An object for managing the asynchronous property retrieval operation.
 */
Windows.Storage.FileProperties.DocumentProperties.prototype.retrievePropertiesAsync = function(propertiesToRetrieve) {};

/**
 * Saves the specified properties and values associated with the item.
 * Saves all properties associated with the item.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>=} propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.FileProperties.DocumentProperties.prototype.savePropertiesAsync = function(propertiesToSave) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.FileProperties.GeotagHelper = function() {};

/**
 * Asynchronously retrieves a Geopoint representing the geographic metadata of a file, if present.
 * @param {!Windows.Storage.IStorageFile} file The file from which the geographic metadata is retrieved.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Devices.Geolocation.Geopoint, !Windows.Foundation.IAsyncOperation<!Windows.Devices.Geolocation.Geopoint>>} An asynchronous operation that returns a Geopoint on successful completion.
 */
Windows.Storage.FileProperties.GeotagHelper.getGeotagAsync = function(file) {};

/**
 * Asynchronously sets the geographic metadata of a file from the provided Geopoint .
 * @param {!Windows.Storage.IStorageFile} file The file into which the geographic metadata is set.
 * @param {!Windows.Devices.Geolocation.Geopoint} geopoint The Geopoint representing the geographic metadata to be set.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asynchronous action.
 */
Windows.Storage.FileProperties.GeotagHelper.setGeotagAsync = function(file, geopoint) {};

/**
 * Asynchronously sets the geographic metadata of a file to the device's current location using the provided Geolocator object.
 * @param {!Windows.Storage.IStorageFile} file The file into which the geographic metadata is set.
 * @param {!Windows.Devices.Geolocation.Geolocator} geolocator The Geolocator object that will be used to determine the device's current location.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} An asychronous action.
 */
Windows.Storage.FileProperties.GeotagHelper.setGeotagFromGeolocatorAsync = function(file, geolocator) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.FileProperties.ImageProperties = function() {};
 /** @type {string} */
Windows.Storage.FileProperties.ImageProperties.prototype.cameraManufacturer;
 /** @type {string} */
Windows.Storage.FileProperties.ImageProperties.prototype.cameraModel;
 /** @type {!Date} */
Windows.Storage.FileProperties.ImageProperties.prototype.dateTaken;
 /** @type {number} */
Windows.Storage.FileProperties.ImageProperties.prototype.height;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.FileProperties.ImageProperties.prototype.keywords;
 /** @type {number} */
Windows.Storage.FileProperties.ImageProperties.prototype.latitude;
 /** @type {number} */
Windows.Storage.FileProperties.ImageProperties.prototype.longitude;
 /** @type {Windows.Storage.FileProperties.PhotoOrientation} */
Windows.Storage.FileProperties.ImageProperties.prototype.orientation;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Storage.FileProperties.ImageProperties.prototype.peopleNames;
 /** @type {number} */
Windows.Storage.FileProperties.ImageProperties.prototype.rating;
 /** @type {string} */
Windows.Storage.FileProperties.ImageProperties.prototype.title;
 /** @type {number} */
Windows.Storage.FileProperties.ImageProperties.prototype.width;

/**
 * Retrieves the specified properties associated with the item.
 * @param {!Windows.Foundation.Collections.IIterable<string>} propertiesToRetrieve A collection that contains the names of the properties to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IMap<?, ?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IMap<?, ?>>>} When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs.
 */
Windows.Storage.FileProperties.ImageProperties.prototype.retrievePropertiesAsync = function(propertiesToRetrieve) {};

/**
 * Saves the specified properties and values associated with the item.
 * Saves all properties associated with the item.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>=} propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.FileProperties.ImageProperties.prototype.savePropertiesAsync = function(propertiesToSave) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.FileProperties.MusicProperties = function() {};
 /** @type {string} */
Windows.Storage.FileProperties.MusicProperties.prototype.album;
 /** @type {string} */
Windows.Storage.FileProperties.MusicProperties.prototype.albumArtist;
 /** @type {string} */
Windows.Storage.FileProperties.MusicProperties.prototype.artist;
 /** @type {number} */
Windows.Storage.FileProperties.MusicProperties.prototype.bitrate;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.FileProperties.MusicProperties.prototype.composers;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.FileProperties.MusicProperties.prototype.conductors;
 /** @type {number} */
Windows.Storage.FileProperties.MusicProperties.prototype.duration;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.FileProperties.MusicProperties.prototype.genre;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.FileProperties.MusicProperties.prototype.producers;
 /** @type {string} */
Windows.Storage.FileProperties.MusicProperties.prototype.publisher;
 /** @type {number} */
Windows.Storage.FileProperties.MusicProperties.prototype.rating;
 /** @type {string} */
Windows.Storage.FileProperties.MusicProperties.prototype.subtitle;
 /** @type {string} */
Windows.Storage.FileProperties.MusicProperties.prototype.title;
 /** @type {number} */
Windows.Storage.FileProperties.MusicProperties.prototype.trackNumber;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.FileProperties.MusicProperties.prototype.writers;
 /** @type {number} */
Windows.Storage.FileProperties.MusicProperties.prototype.year;

/**
 * Retrieves the specified properties associated with the item.
 * @param {!Windows.Foundation.Collections.IIterable<string>} propertiesToRetrieve A collection that contains the names of the properties to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IMap<?, ?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IMap<?, ?>>>} When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs.
 */
Windows.Storage.FileProperties.MusicProperties.prototype.retrievePropertiesAsync = function(propertiesToRetrieve) {};

/**
 * Saves the specified properties and values associated with the item.
 * Saves all properties associated with the item.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>=} propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.FileProperties.MusicProperties.prototype.savePropertiesAsync = function(propertiesToSave) {};

/** @const */
Windows.Storage.FileProperties.PhotoOrientation = {};
/** @const {number} */
Windows.Storage.FileProperties.PhotoOrientation.unspecified;
/** @const {number} */
Windows.Storage.FileProperties.PhotoOrientation.normal;
/** @const {number} */
Windows.Storage.FileProperties.PhotoOrientation.flipHorizontal;
/** @const {number} */
Windows.Storage.FileProperties.PhotoOrientation.rotate180;
/** @const {number} */
Windows.Storage.FileProperties.PhotoOrientation.flipVertical;
/** @const {number} */
Windows.Storage.FileProperties.PhotoOrientation.transpose;
/** @const {number} */
Windows.Storage.FileProperties.PhotoOrientation.rotate270;
/** @const {number} */
Windows.Storage.FileProperties.PhotoOrientation.transverse;
/** @const {number} */
Windows.Storage.FileProperties.PhotoOrientation.rotate90;

/** @const */
Windows.Storage.FileProperties.PropertyPrefetchOptions = {};
/** @const {number} */
Windows.Storage.FileProperties.PropertyPrefetchOptions.none;
/** @const {number} */
Windows.Storage.FileProperties.PropertyPrefetchOptions.musicProperties;
/** @const {number} */
Windows.Storage.FileProperties.PropertyPrefetchOptions.videoProperties;
/** @const {number} */
Windows.Storage.FileProperties.PropertyPrefetchOptions.imageProperties;
/** @const {number} */
Windows.Storage.FileProperties.PropertyPrefetchOptions.documentProperties;
/** @const {number} */
Windows.Storage.FileProperties.PropertyPrefetchOptions.basicProperties;
/**
 * @constructor
 * @struct
 */
Windows.Storage.FileProperties.StorageItemContentProperties = function() {};

/**
 * Retrieves the document properties of the item (like a file of folder).
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.DocumentProperties, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.DocumentProperties>>} When this method completes successfully, it returns a documentProperties object.
 */
Windows.Storage.FileProperties.StorageItemContentProperties.prototype.getDocumentPropertiesAsync = function() {};

/**
 * Retrieves the image properties of the item (like a file of folder).
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.ImageProperties, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.ImageProperties>>} When this method completes successfully, it returns an imageProperties object.
 */
Windows.Storage.FileProperties.StorageItemContentProperties.prototype.getImagePropertiesAsync = function() {};

/**
 * Retrieves the music properties of the item (like a file of folder).
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.MusicProperties, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.MusicProperties>>} When this method completes successfully, it returns a musicProperties object.
 */
Windows.Storage.FileProperties.StorageItemContentProperties.prototype.getMusicPropertiesAsync = function() {};

/**
 * Retrieves the video properties of the item (like a file of folder).
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.VideoProperties, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.VideoProperties>>} When this method completes successfully, it returns a videoProperties object.
 */
Windows.Storage.FileProperties.StorageItemContentProperties.prototype.getVideoPropertiesAsync = function() {};

/**
 * Retrieves the specified properties associated with the item.
 * @param {!Windows.Foundation.Collections.IIterable<string>} propertiesToRetrieve A collection that contains the names of the properties to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IMap<?, ?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IMap<?, ?>>>} When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs. The return value of properties can be null.
 */
Windows.Storage.FileProperties.StorageItemContentProperties.prototype.retrievePropertiesAsync = function(propertiesToRetrieve) {};

/**
 * Saves all properties associated with the item.
 * Saves the specified properties and values associated with the item.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>=} propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.FileProperties.StorageItemContentProperties.prototype.savePropertiesAsync = function(propertiesToSave) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.FileProperties.StorageItemThumbnail = function() {};
 /** @type {boolean} */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.canRead;
 /** @type {boolean} */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.canWrite;
 /** @type {string} */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.contentType;
 /** @type {number} */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.originalHeight;
 /** @type {number} */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.originalWidth;
 /** @type {number} */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.position;
 /** @type {boolean} */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.returnedSmallerCachedSize;
 /** @type {number} */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.size;
 /** @type {Windows.Storage.FileProperties.ThumbnailType} */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.type;

/**
 * Creates a new stream over the thumbnail that is represented by the current storageItemThumbnail object.
 * @return {!Windows.Storage.Streams.IRandomAccessStream} The new thumbnail stream. The initial, internal position of the stream is 0.
 */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.cloneStream = function() {};

/**
 * Releases system resources that are exposed by a Windows Runtime object.
 * @return {void}
 */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.close = function() {};

/**
 * Flushes data asynchronously in a sequential stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The stream flush operation.
 */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.flushAsync = function() {};

/**
 * Retrieves the thumbnail image data as an undecoded stream.
 * @param {number} position The position in the storage item to start reading thumbnail image data.
 * @return {!Windows.Storage.Streams.IInputStream} An object for reading the thumbnail image data.
 */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.getInputStreamAt = function(position) {};

/**
 * Retrieves an output stream object for writing thumbnail image data to a storage item.
 * @param {number} position The position in the storage item to start writing thumbnail image data.
 * @return {!Windows.Storage.Streams.IOutputStream} The output stream.
 */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.getOutputStreamAt = function(position) {};

/**
 * Returns an asynchronous byte reader object.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param {number} count The number of bytes to read that is less than or equal to the Capacity value.
 * @param {Windows.Storage.Streams.InputStreamOptions} options Specifies the type of the asynchronous read operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The asynchronous operation.
 */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.readAsync = function(buffer, count, options) {};

/**
 * Sets the offset of the thumbnail stream to the specified value.
 * @param {number} position The number of bytes from the start of the thumbnail stream where the position of the thumbnail stream is set.
 * @return {void}
 */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.seek = function(position) {};

/**
 * Writes data asynchronously in a sequential stream.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous writer operation writes.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The byte writer operation.
 */
Windows.Storage.FileProperties.StorageItemThumbnail.prototype.writeAsync = function(buffer) {};

/** @const */
Windows.Storage.FileProperties.ThumbnailMode = {};
/** @const {number} */
Windows.Storage.FileProperties.ThumbnailMode.picturesView;
/** @const {number} */
Windows.Storage.FileProperties.ThumbnailMode.videosView;
/** @const {number} */
Windows.Storage.FileProperties.ThumbnailMode.musicView;
/** @const {number} */
Windows.Storage.FileProperties.ThumbnailMode.documentsView;
/** @const {number} */
Windows.Storage.FileProperties.ThumbnailMode.listView;
/** @const {number} */
Windows.Storage.FileProperties.ThumbnailMode.singleItem;

/** @const */
Windows.Storage.FileProperties.ThumbnailOptions = {};
/** @const {number} */
Windows.Storage.FileProperties.ThumbnailOptions.none;
/** @const {number} */
Windows.Storage.FileProperties.ThumbnailOptions.returnOnlyIfCached;
/** @const {number} */
Windows.Storage.FileProperties.ThumbnailOptions.resizeThumbnail;
/** @const {number} */
Windows.Storage.FileProperties.ThumbnailOptions.useCurrentScale;

/** @const */
Windows.Storage.FileProperties.ThumbnailType = {};
/** @const {number} */
Windows.Storage.FileProperties.ThumbnailType.image;
/** @const {number} */
Windows.Storage.FileProperties.ThumbnailType.icon;

/** @const */
Windows.Storage.FileProperties.VideoOrientation = {};
/** @const {number} */
Windows.Storage.FileProperties.VideoOrientation.normal;
/** @const {number} */
Windows.Storage.FileProperties.VideoOrientation.rotate90;
/** @const {number} */
Windows.Storage.FileProperties.VideoOrientation.rotate180;
/** @const {number} */
Windows.Storage.FileProperties.VideoOrientation.rotate270;
/**
 * @constructor
 * @struct
 */
Windows.Storage.FileProperties.VideoProperties = function() {};
 /** @type {number} */
Windows.Storage.FileProperties.VideoProperties.prototype.bitrate;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.FileProperties.VideoProperties.prototype.directors;
 /** @type {number} */
Windows.Storage.FileProperties.VideoProperties.prototype.duration;
 /** @type {number} */
Windows.Storage.FileProperties.VideoProperties.prototype.height;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.FileProperties.VideoProperties.prototype.keywords;
 /** @type {number} */
Windows.Storage.FileProperties.VideoProperties.prototype.latitude;
 /** @type {number} */
Windows.Storage.FileProperties.VideoProperties.prototype.longitude;
 /** @type {Windows.Storage.FileProperties.VideoOrientation} */
Windows.Storage.FileProperties.VideoProperties.prototype.orientation;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.FileProperties.VideoProperties.prototype.producers;
 /** @type {string} */
Windows.Storage.FileProperties.VideoProperties.prototype.publisher;
 /** @type {number} */
Windows.Storage.FileProperties.VideoProperties.prototype.rating;
 /** @type {string} */
Windows.Storage.FileProperties.VideoProperties.prototype.subtitle;
 /** @type {string} */
Windows.Storage.FileProperties.VideoProperties.prototype.title;
 /** @type {number} */
Windows.Storage.FileProperties.VideoProperties.prototype.width;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.FileProperties.VideoProperties.prototype.writers;
 /** @type {number} */
Windows.Storage.FileProperties.VideoProperties.prototype.year;

/**
 * Retrieves the specified properties associated with the item.
 * @param {!Windows.Foundation.Collections.IIterable<string>} propertiesToRetrieve A collection that contains the names of the properties to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IMap<?, ?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IMap<?, ?>>>} When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs.
 */
Windows.Storage.FileProperties.VideoProperties.prototype.retrievePropertiesAsync = function(propertiesToRetrieve) {};

/**
 * Saves the specified properties and values associated with the item.
 * Saves all properties associated with the item.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>=} propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.FileProperties.VideoProperties.prototype.savePropertiesAsync = function(propertiesToSave) {};

/** @const */
Windows.Storage.KnownFolderId = {};
/** @const {number} */
Windows.Storage.KnownFolderId.appCaptures;
/** @const {number} */
Windows.Storage.KnownFolderId.cameraRoll;
/** @const {number} */
Windows.Storage.KnownFolderId.documentsLibrary;
/** @const {number} */
Windows.Storage.KnownFolderId.homeGroup;
/** @const {number} */
Windows.Storage.KnownFolderId.mediaServerDevices;
/** @const {number} */
Windows.Storage.KnownFolderId.musicLibrary;
/** @const {number} */
Windows.Storage.KnownFolderId.objects3D;
/** @const {number} */
Windows.Storage.KnownFolderId.picturesLibrary;
/** @const {number} */
Windows.Storage.KnownFolderId.playlists;
/** @const {number} */
Windows.Storage.KnownFolderId.recordedCalls;
/** @const {number} */
Windows.Storage.KnownFolderId.removableDevices;
/** @const {number} */
Windows.Storage.KnownFolderId.savedPictures;
/** @const {number} */
Windows.Storage.KnownFolderId.screenshots;
/** @const {number} */
Windows.Storage.KnownFolderId.videosLibrary;
/**
 * @constructor
 * @struct
 */
Windows.Storage.KnownFolders = function() {};
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.KnownFolders.appCaptures;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.KnownFolders.cameraRoll;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.KnownFolders.documentsLibrary;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.KnownFolders.homeGroup;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.KnownFolders.mediaServerDevices;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.KnownFolders.musicLibrary;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.KnownFolders.objects3D;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.KnownFolders.picturesLibrary;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.KnownFolders.playlists;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.KnownFolders.recordedCalls;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.KnownFolders.removableDevices;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.KnownFolders.savedPictures;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.KnownFolders.videosLibrary;

/**
 * Static method that returns a specified known folder for a User .
 * @param {!Windows.System.User} user The User for which the folder is returned.
 * @param {Windows.Storage.KnownFolderId} folderId The ID of the folder to be returned.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes, it returns the requested StorageFolder object.
 */
Windows.Storage.KnownFolders.getFolderForUserAsync = function(user, folderId) {};

/** @const */
Windows.Storage.KnownLibraryId = {};
/** @const {number} */
Windows.Storage.KnownLibraryId.music;
/** @const {number} */
Windows.Storage.KnownLibraryId.pictures;
/** @const {number} */
Windows.Storage.KnownLibraryId.videos;
/** @const {number} */
Windows.Storage.KnownLibraryId.documents;

/** @const */
Windows.Storage.NameCollisionOption = {};
/** @const {number} */
Windows.Storage.NameCollisionOption.generateUniqueName;
/** @const {number} */
Windows.Storage.NameCollisionOption.replaceExisting;
/** @const {number} */
Windows.Storage.NameCollisionOption.failIfExists;
/**
 * @constructor
 * @struct
 */
Windows.Storage.PathIO = function() {};

/**
 * Appends lines of text to the file at the specified path or URI using the specified character encoding.
 * Appends lines of text to the file at the specified path or URI.
 * @param {string} absolutePath The path of the file that the lines are appended to. / The path or URI of the file that the lines are appended to.
 * @param {!Windows.Foundation.Collections.IIterable<string>} lines The list of text strings to append as lines.
 * @param {Windows.Storage.Streams.UnicodeEncoding=} encoding The character encoding of the file.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.PathIO.appendLinesAsync = function(absolutePath, lines, encoding) {};

/**
 * Appends text to the file at the specified path or URI using the specified character encoding.
 * Appends text to the file at the specified path or URI.
 * @param {string} absolutePath The path of the file that the text is appended to.
 * @param {string} contents The text to append.
 * @param {Windows.Storage.Streams.UnicodeEncoding=} encoding The character encoding of the file.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.PathIO.appendTextAsync = function(absolutePath, contents, encoding) {};

/**
 * Reads the contents of the file at the specified path or URI and returns a buffer.
 * @param {string} absolutePath The path of the file to read.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IBuffer>>} When this method completes, it returns an object (type IBuffer ) that represents the contents of the file.
 */
Windows.Storage.PathIO.readBufferAsync = function(absolutePath) {};

/**
 * Reads the contents of the file at the specified path or URI and returns lines of text.
 * Reads the contents of the file at the specified path or URI using the specified character encoding and returns lines of text.
 * @param {string} absolutePath The path of the file to read.
 * @param {Windows.Storage.Streams.UnicodeEncoding=} encoding The character encoding of the file.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVector<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVector<?>>>} When this method completes successfully, it returns the contents of the file as a list (type IVector ) of lines of text. Each line of text in the list is represented by a String object.
 */
Windows.Storage.PathIO.readLinesAsync = function(absolutePath, encoding) {};

/**
 * Reads the contents of the file at the specified path or URI and returns text.
 * Reads the contents of the file at the specified path or URI using the specified character encoding and returns text.
 * @param {string} absolutePath The path of the file to read.
 * @param {Windows.Storage.Streams.UnicodeEncoding=} encoding The character encoding of the file.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} When this method completes successfully, it returns the contents of the file as a text string.
 */
Windows.Storage.PathIO.readTextAsync = function(absolutePath, encoding) {};

/**
 * Writes data from a buffer to the file at the specified path or URI.
 * @param {string} absolutePath The path of the file that the data is written to.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer that contains the data to write.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.PathIO.writeBufferAsync = function(absolutePath, buffer) {};

/**
 * Writes a single byte of data to the file at the specified path or URI.
 * @param {string} absolutePath The path of the file that the byte is written to.
 * @param {!Array<number>} buffer An array of bytes to write.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.PathIO.writeBytesAsync = function(absolutePath, buffer) {};

/**
 * Writes lines of text to the file at the specified path or URI using the specified character encoding.
 * Writes lines of text to the file at the specified path or URI.
 * @param {string} absolutePath The path of the file that the lines are appended to. / The path of the file that the lines are written to.
 * @param {!Windows.Foundation.Collections.IIterable<string>} lines The list of text strings to append as lines.
 * @param {Windows.Storage.Streams.UnicodeEncoding=} encoding The character encoding of the file.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.PathIO.writeLinesAsync = function(absolutePath, lines, encoding) {};

/**
 * Writes text to the file at the specified path or URI.
 * Writes text to the file at the specified path or URI using the specified character encoding.
 * @param {string} absolutePath The path of the file that the text is written to.
 * @param {string} contents The text to write.
 * @param {Windows.Storage.Streams.UnicodeEncoding=} encoding The character encoding of the file.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.PathIO.writeTextAsync = function(absolutePath, contents, encoding) {};
/** @const */
Windows.Storage.Pickers = {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Pickers.FileExtensionVector = function() {};
 /** @type {number} */
Windows.Storage.Pickers.FileExtensionVector.prototype.size;

/**
 * Appends a file name extension to the end of the collection.
 * @param {string} value The file name extension to append.
 * @return {void}
 */
Windows.Storage.Pickers.FileExtensionVector.prototype.append = function(value) {};

/**
 * Removes all file name extensions from the collection.
 * @return {void}
 */
Windows.Storage.Pickers.FileExtensionVector.prototype.clear = function() {};

/**
 * Retrieves an iterator that iterates through the file name extensions in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<string>} The iterator.
 */
Windows.Storage.Pickers.FileExtensionVector.prototype.first = function() {};

/**
 * Retrieves the file name extension at the specified index in the collection.
 * @param {number} index The zero-based index of the file name extension to retrieve.
 * @return {string} The file name extension at the specified index.
 */
Windows.Storage.Pickers.FileExtensionVector.prototype.getAt = function(index) {};

/**
 * Retrieves the file name extensions that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the file name extensions in the collection to retrieve.
 * @return {{items: !Array<string>, returnValue: number}}
 */
Windows.Storage.Pickers.FileExtensionVector.prototype.getMany = function(startIndex) {};

/**
 * Retrieves an immutable view of the collection of file name extensions.
 * @return {!Windows.Foundation.Collections.IVectorView<string>} The view of the collection.
 */
Windows.Storage.Pickers.FileExtensionVector.prototype.getView = function() {};

/**
 * Retrieves the index of a specified file name extension in the collection.
 * @param {string} value_or_searchElement The file name extension to find in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Storage.Pickers.FileExtensionVector.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts a file name extension into a collection at a specified index.
 * @param {number} index Zero-based index of the location at which to insert the file name extension.
 * @param {string} value The file name extension to insert.
 * @return {void}
 */
Windows.Storage.Pickers.FileExtensionVector.prototype.insertAt = function(index, value) {};

/**
 * Removes the file name extension at the specified index in the collection.
 * @param {number} index The zero-based index of the file name extension to remove.
 * @return {void}
 */
Windows.Storage.Pickers.FileExtensionVector.prototype.removeAt = function(index) {};

/**
 * Removes the last file name extension from the collection.
 * @return {void}
 */
Windows.Storage.Pickers.FileExtensionVector.prototype.removeAtEnd = function() {};

/**
 * Replaces all file name extensions in the collection with the specified file name extensions.
 * @param {!Array<string>} items The collection of file name extensions to put in the vector.
 * @return {void}
 */
Windows.Storage.Pickers.FileExtensionVector.prototype.replaceAll = function(items) {};

/**
 * Sets the file name extension at the specified index of the collection.
 * @param {number} index The zero-based index of the location at which to set the file name extension.
 * @param {string} value The file name extension.
 * @return {void}
 */
Windows.Storage.Pickers.FileExtensionVector.prototype.setAt = function(index, value) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of a FileOpenPicker .
 */
Windows.Storage.Pickers.FileOpenPicker = function() {};
 /** @type {?} */
Windows.Storage.Pickers.FileOpenPicker.resumePickSingleFileAsync;
 /** @type {string} */
Windows.Storage.Pickers.FileOpenPicker.prototype.commitButtonText;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.Storage.Pickers.FileOpenPicker.prototype.continuationData;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.Pickers.FileOpenPicker.prototype.fileTypeFilter;
 /** @type {string} */
Windows.Storage.Pickers.FileOpenPicker.prototype.settingsIdentifier;
 /** @type {Windows.Storage.Pickers.PickerLocationId} */
Windows.Storage.Pickers.FileOpenPicker.prototype.suggestedStartLocation;
 /** @type {Windows.Storage.Pickers.PickerViewMode} */
Windows.Storage.Pickers.FileOpenPicker.prototype.viewMode;

/**
 * Shows the file picker so that the user can pick multiple files, deactivating and the app and reactivating it when the operation is complete. (Windows Phone Store apps)
 * @return {void}
 */
Windows.Storage.Pickers.FileOpenPicker.prototype.pickMultipleFilesAndContinue = function() {};

/**
 * Shows the file picker so that the user can pick multiple files. (Windows Store apps)
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When the call to this method completes successfully, it returns a filePickerSelectedFilesArray object that contains all the files that were picked by the user. Picked files in this array are represented by storageFile objects.
 */
Windows.Storage.Pickers.FileOpenPicker.prototype.pickMultipleFilesAsync = function() {};

/**
 * Shows the file picker so that the user can pick one file, potentially deactivating the app and reactivating it when the operation is complete. (Windows Phone Store apps)
 * @return {void}
 */
Windows.Storage.Pickers.FileOpenPicker.prototype.pickSingleFileAndContinue = function() {};

/**
 * Shows the file picker so that the user can pick one file.
 * Shows the file picker so that the user can pick one file.
 * @param {string=} pickerOperationId This argument is ignored and has no effect.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When the call to this method completes successfully, it returns a StorageFile object that represents the file that the user picked.
 */
Windows.Storage.Pickers.FileOpenPicker.prototype.pickSingleFileAsync = function(pickerOperationId) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Pickers.FilePickerFileTypesOrderedMap = function() {};
 /** @type {number} */
Windows.Storage.Pickers.FilePickerFileTypesOrderedMap.prototype.size;

/**
 * Removes all display names and associated file name extensions from the collection.
 * @return {void}
 */
Windows.Storage.Pickers.FilePickerFileTypesOrderedMap.prototype.clear = function() {};

/**
 * Retrieves an iterator that iterates through the display names and associated file types in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The iterator.
 */
Windows.Storage.Pickers.FilePickerFileTypesOrderedMap.prototype.first = function() {};

/**
 * Returns an immutable view of the collection of display names and associated file types.
 * @return {!Windows.Foundation.Collections.IMapView<string, !Windows.Foundation.Collections.IVector<string>>} The view of the collection.
 */
Windows.Storage.Pickers.FilePickerFileTypesOrderedMap.prototype.getView = function() {};

/**
 * Determines whether the mapped collection of display names and associated file types contains the specified key.
 * @param {string} key The key.
 * @return {boolean} True if the key is found; otherwise, false.
 */
Windows.Storage.Pickers.FilePickerFileTypesOrderedMap.prototype.hasKey = function(key) {};

/**
 * Inserts or replaces an item in the mapped collection of display names and associated file types.
 * @param {string} key The key associated with the item to insert.
 * @param {!Windows.Foundation.Collections.IVector<string>} value The item to insert.
 * @return {boolean} true if an item with the specified key is an existing item and was replaced; otherwise false.
 */
Windows.Storage.Pickers.FilePickerFileTypesOrderedMap.prototype.insert = function(key, value) {};

/**
 * Returns the item at the specified key in the mapped collection of display names and associated file types.
 * @param {string} key The key to use to locate the item.
 * @return {!Windows.Foundation.Collections.IVector<string>} The item associated with the specified key.
 */
Windows.Storage.Pickers.FilePickerFileTypesOrderedMap.prototype.lookup = function(key) {};

/**
 * Removes an item from the mapped collection of display names and associated file types.
 * @param {string} key The key associated with the item to remove.
 * @return {void}
 */
Windows.Storage.Pickers.FilePickerFileTypesOrderedMap.prototype.remove = function(key) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Pickers.FilePickerSelectedFilesArray = function() {};
 /** @type {number} */
Windows.Storage.Pickers.FilePickerSelectedFilesArray.prototype.size;

/**
 * Retrieves an iterator that iterates through the collection of StorageFile objects that represent selected files.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Storage.StorageFile>} The iterator.
 */
Windows.Storage.Pickers.FilePickerSelectedFilesArray.prototype.first = function() {};

/**
 * Returns the StorageFile object at the specified index in the collection.
 * @param {number} index The zero-based index of the object to retrieve.
 * @return {!Windows.Storage.StorageFile} The object at the specified index.
 */
Windows.Storage.Pickers.FilePickerSelectedFilesArray.prototype.getAt = function(index) {};

/**
 * Retrieves the StorageFile objects that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the objects in the collection to return.
 * @return {{items: !Windows.Storage.StorageFile, returnValue: number}}
 */
Windows.Storage.Pickers.FilePickerSelectedFilesArray.prototype.getMany = function(startIndex) {};

/**
 * Retrieves the index of a specified StorageFile object in the collection.
 * @param {!Windows.Storage.StorageFile} value_or_searchElement The object to find in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Storage.Pickers.FilePickerSelectedFilesArray.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of a FileSavePicker .
 */
Windows.Storage.Pickers.FileSavePicker = function() {};
 /** @type {string} */
Windows.Storage.Pickers.FileSavePicker.prototype.commitButtonText;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.Storage.Pickers.FileSavePicker.prototype.continuationData;
 /** @type {string} */
Windows.Storage.Pickers.FileSavePicker.prototype.defaultFileExtension;
 /** @type {string} */
Windows.Storage.Pickers.FileSavePicker.prototype.enterpriseId;
 /** @type {!Windows.Foundation.Collections.IMap<string, !Windows.Foundation.Collections.IVector<string>>} */
Windows.Storage.Pickers.FileSavePicker.prototype.fileTypeChoices;
 /** @type {string} */
Windows.Storage.Pickers.FileSavePicker.prototype.settingsIdentifier;
 /** @type {string} */
Windows.Storage.Pickers.FileSavePicker.prototype.suggestedFileName;
 /** @type {!Windows.Storage.StorageFile} */
Windows.Storage.Pickers.FileSavePicker.prototype.suggestedSaveFile;
 /** @type {Windows.Storage.Pickers.PickerLocationId} */
Windows.Storage.Pickers.FileSavePicker.prototype.suggestedStartLocation;

/**
 * Shows the file picker so that the user can save a file, deactivating and the app and reactivating it when the operation is complete. (Windows Phone Store apps)
 * @return {void}
 */
Windows.Storage.Pickers.FileSavePicker.prototype.pickSaveFileAndContinue = function() {};

/**
 * Shows the file picker so that the user can save a file and set the file name, extension, and location of the file to be saved. (Windows Store apps)
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When the call to this method completes successfully, it returns a storageFile object that was created to represent the saved file. The file name, extension, and location of this storageFile match those specified by the user, but the file has no content.
 */
Windows.Storage.Pickers.FileSavePicker.prototype.pickSaveFileAsync = function() {};

/**
 * @constructor
 * @struct
 * Creates a new instance of a FolderPicker .
 */
Windows.Storage.Pickers.FolderPicker = function() {};
 /** @type {string} */
Windows.Storage.Pickers.FolderPicker.prototype.commitButtonText;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.Storage.Pickers.FolderPicker.prototype.continuationData;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.Pickers.FolderPicker.prototype.fileTypeFilter;
 /** @type {string} */
Windows.Storage.Pickers.FolderPicker.prototype.settingsIdentifier;
 /** @type {Windows.Storage.Pickers.PickerLocationId} */
Windows.Storage.Pickers.FolderPicker.prototype.suggestedStartLocation;
 /** @type {Windows.Storage.Pickers.PickerViewMode} */
Windows.Storage.Pickers.FolderPicker.prototype.viewMode;

/**
 * Shows the file picker so that the user can pick a folder, deactivating and the app and reactivating it when the operation is complete. (Windows Phone Store apps)
 * @return {void}
 */
Windows.Storage.Pickers.FolderPicker.prototype.pickFolderAndContinue = function() {};

/**
 * Shows the folderPicker object so that the user can pick a folder. (Windows Store apps)
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When the call to this method completes successfully, it returns a storageFolder object that represents the folder that the user picked.
 */
Windows.Storage.Pickers.FolderPicker.prototype.pickSingleFolderAsync = function() {};

/** @const */
Windows.Storage.Pickers.PickerLocationId = {};
/** @const {number} */
Windows.Storage.Pickers.PickerLocationId.documentsLibrary;
/** @const {number} */
Windows.Storage.Pickers.PickerLocationId.computerFolder;
/** @const {number} */
Windows.Storage.Pickers.PickerLocationId.desktop;
/** @const {number} */
Windows.Storage.Pickers.PickerLocationId.downloads;
/** @const {number} */
Windows.Storage.Pickers.PickerLocationId.homeGroup;
/** @const {number} */
Windows.Storage.Pickers.PickerLocationId.musicLibrary;
/** @const {number} */
Windows.Storage.Pickers.PickerLocationId.picturesLibrary;
/** @const {number} */
Windows.Storage.Pickers.PickerLocationId.videosLibrary;
/** @const {number} */
Windows.Storage.Pickers.PickerLocationId.objects3D;
/** @const {number} */
Windows.Storage.Pickers.PickerLocationId.unspecified;

/** @const */
Windows.Storage.Pickers.PickerViewMode = {};
/** @const {number} */
Windows.Storage.Pickers.PickerViewMode.list;
/** @const {number} */
Windows.Storage.Pickers.PickerViewMode.thumbnail;
/** @const */
Windows.Storage.Pickers.Provider = {};

/** @const */
Windows.Storage.Pickers.Provider.AddFileResult = {};
/** @const {number} */
Windows.Storage.Pickers.Provider.AddFileResult.added;
/** @const {number} */
Windows.Storage.Pickers.Provider.AddFileResult.alreadyAdded;
/** @const {number} */
Windows.Storage.Pickers.Provider.AddFileResult.notAllowed;
/** @const {number} */
Windows.Storage.Pickers.Provider.AddFileResult.unavailable;
/**
 * @constructor
 * @struct
 */
Windows.Storage.Pickers.Provider.FileOpenPickerUI = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Storage.Pickers.Provider.FileOpenPickerUI.prototype.allowedFileTypes;
 /** @type {function(?): void} */
Windows.Storage.Pickers.Provider.FileOpenPickerUI.prototype.onclosing;
 /** @type {function(?): void} */
Windows.Storage.Pickers.Provider.FileOpenPickerUI.prototype.onfileremoved;
 /** @type {Windows.Storage.Pickers.Provider.FileSelectionMode} */
Windows.Storage.Pickers.Provider.FileOpenPickerUI.prototype.selectionMode;
 /** @type {string} */
Windows.Storage.Pickers.Provider.FileOpenPickerUI.prototype.settingsIdentifier;
 /** @type {string} */
Windows.Storage.Pickers.Provider.FileOpenPickerUI.prototype.title;

/**
 * Adds the specified file to the list of files that the user has chosen.
 * @param {string} id A unique identifier of the file to add.
 * @param {!Windows.Storage.IStorageFile} file The file to add to the list of files that the user has chosen.
 * @return {Windows.Storage.Pickers.Provider.AddFileResult} The enumeration value that indicates the result of this addFile method.
 */
Windows.Storage.Pickers.Provider.FileOpenPickerUI.prototype.addFile = function(id, file) {};

/**
 * Indicates whether the specified file can be added to the list of files the user has chosen.
 * @param {!Windows.Storage.IStorageFile} file The file to test.
 * @return {boolean} True if the file can be added to the file picker UI; otherwise false.
 */
Windows.Storage.Pickers.Provider.FileOpenPickerUI.prototype.canAddFile = function(file) {};

/**
 * Determines whether the specified file is in the list of files that the user has chosen.
 * @param {string} id The identifier of the file.
 * @return {boolean} True if the file is in the basket; otherwise false.
 */
Windows.Storage.Pickers.Provider.FileOpenPickerUI.prototype.containsFile = function(id) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.Pickers.Provider.FileOpenPickerUI.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.Pickers.Provider.FileOpenPickerUI.prototype.removeEventListener = function(type, listener) {};

/**
 * Removes the specified file from the list of files the user has chosen.
 * @param {string} id The identifier of the file to remove.
 * @return {void}
 */
Windows.Storage.Pickers.Provider.FileOpenPickerUI.prototype.removeFile = function(id) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Pickers.Provider.FileRemovedEventArgs = function() {};
 /** @type {string} */
Windows.Storage.Pickers.Provider.FileRemovedEventArgs.prototype.id;
/**
 * @constructor
 * @struct
 */
Windows.Storage.Pickers.Provider.FileSavePickerUI = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Storage.Pickers.Provider.FileSavePickerUI.prototype.allowedFileTypes;
 /** @type {string} */
Windows.Storage.Pickers.Provider.FileSavePickerUI.prototype.fileName;
 /** @type {function(?): void} */
Windows.Storage.Pickers.Provider.FileSavePickerUI.prototype.onfilenamechanged;
 /** @type {function(?): void} */
Windows.Storage.Pickers.Provider.FileSavePickerUI.prototype.ontargetfilerequested;
 /** @type {string} */
Windows.Storage.Pickers.Provider.FileSavePickerUI.prototype.settingsIdentifier;
 /** @type {string} */
Windows.Storage.Pickers.Provider.FileSavePickerUI.prototype.title;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.Pickers.Provider.FileSavePickerUI.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.Pickers.Provider.FileSavePickerUI.prototype.removeEventListener = function(type, listener) {};

/**
 * Tries to set the file name and extension in the file picker UI.
 * @param {string} value The file name and extension that are used to update the file name text box and file type drop-down menu in the file picker UI.
 * @return {Windows.Storage.Pickers.Provider.SetFileNameResult} The enumeration value that indicates whether the file name and extension were updated in the file picker UI.
 */
Windows.Storage.Pickers.Provider.FileSavePickerUI.prototype.trySetFileName = function(value) {};

/** @const */
Windows.Storage.Pickers.Provider.FileSelectionMode = {};
/** @const {number} */
Windows.Storage.Pickers.Provider.FileSelectionMode.single;
/** @const {number} */
Windows.Storage.Pickers.Provider.FileSelectionMode.multiple;
/**
 * @constructor
 * @struct
 */
Windows.Storage.Pickers.Provider.PickerClosingDeferral = function() {};

/**
 * Signals that the app providing files has finished responding to a closing event.
 * @return {void}
 */
Windows.Storage.Pickers.Provider.PickerClosingDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Pickers.Provider.PickerClosingEventArgs = function() {};
 /** @type {!Windows.Storage.Pickers.Provider.PickerClosingOperation} */
Windows.Storage.Pickers.Provider.PickerClosingEventArgs.prototype.closingOperation;
 /** @type {boolean} */
Windows.Storage.Pickers.Provider.PickerClosingEventArgs.prototype.isCanceled;
/**
 * @constructor
 * @struct
 */
Windows.Storage.Pickers.Provider.PickerClosingOperation = function() {};
 /** @type {!Date} */
Windows.Storage.Pickers.Provider.PickerClosingOperation.prototype.deadline;

/**
 * Gets a pickerClosingDeferral that the app providing files through the file picker can use to respond asynchronously to a closing event.
 * @return {!Windows.Storage.Pickers.Provider.PickerClosingDeferral} The pickerClosingDeferral that the app providing files through the file picker can use to respond asynchronously to a closing event.
 */
Windows.Storage.Pickers.Provider.PickerClosingOperation.prototype.getDeferral = function() {};

/** @const */
Windows.Storage.Pickers.Provider.SetFileNameResult = {};
/** @const {number} */
Windows.Storage.Pickers.Provider.SetFileNameResult.succeeded;
/** @const {number} */
Windows.Storage.Pickers.Provider.SetFileNameResult.notAllowed;
/** @const {number} */
Windows.Storage.Pickers.Provider.SetFileNameResult.unavailable;
/**
 * @constructor
 * @struct
 */
Windows.Storage.Pickers.Provider.TargetFileRequest = function() {};
 /** @type {!Windows.Storage.IStorageFile} */
Windows.Storage.Pickers.Provider.TargetFileRequest.prototype.targetFile;

/**
 * Gets a targetFileRequestDeferral that the app providing the save location can use to respond asynchronously to a targetfilerequested event.
 * @return {!Windows.Storage.Pickers.Provider.TargetFileRequestDeferral} The targetFileRequestDeferral that the providing app can use asynchronously to indicate that it is finished responding to a targetfilerequested event.
 */
Windows.Storage.Pickers.Provider.TargetFileRequest.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Pickers.Provider.TargetFileRequestDeferral = function() {};

/**
 * Signals that the app providing the save location finished responding to a targetfilerequested event.
 * @return {void}
 */
Windows.Storage.Pickers.Provider.TargetFileRequestDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs = function() {};
 /** @type {!Windows.Storage.Pickers.Provider.TargetFileRequest} */
Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs.prototype.request;
/** @const */
Windows.Storage.Provider = {};

/** @const */
Windows.Storage.Provider.CachedFileOptions = {};
/** @const {number} */
Windows.Storage.Provider.CachedFileOptions.none;
/** @const {number} */
Windows.Storage.Provider.CachedFileOptions.requireUpdateOnAccess;
/** @const {number} */
Windows.Storage.Provider.CachedFileOptions.useCachedFileWhenOffline;
/** @const {number} */
Windows.Storage.Provider.CachedFileOptions.denyAccessWhenOffline;

/** @const */
Windows.Storage.Provider.CachedFileTarget = {};
/** @const {number} */
Windows.Storage.Provider.CachedFileTarget.local;
/** @const {number} */
Windows.Storage.Provider.CachedFileTarget.remote;
/**
 * @constructor
 * @struct
 */
Windows.Storage.Provider.CachedFileUpdater = function() {};

/**
 * Configures update policies for a local file.
 * @param {!Windows.Storage.IStorageFile} file The local file.
 * @param {string} contentId A unique identifier for the local file.
 * @param {Windows.Storage.Provider.ReadActivationMode} readMode A value that specifies whether Windows will request updates before the local file is read by other apps.
 * @param {Windows.Storage.Provider.WriteActivationMode} writeMode A value that specifies whether other apps can write to the local file and, if so, whether Windows will request updates after the local file is written.
 * @param {Windows.Storage.Provider.CachedFileOptions} options A value that specifies additional circumstances and behaviors for when Windows requests updates.
 * @return {void}
 */
Windows.Storage.Provider.CachedFileUpdater.setUpdateInformation = function(file, contentId, readMode, writeMode, options) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Provider.CachedFileUpdaterUI = function() {};
 /** @type {function(?): void} */
Windows.Storage.Provider.CachedFileUpdaterUI.prototype.onfileupdaterequested;
 /** @type {function(?): void} */
Windows.Storage.Provider.CachedFileUpdaterUI.prototype.onuirequested;
 /** @type {string} */
Windows.Storage.Provider.CachedFileUpdaterUI.prototype.title;
 /** @type {Windows.Storage.Provider.UIStatus} */
Windows.Storage.Provider.CachedFileUpdaterUI.prototype.uiStatus;
 /** @type {!Windows.Storage.Provider.FileUpdateRequest} */
Windows.Storage.Provider.CachedFileUpdaterUI.prototype.updateRequest;
 /** @type {Windows.Storage.Provider.CachedFileTarget} */
Windows.Storage.Provider.CachedFileUpdaterUI.prototype.updateTarget;

/**
 * Gets an object used to complete a file update request asynchronously.
 * @return {!Windows.Storage.Provider.FileUpdateRequestDeferral} The object that the app uses to indicate, asynchronously, that it has finished responding to a FileUpdateRequested event and that the Request is complete.
 */
Windows.Storage.Provider.CachedFileUpdaterUI.prototype.getDeferral = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.Provider.CachedFileUpdaterUI.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.Provider.CachedFileUpdaterUI.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Provider.FileUpdateRequest = function() {};
 /** @type {string} */
Windows.Storage.Provider.FileUpdateRequest.prototype.contentId;
 /** @type {!Windows.Storage.StorageFile} */
Windows.Storage.Provider.FileUpdateRequest.prototype.file;
 /** @type {Windows.Storage.Provider.FileUpdateStatus} */
Windows.Storage.Provider.FileUpdateRequest.prototype.status;
 /** @type {string} */
Windows.Storage.Provider.FileUpdateRequest.prototype.userInputNeededMessage;

/**
 * Gets an object used to complete an update asynchronously.
 * @return {!Windows.Storage.Provider.FileUpdateRequestDeferral} The object that the app uses to indicate, asynchronously, that it has finished responding to a FileUpdateRequested event and that the Request is complete.
 */
Windows.Storage.Provider.FileUpdateRequest.prototype.getDeferral = function() {};

/**
 * Provide a new version of the local file to represent the remote file.
 * @param {!Windows.Storage.IStorageFile} value The new version of the local file that will represent remote file.
 * @return {void}
 */
Windows.Storage.Provider.FileUpdateRequest.prototype.updateLocalFile = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Provider.FileUpdateRequestDeferral = function() {};

/**
 * Signals that the response to a FileUpdateRequested event is finished.
 * @return {void}
 */
Windows.Storage.Provider.FileUpdateRequestDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Provider.FileUpdateRequestedEventArgs = function() {};
 /** @type {!Windows.Storage.Provider.FileUpdateRequest} */
Windows.Storage.Provider.FileUpdateRequestedEventArgs.prototype.request;

/** @const */
Windows.Storage.Provider.FileUpdateStatus = {};
/** @const {number} */
Windows.Storage.Provider.FileUpdateStatus.incomplete;
/** @const {number} */
Windows.Storage.Provider.FileUpdateStatus.complete;
/** @const {number} */
Windows.Storage.Provider.FileUpdateStatus.userInputNeeded;
/** @const {number} */
Windows.Storage.Provider.FileUpdateStatus.currentlyUnavailable;
/** @const {number} */
Windows.Storage.Provider.FileUpdateStatus.failed;
/** @const {number} */
Windows.Storage.Provider.FileUpdateStatus.completeAndRenamed;

/** @const */
Windows.Storage.Provider.ReadActivationMode = {};
/** @const {number} */
Windows.Storage.Provider.ReadActivationMode.notNeeded;
/** @const {number} */
Windows.Storage.Provider.ReadActivationMode.beforeAccess;

/** @const */
Windows.Storage.Provider.UIStatus = {};
/** @const {number} */
Windows.Storage.Provider.UIStatus.unavailable;
/** @const {number} */
Windows.Storage.Provider.UIStatus.hidden;
/** @const {number} */
Windows.Storage.Provider.UIStatus.visible;
/** @const {number} */
Windows.Storage.Provider.UIStatus.complete;

/** @const */
Windows.Storage.Provider.WriteActivationMode = {};
/** @const {number} */
Windows.Storage.Provider.WriteActivationMode.readOnly;
/** @const {number} */
Windows.Storage.Provider.WriteActivationMode.notNeeded;
/** @const {number} */
Windows.Storage.Provider.WriteActivationMode.afterWrite;
/** @const */
Windows.Storage.Search = {};

/** @const */
Windows.Storage.Search.CommonFileQuery = {};
/** @const {number} */
Windows.Storage.Search.CommonFileQuery.defaultQuery;
/** @const {number} */
Windows.Storage.Search.CommonFileQuery.orderByName;
/** @const {number} */
Windows.Storage.Search.CommonFileQuery.orderByTitle;
/** @const {number} */
Windows.Storage.Search.CommonFileQuery.orderByMusicProperties;
/** @const {number} */
Windows.Storage.Search.CommonFileQuery.orderBySearchRank;
/** @const {number} */
Windows.Storage.Search.CommonFileQuery.orderByDate;

/** @const */
Windows.Storage.Search.CommonFolderQuery = {};
/** @const {number} */
Windows.Storage.Search.CommonFolderQuery.defaultQuery;
/** @const {number} */
Windows.Storage.Search.CommonFolderQuery.groupByYear;
/** @const {number} */
Windows.Storage.Search.CommonFolderQuery.groupByMonth;
/** @const {number} */
Windows.Storage.Search.CommonFolderQuery.groupByArtist;
/** @const {number} */
Windows.Storage.Search.CommonFolderQuery.groupByAlbum;
/** @const {number} */
Windows.Storage.Search.CommonFolderQuery.groupByAlbumArtist;
/** @const {number} */
Windows.Storage.Search.CommonFolderQuery.groupByComposer;
/** @const {number} */
Windows.Storage.Search.CommonFolderQuery.groupByGenre;
/** @const {number} */
Windows.Storage.Search.CommonFolderQuery.groupByPublishedYear;
/** @const {number} */
Windows.Storage.Search.CommonFolderQuery.groupByRating;
/** @const {number} */
Windows.Storage.Search.CommonFolderQuery.groupByTag;
/** @const {number} */
Windows.Storage.Search.CommonFolderQuery.groupByAuthor;
/** @const {number} */
Windows.Storage.Search.CommonFolderQuery.groupByType;
/**
 * @constructor
 * @struct
 */
Windows.Storage.Search.ContentIndexer = function() {};
 /** @type {number} */
Windows.Storage.Search.ContentIndexer.prototype.revision;

/**
 * Gets the per-app index with the specified name or creates a new one, if necessary.
 * Gets an existing per-app index or creates a new one, if necessary.
 * @param {string=} indexName The index name.
 * @return {!Windows.Storage.Search.ContentIndexer} The index.
 */
Windows.Storage.Search.ContentIndexer.getIndexer = function(indexName) {};

/**
 * Adds app-defined items with properties and content to the system index.
 * @param {!Windows.Storage.Search.IIndexableContent} indexableContent The content properties to index.
 * @return {?}
 */
Windows.Storage.Search.ContentIndexer.prototype.addAsync = function(indexableContent) {};

/**
 * Builds a query with the specified search filter, sort order, and identifies which properties to retrieve.
 * Builds a query with the specified search filter, sort order, filter language, and identifies which properties to retrieve.
 * Builds a query with the specified search filter and identifies which properties to retrieve.
 * @param {string} searchFilter The AQS filter. / The AQS filter to apply.
 * @param {!Windows.Foundation.Collections.IIterable<string>} propertiesToRetrieve The properties to retrieve, specified by their Windows canonical property names.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Storage.Search.SortEntry>=} sortOrder The sort order for the filtered results.
 * @param {string=} searchFilterLanguage The language that's used to parse AQS, specified as a BCP-47 language tag.
 * @return {!Windows.Storage.Search.ContentIndexerQuery} The query.
 */
Windows.Storage.Search.ContentIndexer.prototype.createQuery = function(searchFilter, propertiesToRetrieve, sortOrder, searchFilterLanguage) {};

/**
 * Removes all app-defined items from the ContentIndexer .
 * @return {?}
 */
Windows.Storage.Search.ContentIndexer.prototype.deleteAllAsync = function() {};

/**
 * Removes the specified app-defined item from the ContentIndexer .
 * @param {string} contentId The identifier of the item to remove.
 * @return {?}
 */
Windows.Storage.Search.ContentIndexer.prototype.deleteAsync = function(contentId) {};

/**
 * Removes the specified app-defined items from the ContentIndexer .
 * @param {!Windows.Foundation.Collections.IIterable<string>} contentIds The identifier of the item to remove.
 * @return {?}
 */
Windows.Storage.Search.ContentIndexer.prototype.deleteMultipleAsync = function(contentIds) {};

/**
 * Gets content properties based on the given content identifier.
 * @param {string} contentId The identifier for the content properties.
 * @param {!Windows.Foundation.Collections.IIterable<string>} propertiesToRetrieve The retrieved properties, based on contentId.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IMapView<?, ?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IMapView<?, ?>>>} When this method completes, it returns the retrieved properties as a map of key-value pairs.
 */
Windows.Storage.Search.ContentIndexer.prototype.retrievePropertiesAsync = function(contentId, propertiesToRetrieve) {};

/**
 * Updates app content and properties in the ContentIndexer .
 * @param {!Windows.Storage.Search.IIndexableContent} indexableContent The content properties to update.
 * @return {?}
 */
Windows.Storage.Search.ContentIndexer.prototype.updateAsync = function(indexableContent) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Search.ContentIndexerQuery = function() {};
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.Search.ContentIndexerQuery.prototype.queryFolder;

/**
 * Runs the query on the app's indexed content properties and returns the specified number of items from the specified start index in the results collection.
 * Runs the query on the app's indexed content properties.
 * @param {number=} startIndex The index of the first item to get from the results collection.
 * @param {number=} maxItems The maximum number of items to get.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes, it returns the query results, represented as a collection of IndexableContent instances. / When this method completes, it returns the query results, represented as a collection of IIndexableContent instances.
 */
Windows.Storage.Search.ContentIndexerQuery.prototype.getAsync = function(startIndex, maxItems) {};

/**
 * Gets the number of items in the search results.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} When this method completes, it returns the number of items in the search results.
 */
Windows.Storage.Search.ContentIndexerQuery.prototype.getCountAsync = function() {};

/**
 * Retrieves a collection of property sets for an app, where the property sets are key-value pairs.
 * Runs the query on the app's indexed content properties and returns the specified number of properties from the specified start index in the results collection.
 * @param {number=} startIndex The index of the first item to get from the results collection.
 * @param {number=} maxItems The maximum number of items to get.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes, it returns the query results as a collection of PropertyValue instances.
 */
Windows.Storage.Search.ContentIndexerQuery.prototype.getPropertiesAsync = function(startIndex, maxItems) {};

/** @const */
Windows.Storage.Search.DateStackOption = {};
/** @const {number} */
Windows.Storage.Search.DateStackOption.none;
/** @const {number} */
Windows.Storage.Search.DateStackOption.year;
/** @const {number} */
Windows.Storage.Search.DateStackOption.month;

/** @const */
Windows.Storage.Search.FolderDepth = {};
/** @const {number} */
Windows.Storage.Search.FolderDepth.shallow;
/** @const {number} */
Windows.Storage.Search.FolderDepth.deep;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the IndexableContent class.
 */
Windows.Storage.Search.IndexableContent = function() {};
 /** @type {string} */
Windows.Storage.Search.IndexableContent.prototype.id;
 /** @type {!Windows.Foundation.Collections.IMap<string, ?>} */
Windows.Storage.Search.IndexableContent.prototype.properties;
 /** @type {!Windows.Storage.Streams.IRandomAccessStream} */
Windows.Storage.Search.IndexableContent.prototype.stream;
 /** @type {string} */
Windows.Storage.Search.IndexableContent.prototype.streamContentType;

/** @const */
Windows.Storage.Search.IndexedState = {};
/** @const {number} */
Windows.Storage.Search.IndexedState.unknown;
/** @const {number} */
Windows.Storage.Search.IndexedState.notIndexed;
/** @const {number} */
Windows.Storage.Search.IndexedState.partiallyIndexed;
/** @const {number} */
Windows.Storage.Search.IndexedState.fullyIndexed;

/** @const */
Windows.Storage.Search.IndexerOption = {};
/** @const {number} */
Windows.Storage.Search.IndexerOption.useIndexerWhenAvailable;
/** @const {number} */
Windows.Storage.Search.IndexerOption.onlyUseIndexer;
/** @const {number} */
Windows.Storage.Search.IndexerOption.doNotUseIndexer;

/**
 * @constructor
 * @struct
 * Creates an instance of the QueryOptions class for enumerating files and initializes it with values provided by the specified CommonFileQuery and an optional file type filter that determines which files to include in query results.
 * Creates an instance of the QueryOptions class for enumerating subfolders and initializes it with values based on the specified CommonFolderQuery .
 * Creates an instance of the QueryOptions class for enumerating storage items, and initializes it with the following default settings: QueryOptions.FolderDepth gets FolderDepth.Shallow and QueryOptions.IndexerOption gets IndexerOption.DoNotUseIndexer .
 * @param {Windows.Storage.Search.CommonFileQuery|Windows.Storage.Search.CommonFolderQuery=} query An enumeration value that specifies the search parameters to use to query files. / An enumeration value that specifies how to group the contents of the folder where the query is created into subfolders to enumerate. The subfolders that are retrieved using a CommonFolderQuery can be actual file system folders or virtual folders that represent groups of files (which are determined by the CommonFolderQuery value). For example, the CommonFolderQuery.GroupByArtist uses the Artist of the files in the folder (and its subfolders) to group files, creating one virtual folder (or file group) for each artist.
 * @param {!Windows.Foundation.Collections.IIterable<string>=} fileTypeFilter An array of file types to be included in the query results. To include all file types, supply null or an array containing a single entry of "*".
 */
Windows.Storage.Search.QueryOptions = function(query, fileTypeFilter) {};
 /** @type {string} */
Windows.Storage.Search.QueryOptions.prototype.applicationSearchFilter;
 /** @type {Windows.Storage.Search.DateStackOption} */
Windows.Storage.Search.QueryOptions.prototype.dateStackOption;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.Search.QueryOptions.prototype.fileTypeFilter;
 /** @type {Windows.Storage.Search.FolderDepth} */
Windows.Storage.Search.QueryOptions.prototype.folderDepth;
 /** @type {string} */
Windows.Storage.Search.QueryOptions.prototype.groupPropertyName;
 /** @type {Windows.Storage.Search.IndexerOption} */
Windows.Storage.Search.QueryOptions.prototype.indexerOption;
 /** @type {string} */
Windows.Storage.Search.QueryOptions.prototype.language;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Storage.Search.SortEntry>} */
Windows.Storage.Search.QueryOptions.prototype.sortOrder;
 /** @type {!Windows.Foundation.Collections.IVector<string>} */
Windows.Storage.Search.QueryOptions.prototype.storageProviderIdFilter;
 /** @type {string} */
Windows.Storage.Search.QueryOptions.prototype.userSearchFilter;

/**
 * Initializes the current instance of the QueryOptions class with search parameters specified by a string that was created by the SaveToString method.
 * @param {string} value A string retrieved by a previous call to SaveToString .
 * @return {void}
 */
Windows.Storage.Search.QueryOptions.prototype.loadFromString = function(value) {};

/**
 * Converts the values of a QueryOptions object to a string that can be used to initialize the values of a QueryOptions object by calling LoadFromString .
 * @return {string} A string representing the serialized settings of a QueryOptions instance.
 */
Windows.Storage.Search.QueryOptions.prototype.saveToString = function() {};

/**
 * Specifies properties that the system should load in advance for all items in the query result set while the query is being executed (instead of retrieving them on a case-by-case basis). If many properties are specified, the query might take longer to execute, but subsequent property retrieval on query results will be faster.
 * @param {Windows.Storage.FileProperties.PropertyPrefetchOptions} options A value that specifies the set of properties to retrieve in advance.
 * @param {!Windows.Foundation.Collections.IIterable<string>} propertiesToRetrieve A custom list of properties to retrieve in advance as an array of property names. Use the system property names to specify properties, for example "System.Copyright" and "System.Image.ColorSpace".
 * @return {void}
 */
Windows.Storage.Search.QueryOptions.prototype.setPropertyPrefetch = function(options, propertiesToRetrieve) {};

/**
 * Specifies the type and size of thumbnails that the system should start loading immediately when items are accessed (instead of retrieving them on a case-by-case basis). This uses more resources but makes thumbnail retrieval on query results faster.
 * @param {Windows.Storage.FileProperties.ThumbnailMode} mode The enumeration value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @param {number} requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to return a thumbnail image that can be scaled to the requested size without reducing the quality of the image.
 * @param {Windows.Storage.FileProperties.ThumbnailOptions} options The enum value that describes the desired behavior to use to retrieve the thumbnail image. The specified behavior might affect the size and/or quality of the image and how quickly the thumbnail image is retrieved.
 * @return {void}
 */
Windows.Storage.Search.QueryOptions.prototype.setThumbnailPrefetch = function(mode, requestedSize, options) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Search.SortEntryVector = function() {};
 /** @type {number} */
Windows.Storage.Search.SortEntryVector.prototype.size;

/**
 * Appends a sort entry to the end of the collection.
 * @param {!Windows.Storage.Search.SortEntry} value The sort entry to append to the collection.
 * @return {void}
 */
Windows.Storage.Search.SortEntryVector.prototype.append = function(value) {};

/**
 * Removes all sort entries from the collection.
 * @return {void}
 */
Windows.Storage.Search.SortEntryVector.prototype.clear = function() {};

/**
 * Retrieves an iterator that iterates through the sort entries in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Storage.Search.SortEntry>} The iterator.
 */
Windows.Storage.Search.SortEntryVector.prototype.first = function() {};

/**
 * Retrieves the sort entry at the specified index in the collection.
 * @param {number} index The zero-based index of the sort entry to retrieve.
 * @return {!Windows.Storage.Search.SortEntry} The sort entry at the specified index.
 */
Windows.Storage.Search.SortEntryVector.prototype.getAt = function(index) {};

/**
 * Retrieves the sort entries that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the sort entries in the collection to retrieve.
 * @return {{items: !Windows.Storage.Search.SortEntry, returnValue: number}}
 */
Windows.Storage.Search.SortEntryVector.prototype.getMany = function(startIndex) {};

/**
 * Retrieves an immutable view of the collection of sort entries.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Storage.Search.SortEntry>} The view of the collection.
 */
Windows.Storage.Search.SortEntryVector.prototype.getView = function() {};

/**
 * Retrieves the index of a specified sort entry in the collection.
 * @param {!Windows.Storage.Search.SortEntry} value_or_searchElement The sort entry to find in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Storage.Search.SortEntryVector.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts a sort entry into the collection at a specified index.
 * @param {number} index The zero-based index of the location to insert the sort entry.
 * @param {!Windows.Storage.Search.SortEntry} value The sort entry to insert.
 * @return {void}
 */
Windows.Storage.Search.SortEntryVector.prototype.insertAt = function(index, value) {};

/**
 * Removes the sort entry at the specified index in the collection.
 * @param {number} index The zero-based index of the sort entry to remove.
 * @return {void}
 */
Windows.Storage.Search.SortEntryVector.prototype.removeAt = function(index) {};

/**
 * Removes the last sort entry from the collection.
 * @return {void}
 */
Windows.Storage.Search.SortEntryVector.prototype.removeAtEnd = function() {};

/**
 * Replaces all sort entries in the collection with the specified sort entries.
 * @param {!Windows.Storage.Search.SortEntry} items The collection of sort entries to put in the vector.
 * @return {void}
 */
Windows.Storage.Search.SortEntryVector.prototype.replaceAll = function(items) {};

/**
 * Sets the sort entry at the specified index of the collection.
 * @param {number} index The zero-based index of the location at which to set the sort entry.
 * @param {!Windows.Storage.Search.SortEntry} value The sort entry.
 * @return {void}
 */
Windows.Storage.Search.SortEntryVector.prototype.setAt = function(index, value) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Search.StorageFileQueryResult = function() {};
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.Search.StorageFileQueryResult.prototype.folder;
 /** @type {function(?): void} */
Windows.Storage.Search.StorageFileQueryResult.prototype.oncontentschanged;
 /** @type {function(?): void} */
Windows.Storage.Search.StorageFileQueryResult.prototype.onoptionschanged;

/**
 * Modifies query results based on new QueryOptions .
 * @param {!Windows.Storage.Search.QueryOptions} newQueryOptions The new query options.
 * @return {void}
 */
Windows.Storage.Search.StorageFileQueryResult.prototype.applyNewQueryOptions = function(newQueryOptions) {};

/**
 * Retrieves the index of the file from the query results that most closely matches the specified property value (or file, if used with FileActivatedEventArgs.NeighboringFilesQuery ). The property that is matched is determined by the first SortEntry of the QueryOptions.SortOrder list.
 * @param {?} value The property value to match when searching the query results. The property to that is used to match this value is the property in the first SortEntry of the QueryOptions.SortOrder list.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} When this method completes successfully, it returns the index of the matched file in the query results or the index of the file in the FileActivatedEventArgs.NeighboringFilesQuery . In the latter case, the file is expected to be sourced from FileActivatedEventArgs.Files .
 */
Windows.Storage.Search.StorageFileQueryResult.prototype.findStartIndexAsync = function(value) {};

/**
 * Retrieves the query options used to determine query results.
 * @return {!Windows.Storage.Search.QueryOptions} The query options.
 */
Windows.Storage.Search.StorageFileQueryResult.prototype.getCurrentQueryOptions = function() {};

/**
 * Retrieves a list of all the files in the query result set.
 * Retrieves a list of files in a specified range.
 * @param {number=} startIndex The zero-based index of the first file to retrieve. This parameter is 0 by default.
 * @param {number=} maxNumberOfItems The maximum number of files to retrieve. Use -1 to retrieve all files. If the range contains fewer files than the max number, all files in the range are returned.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns a list (type IVectorView ) of files that are represented by storageFile objects.
 */
Windows.Storage.Search.StorageFileQueryResult.prototype.getFilesAsync = function(startIndex, maxNumberOfItems) {};

/**
 * Retrieves the number of files in the set of query results.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} When this method completes successfully, it returns the number of files in the location that match the query.
 */
Windows.Storage.Search.StorageFileQueryResult.prototype.getItemCountAsync = function() {};

/**
 * Gets matching file properties with corresponding text ranges.
 * @param {!Windows.Storage.StorageFile} file The file to query for properties.
 * @return {!Windows.Foundation.Collections.IMap<string, !Windows.Foundation.Collections.IVectorView<?>>} The matched properties and corresponding text ranges.
 */
Windows.Storage.Search.StorageFileQueryResult.prototype.getMatchingPropertiesWithRanges = function(file) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.Search.StorageFileQueryResult.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.Search.StorageFileQueryResult.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Search.StorageFolderQueryResult = function() {};
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.Search.StorageFolderQueryResult.prototype.folder;
 /** @type {function(?): void} */
Windows.Storage.Search.StorageFolderQueryResult.prototype.oncontentschanged;
 /** @type {function(?): void} */
Windows.Storage.Search.StorageFolderQueryResult.prototype.onoptionschanged;

/**
 * Modifies query results based on new QueryOptions .
 * @param {!Windows.Storage.Search.QueryOptions} newQueryOptions The new query options.
 * @return {void}
 */
Windows.Storage.Search.StorageFolderQueryResult.prototype.applyNewQueryOptions = function(newQueryOptions) {};

/**
 * Retrieves the index of the folder from the query results that most closely matches the specified property value. The property that is matched is determined by the first SortEntry of the QueryOptions.SortOrder list.
 * @param {?} value The property value to match when searching the query results. The property to that is used to match this value is the property in the first SortEntry of the QueryOptions.SortOrder list.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} When this method completes successfully it returns the index of the matched folder in the query results.
 */
Windows.Storage.Search.StorageFolderQueryResult.prototype.findStartIndexAsync = function(value) {};

/**
 * Retrieves the query options used to determine query results.
 * @return {!Windows.Storage.Search.QueryOptions} The query options.
 */
Windows.Storage.Search.StorageFolderQueryResult.prototype.getCurrentQueryOptions = function() {};

/**
 * Retrieves folders (or file groups) in a specified range.
 * Retrieves a list of all the folders (or file groups) in the result set.
 * @param {number=} startIndex The zero-based index of the first folder to retrieve. This parameter defaults to 0.
 * @param {number=} maxNumberOfItems The maximum number of folders or file groups to retrieve. Use -1 to retrieve all folders. If the range contains fewer folders than the max number, all folders in the range are returned.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns a list (type IVectorView ) of folders or file groups that are represented by storageFolder objects. / When this method completes successfully, it returns a list (type IVectorView ) of folders or file groups that are represented by storageFolder objects. Each of these folder or file group can also be enumerated to retrieve its contents.
 */
Windows.Storage.Search.StorageFolderQueryResult.prototype.getFoldersAsync = function(startIndex, maxNumberOfItems) {};

/**
 * Retrieves the number of folders (or file groups) in the set of query results.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} When this method completes successfully, it returns the number of folders or file groups in the location that match the query.
 */
Windows.Storage.Search.StorageFolderQueryResult.prototype.getItemCountAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.Search.StorageFolderQueryResult.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.Search.StorageFolderQueryResult.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Search.StorageItemQueryResult = function() {};
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.Search.StorageItemQueryResult.prototype.folder;
 /** @type {function(?): void} */
Windows.Storage.Search.StorageItemQueryResult.prototype.oncontentschanged;
 /** @type {function(?): void} */
Windows.Storage.Search.StorageItemQueryResult.prototype.onoptionschanged;

/**
 * Modifies query results based on new QueryOptions .
 * @param {!Windows.Storage.Search.QueryOptions} newQueryOptions The new query options.
 * @return {void}
 */
Windows.Storage.Search.StorageItemQueryResult.prototype.applyNewQueryOptions = function(newQueryOptions) {};

/**
 * Retrieves the index of the item from the query results that most closely matches the specified property value. The property that is matched is determined by the first SortEntry of the QueryOptions.SortOrder list.
 * @param {?} value The property value to match when searching the query results. The property to that is used to match this value is the property in the first SortEntry of the QueryOptions.SortOrder list.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} When this method completes successfully it returns the index of the matched item in the query results.
 */
Windows.Storage.Search.StorageItemQueryResult.prototype.findStartIndexAsync = function(value) {};

/**
 * Retrieves the query options used to determine query results.
 * @return {!Windows.Storage.Search.QueryOptions} The query options.
 */
Windows.Storage.Search.StorageItemQueryResult.prototype.getCurrentQueryOptions = function() {};

/**
 * Retrieves the number of items in the set of query results.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} When this method completes successfully, it returns the number of items in the location that match the query.
 */
Windows.Storage.Search.StorageItemQueryResult.prototype.getItemCountAsync = function() {};

/**
 * Retrieves a list of all the items (files and folders) in the query results set.
 * Retrieves a list of items (files and folders) in a specified range.
 * @param {number=} startIndex The zero-based index of the first item to retrieve. This parameter defaults to 0.
 * @param {number=} maxNumberOfItems The maximum number of items to retrieve. Use -1 to retrieve all items. If the range contains fewer items than the max number, all items in the range are returned.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns a list (type IVectorView ) of items. Each item is the IStorageItem type and represents a file, folder, or file group.
 */
Windows.Storage.Search.StorageItemQueryResult.prototype.getItemsAsync = function(startIndex, maxNumberOfItems) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.Search.StorageItemQueryResult.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.Search.StorageItemQueryResult.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Search.StorageLibraryContentChangedTriggerDetails = function() {};
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.Search.StorageLibraryContentChangedTriggerDetails.prototype.folder;

/**
 * Query for the creation/modified changes since a previous such query.
 * @param {!Date} lastQueryTime The time the previous query was made.
 * @return {!Windows.Storage.Search.StorageItemQueryResult} The query result.
 */
Windows.Storage.Search.StorageLibraryContentChangedTriggerDetails.prototype.createModifiedSinceQuery = function(lastQueryTime) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the ValueAndLanguage class.
 */
Windows.Storage.Search.ValueAndLanguage = function() {};
 /** @type {string} */
Windows.Storage.Search.ValueAndLanguage.prototype.language;
 /** @type {?} */
Windows.Storage.Search.ValueAndLanguage.prototype.value;
/**
 * @record
 * @struct
 */
Windows.Storage.Search.IStorageQueryResultBase = function() {};
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.Search.IStorageQueryResultBase.prototype.folder;

/**
 * Applies new query options to the results retrieved by the StorageFileQueryResult , StorageFolderQueryResult , or StorageItemQueryResult object.
 * @param {!Windows.Storage.Search.QueryOptions} newQueryOptions The new query options.
 * @return {void}
 */
Windows.Storage.Search.IStorageQueryResultBase.prototype.applyNewQueryOptions = function(newQueryOptions) {};

/**
 * Retrieves the index of the file from the query results that most closely matches the specified property value. The property that is matched is determined by the first SortEntry of the QueryOptions.SortOrder list.
 * @param {?} value The property value to match when searching the query results.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} When this method completes successfully it returns the index of the matched item in the query results.
 */
Windows.Storage.Search.IStorageQueryResultBase.prototype.findStartIndexAsync = function(value) {};

/**
 * Retrieves the query options used to create a StorageFileQueryResult , StorageFolderQueryResult , or StorageItemQueryResult object.
 * @return {!Windows.Storage.Search.QueryOptions} The query options.
 */
Windows.Storage.Search.IStorageQueryResultBase.prototype.getCurrentQueryOptions = function() {};

/**
 * Retrieves the number of items that match the query that created a StorageFileQueryResult , StorageFolderQueryResult , or StorageItemQueryResult object.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperation<number>>} When this method completes successfully, it returns the number of items that match the query.
 */
Windows.Storage.Search.IStorageQueryResultBase.prototype.getItemCountAsync = function() {};
/**
 * @record
 * @struct
 */
Windows.Storage.Search.IIndexableContent = function() {};
 /** @type {string} */
Windows.Storage.Search.IIndexableContent.prototype.id;
 /** @type {!Windows.Foundation.Collections.IMap<string, ?>} */
Windows.Storage.Search.IIndexableContent.prototype.properties;
 /** @type {!Windows.Storage.Streams.IRandomAccessStream} */
Windows.Storage.Search.IIndexableContent.prototype.stream;
 /** @type {string} */
Windows.Storage.Search.IIndexableContent.prototype.streamContentType;
/**
 * @record
 * @struct
 */
Windows.Storage.Search.SortEntry = function() {};
 /** @type {boolean} */
Windows.Storage.Search.SortEntry.prototype.ascendingOrder;
 /** @type {string} */
Windows.Storage.Search.SortEntry.prototype.propertyName;
/**
 * @constructor
 * @struct
 */
Windows.Storage.SetVersionDeferral = function() {};

/**
 * Notifies the system that the app has set the version of the application data in its app data store.
 * @return {void}
 */
Windows.Storage.SetVersionDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.SetVersionRequest = function() {};
 /** @type {number} */
Windows.Storage.SetVersionRequest.prototype.currentVersion;
 /** @type {number} */
Windows.Storage.SetVersionRequest.prototype.desiredVersion;

/**
 * Requests that the set version request be delayed.
 * @return {!Windows.Storage.SetVersionDeferral} The set version deferral.
 */
Windows.Storage.SetVersionRequest.prototype.getDeferral = function() {};

/** @const */
Windows.Storage.StorageDeleteOption = {};
/** @const {number} */
Windows.Storage.StorageDeleteOption.default;
/** @const {number} */
Windows.Storage.StorageDeleteOption.permanentDelete;
/**
 * @constructor
 * @struct
 */
Windows.Storage.StorageFile = function() {};
 /** @type {Windows.Storage.FileAttributes} */
Windows.Storage.StorageFile.prototype.attributes;
 /** @type {string} */
Windows.Storage.StorageFile.prototype.contentType;
 /** @type {!Date} */
Windows.Storage.StorageFile.prototype.dateCreated;
 /** @type {string} */
Windows.Storage.StorageFile.prototype.displayName;
 /** @type {string} */
Windows.Storage.StorageFile.prototype.displayType;
 /** @type {string} */
Windows.Storage.StorageFile.prototype.fileType;
 /** @type {string} */
Windows.Storage.StorageFile.prototype.folderRelativeId;
 /** @type {boolean} */
Windows.Storage.StorageFile.prototype.isAvailable;
 /** @type {string} */
Windows.Storage.StorageFile.prototype.name;
 /** @type {string} */
Windows.Storage.StorageFile.prototype.path;
 /** @type {!Windows.Storage.FileProperties.StorageItemContentProperties} */
Windows.Storage.StorageFile.prototype.properties;
 /** @type {!Windows.Storage.StorageProvider} */
Windows.Storage.StorageFile.prototype.provider;

/**
 * Creates a StorageFile to represent the specified stream of data. This method lets the app produce the data on-demand by specifying a function to be invoked when the StorageFile that represents the stream is first accessed.
 * @param {string} displayNameWithExtension The user-friendly name of the StorageFile to create, including a file type extension.
 * @param {function(!Windows.Storage.StreamedFileDataRequest): void} dataRequested The function that should be invoked when the StorageFile that is returned is first accessed. This function should produce the data stream represented by the returned StorageFile and lets the app produce data on-demand instead of writing the contents of the file at creation time.
 * @param {!Windows.Storage.Streams.IRandomAccessStreamReference} thumbnail The thumbnail image for the StorageFile to create.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns a StorageFile object that represents the new stream of data.
 */
Windows.Storage.StorageFile.createStreamedFileAsync = function(displayNameWithExtension, dataRequested, thumbnail) {};

/**
 * Creates a StorageFile to represent a stream of data from the specified URI resource. This method lets the app download the data on-demand when the StorageFile that represents the stream is first accessed.
 * @param {string} displayNameWithExtension The user-friendly name of the StorageFile to create, including a file type extension.
 * @param {!Windows.Foundation.Uri} uri The URI of the resource used to create the StorageFile .
 * @param {!Windows.Storage.Streams.IRandomAccessStreamReference} thumbnail The thumbnail image for the StorageFile to create.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns a StorageFile object that represents the URI resource.
 */
Windows.Storage.StorageFile.createStreamedFileFromUriAsync = function(displayNameWithExtension, uri, thumbnail) {};

/**
 * Gets a StorageFile object to represent the specified URI app resource. For examples of sample URIs see How to load file resources.
 * @param {!Windows.Foundation.Uri} uri The URI of the app resource to get a StorageFile to represent.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns a StorageFile object that represents the URI resource.
 */
Windows.Storage.StorageFile.getFileFromApplicationUriAsync = function(uri) {};

/**
 * Gets a StorageFile object to represent the file at the specified path.
 * @param {string} path The path of the file to get a StorageFile to represent.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns the file as a StorageFile .
 */
Windows.Storage.StorageFile.getFileFromPathAsync = function(path) {};

/**
 * Replaces the contents of the file referred to by the specified IStorageFile object with a new data stream. This method lets the app produce the data on-demand by specifying a function to be invoked when the StorageFile that represents the stream is first accessed.
 * @param {!Windows.Storage.IStorageFile} fileToReplace The file (type IStorageFile ) that the new data stream should be written to.
 * @param {function(!Windows.Storage.StreamedFileDataRequest): void} dataRequested The function that should be invoked when the StorageFile that is returned is first accessed. This function should produce the data stream represented by the returned StorageFile and lets the app produce data on-demand instead of writing the contents of the file at creation time.
 * @param {!Windows.Storage.Streams.IRandomAccessStreamReference} thumbnail The thumbnail image for the StorageFile to create.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns a StorageFile object that represents the new data stream. Subsequently, this StorageFile object should be used to access file content instead of the file (type IStorageFile ) that was specified to be replace.
 */
Windows.Storage.StorageFile.replaceWithStreamedFileAsync = function(fileToReplace, dataRequested, thumbnail) {};

/**
 * Replaces the contents of the file referred to by the specified IStorageFile object with a new data stream of the specified URI. This method lets the app download the data on-demand when the StorageFile that represents the stream is first accessed.
 * @param {!Windows.Storage.IStorageFile} fileToReplace The file that the created StorageFile will provide a stream of.
 * @param {!Windows.Foundation.Uri} uri The URI of the resource used to create the StorageFile .
 * @param {!Windows.Storage.Streams.IRandomAccessStreamReference} thumbnail The thumbnail image for the StorageFile to create.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns a StorageFile object that represents the streamed file. Subsequently, this StorageFile object should be used to access file content instead of the file (type IStorageFile ) that was specified to be replace.
 */
Windows.Storage.StorageFile.replaceWithStreamedFileFromUriAsync = function(fileToReplace, uri, thumbnail) {};

/**
 * Replaces the specified file with a copy of the current file.
 * @param {!Windows.Storage.IStorageFile} fileToReplace The file to replace.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.StorageFile.prototype.copyAndReplaceAsync = function(fileToReplace) {};

/**
 * Creates a copy of the file in the specified folder and renames the copy. This method also specifies what to do if a file with the same name already exists in the destination folder.
 * Creates a copy of the file in the specified folder and renames the copy.
 * Creates a copy of the file in the specified folder.
 * @param {!Windows.Storage.IStorageFolder} destinationFolder The destination folder where the copy of the file is created.
 * @param {string=} desiredNewName The new name for the copy of the file created in the destinationFolder.
 * @param {Windows.Storage.NameCollisionOption=} option One of the enumeration values that determines how to handle the collision if a file with the specified desiredNewName already exists in the destination folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns a StorageFile that represents the copy of the file created in the destinationFolder.
 */
Windows.Storage.StorageFile.prototype.copyAsync = function(destinationFolder, desiredNewName, option) {};

/**
 * Deletes the current file, optionally deleting the item permanently.
 * Deletes the current file.
 * @param {Windows.Storage.StorageDeleteOption=} option A value that indicates whether to delete the item permanently.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method when it completes.
 */
Windows.Storage.StorageFile.prototype.deleteAsync = function(option) {};

/**
 * Gets the basic properties of the current file.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.BasicProperties, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.BasicProperties>>} When this method completes successfully, it returns the basic properties of the current file as a BasicProperties object.
 */
Windows.Storage.StorageFile.prototype.getBasicPropertiesAsync = function() {};

/**
 * Gets the parent folder of the current file.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes, it returns the parent folder as a StorageFolder .
 */
Windows.Storage.StorageFile.prototype.getParentAsync = function() {};

/**
 * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail, the requested size, and the specified options
 * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail and the requested size.
 * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail.
 * @param {Windows.Storage.FileProperties.ThumbnailMode} mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @param {number=} requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
 * @param {Windows.Storage.FileProperties.ThumbnailOptions=} options The enum value that describes the desired behavior to use to retrieve the thumbnail image. The specified behavior might affect the size and/or quality of the image and how quickly the thumbnail image is retrieved.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.StorageItemThumbnail, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.StorageItemThumbnail>>} When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the item.
 */
Windows.Storage.StorageFile.prototype.getScaledImageAsThumbnailAsync = function(mode, requestedSize, options) {};

/**
 * Retrieves an adjusted thumbnail image for the file, determined by the purpose of the thumbnail.
 * Retrieves an adjusted thumbnail image for the file, determined by the purpose of the thumbnail and the requested size.
 * Retrieves an adjusted thumbnail image for the file, determined by the purpose of the thumbnail, the requested size, and the specified options.
 * @param {Windows.Storage.FileProperties.ThumbnailMode} mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @param {number=} requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
 * @param {Windows.Storage.FileProperties.ThumbnailOptions=} options The enum value that describes the desired behavior to use to retrieve the thumbnail image. The specified behavior might affect the size and/or quality of the image and how quickly the thumbnail image is retrieved.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.StorageItemThumbnail, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.StorageItemThumbnail>>} When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the file.
 */
Windows.Storage.StorageFile.prototype.getThumbnailAsync = function(mode, requestedSize, options) {};

/**
 * Indicates whether the current file is equal to the specified file.
 * @param {!Windows.Storage.IStorageItem} item The IStorageItem object that represents a file to compare against.
 * @return {boolean} Returns true if the current file is equal to the specified file; otherwise false.
 */
Windows.Storage.StorageFile.prototype.isEqual = function(item) {};

/**
 * Determines whether the current StorageFile matches the specified StorageItemTypes value.
 * @param {Windows.Storage.StorageItemTypes} type The value to match against.
 * @return {boolean} True if the StorageFile matches the specified value; otherwise false.
 */
Windows.Storage.StorageFile.prototype.isOfType = function(type) {};

/**
 * Moves the current file to the location of the specified file and replaces the specified file in that location.
 * @param {!Windows.Storage.IStorageFile} fileToReplace The file to replace.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method.
 */
Windows.Storage.StorageFile.prototype.moveAndReplaceAsync = function(fileToReplace) {};

/**
 * Moves the current file to the specified folder.
 * Moves the current file to the specified folder and renames the file according to the desired name.
 * Moves the current file to the specified folder and renames the file according to the desired name. This method also specifies what to do if a file with the same name already exists in the specified folder.
 * @param {!Windows.Storage.IStorageFolder} destinationFolder The destination folder where the file is moved.
 * @param {string=} desiredNewName The desired name of the file after it is moved.
 * @param {Windows.Storage.NameCollisionOption=} option An enum value that determines how Windows responds if the desiredNewName is the same as the name of an existing file in the destination folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method.
 */
Windows.Storage.StorageFile.prototype.moveAsync = function(destinationFolder, desiredNewName, option) {};

/**
 * Opens a random-access stream with the specified options over the specified file.
 * Opens a random-access stream with the specified options over the specified file.
 * @param {Windows.Storage.FileAccessMode} accessMode One of the enumeration values that specifies the type of access to allow.
 * @param {Windows.Storage.StorageOpenOptions=} options A bitwise combination of the enumeration values that specify options for opening the stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStream, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStream>>} When this method completes, it returns an IRandomAccessStream that contains the requested random-access stream.
 */
Windows.Storage.StorageFile.prototype.openAsync = function(accessMode, options) {};

/**
 * Opens a random-access stream over the current file for reading file contents.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType>>} When this method completes, it returns the random-access stream (type IRandomAccessStreamWithContentType ).
 */
Windows.Storage.StorageFile.prototype.openReadAsync = function() {};

/**
 * Opens a sequential-access stream over the current file for reading file contents.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IInputStream, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IInputStream>>} When this method completes, it returns the sequential-access stream (type IInputStream ).
 */
Windows.Storage.StorageFile.prototype.openSequentialReadAsync = function() {};

/**
 * Opens a random-access stream to the file that can be used for transacted-write operations.
 * Opens a random-access stream to the file that can be used for transacted-write operations with the specified options.
 * @param {Windows.Storage.StorageOpenOptions=} options A bitwise combination of the enumeration values that specify options for opening the stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageStreamTransaction, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageStreamTransaction>>} When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
 */
Windows.Storage.StorageFile.prototype.openTransactedWriteAsync = function(options) {};

/**
 * Renames the current file.
 * Renames the current file. This method also specifies what to do if an existing item in the current file's location has the same name.
 * @param {string} desiredName The desired, new name of the current item. / The desired, new name of the current file.
 * @param {Windows.Storage.NameCollisionOption=} option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing item in the current file's location.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method when it completes.
 */
Windows.Storage.StorageFile.prototype.renameAsync = function(desiredName, option) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.StorageFolder = function() {};
 /** @type {Windows.Storage.FileAttributes} */
Windows.Storage.StorageFolder.prototype.attributes;
 /** @type {!Date} */
Windows.Storage.StorageFolder.prototype.dateCreated;
 /** @type {string} */
Windows.Storage.StorageFolder.prototype.displayName;
 /** @type {string} */
Windows.Storage.StorageFolder.prototype.displayType;
 /** @type {string} */
Windows.Storage.StorageFolder.prototype.folderRelativeId;
 /** @type {string} */
Windows.Storage.StorageFolder.prototype.name;
 /** @type {string} */
Windows.Storage.StorageFolder.prototype.path;
 /** @type {!Windows.Storage.FileProperties.StorageItemContentProperties} */
Windows.Storage.StorageFolder.prototype.properties;
 /** @type {!Windows.Storage.StorageProvider} */
Windows.Storage.StorageFolder.prototype.provider;

/**
 * Gets the folder that has the specified absolute path in the file system.
 * @param {string} path The absolute path in the file system (not the Uri) of the folder to get.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes successfully, it returns a StorageFolder that represents the specified folder.
 */
Windows.Storage.StorageFolder.getFolderFromPathAsync = function(path) {};

/**
 * Indicates whether the current folder supports the specified QueryOptions .
 * @param {!Windows.Storage.Search.QueryOptions} queryOptions The QueryOptions to check.
 * @return {boolean} True if the folder or file group supports the specified QueryOptions ; otherwise false.
 */
Windows.Storage.StorageFolder.prototype.areQueryOptionsSupported = function(queryOptions) {};

/**
 * Creates a new file in the current folder. This method also specifies what to do if a file with the same name already exists in the current folder.
 * Creates a new file with the specified name in the current folder.
 * @param {string} desiredName The name of the new file to create in the current folder.
 * @param {Windows.Storage.CreationCollisionOption=} options One of the enumeration values that determines how to handle the collision if a file with the specified desiredName already exists in the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns a StorageFile that represents the new file.
 */
Windows.Storage.StorageFolder.prototype.createFileAsync = function(desiredName, options) {};

/**
 * Gets a query result object that contains the files in the current folder.
 * Gets a query result object that contains the files in the current folder. Also gets the files from the subfolders of the current folder when the value of the query argument is something other than CommonFileQuery.DefaultQuery . Files are sorted based on the specified CommonFileQuery.
 * @param {Windows.Storage.Search.CommonFileQuery=} query One of the enumeration values that specifies how to sort the files and determines whether the query is shallow or deep.
 * @return {!Windows.Storage.Search.StorageFileQueryResult} A query result object. Call the GetFilesAsync method of the query result to get the flat list of files. This method returns a list of type IReadOnlyList< StorageFile >. Each file is represented by an item of type StorageFile. / A query result object. Call the GetFilesAsync method of the query result to get the flat list of files, sorted as specified by query. This method returns a list of type IReadOnlyList< StorageFile >. Each file is represented by an item of type StorageFile.
 */
Windows.Storage.StorageFolder.prototype.createFileQuery = function(query) {};

/**
 * Gets a query result object that contains the files in the current folder and, optionally, in the subfolders of the current folder. The results are based on the specified QueryOptions .
 * @param {!Windows.Storage.Search.QueryOptions} queryOptions The criteria that are applied to the query.
 * @return {!Windows.Storage.Search.StorageFileQueryResult} A query result object that contains the files in the current folder and, optionally, in the subfolders of the current folder, filtered and sorted based on the specified QueryOptions . Call the GetFilesAsync method of the query result to get the flat list of files, sorted as specified by queryOptions. This method returns a list of type IReadOnlyList< StorageFile >. Each file is represented by an item of type StorageFile.
 */
Windows.Storage.StorageFolder.prototype.createFileQueryWithOptions = function(queryOptions) {};

/**
 * Creates a new subfolder with the specified name in the current folder.
 * Creates a new subfolder with the specified name in the current folder. This method also specifies what to do if a subfolder with the same name already exists in the current folder.
 * @param {string} desiredName The name of the new subfolder to create in the current folder.
 * @param {Windows.Storage.CreationCollisionOption=} options One of the enumeration values that determines how to handle the collision if a subfolder with the specified desiredName already exists in the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes, it returns a StorageFolder that represents the new subfolder.
 */
Windows.Storage.StorageFolder.prototype.createFolderAsync = function(desiredName, options) {};

/**
 * Gets a query result object that contains the subfolders in the current folder.
 * Gets a query result object that contains the subfolders in the current folder. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , gets a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. Files are grouped into folders based on the specified value from the CommonFolderQuery enumeration.
 * @param {Windows.Storage.Search.CommonFolderQuery=} query One of the enumeration values that specifies how to group the files into folders and determines whether the query is shallow or deep.
 * @return {!Windows.Storage.Search.StorageFolderQueryResult} A query result object. Call the GetFoldersAsync method of the query result to get the subfolders in the current folder. This method returns a list of type IReadOnlyList< StorageFolder >. Each file or folder is represented by an item of type StorageFolder. / A query result object. Call the GetFoldersAsync method of the query result to get the subfolders in the current folder. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , the query result object contains a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. (Files from the current folder are not included.) The files are grouped as specified by query. The list is of type IReadOnlyList< StorageFolder >. Each folder in the list is represented by a StorageFolder object.
 */
Windows.Storage.StorageFolder.prototype.createFolderQuery = function(query) {};

/**
 * Gets a query result object that contains the subfolders in the current folder and, optionally, nested subfolders. The results are based on the specified QueryOptions .
 * @param {!Windows.Storage.Search.QueryOptions} queryOptions The criteria that are applied to the query.
 * @return {!Windows.Storage.Search.StorageFolderQueryResult} A query result object. Call the GetFoldersAsync method of the query result to get the subfolders in the current folder. If you provided a CommonFolderQuery value other than CommonFolderQuery.DefaultQuery when you instantiated the QueryOptions , the query result object contains a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. (Files from the current folder are not included.) The files are grouped as specified by queryOptions. The list is of type IReadOnlyList< StorageFolder >. Each folder in the list is represented by a StorageFolder object.
 */
Windows.Storage.StorageFolder.prototype.createFolderQueryWithOptions = function(queryOptions) {};

/**
 * Gets a query result object that contains the files and subfolders in the current folder.
 * @return {!Windows.Storage.Search.StorageItemQueryResult} A query result object. Call the GetItemsAsync method of the query result to get the files and subfolders in the current folder. This method returns a list of type IReadOnlyList< IStorageItem >. Each file or folder is represented by an item of type IStorageItem.
 */
Windows.Storage.StorageFolder.prototype.createItemQuery = function() {};

/**
 * Gets a query result object that contains the files and subfolders in the current folder and, optionally, in the subfolders of the current folder. The results are based on the specified QueryOptions .
 * @param {!Windows.Storage.Search.QueryOptions} queryOptions The criteria that are applied to the query.
 * @return {!Windows.Storage.Search.StorageItemQueryResult} A query result object. Call the GetItemsAsync method of the query result to get the files and subfolders in the current folder and, optionally, in the subfolders of the current folder, filtered and sorted based on the specified QueryOptions . This method returns a list of type IReadOnlyList< IStorageItem >. Each file or folder is represented by an item of type IStorageItem.
 */
Windows.Storage.StorageFolder.prototype.createItemQueryWithOptions = function(queryOptions) {};

/**
 * Deletes the current folder. This method also specifies whether to delete the folder permanently.
 * Deletes the current folder.
 * @param {Windows.Storage.StorageDeleteOption=} option One of the enumeration values that specifies whether to delete the folder permanently.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method when it completes.
 */
Windows.Storage.StorageFolder.prototype.deleteAsync = function(option) {};

/**
 * Gets the basic properties of the current folder or file group.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.BasicProperties, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.BasicProperties>>} When this method completes successfully, it returns the basic properties of the current folder or file group as a BasicProperties object.
 */
Windows.Storage.StorageFolder.prototype.getBasicPropertiesAsync = function() {};

/**
 * Gets the file with the specified name from the current folder.
 * @param {string} name The name (or path relative to the current folder) of the file to get.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes successfully, it returns a StorageFile that represents the specified file.
 */
Windows.Storage.StorageFolder.prototype.getFileAsync = function(name) {};

/**
 * Gets the files in the current folder. Also gets the files from the subfolders of the current folder when the value of the query argument is something other than CommonFileQuery.DefaultQuery . Files are sorted based on the specified value from the CommonFileQuery enumeration.
 * Gets the files in the current folder.
 * Gets an index-based range of files from the list of all files in the current folder. Also gets the files from the subfolders of the current folder when the value of the query argument is something other than CommonFileQuery.DefaultQuery . Files are sorted based on the specified value from the CommonFileQuery enumeration.
 * @param {Windows.Storage.Search.CommonFileQuery=} query One of the enumeration values that specifies how to sort the files and determines whether the query is shallow or deep.
 * @param {number=} startIndex The zero-based index of the first file in the range to retrieve.
 * @param {number=} maxItemsToRetrieve The maximum number of files to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns a flat list of files, sorted as specified by query. The list is of type IReadOnlyList< StorageFile >. Each file in the list is represented by a StorageFile object. / When this method completes successfully, it returns a list of the files in the current folder. The list is of type IReadOnlyList< StorageFile >. Each file in the list is represented by a StorageFile object. / When this method completes successfully, it returns a flat list of files sorted as specified by query. The list is of type IReadOnlyList< StorageFile >. Each file in the list is represented by a StorageFile object.
 */
Windows.Storage.StorageFolder.prototype.getFilesAsync = function(query, startIndex, maxItemsToRetrieve) {};

/**
 * Gets the subfolder with the specified name from the current folder.
 * @param {string} name The name (or path relative to the current folder) of the subfolder to get.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes successfully, it returns a StorageFolder that represents the specified subfolder.
 */
Windows.Storage.StorageFolder.prototype.getFolderAsync = function(name) {};

/**
 * Gets the subfolders in the current folder.
 * Gets the subfolders in the current folder. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , gets a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. Files are grouped into folders based on the specified value from the CommonFolderQuery enumeration.
 * Gets an index-based range of folders from the list of all subfolders in the current folder. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , gets a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. Files are grouped into folders based on the specified value from the CommonFolderQuery enumeration.
 * @param {Windows.Storage.Search.CommonFolderQuery=} query One of the enumeration values that specifies how to group the files into folders and determines whether the query is shallow or deep.
 * @param {number=} startIndex The zero-based index of the first folder in the range to retrieve.
 * @param {number=} maxItemsToRetrieve The maximum number of folders to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns a list of the subfolders in the current folder. The list is of type IReadOnlyList< StorageFolder >. Each folder in the list is represented by a StorageFolder object. / When this method completes successfully, it returns a list of subfolders. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , this method returns a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. (Files from the current folder are not included.) The files are grouped as specified by query. The list is of type IReadOnlyList< StorageFolder >. Each folder in the list is represented by a StorageFolder object.
 */
Windows.Storage.StorageFolder.prototype.getFoldersAsync = function(query, startIndex, maxItemsToRetrieve) {};

/**
 * Gets the indexed state of the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.Storage.Search.IndexedState, !Windows.Foundation.IAsyncOperation<Windows.Storage.Search.IndexedState>>} When this method completes successfully, it returns an IndexedState enum value that describes the state of the folder.
 */
Windows.Storage.StorageFolder.prototype.getIndexedStateAsync = function() {};

/**
 * Gets the file or folder with the specified name from the current folder.
 * @param {string} name The name (or path relative to the current folder) of the file or folder to get.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.IStorageItem, !Windows.Foundation.IAsyncOperation<!Windows.Storage.IStorageItem>>} When this method completes successfully, it returns an IStorageItem that represents the specified file or folder.
 */
Windows.Storage.StorageFolder.prototype.getItemAsync = function(name) {};

/**
 * Gets the files and subfolders in the current folder.
 * Gets an index-based range of files and folders from the list of all files and subfolders in the current folder.
 * @param {number=} startIndex The zero-based index of the first item in the range to get.
 * @param {number=} maxItemsToRetrieve The maximum number of items to get.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns a list of the files and folders in the current folder. The list is of type IReadOnlyList< IStorageItem >. Each item in the list is represented by an IStorageItem object. / When this method completes successfully, it returns a list of the files and subfolders in the current folder. The list is of type IReadOnlyList< IStorageItem >. Each item in the list is represented by an IStorageItem object.
 */
Windows.Storage.StorageFolder.prototype.getItemsAsync = function(startIndex, maxItemsToRetrieve) {};

/**
 * Gets the parent folder of the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes, it returns the parent folder as a StorageFolder .
 */
Windows.Storage.StorageFolder.prototype.getParentAsync = function() {};

/**
 * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail, the requested size, and the specified options
 * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail and the requested size.
 * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail.
 * @param {Windows.Storage.FileProperties.ThumbnailMode} mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @param {number=} requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
 * @param {Windows.Storage.FileProperties.ThumbnailOptions=} options The enum value that describes the desired behavior to use to retrieve the thumbnail image. The specified behavior might affect the size and/or quality of the image and how quickly the thumbnail image is retrieved.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.StorageItemThumbnail, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.StorageItemThumbnail>>} When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the item.
 */
Windows.Storage.StorageFolder.prototype.getScaledImageAsThumbnailAsync = function(mode, requestedSize, options) {};

/**
 * Gets a thumbnail image for the current folder, sized for the specified purpose of the thumbnail and adjusted to the requested size with the specified options.
 * Gets a thumbnail image for the current folder, sized for the specified purpose of the thumbnail and adjusted to the requested size.
 * Gets a thumbnail image for the current folder, sized for the specified purpose of the thumbnail.
 * @param {Windows.Storage.FileProperties.ThumbnailMode} mode A value from the enumeration that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
 * @param {number=} requestedSize The requested size, in pixels, of the longest edge of the thumbnail. This method uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
 * @param {Windows.Storage.FileProperties.ThumbnailOptions=} options A value from the enumeration that specifies how to retrieve and size the image. The default value, UseCurrentScale, is suitable for most apps.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.StorageItemThumbnail, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.StorageItemThumbnail>>} When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image, or null if there is no thumbnail image associated with the folder.
 */
Windows.Storage.StorageFolder.prototype.getThumbnailAsync = function(mode, requestedSize, options) {};

/**
 * Indicates whether the current folder supports the specified CommonFileQuery .
 * @param {Windows.Storage.Search.CommonFileQuery} query The value to test.
 * @return {boolean} True if the folder supports the specified CommonFileQuery ; otherwise, false.
 */
Windows.Storage.StorageFolder.prototype.isCommonFileQuerySupported = function(query) {};

/**
 * Indicates whether the current folder supports the specified CommonFolderQuery .
 * @param {Windows.Storage.Search.CommonFolderQuery} query The value to test.
 * @return {boolean} True if the folder supports the specified CommonFolderQuery ; otherwise, false.
 */
Windows.Storage.StorageFolder.prototype.isCommonFolderQuerySupported = function(query) {};

/**
 * Indicates whether the current folder is equal to the specified folder.
 * @param {!Windows.Storage.IStorageItem} item The IStorageItem object that represents the folder to compare against.
 * @return {boolean} Returns true if the current folder is equal to the specified folder; otherwise false.
 */
Windows.Storage.StorageFolder.prototype.isEqual = function(item) {};

/**
 * Indicates whether the current StorageFolder matches the specified StorageItemTypes value.
 * @param {Windows.Storage.StorageItemTypes} type The enum value that determines the object type to match against.
 * @return {boolean} True if the StorageFolder matches the specified StorageItemTypes value; otherwise false.
 */
Windows.Storage.StorageFolder.prototype.isOfType = function(type) {};

/**
 * Renames the current folder.
 * Renames the current folder and specifies what to do if a folder with the same name already exists.
 * @param {string} desiredName The desired, new name for the current folder.
 * @param {Windows.Storage.NameCollisionOption=} option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing item in the current folder's location.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method when it completes.
 */
Windows.Storage.StorageFolder.prototype.renameAsync = function(desiredName, option) {};

/**
 * Tries to get the file or folder with the specified name from the current folder. Returns null instead of raising an exception if the specified file or folder is not found.
 * @param {string} name The name (or path relative to the current folder) of the file or folder to get.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.IStorageItem, !Windows.Foundation.IAsyncOperation<!Windows.Storage.IStorageItem>>} When this method completes successfully, it returns an IStorageItem that represents the specified file or folder. If the specified file or folder is not found, this method returns null instead of raising an exception.
 */
Windows.Storage.StorageFolder.prototype.tryGetItemAsync = function(name) {};

/** @const */
Windows.Storage.StorageItemTypes = {};
/** @const {number} */
Windows.Storage.StorageItemTypes.none;
/** @const {number} */
Windows.Storage.StorageItemTypes.file;
/** @const {number} */
Windows.Storage.StorageItemTypes.folder;
/**
 * @constructor
 * @struct
 */
Windows.Storage.StorageLibrary = function() {};
 /** @type {!Windows.Foundation.Collections.IObservableVector<!Windows.Storage.StorageFolder>} */
Windows.Storage.StorageLibrary.prototype.folders;
 /** @type {function(?): void} */
Windows.Storage.StorageLibrary.prototype.ondefinitionchanged;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.Storage.StorageLibrary.prototype.saveFolder;

/**
 * Gets the specified library.
 * @param {Windows.Storage.KnownLibraryId} libraryId A KnownLibraryId value that identifies the library to retrieve, like Music or Videos.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageLibrary, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageLibrary>>} When this method completes successfully, it returns the library (type StorageLibrary ).
 */
Windows.Storage.StorageLibrary.getLibraryAsync = function(libraryId) {};

/**
 * Gets the specified library for a User .
 * @param {!Windows.System.User} user The User for which the library is retrieved.
 * @param {Windows.Storage.KnownLibraryId} libraryId A KnownLibraryId value that identifies the library to retrieve, like Music or Videos.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageLibrary, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageLibrary>>} When this method completes successfully, it returns the library (type StorageLibrary ).
 */
Windows.Storage.StorageLibrary.getLibraryForUserAsync = function(user, libraryId) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.StorageLibrary.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Storage.StorageLibrary.prototype.removeEventListener = function(type, listener) {};

/**
 * Prompts the user to select a folder, and then adds the folder to the library.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes, it returns the folder that the user picked and added as a StorageFolder . If the user cancels the operation and doesn't pick a folder, the method returns null.
 */
Windows.Storage.StorageLibrary.prototype.requestAddFolderAsync = function() {};

/**
 * Prompts the user to confirm removal of the specified folder from the current library, and then removes the folder.
 * @param {!Windows.Storage.StorageFolder} folder The folder to remove.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} Returns true if the folder was removed; otherwise false.
 */
Windows.Storage.StorageLibrary.prototype.requestRemoveFolderAsync = function(folder) {};

/** @const */
Windows.Storage.StorageOpenOptions = {};
/** @const {number} */
Windows.Storage.StorageOpenOptions.none;
/** @const {number} */
Windows.Storage.StorageOpenOptions.allowOnlyReaders;
/**
 * @constructor
 * @struct
 */
Windows.Storage.StorageProvider = function() {};
 /** @type {string} */
Windows.Storage.StorageProvider.prototype.displayName;
 /** @type {string} */
Windows.Storage.StorageProvider.prototype.id;
/**
 * @constructor
 * @struct
 */
Windows.Storage.StorageStreamTransaction = function() {};
 /** @type {!Windows.Storage.Streams.IRandomAccessStream} */
Windows.Storage.StorageStreamTransaction.prototype.stream;

/**
 * Releases system resources that are exposed by the stream, indicating that the data request is complete.
 * @return {void}
 */
Windows.Storage.StorageStreamTransaction.prototype.close = function() {};

/**
 * Save the stream to the underlying file.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method.
 */
Windows.Storage.StorageStreamTransaction.prototype.commitAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.StreamedFileDataRequest = function() {};

/**
 * Releases system resources that are exposed by the current stream indicating that the data request is complete.
 * @return {void}
 */
Windows.Storage.StreamedFileDataRequest.prototype.close = function() {};

/**
 * Indicates that the data can't be streamed and releases system resources that are exposed by the current stream indicating that the data request is complete.
 * @param {Windows.Storage.StreamedFileFailureMode} failureMode The enum value that indicates why the data stream can't be accessed.
 * @return {void}
 */
Windows.Storage.StreamedFileDataRequest.prototype.failAndClose = function(failureMode) {};

/**
 * Flushes the data in the current stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} When this method completes, it returns true if the data was flushed successfully or false if the flush operation failed.
 */
Windows.Storage.StreamedFileDataRequest.prototype.flushAsync = function() {};

/**
 * Writes data from a buffer to the current stream.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer that contains the data to write.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} When this method completes, it returns the number of bytes (type UInt32 ) that were written to the stream. If the app specifies a function to monitor progress, that function receives the number of bytes (type UInt32) written so far.
 */
Windows.Storage.StreamedFileDataRequest.prototype.writeAsync = function(buffer) {};

/** @const */
Windows.Storage.StreamedFileFailureMode = {};
/** @const {number} */
Windows.Storage.StreamedFileFailureMode.failed;
/** @const {number} */
Windows.Storage.StreamedFileFailureMode.currentlyUnavailable;
/** @const {number} */
Windows.Storage.StreamedFileFailureMode.incomplete;
/** @const */
Windows.Storage.Streams = {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the Buffer class with the specified capacity.
 * @param {number} capacity The maximum number of bytes that the buffer can hold.
 */
Windows.Storage.Streams.Buffer = function(capacity) {};
 /** @type {?} */
Windows.Storage.Streams.Buffer.prototype.byteLength;
 /** @type {number} */
Windows.Storage.Streams.Buffer.prototype.capacity;
 /** @type {number} */
Windows.Storage.Streams.Buffer.prototype.length;

/**
 * Creates a new buffer containing a copy of a specified buffer.
 * @param {!Windows.Foundation.IMemoryBuffer} input The buffer to be copied.
 * @return {!Windows.Storage.Streams.Buffer} The newly created copy.
 */
Windows.Storage.Streams.Buffer.createCopyFromMemoryBuffer = function(input) {};

/**
 * Creates a MemoryBuffer from an existing IBuffer .
 * @param {!Windows.Storage.Streams.IBuffer} input The input IBuffer .
 * @return {!Windows.Foundation.MemoryBuffer} The newly created MemoryBuffer .
 */
Windows.Storage.Streams.Buffer.createMemoryBufferOverIBuffer = function(input) {};

/** @const */
Windows.Storage.Streams.ByteOrder = {};
/** @const {number} */
Windows.Storage.Streams.ByteOrder.littleEndian;
/** @const {number} */
Windows.Storage.Streams.ByteOrder.bigEndian;

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the data reader.
 * @param {!Windows.Storage.Streams.IInputStream} inputStream The input stream.
 */
Windows.Storage.Streams.DataReader = function(inputStream) {};
 /** @type {Windows.Storage.Streams.ByteOrder} */
Windows.Storage.Streams.DataReader.prototype.byteOrder;
 /** @type {Windows.Storage.Streams.InputStreamOptions} */
Windows.Storage.Streams.DataReader.prototype.inputStreamOptions;
 /** @type {number} */
Windows.Storage.Streams.DataReader.prototype.unconsumedBufferLength;
 /** @type {Windows.Storage.Streams.UnicodeEncoding} */
Windows.Storage.Streams.DataReader.prototype.unicodeEncoding;

/**
 * Creates a new instance of the data reader with data from the specified buffer.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer.
 * @return {!Windows.Storage.Streams.DataReader} The data reader.
 */
Windows.Storage.Streams.DataReader.fromBuffer = function(buffer) {};

/**
 * Closes the current stream and releases system resources.
 * @return {void}
 */
Windows.Storage.Streams.DataReader.prototype.close = function() {};

/**
 * Detaches the buffer that is associated with the data reader.
 * @return {!Windows.Storage.Streams.IBuffer} The detached buffer.
 */
Windows.Storage.Streams.DataReader.prototype.detachBuffer = function() {};

/**
 * Detaches the stream that is associated with the data reader.
 * @return {!Windows.Storage.Streams.IInputStream} The detached stream.
 */
Windows.Storage.Streams.DataReader.prototype.detachStream = function() {};

/**
 * Loads data from the input stream.
 * @param {number} count The count of bytes to load into the intermediate buffer.
 * @return {!Windows.Foundation.IPromiseWithOperation<?, !Windows.Storage.Streams.DataReaderLoadOperation>} The asynchronous load data request.
 */
Windows.Storage.Streams.DataReader.prototype.loadAsync = function(count) {};

/**
 * Reads a Boolean value from the input stream.
 * @return {boolean} The value.
 */
Windows.Storage.Streams.DataReader.prototype.readBoolean = function() {};

/**
 * Reads a buffer from the input stream.
 * @param {number} length The length of the buffer, in bytes.
 * @return {!Windows.Storage.Streams.IBuffer} The buffer.
 */
Windows.Storage.Streams.DataReader.prototype.readBuffer = function(length) {};

/**
 * Reads a byte value from the input stream.
 * @return {number} The value.
 */
Windows.Storage.Streams.DataReader.prototype.readByte = function() {};

/**
 * Reads an array of byte values from the input stream.
 * @return {!Array<number>} The array that receives the byte values.
 */
Windows.Storage.Streams.DataReader.prototype.readBytes = function() {};

/**
 * Reads a date and time value from the input stream.
 * @return {!Date} The value.
 */
Windows.Storage.Streams.DataReader.prototype.readDateTime = function() {};

/**
 * Reads a floating-point value from the input stream.
 * @return {number} The value.
 */
Windows.Storage.Streams.DataReader.prototype.readDouble = function() {};

/**
 * Reads a GUID value from the input stream.
 * @return {string} The value.
 */
Windows.Storage.Streams.DataReader.prototype.readGuid = function() {};

/**
 * Reads a 16-bit integer value from the input stream.
 * @return {number} The value.
 */
Windows.Storage.Streams.DataReader.prototype.readInt16 = function() {};

/**
 * Reads a 32-bit integer value from the input stream.
 * @return {number} The value.
 */
Windows.Storage.Streams.DataReader.prototype.readInt32 = function() {};

/**
 * Reads a 64-bit integer value from the input stream.
 * @return {number} The value.
 */
Windows.Storage.Streams.DataReader.prototype.readInt64 = function() {};

/**
 * Reads a floating-point value from the input stream.
 * @return {number} The value.
 */
Windows.Storage.Streams.DataReader.prototype.readSingle = function() {};

/**
 * Reads a string value from the input stream.
 * @param {number} codeUnitCount The length of the string.
 * @return {string} The value.
 */
Windows.Storage.Streams.DataReader.prototype.readString = function(codeUnitCount) {};

/**
 * Reads a time-interval value from the input stream.
 * @return {number} The value.
 */
Windows.Storage.Streams.DataReader.prototype.readTimeSpan = function() {};

/**
 * Reads a 16-bit unsigned integer from the input stream.
 * @return {number} The value.
 */
Windows.Storage.Streams.DataReader.prototype.readUInt16 = function() {};

/**
 * Reads a 32-bit unsigned integer from the input stream.
 * @return {number} The value.
 */
Windows.Storage.Streams.DataReader.prototype.readUInt32 = function() {};

/**
 * Reads a 64-bit unsigned integer from the input stream.
 * @return {number} The value.
 */
Windows.Storage.Streams.DataReader.prototype.readUInt64 = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Streams.DataReaderLoadOperation = function() {};
 /** @type {function(!Windows.Foundation.IAsyncOperation<number>, Windows.Foundation.AsyncStatus): void} */
Windows.Storage.Streams.DataReaderLoadOperation.prototype.completed;
 /** @type {!Windows.WinRTError} */
Windows.Storage.Streams.DataReaderLoadOperation.prototype.errorCode;
 /** @type {number} */
Windows.Storage.Streams.DataReaderLoadOperation.prototype.id;
 /** @type {Windows.Foundation.AsyncStatus} */
Windows.Storage.Streams.DataReaderLoadOperation.prototype.status;

/**
 * Requests the cancellation of the data load operation.
 * @return {void}
 */
Windows.Storage.Streams.DataReaderLoadOperation.prototype.cancel = function() {};

/**
 * Requests that work associated with the data load operation should stop.
 * @return {void}
 */
Windows.Storage.Streams.DataReaderLoadOperation.prototype.close = function() {};

/**
 * Returns the result of the data load operation.
 * @return {number} The result of the operation.
 */
Windows.Storage.Streams.DataReaderLoadOperation.prototype.getResults = function() {};

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the data writer.
 * Creates and initializes a new instance of the data writer to an output stream.
 * @param {!Windows.Storage.Streams.IOutputStream=} outputStream The new output stream instance.
 */
Windows.Storage.Streams.DataWriter = function(outputStream) {};
 /** @type {Windows.Storage.Streams.ByteOrder} */
Windows.Storage.Streams.DataWriter.prototype.byteOrder;
 /** @type {Windows.Storage.Streams.UnicodeEncoding} */
Windows.Storage.Streams.DataWriter.prototype.unicodeEncoding;
 /** @type {number} */
Windows.Storage.Streams.DataWriter.prototype.unstoredBufferLength;

/**
 * Closes the current stream and releases system resources.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.close = function() {};

/**
 * Detaches the buffer that is associated with the data writer.
 * @return {!Windows.Storage.Streams.IBuffer} The detached buffer.
 */
Windows.Storage.Streams.DataWriter.prototype.detachBuffer = function() {};

/**
 * Detaches the stream that is associated with the data writer.
 * @return {!Windows.Storage.Streams.IOutputStream} The detached stream.
 */
Windows.Storage.Streams.DataWriter.prototype.detachStream = function() {};

/**
 * Flushes data asynchronously.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The stream flush operation.
 */
Windows.Storage.Streams.DataWriter.prototype.flushAsync = function() {};

/**
 * Gets the size of a string.
 * @param {string} value The string.
 * @return {number} The size of the string, in bytes.
 */
Windows.Storage.Streams.DataWriter.prototype.measureString = function(value) {};

/**
 * Commits data in the buffer to a backing store.
 * @return {!Windows.Foundation.IPromiseWithOperation<?, !Windows.Storage.Streams.DataWriterStoreOperation>} The asynchronous store data operation.
 */
Windows.Storage.Streams.DataWriter.prototype.storeAsync = function() {};

/**
 * Writes a Boolean value to the output stream.
 * @param {boolean} value The value.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeBoolean = function(value) {};

/**
 * Writes the specified bytes from a buffer to the output stream.
 * Writes the contents of the specified buffer to the output stream.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer.
 * @param {number=} start The starting byte.
 * @param {number=} count The number of bytes to write.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeBuffer = function(buffer, start, count) {};

/**
 * Writes a byte value to the output stream.
 * @param {number} value The value.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeByte = function(value) {};

/**
 * Writes an array of byte values to the output stream.
 * @param {!Array<number>} value The array of values.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeBytes = function(value) {};

/**
 * Writes a date and time value to the output stream.
 * @param {!Date} value The value.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeDateTime = function(value) {};

/**
 * Writes a floating-point value to the output stream.
 * @param {number} value The value.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeDouble = function(value) {};

/**
 * Writes a GUID value to the output stream.
 * @param {string} value The value.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeGuid = function(value) {};

/**
 * Writes a 16-bit integer value to the output stream.
 * @param {number} value The value.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeInt16 = function(value) {};

/**
 * Writes a 32-bit integer value to the output stream.
 * @param {number} value The value.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeInt32 = function(value) {};

/**
 * Writes a 64-bit integer value to the output stream.
 * @param {number} value The value.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeInt64 = function(value) {};

/**
 * Writes a floating-point value to the output stream.
 * @param {number} value The value.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeSingle = function(value) {};

/**
 * Writes a string value to the output stream.
 * @param {string} value The value.
 * @return {number} The length of the string, in bytes.
 */
Windows.Storage.Streams.DataWriter.prototype.writeString = function(value) {};

/**
 * Writes a time-interval value to the output stream.
 * @param {number} value The value.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeTimeSpan = function(value) {};

/**
 * Writes a 16-bit unsigned integer value to the output stream.
 * @param {number} value The value.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeUInt16 = function(value) {};

/**
 * Writes a 32-bit unsigned integer value to the output stream.
 * @param {number} value The value.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeUInt32 = function(value) {};

/**
 * Writes a 64-bit unsigned integer value to the output stream.
 * @param {number} value The value.
 * @return {void}
 */
Windows.Storage.Streams.DataWriter.prototype.writeUInt64 = function(value) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Streams.DataWriterStoreOperation = function() {};
 /** @type {function(!Windows.Foundation.IAsyncOperation<number>, Windows.Foundation.AsyncStatus): void} */
Windows.Storage.Streams.DataWriterStoreOperation.prototype.completed;
 /** @type {!Windows.WinRTError} */
Windows.Storage.Streams.DataWriterStoreOperation.prototype.errorCode;
 /** @type {number} */
Windows.Storage.Streams.DataWriterStoreOperation.prototype.id;
 /** @type {Windows.Foundation.AsyncStatus} */
Windows.Storage.Streams.DataWriterStoreOperation.prototype.status;

/**
 * Requests the cancellation of the data store operation.
 * @return {void}
 */
Windows.Storage.Streams.DataWriterStoreOperation.prototype.cancel = function() {};

/**
 * Requests that work associated with the data store operation should stop.
 * @return {void}
 */
Windows.Storage.Streams.DataWriterStoreOperation.prototype.close = function() {};

/**
 * Returns the result of the data store operation.
 * @return {number} The result of the operation.
 */
Windows.Storage.Streams.DataWriterStoreOperation.prototype.getResults = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Streams.FileInputStream = function() {};

/**
 * Closes the current stream and releases system resources.
 * @return {void}
 */
Windows.Storage.Streams.FileInputStream.prototype.close = function() {};

/**
 * Returns an asynchronous byte reader object.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param {number} count The number of bytes to read that is less than or equal to the Capacity value.
 * @param {Windows.Storage.Streams.InputStreamOptions} options Specifies the type of the asynchronous read operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The asynchronous operation.
 */
Windows.Storage.Streams.FileInputStream.prototype.readAsync = function(buffer, count, options) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Streams.FileOutputStream = function() {};

/**
 * Closes the current stream and releases system resources.
 * @return {void}
 */
Windows.Storage.Streams.FileOutputStream.prototype.close = function() {};

/**
 * Flushes data asynchronously in a sequential stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The stream flush operation.
 */
Windows.Storage.Streams.FileOutputStream.prototype.flushAsync = function() {};

/**
 * Writes data asynchronously to a file.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous writer operation writes.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The byte writer operation.
 */
Windows.Storage.Streams.FileOutputStream.prototype.writeAsync = function(buffer) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Streams.FileRandomAccessStream = function() {};
 /** @type {boolean} */
Windows.Storage.Streams.FileRandomAccessStream.prototype.canRead;
 /** @type {boolean} */
Windows.Storage.Streams.FileRandomAccessStream.prototype.canWrite;
 /** @type {number} */
Windows.Storage.Streams.FileRandomAccessStream.prototype.position;
 /** @type {number} */
Windows.Storage.Streams.FileRandomAccessStream.prototype.size;

/**
 * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
 * @return {!Windows.Storage.Streams.IRandomAccessStream} The new stream. The initial, internal position of the stream is 0.
 */
Windows.Storage.Streams.FileRandomAccessStream.prototype.cloneStream = function() {};

/**
 * Closes the current stream and releases system resources.
 * @return {void}
 */
Windows.Storage.Streams.FileRandomAccessStream.prototype.close = function() {};

/**
 * Flushes data asynchronously in a sequential stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The stream flush operation.
 */
Windows.Storage.Streams.FileRandomAccessStream.prototype.flushAsync = function() {};

/**
 * Returns an input stream at a specified location in a stream.
 * @param {number} position The location in the stream at which to begin.
 * @return {!Windows.Storage.Streams.IInputStream} The input stream.
 */
Windows.Storage.Streams.FileRandomAccessStream.prototype.getInputStreamAt = function(position) {};

/**
 * Returns an output stream at a specified location in a stream.
 * @param {number} position The location in the output stream at which to begin.
 * @return {!Windows.Storage.Streams.IOutputStream} The output stream.
 */
Windows.Storage.Streams.FileRandomAccessStream.prototype.getOutputStreamAt = function(position) {};

/**
 * Returns an asynchronous byte reader object.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param {number} count The number of bytes to read that is less than or equal to the Capacity value.
 * @param {Windows.Storage.Streams.InputStreamOptions} options Specifies the type of the asynchronous read operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The asynchronous operation.
 */
Windows.Storage.Streams.FileRandomAccessStream.prototype.readAsync = function(buffer, count, options) {};

/**
 * Sets the position of the stream to the specified value.
 * @param {number} position The new position of the stream.
 * @return {void}
 */
Windows.Storage.Streams.FileRandomAccessStream.prototype.seek = function(position) {};

/**
 * Writes data asynchronously to a file.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous writer operation writes.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The byte writer operation.
 */
Windows.Storage.Streams.FileRandomAccessStream.prototype.writeAsync = function(buffer) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the InMemoryRandomAccessStream class.
 */
Windows.Storage.Streams.InMemoryRandomAccessStream = function() {};
 /** @type {boolean} */
Windows.Storage.Streams.InMemoryRandomAccessStream.prototype.canRead;
 /** @type {boolean} */
Windows.Storage.Streams.InMemoryRandomAccessStream.prototype.canWrite;
 /** @type {number} */
Windows.Storage.Streams.InMemoryRandomAccessStream.prototype.position;
 /** @type {number} */
Windows.Storage.Streams.InMemoryRandomAccessStream.prototype.size;

/**
 * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
 * @return {!Windows.Storage.Streams.IRandomAccessStream} The new stream. The initial, internal position of the stream is 0.
 */
Windows.Storage.Streams.InMemoryRandomAccessStream.prototype.cloneStream = function() {};

/**
 * Closes the current stream and releases system resources.
 * @return {void}
 */
Windows.Storage.Streams.InMemoryRandomAccessStream.prototype.close = function() {};

/**
 * Flushes data asynchronously in a sequential stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The stream flush operation.
 */
Windows.Storage.Streams.InMemoryRandomAccessStream.prototype.flushAsync = function() {};

/**
 * Returns an input stream at a specified location in a stream.
 * @param {number} position The location in the stream at which to begin.
 * @return {!Windows.Storage.Streams.IInputStream} The input stream.
 */
Windows.Storage.Streams.InMemoryRandomAccessStream.prototype.getInputStreamAt = function(position) {};

/**
 * Returns an output stream at a specified location in a stream.
 * @param {number} position The location in the output stream at which to begin.
 * @return {!Windows.Storage.Streams.IOutputStream} The output stream.
 */
Windows.Storage.Streams.InMemoryRandomAccessStream.prototype.getOutputStreamAt = function(position) {};

/**
 * Returns an asynchronous byte reader object.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param {number} count The number of bytes to read that is less than or equal to the Capacity value.
 * @param {Windows.Storage.Streams.InputStreamOptions} options Specifies the type of the asynchronous read operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The asynchronous operation.
 */
Windows.Storage.Streams.InMemoryRandomAccessStream.prototype.readAsync = function(buffer, count, options) {};

/**
 * Sets the position of the stream to the specified value.
 * @param {number} position The new position of the stream.
 * @return {void}
 */
Windows.Storage.Streams.InMemoryRandomAccessStream.prototype.seek = function(position) {};

/**
 * Writes data asynchronously in a sequential stream.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous writer operation writes.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The byte writer operation.
 */
Windows.Storage.Streams.InMemoryRandomAccessStream.prototype.writeAsync = function(buffer) {};

/** @const */
Windows.Storage.Streams.InputStreamOptions = {};
/** @const {number} */
Windows.Storage.Streams.InputStreamOptions.none;
/** @const {number} */
Windows.Storage.Streams.InputStreamOptions.partial;
/** @const {number} */
Windows.Storage.Streams.InputStreamOptions.readAhead;
/**
 * @constructor
 * @struct
 */
Windows.Storage.Streams.InputStreamOverStream = function() {};

/**
 * Closes the current stream and releases system resources.
 * @return {void}
 */
Windows.Storage.Streams.InputStreamOverStream.prototype.close = function() {};

/**
 * Returns an asynchronous byte reader object.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param {number} count The number of bytes to read that is less than or equal to the Capacity value.
 * @param {Windows.Storage.Streams.InputStreamOptions} options Specifies the type of the asynchronous read operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The asynchronous operation.
 */
Windows.Storage.Streams.InputStreamOverStream.prototype.readAsync = function(buffer, count, options) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Streams.OutputStreamOverStream = function() {};

/**
 * Closes the current stream and releases system resources.
 * @return {void}
 */
Windows.Storage.Streams.OutputStreamOverStream.prototype.close = function() {};

/**
 * Flushes data asynchronously in a sequential stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The stream flush operation.
 */
Windows.Storage.Streams.OutputStreamOverStream.prototype.flushAsync = function() {};

/**
 * Writes data asynchronously in a sequential stream.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous writer operation writes.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The byte writer operation.
 */
Windows.Storage.Streams.OutputStreamOverStream.prototype.writeAsync = function(buffer) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Streams.RandomAccessStream = function() {};

/**
 * Copies a source stream to a destination stream and waits for the copy operation to complete.
 * @param {!Windows.Storage.Streams.IInputStream} source The stream to copy data from.
 * @param {!Windows.Storage.Streams.IOutputStream} destination The stream to copy data to.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The asynchronous operation.
 */
Windows.Storage.Streams.RandomAccessStream.copyAndCloseAsync = function(source, destination) {};

/**
 * Copies the specified number of bytes from a source stream to a destination stream.
 * Copies a source stream to a destination stream.
 * @param {!Windows.Storage.Streams.IInputStream} source The stream to copy data from.
 * @param {!Windows.Storage.Streams.IOutputStream} destination The stream to copy data to.
 * @param {number=} bytesToCopy The number of bytes to copy.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The asynchronous operation.
 */
Windows.Storage.Streams.RandomAccessStream.copyAsync = function(source, destination, bytesToCopy) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Streams.RandomAccessStreamOverStream = function() {};
 /** @type {boolean} */
Windows.Storage.Streams.RandomAccessStreamOverStream.prototype.canRead;
 /** @type {boolean} */
Windows.Storage.Streams.RandomAccessStreamOverStream.prototype.canWrite;
 /** @type {number} */
Windows.Storage.Streams.RandomAccessStreamOverStream.prototype.position;
 /** @type {number} */
Windows.Storage.Streams.RandomAccessStreamOverStream.prototype.size;

/**
 * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
 * @return {!Windows.Storage.Streams.IRandomAccessStream} The new stream. The initial, internal position of the stream is 0.
 */
Windows.Storage.Streams.RandomAccessStreamOverStream.prototype.cloneStream = function() {};

/**
 * Closes the current stream and releases system resources.
 * @return {void}
 */
Windows.Storage.Streams.RandomAccessStreamOverStream.prototype.close = function() {};

/**
 * Flushes data asynchronously in a sequential stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The stream flush operation.
 */
Windows.Storage.Streams.RandomAccessStreamOverStream.prototype.flushAsync = function() {};

/**
 * Returns an input stream at a specified location in a stream.
 * @param {number} position The location in the stream at which to begin.
 * @return {!Windows.Storage.Streams.IInputStream} The input stream.
 */
Windows.Storage.Streams.RandomAccessStreamOverStream.prototype.getInputStreamAt = function(position) {};

/**
 * Returns an output stream at a specified location in a stream.
 * @param {number} position The location in the output stream at which to begin.
 * @return {!Windows.Storage.Streams.IOutputStream} The output stream.
 */
Windows.Storage.Streams.RandomAccessStreamOverStream.prototype.getOutputStreamAt = function(position) {};

/**
 * Returns an asynchronous byte reader object.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous read operation places the bytes that are read.
 * @param {number} count The number of bytes to read that is less than or equal to the Capacity value.
 * @param {Windows.Storage.Streams.InputStreamOptions} options Specifies the type of the asynchronous read operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The asynchronous operation.
 */
Windows.Storage.Streams.RandomAccessStreamOverStream.prototype.readAsync = function(buffer, count, options) {};

/**
 * Sets the position of the stream to the specified value.
 * @param {number} position The new position of the stream.
 * @return {void}
 */
Windows.Storage.Streams.RandomAccessStreamOverStream.prototype.seek = function(position) {};

/**
 * Writes data asynchronously in a sequential stream.
 * @param {!Windows.Storage.Streams.IBuffer} buffer The buffer into which the asynchronous writer operation writes.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The byte writer operation.
 */
Windows.Storage.Streams.RandomAccessStreamOverStream.prototype.writeAsync = function(buffer) {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.Streams.RandomAccessStreamReference = function() {};

/**
 * Creates a random access stream around a file.
 * @param {!Windows.Storage.IStorageFile} file The file to create a stream around.
 * @return {!Windows.Storage.Streams.RandomAccessStreamReference} The stream that encapsulates file.
 */
Windows.Storage.Streams.RandomAccessStreamReference.createFromFile = function(file) {};

/**
 * Creates a random access stream around the specified stream.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} stream The source stream.
 * @return {!Windows.Storage.Streams.RandomAccessStreamReference} The random access stream that encapsulates stream.
 */
Windows.Storage.Streams.RandomAccessStreamReference.createFromStream = function(stream) {};

/**
 * Creates a random access stream around the specified URI.
 * @param {!Windows.Foundation.Uri} uri The URI to create the stream around. The valid URI schemes are http, https, ms-appx, and ms-appdata.
 * @return {!Windows.Storage.Streams.RandomAccessStreamReference} The random access stream that encapsulates uri.
 */
Windows.Storage.Streams.RandomAccessStreamReference.createFromUri = function(uri) {};

/**
 * Opens a stream for random access.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType>>} The asynchronous operation.
 */
Windows.Storage.Streams.RandomAccessStreamReference.prototype.openReadAsync = function() {};

/** @const */
Windows.Storage.Streams.UnicodeEncoding = {};
/** @const {number} */
Windows.Storage.Streams.UnicodeEncoding.utf8;
/** @const {number} */
Windows.Storage.Streams.UnicodeEncoding.utf16LE;
/** @const {number} */
Windows.Storage.Streams.UnicodeEncoding.utf16BE;
/**
 * @record
 * @struct
 */
Windows.Storage.Streams.IRandomAccessStreamReference = function() {};

/**
 * Opens a stream for random access.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStreamWithContentType>>} The asynchronous operation.
 */
Windows.Storage.Streams.IRandomAccessStreamReference.prototype.openReadAsync = function() {};
/**
 * @extends {Windows.Storage.Streams.IRandomAccessStream}
 * @extends {Windows.Foundation.IClosable}
 * @extends {Windows.Storage.Streams.IInputStream}
 * @extends {Windows.Storage.Streams.IOutputStream}
 * @extends {Windows.Storage.Streams.IContentTypeProvider}
 * @record
 * @struct
 */
Windows.Storage.Streams.IRandomAccessStreamWithContentType = function() {};
/**
 * @extends {Windows.Foundation.IClosable}
 * @extends {Windows.Storage.Streams.IInputStream}
 * @extends {Windows.Storage.Streams.IOutputStream}
 * @record
 * @struct
 */
Windows.Storage.Streams.IRandomAccessStream = function() {};
 /** @type {boolean} */
Windows.Storage.Streams.IRandomAccessStream.prototype.canRead;
 /** @type {boolean} */
Windows.Storage.Streams.IRandomAccessStream.prototype.canWrite;
 /** @type {number} */
Windows.Storage.Streams.IRandomAccessStream.prototype.position;
 /** @type {number} */
Windows.Storage.Streams.IRandomAccessStream.prototype.size;

/**
 * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
 * @return {!Windows.Storage.Streams.IRandomAccessStream} The new stream. The initial, internal position of the stream is 0.
 */
Windows.Storage.Streams.IRandomAccessStream.prototype.cloneStream = function() {};

/**
 * Returns an input stream at a specified location in a stream.
 * @param {number} position The location in the stream at which to begin.
 * @return {!Windows.Storage.Streams.IInputStream} The input stream.
 */
Windows.Storage.Streams.IRandomAccessStream.prototype.getInputStreamAt = function(position) {};

/**
 * Returns an output stream at a specified location in a stream.
 * @param {number} position The location in the output stream at which to begin.
 * @return {!Windows.Storage.Streams.IOutputStream} The output stream.
 */
Windows.Storage.Streams.IRandomAccessStream.prototype.getOutputStreamAt = function(position) {};

/**
 * Sets the position of the stream to the specified value.
 * @param {number} position The new position of the stream.
 * @return {void}
 */
Windows.Storage.Streams.IRandomAccessStream.prototype.seek = function(position) {};
/**
 * @record
 * @struct
 */
Windows.Storage.Streams.IBuffer = function() {};
 /** @type {number} */
Windows.Storage.Streams.IBuffer.prototype.capacity;
 /** @type {number} */
Windows.Storage.Streams.IBuffer.prototype.length;
/**
 * @extends {Windows.Foundation.IClosable}
 * @record
 * @struct
 */
Windows.Storage.Streams.IInputStream = function() {};

/**
 * Reads data from the stream asynchronously.
 * @param {!Windows.Storage.Streams.IBuffer} buffer A buffer that may be used to return the bytes that are read. The return value contains the buffer that holds the results.
 * @param {number} count The number of bytes to read that is less than or equal to the Capacity value.
 * @param {Windows.Storage.Streams.InputStreamOptions} options Specifies the type of the asynchronous read operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The asynchronous operation.
 */
Windows.Storage.Streams.IInputStream.prototype.readAsync = function(buffer, count, options) {};
/**
 * @extends {Windows.Foundation.IClosable}
 * @record
 * @struct
 */
Windows.Storage.Streams.IOutputStream = function() {};

/**
 * Flushes data asynchronously in a sequential stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The stream flush operation.
 */
Windows.Storage.Streams.IOutputStream.prototype.flushAsync = function() {};

/**
 * Writes data asynchronously in a sequential stream.
 * @param {!Windows.Storage.Streams.IBuffer} buffer A buffer that contains the data to be written.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The byte writer operation.
 */
Windows.Storage.Streams.IOutputStream.prototype.writeAsync = function(buffer) {};
/**
 * @record
 * @struct
 */
Windows.Storage.Streams.IContentTypeProvider = function() {};
 /** @type {string} */
Windows.Storage.Streams.IContentTypeProvider.prototype.contentType;
/**
 * @record
 * @struct
 */
Windows.Storage.Streams.IInputStreamReference = function() {};

/**
 * Opens a stream for sequential read access.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IInputStream, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IInputStream>>} The asynchronous operation.
 */
Windows.Storage.Streams.IInputStreamReference.prototype.openSequentialReadAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Storage.SystemAudioProperties = function() {};
 /** @type {string} */
Windows.Storage.SystemAudioProperties.prototype.encodingBitrate;
/**
 * @constructor
 * @struct
 */
Windows.Storage.SystemGPSProperties = function() {};
 /** @type {string} */
Windows.Storage.SystemGPSProperties.prototype.latitudeDecimal;
 /** @type {string} */
Windows.Storage.SystemGPSProperties.prototype.longitudeDecimal;
/**
 * @constructor
 * @struct
 */
Windows.Storage.SystemImageProperties = function() {};
 /** @type {string} */
Windows.Storage.SystemImageProperties.prototype.horizontalSize;
 /** @type {string} */
Windows.Storage.SystemImageProperties.prototype.verticalSize;
/**
 * @constructor
 * @struct
 */
Windows.Storage.SystemMediaProperties = function() {};
 /** @type {string} */
Windows.Storage.SystemMediaProperties.prototype.duration;
 /** @type {string} */
Windows.Storage.SystemMediaProperties.prototype.producer;
 /** @type {string} */
Windows.Storage.SystemMediaProperties.prototype.publisher;
 /** @type {string} */
Windows.Storage.SystemMediaProperties.prototype.subTitle;
 /** @type {string} */
Windows.Storage.SystemMediaProperties.prototype.writer;
 /** @type {string} */
Windows.Storage.SystemMediaProperties.prototype.year;
/**
 * @constructor
 * @struct
 */
Windows.Storage.SystemMusicProperties = function() {};
 /** @type {string} */
Windows.Storage.SystemMusicProperties.prototype.albumArtist;
 /** @type {string} */
Windows.Storage.SystemMusicProperties.prototype.albumTitle;
 /** @type {string} */
Windows.Storage.SystemMusicProperties.prototype.artist;
 /** @type {string} */
Windows.Storage.SystemMusicProperties.prototype.composer;
 /** @type {string} */
Windows.Storage.SystemMusicProperties.prototype.conductor;
 /** @type {string} */
Windows.Storage.SystemMusicProperties.prototype.displayArtist;
 /** @type {string} */
Windows.Storage.SystemMusicProperties.prototype.genre;
 /** @type {string} */
Windows.Storage.SystemMusicProperties.prototype.trackNumber;
/**
 * @constructor
 * @struct
 */
Windows.Storage.SystemPhotoProperties = function() {};
 /** @type {string} */
Windows.Storage.SystemPhotoProperties.prototype.cameraManufacturer;
 /** @type {string} */
Windows.Storage.SystemPhotoProperties.prototype.cameraModel;
 /** @type {string} */
Windows.Storage.SystemPhotoProperties.prototype.dateTaken;
 /** @type {string} */
Windows.Storage.SystemPhotoProperties.prototype.orientation;
 /** @type {string} */
Windows.Storage.SystemPhotoProperties.prototype.peopleNames;
/**
 * @constructor
 * @struct
 */
Windows.Storage.SystemProperties = function() {};
 /** @type {!Windows.Storage.SystemAudioProperties} */
Windows.Storage.SystemProperties.audio;
 /** @type {string} */
Windows.Storage.SystemProperties.author;
 /** @type {string} */
Windows.Storage.SystemProperties.comment;
 /** @type {!Windows.Storage.SystemGPSProperties} */
Windows.Storage.SystemProperties.gps;
 /** @type {!Windows.Storage.SystemImageProperties} */
Windows.Storage.SystemProperties.image;
 /** @type {string} */
Windows.Storage.SystemProperties.itemNameDisplay;
 /** @type {string} */
Windows.Storage.SystemProperties.keywords;
 /** @type {!Windows.Storage.SystemMediaProperties} */
Windows.Storage.SystemProperties.media;
 /** @type {!Windows.Storage.SystemMusicProperties} */
Windows.Storage.SystemProperties.music;
 /** @type {!Windows.Storage.SystemPhotoProperties} */
Windows.Storage.SystemProperties.photo;
 /** @type {string} */
Windows.Storage.SystemProperties.rating;
 /** @type {string} */
Windows.Storage.SystemProperties.title;
 /** @type {!Windows.Storage.SystemVideoProperties} */
Windows.Storage.SystemProperties.video;
/**
 * @constructor
 * @struct
 */
Windows.Storage.SystemVideoProperties = function() {};
 /** @type {string} */
Windows.Storage.SystemVideoProperties.prototype.director;
 /** @type {string} */
Windows.Storage.SystemVideoProperties.prototype.frameHeight;
 /** @type {string} */
Windows.Storage.SystemVideoProperties.prototype.frameWidth;
 /** @type {string} */
Windows.Storage.SystemVideoProperties.prototype.orientation;
 /** @type {string} */
Windows.Storage.SystemVideoProperties.prototype.totalBitrate;
/**
 * @record
 * @struct
 */
Windows.Storage.IStorageItem = function() {};
 /** @type {Windows.Storage.FileAttributes} */
Windows.Storage.IStorageItem.prototype.attributes;
 /** @type {!Date} */
Windows.Storage.IStorageItem.prototype.dateCreated;
 /** @type {string} */
Windows.Storage.IStorageItem.prototype.name;
 /** @type {string} */
Windows.Storage.IStorageItem.prototype.path;

/**
 * Deletes the current item, optionally deleting it permanently.
 * Deletes the current item.
 * @param {Windows.Storage.StorageDeleteOption=} option A value that indicates whether to delete the item permanently.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method when it completes.
 */
Windows.Storage.IStorageItem.prototype.deleteAsync = function(option) {};

/**
 * Gets the basic properties of the current item (like a file or folder).
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.FileProperties.BasicProperties, !Windows.Foundation.IAsyncOperation<!Windows.Storage.FileProperties.BasicProperties>>} When this method completes successfully, it returns the basic properties of the current item as a BasicProperties object.
 */
Windows.Storage.IStorageItem.prototype.getBasicPropertiesAsync = function() {};

/**
 * Determines whether the current IStorageItem matches the specified StorageItemTypes value.
 * @param {Windows.Storage.StorageItemTypes} type The value to match against.
 * @return {boolean} True if the IStorageItem matches the specified value; otherwise false.
 */
Windows.Storage.IStorageItem.prototype.isOfType = function(type) {};

/**
 * Renames the current item. This method also specifies what to do if an existing item in the current item's location has the same name.
 * Renames the current item.
 * @param {string} desiredName The desired, new name of the current item. / The desired, new name of the item.
 * @param {Windows.Storage.NameCollisionOption=} option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing item in the current item's location.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method when it completes.
 */
Windows.Storage.IStorageItem.prototype.renameAsync = function(desiredName, option) {};

/**
 * Gets the parent folder of the current storage item.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes, it returns the parent folder as a StorageFolder .
 */
Windows.Storage.IStorageItem.prototype.getParentAsync = function() {};

/**
 * Indicates whether the current item is the same as the specified item.
 * @param {!Windows.Storage.IStorageItem} item The IStorageItem object that represents a storage item to compare against.
 * @return {boolean} Returns true if the current storage item is the same as the specified storage item; otherwise false.
 */
Windows.Storage.IStorageItem.prototype.isEqual = function(item) {};
/**
 * @extends {Windows.Storage.IStorageItem}
 * @extends {Windows.Storage.Streams.IRandomAccessStreamReference}
 * @extends {Windows.Storage.Streams.IInputStreamReference}
 * @record
 * @struct
 */
Windows.Storage.IStorageFile = function() {};
 /** @type {string} */
Windows.Storage.IStorageFile.prototype.contentType;
 /** @type {string} */
Windows.Storage.IStorageFile.prototype.fileType;

/**
 * Replaces the specified file with a copy of the current file.
 * @param {!Windows.Storage.IStorageFile} fileToReplace The file to replace.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned when this method completes.
 */
Windows.Storage.IStorageFile.prototype.copyAndReplaceAsync = function(fileToReplace) {};

/**
 * Creates a copy of the file in the specified folder, using the desired name. This method also specifies what to do if an existing file in the specified folder has the same name.
 * Creates a copy of the file in the specified folder, using the desired name.
 * Creates a copy of the file in the specified folder.
 * @param {!Windows.Storage.IStorageFolder} destinationFolder The destination folder where the copy is created.
 * @param {string=} desiredNewName The desired name of the copy.
 * @param {Windows.Storage.NameCollisionOption=} option An enum value that determines how Windows responds if the desiredNewName is the same as the name of an existing file in the destination folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns a StorageFile that represents the copy.
 */
Windows.Storage.IStorageFile.prototype.copyAsync = function(destinationFolder, desiredNewName, option) {};

/**
 * Moves the current file to the location of the specified file and replaces the specified file in that location.
 * @param {!Windows.Storage.IStorageFile} fileToReplace The file to replace.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method.
 */
Windows.Storage.IStorageFile.prototype.moveAndReplaceAsync = function(fileToReplace) {};

/**
 * Moves the current file to the specified folder.
 * Moves the current file to the specified folder and renames the file according to the desired name. This method also specifies what to do if a file with the same name already exists in the specified folder.
 * Moves the current file to the specified folder and renames the file according to the desired name.
 * @param {!Windows.Storage.IStorageFolder} destinationFolder The destination folder where the file is moved.
 * @param {string=} desiredNewName The desired name of the file after it is moved.
 * @param {Windows.Storage.NameCollisionOption=} option An enum value that determines how Windows responds if the desiredNewName is the same as the name of an existing file in the destination folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} No object or value is returned by this method.
 */
Windows.Storage.IStorageFile.prototype.moveAsync = function(destinationFolder, desiredNewName, option) {};

/**
 * Opens a random-access stream over the file.
 * Opens a random-access stream over the file.
 * @param {Windows.Storage.FileAccessMode} accessMode The type of access to allow. / One of the enumeration values that specifies the type of access to allow.
 * @param {Windows.Storage.StorageOpenOptions=} options A bitwise combination of the enumeration values that specify options for opening the stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStream, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStream>>} When this method completes, it returns the random-access stream (type IRandomAccessStream ). / When this method completes, it returns an IRandomAccessStream that contains the requested random-access stream.
 */
Windows.Storage.IStorageFile.prototype.openAsync = function(accessMode, options) {};

/**
 * Opens a transacted, random-access stream for writing to the file.
 * Opens a random-access stream to the file that can be used for transacted-write operations with the specified options.
 * @param {Windows.Storage.StorageOpenOptions=} options A bitwise combination of the enumeration values that specify options for opening the stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageStreamTransaction, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageStreamTransaction>>} When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
 */
Windows.Storage.IStorageFile.prototype.openTransactedWriteAsync = function(options) {};
/**
 * @extends {Windows.Storage.IStorageItem}
 * @record
 * @struct
 */
Windows.Storage.IStorageFolder = function() {};

/**
 * Creates a new file in the current folder, and specifies what to do if a file with the same name already exists in the current folder.
 * Creates a new file in the current folder.
 * @param {string} desiredName The desired name of the file to create.
 * @param {Windows.Storage.CreationCollisionOption=} options The enum value that determines how Windows responds if the desiredName is the same as the name of an existing file in the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes, it returns the new file as a StorageFile .
 */
Windows.Storage.IStorageFolder.prototype.createFileAsync = function(desiredName, options) {};

/**
 * Creates a new folder in the current folder.
 * Creates a new folder in the current folder, and specifies what to do if a folder with the same name already exists in the current folder.
 * @param {string} desiredName The desired name of the folder to create.
 * @param {Windows.Storage.CreationCollisionOption=} options The enum value that determines how Windows responds if the desiredName is the same as the name of an existing folder in the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes, it returns the new folder as a StorageFolder .
 */
Windows.Storage.IStorageFolder.prototype.createFolderAsync = function(desiredName, options) {};

/**
 * Gets the specified file from the current folder.
 * @param {string} name The name (or path relative to the current folder) of the file to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFile, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFile>>} When this method completes successfully, it returns a StorageFile that represents the file.
 */
Windows.Storage.IStorageFolder.prototype.getFileAsync = function(name) {};

/**
 * Gets the files from the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns a list of the files (type IVectorView ) in the folder. Each file in the list is represented by a StorageFile object.
 */
Windows.Storage.IStorageFolder.prototype.getFilesAsync = function() {};

/**
 * Gets the specified folder from the current folder.
 * @param {string} name The name of the child folder to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.StorageFolder, !Windows.Foundation.IAsyncOperation<!Windows.Storage.StorageFolder>>} When this method completes successfully, it returns a StorageFolder that represents the child folder.
 */
Windows.Storage.IStorageFolder.prototype.getFolderAsync = function(name) {};

/**
 * Gets the folders in the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns a list of the files (type IVectorView ). Each folder in the list is represented by a StorageFolder .
 */
Windows.Storage.IStorageFolder.prototype.getFoldersAsync = function() {};

/**
 * Gets the specified item from the IStorageFolder .
 * @param {string} name The name of the item to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.IStorageItem, !Windows.Foundation.IAsyncOperation<!Windows.Storage.IStorageItem>>} When this method completes successfully, it returns the file or folder (type IStorageItem ).
 */
Windows.Storage.IStorageFolder.prototype.getItemAsync = function(name) {};

/**
 * Gets the items from the current folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns a list of the files and folders (type IVectorView ). The files and folders in the list are represented by objects of type IStorageItem .
 */
Windows.Storage.IStorageFolder.prototype.getItemsAsync = function() {};

/**
 * Try to get a single file or sub-folder from the current folder by using the name of the item.
 * @param {string} name The name (or path relative to the current folder) of the file or sub-folder to try to retrieve.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.IStorageItem, !Windows.Foundation.IAsyncOperation<!Windows.Storage.IStorageItem>>} When this method completes successfully, it returns the file or folder (type IStorageItem ).
 */
Windows.Storage.IStorageFolder.prototype.tryGetItemAsync = function(name) {};

/** @typedef {function(!Windows.Storage.SetVersionRequest): void} */
Windows.Storage.ApplicationDataSetVersionHandler;

/** @typedef {function(!Windows.Storage.StreamedFileDataRequest): void} */
Windows.Storage.StreamedFileDataRequestedHandler;
/** @const */
Windows.System = {};
/**
 * @constructor
 * @struct
 */
Windows.System.AppMemoryReport = function() {};
 /** @type {number} */
Windows.System.AppMemoryReport.prototype.peakPrivateCommitUsage;
 /** @type {number} */
Windows.System.AppMemoryReport.prototype.privateCommitUsage;
 /** @type {number} */
Windows.System.AppMemoryReport.prototype.totalCommitLimit;
 /** @type {number} */
Windows.System.AppMemoryReport.prototype.totalCommitUsage;

/** @const */
Windows.System.AppMemoryUsageLevel = {};
/** @const {number} */
Windows.System.AppMemoryUsageLevel.low;
/** @const {number} */
Windows.System.AppMemoryUsageLevel.medium;
/** @const {number} */
Windows.System.AppMemoryUsageLevel.high;
/**
 * @constructor
 * @struct
 */
Windows.System.AppMemoryUsageLimitChangingEventArgs = function() {};
 /** @type {number} */
Windows.System.AppMemoryUsageLimitChangingEventArgs.prototype.newLimit;
 /** @type {number} */
Windows.System.AppMemoryUsageLimitChangingEventArgs.prototype.oldLimit;
/** @const */
Windows.System.Diagnostics = {};
/**
 * @constructor
 * @struct
 */
Windows.System.Diagnostics.ProcessCpuUsage = function() {};

/**
 * Gets the ProcessCpuUsageReport for the process.
 * @return {!Windows.System.Diagnostics.ProcessCpuUsageReport} The CPU usage report for the process.
 */
Windows.System.Diagnostics.ProcessCpuUsage.prototype.getReport = function() {};
/**
 * @constructor
 * @struct
 */
Windows.System.Diagnostics.ProcessCpuUsageReport = function() {};
 /** @type {number} */
Windows.System.Diagnostics.ProcessCpuUsageReport.prototype.kernelTime;
 /** @type {number} */
Windows.System.Diagnostics.ProcessCpuUsageReport.prototype.userTime;
/**
 * @constructor
 * @struct
 */
Windows.System.Diagnostics.ProcessDiagnosticInfo = function() {};
 /** @type {!Windows.System.Diagnostics.ProcessCpuUsage} */
Windows.System.Diagnostics.ProcessDiagnosticInfo.prototype.cpuUsage;
 /** @type {!Windows.System.Diagnostics.ProcessDiskUsage} */
Windows.System.Diagnostics.ProcessDiagnosticInfo.prototype.diskUsage;
 /** @type {string} */
Windows.System.Diagnostics.ProcessDiagnosticInfo.prototype.executableFileName;
 /** @type {!Windows.System.Diagnostics.ProcessMemoryUsage} */
Windows.System.Diagnostics.ProcessDiagnosticInfo.prototype.memoryUsage;
 /** @type {!Windows.System.Diagnostics.ProcessDiagnosticInfo} */
Windows.System.Diagnostics.ProcessDiagnosticInfo.prototype.parent;
 /** @type {number} */
Windows.System.Diagnostics.ProcessDiagnosticInfo.prototype.processId;
 /** @type {!Date} */
Windows.System.Diagnostics.ProcessDiagnosticInfo.prototype.processStartTime;

/**
 * Gets the ProcessDiagnosticInfo for the currently running process.
 * @return {!Windows.System.Diagnostics.ProcessDiagnosticInfo} The ProcessDiagnosticInfo for the currently running process.
 */
Windows.System.Diagnostics.ProcessDiagnosticInfo.getForCurrentProcess = function() {};

/**
 * Gets a list of ProcessDiagnosticInfo objects for all running processes.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.System.Diagnostics.ProcessDiagnosticInfo>} A list of ProcessDiagnosticInfo objects for all running processes.
 */
Windows.System.Diagnostics.ProcessDiagnosticInfo.getForProcesses = function() {};
/**
 * @constructor
 * @struct
 */
Windows.System.Diagnostics.ProcessDiskUsage = function() {};

/**
 * Gets the ProcessDiskUsageReport for the process.
 * @return {!Windows.System.Diagnostics.ProcessDiskUsageReport} The ProcessDiskUsageReport for the process.
 */
Windows.System.Diagnostics.ProcessDiskUsage.prototype.getReport = function() {};
/**
 * @constructor
 * @struct
 */
Windows.System.Diagnostics.ProcessDiskUsageReport = function() {};
 /** @type {number} */
Windows.System.Diagnostics.ProcessDiskUsageReport.prototype.bytesReadCount;
 /** @type {number} */
Windows.System.Diagnostics.ProcessDiskUsageReport.prototype.bytesWrittenCount;
 /** @type {number} */
Windows.System.Diagnostics.ProcessDiskUsageReport.prototype.otherBytesCount;
 /** @type {number} */
Windows.System.Diagnostics.ProcessDiskUsageReport.prototype.otherOperationCount;
 /** @type {number} */
Windows.System.Diagnostics.ProcessDiskUsageReport.prototype.readOperationCount;
 /** @type {number} */
Windows.System.Diagnostics.ProcessDiskUsageReport.prototype.writeOperationCount;
/**
 * @constructor
 * @struct
 */
Windows.System.Diagnostics.ProcessMemoryUsage = function() {};

/**
 * Gets the ProcessMemoryUsageReport for the process.
 * @return {!Windows.System.Diagnostics.ProcessMemoryUsageReport} The ProcessMemoryUsageReport for the process.
 */
Windows.System.Diagnostics.ProcessMemoryUsage.prototype.getReport = function() {};
/**
 * @constructor
 * @struct
 */
Windows.System.Diagnostics.ProcessMemoryUsageReport = function() {};
 /** @type {number} */
Windows.System.Diagnostics.ProcessMemoryUsageReport.prototype.nonPagedPoolSizeInBytes;
 /** @type {number} */
Windows.System.Diagnostics.ProcessMemoryUsageReport.prototype.pageFaultCount;
 /** @type {number} */
Windows.System.Diagnostics.ProcessMemoryUsageReport.prototype.pageFileSizeInBytes;
 /** @type {number} */
Windows.System.Diagnostics.ProcessMemoryUsageReport.prototype.pagedPoolSizeInBytes;
 /** @type {number} */
Windows.System.Diagnostics.ProcessMemoryUsageReport.prototype.peakNonPagedPoolSizeInBytes;
 /** @type {number} */
Windows.System.Diagnostics.ProcessMemoryUsageReport.prototype.peakPageFileSizeInBytes;
 /** @type {number} */
Windows.System.Diagnostics.ProcessMemoryUsageReport.prototype.peakPagedPoolSizeInBytes;
 /** @type {number} */
Windows.System.Diagnostics.ProcessMemoryUsageReport.prototype.peakVirtualMemorySizeInBytes;
 /** @type {number} */
Windows.System.Diagnostics.ProcessMemoryUsageReport.prototype.peakWorkingSetSizeInBytes;
 /** @type {number} */
Windows.System.Diagnostics.ProcessMemoryUsageReport.prototype.privatePageCount;
 /** @type {number} */
Windows.System.Diagnostics.ProcessMemoryUsageReport.prototype.virtualMemorySizeInBytes;
 /** @type {number} */
Windows.System.Diagnostics.ProcessMemoryUsageReport.prototype.workingSetSizeInBytes;
/** @const */
Windows.System.Display = {};

/**
 * @constructor
 * @struct
 * Creates an instance of the DisplayRequest class.
 */
Windows.System.Display.DisplayRequest = function() {};

/**
 * Activates a display request.
 * @return {void}
 */
Windows.System.Display.DisplayRequest.prototype.requestActive = function() {};

/**
 * Deactivates a display request.
 * @return {void}
 */
Windows.System.Display.DisplayRequest.prototype.requestRelease = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the FolderLauncherOptions class.
 */
Windows.System.FolderLauncherOptions = function() {};
 /** @type {Windows.UI.ViewManagement.ViewSizePreference} */
Windows.System.FolderLauncherOptions.prototype.desiredRemainingView;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Storage.IStorageItem>} */
Windows.System.FolderLauncherOptions.prototype.itemsToSelect;
/**
 * @constructor
 * @struct
 */
Windows.System.KnownUserProperties = function() {};
 /** @type {string} */
Windows.System.KnownUserProperties.accountName;
 /** @type {string} */
Windows.System.KnownUserProperties.displayName;
 /** @type {string} */
Windows.System.KnownUserProperties.domainName;
 /** @type {string} */
Windows.System.KnownUserProperties.firstName;
 /** @type {string} */
Windows.System.KnownUserProperties.guestHost;
 /** @type {string} */
Windows.System.KnownUserProperties.lastName;
 /** @type {string} */
Windows.System.KnownUserProperties.principalName;
 /** @type {string} */
Windows.System.KnownUserProperties.providerName;
 /** @type {string} */
Windows.System.KnownUserProperties.sessionInitiationProtocolUri;

/** @const */
Windows.System.LaunchQuerySupportStatus = {};
/** @const {number} */
Windows.System.LaunchQuerySupportStatus.available;
/** @const {number} */
Windows.System.LaunchQuerySupportStatus.appNotInstalled;
/** @const {number} */
Windows.System.LaunchQuerySupportStatus.appUnavailable;
/** @const {number} */
Windows.System.LaunchQuerySupportStatus.notSupported;
/** @const {number} */
Windows.System.LaunchQuerySupportStatus.unknown;

/** @const */
Windows.System.LaunchQuerySupportType = {};
/** @const {number} */
Windows.System.LaunchQuerySupportType.uri;
/** @const {number} */
Windows.System.LaunchQuerySupportType.uriForResults;
/**
 * @constructor
 * @struct
 */
Windows.System.LaunchUriResult = function() {};
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.System.LaunchUriResult.prototype.result;
 /** @type {Windows.System.LaunchUriStatus} */
Windows.System.LaunchUriResult.prototype.status;

/** @const */
Windows.System.LaunchUriStatus = {};
/** @const {number} */
Windows.System.LaunchUriStatus.success;
/** @const {number} */
Windows.System.LaunchUriStatus.appUnavailable;
/** @const {number} */
Windows.System.LaunchUriStatus.protocolUnavailable;
/** @const {number} */
Windows.System.LaunchUriStatus.unknown;
/**
 * @constructor
 * @struct
 */
Windows.System.Launcher = function() {};

/**
 * Enumerate the file handlers on the device.
 * @param {string} extension The file extension that you want to find handlers for. For example, ".bat". Include the leading period '.'.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.AppInfo>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.AppInfo>>>} A list of AppInfo s for each application that handles the specified file extension.
 */
Windows.System.Launcher.findFileHandlersAsync = function(extension) {};

/**
 * Enumerates the
 * Enumerate the scheme handlers on the device.
 * @param {string} scheme The scheme name that you find to find handlers for. For example, "ms-lens".
 * @param {Windows.System.LaunchQuerySupportType=} launchQuerySupportType Filter the list of handlers by whether they can be launched for results or not.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.AppInfo>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<!Windows.ApplicationModel.AppInfo>>>} A list of AppInfo s for each application that handles the specified scheme.
 */
Windows.System.Launcher.findUriSchemeHandlersAsync = function(scheme, launchQuerySupportType) {};

/**
 * Starts the default app associated with the specified file.
 * Starts the default app associated with the specified file, using the specified options.
 * @param {!Windows.Storage.IStorageFile} file The file.
 * @param {!Windows.System.LauncherOptions=} options The launch options for the app.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The launch operation.
 */
Windows.System.Launcher.launchFileAsync = function(file, options) {};

/**
 * Launches File Explorer with the specified options and displays the contents of the specified folder.
 * Launches File Explorer and displays the contents of the specified folder.
 * @param {!Windows.Storage.IStorageFolder} folder The folder to display in File Explorer.
 * @param {!Windows.System.FolderLauncherOptions=} options Options that specify the amount of screen space that File Explorer fills, and the list of items to select in the specified folder.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The result of the operation.
 */
Windows.System.Launcher.launchFolderAsync = function(folder, options) {};

/**
 * Starts the default app associated with the URI scheme name for the specified URI.
 * Starts the default app associated with the URI scheme name or the one specified by the ContentType for the specified URI, using the specified options.
 * Starts the default app associated with the URI scheme name for the specified URI, using the specified options and input data.
 * @param {!Windows.Foundation.Uri} uri The URI.
 * @param {!Windows.System.LauncherOptions=} options The launch options for the app.
 * @param {!Windows.Foundation.Collections.ValueSet=} inputData The input data for the app.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The launch operation.
 */
Windows.System.Launcher.launchUriAsync = function(uri, options, inputData) {};

/**
 * Asynchronously starts the default app associated with the URI scheme name for the specified URI, using the specified options and input data.
 * Asynchronously starts the default app associated with the URI scheme name for the specified URI, using the specified options.
 * @param {!Windows.Foundation.Uri} uri The Uri to launch.
 * @param {!Windows.System.LauncherOptions} options The launch options.
 * @param {!Windows.Foundation.Collections.ValueSet=} inputData The data to send to the launched app.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.System.LaunchUriResult, !Windows.Foundation.IAsyncOperation<!Windows.System.LaunchUriResult>>} When this method completes, it returns the results of the launch.
 */
Windows.System.Launcher.launchUriForResultsAsync = function(uri, options, inputData) {};

/**
 * Asynchronously query whether an app can be activated for the specified file.
 * Asynchronously query whether an app with the specified package name can be activated for the specified file.
 * @param {!Windows.Storage.StorageFile} file The file for which to query support.
 * @param {string=} packageFamilyName The package for which to query support.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.System.LaunchQuerySupportStatus, !Windows.Foundation.IAsyncOperation<Windows.System.LaunchQuerySupportStatus>>} A value that indicates whether an application can be activated for the file.
 */
Windows.System.Launcher.queryFileSupportAsync = function(file, packageFamilyName) {};

/**
 * Asynchronously query whether an app can be activated for the specified URI, launch type, and package name.
 * Asynchronously query whether an app can be activated for the specified URI and launch type.
 * @param {!Windows.Foundation.Uri} uri The URI for which to query support.
 * @param {Windows.System.LaunchQuerySupportType} launchQuerySupportType The type of launch for which to query support.
 * @param {string=} packageFamilyName Specifies a specific package that will be used to launch this URI.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.System.LaunchQuerySupportStatus, !Windows.Foundation.IAsyncOperation<Windows.System.LaunchQuerySupportStatus>>} A value that indicates whether the application is available to launch the URI. / A value that indicates whether an application is available to launch the URI.
 */
Windows.System.Launcher.queryUriSupportAsync = function(uri, launchQuerySupportType, packageFamilyName) {};

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the launcher options object.
 */
Windows.System.LauncherOptions = function() {};
 /** @type {string} */
Windows.System.LauncherOptions.prototype.contentType;
 /** @type {Windows.UI.ViewManagement.ViewSizePreference} */
Windows.System.LauncherOptions.prototype.desiredRemainingView;
 /** @type {boolean} */
Windows.System.LauncherOptions.prototype.displayApplicationPicker;
 /** @type {!Windows.Foundation.Uri} */
Windows.System.LauncherOptions.prototype.fallbackUri;
 /** @type {!Windows.Storage.Search.StorageFileQueryResult} */
Windows.System.LauncherOptions.prototype.neighboringFilesQuery;
 /** @type {string} */
Windows.System.LauncherOptions.prototype.preferredApplicationDisplayName;
 /** @type {string} */
Windows.System.LauncherOptions.prototype.preferredApplicationPackageFamilyName;
 /** @type {string} */
Windows.System.LauncherOptions.prototype.targetApplicationPackageFamilyName;
 /** @type {boolean} */
Windows.System.LauncherOptions.prototype.treatAsUntrusted;
 /** @type {!Windows.System.LauncherUIOptions} */
Windows.System.LauncherOptions.prototype.ui;
/**
 * @constructor
 * @struct
 */
Windows.System.LauncherUIOptions = function() {};
 /** @type {!Windows.Foundation.Point} */
Windows.System.LauncherUIOptions.prototype.invocationPoint;
 /** @type {Windows.UI.Popups.Placement} */
Windows.System.LauncherUIOptions.prototype.preferredPlacement;
 /** @type {!Windows.Foundation.Rect} */
Windows.System.LauncherUIOptions.prototype.selectionRect;
/**
 * @constructor
 * @struct
 */
Windows.System.MemoryManager = function() {};
 /** @type {number} */
Windows.System.MemoryManager.appMemoryUsage;
 /** @type {Windows.System.AppMemoryUsageLevel} */
Windows.System.MemoryManager.appMemoryUsageLevel;
 /** @type {number} */
Windows.System.MemoryManager.appMemoryUsageLimit;
 /** @type {function(?): void} */
Windows.System.MemoryManager.onappmemoryusagedecreased;
 /** @type {function(?): void} */
Windows.System.MemoryManager.onappmemoryusageincreased;
 /** @type {function(?): void} */
Windows.System.MemoryManager.onappmemoryusagelimitchanging;
 /** @type {?} */
Windows.System.MemoryManager.trySetAppMemoryUsageLimit;

/**
 * Gets an AppMemoryReport for the app, which provides information about its memory usage.
 * @return {!Windows.System.AppMemoryReport} Information about the process' memory usage.
 */
Windows.System.MemoryManager.getAppMemoryReport = function() {};

/**
 * Gets a ProcessMemoryReport for a process, which provides information about its memory usage.
 * @return {!Windows.System.ProcessMemoryReport} Information about the process' memory usage.
 */
Windows.System.MemoryManager.getProcessMemoryReport = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.System.MemoryManager.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.System.MemoryManager.removeEventListener = function(type, listener) {};
/** @const */
Windows.System.Power = {};
/**
 * @constructor
 * @struct
 */
Windows.System.Power.BackgroundEnergyManager = function() {};
 /** @type {number} */
Windows.System.Power.BackgroundEnergyManager.excessiveUsageLevel;
 /** @type {number} */
Windows.System.Power.BackgroundEnergyManager.lowUsageLevel;
 /** @type {number} */
Windows.System.Power.BackgroundEnergyManager.maxAcceptableUsageLevel;
 /** @type {number} */
Windows.System.Power.BackgroundEnergyManager.nearMaxAcceptableUsageLevel;
 /** @type {number} */
Windows.System.Power.BackgroundEnergyManager.nearTerminationUsageLevel;
 /** @type {function(?): void} */
Windows.System.Power.BackgroundEnergyManager.onrecentenergyusageincreased;
 /** @type {function(?): void} */
Windows.System.Power.BackgroundEnergyManager.onrecentenergyusagereturnedtolow;
 /** @type {number} */
Windows.System.Power.BackgroundEnergyManager.recentEnergyUsage;
 /** @type {number} */
Windows.System.Power.BackgroundEnergyManager.recentEnergyUsageLevel;
 /** @type {number} */
Windows.System.Power.BackgroundEnergyManager.terminationUsageLevel;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.System.Power.BackgroundEnergyManager.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.System.Power.BackgroundEnergyManager.removeEventListener = function(type, listener) {};

/** @const */
Windows.System.Power.BatteryStatus = {};
/** @const {number} */
Windows.System.Power.BatteryStatus.notPresent;
/** @const {number} */
Windows.System.Power.BatteryStatus.discharging;
/** @const {number} */
Windows.System.Power.BatteryStatus.idle;
/** @const {number} */
Windows.System.Power.BatteryStatus.charging;
/** @const */
Windows.System.Power.Diagnostics = {};
/**
 * @constructor
 * @struct
 */
Windows.System.Power.Diagnostics.BackgroundEnergyDiagnostics = function() {};
 /** @type {number} */
Windows.System.Power.Diagnostics.BackgroundEnergyDiagnostics.deviceSpecificConversionFactor;

/**
 * Computes the total cumulative energy usage of the background task since the last reset, expressed as a percentage of normal.
 * @return {number} The total cumulative energy usage of the background task since the last reset, expressed as a percentage of normal.
 */
Windows.System.Power.Diagnostics.BackgroundEnergyDiagnostics.computeTotalEnergyUsage = function() {};

/**
 * Clears the value that represents the total cumulative energy usage of the background task since the last reset.
 * @return {void}
 */
Windows.System.Power.Diagnostics.BackgroundEnergyDiagnostics.resetTotalEnergyUsage = function() {};
/**
 * @constructor
 * @struct
 */
Windows.System.Power.Diagnostics.ForegroundEnergyDiagnostics = function() {};
 /** @type {number} */
Windows.System.Power.Diagnostics.ForegroundEnergyDiagnostics.deviceSpecificConversionFactor;

/**
 * Computes the total cumulative energy usage of the foreground app since the last reset, expressed as a percentage of normal.
 * @return {number} The total cumulative energy usage of the foreground app since the last reset, expressed as a percentage of normal.
 */
Windows.System.Power.Diagnostics.ForegroundEnergyDiagnostics.computeTotalEnergyUsage = function() {};

/**
 * Clears the value that represents the total cumulative energy usage of the foreground app since the last reset.
 * @return {void}
 */
Windows.System.Power.Diagnostics.ForegroundEnergyDiagnostics.resetTotalEnergyUsage = function() {};

/** @const */
Windows.System.Power.EnergySaverStatus = {};
/** @const {number} */
Windows.System.Power.EnergySaverStatus.disabled;
/** @const {number} */
Windows.System.Power.EnergySaverStatus.off;
/** @const {number} */
Windows.System.Power.EnergySaverStatus.on;
/**
 * @constructor
 * @struct
 */
Windows.System.Power.ForegroundEnergyManager = function() {};
 /** @type {number} */
Windows.System.Power.ForegroundEnergyManager.excessiveUsageLevel;
 /** @type {number} */
Windows.System.Power.ForegroundEnergyManager.lowUsageLevel;
 /** @type {number} */
Windows.System.Power.ForegroundEnergyManager.maxAcceptableUsageLevel;
 /** @type {number} */
Windows.System.Power.ForegroundEnergyManager.nearMaxAcceptableUsageLevel;
 /** @type {function(?): void} */
Windows.System.Power.ForegroundEnergyManager.onrecentenergyusageincreased;
 /** @type {function(?): void} */
Windows.System.Power.ForegroundEnergyManager.onrecentenergyusagereturnedtolow;
 /** @type {number} */
Windows.System.Power.ForegroundEnergyManager.recentEnergyUsage;
 /** @type {number} */
Windows.System.Power.ForegroundEnergyManager.recentEnergyUsageLevel;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.System.Power.ForegroundEnergyManager.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.System.Power.ForegroundEnergyManager.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.System.Power.PowerManager = function() {};
 /** @type {Windows.System.Power.BatteryStatus} */
Windows.System.Power.PowerManager.batteryStatus;
 /** @type {Windows.System.Power.EnergySaverStatus} */
Windows.System.Power.PowerManager.energySaverStatus;
 /** @type {function(?): void} */
Windows.System.Power.PowerManager.onbatterystatuschanged;
 /** @type {function(?): void} */
Windows.System.Power.PowerManager.onenergysaverstatuschanged;
 /** @type {function(?): void} */
Windows.System.Power.PowerManager.onpowersupplystatuschanged;
 /** @type {function(?): void} */
Windows.System.Power.PowerManager.onremainingchargepercentchanged;
 /** @type {function(?): void} */
Windows.System.Power.PowerManager.onremainingdischargetimechanged;
 /** @type {Windows.System.Power.PowerSupplyStatus} */
Windows.System.Power.PowerManager.powerSupplyStatus;
 /** @type {number} */
Windows.System.Power.PowerManager.remainingChargePercent;
 /** @type {number} */
Windows.System.Power.PowerManager.remainingDischargeTime;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.System.Power.PowerManager.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.System.Power.PowerManager.removeEventListener = function(type, listener) {};

/** @const */
Windows.System.Power.PowerSupplyStatus = {};
/** @const {number} */
Windows.System.Power.PowerSupplyStatus.notPresent;
/** @const {number} */
Windows.System.Power.PowerSupplyStatus.inadequate;
/** @const {number} */
Windows.System.Power.PowerSupplyStatus.adequate;
/**
 * @constructor
 * @struct
 */
Windows.System.ProcessLauncher = function() {};
 /** @type {?} */
Windows.System.ProcessLauncher.runToCompletionAsync;
/**
 * @constructor
 * @struct
 */
Windows.System.ProcessLauncherOptions = function() {};
 /** @type {?} */
Windows.System.ProcessLauncherOptions.prototype.standardError;
 /** @type {?} */
Windows.System.ProcessLauncherOptions.prototype.standardInput;
 /** @type {?} */
Windows.System.ProcessLauncherOptions.prototype.standardOutput;
 /** @type {?} */
Windows.System.ProcessLauncherOptions.prototype.workingDirectory;
/**
 * @constructor
 * @struct
 */
Windows.System.ProcessLauncherResult = function() {};
 /** @type {?} */
Windows.System.ProcessLauncherResult.prototype.exitCode;
/**
 * @constructor
 * @struct
 */
Windows.System.ProcessMemoryReport = function() {};
 /** @type {number} */
Windows.System.ProcessMemoryReport.prototype.privateWorkingSetUsage;
 /** @type {number} */
Windows.System.ProcessMemoryReport.prototype.totalWorkingSetUsage;

/** @const */
Windows.System.ProcessorArchitecture = {};
/** @const {number} */
Windows.System.ProcessorArchitecture.x86;
/** @const {number} */
Windows.System.ProcessorArchitecture.arm;
/** @const {number} */
Windows.System.ProcessorArchitecture.x64;
/** @const {number} */
Windows.System.ProcessorArchitecture.neutral;
/** @const {number} */
Windows.System.ProcessorArchitecture.unknown;
/** @const */
Windows.System.Profile = {};
/**
 * @constructor
 * @struct
 */
Windows.System.Profile.AnalyticsInfo = function() {};
 /** @type {string} */
Windows.System.Profile.AnalyticsInfo.deviceForm;
 /** @type {!Windows.System.Profile.AnalyticsVersionInfo} */
Windows.System.Profile.AnalyticsInfo.versionInfo;
/**
 * @constructor
 * @struct
 */
Windows.System.Profile.AnalyticsVersionInfo = function() {};
 /** @type {string} */
Windows.System.Profile.AnalyticsVersionInfo.prototype.deviceFamily;
 /** @type {string} */
Windows.System.Profile.AnalyticsVersionInfo.prototype.deviceFamilyVersion;
/**
 * @constructor
 * @struct
 */
Windows.System.Profile.HardwareIdentification = function() {};

/**
 * Gets a hardware identifier ( ASHWID) that represents the current hardware. The returned ASHWID will be different for each application package. In other words, this API will return different identifiers when called by two apps from different packages. It will return the same identifier when called by two apps that are part of the same package.
 * @param {!Windows.Storage.Streams.IBuffer} nonce The cryptographic nonce is optional. The nonce is recommended when ASHWID needs to be verified on the cloud against replay attacks. In the scenarios where nonce is desired, the remote server should generate a random nonce and pass it to the client app, and then verify that the signature has the expected nonce once the ASHWID is received from the client system.
 * @return {!Windows.System.Profile.HardwareToken} The hardware Id information.
 */
Windows.System.Profile.HardwareIdentification.getPackageSpecificToken = function(nonce) {};
/**
 * @constructor
 * @struct
 */
Windows.System.Profile.HardwareToken = function() {};
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.System.Profile.HardwareToken.prototype.certificate;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.System.Profile.HardwareToken.prototype.id;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.System.Profile.HardwareToken.prototype.signature;
/**
 * @constructor
 * @struct
 */
Windows.System.Profile.KnownRetailInfoProperties = function() {};
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.batteryLifeDescription;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.displayDescription;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.displayModelName;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.formFactor;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.frontCameraDescription;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.graphicsDescription;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.hasNfc;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.hasOpticalDrive;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.hasSdSlot;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.isFeatured;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.isOfficeInstalled;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.manufacturerName;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.memory;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.modelName;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.price;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.processorDescription;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.rearCameraDescription;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.retailAccessCode;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.screenSize;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.storageDescription;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.weight;
 /** @type {string} */
Windows.System.Profile.KnownRetailInfoProperties.windowsEdition;
/** @const */
Windows.System.Profile.PlatformDataCollectionLevel = {};
 /** @type {?} */
Windows.System.Profile.PlatformDataCollectionLevel.security;
 /** @type {?} */
Windows.System.Profile.PlatformDataCollectionLevel.basic;
 /** @type {?} */
Windows.System.Profile.PlatformDataCollectionLevel.enhanced;
 /** @type {?} */
Windows.System.Profile.PlatformDataCollectionLevel.full;
/**
 * @constructor
 * @struct
 */
Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings = function() {};
 /** @type {?} */
Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings.addEventListener;
 /** @type {?} */
Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings.canCollectDiagnostics;
 /** @type {?} */
Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings.collectionLevel;
 /** @type {?} */
Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings.oncollectionlevelchanged;
 /** @type {?} */
Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings.removeEventListener;
/**
 * @constructor
 * @struct
 */
Windows.System.Profile.RetailInfo = function() {};
 /** @type {boolean} */
Windows.System.Profile.RetailInfo.isDemoModeEnabled;
 /** @type {!Windows.Foundation.Collections.IMapView<string, ?>} */
Windows.System.Profile.RetailInfo.properties;
/** @const */
Windows.System.Profile.SystemManufacturers = {};
/**
 * @constructor
 * @struct
 */
Windows.System.Profile.SystemManufacturers.SmbiosInformation = function() {};
 /** @type {string} */
Windows.System.Profile.SystemManufacturers.SmbiosInformation.serialNumber;
/**
 * @constructor
 * @struct
 */
Windows.System.ProtocolForResultsOperation = function() {};

/**
 * Indicates that the application activated for results is ready to return to the application that launched it for results.
 * @param {!Windows.Foundation.Collections.ValueSet} data The data to return to the application that activated this app.
 * @return {void}
 */
Windows.System.ProtocolForResultsOperation.prototype.reportCompleted = function(data) {};
/** @const */
Windows.System.RemoteDesktop = {};
/**
 * @constructor
 * @struct
 */
Windows.System.RemoteDesktop.InteractiveSession = function() {};
 /** @type {boolean} */
Windows.System.RemoteDesktop.InteractiveSession.isRemote;
/** @const */
Windows.System.ShutdownKind = {};
 /** @type {?} */
Windows.System.ShutdownKind.shutdown;
 /** @type {?} */
Windows.System.ShutdownKind.restart;
/**
 * @constructor
 * @struct
 */
Windows.System.ShutdownManager = function() {};
 /** @type {?} */
Windows.System.ShutdownManager.beginShutdown;
 /** @type {?} */
Windows.System.ShutdownManager.cancelShutdown;
/** @const */
Windows.System.Threading = {};
/** @const */
Windows.System.Threading.Core = {};
/**
 * @constructor
 * @struct
 */
Windows.System.TimeZoneSettings = function() {};
 /** @type {?} */
Windows.System.TimeZoneSettings.canChangeTimeZone;
 /** @type {?} */
Windows.System.TimeZoneSettings.changeTimeZoneByDisplayName;
 /** @type {?} */
Windows.System.TimeZoneSettings.currentTimeZoneDisplayName;
 /** @type {?} */
Windows.System.TimeZoneSettings.supportedTimeZoneDisplayNames;
/**
 * @constructor
 * @struct
 */
Windows.System.User = function() {};
 /** @type {Windows.System.UserAuthenticationStatus} */
Windows.System.User.prototype.authenticationStatus;
 /** @type {string} */
Windows.System.User.prototype.nonRoamableId;
 /** @type {Windows.System.UserType} */
Windows.System.User.prototype.type;

/**
 * Creates a UserWatcher which enumerates users and raises events when the collection of users changes or when a users authentication state changes.
 * @return {!Windows.System.UserWatcher} A UserWatcher which enumerates users and raises events when the collection of users changes.
 */
Windows.System.User.createWatcher = function() {};

/**
 * Finds all users of a given type and authentication status asynchronously.
 * Finds all users asynchronously.
 * Finds all users of a given type asynchronously.
 * @param {Windows.System.UserType=} type The type of users to find.
 * @param {Windows.System.UserAuthenticationStatus=} status The authentication status of users to find.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} When this method completes successfully, it returns a list (type IVectorView ) of Users .
 */
Windows.System.User.findAllAsync = function(type, status) {};

/**
 * Gets a user with a given Id.
 * @param {string} nonRoamableId The Id of the user to get.
 * @return {!Windows.System.User} The user with the given Id.
 */
Windows.System.User.getFromId = function(nonRoamableId) {};

/**
 * Gets a user's picture asynchronously.
 * @param {Windows.System.UserPictureSize} desiredSize The desired size of the user's picture to return.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IRandomAccessStreamReference, !Windows.Foundation.IAsyncOperation<!Windows.Storage.Streams.IRandomAccessStreamReference>>} When this method completes, it returns the user's picture.
 */
Windows.System.User.prototype.getPictureAsync = function(desiredSize) {};

/**
 * Gets properties for the user.
 * @param {!Windows.Foundation.Collections.IVectorView<string>} values The properties to get. Use the KnownUserProperties class to obtain property names.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IPropertySet, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IPropertySet>>} When this method completes, it returns the requested properties. If a property is missing or unavailable, it is reported as an empty string.
 */
Windows.System.User.prototype.getPropertiesAsync = function(values) {};

/**
 * Gets a property for the user. Use the KnownUserProperties class to obtain property names.
 * @param {string} value The property to get.
 * @return {!Windows.Foundation.IPromiseWithOperation<?, !Windows.Foundation.IAsyncOperation<?>>} When this method completes, it returns the requested property. If the property is missing or unavailable, an empty string is returned.
 */
Windows.System.User.prototype.getPropertyAsync = function(value) {};

/** @const */
Windows.System.UserAuthenticationStatus = {};
/** @const {number} */
Windows.System.UserAuthenticationStatus.unauthenticated;
/** @const {number} */
Windows.System.UserAuthenticationStatus.locallyAuthenticated;
/** @const {number} */
Windows.System.UserAuthenticationStatus.remotelyAuthenticated;
/**
 * @constructor
 * @struct
 */
Windows.System.UserAuthenticationStatusChangeDeferral = function() {};

/**
 * Reports that the application has completed its user authentication status change deferral.
 * @return {void}
 */
Windows.System.UserAuthenticationStatusChangeDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.System.UserAuthenticationStatusChangingEventArgs = function() {};
 /** @type {Windows.System.UserAuthenticationStatus} */
Windows.System.UserAuthenticationStatusChangingEventArgs.prototype.currentStatus;
 /** @type {Windows.System.UserAuthenticationStatus} */
Windows.System.UserAuthenticationStatusChangingEventArgs.prototype.newStatus;
 /** @type {!Windows.System.User} */
Windows.System.UserAuthenticationStatusChangingEventArgs.prototype.user;

/**
 * Requests a delay before the user's authentication status changes.
 * @return {!Windows.System.UserAuthenticationStatusChangeDeferral} The user authentication status change deferral.
 */
Windows.System.UserAuthenticationStatusChangingEventArgs.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.System.UserChangedEventArgs = function() {};
 /** @type {!Windows.System.User} */
Windows.System.UserChangedEventArgs.prototype.user;

/** @const */
Windows.System.UserPictureSize = {};
/** @const {number} */
Windows.System.UserPictureSize.size64x64;
/** @const {number} */
Windows.System.UserPictureSize.size208x208;
/** @const {number} */
Windows.System.UserPictureSize.size424x424;
/** @const {number} */
Windows.System.UserPictureSize.size1080x1080;
/** @const */
Windows.System.UserProfile = {};

/** @const */
Windows.System.UserProfile.AccountPictureKind = {};
/** @const {number} */
Windows.System.UserProfile.AccountPictureKind.smallImage;
/** @const {number} */
Windows.System.UserProfile.AccountPictureKind.largeImage;
/** @const {number} */
Windows.System.UserProfile.AccountPictureKind.video;
/**
 * @constructor
 * @struct
 */
Windows.System.UserProfile.AdvertisingManager = function() {};
 /** @type {string} */
Windows.System.UserProfile.AdvertisingManager.advertisingId;
/**
 * @constructor
 * @struct
 */
Windows.System.UserProfile.FirstSignInSettings = function() {};
 /** @type {number} */
Windows.System.UserProfile.FirstSignInSettings.prototype.size;

/**
 * Gets the default instance of the settings.
 * @return {!Windows.System.UserProfile.FirstSignInSettings} The default instance of the settings.
 */
Windows.System.UserProfile.FirstSignInSettings.getDefault = function() {};

/**
 * Returns an iterator for the items in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} The iterator.
 */
Windows.System.UserProfile.FirstSignInSettings.prototype.first = function() {};

/**
 * Determines whether the map view contains the specified key.
 * @param {string} key The key to locate in the map view.
 * @return {boolean} true if the key is found; otherwise, false.
 */
Windows.System.UserProfile.FirstSignInSettings.prototype.hasKey = function(key) {};

/**
 * Returns the item in the map view with the specified key.
 * @param {string} key The key to locate in the map view.
 * @return {?} The item associated with the specified key.
 */
Windows.System.UserProfile.FirstSignInSettings.prototype.lookup = function(key) {};

/**
 * Splits the map view into two views.
 * @return {{first: !Windows.Foundation.Collections.IMapView<string, ?>, second: !Windows.Foundation.Collections.IMapView<string, ?>}}
 */
Windows.System.UserProfile.FirstSignInSettings.prototype.split = function() {};
/**
 * @constructor
 * @struct
 */
Windows.System.UserProfile.GlobalizationPreferences = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.System.UserProfile.GlobalizationPreferences.calendars;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.System.UserProfile.GlobalizationPreferences.clocks;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.System.UserProfile.GlobalizationPreferences.currencies;
 /** @type {string} */
Windows.System.UserProfile.GlobalizationPreferences.homeGeographicRegion;
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.System.UserProfile.GlobalizationPreferences.languages;
 /** @type {Windows.Globalization.DayOfWeek} */
Windows.System.UserProfile.GlobalizationPreferences.weekStartsOn;
/**
 * @constructor
 * @struct
 */
Windows.System.UserProfile.LockScreen = function() {};
 /** @type {!Windows.Foundation.Uri} */
Windows.System.UserProfile.LockScreen.originalImageFile;

/**
 * Gets the current lock screen image as a data stream.
 * @return {!Windows.Storage.Streams.IRandomAccessStream} The stream that contains the lock screen image data.
 */
Windows.System.UserProfile.LockScreen.getImageStream = function() {};

/**
 * Registers an RSS image feed to be used as a lock screen slideshow. (Windows 8.1 only)
 * @param {!Windows.Foundation.Uri} syndicationFeedUri The URI of the RSS image feed.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.System.UserProfile.SetImageFeedResult, !Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetImageFeedResult>>} One of the SetImageFeedResult values.
 */
Windows.System.UserProfile.LockScreen.requestSetImageFeedAsync = function(syndicationFeedUri) {};

/**
 * Sets the lock screen image from a StorageFile object.
 * @param {!Windows.Storage.IStorageFile} value The StorageFile object that contains the new image for the lock screen.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object used to set the image for the lock screen.
 */
Windows.System.UserProfile.LockScreen.setImageFileAsync = function(value) {};

/**
 * Sets the lock screen image from a data stream.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} value The stream that contains the image data.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The object used to set the lock screen image.
 */
Windows.System.UserProfile.LockScreen.setImageStreamAsync = function(value) {};

/**
 * Unregisters the image feed being used in the lock screen slideshow, stopping the slideshow. (Windows 8.1 only)
 * @return {boolean} true if the image feed was disabled; otherwise, false.
 */
Windows.System.UserProfile.LockScreen.tryRemoveImageFeed = function() {};

/** @const */
Windows.System.UserProfile.SetAccountPictureResult = {};
/** @const {number} */
Windows.System.UserProfile.SetAccountPictureResult.success;
/** @const {number} */
Windows.System.UserProfile.SetAccountPictureResult.changeDisabled;
/** @const {number} */
Windows.System.UserProfile.SetAccountPictureResult.largeOrDynamicError;
/** @const {number} */
Windows.System.UserProfile.SetAccountPictureResult.videoFrameSizeError;
/** @const {number} */
Windows.System.UserProfile.SetAccountPictureResult.fileSizeError;
/** @const {number} */
Windows.System.UserProfile.SetAccountPictureResult.failure;

/** @const */
Windows.System.UserProfile.SetImageFeedResult = {};
/** @const {number} */
Windows.System.UserProfile.SetImageFeedResult.success;
/** @const {number} */
Windows.System.UserProfile.SetImageFeedResult.changeDisabled;
/** @const {number} */
Windows.System.UserProfile.SetImageFeedResult.userCanceled;
/**
 * @constructor
 * @struct
 */
Windows.System.UserProfile.UserInformation = function() {};
 /** @type {boolean} */
Windows.System.UserProfile.UserInformation.accountPictureChangeEnabled;
 /** @type {boolean} */
Windows.System.UserProfile.UserInformation.nameAccessAllowed;
 /** @type {function(?): void} */
Windows.System.UserProfile.UserInformation.onaccountpicturechanged;

/**
 * Gets the account picture for the user.
 * @param {Windows.System.UserProfile.AccountPictureKind} kind An enumeration that you can use to determine what type of image you want (small, large, and so on).
 * @return {!Windows.Storage.IStorageFile} An object that contains the image.
 */
Windows.System.UserProfile.UserInformation.getAccountPicture = function(kind) {};

/**
 * Gets the display name for the user account.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} The display name for the user account.
 */
Windows.System.UserProfile.UserInformation.getDisplayNameAsync = function() {};

/**
 * Gets the domain name for the user.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} A string that represents the domain name for the user.
 */
Windows.System.UserProfile.UserInformation.getDomainNameAsync = function() {};

/**
 * Gets the user's first name.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} The user's first name.
 */
Windows.System.UserProfile.UserInformation.getFirstNameAsync = function() {};

/**
 * Gets the user's last name.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} The user's last name.
 */
Windows.System.UserProfile.UserInformation.getLastNameAsync = function() {};

/**
 * Gets the principal name for the user. This name is the User Principal Name (typically the user's address, although this is not always true.)
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperation<string>>} The user's principal name.
 */
Windows.System.UserProfile.UserInformation.getPrincipalNameAsync = function() {};

/**
 * Gets the Uniform Resource Identifier (URI) of the session initiation protocol for the user.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Uri, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Uri>>} The URI of the session initiation protocol.
 */
Windows.System.UserProfile.UserInformation.getSessionInitiationProtocolUriAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.System.UserProfile.UserInformation.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.System.UserProfile.UserInformation.removeEventListener = function(type, listener) {};

/**
 * Sets the picture for the user's account using an IStorageFile object.
 * @param {!Windows.Storage.IStorageFile} image A file that contains the image.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.System.UserProfile.SetAccountPictureResult, !Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>>} A value that indicates the success or failure of the operation.
 */
Windows.System.UserProfile.UserInformation.setAccountPictureAsync = function(image) {};

/**
 * Sets the picture for the user's account using an IRandomAccessStream object.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} image The image.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.System.UserProfile.SetAccountPictureResult, !Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>>} A value that indicates the success or failure of the operation.
 */
Windows.System.UserProfile.UserInformation.setAccountPictureFromStreamAsync = function(image) {};

/**
 * Sets the pictures for the user's account using an IStorageFile object. Supports adding a small image, large image, and video.
 * @param {!Windows.Storage.IStorageFile} smallImage A small version of the image.
 * @param {!Windows.Storage.IStorageFile} largeImage A large version of the image.
 * @param {!Windows.Storage.IStorageFile} video A video.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.System.UserProfile.SetAccountPictureResult, !Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>>} A value that indicates the success or failure of the operation.
 */
Windows.System.UserProfile.UserInformation.setAccountPicturesAsync = function(smallImage, largeImage, video) {};

/**
 * Sets the pictures for the user's account using an IRandomAccessStream object. Supports adding a small image, large image, and video.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} smallImage A small version of the image.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} largeImage A large version of the image.
 * @param {!Windows.Storage.Streams.IRandomAccessStream} video A video.
 * @return {!Windows.Foundation.IPromiseWithOperation<Windows.System.UserProfile.SetAccountPictureResult, !Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>>} A value that indicates the success or failure of the operation.
 */
Windows.System.UserProfile.UserInformation.setAccountPicturesFromStreamsAsync = function(smallImage, largeImage, video) {};
/**
 * @constructor
 * @struct
 */
Windows.System.UserProfile.UserProfilePersonalizationSettings = function() {};
 /** @type {!Windows.System.UserProfile.UserProfilePersonalizationSettings} */
Windows.System.UserProfile.UserProfilePersonalizationSettings.current;

/**
 * Gets a value that indicates whether changing the desktop and lock screen images is supported on the current device.
 * @return {boolean} true if changing the desktop and lock screen images is supported; otherwise, false.
 */
Windows.System.UserProfile.UserProfilePersonalizationSettings.isSupported = function() {};

/**
 * Attempts to set the specified image file as the lock screen background image.
 * @param {!Windows.Storage.StorageFile} imageFile The image to set as the lock screen background.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The result of the async operation. true if the background image was set successfully; otherwise, false.
 */
Windows.System.UserProfile.UserProfilePersonalizationSettings.prototype.trySetLockScreenImageAsync = function(imageFile) {};

/**
 * Attempts to set the specified image file as the desktop wallpaper image.
 * @param {!Windows.Storage.StorageFile} imageFile The image to set as the desktop background.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} The result of the async operation. true if the background image was set successfully; otherwise, false.
 */
Windows.System.UserProfile.UserProfilePersonalizationSettings.prototype.trySetWallpaperImageAsync = function(imageFile) {};

/** @const */
Windows.System.UserType = {};
/** @const {number} */
Windows.System.UserType.localUser;
/** @const {number} */
Windows.System.UserType.remoteUser;
/** @const {number} */
Windows.System.UserType.localGuest;
/** @const {number} */
Windows.System.UserType.remoteGuest;
/**
 * @constructor
 * @struct
 */
Windows.System.UserWatcher = function() {};
 /** @type {function(?): void} */
Windows.System.UserWatcher.prototype.onadded;
 /** @type {function(?): void} */
Windows.System.UserWatcher.prototype.onauthenticationstatuschanged;
 /** @type {function(?): void} */
Windows.System.UserWatcher.prototype.onauthenticationstatuschanging;
 /** @type {function(?): void} */
Windows.System.UserWatcher.prototype.onenumerationcompleted;
 /** @type {function(?): void} */
Windows.System.UserWatcher.prototype.onremoved;
 /** @type {function(?): void} */
Windows.System.UserWatcher.prototype.onstopped;
 /** @type {function(?): void} */
Windows.System.UserWatcher.prototype.onupdated;
 /** @type {Windows.System.UserWatcherStatus} */
Windows.System.UserWatcher.prototype.status;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.System.UserWatcher.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.System.UserWatcher.prototype.removeEventListener = function(type, listener) {};

/**
 * Starts the user watcher.
 * @return {void}
 */
Windows.System.UserWatcher.prototype.start = function() {};

/**
 * Stops the user watcher.
 * @return {void}
 */
Windows.System.UserWatcher.prototype.stop = function() {};

/** @const */
Windows.System.UserWatcherStatus = {};
/** @const {number} */
Windows.System.UserWatcherStatus.created;
/** @const {number} */
Windows.System.UserWatcherStatus.started;
/** @const {number} */
Windows.System.UserWatcherStatus.enumerationCompleted;
/** @const {number} */
Windows.System.UserWatcherStatus.stopping;
/** @const {number} */
Windows.System.UserWatcherStatus.stopped;
/** @const {number} */
Windows.System.UserWatcherStatus.aborted;

/** @const */
Windows.System.VirtualKey = {};
/** @const {number} */
Windows.System.VirtualKey.none;
/** @const {number} */
Windows.System.VirtualKey.leftButton;
/** @const {number} */
Windows.System.VirtualKey.rightButton;
/** @const {number} */
Windows.System.VirtualKey.cancel;
/** @const {number} */
Windows.System.VirtualKey.middleButton;
/** @const {number} */
Windows.System.VirtualKey.xbutton1;
/** @const {number} */
Windows.System.VirtualKey.xbutton2;
/** @const {number} */
Windows.System.VirtualKey.back;
/** @const {number} */
Windows.System.VirtualKey.tab;
/** @const {number} */
Windows.System.VirtualKey.clear;
/** @const {number} */
Windows.System.VirtualKey.enter;
/** @const {number} */
Windows.System.VirtualKey.shift;
/** @const {number} */
Windows.System.VirtualKey.control;
/** @const {number} */
Windows.System.VirtualKey.menu;
/** @const {number} */
Windows.System.VirtualKey.pause;
/** @const {number} */
Windows.System.VirtualKey.capitalLock;
/** @const {number} */
Windows.System.VirtualKey.kana;
/** @const {number} */
Windows.System.VirtualKey.hangul;
/** @const {number} */
Windows.System.VirtualKey.junja;
/** @const {number} */
Windows.System.VirtualKey.final;
/** @const {number} */
Windows.System.VirtualKey.hanja;
/** @const {number} */
Windows.System.VirtualKey.kanji;
/** @const {number} */
Windows.System.VirtualKey.escape;
/** @const {number} */
Windows.System.VirtualKey.convert;
/** @const {number} */
Windows.System.VirtualKey.nonConvert;
/** @const {number} */
Windows.System.VirtualKey.accept;
/** @const {number} */
Windows.System.VirtualKey.modeChange;
/** @const {number} */
Windows.System.VirtualKey.space;
/** @const {number} */
Windows.System.VirtualKey.pageUp;
/** @const {number} */
Windows.System.VirtualKey.pageDown;
/** @const {number} */
Windows.System.VirtualKey.end;
/** @const {number} */
Windows.System.VirtualKey.home;
/** @const {number} */
Windows.System.VirtualKey.left;
/** @const {number} */
Windows.System.VirtualKey.up;
/** @const {number} */
Windows.System.VirtualKey.right;
/** @const {number} */
Windows.System.VirtualKey.down;
/** @const {number} */
Windows.System.VirtualKey.select;
/** @const {number} */
Windows.System.VirtualKey.print;
/** @const {number} */
Windows.System.VirtualKey.execute;
/** @const {number} */
Windows.System.VirtualKey.snapshot;
/** @const {number} */
Windows.System.VirtualKey.insert;
/** @const {number} */
Windows.System.VirtualKey.delete;
/** @const {number} */
Windows.System.VirtualKey.help;
/** @const {number} */
Windows.System.VirtualKey.number0;
/** @const {number} */
Windows.System.VirtualKey.number1;
/** @const {number} */
Windows.System.VirtualKey.number2;
/** @const {number} */
Windows.System.VirtualKey.number3;
/** @const {number} */
Windows.System.VirtualKey.number4;
/** @const {number} */
Windows.System.VirtualKey.number5;
/** @const {number} */
Windows.System.VirtualKey.number6;
/** @const {number} */
Windows.System.VirtualKey.number7;
/** @const {number} */
Windows.System.VirtualKey.number8;
/** @const {number} */
Windows.System.VirtualKey.number9;
/** @const {number} */
Windows.System.VirtualKey.a;
/** @const {number} */
Windows.System.VirtualKey.b;
/** @const {number} */
Windows.System.VirtualKey.c;
/** @const {number} */
Windows.System.VirtualKey.d;
/** @const {number} */
Windows.System.VirtualKey.e;
/** @const {number} */
Windows.System.VirtualKey.f;
/** @const {number} */
Windows.System.VirtualKey.g;
/** @const {number} */
Windows.System.VirtualKey.h;
/** @const {number} */
Windows.System.VirtualKey.i;
/** @const {number} */
Windows.System.VirtualKey.j;
/** @const {number} */
Windows.System.VirtualKey.k;
/** @const {number} */
Windows.System.VirtualKey.l;
/** @const {number} */
Windows.System.VirtualKey.m;
/** @const {number} */
Windows.System.VirtualKey.n;
/** @const {number} */
Windows.System.VirtualKey.o;
/** @const {number} */
Windows.System.VirtualKey.p;
/** @const {number} */
Windows.System.VirtualKey.q;
/** @const {number} */
Windows.System.VirtualKey.r;
/** @const {number} */
Windows.System.VirtualKey.s;
/** @const {number} */
Windows.System.VirtualKey.t;
/** @const {number} */
Windows.System.VirtualKey.u;
/** @const {number} */
Windows.System.VirtualKey.v;
/** @const {number} */
Windows.System.VirtualKey.w;
/** @const {number} */
Windows.System.VirtualKey.x;
/** @const {number} */
Windows.System.VirtualKey.y;
/** @const {number} */
Windows.System.VirtualKey.z;
/** @const {number} */
Windows.System.VirtualKey.leftWindows;
/** @const {number} */
Windows.System.VirtualKey.rightWindows;
/** @const {number} */
Windows.System.VirtualKey.application;
/** @const {number} */
Windows.System.VirtualKey.sleep;
/** @const {number} */
Windows.System.VirtualKey.numberPad0;
/** @const {number} */
Windows.System.VirtualKey.numberPad1;
/** @const {number} */
Windows.System.VirtualKey.numberPad2;
/** @const {number} */
Windows.System.VirtualKey.numberPad3;
/** @const {number} */
Windows.System.VirtualKey.numberPad4;
/** @const {number} */
Windows.System.VirtualKey.numberPad5;
/** @const {number} */
Windows.System.VirtualKey.numberPad6;
/** @const {number} */
Windows.System.VirtualKey.numberPad7;
/** @const {number} */
Windows.System.VirtualKey.numberPad8;
/** @const {number} */
Windows.System.VirtualKey.numberPad9;
/** @const {number} */
Windows.System.VirtualKey.multiply;
/** @const {number} */
Windows.System.VirtualKey.add;
/** @const {number} */
Windows.System.VirtualKey.separator;
/** @const {number} */
Windows.System.VirtualKey.subtract;
/** @const {number} */
Windows.System.VirtualKey.decimal;
/** @const {number} */
Windows.System.VirtualKey.divide;
/** @const {number} */
Windows.System.VirtualKey.f1;
/** @const {number} */
Windows.System.VirtualKey.f2;
/** @const {number} */
Windows.System.VirtualKey.f3;
/** @const {number} */
Windows.System.VirtualKey.f4;
/** @const {number} */
Windows.System.VirtualKey.f5;
/** @const {number} */
Windows.System.VirtualKey.f6;
/** @const {number} */
Windows.System.VirtualKey.f7;
/** @const {number} */
Windows.System.VirtualKey.f8;
/** @const {number} */
Windows.System.VirtualKey.f9;
/** @const {number} */
Windows.System.VirtualKey.f10;
/** @const {number} */
Windows.System.VirtualKey.f11;
/** @const {number} */
Windows.System.VirtualKey.f12;
/** @const {number} */
Windows.System.VirtualKey.f13;
/** @const {number} */
Windows.System.VirtualKey.f14;
/** @const {number} */
Windows.System.VirtualKey.f15;
/** @const {number} */
Windows.System.VirtualKey.f16;
/** @const {number} */
Windows.System.VirtualKey.f17;
/** @const {number} */
Windows.System.VirtualKey.f18;
/** @const {number} */
Windows.System.VirtualKey.f19;
/** @const {number} */
Windows.System.VirtualKey.f20;
/** @const {number} */
Windows.System.VirtualKey.f21;
/** @const {number} */
Windows.System.VirtualKey.f22;
/** @const {number} */
Windows.System.VirtualKey.f23;
/** @const {number} */
Windows.System.VirtualKey.f24;
/** @const {number} */
Windows.System.VirtualKey.navigationView;
/** @const {number} */
Windows.System.VirtualKey.navigationMenu;
/** @const {number} */
Windows.System.VirtualKey.navigationUp;
/** @const {number} */
Windows.System.VirtualKey.navigationDown;
/** @const {number} */
Windows.System.VirtualKey.navigationLeft;
/** @const {number} */
Windows.System.VirtualKey.navigationRight;
/** @const {number} */
Windows.System.VirtualKey.navigationAccept;
/** @const {number} */
Windows.System.VirtualKey.navigationCancel;
/** @const {number} */
Windows.System.VirtualKey.numberKeyLock;
/** @const {number} */
Windows.System.VirtualKey.scroll;
/** @const {number} */
Windows.System.VirtualKey.leftShift;
/** @const {number} */
Windows.System.VirtualKey.rightShift;
/** @const {number} */
Windows.System.VirtualKey.leftControl;
/** @const {number} */
Windows.System.VirtualKey.rightControl;
/** @const {number} */
Windows.System.VirtualKey.leftMenu;
/** @const {number} */
Windows.System.VirtualKey.rightMenu;
/** @const {number} */
Windows.System.VirtualKey.goBack;
/** @const {number} */
Windows.System.VirtualKey.goForward;
/** @const {number} */
Windows.System.VirtualKey.refresh;
/** @const {number} */
Windows.System.VirtualKey.stop;
/** @const {number} */
Windows.System.VirtualKey.search;
/** @const {number} */
Windows.System.VirtualKey.favorites;
/** @const {number} */
Windows.System.VirtualKey.goHome;
/** @const {number} */
Windows.System.VirtualKey.gamepadA;
/** @const {number} */
Windows.System.VirtualKey.gamepadB;
/** @const {number} */
Windows.System.VirtualKey.gamepadX;
/** @const {number} */
Windows.System.VirtualKey.gamepadY;
/** @const {number} */
Windows.System.VirtualKey.gamepadRightShoulder;
/** @const {number} */
Windows.System.VirtualKey.gamepadLeftShoulder;
/** @const {number} */
Windows.System.VirtualKey.gamepadLeftTrigger;
/** @const {number} */
Windows.System.VirtualKey.gamepadRightTrigger;
/** @const {number} */
Windows.System.VirtualKey.gamepadDPadUp;
/** @const {number} */
Windows.System.VirtualKey.gamepadDPadDown;
/** @const {number} */
Windows.System.VirtualKey.gamepadDPadLeft;
/** @const {number} */
Windows.System.VirtualKey.gamepadDPadRight;
/** @const {number} */
Windows.System.VirtualKey.gamepadMenu;
/** @const {number} */
Windows.System.VirtualKey.gamepadView;
/** @const {number} */
Windows.System.VirtualKey.gamepadLeftThumbstickButton;
/** @const {number} */
Windows.System.VirtualKey.gamepadRightThumbstickButton;
/** @const {number} */
Windows.System.VirtualKey.gamepadLeftThumbstickUp;
/** @const {number} */
Windows.System.VirtualKey.gamepadLeftThumbstickDown;
/** @const {number} */
Windows.System.VirtualKey.gamepadLeftThumbstickRight;
/** @const {number} */
Windows.System.VirtualKey.gamepadLeftThumbstickLeft;
/** @const {number} */
Windows.System.VirtualKey.gamepadRightThumbstickUp;
/** @const {number} */
Windows.System.VirtualKey.gamepadRightThumbstickDown;
/** @const {number} */
Windows.System.VirtualKey.gamepadRightThumbstickRight;
/** @const {number} */
Windows.System.VirtualKey.gamepadRightThumbstickLeft;

/** @const */
Windows.System.VirtualKeyModifiers = {};
/** @const {number} */
Windows.System.VirtualKeyModifiers.none;
/** @const {number} */
Windows.System.VirtualKeyModifiers.control;
/** @const {number} */
Windows.System.VirtualKeyModifiers.menu;
/** @const {number} */
Windows.System.VirtualKeyModifiers.shift;
/** @const {number} */
Windows.System.VirtualKeyModifiers.windows;
/** @const */
Windows.UI = {};
/** @const */
Windows.UI.ApplicationSettings = {};
/**
 * @constructor
 * @struct
 */
Windows.UI.ApplicationSettings.AccountsSettingsPane = function() {};
 /** @type {function(?): void} */
Windows.UI.ApplicationSettings.AccountsSettingsPane.prototype.onaccountcommandsrequested;

/**
 * Gets an AccountsSettingsPane object that is associated with the current app view (that is, with CoreWindow ).
 * @return {!Windows.UI.ApplicationSettings.AccountsSettingsPane} The account settings pane.
 */
Windows.UI.ApplicationSettings.AccountsSettingsPane.getForCurrentView = function() {};

/**
 * Displays the account settings pane.
 * @return {void}
 */
Windows.UI.ApplicationSettings.AccountsSettingsPane.show = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.ApplicationSettings.AccountsSettingsPane.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.ApplicationSettings.AccountsSettingsPane.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.ApplicationSettings.AccountsSettingsPaneCommandsRequestedEventArgs = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.UI.ApplicationSettings.SettingsCommand>} */
Windows.UI.ApplicationSettings.AccountsSettingsPaneCommandsRequestedEventArgs.prototype.commands;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.UI.ApplicationSettings.CredentialCommand>} */
Windows.UI.ApplicationSettings.AccountsSettingsPaneCommandsRequestedEventArgs.prototype.credentialCommands;
 /** @type {string} */
Windows.UI.ApplicationSettings.AccountsSettingsPaneCommandsRequestedEventArgs.prototype.headerText;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.UI.ApplicationSettings.WebAccountCommand>} */
Windows.UI.ApplicationSettings.AccountsSettingsPaneCommandsRequestedEventArgs.prototype.webAccountCommands;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.UI.ApplicationSettings.WebAccountProviderCommand>} */
Windows.UI.ApplicationSettings.AccountsSettingsPaneCommandsRequestedEventArgs.prototype.webAccountProviderCommands;

/**
 * Gets the deferral object for the AccountCommandsRequested event.
 * @return {!Windows.UI.ApplicationSettings.AccountsSettingsPaneEventDeferral} The deferral object.
 */
Windows.UI.ApplicationSettings.AccountsSettingsPaneCommandsRequestedEventArgs.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.ApplicationSettings.AccountsSettingsPaneEventDeferral = function() {};

/**
 * Signals that the app has finished populating command collections while handling the AccountCommandsRequested event.
 * @return {void}
 */
Windows.UI.ApplicationSettings.AccountsSettingsPaneEventDeferral.prototype.complete = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the CredentialCommand class with a PasswordCredential object.
 * Initializes a new instance of the CredentialCommand class with a PasswordCredential object and a CredentialCommandCredentialDeletedHandler delegate.
 * @param {!Windows.Security.Credentials.PasswordCredential} passwordCredential The password credential.
 * @param {function(!Windows.UI.ApplicationSettings.CredentialCommand): void=} deleted The delegate that handles credential deletion.
 */
Windows.UI.ApplicationSettings.CredentialCommand = function(passwordCredential, deleted) {};
 /** @type {function(!Windows.UI.ApplicationSettings.CredentialCommand): void} */
Windows.UI.ApplicationSettings.CredentialCommand.prototype.credentialDeleted;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.UI.ApplicationSettings.CredentialCommand.prototype.passwordCredential;

/**
 * @constructor
 * @struct
 * Creates a new settings command.
 * @param {?} settingsCommandId The ID of the command.
 * @param {string} label The label for the command, which is displayed in the settings pane.
 * @param {function(!Windows.UI.Popups.IUICommand): void} handler The event handler that is called when the user selects this command in the settings pane.
 */
Windows.UI.ApplicationSettings.SettingsCommand = function(settingsCommandId, label, handler) {};
 /** @type {!Windows.UI.ApplicationSettings.SettingsCommand} */
Windows.UI.ApplicationSettings.SettingsCommand.accountsCommand;
 /** @type {?} */
Windows.UI.ApplicationSettings.SettingsCommand.prototype.id;
 /** @type {function(!Windows.UI.Popups.IUICommand): void} */
Windows.UI.ApplicationSettings.SettingsCommand.prototype.invoked;
 /** @type {string} */
Windows.UI.ApplicationSettings.SettingsCommand.prototype.label;

/** @const */
Windows.UI.ApplicationSettings.SettingsEdgeLocation = {};
/** @const {number} */
Windows.UI.ApplicationSettings.SettingsEdgeLocation.right;
/** @const {number} */
Windows.UI.ApplicationSettings.SettingsEdgeLocation.left;
/**
 * @constructor
 * @struct
 */
Windows.UI.ApplicationSettings.SettingsPane = function() {};
 /** @type {Windows.UI.ApplicationSettings.SettingsEdgeLocation} */
Windows.UI.ApplicationSettings.SettingsPane.edge;
 /** @type {function(?): void} */
Windows.UI.ApplicationSettings.SettingsPane.prototype.oncommandsrequested;

/**
 * Gets a SettingsPane object that is associated with the current app view (that is, with CoreWindow ).
 * @return {!Windows.UI.ApplicationSettings.SettingsPane} The settings pane.
 */
Windows.UI.ApplicationSettings.SettingsPane.getForCurrentView = function() {};

/**
 * Displays the Settings Charm pane to the user.
 * @return {void}
 */
Windows.UI.ApplicationSettings.SettingsPane.show = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.ApplicationSettings.SettingsPane.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.ApplicationSettings.SettingsPane.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.ApplicationSettings.SettingsPaneCommandsRequest = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.UI.ApplicationSettings.SettingsCommand>} */
Windows.UI.ApplicationSettings.SettingsPaneCommandsRequest.prototype.applicationCommands;
/**
 * @constructor
 * @struct
 */
Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs = function() {};
 /** @type {!Windows.UI.ApplicationSettings.SettingsPaneCommandsRequest} */
Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs.prototype.request;

/** @const */
Windows.UI.ApplicationSettings.SupportedWebAccountActions = {};
/** @const {number} */
Windows.UI.ApplicationSettings.SupportedWebAccountActions.none;
/** @const {number} */
Windows.UI.ApplicationSettings.SupportedWebAccountActions.reconnect;
/** @const {number} */
Windows.UI.ApplicationSettings.SupportedWebAccountActions.remove;
/** @const {number} */
Windows.UI.ApplicationSettings.SupportedWebAccountActions.viewDetails;
/** @const {number} */
Windows.UI.ApplicationSettings.SupportedWebAccountActions.manage;
/** @const {number} */
Windows.UI.ApplicationSettings.SupportedWebAccountActions.more;

/** @const */
Windows.UI.ApplicationSettings.WebAccountAction = {};
/** @const {number} */
Windows.UI.ApplicationSettings.WebAccountAction.reconnect;
/** @const {number} */
Windows.UI.ApplicationSettings.WebAccountAction.remove;
/** @const {number} */
Windows.UI.ApplicationSettings.WebAccountAction.viewDetails;
/** @const {number} */
Windows.UI.ApplicationSettings.WebAccountAction.manage;
/** @const {number} */
Windows.UI.ApplicationSettings.WebAccountAction.more;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the WebAccountCommand class.
 * @param {!Windows.Security.Credentials.WebAccount} webAccount The web account to associate with the current command.
 * @param {function(!Windows.UI.ApplicationSettings.WebAccountCommand, !Windows.UI.ApplicationSettings.WebAccountInvokedArgs): void} invoked The delegate that handles the command.
 * @param {Windows.UI.ApplicationSettings.SupportedWebAccountActions} actions A bitmask of web account actions.
 */
Windows.UI.ApplicationSettings.WebAccountCommand = function(webAccount, invoked, actions) {};
 /** @type {Windows.UI.ApplicationSettings.SupportedWebAccountActions} */
Windows.UI.ApplicationSettings.WebAccountCommand.prototype.actions;
 /** @type {function(!Windows.UI.ApplicationSettings.WebAccountCommand, !Windows.UI.ApplicationSettings.WebAccountInvokedArgs): void} */
Windows.UI.ApplicationSettings.WebAccountCommand.prototype.invoked;
 /** @type {!Windows.Security.Credentials.WebAccount} */
Windows.UI.ApplicationSettings.WebAccountCommand.prototype.webAccount;
/**
 * @constructor
 * @struct
 */
Windows.UI.ApplicationSettings.WebAccountInvokedArgs = function() {};
 /** @type {Windows.UI.ApplicationSettings.WebAccountAction} */
Windows.UI.ApplicationSettings.WebAccountInvokedArgs.prototype.action;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the WebAccountProviderCommand class.
 * @param {!Windows.Security.Credentials.WebAccountProvider} webAccountProvider The web account provider.
 * @param {function(!Windows.UI.ApplicationSettings.WebAccountProviderCommand): void} invoked The delegate that handles the provider command.
 */
Windows.UI.ApplicationSettings.WebAccountProviderCommand = function(webAccountProvider, invoked) {};
 /** @type {function(!Windows.UI.ApplicationSettings.WebAccountProviderCommand): void} */
Windows.UI.ApplicationSettings.WebAccountProviderCommand.prototype.invoked;
 /** @type {!Windows.Security.Credentials.WebAccountProvider} */
Windows.UI.ApplicationSettings.WebAccountProviderCommand.prototype.webAccountProvider;

/** @typedef {function(!Windows.UI.ApplicationSettings.CredentialCommand): void} */
Windows.UI.ApplicationSettings.CredentialCommandCredentialDeletedHandler;

/** @typedef {function(!Windows.UI.ApplicationSettings.WebAccountCommand, !Windows.UI.ApplicationSettings.WebAccountInvokedArgs): void} */
Windows.UI.ApplicationSettings.WebAccountCommandInvokedHandler;

/** @typedef {function(!Windows.UI.ApplicationSettings.WebAccountProviderCommand): void} */
Windows.UI.ApplicationSettings.WebAccountProviderCommandInvokedHandler;
/**
 * @constructor
 * @struct
 */
Windows.UI.ColorHelper = function() {};

/**
 * Generates a Color structure, based on discrete Byte values for ARGB components. C# and Microsoft Visual Basic code should use Color.FromArgb instead.
 * @param {number} a The A (transparency) component of the desired color. Range is 0-255.
 * @param {number} r The R component of the desired color. Range is 0-255.
 * @param {number} g The G component of the desired color. Range is 0-255.
 * @param {number} b The B component of the desired color. Range is 0-255.
 * @return {!Windows.UI.Color} The generated Color value.
 */
Windows.UI.ColorHelper.fromArgb = function(a, r, g, b) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Colors = function() {};
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.aliceBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.antiqueWhite;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.aqua;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.aquamarine;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.azure;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.beige;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.bisque;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.black;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.blanchedAlmond;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.blue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.blueViolet;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.brown;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.burlyWood;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.cadetBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.chartreuse;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.chocolate;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.coral;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.cornflowerBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.cornsilk;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.crimson;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.cyan;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkCyan;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkGoldenrod;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkGray;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkGreen;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkKhaki;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkMagenta;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkOliveGreen;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkOrange;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkOrchid;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkRed;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkSalmon;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkSeaGreen;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkSlateBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkSlateGray;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkTurquoise;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.darkViolet;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.deepPink;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.deepSkyBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.dimGray;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.dodgerBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.firebrick;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.floralWhite;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.forestGreen;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.fuchsia;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.gainsboro;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.ghostWhite;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.gold;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.goldenrod;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.gray;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.green;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.greenYellow;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.honeydew;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.hotPink;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.indianRed;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.indigo;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.ivory;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.khaki;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lavender;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lavenderBlush;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lawnGreen;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lemonChiffon;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lightBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lightCoral;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lightCyan;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lightGoldenrodYellow;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lightGray;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lightGreen;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lightPink;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lightSalmon;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lightSeaGreen;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lightSkyBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lightSlateGray;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lightSteelBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lightYellow;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.lime;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.limeGreen;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.linen;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.magenta;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.maroon;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.mediumAquamarine;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.mediumBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.mediumOrchid;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.mediumPurple;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.mediumSeaGreen;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.mediumSlateBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.mediumSpringGreen;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.mediumTurquoise;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.mediumVioletRed;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.midnightBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.mintCream;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.mistyRose;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.moccasin;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.navajoWhite;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.navy;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.oldLace;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.olive;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.oliveDrab;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.orange;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.orangeRed;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.orchid;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.paleGoldenrod;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.paleGreen;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.paleTurquoise;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.paleVioletRed;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.papayaWhip;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.peachPuff;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.peru;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.pink;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.plum;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.powderBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.purple;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.red;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.rosyBrown;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.royalBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.saddleBrown;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.salmon;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.sandyBrown;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.seaGreen;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.seaShell;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.sienna;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.silver;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.skyBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.slateBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.slateGray;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.snow;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.springGreen;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.steelBlue;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.tan;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.teal;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.thistle;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.tomato;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.transparent;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.turquoise;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.violet;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.wheat;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.white;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.whiteSmoke;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.yellow;
 /** @type {!Windows.UI.Color} */
Windows.UI.Colors.yellowGreen;
/** @const */
Windows.UI.Composition = {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Composition.CompositionAnimation = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Composition.CompositionEasingFunction = function() {};
/** @const */
Windows.UI.Core = {};
/** @const */
Windows.UI.Core.AnimationMetrics = {};

/**
 * @constructor
 * @struct
 * Creates an AnimationDescription object with a specific animation and target.
 * @param {Windows.UI.Core.AnimationMetrics.AnimationEffect} effect The animation effect to apply to the target.
 * @param {Windows.UI.Core.AnimationMetrics.AnimationEffectTarget} target The target of the animation effect.
 */
Windows.UI.Core.AnimationMetrics.AnimationDescription = function(effect, target) {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Core.AnimationMetrics.IPropertyAnimation>} */
Windows.UI.Core.AnimationMetrics.AnimationDescription.prototype.animations;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.AnimationDescription.prototype.delayLimit;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.AnimationDescription.prototype.staggerDelay;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.AnimationDescription.prototype.staggerDelayFactor;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.AnimationDescription.prototype.zorder;

/** @const */
Windows.UI.Core.AnimationMetrics.AnimationEffect = {};
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.expand;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.collapse;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.reposition;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.fadeIn;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.fadeOut;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.addToList;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.deleteFromList;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.addToGrid;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.deleteFromGrid;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.addToSearchGrid;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.deleteFromSearchGrid;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.addToSearchList;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.deleteFromSearchList;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.showEdgeUI;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.showPanel;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.hideEdgeUI;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.hidePanel;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.showPopup;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.hidePopup;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.pointerDown;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.pointerUp;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.dragSourceStart;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.dragSourceEnd;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.transitionContent;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.reveal;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.hide;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.dragBetweenEnter;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.dragBetweenLeave;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.swipeSelect;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.swipeDeselect;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.swipeReveal;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.enterPage;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.transitionPage;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.crossFade;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.peek;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffect.updateBadge;

/** @const */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget = {};
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.primary;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.added;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.affected;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.background;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.content;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.deleted;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.deselected;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.dragSource;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.hidden;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.incoming;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.outgoing;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.outline;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.remaining;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.revealed;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.rowIn;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.rowOut;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.selected;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.selection;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.shown;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.AnimationEffectTarget.tapped;
/**
 * @constructor
 * @struct
 */
Windows.UI.Core.AnimationMetrics.OpacityAnimation = function() {};
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Core.AnimationMetrics.OpacityAnimation.prototype.control1;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Core.AnimationMetrics.OpacityAnimation.prototype.control2;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.OpacityAnimation.prototype.delay;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.OpacityAnimation.prototype.duration;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.OpacityAnimation.prototype.finalOpacity;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.OpacityAnimation.prototype.initialOpacity;
 /** @type {Windows.UI.Core.AnimationMetrics.PropertyAnimationType} */
Windows.UI.Core.AnimationMetrics.OpacityAnimation.prototype.type;
/**
 * @constructor
 * @struct
 */
Windows.UI.Core.AnimationMetrics.PropertyAnimation = function() {};
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Core.AnimationMetrics.PropertyAnimation.prototype.control1;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Core.AnimationMetrics.PropertyAnimation.prototype.control2;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.PropertyAnimation.prototype.delay;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.PropertyAnimation.prototype.duration;
 /** @type {Windows.UI.Core.AnimationMetrics.PropertyAnimationType} */
Windows.UI.Core.AnimationMetrics.PropertyAnimation.prototype.type;

/** @const */
Windows.UI.Core.AnimationMetrics.PropertyAnimationType = {};
/** @const {number} */
Windows.UI.Core.AnimationMetrics.PropertyAnimationType.scale;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.PropertyAnimationType.translation;
/** @const {number} */
Windows.UI.Core.AnimationMetrics.PropertyAnimationType.opacity;
/**
 * @constructor
 * @struct
 */
Windows.UI.Core.AnimationMetrics.ScaleAnimation = function() {};
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Core.AnimationMetrics.ScaleAnimation.prototype.control1;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Core.AnimationMetrics.ScaleAnimation.prototype.control2;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.ScaleAnimation.prototype.delay;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.ScaleAnimation.prototype.duration;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.ScaleAnimation.prototype.finalScaleX;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.ScaleAnimation.prototype.finalScaleY;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.ScaleAnimation.prototype.initialScaleX;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.ScaleAnimation.prototype.initialScaleY;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Core.AnimationMetrics.ScaleAnimation.prototype.normalizedOrigin;
 /** @type {Windows.UI.Core.AnimationMetrics.PropertyAnimationType} */
Windows.UI.Core.AnimationMetrics.ScaleAnimation.prototype.type;
/**
 * @constructor
 * @struct
 */
Windows.UI.Core.AnimationMetrics.TranslationAnimation = function() {};
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Core.AnimationMetrics.TranslationAnimation.prototype.control1;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Core.AnimationMetrics.TranslationAnimation.prototype.control2;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.TranslationAnimation.prototype.delay;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.TranslationAnimation.prototype.duration;
 /** @type {Windows.UI.Core.AnimationMetrics.PropertyAnimationType} */
Windows.UI.Core.AnimationMetrics.TranslationAnimation.prototype.type;
/**
 * @record
 * @struct
 */
Windows.UI.Core.AnimationMetrics.IPropertyAnimation = function() {};
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Core.AnimationMetrics.IPropertyAnimation.prototype.control1;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Core.AnimationMetrics.IPropertyAnimation.prototype.control2;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.IPropertyAnimation.prototype.delay;
 /** @type {number} */
Windows.UI.Core.AnimationMetrics.IPropertyAnimation.prototype.duration;
 /** @type {Windows.UI.Core.AnimationMetrics.PropertyAnimationType} */
Windows.UI.Core.AnimationMetrics.IPropertyAnimation.prototype.type;

/** @const */
Windows.UI.Core.AppViewBackButtonVisibility = {};
/** @const {number} */
Windows.UI.Core.AppViewBackButtonVisibility.visible;
/** @const {number} */
Windows.UI.Core.AppViewBackButtonVisibility.collapsed;
/**
 * @constructor
 * @struct
 */
Windows.UI.Core.BackRequestedEventArgs = function() {};
 /** @type {boolean} */
Windows.UI.Core.BackRequestedEventArgs.prototype.handled;
/**
 * @constructor
 * @struct
 */
Windows.UI.Core.SystemNavigationManager = function() {};
 /** @type {Windows.UI.Core.AppViewBackButtonVisibility} */
Windows.UI.Core.SystemNavigationManager.prototype.appViewBackButtonVisibility;
 /** @type {function(?): void} */
Windows.UI.Core.SystemNavigationManager.prototype.onbackrequested;

/**
 * Returns the SystemNavigationManager object associated with the current window.
 * @return {!Windows.UI.Core.SystemNavigationManager} The SystemNavigationManager object associated with the current window.
 */
Windows.UI.Core.SystemNavigationManager.getForCurrentView = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.Core.SystemNavigationManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.Core.SystemNavigationManager.prototype.removeEventListener = function(type, listener) {};
/** @const */
Windows.UI.Input = {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.CrossSlidingEventArgs = function() {};
 /** @type {Windows.UI.Input.CrossSlidingState} */
Windows.UI.Input.CrossSlidingEventArgs.prototype.crossSlidingState;
 /** @type {Windows.Devices.Input.PointerDeviceType} */
Windows.UI.Input.CrossSlidingEventArgs.prototype.pointerDeviceType;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.CrossSlidingEventArgs.prototype.position;

/** @const */
Windows.UI.Input.CrossSlidingState = {};
/** @const {number} */
Windows.UI.Input.CrossSlidingState.started;
/** @const {number} */
Windows.UI.Input.CrossSlidingState.dragging;
/** @const {number} */
Windows.UI.Input.CrossSlidingState.selecting;
/** @const {number} */
Windows.UI.Input.CrossSlidingState.selectSpeedBumping;
/** @const {number} */
Windows.UI.Input.CrossSlidingState.speedBumping;
/** @const {number} */
Windows.UI.Input.CrossSlidingState.rearranging;
/** @const {number} */
Windows.UI.Input.CrossSlidingState.completed;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.DraggingEventArgs = function() {};
 /** @type {Windows.UI.Input.DraggingState} */
Windows.UI.Input.DraggingEventArgs.prototype.draggingState;
 /** @type {Windows.Devices.Input.PointerDeviceType} */
Windows.UI.Input.DraggingEventArgs.prototype.pointerDeviceType;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.DraggingEventArgs.prototype.position;

/** @const */
Windows.UI.Input.DraggingState = {};
/** @const {number} */
Windows.UI.Input.DraggingState.started;
/** @const {number} */
Windows.UI.Input.DraggingState.continuing;
/** @const {number} */
Windows.UI.Input.DraggingState.completed;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.EdgeGesture = function() {};
 /** @type {function(?): void} */
Windows.UI.Input.EdgeGesture.prototype.oncanceled;
 /** @type {function(?): void} */
Windows.UI.Input.EdgeGesture.prototype.oncompleted;
 /** @type {function(?): void} */
Windows.UI.Input.EdgeGesture.prototype.onstarting;

/**
 * Gets an instance of the EdgeGesture class that is used to add and remove event delegate handlers for the current view.
 * @return {!Windows.UI.Input.EdgeGesture} The currently relevant instance of the EdgeGesture object.
 */
Windows.UI.Input.EdgeGesture.getForCurrentView = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.Input.EdgeGesture.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.Input.EdgeGesture.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.EdgeGestureEventArgs = function() {};
 /** @type {Windows.UI.Input.EdgeGestureKind} */
Windows.UI.Input.EdgeGestureEventArgs.prototype.kind;

/** @const */
Windows.UI.Input.EdgeGestureKind = {};
/** @const {number} */
Windows.UI.Input.EdgeGestureKind.touch;
/** @const {number} */
Windows.UI.Input.EdgeGestureKind.keyboard;
/** @const {number} */
Windows.UI.Input.EdgeGestureKind.mouse;

/**
 * @constructor
 * @struct
 * Initializes a new instance of a GestureRecognizer object.
 */
Windows.UI.Input.GestureRecognizer = function() {};
 /** @type {boolean} */
Windows.UI.Input.GestureRecognizer.prototype.autoProcessInertia;
 /** @type {boolean} */
Windows.UI.Input.GestureRecognizer.prototype.crossSlideExact;
 /** @type {boolean} */
Windows.UI.Input.GestureRecognizer.prototype.crossSlideHorizontally;
 /** @type {!Windows.UI.Input.CrossSlideThresholds} */
Windows.UI.Input.GestureRecognizer.prototype.crossSlideThresholds;
 /** @type {Windows.UI.Input.GestureSettings} */
Windows.UI.Input.GestureRecognizer.prototype.gestureSettings;
 /** @type {number} */
Windows.UI.Input.GestureRecognizer.prototype.inertiaExpansion;
 /** @type {number} */
Windows.UI.Input.GestureRecognizer.prototype.inertiaExpansionDeceleration;
 /** @type {number} */
Windows.UI.Input.GestureRecognizer.prototype.inertiaRotationAngle;
 /** @type {number} */
Windows.UI.Input.GestureRecognizer.prototype.inertiaRotationDeceleration;
 /** @type {number} */
Windows.UI.Input.GestureRecognizer.prototype.inertiaTranslationDeceleration;
 /** @type {number} */
Windows.UI.Input.GestureRecognizer.prototype.inertiaTranslationDisplacement;
 /** @type {boolean} */
Windows.UI.Input.GestureRecognizer.prototype.isActive;
 /** @type {boolean} */
Windows.UI.Input.GestureRecognizer.prototype.isInertial;
 /** @type {boolean} */
Windows.UI.Input.GestureRecognizer.prototype.manipulationExact;
 /** @type {!Windows.UI.Input.MouseWheelParameters} */
Windows.UI.Input.GestureRecognizer.prototype.mouseWheelParameters;
 /** @type {function(?): void} */
Windows.UI.Input.GestureRecognizer.prototype.oncrosssliding;
 /** @type {function(?): void} */
Windows.UI.Input.GestureRecognizer.prototype.ondragging;
 /** @type {function(?): void} */
Windows.UI.Input.GestureRecognizer.prototype.onholding;
 /** @type {function(?): void} */
Windows.UI.Input.GestureRecognizer.prototype.onmanipulationcompleted;
 /** @type {function(?): void} */
Windows.UI.Input.GestureRecognizer.prototype.onmanipulationinertiastarting;
 /** @type {function(?): void} */
Windows.UI.Input.GestureRecognizer.prototype.onmanipulationstarted;
 /** @type {function(?): void} */
Windows.UI.Input.GestureRecognizer.prototype.onmanipulationupdated;
 /** @type {function(?): void} */
Windows.UI.Input.GestureRecognizer.prototype.onrighttapped;
 /** @type {function(?): void} */
Windows.UI.Input.GestureRecognizer.prototype.ontapped;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.GestureRecognizer.prototype.pivotCenter;
 /** @type {number} */
Windows.UI.Input.GestureRecognizer.prototype.pivotRadius;
 /** @type {boolean} */
Windows.UI.Input.GestureRecognizer.prototype.showGestureFeedback;

/**
 * Identifies whether a tap can still be interpreted as the second tap of a double tap gesture.
 * @param {!Windows.UI.Input.PointerPoint} value The last input pointer.
 * @return {boolean} True if a UI element supports the double tap gesture and the time threshold to complete the gesture has not been crossed; otherwise false.
 */
Windows.UI.Input.GestureRecognizer.prototype.canBeDoubleTap = function(value) {};

/**
 * Causes the gesture recognizer to finalize an interaction.
 * @return {void}
 */
Windows.UI.Input.GestureRecognizer.prototype.completeGesture = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.Input.GestureRecognizer.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.Input.GestureRecognizer.prototype.removeEventListener = function(type, listener) {};

/**
 * Processes pointer input and raises the GestureRecognizer events appropriate to a pointer down action for the gestures and manipulations specified by the GestureSettings property.
 * @param {!Windows.UI.Input.PointerPoint} value The input point.
 * @return {void}
 */
Windows.UI.Input.GestureRecognizer.prototype.processDownEvent = function(value) {};

/**
 * Performs inertia calculations and raises the various inertia events.
 * @return {void}
 */
Windows.UI.Input.GestureRecognizer.prototype.processInertia = function() {};

/**
 * Processes pointer input and raises the GestureRecognizer events appropriate to a mouse wheel action for the gestures and manipulations specified by the GestureSettings property.
 * @param {!Windows.UI.Input.PointerPoint} value The input point.
 * @param {boolean} isShiftKeyDown True if the Shift key is pressed; otherwise false.
 * @param {boolean} isControlKeyDown True if the Ctrl key is pressed.
 * @return {void}
 */
Windows.UI.Input.GestureRecognizer.prototype.processMouseWheelEvent = function(value, isShiftKeyDown, isControlKeyDown) {};

/**
 * Processes pointer input and raises the GestureRecognizer events appropriate to a pointer move action for the gestures and manipulations specified by the GestureSettings property.
 * @param {!Windows.Foundation.Collections.IVector<!Windows.UI.Input.PointerPoint>} value The pointer location history based on the PointerId . If no history is available then the value is the current location of the input pointer.
 * @return {void}
 */
Windows.UI.Input.GestureRecognizer.prototype.processMoveEvents = function(value) {};

/**
 * Processes pointer input and raises the GestureRecognizer events appropriate to a pointer up action for the gestures and manipulations specified by the GestureSettings property.
 * @param {!Windows.UI.Input.PointerPoint} value The input point.
 * @return {void}
 */
Windows.UI.Input.GestureRecognizer.prototype.processUpEvent = function(value) {};

/** @const */
Windows.UI.Input.GestureSettings = {};
/** @const {number} */
Windows.UI.Input.GestureSettings.none;
/** @const {number} */
Windows.UI.Input.GestureSettings.tap;
/** @const {number} */
Windows.UI.Input.GestureSettings.doubleTap;
/** @const {number} */
Windows.UI.Input.GestureSettings.hold;
/** @const {number} */
Windows.UI.Input.GestureSettings.holdWithMouse;
/** @const {number} */
Windows.UI.Input.GestureSettings.rightTap;
/** @const {number} */
Windows.UI.Input.GestureSettings.drag;
/** @const {number} */
Windows.UI.Input.GestureSettings.manipulationTranslateX;
/** @const {number} */
Windows.UI.Input.GestureSettings.manipulationTranslateY;
/** @const {number} */
Windows.UI.Input.GestureSettings.manipulationTranslateRailsX;
/** @const {number} */
Windows.UI.Input.GestureSettings.manipulationTranslateRailsY;
/** @const {number} */
Windows.UI.Input.GestureSettings.manipulationRotate;
/** @const {number} */
Windows.UI.Input.GestureSettings.manipulationScale;
/** @const {number} */
Windows.UI.Input.GestureSettings.manipulationTranslateInertia;
/** @const {number} */
Windows.UI.Input.GestureSettings.manipulationRotateInertia;
/** @const {number} */
Windows.UI.Input.GestureSettings.manipulationScaleInertia;
/** @const {number} */
Windows.UI.Input.GestureSettings.crossSlide;
/** @const {number} */
Windows.UI.Input.GestureSettings.manipulationMultipleFingerPanning;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.HoldingEventArgs = function() {};
 /** @type {Windows.UI.Input.HoldingState} */
Windows.UI.Input.HoldingEventArgs.prototype.holdingState;
 /** @type {Windows.Devices.Input.PointerDeviceType} */
Windows.UI.Input.HoldingEventArgs.prototype.pointerDeviceType;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.HoldingEventArgs.prototype.position;

/** @const */
Windows.UI.Input.HoldingState = {};
/** @const {number} */
Windows.UI.Input.HoldingState.started;
/** @const {number} */
Windows.UI.Input.HoldingState.completed;
/** @const {number} */
Windows.UI.Input.HoldingState.canceled;
/** @const */
Windows.UI.Input.Inking = {};
/** @const */
Windows.UI.Input.Inking.Core = {};

/**
 * @constructor
 * @struct
 * Creates a new InkDrawingAttributes object that is used to specify InkStroke attributes.
 */
Windows.UI.Input.Inking.InkDrawingAttributes = function() {};
 /** @type {!Windows.UI.Color} */
Windows.UI.Input.Inking.InkDrawingAttributes.prototype.color;
 /** @type {boolean} */
Windows.UI.Input.Inking.InkDrawingAttributes.prototype.drawAsHighlighter;
 /** @type {boolean} */
Windows.UI.Input.Inking.InkDrawingAttributes.prototype.fitToCurve;
 /** @type {boolean} */
Windows.UI.Input.Inking.InkDrawingAttributes.prototype.ignorePressure;
 /** @type {Windows.UI.Input.Inking.PenTipShape} */
Windows.UI.Input.Inking.InkDrawingAttributes.prototype.penTip;
 /** @type {!Windows.Foundation.Numerics.Matrix3x2} */
Windows.UI.Input.Inking.InkDrawingAttributes.prototype.penTipTransform;
 /** @type {!Windows.Foundation.Size} */
Windows.UI.Input.Inking.InkDrawingAttributes.prototype.size;

/**
 * @constructor
 * @struct
 * Creates a new InkManager object that is used to manage InkStroke objects.
 */
Windows.UI.Input.Inking.InkManager = function() {};
 /** @type {!Windows.Foundation.Rect} */
Windows.UI.Input.Inking.InkManager.prototype.boundingRect;
 /** @type {Windows.UI.Input.Inking.InkManipulationMode} */
Windows.UI.Input.Inking.InkManager.prototype.mode;

/**
 * Adds one or more InkStroke objects to the collection managed by the InkManager .
 * @param {!Windows.UI.Input.Inking.InkStroke} stroke The ink stroke to be added.
 * @return {void}
 */
Windows.UI.Input.Inking.InkManager.prototype.addStroke = function(stroke) {};

/**
 * Identifies whether content on the clipboard can be added to the InkStroke collection that is managed by the InkManager .
 * @return {boolean} True if content can be pasted from the clipboard; otherwise, false.
 */
Windows.UI.Input.Inking.InkManager.prototype.canPasteFromClipboard = function() {};

/**
 * Copies the selected InkStroke objects (from the InkStroke collection managed by the InkManager ) to the clipboard in Ink Serialized Format (ISF) format.
 * @return {void}
 */
Windows.UI.Input.Inking.InkManager.prototype.copySelectedToClipboard = function() {};

/**
 * Deletes the selected InkStroke objects from the InkStroke collection managed by the InkManager .
 * @return {!Windows.Foundation.Rect} The bounding rectangle of the selected ink strokes, or the invalidated rectangle (0, 0, 0, 0) if no strokes were removed (no selected strokes).
 */
Windows.UI.Input.Inking.InkManager.prototype.deleteSelected = function() {};

/**
 * Retrieves the collection of words returned by handwriting recognition.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Input.Inking.InkRecognitionResult>} The words returned by the handwriting recognizer as a collection of InkRecognitionResult objects.
 */
Windows.UI.Input.Inking.InkManager.prototype.getRecognitionResults = function() {};

/**
 * Gets the collection of installed handwriting recognizers.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Input.Inking.InkRecognizer>} The installed handwriting recognizers as a collection of InkRecognizer objects.
 */
Windows.UI.Input.Inking.InkManager.prototype.getRecognizers = function() {};

/**
 * Retrieves all ink strokes in the collection managed by the InkManager .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Input.Inking.InkStroke>} The ink strokes managed by the InkManager as a collection of InkStroke objects.
 */
Windows.UI.Input.Inking.InkManager.prototype.getStrokes = function() {};

/**
 * Asynchronously loads all InkStroke objects from the specified stream to the InkStroke collection that is managed by the InkManager .
 * @param {!Windows.Storage.Streams.IInputStream} inputStream The stream that contains the stroke collection. An IRandomAccessStream (requires IOutputStream ) object can be specified instead.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncActionWithProgress<number>>} The status of the asynchronous operation as the number of bytes fetched. For more information, see ReadAsync method.
 */
Windows.UI.Input.Inking.InkManager.prototype.loadAsync = function(inputStream) {};

/**
 * Moves the selected strokes. All affected strokes are re-rendered.
 * @param {!Windows.Foundation.Point} translation The destination screen coordinates for the upper-left corner of the bounding rectangle of the selected strokes.
 * @return {!Windows.Foundation.Rect} The bounding rectangle of the selected ink strokes.
 */
Windows.UI.Input.Inking.InkManager.prototype.moveSelected = function(translation) {};

/**
 * Adds the InkStroke content from the clipboard to the InkStroke collection that is managed by the InkManager and renders the new strokes..
 * @param {!Windows.Foundation.Point} position The screen coordinates for the upper-left corner of the bounding rectangle of the clipboard content.
 * @return {!Windows.Foundation.Rect} The invalidated bounding rectangle of the InkStroke collection.
 */
Windows.UI.Input.Inking.InkManager.prototype.pasteFromClipboard = function(position) {};

/**
 * Processes information about the position and features of the contact point, like pressure and tilt, on initial down contact. You must call this method before you call ProcessPointerUpdate , and then ProcessPointerUp.
 * @param {!Windows.UI.Input.PointerPoint} pointerPoint Information about the position and features of the contact point.
 * @return {void}
 */
Windows.UI.Input.Inking.InkManager.prototype.processPointerDown = function(pointerPoint) {};

/**
 * Processes information about the position and features of the contact point, like pressure and tilt, on up contact. You must call this method after you call ProcessPointerUpdate .
 * @param {!Windows.UI.Input.PointerPoint} pointerPoint Information about the position and features of the contact point.
 * @return {!Windows.Foundation.Rect} For Inking and Selecting modes, this is the bounding box for the stroke (invalidated rectangle). For Erasing mode, the invalidated rectangle is (0,0,0,0).
 */
Windows.UI.Input.Inking.InkManager.prototype.processPointerUp = function(pointerPoint) {};

/**
 * Processes position and state properties, such as pressure and tilt, for the specified pointer, from the last pointer event up to and including the current pointer event.
 * @param {!Windows.UI.Input.PointerPoint} pointerPoint The input pointer for which updates are to be processed.
 * @return {?} When the current InkManipulationMode is Inking or Selecting, this method returns the Point (screen position in ink space) associated with the last ProcessPointerUpdate of pointerPoint.
 */
Windows.UI.Input.Inking.InkManager.prototype.processPointerUpdate = function(pointerPoint) {};

/**
 * Performs handwriting recognition on one or more InkStroke objects.
 * Performs handwriting recognition on one or more InkStroke objects.
 * @param {Windows.UI.Input.Inking.InkRecognitionTarget|!Windows.UI.Input.Inking.InkStrokeContainer} recognitionTarget_or_strokeCollection One of the values from the InkRecognitionTarget enumeration. / The set of strokes on which recognition is performed.
 * @param {Windows.UI.Input.Inking.InkRecognitionTarget=} recognitionTarget One of the values from the InkRecognitionTarget enumeration.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The results of the recognition as a collection of InkRecognitionResult objects.
 */
Windows.UI.Input.Inking.InkManager.prototype.recognizeAsync = function(recognitionTarget_or_strokeCollection, recognitionTarget) {};

/**
 * Asynchronously saves all InkStroke objects in the InkStroke collection that is managed by the InkManager to the specified stream.
 * @param {!Windows.Storage.Streams.IOutputStream} outputStream The target stream. An IRandomAccessStream (requires IOutputStream ) object can be specified instead.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The size of the saved stream and the status of the asynchronous operation as the number of bytes sent. For more information, see WriteAsync method.
 */
Windows.UI.Input.Inking.InkManager.prototype.saveAsync = function(outputStream) {};

/**
 * Selects all strokes intersected by the new stroke.
 * @param {!Windows.Foundation.Point} from The start of the stroke.
 * @param {!Windows.Foundation.Point} to The end of the stroke.
 * @return {!Windows.Foundation.Rect} The bounding rectangle of the selected ink strokes.
 */
Windows.UI.Input.Inking.InkManager.prototype.selectWithLine = function(from, to) {};

/**
 * Selects all strokes contained entirely within the polyline.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Point>} polyline The points of the polyline.
 * @return {!Windows.Foundation.Rect} The bounding rectangle of the selected ink strokes.
 */
Windows.UI.Input.Inking.InkManager.prototype.selectWithPolyLine = function(polyline) {};

/**
 * Sets the default InkDrawingAttributes for all new InkStroke objects added to the InkStroke collection managed by the InkManager .
 * @param {!Windows.UI.Input.Inking.InkDrawingAttributes} drawingAttributes The default attributes applied to a new ink stroke.
 * @return {void}
 */
Windows.UI.Input.Inking.InkManager.prototype.setDefaultDrawingAttributes = function(drawingAttributes) {};

/**
 * Sets the default InkRecognizer used for handwriting recognition.
 * @param {!Windows.UI.Input.Inking.InkRecognizer} recognizer The InkRecognizer .
 * @return {void}
 */
Windows.UI.Input.Inking.InkManager.prototype.setDefaultRecognizer = function(recognizer) {};

/**
 * Updates the collection of potential text matches from handwriting recognition.
 * @param {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Input.Inking.InkRecognitionResult>} recognitionResults The results returned by recognition, where each InkRecognitionResult object represents one written word.
 * @return {void}
 */
Windows.UI.Input.Inking.InkManager.prototype.updateRecognitionResults = function(recognitionResults) {};

/** @const */
Windows.UI.Input.Inking.InkManipulationMode = {};
/** @const {number} */
Windows.UI.Input.Inking.InkManipulationMode.inking;
/** @const {number} */
Windows.UI.Input.Inking.InkManipulationMode.erasing;
/** @const {number} */
Windows.UI.Input.Inking.InkManipulationMode.selecting;

/**
 * @constructor
 * @struct
 * Creates a new InkPoint object used in the construction of an InkStroke .
 * @param {!Windows.Foundation.Point} position The screen coordinates for the InkPoint object.
 * @param {number} pressure The pressure of the contact on the digitizer surface. The default is 0.5.
 */
Windows.UI.Input.Inking.InkPoint = function(position, pressure) {};
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.Inking.InkPoint.prototype.position;
 /** @type {?} */
Windows.UI.Input.Inking.InkPoint.prototype.pressure;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Inking.InkRecognitionResult = function() {};
 /** @type {!Windows.Foundation.Rect} */
Windows.UI.Input.Inking.InkRecognitionResult.prototype.boundingRect;

/**
 * Retrieves all ink strokes used for handwriting recognition.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Input.Inking.InkStroke>} The ink strokes used for handwriting recognition as a collection of InkStroke objects.
 */
Windows.UI.Input.Inking.InkRecognitionResult.prototype.getStrokes = function() {};

/**
 * Retrieves the collection of strings identified as potential matches for each word returned by handwriting recognition.
 * @return {!Windows.Foundation.Collections.IVectorView<string>} The recognition matches as a collection of String objects. The most likely candidate is topmost in the collection.
 */
Windows.UI.Input.Inking.InkRecognitionResult.prototype.getTextCandidates = function() {};

/** @const */
Windows.UI.Input.Inking.InkRecognitionTarget = {};
/** @const {number} */
Windows.UI.Input.Inking.InkRecognitionTarget.all;
/** @const {number} */
Windows.UI.Input.Inking.InkRecognitionTarget.selected;
/** @const {number} */
Windows.UI.Input.Inking.InkRecognitionTarget.recent;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Inking.InkRecognizer = function() {};
 /** @type {string} */
Windows.UI.Input.Inking.InkRecognizer.prototype.name;

/**
 * @constructor
 * @struct
 * Creates a new InkRecognizerContainer object to manage InkRecognizer objects used for handwriting recognition.
 */
Windows.UI.Input.Inking.InkRecognizerContainer = function() {};

/**
 * Gets the collection of installed handwriting recognizers.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Input.Inking.InkRecognizer>} The installed handwriting recognizers as a collection of InkRecognizer objects.
 */
Windows.UI.Input.Inking.InkRecognizerContainer.prototype.getRecognizers = function() {};

/**
 * Performs handwriting recognition on one or more InkStroke objects.
 * @param {!Windows.UI.Input.Inking.InkStrokeContainer} strokeCollection The set of strokes on which recognition is performed.
 * @param {Windows.UI.Input.Inking.InkRecognitionTarget} recognitionTarget One of the values from the InkRecognitionTarget enumeration.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} The results of the recognition as a collection of InkRecognitionResult objects.
 */
Windows.UI.Input.Inking.InkRecognizerContainer.prototype.recognizeAsync = function(strokeCollection, recognitionTarget) {};

/**
 * Sets the default InkRecognizer used for handwriting recognition.
 * @param {!Windows.UI.Input.Inking.InkRecognizer} recognizer The InkRecognizer .
 * @return {void}
 */
Windows.UI.Input.Inking.InkRecognizerContainer.prototype.setDefaultRecognizer = function(recognizer) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Inking.InkStroke = function() {};
 /** @type {!Windows.Foundation.Rect} */
Windows.UI.Input.Inking.InkStroke.prototype.boundingRect;
 /** @type {!Windows.UI.Input.Inking.InkDrawingAttributes} */
Windows.UI.Input.Inking.InkStroke.prototype.drawingAttributes;
 /** @type {!Windows.Foundation.Numerics.Matrix3x2} */
Windows.UI.Input.Inking.InkStroke.prototype.pointTransform;
 /** @type {boolean} */
Windows.UI.Input.Inking.InkStroke.prototype.recognized;
 /** @type {boolean} */
Windows.UI.Input.Inking.InkStroke.prototype.selected;

/**
 * Copies the InkStroke to another InkManager (or InkStrokeContainer ).
 * @return {!Windows.UI.Input.Inking.InkStroke} The new stroke.
 */
Windows.UI.Input.Inking.InkStroke.prototype.clone = function() {};

/**
 * Gets the collection of InkPoint objects used to construct the InkStroke .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Input.Inking.InkPoint>} The collection of InkPoint objects used to construct the InkStroke .
 */
Windows.UI.Input.Inking.InkStroke.prototype.getInkPoints = function() {};

/**
 * Gets the rendering segments of the stroke.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Input.Inking.InkStrokeRenderingSegment>} The collection of InkStrokeRenderingSegment objects.
 */
Windows.UI.Input.Inking.InkStroke.prototype.getRenderingSegments = function() {};

/**
 * @constructor
 * @struct
 * Creates a new InkStrokeBuilder object that is used to construct InkStroke objects.
 */
Windows.UI.Input.Inking.InkStrokeBuilder = function() {};

/**
 * Adds a new segment to the ink stroke.
 * @param {!Windows.UI.Input.PointerPoint} pointerPoint The end point of the new segment.
 * @return {!Windows.UI.Input.PointerPoint} The previous end point. This end point can be used when rendering the stroke.
 */
Windows.UI.Input.Inking.InkStrokeBuilder.prototype.appendToStroke = function(pointerPoint) {};

/**
 * Starts building the ink stroke.
 * @param {!Windows.UI.Input.PointerPoint} pointerPoint The first point for the stroke.
 * @return {void}
 */
Windows.UI.Input.Inking.InkStrokeBuilder.prototype.beginStroke = function(pointerPoint) {};

/**
 * Creates a stroke from an array of Point coordinates.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Point>} points An array of Point coordinates.
 * @return {!Windows.UI.Input.Inking.InkStroke} The new stroke.
 */
Windows.UI.Input.Inking.InkStrokeBuilder.prototype.createStroke = function(points) {};

/**
 * Creates a stroke from collection of InkPoint objects.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.UI.Input.Inking.InkPoint>} inkPoints The collection of InkPoint objects.
 * @param {!Windows.Foundation.Numerics.Matrix3x2} transform A 2-D transformation matrix.
 * @return {!Windows.UI.Input.Inking.InkStroke} The ink stroke, including the Bzier curve parameters used for final rendering of the stroke.
 */
Windows.UI.Input.Inking.InkStrokeBuilder.prototype.createStrokeFromInkPoints = function(inkPoints, transform) {};

/**
 * Stops building the ink stroke.
 * @param {!Windows.UI.Input.PointerPoint} pointerPoint The last point for the stroke.
 * @return {!Windows.UI.Input.Inking.InkStroke} The stroke built from the points.
 */
Windows.UI.Input.Inking.InkStrokeBuilder.prototype.endStroke = function(pointerPoint) {};

/**
 * Sets the default InkDrawingAttributes for all new ink strokes created after the current stroke.
 * @param {!Windows.UI.Input.Inking.InkDrawingAttributes} drawingAttributes The default attributes.
 * @return {void}
 */
Windows.UI.Input.Inking.InkStrokeBuilder.prototype.setDefaultDrawingAttributes = function(drawingAttributes) {};

/**
 * @constructor
 * @struct
 * Creates a new InkStrokeContainer object that is used to manage InkStroke objects.
 */
Windows.UI.Input.Inking.InkStrokeContainer = function() {};
 /** @type {!Windows.Foundation.Rect} */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.boundingRect;

/**
 * Adds an InkStroke object to the collection managed by the InkStrokeContainer .
 * @param {!Windows.UI.Input.Inking.InkStroke} stroke The ink stroke to be added.
 * @return {void}
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.addStroke = function(stroke) {};

/**
 * Adds one or more ink strokes to the collection managed by the InkStrokeContainer .
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.UI.Input.Inking.InkStroke>} strokes The ink strokes to be added as a collection of InkStroke objects.
 * @return {void}
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.addStrokes = function(strokes) {};

/**
 * Identifies whether content on the clipboard can be added to the InkStroke collection managed by the InkStrokeContainer .
 * @return {boolean} True if content can be pasted from the clipboard; otherwise, false.
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.canPasteFromClipboard = function() {};

/**
 * Deletes all InkStroke objects from the collection managed by the InkStrokeContainer .
 * @return {void}
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.clear = function() {};

/**
 * Copies the selected InkStroke objects (from the InkStroke collection managed by the InkStrokeContainer ) to the clipboard in Ink Serialized Format (ISF) format.
 * @return {void}
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.copySelectedToClipboard = function() {};

/**
 * Deletes the selected InkStroke objects from the InkStroke collection managed by the InkStrokeContainer .
 * @return {!Windows.Foundation.Rect} The bounding rectangle of the selected ink strokes, or the invalidated rectangle (0, 0, 0, 0) if no strokes were removed (no selected strokes).
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.deleteSelected = function() {};

/**
 * Gets the collection of recognition matches previously processed by an InkRecognizer and stored in an InkRecognizerContainer .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Input.Inking.InkRecognitionResult>} The results of the recognition as a collection of InkRecognitionResult objects.
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.getRecognitionResults = function() {};

/**
 * Retrieves all ink strokes in the collection managed by the InkStrokeContainer .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Input.Inking.InkStroke>} The ink strokes managed by the InkStrokeContainer as a collection of InkStroke objects.
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.getStrokes = function() {};

/**
 * Asynchronously loads all InkStroke objects from the specified stream to the InkStroke collection that is managed by the InkStrokeContainer .
 * @param {!Windows.Storage.Streams.IInputStream} inputStream The target stream.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncActionWithProgress<number>>} The status of the asynchronous operation as the number of bytes fetched. For more information, see ReadAsync method.
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.loadAsync = function(inputStream) {};

/**
 * Moves the selected strokes. All affected strokes are re-rendered.
 * @param {!Windows.Foundation.Point} translation The destination screen coordinates for the upper-left corner of the bounding rectangle of the selected strokes.
 * @return {!Windows.Foundation.Rect} The bounding rectangle of the selected ink strokes.
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.moveSelected = function(translation) {};

/**
 * Adds the InkStroke content from the clipboard to the InkStroke collection that is managed by the InkStrokeContainer and renders the new strokes..
 * @param {!Windows.Foundation.Point} position The screen coordinates for the upper-left corner of the bounding rectangle of the clipboard content.
 * @return {!Windows.Foundation.Rect} The invalidated bounding rectangle of the InkStroke collection.
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.pasteFromClipboard = function(position) {};

/**
 * Asynchronously saves all InkStroke objects in the InkStroke collection that is managed by the InkStrokeContainer to the specified stream.
 * @param {!Windows.Storage.Streams.IOutputStream} outputStream The target stream. An IRandomAccessStream (requires IOutputStream ) object can be specified instead.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The status of the asynchronous operation as the number of bytes sent. For more information, see WriteAsync method.
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.saveAsync = function(outputStream) {};

/**
 * Selects all strokes intersected by the new stroke.
 * @param {!Windows.Foundation.Point} from The start of the line.
 * @param {!Windows.Foundation.Point} to The of the line.
 * @return {!Windows.Foundation.Rect} The bounding rectangle of the selected ink strokes.
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.selectWithLine = function(from, to) {};

/**
 * Selects all strokes contained entirely within the polyline.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Point>} polyline The points of the polyline.
 * @return {!Windows.Foundation.Rect} The bounding rectangle of the selected ink strokes.
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.selectWithPolyLine = function(polyline) {};

/**
 * Updates the collection of recognition matches previously processed by an InkRecognizer and stored in an InkRecognizerContainer .
 * @param {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Input.Inking.InkRecognitionResult>} recognitionResults The updated collection of InkRecognitionResult objects.
 * @return {void}
 */
Windows.UI.Input.Inking.InkStrokeContainer.prototype.updateRecognitionResults = function(recognitionResults) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Inking.InkStrokeRenderingSegment = function() {};
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.Inking.InkStrokeRenderingSegment.prototype.bezierControlPoint1;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.Inking.InkStrokeRenderingSegment.prototype.bezierControlPoint2;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.Inking.InkStrokeRenderingSegment.prototype.position;
 /** @type {number} */
Windows.UI.Input.Inking.InkStrokeRenderingSegment.prototype.pressure;
 /** @type {number} */
Windows.UI.Input.Inking.InkStrokeRenderingSegment.prototype.tiltX;
 /** @type {number} */
Windows.UI.Input.Inking.InkStrokeRenderingSegment.prototype.tiltY;
 /** @type {number} */
Windows.UI.Input.Inking.InkStrokeRenderingSegment.prototype.twist;

/** @const */
Windows.UI.Input.Inking.PenTipShape = {};
/** @const {number} */
Windows.UI.Input.Inking.PenTipShape.circle;
/** @const {number} */
Windows.UI.Input.Inking.PenTipShape.rectangle;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.KeyboardDeliveryInterceptor = function() {};
 /** @type {boolean} */
Windows.UI.Input.KeyboardDeliveryInterceptor.prototype.isInterceptionEnabledWhenInForeground;
 /** @type {function(?): void} */
Windows.UI.Input.KeyboardDeliveryInterceptor.prototype.onkeydown;
 /** @type {function(?): void} */
Windows.UI.Input.KeyboardDeliveryInterceptor.prototype.onkeyup;

/**
 * Retrieves a KeyboardDeliveryInterceptor object associated with the current app view.
 * @return {!Windows.UI.Input.KeyboardDeliveryInterceptor} The KeyboardDeliveryInterceptor object associated with the current app.
 */
Windows.UI.Input.KeyboardDeliveryInterceptor.getForCurrentView = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.Input.KeyboardDeliveryInterceptor.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.Input.KeyboardDeliveryInterceptor.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.ManipulationCompletedEventArgs = function() {};
 /** @type {!Windows.UI.Input.ManipulationDelta} */
Windows.UI.Input.ManipulationCompletedEventArgs.prototype.cumulative;
 /** @type {Windows.Devices.Input.PointerDeviceType} */
Windows.UI.Input.ManipulationCompletedEventArgs.prototype.pointerDeviceType;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.ManipulationCompletedEventArgs.prototype.position;
 /** @type {!Windows.UI.Input.ManipulationVelocities} */
Windows.UI.Input.ManipulationCompletedEventArgs.prototype.velocities;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.ManipulationInertiaStartingEventArgs = function() {};
 /** @type {!Windows.UI.Input.ManipulationDelta} */
Windows.UI.Input.ManipulationInertiaStartingEventArgs.prototype.cumulative;
 /** @type {!Windows.UI.Input.ManipulationDelta} */
Windows.UI.Input.ManipulationInertiaStartingEventArgs.prototype.delta;
 /** @type {Windows.Devices.Input.PointerDeviceType} */
Windows.UI.Input.ManipulationInertiaStartingEventArgs.prototype.pointerDeviceType;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.ManipulationInertiaStartingEventArgs.prototype.position;
 /** @type {!Windows.UI.Input.ManipulationVelocities} */
Windows.UI.Input.ManipulationInertiaStartingEventArgs.prototype.velocities;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.ManipulationStartedEventArgs = function() {};
 /** @type {!Windows.UI.Input.ManipulationDelta} */
Windows.UI.Input.ManipulationStartedEventArgs.prototype.cumulative;
 /** @type {Windows.Devices.Input.PointerDeviceType} */
Windows.UI.Input.ManipulationStartedEventArgs.prototype.pointerDeviceType;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.ManipulationStartedEventArgs.prototype.position;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.ManipulationUpdatedEventArgs = function() {};
 /** @type {!Windows.UI.Input.ManipulationDelta} */
Windows.UI.Input.ManipulationUpdatedEventArgs.prototype.cumulative;
 /** @type {!Windows.UI.Input.ManipulationDelta} */
Windows.UI.Input.ManipulationUpdatedEventArgs.prototype.delta;
 /** @type {Windows.Devices.Input.PointerDeviceType} */
Windows.UI.Input.ManipulationUpdatedEventArgs.prototype.pointerDeviceType;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.ManipulationUpdatedEventArgs.prototype.position;
 /** @type {!Windows.UI.Input.ManipulationVelocities} */
Windows.UI.Input.ManipulationUpdatedEventArgs.prototype.velocities;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.MouseWheelParameters = function() {};
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.MouseWheelParameters.prototype.charTranslation;
 /** @type {number} */
Windows.UI.Input.MouseWheelParameters.prototype.deltaRotationAngle;
 /** @type {number} */
Windows.UI.Input.MouseWheelParameters.prototype.deltaScale;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.MouseWheelParameters.prototype.pageTranslation;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.PointerPoint = function() {};
 /** @type {number} */
Windows.UI.Input.PointerPoint.prototype.frameId;
 /** @type {boolean} */
Windows.UI.Input.PointerPoint.prototype.isInContact;
 /** @type {!Windows.Devices.Input.PointerDevice} */
Windows.UI.Input.PointerPoint.prototype.pointerDevice;
 /** @type {number} */
Windows.UI.Input.PointerPoint.prototype.pointerId;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.PointerPoint.prototype.position;
 /** @type {!Windows.UI.Input.PointerPointProperties} */
Windows.UI.Input.PointerPoint.prototype.properties;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.PointerPoint.prototype.rawPosition;
 /** @type {number} */
Windows.UI.Input.PointerPoint.prototype.timestamp;

/**
 * Retrieves position and state information for the specified pointer.
 * Retrieves the transformed information for the specified pointer.
 * @param {number} pointerId The ID of the pointer.
 * @param {!Windows.UI.Input.IPointerPointTransform=} transform The transform to apply to the pointer.
 * @return {!Windows.UI.Input.PointerPoint} The pointer property values.
 */
Windows.UI.Input.PointerPoint.getCurrentPoint = function(pointerId, transform) {};

/**
 * Retrieves the transformed position and state information for the specified pointer, from the last pointer event up to and including the current pointer event.
 * Retrieves position and state information for the specified pointer, from the last pointer event up to and including the current pointer event.
 * @param {number} pointerId The ID of the pointer.
 * @param {!Windows.UI.Input.IPointerPointTransform=} transform The transform to apply to the pointer.
 * @return {!Windows.Foundation.Collections.IVector<!Windows.UI.Input.PointerPoint>} The transformed pointer properties (current and historic).
 */
Windows.UI.Input.PointerPoint.getIntermediatePoints = function(pointerId, transform) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.PointerPointProperties = function() {};
 /** @type {!Windows.Foundation.Rect} */
Windows.UI.Input.PointerPointProperties.prototype.contactRect;
 /** @type {!Windows.Foundation.Rect} */
Windows.UI.Input.PointerPointProperties.prototype.contactRectRaw;
 /** @type {boolean} */
Windows.UI.Input.PointerPointProperties.prototype.isBarrelButtonPressed;
 /** @type {boolean} */
Windows.UI.Input.PointerPointProperties.prototype.isCanceled;
 /** @type {boolean} */
Windows.UI.Input.PointerPointProperties.prototype.isEraser;
 /** @type {boolean} */
Windows.UI.Input.PointerPointProperties.prototype.isHorizontalMouseWheel;
 /** @type {boolean} */
Windows.UI.Input.PointerPointProperties.prototype.isInRange;
 /** @type {boolean} */
Windows.UI.Input.PointerPointProperties.prototype.isInverted;
 /** @type {boolean} */
Windows.UI.Input.PointerPointProperties.prototype.isLeftButtonPressed;
 /** @type {boolean} */
Windows.UI.Input.PointerPointProperties.prototype.isMiddleButtonPressed;
 /** @type {boolean} */
Windows.UI.Input.PointerPointProperties.prototype.isPrimary;
 /** @type {boolean} */
Windows.UI.Input.PointerPointProperties.prototype.isRightButtonPressed;
 /** @type {boolean} */
Windows.UI.Input.PointerPointProperties.prototype.isXButton1Pressed;
 /** @type {boolean} */
Windows.UI.Input.PointerPointProperties.prototype.isXButton2Pressed;
 /** @type {number} */
Windows.UI.Input.PointerPointProperties.prototype.mouseWheelDelta;
 /** @type {number} */
Windows.UI.Input.PointerPointProperties.prototype.orientation;
 /** @type {Windows.UI.Input.PointerUpdateKind} */
Windows.UI.Input.PointerPointProperties.prototype.pointerUpdateKind;
 /** @type {number} */
Windows.UI.Input.PointerPointProperties.prototype.pressure;
 /** @type {boolean} */
Windows.UI.Input.PointerPointProperties.prototype.touchConfidence;
 /** @type {number} */
Windows.UI.Input.PointerPointProperties.prototype.twist;
 /** @type {number} */
Windows.UI.Input.PointerPointProperties.prototype.xtilt;
 /** @type {number} */
Windows.UI.Input.PointerPointProperties.prototype.ytilt;
 /** @type {?} */
Windows.UI.Input.PointerPointProperties.prototype.zdistance;

/**
 * Gets the Human Interface Device (HID) usage value of the raw input.
 * @param {number} usagePage The HID usage page of the pointer device.
 * @param {number} usageId Indicates a usage in a usage page.
 * @return {number} The extended usage of the raw input pointer.
 */
Windows.UI.Input.PointerPointProperties.prototype.getUsageValue = function(usagePage, usageId) {};

/**
 * Gets a value that indicates whether the input data from the pointer device contains the specified Human Interface Device (HID) usage information.
 * @param {number} usagePage The HID usage page of the pointer device.
 * @param {number} usageId Indicates a usage in a usage page.
 * @return {boolean} True if the input data includes usage information; otherwise false.
 */
Windows.UI.Input.PointerPointProperties.prototype.hasUsage = function(usagePage, usageId) {};

/** @const */
Windows.UI.Input.PointerUpdateKind = {};
/** @const {number} */
Windows.UI.Input.PointerUpdateKind.other;
/** @const {number} */
Windows.UI.Input.PointerUpdateKind.leftButtonPressed;
/** @const {number} */
Windows.UI.Input.PointerUpdateKind.leftButtonReleased;
/** @const {number} */
Windows.UI.Input.PointerUpdateKind.rightButtonPressed;
/** @const {number} */
Windows.UI.Input.PointerUpdateKind.rightButtonReleased;
/** @const {number} */
Windows.UI.Input.PointerUpdateKind.middleButtonPressed;
/** @const {number} */
Windows.UI.Input.PointerUpdateKind.middleButtonReleased;
/** @const {number} */
Windows.UI.Input.PointerUpdateKind.xbutton1Pressed;
/** @const {number} */
Windows.UI.Input.PointerUpdateKind.xbutton1Released;
/** @const {number} */
Windows.UI.Input.PointerUpdateKind.xbutton2Pressed;
/** @const {number} */
Windows.UI.Input.PointerUpdateKind.xbutton2Released;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.PointerVisualizationSettings = function() {};
 /** @type {boolean} */
Windows.UI.Input.PointerVisualizationSettings.prototype.isBarrelButtonFeedbackEnabled;
 /** @type {boolean} */
Windows.UI.Input.PointerVisualizationSettings.prototype.isContactFeedbackEnabled;

/**
 * Gets a PointerVisualizationSettings object associated with the current app.
 * @return {!Windows.UI.Input.PointerVisualizationSettings} The PointerVisualizationSettings object associated with the current app.
 */
Windows.UI.Input.PointerVisualizationSettings.getForCurrentView = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.RightTappedEventArgs = function() {};
 /** @type {Windows.Devices.Input.PointerDeviceType} */
Windows.UI.Input.RightTappedEventArgs.prototype.pointerDeviceType;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.RightTappedEventArgs.prototype.position;
/** @const */
Windows.UI.Input.Spatial = {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialGestureRecognizer = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.addEventListener;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.cancelPendingGestures;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.captureInteraction;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.gestureSettings;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.onholdcanceled;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.onholdcompleted;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.onholdstarted;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.onmanipulationcanceled;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.onmanipulationcompleted;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.onmanipulationstarted;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.onmanipulationupdated;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.onnavigationcanceled;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.onnavigationcompleted;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.onnavigationstarted;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.onnavigationupdated;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.onrecognitionended;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.onrecognitionstarted;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.ontapped;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.removeEventListener;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureRecognizer.prototype.trySetGestureSettings;
/** @const */
Windows.UI.Input.Spatial.SpatialGestureSettings = {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureSettings.none;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureSettings.tap;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureSettings.doubleTap;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureSettings.hold;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureSettings.manipulationTranslate;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureSettings.navigationX;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureSettings.navigationY;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureSettings.navigationZ;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureSettings.navigationRailsX;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureSettings.navigationRailsY;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialGestureSettings.navigationRailsZ;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialHoldCanceledEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialHoldCanceledEventArgs.prototype.interactionSourceKind;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialHoldCompletedEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialHoldCompletedEventArgs.prototype.interactionSourceKind;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialHoldStartedEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialHoldStartedEventArgs.prototype.interactionSourceKind;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialHoldStartedEventArgs.prototype.tryGetPointerPose;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialInteraction = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteraction.prototype.sourceState;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialInteractionDetectedEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionDetectedEventArgs.prototype.interaction;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionDetectedEventArgs.prototype.interactionSourceKind;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionDetectedEventArgs.prototype.tryGetPointerPose;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialInteractionManager = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionManager.getForCurrentView;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionManager.prototype.addEventListener;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionManager.prototype.getDetectedSourcesAtTimestamp;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionManager.prototype.oninteractiondetected;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionManager.prototype.onsourcedetected;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionManager.prototype.onsourcelost;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionManager.prototype.onsourcepressed;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionManager.prototype.onsourcereleased;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionManager.prototype.onsourceupdated;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionManager.prototype.removeEventListener;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialInteractionSource = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSource.prototype.id;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSource.prototype.kind;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialInteractionSourceEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceEventArgs.prototype.state;
/** @const */
Windows.UI.Input.Spatial.SpatialInteractionSourceKind = {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceKind.other;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceKind.hand;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceKind.voice;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceKind.controller;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialInteractionSourceLocation = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceLocation.prototype.position;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceLocation.prototype.velocity;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialInteractionSourceProperties = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceProperties.prototype.sourceLossRisk;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceProperties.prototype.tryGetLocation;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceProperties.prototype.tryGetSourceLossMitigationDirection;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialInteractionSourceState = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceState.prototype.isPressed;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceState.prototype.properties;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceState.prototype.source;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceState.prototype.timestamp;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialInteractionSourceState.prototype.tryGetPointerPose;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialManipulationCanceledEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialManipulationCanceledEventArgs.prototype.interactionSourceKind;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialManipulationCompletedEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialManipulationCompletedEventArgs.prototype.interactionSourceKind;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialManipulationCompletedEventArgs.prototype.tryGetCumulativeDelta;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialManipulationDelta = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialManipulationDelta.prototype.translation;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialManipulationStartedEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialManipulationStartedEventArgs.prototype.interactionSourceKind;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialManipulationStartedEventArgs.prototype.tryGetPointerPose;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialManipulationUpdatedEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialManipulationUpdatedEventArgs.prototype.interactionSourceKind;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialManipulationUpdatedEventArgs.prototype.tryGetCumulativeDelta;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialNavigationCanceledEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialNavigationCanceledEventArgs.prototype.interactionSourceKind;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialNavigationCompletedEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialNavigationCompletedEventArgs.prototype.interactionSourceKind;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialNavigationCompletedEventArgs.prototype.normalizedOffset;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs.prototype.interactionSourceKind;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs.prototype.isNavigatingX;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs.prototype.isNavigatingY;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs.prototype.isNavigatingZ;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs.prototype.tryGetPointerPose;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialNavigationUpdatedEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialNavigationUpdatedEventArgs.prototype.interactionSourceKind;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialNavigationUpdatedEventArgs.prototype.normalizedOffset;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialPointerPose = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialPointerPose.tryGetAtTimestamp;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialPointerPose.prototype.head;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialPointerPose.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialRecognitionEndedEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialRecognitionEndedEventArgs.prototype.interactionSourceKind;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialRecognitionStartedEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialRecognitionStartedEventArgs.prototype.interactionSourceKind;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialRecognitionStartedEventArgs.prototype.isGesturePossible;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialRecognitionStartedEventArgs.prototype.tryGetPointerPose;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.Spatial.SpatialTappedEventArgs = function() {};
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialTappedEventArgs.prototype.interactionSourceKind;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialTappedEventArgs.prototype.tapCount;
 /** @type {?} */
Windows.UI.Input.Spatial.SpatialTappedEventArgs.prototype.tryGetPointerPose;
/**
 * @constructor
 * @struct
 */
Windows.UI.Input.TappedEventArgs = function() {};
 /** @type {Windows.Devices.Input.PointerDeviceType} */
Windows.UI.Input.TappedEventArgs.prototype.pointerDeviceType;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.TappedEventArgs.prototype.position;
 /** @type {number} */
Windows.UI.Input.TappedEventArgs.prototype.tapCount;
/**
 * @record
 * @struct
 */
Windows.UI.Input.CrossSlideThresholds = function() {};
 /** @type {number} */
Windows.UI.Input.CrossSlideThresholds.prototype.rearrangeStart;
 /** @type {number} */
Windows.UI.Input.CrossSlideThresholds.prototype.selectionStart;
 /** @type {number} */
Windows.UI.Input.CrossSlideThresholds.prototype.speedBumpEnd;
 /** @type {number} */
Windows.UI.Input.CrossSlideThresholds.prototype.speedBumpStart;
/**
 * @record
 * @struct
 */
Windows.UI.Input.ManipulationDelta = function() {};
 /** @type {number} */
Windows.UI.Input.ManipulationDelta.prototype.expansion;
 /** @type {number} */
Windows.UI.Input.ManipulationDelta.prototype.rotation;
 /** @type {number} */
Windows.UI.Input.ManipulationDelta.prototype.scale;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.ManipulationDelta.prototype.translation;
/**
 * @record
 * @struct
 */
Windows.UI.Input.ManipulationVelocities = function() {};
 /** @type {number} */
Windows.UI.Input.ManipulationVelocities.prototype.angular;
 /** @type {number} */
Windows.UI.Input.ManipulationVelocities.prototype.expansion;
 /** @type {!Windows.Foundation.Point} */
Windows.UI.Input.ManipulationVelocities.prototype.linear;
/**
 * @record
 * @struct
 */
Windows.UI.Input.IPointerPointTransform = function() {};
 /** @type {!Windows.UI.Input.IPointerPointTransform} */
Windows.UI.Input.IPointerPointTransform.prototype.inverse;

/**
 * Transforms the specified bounding rectangle.
 * @param {!Windows.Foundation.Rect} rect The bounding rectangle to transform.
 * @return {!Windows.Foundation.Rect} The smallest, axis-aligned bounding box that encloses rect after the transformation. (An axis-aligned bounding box is one which has all sides parallel to the coordinate axes.)
 */
Windows.UI.Input.IPointerPointTransform.prototype.transformBounds = function(rect) {};

/**
 * Attempts to perform the transformation on the specified input point.
 * @param {!Windows.Foundation.Point} inPoint The original input point.
 * @return {{outPoint: !Windows.Foundation.Point, returnValue: boolean}}
 */
Windows.UI.Input.IPointerPointTransform.prototype.tryTransform = function(inPoint) {};
/** @const */
Windows.UI.Notifications = {};

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the BadgeNotification .
 * @param {!Windows.Data.Xml.Dom.XmlDocument} content The XML content that defines the badge update.
 */
Windows.UI.Notifications.BadgeNotification = function(content) {};
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.UI.Notifications.BadgeNotification.prototype.content;
 /** @type {!Date} */
Windows.UI.Notifications.BadgeNotification.prototype.expirationTime;

/** @const */
Windows.UI.Notifications.BadgeTemplateType = {};
/** @const {number} */
Windows.UI.Notifications.BadgeTemplateType.badgeGlyph;
/** @const {number} */
Windows.UI.Notifications.BadgeTemplateType.badgeNumber;
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.BadgeUpdateManager = function() {};

/**
 * Creates and initializes a new instance of the BadgeUpdater , which lets you change the appearance or content of the badge on the calling app's tile.
 * Creates and initializes a new instance of the BadgeUpdater for a specified app tile's badge, usually the tile of another app in the package. The BadgeUpdater lets you change the appearance or content of that badge.
 * @param {string=} applicationId The unique ID of the tile whose badge you want to update.
 * @return {!Windows.UI.Notifications.BadgeUpdater} The object you will use to send changes to the app tile's badge. / The object you will use to send changes to the application tile's badge.
 */
Windows.UI.Notifications.BadgeUpdateManager.createBadgeUpdaterForApplication = function(applicationId) {};

/**
 * Creates and initializes a new instance of the BadgeUpdater , which enables you to change the appearance or content of a badge on a secondary tile . The tile can belong to the calling app or any other app in the same package.
 * @param {string} tileId The unique ID of the tile.
 * @return {!Windows.UI.Notifications.BadgeUpdater} The object you will use to send badge updates to the tile identified by tileID.
 */
Windows.UI.Notifications.BadgeUpdateManager.createBadgeUpdaterForSecondaryTile = function(tileId) {};

/**
 * Gets the XML content of one of the predefined badge templates so that you can customize it for a badge update.
 * @param {Windows.UI.Notifications.BadgeTemplateType} type The type of badge template, either a glyph or a number.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The object that contains the template XML.
 */
Windows.UI.Notifications.BadgeUpdateManager.getTemplateContent = function(type) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.BadgeUpdater = function() {};

/**
 * Removes the badge from the tile that the updater is bound to.
 * @return {void}
 */
Windows.UI.Notifications.BadgeUpdater.prototype.clear = function() {};

/**
 * Begins a series of timed updates for the badge from a web resource that the updater is bound to. Updates begin at a specified time. Note that only web resources (http/https) are allowed in a periodic update.
 * Begins a series of timed updates for the badge from a web resource that the updater is bound to, beginning immediately. Note that only web resources (http/https) are allowed in a periodic update.
 * @param {!Windows.Foundation.Uri} badgeContent The URI from which the XML content of the badge update will be retrieved.
 * @param {!Date|Windows.UI.Notifications.PeriodicUpdateRecurrence} startTime_or_requestedInterval The time at which the URI should first be polled for new badge content. / The frequency with which the URI is polled for new badge content.
 * @param {Windows.UI.Notifications.PeriodicUpdateRecurrence=} requestedInterval The frequency with which the URI is polled for new badge content, following the initial update at startTime.
 * @return {void}
 */
Windows.UI.Notifications.BadgeUpdater.prototype.startPeriodicUpdate = function(badgeContent, startTime_or_requestedInterval, requestedInterval) {};

/**
 * Cancels the current series of timed updates for the badge that the updater is bound to.
 * @return {void}
 */
Windows.UI.Notifications.BadgeUpdater.prototype.stopPeriodicUpdate = function() {};

/**
 * Applies a change to the badge's glyph or number.
 * @param {!Windows.UI.Notifications.BadgeNotification} notification The object that supplies the new XML definition for the badge.
 * @return {void}
 */
Windows.UI.Notifications.BadgeUpdater.prototype.update = function(notification) {};

/** @const */
Windows.UI.Notifications.NotificationSetting = {};
/** @const {number} */
Windows.UI.Notifications.NotificationSetting.enabled;
/** @const {number} */
Windows.UI.Notifications.NotificationSetting.disabledForApplication;
/** @const {number} */
Windows.UI.Notifications.NotificationSetting.disabledForUser;
/** @const {number} */
Windows.UI.Notifications.NotificationSetting.disabledByGroupPolicy;
/** @const {number} */
Windows.UI.Notifications.NotificationSetting.disabledByManifest;

/** @const */
Windows.UI.Notifications.PeriodicUpdateRecurrence = {};
/** @const {number} */
Windows.UI.Notifications.PeriodicUpdateRecurrence.halfHour;
/** @const {number} */
Windows.UI.Notifications.PeriodicUpdateRecurrence.hour;
/** @const {number} */
Windows.UI.Notifications.PeriodicUpdateRecurrence.sixHours;
/** @const {number} */
Windows.UI.Notifications.PeriodicUpdateRecurrence.twelveHours;
/** @const {number} */
Windows.UI.Notifications.PeriodicUpdateRecurrence.daily;

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the ScheduledTileNotification object for use with a TileUpdater .
 * @param {!Windows.Data.Xml.Dom.XmlDocument} content The object that provides the content for the tile notification.
 * @param {!Date} deliveryTime The time at which the tile should be updated with the notification information.
 */
Windows.UI.Notifications.ScheduledTileNotification = function(content, deliveryTime) {};
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.UI.Notifications.ScheduledTileNotification.prototype.content;
 /** @type {!Date} */
Windows.UI.Notifications.ScheduledTileNotification.prototype.deliveryTime;
 /** @type {!Date} */
Windows.UI.Notifications.ScheduledTileNotification.prototype.expirationTime;
 /** @type {string} */
Windows.UI.Notifications.ScheduledTileNotification.prototype.id;
 /** @type {string} */
Windows.UI.Notifications.ScheduledTileNotification.prototype.tag;

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of a recurring ScheduledToastNotification .
 * Creates and initializes a new instance of a ScheduledToastNotification that will be displayed only once.
 * @param {!Windows.Data.Xml.Dom.XmlDocument} content The XML that defines the toast notification content.
 * @param {!Date} deliveryTime The date and time that Windows should first display the toast notification. You must call AddToSchedule before this time. / The date and time that Windows should display the toast notification. You must call AddToSchedule before this time.
 * @param {number=} snoozeInterval The amount of time between occurrences of the notification. To be valid, this value must be no less than 60 seconds and no more than 60 minutes.
 * @param {number=} maximumSnoozeCount The maximum number of times to display this notification. Valid values range from 1 to 5.
 */
Windows.UI.Notifications.ScheduledToastNotification = function(content, deliveryTime, snoozeInterval, maximumSnoozeCount) {};
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.UI.Notifications.ScheduledToastNotification.prototype.content;
 /** @type {!Date} */
Windows.UI.Notifications.ScheduledToastNotification.prototype.deliveryTime;
 /** @type {string} */
Windows.UI.Notifications.ScheduledToastNotification.prototype.group;
 /** @type {string} */
Windows.UI.Notifications.ScheduledToastNotification.prototype.id;
 /** @type {number} */
Windows.UI.Notifications.ScheduledToastNotification.prototype.maximumSnoozeCount;
 /** @type {number} */
Windows.UI.Notifications.ScheduledToastNotification.prototype.snoozeInterval;
 /** @type {boolean} */
Windows.UI.Notifications.ScheduledToastNotification.prototype.suppressPopup;
 /** @type {string} */
Windows.UI.Notifications.ScheduledToastNotification.prototype.tag;
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.TileFlyoutNotification = function() {};
 /** @type {?} */
Windows.UI.Notifications.TileFlyoutNotification.prototype.content;
 /** @type {?} */
Windows.UI.Notifications.TileFlyoutNotification.prototype.expirationTime;
/** @const */
Windows.UI.Notifications.TileFlyoutTemplateType = {};
 /** @type {?} */
Windows.UI.Notifications.TileFlyoutTemplateType.tileFlyoutTemplate01;
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.TileFlyoutUpdateManager = function() {};
 /** @type {?} */
Windows.UI.Notifications.TileFlyoutUpdateManager.createTileFlyoutUpdaterForApplication;
 /** @type {?} */
Windows.UI.Notifications.TileFlyoutUpdateManager.createTileFlyoutUpdaterForSecondaryTile;
 /** @type {?} */
Windows.UI.Notifications.TileFlyoutUpdateManager.getTemplateContent;
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.TileFlyoutUpdater = function() {};
 /** @type {?} */
Windows.UI.Notifications.TileFlyoutUpdater.prototype.clear;
 /** @type {?} */
Windows.UI.Notifications.TileFlyoutUpdater.prototype.setting;
 /** @type {?} */
Windows.UI.Notifications.TileFlyoutUpdater.prototype.startPeriodicUpdate;
 /** @type {?} */
Windows.UI.Notifications.TileFlyoutUpdater.prototype.stopPeriodicUpdate;
 /** @type {?} */
Windows.UI.Notifications.TileFlyoutUpdater.prototype.update;

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the TileNotification object for use with a TileUpdater .
 * @param {!Windows.Data.Xml.Dom.XmlDocument} content The object that provides the content for the tile notification.
 */
Windows.UI.Notifications.TileNotification = function(content) {};
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.UI.Notifications.TileNotification.prototype.content;
 /** @type {!Date} */
Windows.UI.Notifications.TileNotification.prototype.expirationTime;
 /** @type {string} */
Windows.UI.Notifications.TileNotification.prototype.tag;

/** @const */
Windows.UI.Notifications.TileTemplateType = {};
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquareImage;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquareBlock;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquareText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquareText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquareText03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquareText04;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquarePeekImageAndText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquarePeekImageAndText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquarePeekImageAndText03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquarePeekImageAndText04;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideImage;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideImageCollection;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideImageAndText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideImageAndText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideBlockAndText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideBlockAndText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWidePeekImageCollection01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWidePeekImageCollection02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWidePeekImageCollection03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWidePeekImageCollection04;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWidePeekImageCollection05;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWidePeekImageCollection06;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWidePeekImageAndText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWidePeekImageAndText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWidePeekImage01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWidePeekImage02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWidePeekImage03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWidePeekImage04;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWidePeekImage05;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWidePeekImage06;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideSmallImageAndText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideSmallImageAndText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideSmallImageAndText03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideSmallImageAndText04;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideSmallImageAndText05;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideText03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideText04;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideText05;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideText06;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideText07;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideText08;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideText09;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideText10;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWideText11;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare150x150Image;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare150x150Block;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare150x150Text01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare150x150Text02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare150x150Text03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare150x150Text04;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare150x150PeekImageAndText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare150x150PeekImageAndText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare150x150PeekImageAndText03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare150x150PeekImageAndText04;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150Image;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150ImageCollection;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150ImageAndText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150ImageAndText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150BlockAndText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150BlockAndText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150PeekImageCollection01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150PeekImageCollection02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150PeekImageCollection03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150PeekImageCollection04;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150PeekImageCollection05;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150PeekImageCollection06;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150PeekImageAndText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150PeekImageAndText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150PeekImage01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150PeekImage02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150PeekImage03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150PeekImage04;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150PeekImage05;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150PeekImage06;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150SmallImageAndText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150SmallImageAndText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150SmallImageAndText03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150SmallImageAndText04;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150SmallImageAndText05;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150Text01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150Text02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150Text03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150Text04;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150Text05;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150Text06;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150Text07;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150Text08;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150Text09;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150Text10;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150Text11;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310BlockAndText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310BlockAndText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310Image;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310ImageAndText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310ImageAndText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310ImageAndTextOverlay01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310ImageAndTextOverlay02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310ImageAndTextOverlay03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310ImageCollectionAndText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310ImageCollectionAndText02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310ImageCollection;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310SmallImagesAndTextList01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310SmallImagesAndTextList02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310SmallImagesAndTextList03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310SmallImagesAndTextList04;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310Text01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310Text02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310Text03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310Text04;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310Text05;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310Text06;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310Text07;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310Text08;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310TextList01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310TextList02;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310TextList03;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310SmallImageAndText01;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310SmallImagesAndTextList05;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare310x310Text09;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare71x71IconWithBadge;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare150x150IconWithBadge;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileWide310x150IconWithBadgeAndText;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileSquare71x71Image;
/** @const {number} */
Windows.UI.Notifications.TileTemplateType.tileTall150x310Image;
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.TileUpdateManager = function() {};

/**
 * Creates and initializes a new instance of the TileUpdater , which lets you change the appearance of the calling app's tile.
 * Creates and initializes a new instance of the TileUpdater for a tile that belongs to another app in the same package as the calling app. The TileUpdater lets a developer change the appearance of that tile.
 * @param {string=} applicationId The Package Relative Application ID (PRAID) of the tile.
 * @return {!Windows.UI.Notifications.TileUpdater} The object you will use to send changes to the app's tile. / The object you will use to send changes to the tile identified by applicationId.
 */
Windows.UI.Notifications.TileUpdateManager.createTileUpdaterForApplication = function(applicationId) {};

/**
 * Creates and initializes a new instance of the TileUpdater , which enables you to change the appearance of a secondary tile . The tile can belong to the calling app or any other app in the same package.
 * @param {string} tileId A unique ID for the tile.
 * @return {!Windows.UI.Notifications.TileUpdater} The object you will use to send updates to the tile identified by tileID.
 */
Windows.UI.Notifications.TileUpdateManager.createTileUpdaterForSecondaryTile = function(tileId) {};

/**
 * Gets the XML content of one of the predefined tile templates so that you can customize it for a tile update.
 * @param {Windows.UI.Notifications.TileTemplateType} type The name of the template.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The object that contains the XML.
 */
Windows.UI.Notifications.TileUpdateManager.getTemplateContent = function(type) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.TileUpdater = function() {};
 /** @type {Windows.UI.Notifications.NotificationSetting} */
Windows.UI.Notifications.TileUpdater.prototype.setting;

/**
 * Adds a ScheduledTileNotification to the schedule.
 * @param {!Windows.UI.Notifications.ScheduledTileNotification} scheduledTile The scheduled tile update object.
 * @return {void}
 */
Windows.UI.Notifications.TileUpdater.prototype.addToSchedule = function(scheduledTile) {};

/**
 * Removes all updates and causes the tile to display its default content as declared in the app's manifest.
 * @return {void}
 */
Windows.UI.Notifications.TileUpdater.prototype.clear = function() {};

/**
 * Enables the tile to queue up to five notifications. This enables the notification queue on all tile sizes.
 * @param {boolean} enable True to enable queuing; otherwise false.
 * @return {void}
 */
Windows.UI.Notifications.TileUpdater.prototype.enableNotificationQueue = function(enable) {};

/**
 * Enables the tile to queue up to five notifications on the medium tile.
 * @param {boolean} enable True to enable queuing on this tile size; otherwise false.
 * @return {void}
 */
Windows.UI.Notifications.TileUpdater.prototype.enableNotificationQueueForSquare150x150 = function(enable) {};

/**
 * Enables the tile to queue up to five notifications on the large tile.
 * @param {boolean} enable True to enable queuing on this tile size; otherwise false.
 * @return {void}
 */
Windows.UI.Notifications.TileUpdater.prototype.enableNotificationQueueForSquare310x310 = function(enable) {};

/**
 * Enables the tile to queue up to five notifications on the wide tile.
 * @param {boolean} enable True to enable queuing on this tile size; otherwise false.
 * @return {void}
 */
Windows.UI.Notifications.TileUpdater.prototype.enableNotificationQueueForWide310x150 = function(enable) {};

/**
 * Retrieves a list of scheduled updates to the tile.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Notifications.ScheduledTileNotification>} The collection of scheduled updates for this tile.
 */
Windows.UI.Notifications.TileUpdater.prototype.getScheduledTileNotifications = function() {};

/**
 * Removes an upcoming tile update from the schedule.
 * @param {!Windows.UI.Notifications.ScheduledTileNotification} scheduledTile The notification to remove from the schedule.
 * @return {void}
 */
Windows.UI.Notifications.TileUpdater.prototype.removeFromSchedule = function(scheduledTile) {};

/**
 * Begins a series of timed content changes for the tile that the updater is bound to, beginning immediately.
 * Begins a series of timed updates for the tile that the updater is bound to. Update content is retrieved from a specified Uniform Resource Identifier (URI). Updates begin at a specified time.
 * @param {!Windows.Foundation.Uri} tileContent The URI from which the XML content of the tile update will be retrieved.
 * @param {Windows.UI.Notifications.PeriodicUpdateRecurrence|!Date} requestedInterval_or_startTime The frequency with which the URI is polled for new tile content, following the initial update at startTime. / The time at which the URI should first be polled for new tile content.
 * @param {Windows.UI.Notifications.PeriodicUpdateRecurrence=} requestedInterval The frequency with which the URI is polled for new tile content, following the initial update at startTime.
 * @return {void}
 */
Windows.UI.Notifications.TileUpdater.prototype.startPeriodicUpdate = function(tileContent, requestedInterval_or_startTime, requestedInterval) {};

/**
 * Begins a series of timed updates that cycle on the tile that the updater is bound to. Update content is retrieved from an array of specified Uniform Resource Identifiers (URIs), the first update happening immediately and subsequent updates occurring at the periodic interval thereafter.
 * Begins a series of timed updates that cycle on the tile that the updater is bound to. Update content is retrieved from an array of specified Uniform Resource Identifiers (URIs) with updates beginning at a specified time and subsequent updates occurring at the periodic interval thereafter.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Uri>} tileContents An array of up to five URIs from which the XML content of the cycling tile updates will be retrieved. If the array contains more than five URIs, the method will fail.
 * @param {Windows.UI.Notifications.PeriodicUpdateRecurrence|!Date} requestedInterval_or_startTime The frequency with which the URI is polled for new tile content, following the initial update at startTime. / The time at which the initial URI should first be polled for new content.
 * @param {Windows.UI.Notifications.PeriodicUpdateRecurrence=} requestedInterval The frequency with which the URI is polled for new tile content, following the initial update at startTime.
 * @return {void}
 */
Windows.UI.Notifications.TileUpdater.prototype.startPeriodicUpdateBatch = function(tileContents, requestedInterval_or_startTime, requestedInterval) {};

/**
 * Cancels the current series of timed updates for the tile that the updater is bound to.
 * @return {void}
 */
Windows.UI.Notifications.TileUpdater.prototype.stopPeriodicUpdate = function() {};

/**
 * Applies a change in content or appearance to the tile.
 * @param {!Windows.UI.Notifications.TileNotification} notification The object that supplies the new XML definition for the tile's content.
 * @return {void}
 */
Windows.UI.Notifications.TileUpdater.prototype.update = function(notification) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.ToastActivatedEventArgs = function() {};
 /** @type {string} */
Windows.UI.Notifications.ToastActivatedEventArgs.prototype.arguments;

/** @const */
Windows.UI.Notifications.ToastDismissalReason = {};
/** @const {number} */
Windows.UI.Notifications.ToastDismissalReason.userCanceled;
/** @const {number} */
Windows.UI.Notifications.ToastDismissalReason.applicationHidden;
/** @const {number} */
Windows.UI.Notifications.ToastDismissalReason.timedOut;
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.ToastDismissedEventArgs = function() {};
 /** @type {Windows.UI.Notifications.ToastDismissalReason} */
Windows.UI.Notifications.ToastDismissedEventArgs.prototype.reason;
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.ToastFailedEventArgs = function() {};
 /** @type {!Windows.WinRTError} */
Windows.UI.Notifications.ToastFailedEventArgs.prototype.errorCode;

/** @const */
Windows.UI.Notifications.ToastHistoryChangedType = {};
/** @const {number} */
Windows.UI.Notifications.ToastHistoryChangedType.cleared;
/** @const {number} */
Windows.UI.Notifications.ToastHistoryChangedType.removed;
/** @const {number} */
Windows.UI.Notifications.ToastHistoryChangedType.expired;
/** @const {number} */
Windows.UI.Notifications.ToastHistoryChangedType.added;

/**
 * @constructor
 * @struct
 * Creates and initializes a new instance of the ToastNotification .
 * @param {!Windows.Data.Xml.Dom.XmlDocument} content The XML content that defines the toast notification.
 */
Windows.UI.Notifications.ToastNotification = function(content) {};
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.UI.Notifications.ToastNotification.prototype.content;
 /** @type {!Date} */
Windows.UI.Notifications.ToastNotification.prototype.expirationTime;
 /** @type {string} */
Windows.UI.Notifications.ToastNotification.prototype.group;
 /** @type {function(?): void} */
Windows.UI.Notifications.ToastNotification.prototype.onactivated;
 /** @type {function(?): void} */
Windows.UI.Notifications.ToastNotification.prototype.ondismissed;
 /** @type {function(?): void} */
Windows.UI.Notifications.ToastNotification.prototype.onfailed;
 /** @type {boolean} */
Windows.UI.Notifications.ToastNotification.prototype.suppressPopup;
 /** @type {string} */
Windows.UI.Notifications.ToastNotification.prototype.tag;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.Notifications.ToastNotification.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.Notifications.ToastNotification.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.ToastNotificationActionTriggerDetail = function() {};
 /** @type {?} */
Windows.UI.Notifications.ToastNotificationActionTriggerDetail.prototype.argument;
 /** @type {?} */
Windows.UI.Notifications.ToastNotificationActionTriggerDetail.prototype.userInput;
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.ToastNotificationHistory = function() {};

/**
 * Removes all notifications from action center that were sent by another app inside the same app package.
 * Removes all notifications sent by this app from action center.
 * @param {string=} applicationId The ID of the app inside the app package whose notifications are to be deleted.
 * @return {void}
 */
Windows.UI.Notifications.ToastNotificationHistory.prototype.clear = function(applicationId) {};

/**
 * Gets notification history, for a toast with the specified tag label, from action center.
 * Gets notification history, for all notifications sent by this app, from action center.
 * @param {string=} applicationId The tag label for the toast being queried-for.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Notifications.ToastNotification>} A collection of toasts.
 */
Windows.UI.Notifications.ToastNotificationHistory.prototype.getHistory = function(applicationId) {};

/**
 * Removes an individual toast, with the specified tag label, from action center.
 * Removes an individual toast notification from action center, identified by the combination of tag label, group label and app ID.
 * Removes a toast notification from the action using the notification's tag and group labels.
 * @param {string} tag The tag label of the toast notification to be removed.
 * @param {string=} group The group label of the toast notification to be removed.
 * @param {string=} applicationId The app ID of the app that sent the specified toast notification. This app must be part of the same app package as the app making this remove request.
 * @return {void}
 */
Windows.UI.Notifications.ToastNotificationHistory.prototype.remove = function(tag, group, applicationId) {};

/**
 * Removes a group of toast notifications, identified by the specified group label, from action center.
 * Removes a group of toast notifications sent by the another app inside the same app package from action center using the group label.
 * @param {string} group The group label of the toast notifications to be removed.
 * @param {string=} applicationId The app ID of the app within the same app package of the calling app.
 * @return {void}
 */
Windows.UI.Notifications.ToastNotificationHistory.prototype.removeGroup = function(group, applicationId) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.ToastNotificationHistoryChangedTriggerDetail = function() {};
 /** @type {Windows.UI.Notifications.ToastHistoryChangedType} */
Windows.UI.Notifications.ToastNotificationHistoryChangedTriggerDetail.prototype.changeType;
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.ToastNotificationManager = function() {};
 /** @type {!Windows.UI.Notifications.ToastNotificationHistory} */
Windows.UI.Notifications.ToastNotificationManager.history;

/**
 * Creates and initializes a new instance of the ToastNotification , bound to the calling application, that lets you raise a toast notification to that app.
 * Creates and initializes a new instance of the ToastNotification , bound to a specified app, usually another app in the same package.
 * @param {string=} applicationId The unique ID of the app.
 * @return {!Windows.UI.Notifications.ToastNotifier} The object you will use to send the toast notification to the app. / The object you will use to send the toast notification to the tile.
 */
Windows.UI.Notifications.ToastNotificationManager.createToastNotifier = function(applicationId) {};

/**
 * Gets the XML content of one of the predefined toast templates so that you can customize it for use in your notification.
 * @param {Windows.UI.Notifications.ToastTemplateType} type One of the system-provided toast templates.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The object that contains the template XML.
 */
Windows.UI.Notifications.ToastNotificationManager.getTemplateContent = function(type) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Notifications.ToastNotifier = function() {};
 /** @type {Windows.UI.Notifications.NotificationSetting} */
Windows.UI.Notifications.ToastNotifier.prototype.setting;

/**
 * Adds a ScheduledToastNotification for later display by Windows.
 * @param {!Windows.UI.Notifications.ScheduledToastNotification} scheduledToast The scheduled toast notification, which includes its content and timing instructions.
 * @return {void}
 */
Windows.UI.Notifications.ToastNotifier.prototype.addToSchedule = function(scheduledToast) {};

/**
 * Gets the collection of ScheduledToastNotification objects that this app has scheduled for display.
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Notifications.ScheduledToastNotification>} The collection of scheduled toast notifications that the app bound to this notifier has scheduled for timed display.
 */
Windows.UI.Notifications.ToastNotifier.prototype.getScheduledToastNotifications = function() {};

/**
 * Removes the specified toast notification from the screen.
 * @param {!Windows.UI.Notifications.ToastNotification} notification The object that specifies the toast to hide.
 * @return {void}
 */
Windows.UI.Notifications.ToastNotifier.prototype.hide = function(notification) {};

/**
 * Cancels the scheduled display of a specified ScheduledToastNotification .
 * @param {!Windows.UI.Notifications.ScheduledToastNotification} scheduledToast The notification to remove from the schedule.
 * @return {void}
 */
Windows.UI.Notifications.ToastNotifier.prototype.removeFromSchedule = function(scheduledToast) {};

/**
 * Displays the specified toast notification.
 * @param {!Windows.UI.Notifications.ToastNotification} notification The object that contains the content of the toast notification to display.
 * @return {void}
 */
Windows.UI.Notifications.ToastNotifier.prototype.show = function(notification) {};

/** @const */
Windows.UI.Notifications.ToastTemplateType = {};
/** @const {number} */
Windows.UI.Notifications.ToastTemplateType.toastImageAndText01;
/** @const {number} */
Windows.UI.Notifications.ToastTemplateType.toastImageAndText02;
/** @const {number} */
Windows.UI.Notifications.ToastTemplateType.toastImageAndText03;
/** @const {number} */
Windows.UI.Notifications.ToastTemplateType.toastImageAndText04;
/** @const {number} */
Windows.UI.Notifications.ToastTemplateType.toastText01;
/** @const {number} */
Windows.UI.Notifications.ToastTemplateType.toastText02;
/** @const {number} */
Windows.UI.Notifications.ToastTemplateType.toastText03;
/** @const {number} */
Windows.UI.Notifications.ToastTemplateType.toastText04;
/** @const */
Windows.UI.Popups = {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the MessageDialog class to display a titled message dialog that can be used to ask your user simple questions.
 * Initializes a new instance of the MessageDialog class to display an untitled message dialog that can be used to ask your user simple questions.
 * @param {string} content The message displayed to the user.
 * @param {string=} title The title you want displayed on the dialog.
 */
Windows.UI.Popups.MessageDialog = function(content, title) {};
 /** @type {number} */
Windows.UI.Popups.MessageDialog.prototype.cancelCommandIndex;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.UI.Popups.IUICommand>} */
Windows.UI.Popups.MessageDialog.prototype.commands;
 /** @type {string} */
Windows.UI.Popups.MessageDialog.prototype.content;
 /** @type {number} */
Windows.UI.Popups.MessageDialog.prototype.defaultCommandIndex;
 /** @type {Windows.UI.Popups.MessageDialogOptions} */
Windows.UI.Popups.MessageDialog.prototype.options;
 /** @type {string} */
Windows.UI.Popups.MessageDialog.prototype.title;

/**
 * Begins an asynchronous operation showing a dialog.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.UI.Popups.IUICommand, !Windows.Foundation.IAsyncOperation<!Windows.UI.Popups.IUICommand>>} An object that represents the asynchronous operation. For more on the async pattern, see Asynchronous programming.
 */
Windows.UI.Popups.MessageDialog.prototype.showAsync = function() {};

/** @const */
Windows.UI.Popups.MessageDialogOptions = {};
/** @const {number} */
Windows.UI.Popups.MessageDialogOptions.none;
/** @const {number} */
Windows.UI.Popups.MessageDialogOptions.acceptUserInputAfterDelay;

/** @const */
Windows.UI.Popups.Placement = {};
/** @const {number} */
Windows.UI.Popups.Placement.default;
/** @const {number} */
Windows.UI.Popups.Placement.above;
/** @const {number} */
Windows.UI.Popups.Placement.below;
/** @const {number} */
Windows.UI.Popups.Placement.left;
/** @const {number} */
Windows.UI.Popups.Placement.right;

/**
 * @constructor
 * @struct
 * Creates a new instance of the PopupMenu class.
 */
Windows.UI.Popups.PopupMenu = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.UI.Popups.IUICommand>} */
Windows.UI.Popups.PopupMenu.prototype.commands;

/**
 * Shows the context menu at the specified client coordinates.
 * @param {!Windows.Foundation.Point} invocationPoint The coordinates (in DIPs), relative to the window, of the user's finger or mouse pointer when the oncontextmenu event fired. The menu is placed above and centered on this point.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.UI.Popups.IUICommand, !Windows.Foundation.IAsyncOperation<!Windows.UI.Popups.IUICommand>>} A IUICommand object that represents the context menu command that was invoked by the user, after the ShowAsync call completes.
 */
Windows.UI.Popups.PopupMenu.prototype.showAsync = function(invocationPoint) {};

/**
 * Shows the context menu above the specified selection.
 * Shows the context menu in the preferred placement relative to the specified selection.
 * @param {!Windows.Foundation.Rect} selection The coordinates (in DIPs) of the selected rectangle, relative to the window. The context menu is placed directly above and centered on this rectangle such that selection is not covered. / The coordinates (in DIPs) of the selected rectangle, relative to the window.
 * @param {Windows.UI.Popups.Placement=} preferredPlacement The preferred placement of the context menu relative to the selection rectangle.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.UI.Popups.IUICommand, !Windows.Foundation.IAsyncOperation<!Windows.UI.Popups.IUICommand>>} A IUICommand object that represents the context menu command invoked by the user, after the ShowForSelectionAsync call completes.
 */
Windows.UI.Popups.PopupMenu.prototype.showForSelectionAsync = function(selection, preferredPlacement) {};

/**
 * @constructor
 * @struct
 * Creates a new instance of the UICommand class.
 * Creates a new instance of the UICommand class using the specified label and event handler.
 * Creates a new instance of the UICommand class using the specified label, event handler, and command identifier.
 * Creates a new instance of the UICommand class using the specified label.
 * @param {string=} label The label for the new command. / The label for the UICommand .
 * @param {function(!Windows.UI.Popups.IUICommand): void=} action The event handler for the new command.
 * @param {?=} commandId The command identifier for the new command.
 */
Windows.UI.Popups.UICommand = function(label, action, commandId) {};
 /** @type {?} */
Windows.UI.Popups.UICommand.prototype.id;
 /** @type {function(!Windows.UI.Popups.IUICommand): void} */
Windows.UI.Popups.UICommand.prototype.invoked;
 /** @type {string} */
Windows.UI.Popups.UICommand.prototype.label;

/**
 * @constructor
 * @struct
 * Creates a new instance of the UICommandSeparator class.
 */
Windows.UI.Popups.UICommandSeparator = function() {};
 /** @type {?} */
Windows.UI.Popups.UICommandSeparator.prototype.id;
 /** @type {function(!Windows.UI.Popups.IUICommand): void} */
Windows.UI.Popups.UICommandSeparator.prototype.invoked;
 /** @type {string} */
Windows.UI.Popups.UICommandSeparator.prototype.label;

/** @typedef {function(!Windows.UI.Popups.IUICommand): void} */
Windows.UI.Popups.UICommandInvokedHandler;
/**
 * @record
 * @struct
 */
Windows.UI.Popups.IUICommand = function() {};
 /** @type {?} */
Windows.UI.Popups.IUICommand.prototype.id;
 /** @type {function(!Windows.UI.Popups.IUICommand): void} */
Windows.UI.Popups.IUICommand.prototype.invoked;
 /** @type {string} */
Windows.UI.Popups.IUICommand.prototype.label;
/** @const */
Windows.UI.StartScreen = {};

/** @const */
Windows.UI.StartScreen.ForegroundText = {};
/** @const {number} */
Windows.UI.StartScreen.ForegroundText.dark;
/** @const {number} */
Windows.UI.StartScreen.ForegroundText.light;
/**
 * @constructor
 * @struct
 */
Windows.UI.StartScreen.JumpList = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.UI.StartScreen.JumpListItem>} */
Windows.UI.StartScreen.JumpList.prototype.items;
 /** @type {Windows.UI.StartScreen.JumpListSystemGroupKind} */
Windows.UI.StartScreen.JumpList.prototype.systemGroupKind;

/**
 * Gets a value that indicates whether the system supports jump lists.
 * @return {boolean} A boolean value that is True if jump lists are supported. Otherwise, False.
 */
Windows.UI.StartScreen.JumpList.isSupported = function() {};

/**
 * Asynchronously retrieves the current jump list and its items.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.UI.StartScreen.JumpList, !Windows.Foundation.IAsyncOperation<!Windows.UI.StartScreen.JumpList>>} When this method completes successfully, it returns the current JumpList . If the system does not support jump lists, this method returns an empty jump list and the SaveAsync method has no effect. Apps can check for this case using the isSupported method.
 */
Windows.UI.StartScreen.JumpList.loadCurrentAsync = function() {};

/**
 * Asynchronously saves changes to the jump list and its items.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} Returns an IAsyncAction object that is used to control the asynchronous operation. If the system does not support jump lists, the SaveAsync method has no effect and future calls to LoadCurrentAsync will produce an empty jump list. An app can check for this case using the IsSupported method.
 */
Windows.UI.StartScreen.JumpList.prototype.saveAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.StartScreen.JumpListItem = function() {};
 /** @type {string} */
Windows.UI.StartScreen.JumpListItem.prototype.arguments;
 /** @type {string} */
Windows.UI.StartScreen.JumpListItem.prototype.description;
 /** @type {string} */
Windows.UI.StartScreen.JumpListItem.prototype.displayName;
 /** @type {string} */
Windows.UI.StartScreen.JumpListItem.prototype.groupName;
 /** @type {Windows.UI.StartScreen.JumpListItemKind} */
Windows.UI.StartScreen.JumpListItem.prototype.kind;
 /** @type {!Windows.Foundation.Uri} */
Windows.UI.StartScreen.JumpListItem.prototype.logo;
 /** @type {boolean} */
Windows.UI.StartScreen.JumpListItem.prototype.removedByUser;

/**
 * Creates a jump list item that is an inert separator for a custom group within the app's jump list.
 * @return {!Windows.UI.StartScreen.JumpListItem} A jump list item that can be added to an app's jump list through the items property.
 */
Windows.UI.StartScreen.JumpListItem.createSeparator = function() {};

/**
 * Creates a new jump list item for an app's jump list.
 * @param {string} args
 * @param {string} displayName String that specifies a display name for the jump list item. If localization is desired, this string must be a ms-resource: scheme specified URI.
 * @return {!Windows.UI.StartScreen.JumpListItem} A jump list item with the specified parameters that can be added to an app's jump list through the items property.
 */
Windows.UI.StartScreen.JumpListItem.createWithArguments = function(args, displayName) {};

/** @const */
Windows.UI.StartScreen.JumpListItemKind = {};
/** @const {number} */
Windows.UI.StartScreen.JumpListItemKind.arguments;
/** @const {number} */
Windows.UI.StartScreen.JumpListItemKind.separator;

/** @const */
Windows.UI.StartScreen.JumpListSystemGroupKind = {};
/** @const {number} */
Windows.UI.StartScreen.JumpListSystemGroupKind.none;
/** @const {number} */
Windows.UI.StartScreen.JumpListSystemGroupKind.frequent;
/** @const {number} */
Windows.UI.StartScreen.JumpListSystemGroupKind.recent;

/**
 * @constructor
 * @struct
 * Creates a SecondaryTile object. The caller must then set any mandatory properties through the object before attempting to pin, update, or delete the tile.
 * Creates a SecondaryTile object as a wide tile.
 * Creates a SecondaryTile object with a specific ID. This form of the constructor should be used to create a secondary tile object to perform a tile update or deletion.
 * Creates a SecondaryTile object as a medium tile.
 * Creates a SecondaryTile object that includes all of the mandatory properties required to create a medium tile.
 * @param {string=} tileId A string that will uniquely identify the tile within your app's package. Choose a unique ID that is descriptive and meaningful to your app. It is limited to 64 characters and must begin with a number or letter and be composed of the characters a-z, A-Z, 0-9, period (.), or underscore (_). If you provide the same ID as that of an existing secondary tile, the existing secondary tile will be overwritten. Can be set or retrieved through the TileId property. / A string that will uniquely identify the tile within your app. Choose a unique ID that is descriptive and meaningful to your app. If you provide the same ID as that of an existing secondary tile, the existing secondary tile will be overwritten.
 * @param {string=} shortName_or_displayName A short name to display directly on the tile if the app chooses to do so. Anything over 40 characters will be truncated. The user has the option to change this value as part of the pinning process. Can be set or retrieved through the ShortName property. / A name to be displayed on the tile, in the tile's tooltip, and when showing small tiles, such as on the Apps or search results screens. This string is equivalent to the display name given in the manifest for the main tile. It is restricted to 256 characters, but in practice should be kept short to avoid truncation. This value can be set or retrieved through the DisplayName property.
 * @param {string=} displayName_or_args A name to be displayed on the tile, in the tile's tooltip, and when showing small tiles, such as on the Apps or search results screens. This string is equivalent to the display name given in the manifest for the main tile. It is restricted to 256 characters, but in practice should be kept short to avoid truncation. This value can be set or retrieved through the DisplayName property.
 * @param {string|!Windows.Foundation.Uri=} args_or_square150x150Logo A reference to a medium logo image stored at a URI. Can be set or retrieved through the SecondaryTileVisualElements.Square150x150Logo property. This value can be expressed using one of these schemes:
 * @param {Windows.UI.StartScreen.TileOptions|Windows.UI.StartScreen.TileSize=} tileOptions_or_desiredSize A value that specifies various options such as whether the name will be displayed on the secondary tile. Can be set or retrieved through the TileOptions property. / The size of tile to pin. This value must be Default (which provides Windows 8 behavior), Square150x150, or Wide310x150. Any other TileSize value causes an exception to be thrown during runtime.
 * @param {!Windows.Foundation.Uri=} logoReference A reference to a medium logo image stored at a URI. Can be set or retrieved through the Square150x150Logo property. This value can be expressed using one of these schemes: / A reference to a square logo image stored at a URI. Can be set or retrieved through the Logo property. This value can be expressed using one of these schemes:
 * @param {!Windows.Foundation.Uri=} wideLogoReference A reference to a wide logo image stored at a URI. Can be set or retrieved through the WideLogo property. This value can be expressed using one of these schemes:
 */
Windows.UI.StartScreen.SecondaryTile = function(tileId, shortName_or_displayName, displayName_or_args, args_or_square150x150Logo, tileOptions_or_desiredSize, logoReference, wideLogoReference) {};
 /** @type {string} */
Windows.UI.StartScreen.SecondaryTile.prototype.arguments;
 /** @type {!Windows.UI.Color} */
Windows.UI.StartScreen.SecondaryTile.prototype.backgroundColor;
 /** @type {string} */
Windows.UI.StartScreen.SecondaryTile.prototype.displayName;
 /** @type {Windows.UI.StartScreen.ForegroundText} */
Windows.UI.StartScreen.SecondaryTile.prototype.foregroundText;
 /** @type {!Windows.Foundation.Uri} */
Windows.UI.StartScreen.SecondaryTile.prototype.lockScreenBadgeLogo;
 /** @type {boolean} */
Windows.UI.StartScreen.SecondaryTile.prototype.lockScreenDisplayBadgeAndTileText;
 /** @type {!Windows.Foundation.Uri} */
Windows.UI.StartScreen.SecondaryTile.prototype.logo;
 /** @type {function(?): void} */
Windows.UI.StartScreen.SecondaryTile.prototype.onvisualelementsrequested;
 /** @type {string} */
Windows.UI.StartScreen.SecondaryTile.prototype.phoneticName;
 /** @type {boolean} */
Windows.UI.StartScreen.SecondaryTile.prototype.roamingEnabled;
 /** @type {string} */
Windows.UI.StartScreen.SecondaryTile.prototype.shortName;
 /** @type {!Windows.Foundation.Uri} */
Windows.UI.StartScreen.SecondaryTile.prototype.smallLogo;
 /** @type {string} */
Windows.UI.StartScreen.SecondaryTile.prototype.tileId;
 /** @type {Windows.UI.StartScreen.TileOptions} */
Windows.UI.StartScreen.SecondaryTile.prototype.tileOptions;
 /** @type {!Windows.UI.StartScreen.SecondaryTileVisualElements} */
Windows.UI.StartScreen.SecondaryTile.prototype.visualElements;
 /** @type {!Windows.Foundation.Uri} */
Windows.UI.StartScreen.SecondaryTile.prototype.wideLogo;

/**
 * Checks whether a specific secondary tile exists for the calling app.
 * @param {string} tileId The unique ID string that was assigned to the tile when it was created.
 * @return {boolean} True if the tile exists in the calling application; otherwise, false.
 */
Windows.UI.StartScreen.SecondaryTile.exists = function(tileId) {};

/**
 * Retrieves a list of secondary tiles created for the calling app.
 * Retrieves a list of secondary tiles created for another app in the same package as the calling app.
 * @param {string=} applicationId The Package Relative Application ID (PRAID) of the app.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An enumeration object that allows you to examine the set of tiles.
 */
Windows.UI.StartScreen.SecondaryTile.findAllAsync = function(applicationId) {};

/**
 * Retrieves a list of secondary tiles created for all of the apps in the package of the calling app.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Foundation.Collections.IVectorView<?>, !Windows.Foundation.IAsyncOperation<!Windows.Foundation.Collections.IVectorView<?>>>} An enumeration object that allows you to examine the set of tiles.
 */
Windows.UI.StartScreen.SecondaryTile.findAllForPackageAsync = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.StartScreen.SecondaryTile.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.StartScreen.SecondaryTile.prototype.removeEventListener = function(type, listener) {};

/**
 * Displays the Pin to Start flyout above a specified location, through which the user can confirm that they want to create the secondary tile, which in turn creates the tile.
 * Displays the Pin to Start flyout, through which the user can confirm that they want to create the secondary tile, which in turn creates the tile. Overloads of this method let you specify the on-screen location of the flyout.
 * @param {!Windows.Foundation.Point=} invocationPoint The point used as the lower-right corner of the Pin to Start flyout.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An object that provides information concerning the asynchronous create operation. / An object used to launch the asynchronous create operation as well as to retrieve information about it.
 */
Windows.UI.StartScreen.SecondaryTile.prototype.requestCreateAsync = function(invocationPoint) {};

/**
 * Displays the Pin to Start flyout above a specified area. This flyout is used by the user to confirm that they want to create the secondary tile, which in turn creates the tile.
 * Displays the Pin to Start flyout at the specified side of a specified area. This flyout is used by the user to confirm that they want to create the secondary tile, which in turn creates the tile.
 * @param {!Windows.Foundation.Rect} selection The area that the flyout is displayed directly above. / The area to one side of which the flyout will be displayed.
 * @param {Windows.UI.Popups.Placement=} preferredPlacement The side of the rectangle where the flyout should appear.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An object that provides information concerning the asynchronous create operation.
 */
Windows.UI.StartScreen.SecondaryTile.prototype.requestCreateForSelectionAsync = function(selection, preferredPlacement) {};

/**
 * Displays the Unpin from Start flyout. This flyout lets the user confirm removal of the secondary tile.
 * Displays the Unpin from Start flyout at a specified point. This flyout lets the user confirm removal of the secondary tile.
 * @param {!Windows.Foundation.Point=} invocationPoint The point used as the lower-right corner of the Pin to Start flyout.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An object that provides information concerning the asynchronous delete operation.
 */
Windows.UI.StartScreen.SecondaryTile.prototype.requestDeleteAsync = function(invocationPoint) {};

/**
 * Displays the Unpin from Start flyout above a specified area. This flyout lets the user confirm removal of the secondary tile.
 * Displays the Unpin from Start flyout at the specified side of a specified area. This flyout lets the user confirm removal of the secondary tile.
 * @param {!Windows.Foundation.Rect} selection The area that the secondary tile is displayed directly above. / The area to the side of which the flyout will be displayed.
 * @param {Windows.UI.Popups.Placement=} preferredPlacement One of the enumeration values that specifies the side of the rectangle where the flyout should be shown.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An object that provides information concerning the asynchronous delete operation.
 */
Windows.UI.StartScreen.SecondaryTile.prototype.requestDeleteForSelectionAsync = function(selection, preferredPlacement) {};

/**
 * Updates a secondary tile after that tile is pinned to the Start screen.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} An object used to launch the asynchronous create operation as well as to retrieve information about it.
 */
Windows.UI.StartScreen.SecondaryTile.prototype.updateAsync = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.StartScreen.SecondaryTileVisualElements = function() {};
 /** @type {!Windows.UI.Color} */
Windows.UI.StartScreen.SecondaryTileVisualElements.prototype.backgroundColor;
 /** @type {Windows.UI.StartScreen.ForegroundText} */
Windows.UI.StartScreen.SecondaryTileVisualElements.prototype.foregroundText;
 /** @type {boolean} */
Windows.UI.StartScreen.SecondaryTileVisualElements.prototype.showNameOnSquare150x150Logo;
 /** @type {boolean} */
Windows.UI.StartScreen.SecondaryTileVisualElements.prototype.showNameOnSquare310x310Logo;
 /** @type {boolean} */
Windows.UI.StartScreen.SecondaryTileVisualElements.prototype.showNameOnWide310x150Logo;
 /** @type {!Windows.Foundation.Uri} */
Windows.UI.StartScreen.SecondaryTileVisualElements.prototype.square150x150Logo;
 /** @type {!Windows.Foundation.Uri} */
Windows.UI.StartScreen.SecondaryTileVisualElements.prototype.square30x30Logo;
 /** @type {!Windows.Foundation.Uri} */
Windows.UI.StartScreen.SecondaryTileVisualElements.prototype.square310x310Logo;
 /** @type {!Windows.Foundation.Uri} */
Windows.UI.StartScreen.SecondaryTileVisualElements.prototype.square44x44Logo;
 /** @type {!Windows.Foundation.Uri} */
Windows.UI.StartScreen.SecondaryTileVisualElements.prototype.square70x70Logo;
 /** @type {!Windows.Foundation.Uri} */
Windows.UI.StartScreen.SecondaryTileVisualElements.prototype.square71x71Logo;
 /** @type {!Windows.Foundation.Uri} */
Windows.UI.StartScreen.SecondaryTileVisualElements.prototype.wide310x150Logo;

/** @const */
Windows.UI.StartScreen.TileOptions = {};
/** @const {number} */
Windows.UI.StartScreen.TileOptions.none;
/** @const {number} */
Windows.UI.StartScreen.TileOptions.showNameOnLogo;
/** @const {number} */
Windows.UI.StartScreen.TileOptions.showNameOnWideLogo;
/** @const {number} */
Windows.UI.StartScreen.TileOptions.copyOnDeployment;

/** @const */
Windows.UI.StartScreen.TileSize = {};
/** @const {number} */
Windows.UI.StartScreen.TileSize.default;
/** @const {number} */
Windows.UI.StartScreen.TileSize.square30x30;
/** @const {number} */
Windows.UI.StartScreen.TileSize.square70x70;
/** @const {number} */
Windows.UI.StartScreen.TileSize.square150x150;
/** @const {number} */
Windows.UI.StartScreen.TileSize.wide310x150;
/** @const {number} */
Windows.UI.StartScreen.TileSize.square310x310;
/** @const {number} */
Windows.UI.StartScreen.TileSize.square71x71;
/** @const {number} */
Windows.UI.StartScreen.TileSize.square44x44;
/**
 * @constructor
 * @struct
 */
Windows.UI.StartScreen.VisualElementsRequest = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.UI.StartScreen.SecondaryTileVisualElements>} */
Windows.UI.StartScreen.VisualElementsRequest.prototype.alternateVisualElements;
 /** @type {!Date} */
Windows.UI.StartScreen.VisualElementsRequest.prototype.deadline;
 /** @type {!Windows.UI.StartScreen.SecondaryTileVisualElements} */
Windows.UI.StartScreen.VisualElementsRequest.prototype.visualElements;

/**
 * Retrieves a deferral object, which allows the app time to provide information and assets used in the Pin to Start flyout.
 * @return {!Windows.UI.StartScreen.VisualElementsRequestDeferral} The deferral object.
 */
Windows.UI.StartScreen.VisualElementsRequest.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.StartScreen.VisualElementsRequestDeferral = function() {};

/**
 * Tells Windows that the app is ready to display the Pin to Start flyout. The app calls this method when it has finished setting the properties that specify what to show in that flyout.
 * @return {void}
 */
Windows.UI.StartScreen.VisualElementsRequestDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.StartScreen.VisualElementsRequestedEventArgs = function() {};
 /** @type {!Windows.UI.StartScreen.VisualElementsRequest} */
Windows.UI.StartScreen.VisualElementsRequestedEventArgs.prototype.request;
/** @const */
Windows.UI.Text = {};

/** @const */
Windows.UI.Text.CaretType = {};
/** @const {number} */
Windows.UI.Text.CaretType.normal;
/** @const {number} */
Windows.UI.Text.CaretType.null;
/** @const */
Windows.UI.Text.Core = {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.UI.Text.Core.CoreTextCompositionSegment>} */
Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs.prototype.compositionSegments;
 /** @type {boolean} */
Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs.prototype.isCanceled;

/**
 * Requests that the operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return {!Windows.Foundation.Deferral} A Deferral object.
 */
Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextCompositionSegment = function() {};
 /** @type {string} */
Windows.UI.Text.Core.CoreTextCompositionSegment.prototype.preconversionString;
 /** @type {!Windows.UI.Text.Core.CoreTextRange} */
Windows.UI.Text.Core.CoreTextCompositionSegment.prototype.range;
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs = function() {};
 /** @type {boolean} */
Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs.prototype.isCanceled;

/**
 * Requests that the operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return {!Windows.Foundation.Deferral} A Deferral object.
 */
Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextEditContext = function() {};
 /** @type {Windows.UI.Text.Core.CoreTextInputPaneDisplayPolicy} */
Windows.UI.Text.Core.CoreTextEditContext.prototype.inputPaneDisplayPolicy;
 /** @type {Windows.UI.Text.Core.CoreTextInputScope} */
Windows.UI.Text.Core.CoreTextEditContext.prototype.inputScope;
 /** @type {boolean} */
Windows.UI.Text.Core.CoreTextEditContext.prototype.isReadOnly;
 /** @type {string} */
Windows.UI.Text.Core.CoreTextEditContext.prototype.name;
 /** @type {function(?): void} */
Windows.UI.Text.Core.CoreTextEditContext.prototype.oncompositioncompleted;
 /** @type {function(?): void} */
Windows.UI.Text.Core.CoreTextEditContext.prototype.oncompositionstarted;
 /** @type {function(?): void} */
Windows.UI.Text.Core.CoreTextEditContext.prototype.onfocusremoved;
 /** @type {function(?): void} */
Windows.UI.Text.Core.CoreTextEditContext.prototype.onformatupdating;
 /** @type {function(?): void} */
Windows.UI.Text.Core.CoreTextEditContext.prototype.onlayoutrequested;
 /** @type {function(?): void} */
Windows.UI.Text.Core.CoreTextEditContext.prototype.onnotifyfocusleavecompleted;
 /** @type {function(?): void} */
Windows.UI.Text.Core.CoreTextEditContext.prototype.onselectionrequested;
 /** @type {function(?): void} */
Windows.UI.Text.Core.CoreTextEditContext.prototype.onselectionupdating;
 /** @type {function(?): void} */
Windows.UI.Text.Core.CoreTextEditContext.prototype.ontextrequested;
 /** @type {function(?): void} */
Windows.UI.Text.Core.CoreTextEditContext.prototype.ontextupdating;

/**
 * Notifies the text input server that focus has entered the text input control.
 * @return {void}
 */
Windows.UI.Text.Core.CoreTextEditContext.prototype.notifyFocusEnter = function() {};

/**
 * Notifies the text input server that focus has left the text input control.
 * @return {void}
 */
Windows.UI.Text.Core.CoreTextEditContext.prototype.notifyFocusLeave = function() {};

/**
 * Notifies the text input server that the layout of text inside the text input control has changed.
 * @return {void}
 */
Windows.UI.Text.Core.CoreTextEditContext.prototype.notifyLayoutChanged = function() {};

/**
 * Notifies the text input server about any change that the text input control needs to make to the selection range. This is important in order to keep the internal state of the control and the internal state of the server synchronized.
 * @param {!Windows.UI.Text.Core.CoreTextRange} selection The range of selection currently in effect.
 * @return {void}
 */
Windows.UI.Text.Core.CoreTextEditContext.prototype.notifySelectionChanged = function(selection) {};

/**
 * Notifies the text input server about any change that the text input control needs to make to the text. This is important in order to keep the internal state of the control and the internal state of the server synchronized. Since a change to the text is also likely to affect the selection range, the method takes the selection range as a parameter.
 * @param {!Windows.UI.Text.Core.CoreTextRange} modifiedRange The range of text to replace, in terms of the state the text buffer is in prior to this text change.
 * @param {number} newLength The length of the text that should replace modifiedRange.
 * @param {!Windows.UI.Text.Core.CoreTextRange} newSelection The range of selection in effect after the text change.
 * @return {void}
 */
Windows.UI.Text.Core.CoreTextEditContext.prototype.notifyTextChanged = function(modifiedRange, newLength, newSelection) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.Text.Core.CoreTextEditContext.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.Text.Core.CoreTextEditContext.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs = function() {};
 /** @type {Windows.UI.ViewManagement.UIElementType} */
Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs.prototype.backgroundColor;
 /** @type {boolean} */
Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs.prototype.isCanceled;
 /** @type {!Windows.UI.Text.Core.CoreTextRange} */
Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs.prototype.range;
 /** @type {Windows.UI.Text.Core.CoreTextFormatUpdatingReason} */
Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs.prototype.reason;
 /** @type {Windows.UI.Text.Core.CoreTextFormatUpdatingResult} */
Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs.prototype.result;
 /** @type {Windows.UI.ViewManagement.UIElementType} */
Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs.prototype.textColor;
 /** @type {Windows.UI.ViewManagement.UIElementType} */
Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs.prototype.underlineColor;
 /** @type {Windows.UI.Text.UnderlineType} */
Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs.prototype.underlineType;

/**
 * Requests that the format update operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return {!Windows.Foundation.Deferral} A Deferral object.
 */
Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs.prototype.getDeferral = function() {};

/** @const */
Windows.UI.Text.Core.CoreTextFormatUpdatingReason = {};
/** @const {number} */
Windows.UI.Text.Core.CoreTextFormatUpdatingReason.none;
/** @const {number} */
Windows.UI.Text.Core.CoreTextFormatUpdatingReason.compositionUnconverted;
/** @const {number} */
Windows.UI.Text.Core.CoreTextFormatUpdatingReason.compositionConverted;
/** @const {number} */
Windows.UI.Text.Core.CoreTextFormatUpdatingReason.compositionTargetUnconverted;
/** @const {number} */
Windows.UI.Text.Core.CoreTextFormatUpdatingReason.compositionTargetConverted;

/** @const */
Windows.UI.Text.Core.CoreTextFormatUpdatingResult = {};
/** @const {number} */
Windows.UI.Text.Core.CoreTextFormatUpdatingResult.succeeded;
/** @const {number} */
Windows.UI.Text.Core.CoreTextFormatUpdatingResult.failed;

/** @const */
Windows.UI.Text.Core.CoreTextInputPaneDisplayPolicy = {};
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputPaneDisplayPolicy.automatic;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputPaneDisplayPolicy.manual;

/** @const */
Windows.UI.Text.Core.CoreTextInputScope = {};
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.default;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.url;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.filePath;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.fileName;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.emailUserName;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.emailAddress;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.userName;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.personalFullName;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.personalNamePrefix;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.personalGivenName;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.personalMiddleName;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.personalSurname;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.personalNameSuffix;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.address;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.addressPostalCode;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.addressStreet;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.addressStateOrProvince;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.addressCity;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.addressCountryName;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.addressCountryShortName;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.currencyAmountAndSymbol;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.currencyAmount;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.date;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.dateMonth;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.dateDay;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.dateYear;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.dateMonthName;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.dateDayName;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.number;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.singleCharacter;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.password;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.telephoneNumber;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.telephoneCountryCode;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.telephoneAreaCode;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.telephoneLocalNumber;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.time;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.timeHour;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.timeMinuteOrSecond;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.numberFullWidth;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.alphanumericHalfWidth;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.alphanumericFullWidth;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.currencyChinese;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.bopomofo;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.hiragana;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.katakanaHalfWidth;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.katakanaFullWidth;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.hanja;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.hangulHalfWidth;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.hangulFullWidth;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.search;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.formula;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.searchIncremental;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.chineseHalfWidth;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.chineseFullWidth;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.nativeScript;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.text;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.chat;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.nameOrPhoneNumber;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.emailUserNameOrAddress;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.private;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.maps;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.passwordNumeric;
/** @const {number} */
Windows.UI.Text.Core.CoreTextInputScope.formulaNumber;
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextLayoutBounds = function() {};
 /** @type {!Windows.Foundation.Rect} */
Windows.UI.Text.Core.CoreTextLayoutBounds.prototype.controlBounds;
 /** @type {!Windows.Foundation.Rect} */
Windows.UI.Text.Core.CoreTextLayoutBounds.prototype.textBounds;
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextLayoutRequest = function() {};
 /** @type {boolean} */
Windows.UI.Text.Core.CoreTextLayoutRequest.prototype.isCanceled;
 /** @type {!Windows.UI.Text.Core.CoreTextLayoutBounds} */
Windows.UI.Text.Core.CoreTextLayoutRequest.prototype.layoutBounds;
 /** @type {!Windows.UI.Text.Core.CoreTextRange} */
Windows.UI.Text.Core.CoreTextLayoutRequest.prototype.range;

/**
 * Requests that the layout request operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return {!Windows.Foundation.Deferral} A Deferral object.
 */
Windows.UI.Text.Core.CoreTextLayoutRequest.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextLayoutRequestedEventArgs = function() {};
 /** @type {!Windows.UI.Text.Core.CoreTextLayoutRequest} */
Windows.UI.Text.Core.CoreTextLayoutRequestedEventArgs.prototype.request;
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextSelectionRequest = function() {};
 /** @type {boolean} */
Windows.UI.Text.Core.CoreTextSelectionRequest.prototype.isCanceled;
 /** @type {!Windows.UI.Text.Core.CoreTextRange} */
Windows.UI.Text.Core.CoreTextSelectionRequest.prototype.selection;

/**
 * Requests that the selection request operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return {!Windows.Foundation.Deferral} A Deferral object.
 */
Windows.UI.Text.Core.CoreTextSelectionRequest.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextSelectionRequestedEventArgs = function() {};
 /** @type {!Windows.UI.Text.Core.CoreTextSelectionRequest} */
Windows.UI.Text.Core.CoreTextSelectionRequestedEventArgs.prototype.request;
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs = function() {};
 /** @type {boolean} */
Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs.prototype.isCanceled;
 /** @type {Windows.UI.Text.Core.CoreTextSelectionUpdatingResult} */
Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs.prototype.result;
 /** @type {!Windows.UI.Text.Core.CoreTextRange} */
Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs.prototype.selection;

/**
 * Requests that the selection update operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return {!Windows.Foundation.Deferral} A Deferral object.
 */
Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs.prototype.getDeferral = function() {};

/** @const */
Windows.UI.Text.Core.CoreTextSelectionUpdatingResult = {};
/** @const {number} */
Windows.UI.Text.Core.CoreTextSelectionUpdatingResult.succeeded;
/** @const {number} */
Windows.UI.Text.Core.CoreTextSelectionUpdatingResult.failed;
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextServicesConstants = function() {};
 /** @type {string} */
Windows.UI.Text.Core.CoreTextServicesConstants.hiddenCharacter;
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextServicesManager = function() {};
 /** @type {!Windows.Globalization.Language} */
Windows.UI.Text.Core.CoreTextServicesManager.prototype.inputLanguage;
 /** @type {function(?): void} */
Windows.UI.Text.Core.CoreTextServicesManager.prototype.oninputlanguagechanged;

/**
 * Gets the CoreTextServicesManager object for the currently active view.
 * @return {!Windows.UI.Text.Core.CoreTextServicesManager} A CoreTextServicesManager instance, which can be used to create further objects to support the app's text input scenarios.
 */
Windows.UI.Text.Core.CoreTextServicesManager.getForCurrentView = function() {};

/**
 * Creates a context object used by a text input control to communicate with the text input server. Each text input control must create its own context object.
 * @return {!Windows.UI.Text.Core.CoreTextEditContext} A CoreTextEditContext instance, which is the primary object used for communicating with the text input server.
 */
Windows.UI.Text.Core.CoreTextServicesManager.prototype.createEditContext = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.Text.Core.CoreTextServicesManager.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.Text.Core.CoreTextServicesManager.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextTextRequest = function() {};
 /** @type {boolean} */
Windows.UI.Text.Core.CoreTextTextRequest.prototype.isCanceled;
 /** @type {!Windows.UI.Text.Core.CoreTextRange} */
Windows.UI.Text.Core.CoreTextTextRequest.prototype.range;
 /** @type {string} */
Windows.UI.Text.Core.CoreTextTextRequest.prototype.text;

/**
 * Requests that the text request operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return {!Windows.Foundation.Deferral} A Deferral object.
 */
Windows.UI.Text.Core.CoreTextTextRequest.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextTextRequestedEventArgs = function() {};
 /** @type {!Windows.UI.Text.Core.CoreTextTextRequest} */
Windows.UI.Text.Core.CoreTextTextRequestedEventArgs.prototype.request;
/**
 * @constructor
 * @struct
 */
Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs = function() {};
 /** @type {!Windows.Globalization.Language} */
Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs.prototype.inputLanguage;
 /** @type {boolean} */
Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs.prototype.isCanceled;
 /** @type {!Windows.UI.Text.Core.CoreTextRange} */
Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs.prototype.newSelection;
 /** @type {!Windows.UI.Text.Core.CoreTextRange} */
Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs.prototype.range;
 /** @type {Windows.UI.Text.Core.CoreTextTextUpdatingResult} */
Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs.prototype.result;
 /** @type {string} */
Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs.prototype.text;

/**
 * Requests that the text update operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
 * @return {!Windows.Foundation.Deferral} A Deferral deferral object.
 */
Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs.prototype.getDeferral = function() {};

/** @const */
Windows.UI.Text.Core.CoreTextTextUpdatingResult = {};
/** @const {number} */
Windows.UI.Text.Core.CoreTextTextUpdatingResult.succeeded;
/** @const {number} */
Windows.UI.Text.Core.CoreTextTextUpdatingResult.failed;
/**
 * @record
 * @struct
 */
Windows.UI.Text.Core.CoreTextRange = function() {};
 /** @type {number} */
Windows.UI.Text.Core.CoreTextRange.prototype.endCaretPosition;
 /** @type {number} */
Windows.UI.Text.Core.CoreTextRange.prototype.startCaretPosition;

/** @const */
Windows.UI.Text.FindOptions = {};
/** @const {number} */
Windows.UI.Text.FindOptions.none;
/** @const {number} */
Windows.UI.Text.FindOptions.word;
/** @const {number} */
Windows.UI.Text.FindOptions.case;

/** @const */
Windows.UI.Text.FontStretch = {};
/** @const {number} */
Windows.UI.Text.FontStretch.undefined;
/** @const {number} */
Windows.UI.Text.FontStretch.ultraCondensed;
/** @const {number} */
Windows.UI.Text.FontStretch.extraCondensed;
/** @const {number} */
Windows.UI.Text.FontStretch.condensed;
/** @const {number} */
Windows.UI.Text.FontStretch.semiCondensed;
/** @const {number} */
Windows.UI.Text.FontStretch.normal;
/** @const {number} */
Windows.UI.Text.FontStretch.semiExpanded;
/** @const {number} */
Windows.UI.Text.FontStretch.expanded;
/** @const {number} */
Windows.UI.Text.FontStretch.extraExpanded;
/** @const {number} */
Windows.UI.Text.FontStretch.ultraExpanded;

/** @const */
Windows.UI.Text.FontStyle = {};
/** @const {number} */
Windows.UI.Text.FontStyle.normal;
/** @const {number} */
Windows.UI.Text.FontStyle.oblique;
/** @const {number} */
Windows.UI.Text.FontStyle.italic;

/** @const */
Windows.UI.Text.FormatEffect = {};
/** @const {number} */
Windows.UI.Text.FormatEffect.off;
/** @const {number} */
Windows.UI.Text.FormatEffect.on;
/** @const {number} */
Windows.UI.Text.FormatEffect.toggle;
/** @const {number} */
Windows.UI.Text.FormatEffect.undefined;

/** @const */
Windows.UI.Text.HorizontalCharacterAlignment = {};
/** @const {number} */
Windows.UI.Text.HorizontalCharacterAlignment.left;
/** @const {number} */
Windows.UI.Text.HorizontalCharacterAlignment.right;
/** @const {number} */
Windows.UI.Text.HorizontalCharacterAlignment.center;

/** @const */
Windows.UI.Text.LetterCase = {};
/** @const {number} */
Windows.UI.Text.LetterCase.lower;
/** @const {number} */
Windows.UI.Text.LetterCase.upper;

/** @const */
Windows.UI.Text.LineSpacingRule = {};
/** @const {number} */
Windows.UI.Text.LineSpacingRule.undefined;
/** @const {number} */
Windows.UI.Text.LineSpacingRule.single;
/** @const {number} */
Windows.UI.Text.LineSpacingRule.oneAndHalf;
/** @const {number} */
Windows.UI.Text.LineSpacingRule.double;
/** @const {number} */
Windows.UI.Text.LineSpacingRule.atLeast;
/** @const {number} */
Windows.UI.Text.LineSpacingRule.exactly;
/** @const {number} */
Windows.UI.Text.LineSpacingRule.multiple;
/** @const {number} */
Windows.UI.Text.LineSpacingRule.percent;

/** @const */
Windows.UI.Text.LinkType = {};
/** @const {number} */
Windows.UI.Text.LinkType.undefined;
/** @const {number} */
Windows.UI.Text.LinkType.notALink;
/** @const {number} */
Windows.UI.Text.LinkType.clientLink;
/** @const {number} */
Windows.UI.Text.LinkType.friendlyLinkName;
/** @const {number} */
Windows.UI.Text.LinkType.friendlyLinkAddress;
/** @const {number} */
Windows.UI.Text.LinkType.autoLink;
/** @const {number} */
Windows.UI.Text.LinkType.autoLinkEmail;
/** @const {number} */
Windows.UI.Text.LinkType.autoLinkPhone;
/** @const {number} */
Windows.UI.Text.LinkType.autoLinkPath;

/** @const */
Windows.UI.Text.MarkerAlignment = {};
/** @const {number} */
Windows.UI.Text.MarkerAlignment.undefined;
/** @const {number} */
Windows.UI.Text.MarkerAlignment.left;
/** @const {number} */
Windows.UI.Text.MarkerAlignment.center;
/** @const {number} */
Windows.UI.Text.MarkerAlignment.right;

/** @const */
Windows.UI.Text.MarkerStyle = {};
/** @const {number} */
Windows.UI.Text.MarkerStyle.undefined;
/** @const {number} */
Windows.UI.Text.MarkerStyle.parenthesis;
/** @const {number} */
Windows.UI.Text.MarkerStyle.parentheses;
/** @const {number} */
Windows.UI.Text.MarkerStyle.period;
/** @const {number} */
Windows.UI.Text.MarkerStyle.plain;
/** @const {number} */
Windows.UI.Text.MarkerStyle.minus;
/** @const {number} */
Windows.UI.Text.MarkerStyle.noNumber;

/** @const */
Windows.UI.Text.MarkerType = {};
/** @const {number} */
Windows.UI.Text.MarkerType.undefined;
/** @const {number} */
Windows.UI.Text.MarkerType.none;
/** @const {number} */
Windows.UI.Text.MarkerType.bullet;
/** @const {number} */
Windows.UI.Text.MarkerType.arabic;
/** @const {number} */
Windows.UI.Text.MarkerType.lowercaseEnglishLetter;
/** @const {number} */
Windows.UI.Text.MarkerType.uppercaseEnglishLetter;
/** @const {number} */
Windows.UI.Text.MarkerType.lowercaseRoman;
/** @const {number} */
Windows.UI.Text.MarkerType.uppercaseRoman;
/** @const {number} */
Windows.UI.Text.MarkerType.unicodeSequence;
/** @const {number} */
Windows.UI.Text.MarkerType.circledNumber;
/** @const {number} */
Windows.UI.Text.MarkerType.blackCircleWingding;
/** @const {number} */
Windows.UI.Text.MarkerType.whiteCircleWingding;
/** @const {number} */
Windows.UI.Text.MarkerType.arabicWide;
/** @const {number} */
Windows.UI.Text.MarkerType.simplifiedChinese;
/** @const {number} */
Windows.UI.Text.MarkerType.traditionalChinese;
/** @const {number} */
Windows.UI.Text.MarkerType.japanSimplifiedChinese;
/** @const {number} */
Windows.UI.Text.MarkerType.japanKorea;
/** @const {number} */
Windows.UI.Text.MarkerType.arabicDictionary;
/** @const {number} */
Windows.UI.Text.MarkerType.arabicAbjad;
/** @const {number} */
Windows.UI.Text.MarkerType.hebrew;
/** @const {number} */
Windows.UI.Text.MarkerType.thaiAlphabetic;
/** @const {number} */
Windows.UI.Text.MarkerType.thaiNumeric;
/** @const {number} */
Windows.UI.Text.MarkerType.devanagariVowel;
/** @const {number} */
Windows.UI.Text.MarkerType.devanagariConsonant;
/** @const {number} */
Windows.UI.Text.MarkerType.devanagariNumeric;

/** @const */
Windows.UI.Text.ParagraphAlignment = {};
/** @const {number} */
Windows.UI.Text.ParagraphAlignment.undefined;
/** @const {number} */
Windows.UI.Text.ParagraphAlignment.left;
/** @const {number} */
Windows.UI.Text.ParagraphAlignment.center;
/** @const {number} */
Windows.UI.Text.ParagraphAlignment.right;
/** @const {number} */
Windows.UI.Text.ParagraphAlignment.justify;

/** @const */
Windows.UI.Text.ParagraphStyle = {};
/** @const {number} */
Windows.UI.Text.ParagraphStyle.undefined;
/** @const {number} */
Windows.UI.Text.ParagraphStyle.none;
/** @const {number} */
Windows.UI.Text.ParagraphStyle.normal;
/** @const {number} */
Windows.UI.Text.ParagraphStyle.heading1;
/** @const {number} */
Windows.UI.Text.ParagraphStyle.heading2;
/** @const {number} */
Windows.UI.Text.ParagraphStyle.heading3;
/** @const {number} */
Windows.UI.Text.ParagraphStyle.heading4;
/** @const {number} */
Windows.UI.Text.ParagraphStyle.heading5;
/** @const {number} */
Windows.UI.Text.ParagraphStyle.heading6;
/** @const {number} */
Windows.UI.Text.ParagraphStyle.heading7;
/** @const {number} */
Windows.UI.Text.ParagraphStyle.heading8;
/** @const {number} */
Windows.UI.Text.ParagraphStyle.heading9;

/** @const */
Windows.UI.Text.PointOptions = {};
/** @const {number} */
Windows.UI.Text.PointOptions.none;
/** @const {number} */
Windows.UI.Text.PointOptions.includeInset;
/** @const {number} */
Windows.UI.Text.PointOptions.start;
/** @const {number} */
Windows.UI.Text.PointOptions.clientCoordinates;
/** @const {number} */
Windows.UI.Text.PointOptions.allowOffClient;
/** @const {number} */
Windows.UI.Text.PointOptions.transform;
/** @const {number} */
Windows.UI.Text.PointOptions.noHorizontalScroll;
/** @const {number} */
Windows.UI.Text.PointOptions.noVerticalScroll;

/** @const */
Windows.UI.Text.RangeGravity = {};
/** @const {number} */
Windows.UI.Text.RangeGravity.uiBehavior;
/** @const {number} */
Windows.UI.Text.RangeGravity.backward;
/** @const {number} */
Windows.UI.Text.RangeGravity.forward;
/** @const {number} */
Windows.UI.Text.RangeGravity.inward;
/** @const {number} */
Windows.UI.Text.RangeGravity.outward;

/** @const */
Windows.UI.Text.SelectionOptions = {};
/** @const {number} */
Windows.UI.Text.SelectionOptions.startActive;
/** @const {number} */
Windows.UI.Text.SelectionOptions.atEndOfLine;
/** @const {number} */
Windows.UI.Text.SelectionOptions.overtype;
/** @const {number} */
Windows.UI.Text.SelectionOptions.active;
/** @const {number} */
Windows.UI.Text.SelectionOptions.replace;

/** @const */
Windows.UI.Text.SelectionType = {};
/** @const {number} */
Windows.UI.Text.SelectionType.none;
/** @const {number} */
Windows.UI.Text.SelectionType.insertionPoint;
/** @const {number} */
Windows.UI.Text.SelectionType.normal;
/** @const {number} */
Windows.UI.Text.SelectionType.inlineShape;
/** @const {number} */
Windows.UI.Text.SelectionType.shape;

/** @const */
Windows.UI.Text.TabAlignment = {};
/** @const {number} */
Windows.UI.Text.TabAlignment.left;
/** @const {number} */
Windows.UI.Text.TabAlignment.center;
/** @const {number} */
Windows.UI.Text.TabAlignment.right;
/** @const {number} */
Windows.UI.Text.TabAlignment.decimal;
/** @const {number} */
Windows.UI.Text.TabAlignment.bar;

/** @const */
Windows.UI.Text.TabLeader = {};
/** @const {number} */
Windows.UI.Text.TabLeader.spaces;
/** @const {number} */
Windows.UI.Text.TabLeader.dots;
/** @const {number} */
Windows.UI.Text.TabLeader.dashes;
/** @const {number} */
Windows.UI.Text.TabLeader.lines;
/** @const {number} */
Windows.UI.Text.TabLeader.thickLines;
/** @const {number} */
Windows.UI.Text.TabLeader.equals;

/** @const */
Windows.UI.Text.TextGetOptions = {};
/** @const {number} */
Windows.UI.Text.TextGetOptions.none;
/** @const {number} */
Windows.UI.Text.TextGetOptions.adjustCrlf;
/** @const {number} */
Windows.UI.Text.TextGetOptions.useCrlf;
/** @const {number} */
Windows.UI.Text.TextGetOptions.useObjectText;
/** @const {number} */
Windows.UI.Text.TextGetOptions.allowFinalEop;
/** @const {number} */
Windows.UI.Text.TextGetOptions.noHidden;
/** @const {number} */
Windows.UI.Text.TextGetOptions.includeNumbering;
/** @const {number} */
Windows.UI.Text.TextGetOptions.formatRtf;

/** @const */
Windows.UI.Text.TextRangeUnit = {};
/** @const {number} */
Windows.UI.Text.TextRangeUnit.character;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.word;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.sentence;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.paragraph;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.line;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.story;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.screen;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.section;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.window;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.characterFormat;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.paragraphFormat;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.object;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.hardParagraph;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.cluster;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.bold;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.italic;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.underline;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.strikethrough;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.protectedText;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.link;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.smallCaps;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.allCaps;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.hidden;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.outline;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.shadow;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.imprint;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.disabled;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.revised;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.subscript;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.superscript;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.fontBound;
/** @const {number} */
Windows.UI.Text.TextRangeUnit.linkProtected;

/** @const */
Windows.UI.Text.TextScript = {};
/** @const {number} */
Windows.UI.Text.TextScript.undefined;
/** @const {number} */
Windows.UI.Text.TextScript.ansi;
/** @const {number} */
Windows.UI.Text.TextScript.eastEurope;
/** @const {number} */
Windows.UI.Text.TextScript.cyrillic;
/** @const {number} */
Windows.UI.Text.TextScript.greek;
/** @const {number} */
Windows.UI.Text.TextScript.turkish;
/** @const {number} */
Windows.UI.Text.TextScript.hebrew;
/** @const {number} */
Windows.UI.Text.TextScript.arabic;
/** @const {number} */
Windows.UI.Text.TextScript.baltic;
/** @const {number} */
Windows.UI.Text.TextScript.vietnamese;
/** @const {number} */
Windows.UI.Text.TextScript.default;
/** @const {number} */
Windows.UI.Text.TextScript.symbol;
/** @const {number} */
Windows.UI.Text.TextScript.thai;
/** @const {number} */
Windows.UI.Text.TextScript.shiftJis;
/** @const {number} */
Windows.UI.Text.TextScript.gb2312;
/** @const {number} */
Windows.UI.Text.TextScript.hangul;
/** @const {number} */
Windows.UI.Text.TextScript.big5;
/** @const {number} */
Windows.UI.Text.TextScript.pc437;
/** @const {number} */
Windows.UI.Text.TextScript.oem;
/** @const {number} */
Windows.UI.Text.TextScript.mac;
/** @const {number} */
Windows.UI.Text.TextScript.armenian;
/** @const {number} */
Windows.UI.Text.TextScript.syriac;
/** @const {number} */
Windows.UI.Text.TextScript.thaana;
/** @const {number} */
Windows.UI.Text.TextScript.devanagari;
/** @const {number} */
Windows.UI.Text.TextScript.bengali;
/** @const {number} */
Windows.UI.Text.TextScript.gurmukhi;
/** @const {number} */
Windows.UI.Text.TextScript.gujarati;
/** @const {number} */
Windows.UI.Text.TextScript.oriya;
/** @const {number} */
Windows.UI.Text.TextScript.tamil;
/** @const {number} */
Windows.UI.Text.TextScript.telugu;
/** @const {number} */
Windows.UI.Text.TextScript.kannada;
/** @const {number} */
Windows.UI.Text.TextScript.malayalam;
/** @const {number} */
Windows.UI.Text.TextScript.sinhala;
/** @const {number} */
Windows.UI.Text.TextScript.lao;
/** @const {number} */
Windows.UI.Text.TextScript.tibetan;
/** @const {number} */
Windows.UI.Text.TextScript.myanmar;
/** @const {number} */
Windows.UI.Text.TextScript.georgian;
/** @const {number} */
Windows.UI.Text.TextScript.jamo;
/** @const {number} */
Windows.UI.Text.TextScript.ethiopic;
/** @const {number} */
Windows.UI.Text.TextScript.cherokee;
/** @const {number} */
Windows.UI.Text.TextScript.aboriginal;
/** @const {number} */
Windows.UI.Text.TextScript.ogham;
/** @const {number} */
Windows.UI.Text.TextScript.runic;
/** @const {number} */
Windows.UI.Text.TextScript.khmer;
/** @const {number} */
Windows.UI.Text.TextScript.mongolian;
/** @const {number} */
Windows.UI.Text.TextScript.braille;
/** @const {number} */
Windows.UI.Text.TextScript.yi;
/** @const {number} */
Windows.UI.Text.TextScript.limbu;
/** @const {number} */
Windows.UI.Text.TextScript.taiLe;
/** @const {number} */
Windows.UI.Text.TextScript.newTaiLue;
/** @const {number} */
Windows.UI.Text.TextScript.sylotiNagri;
/** @const {number} */
Windows.UI.Text.TextScript.kharoshthi;
/** @const {number} */
Windows.UI.Text.TextScript.kayahli;
/** @const {number} */
Windows.UI.Text.TextScript.unicodeSymbol;
/** @const {number} */
Windows.UI.Text.TextScript.emoji;
/** @const {number} */
Windows.UI.Text.TextScript.glagolitic;
/** @const {number} */
Windows.UI.Text.TextScript.lisu;
/** @const {number} */
Windows.UI.Text.TextScript.vai;
/** @const {number} */
Windows.UI.Text.TextScript.nko;
/** @const {number} */
Windows.UI.Text.TextScript.osmanya;
/** @const {number} */
Windows.UI.Text.TextScript.phagsPa;
/** @const {number} */
Windows.UI.Text.TextScript.gothic;
/** @const {number} */
Windows.UI.Text.TextScript.deseret;
/** @const {number} */
Windows.UI.Text.TextScript.tifinagh;

/** @const */
Windows.UI.Text.TextSetOptions = {};
/** @const {number} */
Windows.UI.Text.TextSetOptions.none;
/** @const {number} */
Windows.UI.Text.TextSetOptions.unicodeBidi;
/** @const {number} */
Windows.UI.Text.TextSetOptions.unlink;
/** @const {number} */
Windows.UI.Text.TextSetOptions.unhide;
/** @const {number} */
Windows.UI.Text.TextSetOptions.checkTextLimit;
/** @const {number} */
Windows.UI.Text.TextSetOptions.formatRtf;
/** @const {number} */
Windows.UI.Text.TextSetOptions.applyRtfDocumentDefaults;

/** @const */
Windows.UI.Text.UnderlineType = {};
/** @const {number} */
Windows.UI.Text.UnderlineType.undefined;
/** @const {number} */
Windows.UI.Text.UnderlineType.none;
/** @const {number} */
Windows.UI.Text.UnderlineType.single;
/** @const {number} */
Windows.UI.Text.UnderlineType.words;
/** @const {number} */
Windows.UI.Text.UnderlineType.double;
/** @const {number} */
Windows.UI.Text.UnderlineType.dotted;
/** @const {number} */
Windows.UI.Text.UnderlineType.dash;
/** @const {number} */
Windows.UI.Text.UnderlineType.dashDot;
/** @const {number} */
Windows.UI.Text.UnderlineType.dashDotDot;
/** @const {number} */
Windows.UI.Text.UnderlineType.wave;
/** @const {number} */
Windows.UI.Text.UnderlineType.thick;
/** @const {number} */
Windows.UI.Text.UnderlineType.thin;
/** @const {number} */
Windows.UI.Text.UnderlineType.doubleWave;
/** @const {number} */
Windows.UI.Text.UnderlineType.heavyWave;
/** @const {number} */
Windows.UI.Text.UnderlineType.longDash;
/** @const {number} */
Windows.UI.Text.UnderlineType.thickDash;
/** @const {number} */
Windows.UI.Text.UnderlineType.thickDashDot;
/** @const {number} */
Windows.UI.Text.UnderlineType.thickDashDotDot;
/** @const {number} */
Windows.UI.Text.UnderlineType.thickDotted;
/** @const {number} */
Windows.UI.Text.UnderlineType.thickLongDash;

/** @const */
Windows.UI.Text.VerticalCharacterAlignment = {};
/** @const {number} */
Windows.UI.Text.VerticalCharacterAlignment.top;
/** @const {number} */
Windows.UI.Text.VerticalCharacterAlignment.baseline;
/** @const {number} */
Windows.UI.Text.VerticalCharacterAlignment.bottom;
/**
 * @record
 * @struct
 */
Windows.UI.Text.FontWeight = function() {};
 /** @type {number} */
Windows.UI.Text.FontWeight.prototype.weight;
/** @const */
Windows.UI.ViewManagement = {};

/**
 * @constructor
 * @struct
 * Initializes a new AccessibilitySettings object.
 */
Windows.UI.ViewManagement.AccessibilitySettings = function() {};
 /** @type {boolean} */
Windows.UI.ViewManagement.AccessibilitySettings.prototype.highContrast;
 /** @type {string} */
Windows.UI.ViewManagement.AccessibilitySettings.prototype.highContrastScheme;
 /** @type {function(?): void} */
Windows.UI.ViewManagement.AccessibilitySettings.prototype.onhighcontrastchanged;

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.ViewManagement.AccessibilitySettings.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.ViewManagement.AccessibilitySettings.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.ViewManagement.ActivationViewSwitcher = function() {};
 /** @type {?} */
Windows.UI.ViewManagement.ActivationViewSwitcher.prototype.isViewPresentedOnActivationVirtualDesktop;

/**
 * Shows the view in a new standalone window and sets the size preference for the view.
 * Shows the view in a new standalone window.
 * @param {number} viewId The identifier for the view.
 * @param {Windows.UI.ViewManagement.ViewSizePreference=} sizePreference The preferred size of the view.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The asynchronous results of the operation. Use this to determine when the async call is complete.
 */
Windows.UI.ViewManagement.ActivationViewSwitcher.prototype.showAsStandaloneAsync = function(viewId, sizePreference) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.ViewManagement.ApplicationView = function() {};
 /** @type {!Windows.Foundation.Size} */
Windows.UI.ViewManagement.ApplicationView.preferredLaunchViewSize;
 /** @type {Windows.UI.ViewManagement.ApplicationViewWindowingMode} */
Windows.UI.ViewManagement.ApplicationView.preferredLaunchWindowingMode;
 /** @type {boolean} */
Windows.UI.ViewManagement.ApplicationView.terminateAppOnFinalViewClose;
 /** @type {?} */
Windows.UI.ViewManagement.ApplicationView.tryUnsnapToFullscreen;
 /** @type {Windows.UI.ViewManagement.ApplicationViewState} */
Windows.UI.ViewManagement.ApplicationView.value;
 /** @type {boolean} */
Windows.UI.ViewManagement.ApplicationView.prototype.adjacentToLeftDisplayEdge;
 /** @type {boolean} */
Windows.UI.ViewManagement.ApplicationView.prototype.adjacentToRightDisplayEdge;
 /** @type {Windows.UI.ViewManagement.ApplicationViewBoundsMode} */
Windows.UI.ViewManagement.ApplicationView.prototype.desiredBoundsMode;
 /** @type {Windows.UI.ViewManagement.FullScreenSystemOverlayMode} */
Windows.UI.ViewManagement.ApplicationView.prototype.fullScreenSystemOverlayMode;
 /** @type {number} */
Windows.UI.ViewManagement.ApplicationView.prototype.id;
 /** @type {boolean} */
Windows.UI.ViewManagement.ApplicationView.prototype.isFullScreen;
 /** @type {?} */
Windows.UI.ViewManagement.ApplicationView.prototype.isFullScreenMode;
 /** @type {boolean} */
Windows.UI.ViewManagement.ApplicationView.prototype.isOnLockScreen;
 /** @type {boolean} */
Windows.UI.ViewManagement.ApplicationView.prototype.isScreenCaptureEnabled;
 /** @type {function(?): void} */
Windows.UI.ViewManagement.ApplicationView.prototype.onconsolidated;
 /** @type {function(?): void} */
Windows.UI.ViewManagement.ApplicationView.prototype.onvisibleboundschanged;
 /** @type {Windows.UI.ViewManagement.ApplicationViewOrientation} */
Windows.UI.ViewManagement.ApplicationView.prototype.orientation;
 /** @type {boolean} */
Windows.UI.ViewManagement.ApplicationView.prototype.suppressSystemOverlays;
 /** @type {string} */
Windows.UI.ViewManagement.ApplicationView.prototype.title;
 /** @type {!Windows.UI.ViewManagement.ApplicationViewTitleBar} */
Windows.UI.ViewManagement.ApplicationView.prototype.titleBar;
 /** @type {!Windows.Foundation.Rect} */
Windows.UI.ViewManagement.ApplicationView.prototype.visibleBounds;

/**
 * Gets the view state and behavior settings of the active application.
 * @return {!Windows.UI.ViewManagement.ApplicationView} An ApplicationView instance that can be used to get and set app display properties.
 */
Windows.UI.ViewManagement.ApplicationView.getForCurrentView = function() {};

/**
 * Attempts to unsnap a previously snapped app. This call will only succeed when the app is running in the foreground.
 * @return {boolean} true if the app has been successfully unsnapped; false if the unsnap attempt failed.
 */
Windows.UI.ViewManagement.ApplicationView.tryUnsnap = function() {};

/**
 * Takes the app out of full-screen mode.
 * @return {void}
 */
Windows.UI.ViewManagement.ApplicationView.prototype.exitFullScreenMode = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.ViewManagement.ApplicationView.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.ViewManagement.ApplicationView.prototype.removeEventListener = function(type, listener) {};

/**
 * Sets a value indicating the bounds used by the framework to lay out the contents of the window (app view).
 * @param {Windows.UI.ViewManagement.ApplicationViewBoundsMode} boundsMode The bounds that the framework should use to lay out the contents of the window (app view).
 * @return {boolean} true to confirm that the change to DesiredBoundsMode was successful; otherwise, false.
 */
Windows.UI.ViewManagement.ApplicationView.prototype.setDesiredBoundsMode = function(boundsMode) {};

/**
 * Sets the smallest size, in effective pixels, allowed for the app window.
 * @param {!Windows.Foundation.Size} minSize The smallest size allowed for the app window, or a Size whose height and width are both zero to use the system default minimum size.
 * @return {void}
 */
Windows.UI.ViewManagement.ApplicationView.prototype.setPreferredMinSize = function(minSize) {};

/**
 * Shows system UI elements, like the title bar, over a full-screen app.
 * @return {void}
 */
Windows.UI.ViewManagement.ApplicationView.prototype.showStandardSystemOverlays = function() {};

/**
 * Attempts to place the app in full-screen mode.
 * @return {boolean} true if the app is placed in full-screen mode; otherwise, false.
 */
Windows.UI.ViewManagement.ApplicationView.prototype.tryEnterFullScreenMode = function() {};

/**
 * Attempts to change the size of the view to the specified size.
 * @param {!Windows.Foundation.Size} value The new size of the view.
 * @return {boolean} true if the view is resized; otherwise, false.
 */
Windows.UI.ViewManagement.ApplicationView.prototype.tryResizeView = function(value) {};

/** @const */
Windows.UI.ViewManagement.ApplicationViewBoundsMode = {};
/** @const {number} */
Windows.UI.ViewManagement.ApplicationViewBoundsMode.useVisible;
/** @const {number} */
Windows.UI.ViewManagement.ApplicationViewBoundsMode.useCoreWindow;
/**
 * @constructor
 * @struct
 */
Windows.UI.ViewManagement.ApplicationViewConsolidatedEventArgs = function() {};
 /** @type {boolean} */
Windows.UI.ViewManagement.ApplicationViewConsolidatedEventArgs.prototype.isUserInitiated;

/** @const */
Windows.UI.ViewManagement.ApplicationViewOrientation = {};
/** @const {number} */
Windows.UI.ViewManagement.ApplicationViewOrientation.landscape;
/** @const {number} */
Windows.UI.ViewManagement.ApplicationViewOrientation.portrait;

/** @const */
Windows.UI.ViewManagement.ApplicationViewState = {};
/** @const {number} */
Windows.UI.ViewManagement.ApplicationViewState.fullScreenLandscape;
/** @const {number} */
Windows.UI.ViewManagement.ApplicationViewState.filled;
/** @const {number} */
Windows.UI.ViewManagement.ApplicationViewState.snapped;
/** @const {number} */
Windows.UI.ViewManagement.ApplicationViewState.fullScreenPortrait;
/**
 * @constructor
 * @struct
 */
Windows.UI.ViewManagement.ApplicationViewSwitcher = function() {};
 /** @type {?} */
Windows.UI.ViewManagement.ApplicationViewSwitcher.disableSystemViewActivationPolicy;

/**
 * Disables the primary window (app view) when the app is activated, showing the most recently displayed window instead.
 * @return {void}
 */
Windows.UI.ViewManagement.ApplicationViewSwitcher.disableShowingMainViewOnActivation = function() {};

/**
 * Prepares your app to visually transition between two windows with a custom animation.
 * @param {number} toViewId The ID of the window from which your app is transitioning.
 * @param {number} fromViewId The ID of the window to which your app is transitioning.
 * @param {Windows.UI.ViewManagement.ApplicationViewSwitchingOptions} options Enumeration value that specifies thw view switching behaviors.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} Asynchronously returns true if the call succeeds; false if it does not.
 */
Windows.UI.ViewManagement.ApplicationViewSwitcher.prepareForCustomAnimatedSwitchAsync = function(toViewId, fromViewId, options) {};

/**
 * Visually replaces the calling window (app view) with a specified window.
 * Visually replaces the calling window (app view) with a specified window.
 * Visually replaces the calling window (app view) with a specified window.
 * @param {number} viewId_or_toViewId The ID of the window under preparation for display.
 * @param {number=} fromViewId The ID of the calling, currently displayed window.
 * @param {Windows.UI.ViewManagement.ApplicationViewSwitchingOptions=} options Options for the display transition behaviors.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The asynchronous results of the operation. Use this to determine when the async call is complete.
 */
Windows.UI.ViewManagement.ApplicationViewSwitcher.switchAsync = function(viewId_or_toViewId, fromViewId, options) {};

/**
 * Displays another window (app view) for the app on the screen, adjacent to the original window.
 * Displays another window (app view) for the app on the screen, adjacent to the original window
 * Displays another window (app view) for the app on the screen, adjacent to the original window
 * @param {number} viewId The ID of the new window to display.
 * @param {Windows.UI.ViewManagement.ViewSizePreference=} sizePreference The preferred general sizing of the new window.
 * @param {number=} anchorViewId The ID of the calling (anchor) window.
 * @param {Windows.UI.ViewManagement.ViewSizePreference=} anchorSizePreference The preferred new general sizing of the calling window if this call succeeds.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} Asynchronously returns true if the call succeeds; false if it does not.
 */
Windows.UI.ViewManagement.ApplicationViewSwitcher.tryShowAsStandaloneAsync = function(viewId, sizePreference, anchorViewId, anchorSizePreference) {};

/** @const */
Windows.UI.ViewManagement.ApplicationViewSwitchingOptions = {};
/** @const {number} */
Windows.UI.ViewManagement.ApplicationViewSwitchingOptions.default;
/** @const {number} */
Windows.UI.ViewManagement.ApplicationViewSwitchingOptions.skipAnimation;
/** @const {number} */
Windows.UI.ViewManagement.ApplicationViewSwitchingOptions.consolidateViews;
/**
 * @constructor
 * @struct
 */
Windows.UI.ViewManagement.ApplicationViewTitleBar = function() {};
 /** @type {!Windows.UI.Color} */
Windows.UI.ViewManagement.ApplicationViewTitleBar.prototype.backgroundColor;
 /** @type {!Windows.UI.Color} */
Windows.UI.ViewManagement.ApplicationViewTitleBar.prototype.buttonBackgroundColor;
 /** @type {!Windows.UI.Color} */
Windows.UI.ViewManagement.ApplicationViewTitleBar.prototype.buttonForegroundColor;
 /** @type {!Windows.UI.Color} */
Windows.UI.ViewManagement.ApplicationViewTitleBar.prototype.buttonHoverBackgroundColor;
 /** @type {!Windows.UI.Color} */
Windows.UI.ViewManagement.ApplicationViewTitleBar.prototype.buttonHoverForegroundColor;
 /** @type {!Windows.UI.Color} */
Windows.UI.ViewManagement.ApplicationViewTitleBar.prototype.buttonInactiveBackgroundColor;
 /** @type {!Windows.UI.Color} */
Windows.UI.ViewManagement.ApplicationViewTitleBar.prototype.buttonInactiveForegroundColor;
 /** @type {!Windows.UI.Color} */
Windows.UI.ViewManagement.ApplicationViewTitleBar.prototype.buttonPressedBackgroundColor;
 /** @type {!Windows.UI.Color} */
Windows.UI.ViewManagement.ApplicationViewTitleBar.prototype.buttonPressedForegroundColor;
 /** @type {!Windows.UI.Color} */
Windows.UI.ViewManagement.ApplicationViewTitleBar.prototype.foregroundColor;
 /** @type {!Windows.UI.Color} */
Windows.UI.ViewManagement.ApplicationViewTitleBar.prototype.inactiveBackgroundColor;
 /** @type {!Windows.UI.Color} */
Windows.UI.ViewManagement.ApplicationViewTitleBar.prototype.inactiveForegroundColor;
/**
 * @constructor
 * @struct
 */
Windows.UI.ViewManagement.ApplicationViewTransferContext = function() {};
 /** @type {?} */
Windows.UI.ViewManagement.ApplicationViewTransferContext.dataPackageFormatId;
 /** @type {?} */
Windows.UI.ViewManagement.ApplicationViewTransferContext.prototype.viewId;

/** @const */
Windows.UI.ViewManagement.ApplicationViewWindowingMode = {};
/** @const {number} */
Windows.UI.ViewManagement.ApplicationViewWindowingMode.auto;
/** @const {number} */
Windows.UI.ViewManagement.ApplicationViewWindowingMode.preferredLaunchViewSize;
/** @const {number} */
Windows.UI.ViewManagement.ApplicationViewWindowingMode.fullScreen;

/** @const */
Windows.UI.ViewManagement.FullScreenSystemOverlayMode = {};
/** @const {number} */
Windows.UI.ViewManagement.FullScreenSystemOverlayMode.standard;
/** @const {number} */
Windows.UI.ViewManagement.FullScreenSystemOverlayMode.minimal;

/** @const */
Windows.UI.ViewManagement.HandPreference = {};
/** @const {number} */
Windows.UI.ViewManagement.HandPreference.leftHanded;
/** @const {number} */
Windows.UI.ViewManagement.HandPreference.rightHanded;
/**
 * @constructor
 * @struct
 */
Windows.UI.ViewManagement.InputPane = function() {};
 /** @type {!Windows.Foundation.Rect} */
Windows.UI.ViewManagement.InputPane.prototype.occludedRect;
 /** @type {function(?): void} */
Windows.UI.ViewManagement.InputPane.prototype.onhiding;
 /** @type {function(?): void} */
Windows.UI.ViewManagement.InputPane.prototype.onshowing;
 /** @type {boolean} */
Windows.UI.ViewManagement.InputPane.prototype.visible;

/**
 * Gets the InputPane object associated with the application window that is currently visible.
 * @return {!Windows.UI.ViewManagement.InputPane} The input pane.
 */
Windows.UI.ViewManagement.InputPane.getForCurrentView = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.ViewManagement.InputPane.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.ViewManagement.InputPane.prototype.removeEventListener = function(type, listener) {};

/**
 * Hides the InputPane if it is showing.
 * @return {boolean} true if the InputPane was hidden successfully; otherwise false.
 */
Windows.UI.ViewManagement.InputPane.prototype.tryHide = function() {};

/**
 * Shows the InputPane if it is hidden.
 * @return {boolean} true if the InputPane was shown successfully; otherwise false.
 */
Windows.UI.ViewManagement.InputPane.prototype.tryShow = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.ViewManagement.InputPaneVisibilityEventArgs = function() {};
 /** @type {boolean} */
Windows.UI.ViewManagement.InputPaneVisibilityEventArgs.prototype.ensuredFocusedElementInView;
 /** @type {!Windows.Foundation.Rect} */
Windows.UI.ViewManagement.InputPaneVisibilityEventArgs.prototype.occludedRect;
/**
 * @constructor
 * @struct
 */
Windows.UI.ViewManagement.ProjectionManager = function() {};
 /** @type {function(?): void} */
Windows.UI.ViewManagement.ProjectionManager.onprojectiondisplayavailablechanged;
 /** @type {boolean} */
Windows.UI.ViewManagement.ProjectionManager.projectionDisplayAvailable;

/**
 * Returns a string that is used to enumerate device services.
 * @return {string} A string that is used to enumerate device services.
 */
Windows.UI.ViewManagement.ProjectionManager.getDeviceSelector = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.ViewManagement.ProjectionManager.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.ViewManagement.ProjectionManager.removeEventListener = function(type, listener) {};

/**
 * Makes a request to asynchronously sends a window (app view) to the projector or other secondary display with the specified preferred placement.
 * Makes a request to asynchronously sends a window (app view) to the projector or other secondary display.
 * @param {number} projectionViewId The new ID of the window to be displayed by the projector or other secondary display.
 * @param {number} anchorViewId The ID of the original window before projection.
 * @param {!Windows.Foundation.Rect} selection The area to one side of which the flyout is displayed.
 * @param {Windows.UI.Popups.Placement=} prefferedPlacement The side of the rectangle where the flyout should appear.
 * @return {!Windows.Foundation.IPromiseWithOperation<boolean, !Windows.Foundation.IAsyncOperation<boolean>>} true if projection started; otherwise, false.
 */
Windows.UI.ViewManagement.ProjectionManager.requestStartProjectingAsync = function(projectionViewId, anchorViewId, selection, prefferedPlacement) {};

/**
 * Asynchronously sends a window (app view) to the projector or other secondary display.
 * Asynchronously sends a window (app view) to the projector or other secondary display, and provides info about the display.
 * @param {number} projectionViewId The new ID of the window to be displayed by the projector or other secondary display.
 * @param {number} anchorViewId The ID of the original window before projection.
 * @param {!Windows.Devices.Enumeration.DeviceInformation=} displayDeviceInfo Information about the display device.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The asynchronous results of the operation. Use this to determine when the async call is complete.
 */
Windows.UI.ViewManagement.ProjectionManager.startProjectingAsync = function(projectionViewId, anchorViewId, displayDeviceInfo) {};

/**
 * Asynchronously hides a window (app view) displayed by a projector or other secondary display.
 * @param {number} projectionViewId The ID of the window currently displayed by the projector or other secondary display.
 * @param {number} anchorViewId The ID of the original window before projection.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The asynchronous results of the operation. Use this to determine when the async call is complete.
 */
Windows.UI.ViewManagement.ProjectionManager.stopProjectingAsync = function(projectionViewId, anchorViewId) {};

/**
 * Asynchronously swaps the calling window (app view) with the window displayed on the projector or other secondary display. The result is that the calling window is displayed on the projector, and the formerly projected window is displayed on the device screen.
 * @param {number} projectionViewId The ID of the window currently displayed by the projector.
 * @param {number} anchorViewId The ID of the window to swap with the projected window.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncAction>} The asynchronous results of the operation. Use this to determine when the async call is complete.
 */
Windows.UI.ViewManagement.ProjectionManager.swapDisplaysForViewsAsync = function(projectionViewId, anchorViewId) {};

/** @const */
Windows.UI.ViewManagement.UIColorType = {};
/** @const {number} */
Windows.UI.ViewManagement.UIColorType.background;
/** @const {number} */
Windows.UI.ViewManagement.UIColorType.foreground;
/** @const {number} */
Windows.UI.ViewManagement.UIColorType.accentDark3;
/** @const {number} */
Windows.UI.ViewManagement.UIColorType.accentDark2;
/** @const {number} */
Windows.UI.ViewManagement.UIColorType.accentDark1;
/** @const {number} */
Windows.UI.ViewManagement.UIColorType.accent;
/** @const {number} */
Windows.UI.ViewManagement.UIColorType.accentLight1;
/** @const {number} */
Windows.UI.ViewManagement.UIColorType.accentLight2;
/** @const {number} */
Windows.UI.ViewManagement.UIColorType.accentLight3;
/** @const {number} */
Windows.UI.ViewManagement.UIColorType.complement;

/** @const */
Windows.UI.ViewManagement.UIElementType = {};
/** @const {number} */
Windows.UI.ViewManagement.UIElementType.activeCaption;
/** @const {number} */
Windows.UI.ViewManagement.UIElementType.background;
/** @const {number} */
Windows.UI.ViewManagement.UIElementType.buttonFace;
/** @const {number} */
Windows.UI.ViewManagement.UIElementType.buttonText;
/** @const {number} */
Windows.UI.ViewManagement.UIElementType.captionText;
/** @const {number} */
Windows.UI.ViewManagement.UIElementType.grayText;
/** @const {number} */
Windows.UI.ViewManagement.UIElementType.highlight;
/** @const {number} */
Windows.UI.ViewManagement.UIElementType.highlightText;
/** @const {number} */
Windows.UI.ViewManagement.UIElementType.hotlight;
/** @const {number} */
Windows.UI.ViewManagement.UIElementType.inactiveCaption;
/** @const {number} */
Windows.UI.ViewManagement.UIElementType.inactiveCaptionText;
/** @const {number} */
Windows.UI.ViewManagement.UIElementType.window;
/** @const {number} */
Windows.UI.ViewManagement.UIElementType.windowText;

/**
 * @constructor
 * @struct
 * Creates a new default instance of the UISettings class.
 */
Windows.UI.ViewManagement.UISettings = function() {};
 /** @type {boolean} */
Windows.UI.ViewManagement.UISettings.prototype.animationsEnabled;
 /** @type {number} */
Windows.UI.ViewManagement.UISettings.prototype.caretBlinkRate;
 /** @type {boolean} */
Windows.UI.ViewManagement.UISettings.prototype.caretBrowsingEnabled;
 /** @type {number} */
Windows.UI.ViewManagement.UISettings.prototype.caretWidth;
 /** @type {!Windows.Foundation.Size} */
Windows.UI.ViewManagement.UISettings.prototype.cursorSize;
 /** @type {number} */
Windows.UI.ViewManagement.UISettings.prototype.doubleClickTime;
 /** @type {Windows.UI.ViewManagement.HandPreference} */
Windows.UI.ViewManagement.UISettings.prototype.handPreference;
 /** @type {number} */
Windows.UI.ViewManagement.UISettings.prototype.messageDuration;
 /** @type {number} */
Windows.UI.ViewManagement.UISettings.prototype.mouseHoverTime;
 /** @type {function(?): void} */
Windows.UI.ViewManagement.UISettings.prototype.oncolorvalueschanged;
 /** @type {function(?): void} */
Windows.UI.ViewManagement.UISettings.prototype.ontextscalefactorchanged;
 /** @type {!Windows.Foundation.Size} */
Windows.UI.ViewManagement.UISettings.prototype.scrollBarArrowSize;
 /** @type {!Windows.Foundation.Size} */
Windows.UI.ViewManagement.UISettings.prototype.scrollBarSize;
 /** @type {!Windows.Foundation.Size} */
Windows.UI.ViewManagement.UISettings.prototype.scrollBarThumbBoxSize;
 /** @type {number} */
Windows.UI.ViewManagement.UISettings.prototype.textScaleFactor;

/**
 * Returns the color value of the specified color type.
 * @param {Windows.UI.ViewManagement.UIColorType} desiredColor An enumeration value that specifies the type of color to get a value for.
 * @return {!Windows.UI.Color} The color value of the specified color type.
 */
Windows.UI.ViewManagement.UISettings.prototype.getColorValue = function(desiredColor) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.ViewManagement.UISettings.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.ViewManagement.UISettings.prototype.removeEventListener = function(type, listener) {};

/**
 * Gets the color used for a specific user interface element type, such as a button face or window text.
 * @param {Windows.UI.ViewManagement.UIElementType} desiredElement The type of element for which the color will be obtained.
 * @return {!Windows.UI.Color} The color of the element type, expressed as a 32-bit color value.
 */
Windows.UI.ViewManagement.UISettings.prototype.uiElementColor = function(desiredElement) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.ViewManagement.UIViewSettings = function() {};
 /** @type {Windows.UI.ViewManagement.UserInteractionMode} */
Windows.UI.ViewManagement.UIViewSettings.prototype.userInteractionMode;

/**
 * Gets the UI states and behaviors associated with the device mode (Tablet or Desktop) for the active app.
 * @return {!Windows.UI.ViewManagement.UIViewSettings} A UIViewSettings instance that can be used to get and set view settings properties.
 */
Windows.UI.ViewManagement.UIViewSettings.getForCurrentView = function() {};

/** @const */
Windows.UI.ViewManagement.UserInteractionMode = {};
/** @const {number} */
Windows.UI.ViewManagement.UserInteractionMode.mouse;
/** @const {number} */
Windows.UI.ViewManagement.UserInteractionMode.touch;

/** @const */
Windows.UI.ViewManagement.ViewSizePreference = {};
/** @const {number} */
Windows.UI.ViewManagement.ViewSizePreference.default;
/** @const {number} */
Windows.UI.ViewManagement.ViewSizePreference.useLess;
/** @const {number} */
Windows.UI.ViewManagement.ViewSizePreference.useHalf;
/** @const {number} */
Windows.UI.ViewManagement.ViewSizePreference.useMore;
/** @const {number} */
Windows.UI.ViewManagement.ViewSizePreference.useMinimum;
/** @const {number} */
Windows.UI.ViewManagement.ViewSizePreference.useNone;
/** @const */
Windows.UI.WebUI = {};
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.ActivatedDeferral = function() {};

/**
 * Notifies the system that the app has set up its state and initial UI and is ready to be displayed.
 * @return {void}
 */
Windows.UI.WebUI.ActivatedDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.ActivatedOperation = function() {};

/**
 * Requests that the completion of app activation be delayed.
 * @return {!Windows.UI.WebUI.ActivatedDeferral} The activation deferral object.
 */
Windows.UI.WebUI.ActivatedOperation.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.HtmlPrintDocumentSource = function() {};
 /** @type {number} */
Windows.UI.WebUI.HtmlPrintDocumentSource.prototype.bottomMargin;
 /** @type {Windows.UI.WebUI.PrintContent} */
Windows.UI.WebUI.HtmlPrintDocumentSource.prototype.content;
 /** @type {boolean} */
Windows.UI.WebUI.HtmlPrintDocumentSource.prototype.enableHeaderFooter;
 /** @type {number} */
Windows.UI.WebUI.HtmlPrintDocumentSource.prototype.leftMargin;
 /** @type {string} */
Windows.UI.WebUI.HtmlPrintDocumentSource.prototype.pageRange;
 /** @type {number} */
Windows.UI.WebUI.HtmlPrintDocumentSource.prototype.percentScale;
 /** @type {number} */
Windows.UI.WebUI.HtmlPrintDocumentSource.prototype.rightMargin;
 /** @type {boolean} */
Windows.UI.WebUI.HtmlPrintDocumentSource.prototype.shrinkToFit;
 /** @type {number} */
Windows.UI.WebUI.HtmlPrintDocumentSource.prototype.topMargin;

/**
 * Performs app-defined tasks that are associated with freeing, releasing, or resetting resources that were allocated for the document source.
 * @return {void}
 */
Windows.UI.WebUI.HtmlPrintDocumentSource.prototype.close = function() {};

/**
 * Tries to set the page range of the document source.
 * @param {string} strPageRange The page range to set.
 * @return {boolean} A Boolean value that indicates whether trySetPageRange set the page range in strPageRange. TRUE indicates the page range was set and FALSE otherwise.
 */
Windows.UI.WebUI.HtmlPrintDocumentSource.prototype.trySetPageRange = function(strPageRange) {};

/** @const */
Windows.UI.WebUI.PrintContent = {};
/** @const {number} */
Windows.UI.WebUI.PrintContent.allPages;
/** @const {number} */
Windows.UI.WebUI.PrintContent.currentPage;
/** @const {number} */
Windows.UI.WebUI.PrintContent.customPageRange;
/** @const {number} */
Windows.UI.WebUI.PrintContent.currentSelection;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.SuspendingDeferral = function() {};

/**
 * Notifies the system that the app has saved its data and is ready to be suspended.
 * @return {void}
 */
Windows.UI.WebUI.SuspendingDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.SuspendingEventArgs = function() {};
 /** @type {!Windows.ApplicationModel.SuspendingOperation} */
Windows.UI.WebUI.SuspendingEventArgs.prototype.suspendingOperation;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.SuspendingOperation = function() {};
 /** @type {!Date} */
Windows.UI.WebUI.SuspendingOperation.prototype.deadline;

/**
 * Requests that the app suspension operation be delayed.
 * @return {!Windows.ApplicationModel.SuspendingDeferral} The suspension deferral.
 */
Windows.UI.WebUI.SuspendingOperation.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIApplication = function() {};
 /** @type {function(?): void} */
Windows.UI.WebUI.WebUIApplication.onactivated;
 /** @type {function(?): void} */
Windows.UI.WebUI.WebUIApplication.onnavigated;
 /** @type {function(!Windows.WinRTEvent<?>): void} */
Windows.UI.WebUI.WebUIApplication.onresuming;
 /** @type {function(?): void} */
Windows.UI.WebUI.WebUIApplication.onsuspending;

/**
 * @param {string} type
 * @param {function(?): void|function(!Windows.WinRTEvent<?>): void} listener
 * @return {void}
 */
Windows.UI.WebUI.WebUIApplication.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void|function(!Windows.WinRTEvent<?>): void} listener
 * @return {void}
 */
Windows.UI.WebUI.WebUIApplication.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs.prototype.activatedOperation;
 /** @type {!Windows.ApplicationModel.Appointments.AppointmentsProvider.AddAppointmentOperation} */
Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs.prototype.addAppointmentOperation;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs.prototype.activatedOperation;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Appointments.AppointmentsProvider.RemoveAppointmentOperation} */
Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs.prototype.removeAppointmentOperation;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs.prototype.activatedOperation;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Appointments.AppointmentsProvider.ReplaceAppointmentOperation} */
Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs.prototype.replaceAppointmentOperation;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.activatedOperation;
 /** @type {!Date} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.instanceStartDate;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.kind;
 /** @type {string} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.localId;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.previousExecutionState;
 /** @type {string} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.roamingId;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs.prototype.activatedOperation;
 /** @type {number} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs.prototype.duration;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs.prototype.splashScreen;
 /** @type {!Date} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs.prototype.timeToShow;
 /** @type {string} */
Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIBackgroundTaskInstance = function() {};
 /** @type {!Windows.UI.WebUI.IWebUIBackgroundTaskInstance} */
Windows.UI.WebUI.WebUIBackgroundTaskInstance.current;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass = function() {};
 /** @type {string} */
Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass.prototype.instanceId;
 /** @type {function(?): void} */
Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass.prototype.oncanceled;
 /** @type {number} */
Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass.prototype.progress;
 /** @type {boolean} */
Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass.prototype.succeeded;
 /** @type {number} */
Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass.prototype.suspendedCount;
 /** @type {!Windows.ApplicationModel.Background.BackgroundTaskRegistration} */
Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass.prototype.task;
 /** @type {?} */
Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass.prototype.triggerDetails;

/**
 * Informs the system that the background task might continue to perform work after the IBackgroundTask.Run method returns. This method is not applicable to JavaScript background tasks.
 * @return {!Windows.ApplicationModel.Background.BackgroundTaskDeferral} A background task deferral.
 */
Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass.prototype.getDeferral = function() {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass.prototype.removeEventListener = function(type, listener) {};
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs.prototype.activatedOperation;
 /** @type {!Windows.Storage.Provider.CachedFileUpdaterUI} */
Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs.prototype.cachedFileUpdaterUI;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs.prototype.activatedOperation;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs.prototype.splashScreen;
 /** @type {?} */
Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs.prototype.videoDeviceController;
 /** @type {?} */
Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs.prototype.videoDeviceExtension;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIContactCallActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIContactCallActivatedEventArgs.prototype.activatedOperation;
 /** @type {!Windows.ApplicationModel.Contacts.Contact} */
Windows.UI.WebUI.WebUIContactCallActivatedEventArgs.prototype.contact;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIContactCallActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIContactCallActivatedEventArgs.prototype.previousExecutionState;
 /** @type {string} */
Windows.UI.WebUI.WebUIContactCallActivatedEventArgs.prototype.serviceId;
 /** @type {string} */
Windows.UI.WebUI.WebUIContactCallActivatedEventArgs.prototype.serviceUserId;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIContactCallActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.UI.WebUI.WebUIContactCallActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIContactMapActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIContactMapActivatedEventArgs.prototype.activatedOperation;
 /** @type {!Windows.ApplicationModel.Contacts.ContactAddress} */
Windows.UI.WebUI.WebUIContactMapActivatedEventArgs.prototype.address;
 /** @type {!Windows.ApplicationModel.Contacts.Contact} */
Windows.UI.WebUI.WebUIContactMapActivatedEventArgs.prototype.contact;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIContactMapActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIContactMapActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIContactMapActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.UI.WebUI.WebUIContactMapActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs.prototype.activatedOperation;
 /** @type {!Windows.ApplicationModel.Contacts.Contact} */
Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs.prototype.contact;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs.prototype.previousExecutionState;
 /** @type {string} */
Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs.prototype.serviceId;
 /** @type {string} */
Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs.prototype.serviceUserId;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs.prototype.activatedOperation;
 /** @type {!Windows.ApplicationModel.Contacts.Provider.ContactPickerUI} */
Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs.prototype.contactPickerUI;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIContactPostActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIContactPostActivatedEventArgs.prototype.activatedOperation;
 /** @type {!Windows.ApplicationModel.Contacts.Contact} */
Windows.UI.WebUI.WebUIContactPostActivatedEventArgs.prototype.contact;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIContactPostActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIContactPostActivatedEventArgs.prototype.previousExecutionState;
 /** @type {string} */
Windows.UI.WebUI.WebUIContactPostActivatedEventArgs.prototype.serviceId;
 /** @type {string} */
Windows.UI.WebUI.WebUIContactPostActivatedEventArgs.prototype.serviceUserId;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIContactPostActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.UI.WebUI.WebUIContactPostActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs.prototype.activatedOperation;
 /** @type {!Windows.ApplicationModel.Contacts.Contact} */
Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs.prototype.contact;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs.prototype.previousExecutionState;
 /** @type {string} */
Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs.prototype.serviceId;
 /** @type {string} */
Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs.prototype.serviceUserId;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIDeviceActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIDeviceActivatedEventArgs.prototype.activatedOperation;
 /** @type {number} */
Windows.UI.WebUI.WebUIDeviceActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {string} */
Windows.UI.WebUI.WebUIDeviceActivatedEventArgs.prototype.deviceInformationId;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIDeviceActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIDeviceActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIDeviceActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.UI.WebUI.WebUIDeviceActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs.prototype.activatedOperation;
 /** @type {!Windows.Devices.Enumeration.DeviceInformation} */
Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs.prototype.deviceInformation;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs.prototype.activatedOperation;
 /** @type {string} */
Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs.prototype.appName;
 /** @type {string} */
Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs.prototype.arguments;
 /** @type {number} */
Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs.prototype.tileId;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIFileActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIFileActivatedEventArgs.prototype.activatedOperation;
 /** @type {number} */
Windows.UI.WebUI.WebUIFileActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Storage.IStorageItem>} */
Windows.UI.WebUI.WebUIFileActivatedEventArgs.prototype.files;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIFileActivatedEventArgs.prototype.kind;
 /** @type {!Windows.Storage.Search.StorageFileQueryResult} */
Windows.UI.WebUI.WebUIFileActivatedEventArgs.prototype.neighboringFilesQuery;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIFileActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIFileActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.UI.WebUI.WebUIFileActivatedEventArgs.prototype.verb;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs.prototype.activatedOperation;
 /** @type {string} */
Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs.prototype.callerPackageFamilyName;
 /** @type {!Windows.Storage.Pickers.Provider.FileOpenPickerUI} */
Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs.prototype.fileOpenPickerUI;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs.prototype.activatedOperation;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs.prototype.continuationData;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Storage.StorageFile>} */
Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs.prototype.files;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs.prototype.activatedOperation;
 /** @type {string} */
Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs.prototype.callerPackageFamilyName;
 /** @type {string} */
Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs.prototype.enterpriseId;
 /** @type {!Windows.Storage.Pickers.Provider.FileSavePickerUI} */
Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs.prototype.fileSavePickerUI;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs.prototype.activatedOperation;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs.prototype.continuationData;
 /** @type {!Windows.Storage.StorageFile} */
Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs.prototype.file;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs.prototype.activatedOperation;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs.prototype.continuationData;
 /** @type {!Windows.Storage.StorageFolder} */
Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs.prototype.folder;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUILaunchActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUILaunchActivatedEventArgs.prototype.activatedOperation;
 /** @type {string} */
Windows.UI.WebUI.WebUILaunchActivatedEventArgs.prototype.arguments;
 /** @type {number} */
Windows.UI.WebUI.WebUILaunchActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUILaunchActivatedEventArgs.prototype.kind;
 /** @type {boolean} */
Windows.UI.WebUI.WebUILaunchActivatedEventArgs.prototype.prelaunchActivated;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUILaunchActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUILaunchActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.UI.WebUI.WebUILaunchActivatedEventArgs.prototype.tileId;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUILockScreenActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUILockScreenActivatedEventArgs.prototype.activatedOperation;
 /** @type {number} */
Windows.UI.WebUI.WebUILockScreenActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {?} */
Windows.UI.WebUI.WebUILockScreenActivatedEventArgs.prototype.info;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUILockScreenActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUILockScreenActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUILockScreenActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs.prototype.activatedOperation;
 /** @type {string} */
Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs.prototype.arguments;
 /** @type {!Windows.ApplicationModel.Calls.LockScreenCallUI} */
Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs.prototype.callUI;
 /** @type {number} */
Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs.prototype.splashScreen;
 /** @type {string} */
Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs.prototype.tileId;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUINavigatedDeferral = function() {};

/**
 * Notifies the system that the app has set up its state and UI and is ready to be displayed after a top level navigation.
 * @return {void}
 */
Windows.UI.WebUI.WebUINavigatedDeferral.prototype.complete = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUINavigatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.WebUINavigatedOperation} */
Windows.UI.WebUI.WebUINavigatedEventArgs.prototype.navigatedOperation;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUINavigatedOperation = function() {};

/**
 * Requests that the completion of app navigation be delayed.
 * @return {!Windows.UI.WebUI.WebUINavigatedDeferral} The navigated deferral object.
 */
Windows.UI.WebUI.WebUINavigatedOperation.prototype.getDeferral = function() {};
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs.prototype.activatedOperation;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs.prototype.splashScreen;
 /** @type {!Windows.Devices.Printers.Extensions.Print3DWorkflow} */
Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs.prototype.workflow;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs.prototype.activatedOperation;
 /** @type {!Windows.Devices.Printers.Extensions.PrintTaskConfiguration} */
Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs.prototype.configuration;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIProtocolActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIProtocolActivatedEventArgs.prototype.activatedOperation;
 /** @type {string} */
Windows.UI.WebUI.WebUIProtocolActivatedEventArgs.prototype.callerPackageFamilyName;
 /** @type {number} */
Windows.UI.WebUI.WebUIProtocolActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.UI.WebUI.WebUIProtocolActivatedEventArgs.prototype.data;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIProtocolActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIProtocolActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIProtocolActivatedEventArgs.prototype.splashScreen;
 /** @type {!Windows.Foundation.Uri} */
Windows.UI.WebUI.WebUIProtocolActivatedEventArgs.prototype.uri;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs.prototype.activatedOperation;
 /** @type {string} */
Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs.prototype.callerPackageFamilyName;
 /** @type {number} */
Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs.prototype.data;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.System.ProtocolForResultsOperation} */
Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs.prototype.protocolForResultsOperation;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs.prototype.splashScreen;
 /** @type {!Windows.Foundation.Uri} */
Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs.prototype.uri;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs.prototype.activatedOperation;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs.prototype.previousExecutionState;
 /** @type {?} */
Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs.prototype.sharedContext;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUISearchActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUISearchActivatedEventArgs.prototype.activatedOperation;
 /** @type {number} */
Windows.UI.WebUI.WebUISearchActivatedEventArgs.prototype.currentlyShownApplicationViewId;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUISearchActivatedEventArgs.prototype.kind;
 /** @type {string} */
Windows.UI.WebUI.WebUISearchActivatedEventArgs.prototype.language;
 /** @type {!Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails} */
Windows.UI.WebUI.WebUISearchActivatedEventArgs.prototype.linguisticDetails;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUISearchActivatedEventArgs.prototype.previousExecutionState;
 /** @type {string} */
Windows.UI.WebUI.WebUISearchActivatedEventArgs.prototype.queryText;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUISearchActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs.prototype.activatedOperation;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation} */
Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs.prototype.shareOperation;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs.prototype.activatedOperation;
 /** @type {string} */
Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs.prototype.argument;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs.prototype.splashScreen;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs.prototype.userInput;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs.prototype.activatedOperation;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.Media.SpeechRecognition.SpeechRecognitionResult} */
Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs.prototype.result;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs = function() {};
 /** @type {string} */
Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs.prototype.actionId;
 /** @type {Windows.ApplicationModel.Wallet.WalletActionKind} */
Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs.prototype.actionKind;
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs.prototype.activatedOperation;
 /** @type {string} */
Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs.prototype.itemId;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs.prototype.activatedOperation;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs.prototype.kind;
 /** @type {!Windows.Security.Authentication.Web.Provider.IWebAccountProviderOperation} */
Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs.prototype.operation;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs.prototype.splashScreen;
/**
 * @constructor
 * @struct
 */
Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.ActivatedOperation} */
Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs.prototype.activatedOperation;
 /** @type {!Windows.Foundation.Collections.ValueSet} */
Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs.prototype.continuationData;
 /** @type {Windows.ApplicationModel.Activation.ActivationKind} */
Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs.prototype.kind;
 /** @type {Windows.ApplicationModel.Activation.ApplicationExecutionState} */
Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs.prototype.previousExecutionState;
 /** @type {!Windows.ApplicationModel.Activation.SplashScreen} */
Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs.prototype.splashScreen;
 /** @type {!Windows.Security.Authentication.Web.WebAuthenticationResult} */
Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs.prototype.webAuthenticationResult;

/** @typedef {function(?): void} */
Windows.UI.WebUI.ActivatedEventHandler;

/** @typedef {function(?): void} */
Windows.UI.WebUI.NavigatedEventHandler;

/** @typedef {function(!Windows.WinRTEvent<?>): void} */
Windows.UI.WebUI.ResumingEventHandler;

/** @typedef {function(?): void} */
Windows.UI.WebUI.SuspendingEventHandler;
/**
 * @record
 * @struct
 */
Windows.UI.WebUI.IWebUIBackgroundTaskInstance = function() {};
 /** @type {boolean} */
Windows.UI.WebUI.IWebUIBackgroundTaskInstance.prototype.succeeded;
/**
 * @record
 * @struct
 */
Windows.UI.WebUI.IWebUINavigatedEventArgs = function() {};
 /** @type {!Windows.UI.WebUI.WebUINavigatedOperation} */
Windows.UI.WebUI.IWebUINavigatedEventArgs.prototype.navigatedOperation;
/** @const */
Windows.UI.Xaml = {};
/** @const */
Windows.UI.Xaml.Automation = {};
/** @const */
Windows.UI.Xaml.Automation.Peers = {};
/** @const */
Windows.UI.Xaml.Automation.Provider = {};
/** @const */
Windows.UI.Xaml.Automation.Text = {};
/** @const */
Windows.UI.Xaml.Controls = {};
/** @const */
Windows.UI.Xaml.Controls.Maps = {};
/** @const */
Windows.UI.Xaml.Controls.Primitives = {};
/** @const */
Windows.UI.Xaml.Data = {};
/** @const */
Windows.UI.Xaml.Documents = {};
/** @const */
Windows.UI.Xaml.Hosting = {};
/** @const */
Windows.UI.Xaml.Input = {};
/** @const */
Windows.UI.Xaml.Interop = {};
/** @const */
Windows.UI.Xaml.Markup = {};
/** @const */
Windows.UI.Xaml.Media = {};
/** @const */
Windows.UI.Xaml.Media.Animation = {};
/** @const */
Windows.UI.Xaml.Media.Imaging = {};
/** @const */
Windows.UI.Xaml.Media.Media3D = {};
/** @const */
Windows.UI.Xaml.Navigation = {};
/** @const */
Windows.UI.Xaml.Printing = {};
/** @const */
Windows.UI.Xaml.Resources = {};
/** @const */
Windows.UI.Xaml.Shapes = {};
/**
 * @record
 * @struct
 */
Windows.UI.Color = function() {};
 /** @type {number} */
Windows.UI.Color.prototype.a;
 /** @type {number} */
Windows.UI.Color.prototype.b;
 /** @type {number} */
Windows.UI.Color.prototype.g;
 /** @type {number} */
Windows.UI.Color.prototype.r;
/** @const */
Windows.Web = {};
/** @const */
Windows.Web.AtomPub = {};

/**
 * @constructor
 * @struct
 * Creates a new AtomPubClient object with the credential to use when making requests to the server. Initially, a 'username/password' tuple. However, for domain credentials, the username must be in 'domain\user form'.
 * Creates a new AtomPubClient object.
 * @param {!Windows.Security.Credentials.PasswordCredential=} serverCredential The specified security credentials.
 */
Windows.Web.AtomPub.AtomPubClient = function(serverCredential) {};
 /** @type {boolean} */
Windows.Web.AtomPub.AtomPubClient.prototype.bypassCacheOnRetrieve;
 /** @type {number} */
Windows.Web.AtomPub.AtomPubClient.prototype.maxResponseBufferSize;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Web.AtomPub.AtomPubClient.prototype.proxyCredential;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Web.AtomPub.AtomPubClient.prototype.serverCredential;
 /** @type {number} */
Windows.Web.AtomPub.AtomPubClient.prototype.timeout;

/**
 * Cancels any in-progress asynchronous operations, causing them to fail (asynchronously) with an error code indicating cancellation.
 * @return {void}
 */
Windows.Web.AtomPub.AtomPubClient.prototype.cancelAsyncOperations = function() {};

/**
 * Creates a new media resource in the specified collection.
 * @param {!Windows.Foundation.Uri} uri The URI of the specified collection in which the new resource should be created.
 * @param {string} mediaType The type for the media resource.
 * @param {string} description The description of the new resource that is turned into the Slug: header of the POST request.
 * @param {!Windows.Storage.Streams.IInputStream} mediaStream Specifies the IInputStream to use as the media resource.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Web.Syndication.SyndicationItem, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Web.Syndication.SyndicationItem, !Windows.Web.Syndication.TransferProgress>>} The object that is used to create the resource asynchronously and to report the progress and completion status of the operation.
 */
Windows.Web.AtomPub.AtomPubClient.prototype.createMediaResourceAsync = function(uri, mediaType, description, mediaStream) {};

/**
 * Creates a new Entry resource in the specified collection. The Uri of the collection in which to create the new resource can be discovered from the ResourceCollection object retrieved from the RetrieveResourceAsync method.
 * @param {!Windows.Foundation.Uri} uri The Uri of the specified collection in which the new resource should be created.
 * @param {string} description The description of the new resource that is turned into the Slug: header of the POST request.
 * @param {!Windows.Web.Syndication.SyndicationItem} item The new resource to be created.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Web.Syndication.SyndicationItem, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Web.Syndication.SyndicationItem, !Windows.Web.Syndication.TransferProgress>>} The object that is used to create the resource asynchronously and to report the progress and completion status of the operation.
 */
Windows.Web.AtomPub.AtomPubClient.prototype.createResourceAsync = function(uri, description, item) {};

/**
 * Deletes an existing Entry or Media Link resource.
 * @param {!Windows.Foundation.Uri} uri The Uri of the resource to be deleted.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncActionWithProgress<!Windows.Web.Syndication.TransferProgress>>} The object that is used to delete the resource asynchronously and to report the progress and completion status of the operation.
 */
Windows.Web.AtomPub.AtomPubClient.prototype.deleteResourceAsync = function(uri) {};

/**
 * Deletes an existing Entry or Media Link resource. This differs from the DeleteResourceAsync method in that the SyndicationItem object that represents the resource to be deleted is specified instead of the Uri. The DeleteResourceItemAsync method uses the EditUri property of the specified SyndicationItem as the Uri of the resource to be deleted.
 * @param {!Windows.Web.Syndication.SyndicationItem} item The resource to be deleted.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncActionWithProgress<!Windows.Web.Syndication.TransferProgress>>} The object that is used to delete the resource asynchronously and to report the progress and completion status of the operation.
 */
Windows.Web.AtomPub.AtomPubClient.prototype.deleteResourceItemAsync = function(item) {};

/**
 * Starts an asynchronous operation to download the syndication feed from the given URI. This method instantiates a SyndicationFeed object from the feed string, which can be in one of the formats specified in SyndicationFormat .
 * @param {!Windows.Foundation.Uri} uri The URI from which the feed is downloaded.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Web.Syndication.SyndicationFeed, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Web.Syndication.SyndicationFeed, !Windows.Web.Syndication.RetrievalProgress>>} Contains the results of the operation.
 */
Windows.Web.AtomPub.AtomPubClient.prototype.retrieveFeedAsync = function(uri) {};

/**
 * Retrieves a media link resource from the specified Uniform Resource Identifier (URI).
 * @param {!Windows.Foundation.Uri} uri The URI for the media resource.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IInputStream, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IInputStream, !Windows.Web.Syndication.RetrievalProgress>>} The object used to retrieve the media resource and report the progress and completion status of the operation.
 */
Windows.Web.AtomPub.AtomPubClient.prototype.retrieveMediaResourceAsync = function(uri) {};

/**
 * Retrieves an Entry resource or Media Link resource from the specified Uniform Resource Identifier (URI).
 * @param {!Windows.Foundation.Uri} uri The specified URI.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Web.Syndication.SyndicationItem, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Web.Syndication.SyndicationItem, !Windows.Web.Syndication.RetrievalProgress>>} The object that is used to retrieve the resource asynchronously and to report the progress and completion status of the operation.
 */
Windows.Web.AtomPub.AtomPubClient.prototype.retrieveResourceAsync = function(uri) {};

/**
 * Retrieves a service document from the specified Uri.
 * @param {!Windows.Foundation.Uri} uri The specified Uri.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Web.AtomPub.ServiceDocument, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Web.AtomPub.ServiceDocument, !Windows.Web.Syndication.RetrievalProgress>>} The object that is used to retrieve the service document asynchronously and to report the progress and completion status of the operation.
 */
Windows.Web.AtomPub.AtomPubClient.prototype.retrieveServiceDocumentAsync = function(uri) {};

/**
 * Sets an HTTP header for the request. This method can be called multiple times to set multiple headers. When the same header is set multiple times, the values will be concatenated and separated by ",".
 * @param {string} name The name of the header.
 * @param {string} value The value of the header.
 * @return {void}
 */
Windows.Web.AtomPub.AtomPubClient.prototype.setRequestHeader = function(name, value) {};

/**
 * Updates a media link resource from the specified Uniform Resource Identifier (URI).
 * @param {!Windows.Foundation.Uri} uri The URI of the resource to be updated.
 * @param {string} mediaType The media type of the resource.
 * @param {!Windows.Storage.Streams.IInputStream} mediaStream The IInputStream of the media that is updating the media resource.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncActionWithProgress<!Windows.Web.Syndication.TransferProgress>>} Completion status or error codes.
 */
Windows.Web.AtomPub.AtomPubClient.prototype.updateMediaResourceAsync = function(uri, mediaType, mediaStream) {};

/**
 * Updates an existing Entry or Media Link resource. If an ETag: header has previously been seen while retrieving this resource (in a response to RetrieveResourceAsync , CreateResourceAsync or a previous call to UpdateResourceAsync), this method automatically sends an If-Match: header with the remembered value.
 * @param {!Windows.Foundation.Uri} uri The URI of the resource to be updated.
 * @param {!Windows.Web.Syndication.SyndicationItem} item The resource to be updated.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncActionWithProgress<!Windows.Web.Syndication.TransferProgress>>} The object that is used to update the resource asynchronously and to report the progress and completion status of the operation.
 */
Windows.Web.AtomPub.AtomPubClient.prototype.updateResourceAsync = function(uri, item) {};

/**
 * Updates an existing Entry or Media Link resource. This differs from the UpdateResourceAsync method in that the EditUri property of the specified SyndicationItem object is used as the Uri of the resource to be updated.
 * @param {!Windows.Web.Syndication.SyndicationItem} item The resource to be updated.
 * @return {!Windows.Foundation.IPromiseWithOperation<void, !Windows.Foundation.IAsyncActionWithProgress<!Windows.Web.Syndication.TransferProgress>>} The object that is used to update the resource asynchronously and to report the progress and completion status of the operation.
 */
Windows.Web.AtomPub.AtomPubClient.prototype.updateResourceItemAsync = function(item) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.AtomPub.ResourceCollection = function() {};
 /** @type {!Windows.Foundation.Collections.IVectorView<string>} */
Windows.Web.AtomPub.ResourceCollection.prototype.accepts;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationAttribute>} */
Windows.Web.AtomPub.ResourceCollection.prototype.attributeExtensions;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.AtomPub.ResourceCollection.prototype.baseUri;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Syndication.SyndicationCategory>} */
Windows.Web.AtomPub.ResourceCollection.prototype.categories;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.ISyndicationNode>} */
Windows.Web.AtomPub.ResourceCollection.prototype.elementExtensions;
 /** @type {string} */
Windows.Web.AtomPub.ResourceCollection.prototype.language;
 /** @type {string} */
Windows.Web.AtomPub.ResourceCollection.prototype.nodeName;
 /** @type {string} */
Windows.Web.AtomPub.ResourceCollection.prototype.nodeNamespace;
 /** @type {string} */
Windows.Web.AtomPub.ResourceCollection.prototype.nodeValue;
 /** @type {!Windows.Web.Syndication.ISyndicationText} */
Windows.Web.AtomPub.ResourceCollection.prototype.title;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.AtomPub.ResourceCollection.prototype.uri;

/**
 * Generates the DOM object that represents this element, and all the attributes and child elements including foreign markups.
 * @param {Windows.Web.Syndication.SyndicationFormat} format The format of the element. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The XML document.
 */
Windows.Web.AtomPub.ResourceCollection.prototype.getXmlDocument = function(format) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.AtomPub.ServiceDocument = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationAttribute>} */
Windows.Web.AtomPub.ServiceDocument.prototype.attributeExtensions;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.AtomPub.ServiceDocument.prototype.baseUri;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.ISyndicationNode>} */
Windows.Web.AtomPub.ServiceDocument.prototype.elementExtensions;
 /** @type {string} */
Windows.Web.AtomPub.ServiceDocument.prototype.language;
 /** @type {string} */
Windows.Web.AtomPub.ServiceDocument.prototype.nodeName;
 /** @type {string} */
Windows.Web.AtomPub.ServiceDocument.prototype.nodeNamespace;
 /** @type {string} */
Windows.Web.AtomPub.ServiceDocument.prototype.nodeValue;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Web.AtomPub.Workspace>} */
Windows.Web.AtomPub.ServiceDocument.prototype.workspaces;

/**
 * Generates the DOM object that represents this element, and all the attributes and child elements including foreign markups.
 * @param {Windows.Web.Syndication.SyndicationFormat} format The format of the element. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The XML document.
 */
Windows.Web.AtomPub.ServiceDocument.prototype.getXmlDocument = function(format) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.AtomPub.Workspace = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationAttribute>} */
Windows.Web.AtomPub.Workspace.prototype.attributeExtensions;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.AtomPub.Workspace.prototype.baseUri;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Web.AtomPub.ResourceCollection>} */
Windows.Web.AtomPub.Workspace.prototype.collections;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.ISyndicationNode>} */
Windows.Web.AtomPub.Workspace.prototype.elementExtensions;
 /** @type {string} */
Windows.Web.AtomPub.Workspace.prototype.language;
 /** @type {string} */
Windows.Web.AtomPub.Workspace.prototype.nodeName;
 /** @type {string} */
Windows.Web.AtomPub.Workspace.prototype.nodeNamespace;
 /** @type {string} */
Windows.Web.AtomPub.Workspace.prototype.nodeValue;
 /** @type {!Windows.Web.Syndication.ISyndicationText} */
Windows.Web.AtomPub.Workspace.prototype.title;

/**
 * Generates the DOM object that represents this element, and all the attributes and child elements including foreign markups.
 * @param {Windows.Web.Syndication.SyndicationFormat} format The format for the element. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The XML document.
 */
Windows.Web.AtomPub.Workspace.prototype.getXmlDocument = function(format) {};
/** @const */
Windows.Web.Http = {};
/** @const */
Windows.Web.Http.Diagnostics = {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Diagnostics.HttpDiagnosticProvider = function() {};
 /** @type {function(?): void} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProvider.prototype.onrequestresponsecompleted;
 /** @type {function(?): void} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProvider.prototype.onrequestsent;
 /** @type {function(?): void} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProvider.prototype.onresponsereceived;

/**
 * Creates a new HttpDiagnosticProvider based on the specified ProcessDiagnosticInfo object.
 * @param {!Windows.System.Diagnostics.ProcessDiagnosticInfo} processDiagnosticInfo The ProcessDiagnosticInfo that identifies the process to watch.
 * @return {!Windows.Web.Http.Diagnostics.HttpDiagnosticProvider} The newly created HttpDiagnosticProvider .
 */
Windows.Web.Http.Diagnostics.HttpDiagnosticProvider.createFromProcessDiagnosticInfo = function(processDiagnosticInfo) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Web.Http.Diagnostics.HttpDiagnosticProvider.prototype.addEventListener = function(type, listener) {};

/**
 * @param {string} type
 * @param {function(?): void} listener
 * @return {void}
 */
Windows.Web.Http.Diagnostics.HttpDiagnosticProvider.prototype.removeEventListener = function(type, listener) {};

/**
 * Starts the HttpDiagnosticProvider monitoring the attached process target.
 * @return {void}
 */
Windows.Web.Http.Diagnostics.HttpDiagnosticProvider.prototype.start = function() {};

/**
 * Stops the HttpDiagnosticProvider from monitoring the attached process target.
 * @return {void}
 */
Windows.Web.Http.Diagnostics.HttpDiagnosticProvider.prototype.stop = function() {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs = function() {};
 /** @type {string} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs.prototype.activityId;
 /** @type {Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs.prototype.initiator;
 /** @type {?} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs.prototype.processId;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs.prototype.requestedUri;
 /** @type {?} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs.prototype.sourceLocations;
 /** @type {?} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs.prototype.threadId;
 /** @type {!Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs.prototype.timestamps;
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps = function() {};
 /** @type {!Date} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps.prototype.cacheCheckedTimestamp;
 /** @type {!Date} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps.prototype.connectionCompletedTimestamp;
 /** @type {!Date} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps.prototype.connectionInitiatedTimestamp;
 /** @type {!Date} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps.prototype.nameResolvedTimestamp;
 /** @type {!Date} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps.prototype.requestCompletedTimestamp;
 /** @type {!Date} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps.prototype.requestSentTimestamp;
 /** @type {!Date} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps.prototype.responseCompletedTimestamp;
 /** @type {!Date} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps.prototype.responseReceivedTimestamp;
 /** @type {!Date} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps.prototype.sslNegotiatedTimestamp;
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs = function() {};
 /** @type {string} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs.prototype.activityId;
 /** @type {Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs.prototype.initiator;
 /** @type {!Windows.Web.Http.HttpRequestMessage} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs.prototype.message;
 /** @type {number} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs.prototype.processId;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Http.Diagnostics.HttpDiagnosticSourceLocation>} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs.prototype.sourceLocations;
 /** @type {number} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs.prototype.threadId;
 /** @type {!Date} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs = function() {};
 /** @type {string} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs.prototype.activityId;
 /** @type {!Windows.Web.Http.HttpResponseMessage} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs.prototype.message;
 /** @type {!Date} */
Windows.Web.Http.Diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs.prototype.timestamp;

/** @const */
Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator = {};
/** @const {number} */
Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator.parsedElement;
/** @const {number} */
Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator.script;
/** @const {number} */
Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator.image;
/** @const {number} */
Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator.link;
/** @const {number} */
Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator.style;
/** @const {number} */
Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator.xmlHttpRequest;
/** @const {number} */
Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator.media;
/** @const {number} */
Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator.htmlDownload;
/** @const {number} */
Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator.prefetch;
/** @const {number} */
Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator.other;
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Diagnostics.HttpDiagnosticSourceLocation = function() {};
 /** @type {number} */
Windows.Web.Http.Diagnostics.HttpDiagnosticSourceLocation.prototype.columnNumber;
 /** @type {number} */
Windows.Web.Http.Diagnostics.HttpDiagnosticSourceLocation.prototype.lineNumber;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Http.Diagnostics.HttpDiagnosticSourceLocation.prototype.sourceUri;
/** @const */
Windows.Web.Http.Filters = {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpBaseProtocolFilter class.
 */
Windows.Web.Http.Filters.HttpBaseProtocolFilter = function() {};
 /** @type {boolean} */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.allowAutoRedirect;
 /** @type {boolean} */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.allowUI;
 /** @type {boolean} */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.automaticDecompression;
 /** @type {!Windows.Web.Http.Filters.HttpCacheControl} */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.cacheControl;
 /** @type {!Windows.Security.Cryptography.Certificates.Certificate} */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.clientCertificate;
 /** @type {!Windows.Web.Http.HttpCookieManager} */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.cookieManager;
 /** @type {Windows.Web.Http.Filters.HttpCookieUsageBehavior} */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.cookieUsageBehavior;
 /** @type {!Windows.Foundation.Collections.IVector<Windows.Security.Cryptography.Certificates.ChainValidationResult>} */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.ignorableServerCertificateErrors;
 /** @type {number} */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.maxConnectionsPerServer;
 /** @type {Windows.Web.Http.HttpVersion} */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.maxVersion;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.proxyCredential;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.serverCredential;
 /** @type {boolean} */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.useProxy;

/**
 * Closes the HttpBaseProtocolFilter instance and releases allocated resources.
 * @return {void}
 */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.close = function() {};

/**
 * Send an HTTP request using the HttpBaseProtocolFilter as an asynchronous operation.
 * @param {!Windows.Web.Http.HttpRequestMessage} request The HTTP request message to send.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Web.Http.HttpResponseMessage, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Web.Http.HttpResponseMessage, !Windows.Web.Http.HttpProgress>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.Filters.HttpBaseProtocolFilter.prototype.sendRequestAsync = function(request) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Filters.HttpCacheControl = function() {};
 /** @type {Windows.Web.Http.Filters.HttpCacheReadBehavior} */
Windows.Web.Http.Filters.HttpCacheControl.prototype.readBehavior;
 /** @type {Windows.Web.Http.Filters.HttpCacheWriteBehavior} */
Windows.Web.Http.Filters.HttpCacheControl.prototype.writeBehavior;

/** @const */
Windows.Web.Http.Filters.HttpCacheReadBehavior = {};
/** @const {number} */
Windows.Web.Http.Filters.HttpCacheReadBehavior.default;
/** @const {number} */
Windows.Web.Http.Filters.HttpCacheReadBehavior.mostRecent;
/** @const {number} */
Windows.Web.Http.Filters.HttpCacheReadBehavior.onlyFromCache;

/** @const */
Windows.Web.Http.Filters.HttpCacheWriteBehavior = {};
/** @const {number} */
Windows.Web.Http.Filters.HttpCacheWriteBehavior.default;
/** @const {number} */
Windows.Web.Http.Filters.HttpCacheWriteBehavior.noCache;

/** @const */
Windows.Web.Http.Filters.HttpCookieUsageBehavior = {};
/** @const {number} */
Windows.Web.Http.Filters.HttpCookieUsageBehavior.default;
/** @const {number} */
Windows.Web.Http.Filters.HttpCookieUsageBehavior.noCookies;
/**
 * @extends {Windows.Foundation.IClosable}
 * @record
 * @struct
 */
Windows.Web.Http.Filters.IHttpFilter = function() {};

/**
 * Send an HTTP request on the IHttpFilter instance as an asynchronous operation.
 * @param {!Windows.Web.Http.HttpRequestMessage} request The HTTP request message to send.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Web.Http.HttpResponseMessage, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Web.Http.HttpResponseMessage, !Windows.Web.Http.HttpProgress>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.Filters.IHttpFilter.prototype.sendRequestAsync = function(request) {};
/** @const */
Windows.Web.Http.Headers = {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection = function() {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.maxAge;
 /** @type {number} */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.maxStale;
 /** @type {number} */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.minFresh;
 /** @type {number} */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.sharedMaxAge;
 /** @type {number} */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.size;

/**
 * Adds a new HttpNameValueHeaderValue item to the end of the collection.
 * @param {!Windows.Web.Http.Headers.HttpNameValueHeaderValue} value The HttpNameValueHeaderValue object to append.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.append = function(value) {};

/**
 * Removes all objects from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first HttpNameValueHeaderValue item in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.Headers.HttpNameValueHeaderValue>} An object that can be used to enumerate the HttpNameValueHeaderValue items in the collection. The iterator points to the first HttpNameValueHeaderValue item in the HttpCacheDirectiveHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.first = function() {};

/**
 * Returns the HttpNameValueHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index of a specified item in the HttpCacheDirectiveHeaderValueCollection .
 * @return {!Windows.Web.Http.Headers.HttpNameValueHeaderValue} The HttpNameValueHeaderValue at the specified index in the HttpCacheDirectiveHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.getAt = function(index) {};

/**
 * Retrieves the HttpNameValueHeaderValue items that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the HttpNameValueHeaderValue items in the HttpCacheDirectiveHeaderValueCollection .
 * @return {{items: !Windows.Web.Http.Headers.HttpNameValueHeaderValue, returnValue: number}}
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.getMany = function(startIndex) {};

/**
 * Returns an immutable view of the HttpCacheDirectiveHeaderValueCollection .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Http.Headers.HttpNameValueHeaderValue>} The view of the HttpCacheDirectiveHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.getView = function() {};

/**
 * Retrieves the index of an HttpNameValueHeaderValue in the collection.
 * Determines the index of a specific item in the collection.
 * @param {!Windows.Web.Http.Headers.HttpNameValueHeaderValue} value_or_item_or_searchElement The HttpNameValueHeaderValue to find in the HttpCacheDirectiveHeaderValueCollection . / The object to locate in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number} The index of item if found in the collection; otherwise, 1.
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.indexOf = function(value_or_item_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts an HttpNameValueHeaderValue into the collection at the specified index.
 * @param {number} index The zero-based index at which value should be inserted.
 * @param {!Windows.Web.Http.Headers.HttpNameValueHeaderValue} value The object to insert into the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.insertAt = function(index, value) {};

/**
 * Parses and adds an entry to the HttpCacheDirectiveHeaderValueCollection .
 * @param {string} input The entry to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.parseAdd = function(input) {};

/**
 * Removes the entry at the specified index from the HttpCacheDirectiveHeaderValueCollection .
 * Removes the element at the specified index of the collection.
 * @param {number} index The index of the entry to remove. / The zero-based index of the element to remove.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.removeAt = function(index) {};

/**
 * Removes the last HttpNameValueHeaderValue item from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.removeAtEnd = function() {};

/**
 * Replaces all the HttpNameValueHeaderValue items in the collection with the specified HttpNameValueHeaderValue items.
 * @param {!Windows.Web.Http.Headers.HttpNameValueHeaderValue} items The collection of HttpNameValueHeaderValue items to add to the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.replaceAll = function(items) {};

/**
 * Sets the HttpNameValueHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index at which to set the HttpNameValueHeaderValue .
 * @param {!Windows.Web.Http.Headers.HttpNameValueHeaderValue} value The item to set.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.setAt = function(index, value) {};

/**
 * Tries to parse and add the specified item to the HttpCacheDirectiveHeaderValueCollection .
 * @param {string} input The item to parse and add.
 * @return {boolean} true if the item successfully parsed and was added; otherwise false.
 */
Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection.prototype.tryParseAdd = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpChallengeHeaderValue class with the scheme to use for authorization and the SPNEGO token.
 * Initializes a new instance of the HttpChallengeHeaderValue class with the scheme to use for authorization.
 * @param {string} scheme The scheme to use for authorization.
 * @param {string=} token The SPNEGO token to use with the Negotiate protocol scheme.
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValue = function(scheme, token) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Http.Headers.HttpNameValueHeaderValue>} */
Windows.Web.Http.Headers.HttpChallengeHeaderValue.prototype.parameters;
 /** @type {string} */
Windows.Web.Http.Headers.HttpChallengeHeaderValue.prototype.scheme;
 /** @type {string} */
Windows.Web.Http.Headers.HttpChallengeHeaderValue.prototype.token;

/**
 * Converts a string to an HttpChallengeHeaderValue instance.
 * @param {string} input A string that represents authentication header value information.
 * @return {!Windows.Web.Http.Headers.HttpChallengeHeaderValue} An HttpChallengeHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpChallengeHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{challengeHeaderValue: !Windows.Web.Http.Headers.HttpChallengeHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValue.tryParse = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection = function() {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.size;

/**
 * Adds a new HttpChallengeHeaderValue item to the end of the collection.
 * @param {!Windows.Web.Http.Headers.HttpChallengeHeaderValue} value The HttpChallengeHeaderValue object to append.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.append = function(value) {};

/**
 * Removes all HttpChallengeHeaderValue objects from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first HttpChallengeHeaderValue item in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.Headers.HttpChallengeHeaderValue>} An object that can be used to enumerate the HttpChallengeHeaderValue items in the collection. The iterator points to the first HttpChallengeHeaderValue item in the HttpChallengeHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.first = function() {};

/**
 * Returns the HttpChallengeHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index of a specified item in the HttpChallengeHeaderValueCollection .
 * @return {!Windows.Web.Http.Headers.HttpChallengeHeaderValue} The HttpChallengeHeaderValue at the specified index in the HttpChallengeHeaderValueCollection
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.getAt = function(index) {};

/**
 * Retrieves the HttpChallengeHeaderValue items that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the HttpChallengeHeaderValue items in the HttpChallengeHeaderValueCollection .
 * @return {{items: !Windows.Web.Http.Headers.HttpChallengeHeaderValue, returnValue: number}}
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.getMany = function(startIndex) {};

/**
 * Returns an immutable view of the HttpChallengeHeaderValueCollection .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Http.Headers.HttpChallengeHeaderValue>} The view of the HttpChallengeHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.getView = function() {};

/**
 * Retrieves the index of an HttpChallengeHeaderValue in the collection.
 * Determines the index of a specific item in the collection.
 * @param {!Windows.Web.Http.Headers.HttpChallengeHeaderValue} value_or_item_or_searchElement The HttpChallengeHeaderValue to find in the HttpChallengeHeaderValueCollection . / The object to locate in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number} The index of item if found in the collection; otherwise, 1.
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.indexOf = function(value_or_item_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts an HttpChallengeHeaderValue into the collection at the specified index.
 * @param {number} index The zero-based index at which value should be inserted.
 * @param {!Windows.Web.Http.Headers.HttpChallengeHeaderValue} value The object to insert into the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.insertAt = function(index, value) {};

/**
 * Parses and adds an entry to the HttpChallengeHeaderValueCollection .
 * @param {string} input The entry to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.parseAdd = function(input) {};

/**
 * Removes the entry at the specified index from the HttpChallengeHeaderValueCollection .
 * Removes the element at the specified index of the collection.
 * @param {number} index The index of the entry to remove. / The zero-based index of the element to remove.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.removeAt = function(index) {};

/**
 * Removes the last HttpChallengeHeaderValue item from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.removeAtEnd = function() {};

/**
 * Replaces all the HttpChallengeHeaderValue items in the collection with the specified HttpChallengeHeaderValue items.
 * @param {!Windows.Web.Http.Headers.HttpChallengeHeaderValue} items The collection of HttpChallengeHeaderValue items to add to the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.replaceAll = function(items) {};

/**
 * Sets the HttpChallengeHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index at which to set the HttpChallengeHeaderValue .
 * @param {!Windows.Web.Http.Headers.HttpChallengeHeaderValue} value The item to set.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.setAt = function(index, value) {};

/**
 * Tries to parse and add the specified item to the HttpChallengeHeaderValueCollection .
 * @param {string} input The item to parse and add.
 * @return {boolean} true if the item successfully parsed and was added; otherwise false.
 */
Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection.prototype.tryParseAdd = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpConnectionOptionHeaderValue class.
 * @param {string} token The value of the connection-token to use.
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue = function(token) {};
 /** @type {string} */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue.prototype.token;

/**
 * Converts a string to an HttpConnectionOptionHeaderValue instance.
 * @param {string} input A string that represents the connection information in the Connection HTTP header.
 * @return {!Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue} An HttpConnectionOptionHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpConnectionOptionHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{connectionOptionHeaderValue: !Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue.tryParse = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection = function() {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.size;

/**
 * Adds a new HttpConnectionOptionHeaderValue item to the end of the collection.
 * @param {!Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue} value The HttpConnectionOptionHeaderValue object to append.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.append = function(value) {};

/**
 * Removes all HttpConnectionOptionHeaderValue objects from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first HttpConnectionOptionHeaderValue item in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue>} An object that can be used to enumerate the HttpConnectionOptionHeaderValue items in the collection. The iterator points to the first HttpConnectionOptionHeaderValue item in the HttpConnectionOptionHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.first = function() {};

/**
 * Returns the HttpConnectionOptionHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index of a specified item in the HttpConnectionOptionHeaderValueCollection .
 * @return {!Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue} The HttpConnectionOptionHeaderValue at the specified index in the HttpConnectionOptionHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.getAt = function(index) {};

/**
 * Retrieves the HttpConnectionOptionHeaderValue items that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the HttpConnectionOptionHeaderValue items in the HttpConnectionOptionHeaderValueCollection .
 * @return {{items: !Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue, returnValue: number}}
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.getMany = function(startIndex) {};

/**
 * Returns an immutable view of the HttpConnectionOptionHeaderValueCollection .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue>} The view of the HttpConnectionOptionHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.getView = function() {};

/**
 * Retrieves the index of an HttpConnectionOptionHeaderValue in the collection.
 * Determines the index of a specific item in the collection.
 * @param {!Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue} value_or_item_or_searchElement The HttpConnectionOptionHeaderValue to find in the HttpConnectionOptionHeaderValueCollection . / The object to locate in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number} The index of item if found in the collection; otherwise, 1.
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.indexOf = function(value_or_item_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts an HttpConnectionOptionHeaderValue into the collection at the specified index.
 * @param {number} index The zero-based index at which value should be inserted.
 * @param {!Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue} value The object to insert into the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.insertAt = function(index, value) {};

/**
 * Parses and adds an entry to the HttpConnectionOptionHeaderValueCollection .
 * @param {string} input The entry to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.parseAdd = function(input) {};

/**
 * Removes the entry at the specified index from the HttpConnectionOptionHeaderValueCollection .
 * Removes the element at the specified index of the collection.
 * @param {number} index The index of the entry to remove. / The zero-based index of the element to remove.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.removeAt = function(index) {};

/**
 * Removes the last HttpConnectionOptionHeaderValue item from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.removeAtEnd = function() {};

/**
 * Replaces all the HttpConnectionOptionHeaderValue items in the collection with the specified HttpConnectionOptionHeaderValue items.
 * @param {!Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue} items The collection of HttpConnectionOptionHeaderValue items to add to the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.replaceAll = function(items) {};

/**
 * Sets the HttpConnectionOptionHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index at which to set the HttpConnectionOptionHeaderValue .
 * @param {!Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue} value The item to set.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.setAt = function(index, value) {};

/**
 * Tries to parse and add the specified item to the HttpConnectionOptionHeaderValueCollection .
 * @param {string} input The item to parse and add.
 * @return {boolean} true if the item successfully parsed and was added; otherwise false.
 */
Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection.prototype.tryParseAdd = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpContentCodingHeaderValue class.
 * @param {string} contentCoding The value of the content-coding to use.
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValue = function(contentCoding) {};
 /** @type {string} */
Windows.Web.Http.Headers.HttpContentCodingHeaderValue.prototype.contentCoding;

/**
 * Converts a string to an HttpContentCodingHeaderValue instance.
 * @param {string} input A string that represents the content coding information in the Content-Encoding HTTP header.
 * @return {!Windows.Web.Http.Headers.HttpContentCodingHeaderValue} An HttpContentCodingHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpContentCodingHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{contentCodingHeaderValue: !Windows.Web.Http.Headers.HttpContentCodingHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValue.tryParse = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection = function() {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.size;

/**
 * Adds a new HttpContentCodingHeaderValue item to the end of the collection.
 * @param {!Windows.Web.Http.Headers.HttpContentCodingHeaderValue} value The HttpContentCodingHeaderValue object to append.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.append = function(value) {};

/**
 * Removes all objects from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first HttpContentCodingHeaderValue item in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.Headers.HttpContentCodingHeaderValue>} An object that can be used to enumerate the HttpContentCodingHeaderValue items in the collection. The iterator points to the first HttpContentCodingHeaderValue item in the HttpContentCodingHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.first = function() {};

/**
 * Returns the HttpContentCodingHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index of a specified item in the HttpContentCodingHeaderValueCollection .
 * @return {!Windows.Web.Http.Headers.HttpContentCodingHeaderValue} The HttpContentCodingHeaderValue at the specified index in the HttpContentCodingHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.getAt = function(index) {};

/**
 * Retrieves the HttpContentCodingHeaderValue items that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the HttpContentCodingHeaderValue items in the HttpContentCodingHeaderValueCollection .
 * @return {{items: !Windows.Web.Http.Headers.HttpContentCodingHeaderValue, returnValue: number}}
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.getMany = function(startIndex) {};

/**
 * Returns an immutable view of the HttpContentCodingHeaderValueCollection .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Http.Headers.HttpContentCodingHeaderValue>} The view of the HttpContentCodingHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.getView = function() {};

/**
 * Retrieves the index of an HttpContentCodingHeaderValue in the collection.
 * Determines the index of a specific item in the collection.
 * @param {!Windows.Web.Http.Headers.HttpContentCodingHeaderValue} value_or_item_or_searchElement The HttpContentCodingHeaderValue to find in the HttpContentCodingHeaderValueCollection . / The object to locate in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number} The index of item if found in the collection; otherwise, 1.
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.indexOf = function(value_or_item_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts an HttpContentCodingHeaderValue into the collection at the specified index.
 * @param {number} index The zero-based index at which value should be inserted.
 * @param {!Windows.Web.Http.Headers.HttpContentCodingHeaderValue} value The object to insert into the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.insertAt = function(index, value) {};

/**
 * Parses and adds an entry to the HttpContentCodingHeaderValueCollection .
 * @param {string} input The entry to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.parseAdd = function(input) {};

/**
 * Removes the entry at the specified index from the HttpContentCodingHeaderValueCollection .
 * Removes the element at the specified index of the collection.
 * @param {number} index The index of the entry to remove. / The zero-based index of the element to remove.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.removeAt = function(index) {};

/**
 * Removes the last HttpContentCodingHeaderValue item from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.removeAtEnd = function() {};

/**
 * Replaces all the HttpContentCodingHeaderValue items in the collection with the specified HttpContentCodingHeaderValue items.
 * @param {!Windows.Web.Http.Headers.HttpContentCodingHeaderValue} items The HttpContentCodingHeaderValue items to add to the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.replaceAll = function(items) {};

/**
 * Sets the HttpContentCodingHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index at which to set the HttpContentCodingHeaderValue .
 * @param {!Windows.Web.Http.Headers.HttpContentCodingHeaderValue} value The item to set.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.setAt = function(index, value) {};

/**
 * Tries to parse and add the specified item to the HttpContentCodingHeaderValueCollection .
 * @param {string} input The item to parse and add.
 * @return {boolean} true if the item successfully parsed and was added; otherwise false.
 */
Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection.prototype.tryParseAdd = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpContentCodingHeaderValue class with content-coding information and a qvalue.
 * Initializes a new instance of the HttpContentCodingHeaderValue class with content-coding information.
 * @param {string} contentCoding The value of the content-coding information to use. / The value of the content-coding to use.
 * @param {number=} quality The value of the qvalue to use.
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue = function(contentCoding, quality) {};
 /** @type {string} */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue.prototype.contentCoding;
 /** @type {number} */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue.prototype.quality;

/**
 * Converts a string to an HttpContentCodingWithQualityHeaderValue instance.
 * @param {string} input A string that represents the content coding information in the Accept-Encoding HTTP header.
 * @return {!Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue} An HttpContentCodingWithQualityHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpContentCodingWithQualityHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{contentCodingWithQualityHeaderValue: !Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue.tryParse = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection = function() {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.size;

/**
 * Adds a new HttpContentCodingWithQualityHeaderValue item to the end of the collection.
 * @param {!Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue} value The HttpContentCodingWithQualityHeaderValue object to append.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.append = function(value) {};

/**
 * Removes all objects from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first HttpContentCodingWithQualityHeaderValue item in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue>} An object that can be used to enumerate the HttpContentCodingWithQualityHeaderValue items in the collection. The iterator points to the first HttpContentCodingWithQualityHeaderValue item in the HttpContentCodingWithQualityHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.first = function() {};

/**
 * Returns the HttpContentCodingWithQualityHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index of a specified item in the collection.
 * @return {!Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue} The HttpContentCodingWithQualityHeaderValue at the specified index in the HttpContentCodingWithQualityHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.getAt = function(index) {};

/**
 * Retrieves the HttpContentCodingWithQualityHeaderValue items that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the HttpContentCodingWithQualityHeaderValue items in the HttpContentCodingWithQualityHeaderValueCollection .
 * @return {{items: !Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue, returnValue: number}}
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.getMany = function(startIndex) {};

/**
 * Returns an immutable view of the HttpContentCodingWithQualityHeaderValueCollection .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue>} The view of the HttpContentCodingWithQualityHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.getView = function() {};

/**
 * Retrieves the index of an HttpContentCodingWithQualityHeaderValue in the collection.
 * Determines the index of a specific item in the collection.
 * @param {!Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue} value_or_item_or_searchElement The HttpContentCodingWithQualityHeaderValue to find in the HttpContentCodingWithQualityHeaderValueCollection . / The object to locate in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number} The index of item if found in the collection; otherwise, 1.
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.indexOf = function(value_or_item_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts an HttpContentCodingWithQualityHeaderValue into the collection at the specified index.
 * @param {number} index The zero-based index at which value should be inserted.
 * @param {!Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue} value The object to insert into the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.insertAt = function(index, value) {};

/**
 * Parses and adds an entry to the HttpContentCodingWithQualityHeaderValueCollection .
 * @param {string} input The entry to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.parseAdd = function(input) {};

/**
 * Removes the entry at the specified index from the HttpContentCodingWithQualityHeaderValueCollection .
 * Removes the element at the specified index of the collection.
 * @param {number} index The index of the entry to remove. / The zero-based index of the element to remove.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.removeAt = function(index) {};

/**
 * Removes the last HttpContentCodingWithQualityHeaderValue item from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.removeAtEnd = function() {};

/**
 * Replaces all the HttpContentCodingWithQualityHeaderValue items in the collection with the specified HttpContentCodingWithQualityHeaderValue items.
 * @param {!Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue} items The HttpContentCodingWithQualityHeaderValue items to add to the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.replaceAll = function(items) {};

/**
 * Sets the HttpContentCodingWithQualityHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index at which to set the HttpContentCodingWithQualityHeaderValue .
 * @param {!Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue} value The item to set.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.setAt = function(index, value) {};

/**
 * Tries to parse and add the specified item to the HttpContentCodingWithQualityHeaderValueCollection .
 * @param {string} input The item to parse and add.
 * @return {boolean} true if the item successfully parsed and was added; otherwise false.
 */
Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection.prototype.tryParseAdd = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpContentDispositionHeaderValue class with content-coding information for use in the Content-Disposition HTTP header.
 * @param {string} dispositionType The value of the disposition-type information to be used in the Content-Disposition HTTP header.
 */
Windows.Web.Http.Headers.HttpContentDispositionHeaderValue = function(dispositionType) {};
 /** @type {string} */
Windows.Web.Http.Headers.HttpContentDispositionHeaderValue.prototype.dispositionType;
 /** @type {string} */
Windows.Web.Http.Headers.HttpContentDispositionHeaderValue.prototype.fileName;
 /** @type {string} */
Windows.Web.Http.Headers.HttpContentDispositionHeaderValue.prototype.fileNameStar;
 /** @type {string} */
Windows.Web.Http.Headers.HttpContentDispositionHeaderValue.prototype.name;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Http.Headers.HttpNameValueHeaderValue>} */
Windows.Web.Http.Headers.HttpContentDispositionHeaderValue.prototype.parameters;
 /** @type {number} */
Windows.Web.Http.Headers.HttpContentDispositionHeaderValue.prototype.size;

/**
 * Converts a string to an HttpContentDispositionHeaderValue instance.
 * @param {string} input A string that represents the content disposition information in the Content-Disposition HTTP header.
 * @return {!Windows.Web.Http.Headers.HttpContentDispositionHeaderValue} An HttpContentDispositionHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpContentDispositionHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpContentDispositionHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{contentDispositionHeaderValue: !Windows.Web.Http.Headers.HttpContentDispositionHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpContentDispositionHeaderValue.tryParse = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpContentHeaderCollection class.
 */
Windows.Web.Http.Headers.HttpContentHeaderCollection = function() {};
 /** @type {!Windows.Web.Http.Headers.HttpContentDispositionHeaderValue} */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.contentDisposition;
 /** @type {!Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection} */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.contentEncoding;
 /** @type {!Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection} */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.contentLanguage;
 /** @type {number} */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.contentLength;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.contentLocation;
 /** @type {!Windows.Storage.Streams.IBuffer} */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.contentMD5;
 /** @type {!Windows.Web.Http.Headers.HttpContentRangeHeaderValue} */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.contentRange;
 /** @type {!Windows.Web.Http.Headers.HttpMediaTypeHeaderValue} */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.contentType;
 /** @type {!Date} */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.expires;
 /** @type {!Date} */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.lastModified;
 /** @type {number} */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.size;

/**
 * Adds a new item to the end of the HttpContentHeaderCollection .
 * @param {string} name The name of the value to add.
 * @param {string} value The item value to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.append = function(name, value) {};

/**
 * Removes all objects from the HttpContentHeaderCollection .
 * @return {void}
 */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first item in the HttpContentHeaderCollection .
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} An object that can be used to enumerate the items in the collection. The iterator points to the first item in the HttpContentHeaderCollection .
 */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.first = function() {};

/**
 * Returns an immutable view of the HttpContentHeaderCollection .
 * @return {!Windows.Foundation.Collections.IMapView<string, string>} The view of the HttpContentHeaderCollection .
 */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.getView = function() {};

/**
 * Determines whether the HttpContentHeaderCollection contains the specified key.
 * @param {string} key The key associated with the item to locate.
 * @return {boolean} true if the key is found; otherwise, false.
 */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.hasKey = function(key) {};

/**
 * Inserts or replaces an item in the HttpContentHeaderCollection with the specified key and value.
 * @param {string} key The key of the item to be inserted.
 * @param {string} value The value of the item to insert.
 * @return {boolean} true if an item with the specified key is an existing item that was replaced; otherwise false.
 */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.insert = function(key, value) {};

/**
 * Finds an item in the HttpContentHeaderCollection if it exists.
 * @param {string} key The key of the item to lookup.
 * @return {string} The value of the item if found.
 */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.lookup = function(key) {};

/**
 * Removes a specific object from the HttpContentHeaderCollection .
 * Removes a specific item from the HttpContentHeaderCollection .
 * @param {string} key The key of the item to remove.
 * @return {void|boolean} true if the item was removed, otherwise false.
 */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.remove = function(key) {};

/**
 * Try to append the specified item to the HttpContentHeaderCollection without validation.
 * @param {string} name The name of the item to append.
 * @param {string} value The value of the item to append.
 * @return {boolean} true if the item was appended; otherwise false.
 */
Windows.Web.Http.Headers.HttpContentHeaderCollection.prototype.tryAppendWithoutValidation = function(name, value) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpContentRangeHeaderValue class with a content length.
 * Initializes a new instance of the HttpContentRangeHeaderValue class with a start and stop position.
 * Initializes a new instance of the HttpContentRangeHeaderValue class with a start and stop position and a content length.
 * @param {number} length_or_from The length, in bytes, of the full content entity body. / The position, in bytes, at which to start sending data.
 * @param {number=} to The position, in bytes, at which to stop sending data.
 * @param {number=} length The length, in bytes, of the full content entity body.
 */
Windows.Web.Http.Headers.HttpContentRangeHeaderValue = function(length_or_from, to, length) {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpContentRangeHeaderValue.prototype.firstBytePosition;
 /** @type {number} */
Windows.Web.Http.Headers.HttpContentRangeHeaderValue.prototype.lastBytePosition;
 /** @type {number} */
Windows.Web.Http.Headers.HttpContentRangeHeaderValue.prototype.length;
 /** @type {string} */
Windows.Web.Http.Headers.HttpContentRangeHeaderValue.prototype.unit;

/**
 * Converts a string to an HttpContentRangeHeaderValue instance.
 * @param {string} input A string that represents the content range information in the Content-Range HTTP header.
 * @return {!Windows.Web.Http.Headers.HttpContentRangeHeaderValue} An HttpContentRangeHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpContentRangeHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpContentRangeHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{contentRangeHeaderValue: !Windows.Web.Http.Headers.HttpContentRangeHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpContentRangeHeaderValue.tryParse = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpCookiePairHeaderValue class. with a cookie name and a value for the cookie.
 * Initializes a new instance of the HttpCookiePairHeaderValue class. with a cookie name.
 * @param {string} name A token that represents the cookie name.
 * @param {string=} value A value for the cookie.
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValue = function(name, value) {};
 /** @type {string} */
Windows.Web.Http.Headers.HttpCookiePairHeaderValue.prototype.name;
 /** @type {string} */
Windows.Web.Http.Headers.HttpCookiePairHeaderValue.prototype.value;

/**
 * Converts a string to an HttpCookiePairHeaderValue instance.
 * @param {string} input A string that represents the cookie name and value in the Cookie HTTP header.
 * @return {!Windows.Web.Http.Headers.HttpCookiePairHeaderValue} An HttpCookiePairHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpCookiePairHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{cookiePairHeaderValue: !Windows.Web.Http.Headers.HttpCookiePairHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValue.tryParse = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection = function() {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.size;

/**
 * Adds a new HttpCookiePairHeaderValue item to the end of the collection.
 * @param {!Windows.Web.Http.Headers.HttpCookiePairHeaderValue} value The new item to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.append = function(value) {};

/**
 * Removes all objects from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first HttpCookiePairHeaderValue item in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.Headers.HttpCookiePairHeaderValue>} An object that can be used to enumerate the HttpCookiePairHeaderValue items in the collection. The iterator points to the first HttpCookiePairHeaderValue item in the HttpCookiePairHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.first = function() {};

/**
 * Returns the HttpCookiePairHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index of a specified item in the collection.
 * @return {!Windows.Web.Http.Headers.HttpCookiePairHeaderValue} The HttpCookiePairHeaderValue at the specified index in the HttpCookiePairHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.getAt = function(index) {};

/**
 * Retrieves the HttpCookiePairHeaderValue items that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the HttpCookiePairHeaderValue items in the HttpCookiePairHeaderValueCollection .
 * @return {{items: !Windows.Web.Http.Headers.HttpCookiePairHeaderValue, returnValue: number}}
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.getMany = function(startIndex) {};

/**
 * Returns an immutable view of the HttpCookiePairHeaderValueCollection .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Http.Headers.HttpCookiePairHeaderValue>} The view of the HttpCookiePairHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.getView = function() {};

/**
 * Retrieves the index of an HttpCookiePairHeaderValue in the collection.
 * Determines the index of a specific item in the collection.
 * @param {!Windows.Web.Http.Headers.HttpCookiePairHeaderValue} value_or_item_or_searchElement The HttpCookiePairHeaderValue to find in the HttpCookiePairHeaderValueCollection . / The object to locate in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number} The index of item if found in the collection; otherwise, 1.
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.indexOf = function(value_or_item_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts an HttpCookiePairHeaderValue into the collection at the specified index.
 * @param {number} index The zero-based index at which value should be inserted.
 * @param {!Windows.Web.Http.Headers.HttpCookiePairHeaderValue} value The object to insert into the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.insertAt = function(index, value) {};

/**
 * Parses and adds an entry to the HttpCookiePairHeaderValueCollection .
 * @param {string} input The entry to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.parseAdd = function(input) {};

/**
 * Removes the entry at the specified index from the HttpCookiePairHeaderValueCollection .
 * Removes the element at the specified index of the collection.
 * @param {number} index The index of the entry to remove. / The zero-based index of the element to remove.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.removeAt = function(index) {};

/**
 * Removes the last HttpCookiePairHeaderValue item from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.removeAtEnd = function() {};

/**
 * Replaces all the HttpCookiePairHeaderValue items in the collection with the specified HttpCookiePairHeaderValue items.
 * @param {!Windows.Web.Http.Headers.HttpCookiePairHeaderValue} items The HttpCookiePairHeaderValue items to add to the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.replaceAll = function(items) {};

/**
 * Sets the HttpCookiePairHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index at which to set the HttpCookiePairHeaderValue .
 * @param {!Windows.Web.Http.Headers.HttpCookiePairHeaderValue} value The item to set.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.setAt = function(index, value) {};

/**
 * Tries to parse and add the specified item to the HttpCookiePairHeaderValueCollection .
 * @param {string} input The item to parse and add.
 * @return {boolean} true if the item successfully parsed and was added; otherwise false.
 */
Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection.prototype.tryParseAdd = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpCredentialsHeaderValue class with the scheme and user token information to use for authentication.
 * Initializes a new instance of the HttpCredentialsHeaderValue class with the scheme to use for authentication.
 * @param {string} scheme The scheme to use for authentication.
 * @param {string=} token The user token information to use for authentication.
 */
Windows.Web.Http.Headers.HttpCredentialsHeaderValue = function(scheme, token) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Http.Headers.HttpNameValueHeaderValue>} */
Windows.Web.Http.Headers.HttpCredentialsHeaderValue.prototype.parameters;
 /** @type {string} */
Windows.Web.Http.Headers.HttpCredentialsHeaderValue.prototype.scheme;
 /** @type {string} */
Windows.Web.Http.Headers.HttpCredentialsHeaderValue.prototype.token;

/**
 * Converts a string to an HttpCredentialsHeaderValue instance.
 * @param {string} input A string that represents the credential information in the Authorization or Proxy-Authorization HTTP header.
 * @return {!Windows.Web.Http.Headers.HttpCredentialsHeaderValue} An HttpCredentialsHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpCredentialsHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpCredentialsHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{credentialsHeaderValue: !Windows.Web.Http.Headers.HttpCredentialsHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpCredentialsHeaderValue.tryParse = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue = function() {};
 /** @type {!Date} */
Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue.prototype.date;
 /** @type {number} */
Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue.prototype.delta;

/**
 * Converts a string to an HttpDateOrDeltaHeaderValue instance.
 * @param {string} input A string that represents the HTTP-date or delta-seconds information in the Retry-After HTTP header.
 * @return {!Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue} An HttpDateOrDeltaHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpDateOrDeltaHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{dateOrDeltaHeaderValue: !Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue.tryParse = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpExpectationHeaderValue class with a name and value for the name.
 * Initializes a new instance of the HttpExpectationHeaderValue class with a name.
 * @param {string} name A token that represents a name used in the Expect HTTP header.
 * @param {string=} value A value for the name used in the Expect HTTP header.
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValue = function(name, value) {};
 /** @type {string} */
Windows.Web.Http.Headers.HttpExpectationHeaderValue.prototype.name;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Http.Headers.HttpNameValueHeaderValue>} */
Windows.Web.Http.Headers.HttpExpectationHeaderValue.prototype.parameters;
 /** @type {string} */
Windows.Web.Http.Headers.HttpExpectationHeaderValue.prototype.value;

/**
 * Converts a string to an HttpExpectationHeaderValue instance.
 * @param {string} input A string that represents the information in the Expect HTTP header.
 * @return {!Windows.Web.Http.Headers.HttpExpectationHeaderValue} An HttpExpectationHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpCredentialsHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{expectationHeaderValue: !Windows.Web.Http.Headers.HttpExpectationHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValue.tryParse = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection = function() {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.size;

/**
 * Adds a new HttpExpectationHeaderValue item to the end of the collection.
 * @param {!Windows.Web.Http.Headers.HttpExpectationHeaderValue} value The new item to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.append = function(value) {};

/**
 * Removes all objects from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first HttpExpectationHeaderValue item in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.Headers.HttpExpectationHeaderValue>} An object that can be used to enumerate the HttpExpectationHeaderValue items in the collection. The iterator points to the first HttpExpectationHeaderValue item in the HttpExpectationHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.first = function() {};

/**
 * Returns the HttpExpectationHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index of a specified item in the collection.
 * @return {!Windows.Web.Http.Headers.HttpExpectationHeaderValue} The HttpExpectationHeaderValue at the specified index in the HttpExpectationHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.getAt = function(index) {};

/**
 * Retrieves the HttpExpectationHeaderValue items that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the HttpExpectationHeaderValue items in the HttpExpectationHeaderValueCollection .
 * @return {{items: !Windows.Web.Http.Headers.HttpExpectationHeaderValue, returnValue: number}}
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.getMany = function(startIndex) {};

/**
 * Returns an immutable view of the HttpExpectationHeaderValueCollection .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Http.Headers.HttpExpectationHeaderValue>} The view of the HttpExpectationHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.getView = function() {};

/**
 * Retrieves the index of an HttpExpectationHeaderValue in the collection.
 * Determines the index of a specific item in the collection.
 * @param {!Windows.Web.Http.Headers.HttpExpectationHeaderValue} value_or_item_or_searchElement The HttpExpectationHeaderValue to find in the HttpExpectationHeaderValueCollection . / The object to locate in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number} The index of item if found in the collection; otherwise, 1.
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.indexOf = function(value_or_item_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts an HttpExpectationHeaderValue into the collection at the specified index.
 * @param {number} index The zero-based index at which value should be inserted.
 * @param {!Windows.Web.Http.Headers.HttpExpectationHeaderValue} value The object to insert into the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.insertAt = function(index, value) {};

/**
 * Parses and adds an entry to the HttpExpectationHeaderValueCollection .
 * @param {string} input The entry to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.parseAdd = function(input) {};

/**
 * Removes the entry at the specified index from the HttpExpectationHeaderValueCollection .
 * Removes the element at the specified index of the collection.
 * @param {number} index The index of the entry to remove. / The zero-based index of the element to remove.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.removeAt = function(index) {};

/**
 * Removes the last HttpExpectationHeaderValue item from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.removeAtEnd = function() {};

/**
 * Replaces all the HttpExpectationHeaderValue items in the collection with the specified HttpExpectationHeaderValue items.
 * @param {!Windows.Web.Http.Headers.HttpExpectationHeaderValue} items The HttpExpectationHeaderValue items to add to the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.replaceAll = function(items) {};

/**
 * Sets the HttpExpectationHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index at which to set the HttpExpectationHeaderValue .
 * @param {!Windows.Web.Http.Headers.HttpExpectationHeaderValue} value The item to set.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.setAt = function(index, value) {};

/**
 * Tries to parse and add the specified item to the HttpExpectationHeaderValueCollection .
 * @param {string} input The item to parse and add.
 * @return {boolean} true if the item successfully parsed and was added; otherwise false.
 */
Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection.prototype.tryParseAdd = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection = function() {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.size;

/**
 * Adds a new Language item to the end of the collection.
 * @param {!Windows.Globalization.Language} value The new item to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.append = function(value) {};

/**
 * Removes all objects from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first Language item in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Globalization.Language>} An object that can be used to enumerate the Language items in the collection. The iterator points to the first Language item in the HttpLanguageHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.first = function() {};

/**
 * Returns the Language item at the specified index in the collection.
 * @param {number} index The zero-based index of a specified item in the collection.
 * @return {!Windows.Globalization.Language} The Language item at the specified index in the HttpLanguageHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.getAt = function(index) {};

/**
 * Retrieves the Language items that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the Language items in the HttpLanguageHeaderValueCollection .
 * @return {{items: !Windows.Globalization.Language, returnValue: number}}
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.getMany = function(startIndex) {};

/**
 * Returns an immutable view of the HttpLanguageHeaderValueCollection .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Globalization.Language>} The view of the HttpLanguageHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.getView = function() {};

/**
 * Retrieves the index of a Language in the collection.
 * Determines the index of a specific item in the collection.
 * @param {!Windows.Globalization.Language} value_or_item_or_searchElement The item to find in the HttpLanguageHeaderValueCollection . / The object to locate in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number} The index of item if found in the collection; otherwise, 1.
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.indexOf = function(value_or_item_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts a Language into the collection at the specified index.
 * @param {number} index The zero-based index at which value should be inserted.
 * @param {!Windows.Globalization.Language} value The object to insert into the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.insertAt = function(index, value) {};

/**
 * Parses and adds an entry to the HttpLanguageHeaderValueCollection .
 * @param {string} input The entry to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.parseAdd = function(input) {};

/**
 * Removes the entry at the specified index from the HttpLanguageHeaderValueCollection .
 * Removes the element at the specified index of the collection.
 * @param {number} index The index of the entry to remove. / The zero-based index of the element to remove.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.removeAt = function(index) {};

/**
 * Removes the last Language item from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.removeAtEnd = function() {};

/**
 * Replaces all the Language items in the collection with the specified Language items.
 * @param {!Windows.Globalization.Language} items The Language items to add to the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.replaceAll = function(items) {};

/**
 * Sets the Language at the specified index in the collection.
 * @param {number} index The zero-based index at which to set the Language .
 * @param {!Windows.Globalization.Language} value The item to set.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.setAt = function(index, value) {};

/**
 * Tries to parse and add the specified item to the HttpLanguageHeaderValueCollection .
 * @param {string} input The item to parse and add.
 * @return {boolean} true if the item successfully parsed and was added; otherwise false.
 */
Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection.prototype.tryParseAdd = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpLanguageRangeWithQualityHeaderValue class with language-range and quality information.
 * Initializes a new instance of the HttpLanguageRangeWithQualityHeaderValue class with language-range information.
 * @param {string} languageRange The value of the language-range information used in the Accept-Language HTTP header.
 * @param {number=} quality The value of the qvalue or quality factor used in the Accept-Language HTTP header.
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue = function(languageRange, quality) {};
 /** @type {string} */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue.prototype.languageRange;
 /** @type {number} */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue.prototype.quality;

/**
 * Converts a string to an HttpLanguageRangeWithQualityHeaderValue instance.
 * @param {string} input A string that represents the language-range and quality factor information used in the Accept-Encoding HTTP header.
 * @return {!Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue} An HttpLanguageRangeWithQualityHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpLanguageRangeWithQualityHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{languageRangeWithQualityHeaderValue: !Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue.tryParse = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection = function() {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.size;

/**
 * Adds a new HttpLanguageRangeWithQualityHeaderValue item to the end of the collection.
 * @param {!Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue} value The new item to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.append = function(value) {};

/**
 * Removes all objects from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first HttpLanguageRangeWithQualityHeaderValue item in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue>} An object that can be used to enumerate the HttpLanguageRangeWithQualityHeaderValue items in the collection. The iterator points to the first HttpLanguageRangeWithQualityHeaderValue item in the HttpLanguageRangeWithQualityHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.first = function() {};

/**
 * Returns the HttpLanguageRangeWithQualityHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index of a specified item in the collection.
 * @return {!Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue} The HttpLanguageRangeWithQualityHeaderValue at the specified index in the HttpLanguageRangeWithQualityHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.getAt = function(index) {};

/**
 * Retrieves the HttpLanguageRangeWithQualityHeaderValue items that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the HttpLanguageRangeWithQualityHeaderValue items in the HttpLanguageRangeWithQualityHeaderValueCollection .
 * @return {{items: !Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue, returnValue: number}}
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.getMany = function(startIndex) {};

/**
 * Returns an immutable view of the HttpLanguageRangeWithQualityHeaderValueCollection .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue>} The view of the HttpLanguageRangeWithQualityHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.getView = function() {};

/**
 * Retrieves the index of an HttpLanguageRangeWithQualityHeaderValue in the collection.
 * Determines the index of a specific item in the collection.
 * @param {!Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue} value_or_item_or_searchElement The HttpLanguageRangeWithQualityHeaderValue to find in the HttpLanguageRangeWithQualityHeaderValueCollection . / The object to locate in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number} The index of item if found in the collection; otherwise, 1.
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.indexOf = function(value_or_item_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts an HttpLanguageRangeWithQualityHeaderValue into the collection at the specified index.
 * @param {number} index The zero-based index at which value should be inserted.
 * @param {!Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue} value The object to insert into the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.insertAt = function(index, value) {};

/**
 * Parses and adds an entry to the HttpLanguageRangeWithQualityHeaderValueCollection .
 * @param {string} input The entry to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.parseAdd = function(input) {};

/**
 * Removes the entry at the specified index from the HttpLanguageRangeWithQualityHeaderValueCollection .
 * Removes the element at the specified index of the collection.
 * @param {number} index The index of the entry to remove. / The zero-based index of the element to remove.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.removeAt = function(index) {};

/**
 * Removes the last HttpLanguageRangeWithQualityHeaderValue item from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.removeAtEnd = function() {};

/**
 * Replaces all the HttpLanguageRangeWithQualityHeaderValue items in the collection with the specified HttpLanguageRangeWithQualityHeaderValue items.
 * @param {!Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue} items The HttpLanguageRangeWithQualityHeaderValue items to add to the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.replaceAll = function(items) {};

/**
 * Sets the HttpLanguageRangeWithQualityHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index at which to set the HttpLanguageRangeWithQualityHeaderValue .
 * @param {!Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue} value The item to set.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.setAt = function(index, value) {};

/**
 * Tries to parse and add the specified item to the HttpLanguageRangeWithQualityHeaderValueCollection .
 * @param {string} input The item to parse and add.
 * @return {boolean} true if the item successfully parsed and was added; otherwise false.
 */
Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection.prototype.tryParseAdd = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpMediaTypeHeaderValue class.
 * @param {string} mediaType The media-type of the entity-body used in the Content-Type HTTP header.
 */
Windows.Web.Http.Headers.HttpMediaTypeHeaderValue = function(mediaType) {};
 /** @type {string} */
Windows.Web.Http.Headers.HttpMediaTypeHeaderValue.prototype.charSet;
 /** @type {string} */
Windows.Web.Http.Headers.HttpMediaTypeHeaderValue.prototype.mediaType;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Http.Headers.HttpNameValueHeaderValue>} */
Windows.Web.Http.Headers.HttpMediaTypeHeaderValue.prototype.parameters;

/**
 * Converts a string to an HttpMediaTypeHeaderValue instance.
 * @param {string} input A string that represents the media-type and character set information used in the Content-Type HTTP header.
 * @return {!Windows.Web.Http.Headers.HttpMediaTypeHeaderValue} An HttpMediaTypeHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpMediaTypeHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpMediaTypeHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{mediaTypeHeaderValue: !Windows.Web.Http.Headers.HttpMediaTypeHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpMediaTypeHeaderValue.tryParse = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpMediaTypeHeaderValue class with a media type and quality.
 * Initializes a new instance of the HttpMediaTypeHeaderValue class with a media type.
 * @param {string} mediaType The media-type of the entity-body to accept that is used in the Accept HTTP header.
 * @param {number=} quality The qvalue or quality.
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue = function(mediaType, quality) {};
 /** @type {string} */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue.prototype.charSet;
 /** @type {string} */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue.prototype.mediaType;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Http.Headers.HttpNameValueHeaderValue>} */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue.prototype.parameters;
 /** @type {number} */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue.prototype.quality;

/**
 * Converts a string to an HttpMediaTypeWithQualityHeaderValue instance.
 * @param {string} input A string that represents the media-type, character set, and quality information used in the Accept HTTP header.
 * @return {!Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue} An HttpMediaTypeWithQualityHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpMediaTypeWithQualityHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{mediaTypeWithQualityHeaderValue: !Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue.tryParse = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection = function() {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.size;

/**
 * Adds a new HttpMediaTypeWithQualityHeaderValue item to the end of the collection.
 * @param {!Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue} value The new item to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.append = function(value) {};

/**
 * Removes all objects from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first HttpMediaTypeWithQualityHeaderValue item in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue>} An object that can be used to enumerate the HttpMediaTypeWithQualityHeaderValue items in the collection. The iterator points to the first HttpMediaTypeWithQualityHeaderValue item in the HttpMediaTypeWithQualityHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.first = function() {};

/**
 * Returns the HttpMediaTypeWithQualityHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index of a specified item in the collection.
 * @return {!Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue} The HttpMediaTypeWithQualityHeaderValue at the specified index in the HttpMediaTypeWithQualityHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.getAt = function(index) {};

/**
 * Retrieves the HttpMediaTypeWithQualityHeaderValue items that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the HttpMediaTypeWithQualityHeaderValue items in the HttpMediaTypeWithQualityHeaderValueCollection .
 * @return {{items: !Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue, returnValue: number}}
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.getMany = function(startIndex) {};

/**
 * Returns an immutable view of the HttpMediaTypeWithQualityHeaderValueCollection .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue>} The view of the HttpMediaTypeWithQualityHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.getView = function() {};

/**
 * Retrieves the index of an HttpMediaTypeWithQualityHeaderValue in the collection.
 * Determines the index of a specific item in the collection.
 * @param {!Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue} value_or_item_or_searchElement The HttpMediaTypeWithQualityHeaderValue to find in the HttpMediaTypeWithQualityHeaderValueCollection . / The object to locate in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number} The index of item if found in the collection; otherwise, 1.
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.indexOf = function(value_or_item_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts an HttpMediaTypeWithQualityHeaderValue into the collection at the specified index.
 * @param {number} index The zero-based index at which value should be inserted.
 * @param {!Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue} value The object to insert into the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.insertAt = function(index, value) {};

/**
 * Parses and adds an entry to the HttpMediaTypeWithQualityHeaderValueCollection .
 * @param {string} input The entry to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.parseAdd = function(input) {};

/**
 * Removes the entry at the specified index from the HttpMediaTypeWithQualityHeaderValueCollection .
 * Removes the element at the specified index of the collection.
 * @param {number} index The index of the entry to remove. / The zero-based index of the element to remove.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.removeAt = function(index) {};

/**
 * Removes the last HttpMediaTypeWithQualityHeaderValue item from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.removeAtEnd = function() {};

/**
 * Replaces all the HttpMediaTypeWithQualityHeaderValue items in the collection with the specified HttpMediaTypeWithQualityHeaderValue items.
 * @param {!Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue} items The HttpMediaTypeWithQualityHeaderValue items to add to the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.replaceAll = function(items) {};

/**
 * Sets the HttpMediaTypeWithQualityHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index at which to set the HttpMediaTypeWithQualityHeaderValue .
 * @param {!Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue} value The item to set.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.setAt = function(index, value) {};

/**
 * Tries to parse and add the specified item to the HttpMediaTypeWithQualityHeaderValueCollection .
 * @param {string} input The item to parse and add.
 * @return {boolean} true if the item successfully parsed and was added; otherwise false.
 */
Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection.prototype.tryParseAdd = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection = function() {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.size;

/**
 * Adds a new HttpMethod item to the end of the collection.
 * @param {!Windows.Web.Http.HttpMethod} value The new item to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.append = function(value) {};

/**
 * Removes all objects from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first HttpMethod item in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.HttpMethod>} An object that can be used to enumerate the HttpMethod items in the collection. The iterator points to the first HttpMethod item in the HttpMethodHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.first = function() {};

/**
 * Returns the HttpMethod at the specified index in the collection.
 * @param {number} index The zero-based index of a specified item in the collection.
 * @return {!Windows.Web.Http.HttpMethod} The HttpMethod at the specified index in the HttpMethodHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.getAt = function(index) {};

/**
 * Retrieves the HttpMethod items that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the HttpMethod items in the HttpMethodHeaderValueCollection .
 * @return {{items: !Windows.Web.Http.HttpMethod, returnValue: number}}
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.getMany = function(startIndex) {};

/**
 * Returns an immutable view of the HttpMethodHeaderValueCollection .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Http.HttpMethod>} The view of the HttpMethodHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.getView = function() {};

/**
 * Retrieves the index of an HttpMethod in the collection.
 * Determines the index of a specific item in the collection.
 * @param {!Windows.Web.Http.HttpMethod} value_or_item_or_searchElement The HttpMethod to find in the HttpMethodHeaderValueCollection . / The object to locate in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number} The index of item if found in the collection; otherwise, 1.
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.indexOf = function(value_or_item_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts an HttpMethod into the collection at the specified index.
 * @param {number} index The zero-based index at which value should be inserted.
 * @param {!Windows.Web.Http.HttpMethod} value The object to insert into the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.insertAt = function(index, value) {};

/**
 * Parses and adds an entry to the HttpMethodHeaderValueCollection .
 * @param {string} input The entry to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.parseAdd = function(input) {};

/**
 * Removes the entry at the specified index from the HttpMethodHeaderValueCollection .
 * Removes the element at the specified index of the collection.
 * @param {number} index The index of the entry to remove. / The zero-based index of the element to remove.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.removeAt = function(index) {};

/**
 * Removes the last HttpMethod item from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.removeAtEnd = function() {};

/**
 * Replaces all the HttpMethod items in the collection with the specified HttpMethod items.
 * @param {!Windows.Web.Http.HttpMethod} items The HttpMethod items to add to the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.replaceAll = function(items) {};

/**
 * Sets the HttpMethod at the specified index in the collection.
 * @param {number} index The zero-based index at which to set the HttpMethod .
 * @param {!Windows.Web.Http.HttpMethod} value The item to set.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.setAt = function(index, value) {};

/**
 * Tries to parse and add the specified item to the HttpMethodHeaderValueCollection .
 * @param {string} input The item to parse and add.
 * @return {boolean} true if the item successfully parsed and was added; otherwise false.
 */
Windows.Web.Http.Headers.HttpMethodHeaderValueCollection.prototype.tryParseAdd = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpNameValueHeaderValue class. with a name and value.
 * Initializes a new instance of the HttpNameValueHeaderValue class. with a name.
 * @param {string} name The name to be used.
 * @param {string=} value The value to associate with the name.
 */
Windows.Web.Http.Headers.HttpNameValueHeaderValue = function(name, value) {};
 /** @type {string} */
Windows.Web.Http.Headers.HttpNameValueHeaderValue.prototype.name;
 /** @type {string} */
Windows.Web.Http.Headers.HttpNameValueHeaderValue.prototype.value;

/**
 * Converts a string to an HttpNameValueHeaderValue instance.
 * @param {string} input A string that represents the name and value.
 * @return {!Windows.Web.Http.Headers.HttpNameValueHeaderValue} An HttpNameValueHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpNameValueHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpNameValueHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{nameValueHeaderValue: !Windows.Web.Http.Headers.HttpNameValueHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpNameValueHeaderValue.tryParse = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpProductHeaderValue class with a product name and a product version.
 * Initializes a new instance of the HttpProductHeaderValue class with a product name.
 * @param {string} productName The name of the product token used in the User-Agent HTTP header.
 * @param {string=} productVersion The version of the product token used in the User-Agent HTTP header.
 */
Windows.Web.Http.Headers.HttpProductHeaderValue = function(productName, productVersion) {};
 /** @type {string} */
Windows.Web.Http.Headers.HttpProductHeaderValue.prototype.name;
 /** @type {string} */
Windows.Web.Http.Headers.HttpProductHeaderValue.prototype.version;

/**
 * Converts a string to an HttpProductHeaderValue instance.
 * @param {string} input A string that represents the product name and version.
 * @return {!Windows.Web.Http.Headers.HttpProductHeaderValue} An HttpProductHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpProductHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpProductHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{productHeaderValue: !Windows.Web.Http.Headers.HttpProductHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpProductHeaderValue.tryParse = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpProductInfoHeaderValue class with a product name and version.
 * Initializes a new instance of the HttpProductInfoHeaderValue class with a product comment.
 * @param {string} productName_or_productComment The name of the product token used in the User-Agent HTTP header. / The product comment used in the User-Agent HTTP header.
 * @param {string=} productVersion The version of the product token used in the User-Agent HTTP header.
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValue = function(productName_or_productComment, productVersion) {};
 /** @type {string} */
Windows.Web.Http.Headers.HttpProductInfoHeaderValue.prototype.comment;
 /** @type {!Windows.Web.Http.Headers.HttpProductHeaderValue} */
Windows.Web.Http.Headers.HttpProductInfoHeaderValue.prototype.product;

/**
 * Converts a string to an HttpProductInfoHeaderValue instance.
 * @param {string} input A string that represents the product information.
 * @return {!Windows.Web.Http.Headers.HttpProductInfoHeaderValue} An HttpProductInfoHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpProductInfoHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{productInfoHeaderValue: !Windows.Web.Http.Headers.HttpProductInfoHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValue.tryParse = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection = function() {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.size;

/**
 * Adds a new HttpProductInfoHeaderValue item to the end of the collection.
 * @param {!Windows.Web.Http.Headers.HttpProductInfoHeaderValue} value The new item to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.append = function(value) {};

/**
 * Removes all objects from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first HttpProductInfoHeaderValue item in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.Headers.HttpProductInfoHeaderValue>} An object that can be used to enumerate the HttpProductInfoHeaderValue items in the collection. The iterator points to the first HttpProductInfoHeaderValue item in the HttpProductInfoHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.first = function() {};

/**
 * Returns the HttpProductInfoHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index of a specified item in the collection.
 * @return {!Windows.Web.Http.Headers.HttpProductInfoHeaderValue} The HttpProductInfoHeaderValue at the specified index in the HttpProductInfoHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.getAt = function(index) {};

/**
 * Retrieves the HttpProductInfoHeaderValue items that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the HttpProductInfoHeaderValue items in the HttpProductInfoHeaderValueCollection .
 * @return {{items: !Windows.Web.Http.Headers.HttpProductInfoHeaderValue, returnValue: number}}
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.getMany = function(startIndex) {};

/**
 * Returns an immutable view of the HttpProductInfoHeaderValueCollection .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Http.Headers.HttpProductInfoHeaderValue>} The view of the HttpProductInfoHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.getView = function() {};

/**
 * Determines whether an element is in the collection.
 * Retrieves the index of an HttpProductInfoHeaderValue in the collection.
 * Determines the index of a specific item in the collection.
 * @param {!Windows.Web.Http.Headers.HttpProductInfoHeaderValue} item_or_value_or_searchElement The item to find in the collection. / The HttpProductInfoHeaderValue to find in the HttpProductInfoHeaderValueCollection . / The object to locate in the collection.
 * @param {...?|number=} extra_or_fromIndex
 * @return {boolean|{index: number, returnValue: boolean}|number} true if the item was found in the collection; otherwise, false. / The index of item if found in the collection; otherwise, 1.
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.indexOf = function(item_or_value_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts an HttpProductInfoHeaderValue into the collection at the specified index.
 * @param {number} index The zero-based index at which value should be inserted.
 * @param {!Windows.Web.Http.Headers.HttpProductInfoHeaderValue} value The object to insert into the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.insertAt = function(index, value) {};

/**
 * Parses and adds an entry to the HttpProductInfoHeaderValueCollection .
 * @param {string} input The entry to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.parseAdd = function(input) {};

/**
 * Removes the entry at the specified index from the HttpMethodHeaderValueCollection.
 * Removes the element at the specified index of the collection.
 * @param {number} index The index of the entry to remove. / The zero-based index of the element to remove.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.removeAt = function(index) {};

/**
 * Removes the last HttpProductInfoHeaderValue item from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.removeAtEnd = function() {};

/**
 * Replaces all the HttpProductInfoHeaderValue items in the collection with the specified HttpProductInfoHeaderValue items.
 * @param {!Windows.Web.Http.Headers.HttpProductInfoHeaderValue} items The HttpProductInfoHeaderValue items to add to the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.replaceAll = function(items) {};

/**
 * Sets the HttpProductInfoHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index at which to set the HttpProductInfoHeaderValue .
 * @param {!Windows.Web.Http.Headers.HttpProductInfoHeaderValue} value The item to set.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.setAt = function(index, value) {};

/**
 * Tries to parse and add the specified item to the HttpProductInfoHeaderValueCollection .
 * @param {string} input The item to parse and add.
 * @return {boolean} true if the item successfully parsed and was added; otherwise false.
 */
Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection.prototype.tryParseAdd = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpRequestHeaderCollection = function() {};
 /** @type {!Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.accept;
 /** @type {!Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.acceptEncoding;
 /** @type {!Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.acceptLanguage;
 /** @type {!Windows.Web.Http.Headers.HttpCredentialsHeaderValue} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.authorization;
 /** @type {!Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.cacheControl;
 /** @type {!Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.connection;
 /** @type {!Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.cookie;
 /** @type {!Date} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.date;
 /** @type {!Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.expect;
 /** @type {string} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.from;
 /** @type {!Windows.Networking.HostName} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.host;
 /** @type {!Date} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.ifModifiedSince;
 /** @type {!Date} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.ifUnmodifiedSince;
 /** @type {number} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.maxForwards;
 /** @type {!Windows.Web.Http.Headers.HttpCredentialsHeaderValue} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.proxyAuthorization;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.referer;
 /** @type {number} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.size;
 /** @type {!Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.transferEncoding;
 /** @type {!Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection} */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.userAgent;

/**
 * Adds a new item to the end of the HttpRequestHeaderCollection .
 * @param {string} name The name of the value to add.
 * @param {string} value The item value to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.append = function(name, value) {};

/**
 * Removes all objects from the HttpRequestHeaderCollection .
 * @return {void}
 */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first item in the HttpRequestHeaderCollection .
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} An object that can be used to enumerate the items in the collection. The iterator points to the first item in the HttpRequestHeaderCollection .
 */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.first = function() {};

/**
 * Returns an immutable view of the HttpRequestHeaderCollection .
 * @return {!Windows.Foundation.Collections.IMapView<string, string>} The view of the HttpRequestHeaderCollection .
 */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.getView = function() {};

/**
 * Determines whether the HttpRequestHeaderCollection contains the specified key.
 * @param {string} key The key associated with the item to locate.
 * @return {boolean} true if the key is found; otherwise, false.
 */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.hasKey = function(key) {};

/**
 * Inserts or replaces an item in the HttpRequestHeaderCollection with the specified key and value.
 * @param {string} key The key of the item to be inserted.
 * @param {string} value The value of the item to insert.
 * @return {boolean} true if an item with the specified key is an existing item that was replaced; otherwise false.
 */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.insert = function(key, value) {};

/**
 * Finds an item in the HttpRequestHeaderCollection if it exists.
 * @param {string} key The key of the item to lookup.
 * @return {string} The value of the item if found.
 */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.lookup = function(key) {};

/**
 * Removes a specific object from the HttpRequestHeaderCollection .
 * Removes a specific item from the HttpRequestHeaderCollection .
 * @param {string} key The key of the item to remove.
 * @return {void|boolean} true if the item was removed, otherwise false.
 */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.remove = function(key) {};

/**
 * Try to append the specified item to the HttpRequestHeaderCollection without validation.
 * @param {string} name The name of the item to append.
 * @param {string} value The value of the item to append.
 * @return {boolean} true if the item was appended; otherwise false.
 */
Windows.Web.Http.Headers.HttpRequestHeaderCollection.prototype.tryAppendWithoutValidation = function(name, value) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpResponseHeaderCollection = function() {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.age;
 /** @type {!Windows.Web.Http.Headers.HttpMethodHeaderValueCollection} */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.allow;
 /** @type {!Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection} */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.cacheControl;
 /** @type {!Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection} */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.connection;
 /** @type {!Date} */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.date;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.location;
 /** @type {!Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection} */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.proxyAuthenticate;
 /** @type {!Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue} */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.retryAfter;
 /** @type {number} */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.size;
 /** @type {!Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection} */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.transferEncoding;
 /** @type {!Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection} */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.wwwAuthenticate;

/**
 * Adds a new item to the end of the HttpResponseHeaderCollection .
 * @param {string} name The name of the value to add.
 * @param {string} value The item value to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.append = function(name, value) {};

/**
 * Removes all objects from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first item in the HttpResponseHeaderCollection .
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} An object that can be used to enumerate the items in the collection. The iterator points to the first item in the HttpResponseHeaderCollection .
 */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.first = function() {};

/**
 * Returns an immutable view of the HttpResponseHeaderCollection .
 * @return {!Windows.Foundation.Collections.IMapView<string, string>} The view of the HttpResponseHeaderCollection .
 */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.getView = function() {};

/**
 * Determines whether the HttpResponseHeaderCollection contains the specified key.
 * @param {string} key The key associated with the item to locate.
 * @return {boolean} true if the key is found; otherwise, false.
 */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.hasKey = function(key) {};

/**
 * Inserts or replaces an item in the HttpResponseHeaderCollection with the specified key and value.
 * @param {string} key The key of the item to be inserted.
 * @param {string} value The value of the item to insert.
 * @return {boolean} true if an item with the specified key is an existing item that was replaced; otherwise false.
 */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.insert = function(key, value) {};

/**
 * Lookup an item in the HttpResponseHeaderCollection .
 * @param {string} key The key of the item to lookup.
 * @return {string} The value of the item if found.
 */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.lookup = function(key) {};

/**
 * Removes an item with a given key from the HttpResponseHeaderCollection .
 * @param {string} key Key of the item to be removed.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.remove = function(key) {};

/**
 * Try to append the specified item to the HttpResponseHeaderCollection without validation.
 * @param {string} name The name of the item to append.
 * @param {string} value The value of the item to append.
 * @return {boolean} true if the item was appended; otherwise false.
 */
Windows.Web.Http.Headers.HttpResponseHeaderCollection.prototype.tryAppendWithoutValidation = function(name, value) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpProductInfoHeaderValue class.
 * @param {string} input The transfer-coding information to initialize the HttpProductInfoHeaderValue object.
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValue = function(input) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Http.Headers.HttpNameValueHeaderValue>} */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValue.prototype.parameters;
 /** @type {string} */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValue.prototype.value;

/**
 * Converts a string to an HttpTransferCodingHeaderValue instance.
 * @param {string} input A string that represents the transfer-coding information.
 * @return {!Windows.Web.Http.Headers.HttpTransferCodingHeaderValue} An HttpProductInfoHeaderValue instance.
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValue.parse = function(input) {};

/**
 * Determines whether a string is valid HttpTransferCodingHeaderValue information.
 * @param {string} input The string to validate.
 * @return {{transferCodingHeaderValue: !Windows.Web.Http.Headers.HttpTransferCodingHeaderValue, returnValue: boolean}}
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValue.tryParse = function(input) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection = function() {};
 /** @type {number} */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.size;

/**
 * Adds a new HttpTransferCodingHeaderValue item to the end of the collection.
 * @param {!Windows.Web.Http.Headers.HttpTransferCodingHeaderValue} value The new item to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.append = function(value) {};

/**
 * Removes all objects from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.clear = function() {};

/**
 * Retrieves an iterator to the first HttpTransferCodingHeaderValue item in the collection.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.Headers.HttpTransferCodingHeaderValue>} An object that can be used to enumerate the HttpTransferCodingHeaderValue items in the collection. The iterator points to the first HttpTransferCodingHeaderValue item in the HttpTransferCodingHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.first = function() {};

/**
 * Returns the HttpTransferCodingHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index of a specified item in the collection.
 * @return {!Windows.Web.Http.Headers.HttpTransferCodingHeaderValue} The HttpTransferCodingHeaderValue at the specified index in the HttpTransferCodingHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.getAt = function(index) {};

/**
 * Retrieves the HttpTransferCodingHeaderValue items that start at the specified index in the collection.
 * @param {number} startIndex The zero-based index of the start of the HttpTransferCodingHeaderValue items in the HttpTransferCodingHeaderValueCollection .
 * @return {{items: !Windows.Web.Http.Headers.HttpTransferCodingHeaderValue, returnValue: number}}
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.getMany = function(startIndex) {};

/**
 * Returns an immutable view of the HttpTransferCodingHeaderValueCollection .
 * @return {!Windows.Foundation.Collections.IVectorView<!Windows.Web.Http.Headers.HttpTransferCodingHeaderValue>} The view of the HttpTransferCodingHeaderValueCollection .
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.getView = function() {};

/**
 * Determines the index of a specific item in the collection.
 * Determines whether an element is in the collection.
 * Retrieves the index of an HttpTransferCodingHeaderValue in the collection.
 * @param {!Windows.Web.Http.Headers.HttpTransferCodingHeaderValue} item_or_value_or_searchElement The object to locate in the collection. / The item to find in the collection. / The HttpTransferCodingHeaderValue to find in the HttpTransferCodingHeaderValueCollection .
 * @param {...?|number=} extra_or_fromIndex
 * @return {number|boolean|{index: number, returnValue: boolean}} The index of item if found in the collection; otherwise, 1. / true if the item was found in the collection; otherwise, false.
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.indexOf = function(item_or_value_or_searchElement, extra_or_fromIndex) {};

/**
 * Inserts an HttpTransferCodingHeaderValue into the collection at the specified index.
 * @param {number} index The zero-based index at which value should be inserted.
 * @param {!Windows.Web.Http.Headers.HttpTransferCodingHeaderValue} value The object to insert into the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.insertAt = function(index, value) {};

/**
 * Parses and adds an entry to the HttpTransferCodingHeaderValueCollection .
 * @param {string} input The entry to add.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.parseAdd = function(input) {};

/**
 * Removes the entry at the specified index from the HttpTransferCodingHeaderValueCollection .
 * Removes the element at the specified index of the collection.
 * @param {number} index The index of the entry to remove. / The zero-based index of the element to remove.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.removeAt = function(index) {};

/**
 * Removes the last HttpTransferCodingHeaderValue item from the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.removeAtEnd = function() {};

/**
 * Replaces all the HttpTransferCodingHeaderValue items in the collection with the specified HttpTransferCodingHeaderValue items.
 * @param {!Windows.Web.Http.Headers.HttpTransferCodingHeaderValue} items The HttpTransferCodingHeaderValue items to add to the collection.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.replaceAll = function(items) {};

/**
 * Sets the HttpTransferCodingHeaderValue at the specified index in the collection.
 * @param {number} index The zero-based index at which to set the HttpTransferCodingHeaderValue .
 * @param {!Windows.Web.Http.Headers.HttpTransferCodingHeaderValue} value The item to set.
 * @return {void}
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.setAt = function(index, value) {};

/**
 * Tries to parse and add the specified item to the HttpTransferCodingHeaderValueCollection .
 * @param {string} input The item to parse and add.
 * @return {boolean} true if the item successfully parsed and was added; otherwise false.
 */
Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection.prototype.tryParseAdd = function(input) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpBufferContent class with the specified buffer.
 * Initializes a new instance of the HttpBufferContent class with an offset and count of bytes from the specified buffer.
 * @param {!Windows.Storage.Streams.IBuffer} content The content used to initialize the HttpBufferContent .
 * @param {number=} offset The offset in bytes from the beginning of the content buffer to initialize the HttpBufferContent .
 * @param {number=} count The count of bytes in the content buffer to initialize the HttpBufferContent .
 */
Windows.Web.Http.HttpBufferContent = function(content, offset, count) {};
 /** @type {!Windows.Web.Http.Headers.HttpContentHeaderCollection} */
Windows.Web.Http.HttpBufferContent.prototype.headers;

/**
 * Serialize the HttpBufferContent into memory as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpBufferContent.prototype.bufferAllAsync = function() {};

/**
 * Closes the HttpBufferContent instance and releases allocated resources.
 * @return {void}
 */
Windows.Web.Http.HttpBufferContent.prototype.close = function() {};

/**
 * Serialize the HttpBufferContent to a buffer as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpBufferContent.prototype.readAsBufferAsync = function() {};

/**
 * Serialize the HttpBufferContent and return an input stream that represents the content as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IInputStream, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IInputStream, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpBufferContent.prototype.readAsInputStreamAsync = function() {};

/**
 * Serialize the HttpBufferContent to a String as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperationWithProgress<string, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpBufferContent.prototype.readAsStringAsync = function() {};

/**
 * Computes the HttpBufferContent length in bytes.
 * @return {{length: number, returnValue: boolean}}
 */
Windows.Web.Http.HttpBufferContent.prototype.tryComputeLength = function() {};

/**
 * Write the HttpBufferContent to an output stream as an asynchronous operation.
 * @param {!Windows.Storage.Streams.IOutputStream} outputStream The output stream to write to.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpBufferContent.prototype.writeToStreamAsync = function(outputStream) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpClient class.
 * Initializes a new instance of the HttpClient class with a specific filter for handling HTTP response messages.
 * @param {!Windows.Web.Http.Filters.IHttpFilter=} filter The HTTP filter to use for handling response messages.
 */
Windows.Web.Http.HttpClient = function(filter) {};
 /** @type {!Windows.Web.Http.Headers.HttpRequestHeaderCollection} */
Windows.Web.Http.HttpClient.prototype.defaultRequestHeaders;

/**
 * Closes the HttpClient instance and releases allocated resources.
 * @return {void}
 */
Windows.Web.Http.HttpClient.prototype.close = function() {};

/**
 * Send a DELETE request to the specified Uri as an asynchronous operation.
 * @param {!Windows.Foundation.Uri} uri The Uri the request is sent to.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Web.Http.HttpResponseMessage, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Web.Http.HttpResponseMessage, !Windows.Web.Http.HttpProgress>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpClient.prototype.deleteAsync = function(uri) {};

/**
 * Send a GET request to the specified Uri with an HTTP completion option as an asynchronous operation.
 * Send a GET request to the specified Uri as an asynchronous operation.
 * @param {!Windows.Foundation.Uri} uri The Uri the request is sent to. / The Uri to which the request is to be sent.
 * @param {Windows.Web.Http.HttpCompletionOption=} completionOption An HTTP completion option value that indicates when the operation should be considered completed.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Web.Http.HttpResponseMessage, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Web.Http.HttpResponseMessage, !Windows.Web.Http.HttpProgress>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpClient.prototype.getAsync = function(uri, completionOption) {};

/**
 * Send a GET request to the specified Uri and return the response body as a buffer in an asynchronous operation.
 * @param {!Windows.Foundation.Uri} uri The Uri the request is sent to.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, !Windows.Web.Http.HttpProgress>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpClient.prototype.getBufferAsync = function(uri) {};

/**
 * Send a GET request to the specified Uri and return the response body as a stream in an asynchronous operation.
 * @param {!Windows.Foundation.Uri} uri The Uri the request is sent to.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IInputStream, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IInputStream, !Windows.Web.Http.HttpProgress>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpClient.prototype.getInputStreamAsync = function(uri) {};

/**
 * Send a GET request to the specified Uri and return the response body as a string in an asynchronous operation.
 * @param {!Windows.Foundation.Uri} uri The Uri the request is sent to.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperationWithProgress<string, !Windows.Web.Http.HttpProgress>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpClient.prototype.getStringAsync = function(uri) {};

/**
 * Send a POST request to the specified Uri as an asynchronous operation.
 * @param {!Windows.Foundation.Uri} uri The Uri the request is sent to.
 * @param {!Windows.Web.Http.IHttpContent} content The HTTP request content to send to the server.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Web.Http.HttpResponseMessage, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Web.Http.HttpResponseMessage, !Windows.Web.Http.HttpProgress>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpClient.prototype.postAsync = function(uri, content) {};

/**
 * Send a PUT request to the specified Uri as an asynchronous operation.
 * @param {!Windows.Foundation.Uri} uri The Uri the request is sent to.
 * @param {!Windows.Web.Http.IHttpContent} content The HTTP request content to send to the server.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Web.Http.HttpResponseMessage, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Web.Http.HttpResponseMessage, !Windows.Web.Http.HttpProgress>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpClient.prototype.putAsync = function(uri, content) {};

/**
 * Send an HTTP request with an HTTP completion option as an asynchronous operation.
 * Send an HTTP request as an asynchronous operation.
 * @param {!Windows.Web.Http.HttpRequestMessage} request The HTTP request message to send.
 * @param {Windows.Web.Http.HttpCompletionOption=} completionOption A value that indicates whether the HttpClient operation is considered completed when all of the response is read, or when just the headers are read.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Web.Http.HttpResponseMessage, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Web.Http.HttpResponseMessage, !Windows.Web.Http.HttpProgress>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpClient.prototype.sendRequestAsync = function(request, completionOption) {};

/** @const */
Windows.Web.Http.HttpCompletionOption = {};
/** @const {number} */
Windows.Web.Http.HttpCompletionOption.responseContentRead;
/** @const {number} */
Windows.Web.Http.HttpCompletionOption.responseHeadersRead;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpCookie class with a specified name, domain, and path.
 * @param {string} name The name for the HttpCookie
 * @param {string} domain The domain for which the HttpCookie is valid.
 * @param {string} path The URIs to which the HttpCookie applies.
 */
Windows.Web.Http.HttpCookie = function(name, domain, path) {};
 /** @type {string} */
Windows.Web.Http.HttpCookie.prototype.domain;
 /** @type {!Date} */
Windows.Web.Http.HttpCookie.prototype.expires;
 /** @type {boolean} */
Windows.Web.Http.HttpCookie.prototype.httpOnly;
 /** @type {string} */
Windows.Web.Http.HttpCookie.prototype.name;
 /** @type {string} */
Windows.Web.Http.HttpCookie.prototype.path;
 /** @type {boolean} */
Windows.Web.Http.HttpCookie.prototype.secure;
 /** @type {string} */
Windows.Web.Http.HttpCookie.prototype.value;
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.HttpCookieCollection = function() {};
 /** @type {number} */
Windows.Web.Http.HttpCookieCollection.prototype.size;

/**
 * Retrieves an iterator to the first HttpCookie item in the HttpCookieCollection .
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.HttpCookie>} An iterator to the first HttpCookie item in the HttpCookieCollection .
 */
Windows.Web.Http.HttpCookieCollection.prototype.first = function() {};

/**
 * Returns the HttpCookie at the specified index from the HttpCookieCollection .
 * @param {number} index The zero-based index of a specified item in the HttpCookieCollection .
 * @return {!Windows.Web.Http.HttpCookie} The HTTP cookie at the specified index from the HttpCookieCollection .
 */
Windows.Web.Http.HttpCookieCollection.prototype.getAt = function(index) {};

/**
 * Retrieves the HttpCookie items that start at the specified index in the HttpCookieCollection .
 * @param {number} startIndex The zero-based index of the start of the HttpCookie items in the HttpCookieCollection .
 * @return {{items: !Windows.Web.Http.HttpCookie, returnValue: number}}
 */
Windows.Web.Http.HttpCookieCollection.prototype.getMany = function(startIndex) {};

/**
 * Retrieves the index of an HttpCookie in the HttpCookieCollection .
 * @param {!Windows.Web.Http.HttpCookie} value_or_searchElement The HttpCookie to find in the HttpCookieCollection .
 * @param {...?|number=} extra_or_fromIndex
 * @return {{index: number, returnValue: boolean}|number}
 */
Windows.Web.Http.HttpCookieCollection.prototype.indexOf = function(value_or_searchElement, extra_or_fromIndex) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.HttpCookieManager = function() {};

/**
 * Delete an HttpCookie from the cookies associated with an app.
 * @param {!Windows.Web.Http.HttpCookie} cookie The HttpCookie to delete.
 * @return {void}
 */
Windows.Web.Http.HttpCookieManager.prototype.deleteCookie = function(cookie) {};

/**
 * Gets an HttpCookieCollection that contains the HttpCookie instances that are associated with a specific URI.
 * @param {!Windows.Foundation.Uri} uri The URI of the HttpCookie instances desired.
 * @return {!Windows.Web.Http.HttpCookieCollection} The HttpCookieCollection that contains the HttpCookie instances that are associated with a specific URI.
 */
Windows.Web.Http.HttpCookieManager.prototype.getCookies = function(uri) {};

/**
 * Add or change an HttpCookie in the cookies associated with an app.
 * Add or change an HttpCookie in the cookies associated with an app that is sent on future requests.
 * @param {!Windows.Web.Http.HttpCookie} cookie The HttpCookie to change or add.
 * @param {boolean=} thirdParty A value that indicates whether the HttpCookie is a third party HTTP cookie.
 * @return {boolean} true if the HttpCookie replaced an existing cookie; otherwise false.
 */
Windows.Web.Http.HttpCookieManager.prototype.setCookie = function(cookie, thirdParty) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpFormUrlEncodedContent class with the specified content.
 * @param {!Windows.Foundation.Collections.IIterable<!Windows.Foundation.Collections.IKeyValuePair<?, ?>>} content The content used to initialize the HttpFormUrlEncodedContent .
 */
Windows.Web.Http.HttpFormUrlEncodedContent = function(content) {};
 /** @type {!Windows.Web.Http.Headers.HttpContentHeaderCollection} */
Windows.Web.Http.HttpFormUrlEncodedContent.prototype.headers;

/**
 * Serialize the HttpFormUrlEncodedContent into memory as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpFormUrlEncodedContent.prototype.bufferAllAsync = function() {};

/**
 * Closes the HttpFormUrlEncodedContent instance and releases allocated resources.
 * @return {void}
 */
Windows.Web.Http.HttpFormUrlEncodedContent.prototype.close = function() {};

/**
 * Serialize the HttpFormUrlEncodedContent to a buffer as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpFormUrlEncodedContent.prototype.readAsBufferAsync = function() {};

/**
 * Serialize the HttpFormUrlEncodedContent and return an input stream that represents the content as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IInputStream, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IInputStream, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpFormUrlEncodedContent.prototype.readAsInputStreamAsync = function() {};

/**
 * Serialize the HttpFormUrlEncodedContent to a String as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperationWithProgress<string, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpFormUrlEncodedContent.prototype.readAsStringAsync = function() {};

/**
 * Computes the HttpFormUrlEncodedContent length in bytes.
 * @return {{length: number, returnValue: boolean}}
 */
Windows.Web.Http.HttpFormUrlEncodedContent.prototype.tryComputeLength = function() {};

/**
 * Write the HttpFormUrlEncodedContent to an output stream as an asynchronous operation.
 * @param {!Windows.Storage.Streams.IOutputStream} outputStream The output stream to write to.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpFormUrlEncodedContent.prototype.writeToStreamAsync = function(outputStream) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpMethod class with a specific HTTP method.
 * @param {string} method The HTTP method.
 */
Windows.Web.Http.HttpMethod = function(method) {};
 /** @type {!Windows.Web.Http.HttpMethod} */
Windows.Web.Http.HttpMethod.delete;
 /** @type {!Windows.Web.Http.HttpMethod} */
Windows.Web.Http.HttpMethod.get;
 /** @type {!Windows.Web.Http.HttpMethod} */
Windows.Web.Http.HttpMethod.head;
 /** @type {!Windows.Web.Http.HttpMethod} */
Windows.Web.Http.HttpMethod.options;
 /** @type {!Windows.Web.Http.HttpMethod} */
Windows.Web.Http.HttpMethod.patch;
 /** @type {!Windows.Web.Http.HttpMethod} */
Windows.Web.Http.HttpMethod.post;
 /** @type {!Windows.Web.Http.HttpMethod} */
Windows.Web.Http.HttpMethod.put;
 /** @type {string} */
Windows.Web.Http.HttpMethod.prototype.method;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpMultipartContent class.
 * Initializes a new instance of the HttpMultipartContent class with the specified MIME subtype and boundary string.
 * Initializes a new instance of the HttpMultipartContent class with the specified MIME subtype.
 * @param {string=} subtype The MIME subtype of the multipart content.
 * @param {string=} boundary The boundary string for the multipart content.
 */
Windows.Web.Http.HttpMultipartContent = function(subtype, boundary) {};
 /** @type {!Windows.Web.Http.Headers.HttpContentHeaderCollection} */
Windows.Web.Http.HttpMultipartContent.prototype.headers;

/**
 * Add HTTP content to the HttpMultipartContent instance.
 * @param {!Windows.Web.Http.IHttpContent} content The HTTP content to add to HttpMultipartContent .
 * @return {void}
 */
Windows.Web.Http.HttpMultipartContent.prototype.add = function(content) {};

/**
 * Serialize the HttpMultipartContent into memory as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpMultipartContent.prototype.bufferAllAsync = function() {};

/**
 * Closes the HttpMultipartContent instance and releases allocated resources.
 * @return {void}
 */
Windows.Web.Http.HttpMultipartContent.prototype.close = function() {};

/**
 * Gets an object that can be used to enumerate the contents in the HttpMultipartContent object.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.IHttpContent>} An object that can be used to enumerate the contents in the HttpMultipartContent object.
 */
Windows.Web.Http.HttpMultipartContent.prototype.first = function() {};

/**
 * Serialize the HttpMultipartContent to a buffer as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpMultipartContent.prototype.readAsBufferAsync = function() {};

/**
 * Serialize the HttpMultipartContent and return an input stream that represents the content as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IInputStream, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IInputStream, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpMultipartContent.prototype.readAsInputStreamAsync = function() {};

/**
 * Serialize the HttpMultipartContent to a String as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperationWithProgress<string, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpMultipartContent.prototype.readAsStringAsync = function() {};

/**
 * Determines whether the HttpMultipartContent has a valid length in bytes.
 * @return {{length: number, returnValue: boolean}}
 */
Windows.Web.Http.HttpMultipartContent.prototype.tryComputeLength = function() {};

/**
 * Write the HttpMultipartContent to an output stream as an asynchronous operation.
 * @param {!Windows.Storage.Streams.IOutputStream} outputStream The output stream to write to.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpMultipartContent.prototype.writeToStreamAsync = function(outputStream) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpMultipartFormDataContent class.
 * Initializes a new instance of the HttpMultipartFormDataContent class with the specified boundary string.
 * @param {string=} boundary The boundary string for the multipart content.
 */
Windows.Web.Http.HttpMultipartFormDataContent = function(boundary) {};
 /** @type {!Windows.Web.Http.Headers.HttpContentHeaderCollection} */
Windows.Web.Http.HttpMultipartFormDataContent.prototype.headers;

/**
 * Add HTTP content with a specified name from a file to the HttpMultipartFormDataContent instance.
 * Add HTTP content to the HttpMultipartFormDataContent instance.
 * Add HTTP content with a specified name to the HttpMultipartFormDataContent instance.
 * @param {!Windows.Web.Http.IHttpContent} content The HTTP content to add to HttpMultipartFormDataContent .
 * @param {string=} name The name for the HTTP content to add to HttpMultipartFormDataContent .
 * @param {string=} fileName The file name for the HTTP content to add to HttpMultipartFormDataContent .
 * @return {void}
 */
Windows.Web.Http.HttpMultipartFormDataContent.prototype.add = function(content, name, fileName) {};

/**
 * Serialize the HttpMultipartFormDataContent into memory as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpMultipartFormDataContent.prototype.bufferAllAsync = function() {};

/**
 * Closes the HttpMultipartFormDataContent instance and releases allocated resources.
 * @return {void}
 */
Windows.Web.Http.HttpMultipartFormDataContent.prototype.close = function() {};

/**
 * Gets an object that can be used to enumerate the contents in the HttpMultipartFormDataContent object.
 * @return {!Windows.Foundation.Collections.IIterator<!Windows.Web.Http.IHttpContent>} An object that can be used to enumerate the contents in the HttpMultipartFormDataContent object.
 */
Windows.Web.Http.HttpMultipartFormDataContent.prototype.first = function() {};

/**
 * Serialize the HttpMultipartFormDataContent to a buffer as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpMultipartFormDataContent.prototype.readAsBufferAsync = function() {};

/**
 * Serialize the HttpMultipartFormDataContent and return an input stream that represents the content as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IInputStream, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IInputStream, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpMultipartFormDataContent.prototype.readAsInputStreamAsync = function() {};

/**
 * Serialize the HttpMultipartFormDataContent to a String as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperationWithProgress<string, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpMultipartFormDataContent.prototype.readAsStringAsync = function() {};

/**
 * Determines whether the HttpMultipartFormDataContent has a valid length in bytes.
 * @return {{length: number, returnValue: boolean}}
 */
Windows.Web.Http.HttpMultipartFormDataContent.prototype.tryComputeLength = function() {};

/**
 * Write the HttpMultipartFormDataContent to an output stream as an asynchronous operation.
 * @param {!Windows.Storage.Streams.IOutputStream} outputStream The output stream to write to.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpMultipartFormDataContent.prototype.writeToStreamAsync = function(outputStream) {};

/** @const */
Windows.Web.Http.HttpProgressStage = {};
/** @const {number} */
Windows.Web.Http.HttpProgressStage.none;
/** @const {number} */
Windows.Web.Http.HttpProgressStage.detectingProxy;
/** @const {number} */
Windows.Web.Http.HttpProgressStage.resolvingName;
/** @const {number} */
Windows.Web.Http.HttpProgressStage.connectingToServer;
/** @const {number} */
Windows.Web.Http.HttpProgressStage.negotiatingSsl;
/** @const {number} */
Windows.Web.Http.HttpProgressStage.sendingHeaders;
/** @const {number} */
Windows.Web.Http.HttpProgressStage.sendingContent;
/** @const {number} */
Windows.Web.Http.HttpProgressStage.waitingForResponse;
/** @const {number} */
Windows.Web.Http.HttpProgressStage.receivingHeaders;
/** @const {number} */
Windows.Web.Http.HttpProgressStage.receivingContent;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpRequestMessage class.
 * Initializes a new instance of the HttpRequestMessage class with an HTTP method and a request Uri .
 * @param {!Windows.Web.Http.HttpMethod=} method The HTTP method to perform
 * @param {!Windows.Foundation.Uri=} uri The Uri to request.
 */
Windows.Web.Http.HttpRequestMessage = function(method, uri) {};
 /** @type {!Windows.Web.Http.IHttpContent} */
Windows.Web.Http.HttpRequestMessage.prototype.content;
 /** @type {!Windows.Web.Http.Headers.HttpRequestHeaderCollection} */
Windows.Web.Http.HttpRequestMessage.prototype.headers;
 /** @type {!Windows.Web.Http.HttpMethod} */
Windows.Web.Http.HttpRequestMessage.prototype.method;
 /** @type {!Windows.Foundation.Collections.IMap<string, ?>} */
Windows.Web.Http.HttpRequestMessage.prototype.properties;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Http.HttpRequestMessage.prototype.requestUri;
 /** @type {!Windows.Web.Http.HttpTransportInformation} */
Windows.Web.Http.HttpRequestMessage.prototype.transportInformation;

/**
 * Closes the HttpRequestMessage instance and releases allocated resources.
 * @return {void}
 */
Windows.Web.Http.HttpRequestMessage.prototype.close = function() {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpResponseMessage class with a specific HttpStatusCode .
 * Initializes a new instance of the HttpResponseMessage class.
 * @param {Windows.Web.Http.HttpStatusCode=} statusCode The status code of the HTTP response.
 */
Windows.Web.Http.HttpResponseMessage = function(statusCode) {};
 /** @type {!Windows.Web.Http.IHttpContent} */
Windows.Web.Http.HttpResponseMessage.prototype.content;
 /** @type {!Windows.Web.Http.Headers.HttpResponseHeaderCollection} */
Windows.Web.Http.HttpResponseMessage.prototype.headers;
 /** @type {boolean} */
Windows.Web.Http.HttpResponseMessage.prototype.isSuccessStatusCode;
 /** @type {string} */
Windows.Web.Http.HttpResponseMessage.prototype.reasonPhrase;
 /** @type {!Windows.Web.Http.HttpRequestMessage} */
Windows.Web.Http.HttpResponseMessage.prototype.requestMessage;
 /** @type {Windows.Web.Http.HttpResponseMessageSource} */
Windows.Web.Http.HttpResponseMessage.prototype.source;
 /** @type {Windows.Web.Http.HttpStatusCode} */
Windows.Web.Http.HttpResponseMessage.prototype.statusCode;
 /** @type {Windows.Web.Http.HttpVersion} */
Windows.Web.Http.HttpResponseMessage.prototype.version;

/**
 * Closes the HttpResponseMessage instance and releases allocated resources.
 * @return {void}
 */
Windows.Web.Http.HttpResponseMessage.prototype.close = function() {};

/**
 * Throws an exception if the IsSuccessStatusCode property for the HTTP response is false.
 * @return {!Windows.Web.Http.HttpResponseMessage} The HTTP response if the request was successful.
 */
Windows.Web.Http.HttpResponseMessage.prototype.ensureSuccessStatusCode = function() {};

/** @const */
Windows.Web.Http.HttpResponseMessageSource = {};
/** @const {number} */
Windows.Web.Http.HttpResponseMessageSource.none;
/** @const {number} */
Windows.Web.Http.HttpResponseMessageSource.cache;
/** @const {number} */
Windows.Web.Http.HttpResponseMessageSource.network;

/** @const */
Windows.Web.Http.HttpStatusCode = {};
/** @const {number} */
Windows.Web.Http.HttpStatusCode.none;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.continue;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.switchingProtocols;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.processing;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.ok;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.created;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.accepted;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.nonAuthoritativeInformation;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.noContent;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.resetContent;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.partialContent;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.multiStatus;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.alreadyReported;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.imUsed;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.multipleChoices;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.movedPermanently;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.found;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.seeOther;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.notModified;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.useProxy;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.temporaryRedirect;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.permanentRedirect;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.badRequest;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.unauthorized;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.paymentRequired;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.forbidden;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.notFound;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.methodNotAllowed;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.notAcceptable;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.proxyAuthenticationRequired;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.requestTimeout;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.conflict;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.gone;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.lengthRequired;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.preconditionFailed;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.requestEntityTooLarge;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.requestUriTooLong;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.unsupportedMediaType;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.requestedRangeNotSatisfiable;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.expectationFailed;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.unprocessableEntity;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.locked;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.failedDependency;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.upgradeRequired;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.preconditionRequired;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.tooManyRequests;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.requestHeaderFieldsTooLarge;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.internalServerError;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.notImplemented;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.badGateway;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.serviceUnavailable;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.gatewayTimeout;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.httpVersionNotSupported;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.variantAlsoNegotiates;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.insufficientStorage;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.loopDetected;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.notExtended;
/** @const {number} */
Windows.Web.Http.HttpStatusCode.networkAuthenticationRequired;

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpStreamContent class with the specified content.
 * @param {!Windows.Storage.Streams.IInputStream} content The content used to initialize the HttpStreamContent .
 */
Windows.Web.Http.HttpStreamContent = function(content) {};
 /** @type {!Windows.Web.Http.Headers.HttpContentHeaderCollection} */
Windows.Web.Http.HttpStreamContent.prototype.headers;

/**
 * Serialize the HttpStreamContent into memory as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpStreamContent.prototype.bufferAllAsync = function() {};

/**
 * Closes the HttpStreamContent instance and releases allocated resources.
 * @return {void}
 */
Windows.Web.Http.HttpStreamContent.prototype.close = function() {};

/**
 * Serialize the HttpStreamContent to a buffer as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpStreamContent.prototype.readAsBufferAsync = function() {};

/**
 * Serialize the HttpStreamContent and return an input stream that represents the content as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IInputStream, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IInputStream, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpStreamContent.prototype.readAsInputStreamAsync = function() {};

/**
 * Serialize the HttpStreamContent to a String as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperationWithProgress<string, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.HttpStreamContent.prototype.readAsStringAsync = function() {};

/**
 * Determines whether the HttpStreamContent has a valid length in bytes.
 * @return {{length: number, returnValue: boolean}}
 */
Windows.Web.Http.HttpStreamContent.prototype.tryComputeLength = function() {};

/**
 * Write the HttpStreamContent to an output stream as an asynchronous operation.
 * @param {!Windows.Storage.Streams.IOutputStream} outputStream The output stream to write to.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpStreamContent.prototype.writeToStreamAsync = function(outputStream) {};

/**
 * @constructor
 * @struct
 * Initializes a new instance of the HttpStringContent class with the specified content and encoding.
 * Initializes a new instance of the HttpStringContent class with the specified content, encoding, and media type.
 * Initializes a new instance of the HttpStringContent class with the specified content.
 * @param {string} content The content used to initialize the HttpStringContent .
 * @param {Windows.Storage.Streams.UnicodeEncoding=} encoding The encoding to use for the content.
 * @param {string=} mediaType The media type to use for the content.
 */
Windows.Web.Http.HttpStringContent = function(content, encoding, mediaType) {};
 /** @type {!Windows.Web.Http.Headers.HttpContentHeaderCollection} */
Windows.Web.Http.HttpStringContent.prototype.headers;

/**
 * Serialize the HttpStringContent into memory as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpStringContent.prototype.bufferAllAsync = function() {};

/**
 * Closes the HttpStringContent instance and releases allocated resources.
 * @return {void}
 */
Windows.Web.Http.HttpStringContent.prototype.close = function() {};

/**
 * Serialize the HttpStringContent to a buffer as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpStringContent.prototype.readAsBufferAsync = function() {};

/**
 * Serialize the HttpStringContent and return an input stream that represents the content as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IInputStream, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IInputStream, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpStringContent.prototype.readAsInputStreamAsync = function() {};

/**
 * Serialize the HttpStringContent to a String as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperationWithProgress<string, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpStringContent.prototype.readAsStringAsync = function() {};

/**
 * Compute the HttpStringContent length in bytes.
 * @return {{length: number, returnValue: boolean}}
 */
Windows.Web.Http.HttpStringContent.prototype.tryComputeLength = function() {};

/**
 * Write the HttpStringContent to an output stream as an asynchronous operation.
 * @param {!Windows.Storage.Streams.IOutputStream} outputStream The output stream to write to.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.HttpStringContent.prototype.writeToStreamAsync = function(outputStream) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Http.HttpTransportInformation = function() {};
 /** @type {!Windows.Security.Cryptography.Certificates.Certificate} */
Windows.Web.Http.HttpTransportInformation.prototype.serverCertificate;
 /** @type {Windows.Networking.Sockets.SocketSslErrorSeverity} */
Windows.Web.Http.HttpTransportInformation.prototype.serverCertificateErrorSeverity;
 /** @type {!Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.ChainValidationResult>} */
Windows.Web.Http.HttpTransportInformation.prototype.serverCertificateErrors;
 /** @type {!Windows.Foundation.Collections.IVectorView<!Windows.Security.Cryptography.Certificates.Certificate>} */
Windows.Web.Http.HttpTransportInformation.prototype.serverIntermediateCertificates;

/** @const */
Windows.Web.Http.HttpVersion = {};
/** @const {number} */
Windows.Web.Http.HttpVersion.none;
/** @const {number} */
Windows.Web.Http.HttpVersion.http10;
/** @const {number} */
Windows.Web.Http.HttpVersion.http11;
/** @const {number} */
Windows.Web.Http.HttpVersion.http20;
/**
 * @record
 * @struct
 */
Windows.Web.Http.HttpProgress = function() {};
 /** @type {number} */
Windows.Web.Http.HttpProgress.prototype.bytesReceived;
 /** @type {number} */
Windows.Web.Http.HttpProgress.prototype.bytesSent;
 /** @type {number} */
Windows.Web.Http.HttpProgress.prototype.retries;
 /** @type {Windows.Web.Http.HttpProgressStage} */
Windows.Web.Http.HttpProgress.prototype.stage;
 /** @type {number} */
Windows.Web.Http.HttpProgress.prototype.totalBytesToReceive;
 /** @type {number} */
Windows.Web.Http.HttpProgress.prototype.totalBytesToSend;
/**
 * @extends {Windows.Foundation.IClosable}
 * @extends {Windows.Foundation.IStringable}
 * @record
 * @struct
 */
Windows.Web.Http.IHttpContent = function() {};
 /** @type {!Windows.Web.Http.Headers.HttpContentHeaderCollection} */
Windows.Web.Http.IHttpContent.prototype.headers;

/**
 * Serialize the HTTP content into memory as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The object that represents the asynchronous operation.
 */
Windows.Web.Http.IHttpContent.prototype.bufferAllAsync = function() {};

/**
 * Serialize the HTTP content to a buffer as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IBuffer, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IBuffer, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.IHttpContent.prototype.readAsBufferAsync = function() {};

/**
 * Serialize the HTTP content and return an input stream that represents the content as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Storage.Streams.IInputStream, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Storage.Streams.IInputStream, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.IHttpContent.prototype.readAsInputStreamAsync = function() {};

/**
 * Serialize the HTTP content to a String as an asynchronous operation.
 * @return {!Windows.Foundation.IPromiseWithOperation<string, !Windows.Foundation.IAsyncOperationWithProgress<string, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.IHttpContent.prototype.readAsStringAsync = function() {};

/**
 * Determines whether the HTTP content has a valid length in bytes.
 * @return {{length: number, returnValue: boolean}}
 */
Windows.Web.Http.IHttpContent.prototype.tryComputeLength = function() {};

/**
 * Write the HTTP content to an output stream as an asynchronous operation.
 * @param {!Windows.Storage.Streams.IOutputStream} outputStream The output stream to write to.
 * @return {!Windows.Foundation.IPromiseWithOperation<number, !Windows.Foundation.IAsyncOperationWithProgress<number, number>>} The object representing the asynchronous operation.
 */
Windows.Web.Http.IHttpContent.prototype.writeToStreamAsync = function(outputStream) {};
/** @const */
Windows.Web.Syndication = {};

/**
 * @constructor
 * @struct
 * Creates a new SyndicationAttribute object.
 * Creates a new SyndicationAttribute object with the specified Name, Namespace, and Value property values.
 * @param {string=} attributeName The name of the attribute.
 * @param {string=} attributeNamespace The namespace of the attribute.
 * @param {string=} attributeValue The value of the attribute.
 */
Windows.Web.Syndication.SyndicationAttribute = function(attributeName, attributeNamespace, attributeValue) {};
 /** @type {string} */
Windows.Web.Syndication.SyndicationAttribute.prototype.name;
 /** @type {string} */
Windows.Web.Syndication.SyndicationAttribute.prototype.namespace;
 /** @type {string} */
Windows.Web.Syndication.SyndicationAttribute.prototype.value;

/**
 * @constructor
 * @struct
 * Creates SyndicationCategory object with the specified property values.
 * Creates a SyndicationCategory object.
 * Creates a SyndicationCategory object with the specified term property.
 * @param {string=} term A string that identifies the category. / A string that identifies the category. This parameter represents the required term attribute on atom:category or the text content of the category element in RSS 2.0.
 * @param {string=} scheme The scheme of the category.
 * @param {string=} label A label for display in end-user applications.
 */
Windows.Web.Syndication.SyndicationCategory = function(term, scheme, label) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationAttribute>} */
Windows.Web.Syndication.SyndicationCategory.prototype.attributeExtensions;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationCategory.prototype.baseUri;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.ISyndicationNode>} */
Windows.Web.Syndication.SyndicationCategory.prototype.elementExtensions;
 /** @type {string} */
Windows.Web.Syndication.SyndicationCategory.prototype.label;
 /** @type {string} */
Windows.Web.Syndication.SyndicationCategory.prototype.language;
 /** @type {string} */
Windows.Web.Syndication.SyndicationCategory.prototype.nodeName;
 /** @type {string} */
Windows.Web.Syndication.SyndicationCategory.prototype.nodeNamespace;
 /** @type {string} */
Windows.Web.Syndication.SyndicationCategory.prototype.nodeValue;
 /** @type {string} */
Windows.Web.Syndication.SyndicationCategory.prototype.scheme;
 /** @type {string} */
Windows.Web.Syndication.SyndicationCategory.prototype.term;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param {Windows.Web.Syndication.SyndicationFormat} format The format of the data.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
Windows.Web.Syndication.SyndicationCategory.prototype.getXmlDocument = function(format) {};

/**
 * @constructor
 * @struct
 * Creates a new SyndicationClient object.
 * Creates a new SyndicationClient object with authentication credentials.
 * @param {!Windows.Security.Credentials.PasswordCredential=} serverCredential Credentials for user authentication.
 */
Windows.Web.Syndication.SyndicationClient = function(serverCredential) {};
 /** @type {boolean} */
Windows.Web.Syndication.SyndicationClient.prototype.bypassCacheOnRetrieve;
 /** @type {number} */
Windows.Web.Syndication.SyndicationClient.prototype.maxResponseBufferSize;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Web.Syndication.SyndicationClient.prototype.proxyCredential;
 /** @type {!Windows.Security.Credentials.PasswordCredential} */
Windows.Web.Syndication.SyndicationClient.prototype.serverCredential;
 /** @type {number} */
Windows.Web.Syndication.SyndicationClient.prototype.timeout;

/**
 * Starts an asynchronous operation to download the syndication feed from the given URI. This method instantiates a SyndicationFeed object from the feed string, which can be in one of the formats specified in SyndicationFormat .
 * @param {!Windows.Foundation.Uri} uri The URI from which the feed is downloaded.
 * @return {!Windows.Foundation.IPromiseWithOperation<!Windows.Web.Syndication.SyndicationFeed, !Windows.Foundation.IAsyncOperationWithProgress<!Windows.Web.Syndication.SyndicationFeed, !Windows.Web.Syndication.RetrievalProgress>>} Contains the results of the operation.
 */
Windows.Web.Syndication.SyndicationClient.prototype.retrieveFeedAsync = function(uri) {};

/**
 * Sets an HTTP header for the request. This method can be called multiple times to set multiple headers. When the same header is set multiple times, the values will be concatenated and separated by ",".
 * @param {string} name The name of the header.
 * @param {string} value The value of the header.
 * @return {void}
 */
Windows.Web.Syndication.SyndicationClient.prototype.setRequestHeader = function(name, value) {};

/**
 * @constructor
 * @struct
 * Creates a new SyndicationContent object with the specified Uri property value.
 * Creates a new SyndicationContent object.
 * Creates a new SyndicationContent object with the specified Text and Type property values.
 * @param {!Windows.Foundation.Uri|string=} sourceUri_or_text The Uri value. / The text of the content.
 * @param {Windows.Web.Syndication.SyndicationTextType=} type The type of the content.
 */
Windows.Web.Syndication.SyndicationContent = function(sourceUri_or_text, type) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationAttribute>} */
Windows.Web.Syndication.SyndicationContent.prototype.attributeExtensions;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationContent.prototype.baseUri;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.ISyndicationNode>} */
Windows.Web.Syndication.SyndicationContent.prototype.elementExtensions;
 /** @type {string} */
Windows.Web.Syndication.SyndicationContent.prototype.language;
 /** @type {string} */
Windows.Web.Syndication.SyndicationContent.prototype.nodeName;
 /** @type {string} */
Windows.Web.Syndication.SyndicationContent.prototype.nodeNamespace;
 /** @type {string} */
Windows.Web.Syndication.SyndicationContent.prototype.nodeValue;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationContent.prototype.sourceUri;
 /** @type {string} */
Windows.Web.Syndication.SyndicationContent.prototype.text;
 /** @type {string} */
Windows.Web.Syndication.SyndicationContent.prototype.type;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Web.Syndication.SyndicationContent.prototype.xml;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param {Windows.Web.Syndication.SyndicationFormat} format The format of the data.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
Windows.Web.Syndication.SyndicationContent.prototype.getXmlDocument = function(format) {};
/**
 * @constructor
 * @struct
 */
Windows.Web.Syndication.SyndicationError = function() {};

/**
 * Gets the specific error using the returned HRESULT value. Possible values are defined by SyndicationErrorStatus .
 * @param {number} hresult An HRESULT returned during the operation.
 * @return {Windows.Web.Syndication.SyndicationErrorStatus} The error encountered.
 */
Windows.Web.Syndication.SyndicationError.getStatus = function(hresult) {};

/** @const */
Windows.Web.Syndication.SyndicationErrorStatus = {};
/** @const {number} */
Windows.Web.Syndication.SyndicationErrorStatus.unknown;
/** @const {number} */
Windows.Web.Syndication.SyndicationErrorStatus.missingRequiredElement;
/** @const {number} */
Windows.Web.Syndication.SyndicationErrorStatus.missingRequiredAttribute;
/** @const {number} */
Windows.Web.Syndication.SyndicationErrorStatus.invalidXml;
/** @const {number} */
Windows.Web.Syndication.SyndicationErrorStatus.unexpectedContent;
/** @const {number} */
Windows.Web.Syndication.SyndicationErrorStatus.unsupportedFormat;

/**
 * @constructor
 * @struct
 * Creates a new SyndicationFeed object.
 * Creates a new SyndicationFeed object with a Title, Subtitle, and Uri.
 * @param {string=} title The Title of the syndication feed.
 * @param {string=} subtitle The Subtitle of the syndication feed.
 * @param {!Windows.Foundation.Uri=} uri The Uri value.
 */
Windows.Web.Syndication.SyndicationFeed = function(title, subtitle, uri) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationAttribute>} */
Windows.Web.Syndication.SyndicationFeed.prototype.attributeExtensions;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationPerson>} */
Windows.Web.Syndication.SyndicationFeed.prototype.authors;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationFeed.prototype.baseUri;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationCategory>} */
Windows.Web.Syndication.SyndicationFeed.prototype.categories;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationPerson>} */
Windows.Web.Syndication.SyndicationFeed.prototype.contributors;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.ISyndicationNode>} */
Windows.Web.Syndication.SyndicationFeed.prototype.elementExtensions;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationFeed.prototype.firstUri;
 /** @type {!Windows.Web.Syndication.SyndicationGenerator} */
Windows.Web.Syndication.SyndicationFeed.prototype.generator;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationFeed.prototype.iconUri;
 /** @type {string} */
Windows.Web.Syndication.SyndicationFeed.prototype.id;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationFeed.prototype.imageUri;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationItem>} */
Windows.Web.Syndication.SyndicationFeed.prototype.items;
 /** @type {string} */
Windows.Web.Syndication.SyndicationFeed.prototype.language;
 /** @type {!Date} */
Windows.Web.Syndication.SyndicationFeed.prototype.lastUpdatedTime;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationFeed.prototype.lastUri;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationLink>} */
Windows.Web.Syndication.SyndicationFeed.prototype.links;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationFeed.prototype.nextUri;
 /** @type {string} */
Windows.Web.Syndication.SyndicationFeed.prototype.nodeName;
 /** @type {string} */
Windows.Web.Syndication.SyndicationFeed.prototype.nodeNamespace;
 /** @type {string} */
Windows.Web.Syndication.SyndicationFeed.prototype.nodeValue;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationFeed.prototype.previousUri;
 /** @type {!Windows.Web.Syndication.ISyndicationText} */
Windows.Web.Syndication.SyndicationFeed.prototype.rights;
 /** @type {Windows.Web.Syndication.SyndicationFormat} */
Windows.Web.Syndication.SyndicationFeed.prototype.sourceFormat;
 /** @type {!Windows.Web.Syndication.ISyndicationText} */
Windows.Web.Syndication.SyndicationFeed.prototype.subtitle;
 /** @type {!Windows.Web.Syndication.ISyndicationText} */
Windows.Web.Syndication.SyndicationFeed.prototype.title;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param {Windows.Web.Syndication.SyndicationFormat} format The format of the data.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
Windows.Web.Syndication.SyndicationFeed.prototype.getXmlDocument = function(format) {};

/**
 * Initializes the object from the given feed string, which can be in either RSS 2.0 or Atom 1.0 format.
 * @param {string} feed The feed string, which can be in either RSS 2.0 or Atom 1.0 format.
 * @return {void}
 */
Windows.Web.Syndication.SyndicationFeed.prototype.load = function(feed) {};

/**
 * Initializes the SyndicationFeed object from the given DOM object, which can contain XML content in either RSS 2.0 or Atom 1.0 format.
 * @param {!Windows.Data.Xml.Dom.XmlDocument} feedDocument The DOM object which contains XML content in either RSS 2.0 or Atom 1.0 format.
 * @return {void}
 */
Windows.Web.Syndication.SyndicationFeed.prototype.loadFromXml = function(feedDocument) {};

/** @const */
Windows.Web.Syndication.SyndicationFormat = {};
/** @const {number} */
Windows.Web.Syndication.SyndicationFormat.atom10;
/** @const {number} */
Windows.Web.Syndication.SyndicationFormat.rss20;
/** @const {number} */
Windows.Web.Syndication.SyndicationFormat.rss10;
/** @const {number} */
Windows.Web.Syndication.SyndicationFormat.rss092;
/** @const {number} */
Windows.Web.Syndication.SyndicationFormat.rss091;
/** @const {number} */
Windows.Web.Syndication.SyndicationFormat.atom03;

/**
 * @constructor
 * @struct
 * Creates a new SyndicationGenerator object.
 * Creates a new SyndicationGenerator object with the specified Text property value.
 * @param {string=} text Identifies the generator. This parameter represents the text content in the atom:generator element or the generator element in RSS 2.0.
 */
Windows.Web.Syndication.SyndicationGenerator = function(text) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationAttribute>} */
Windows.Web.Syndication.SyndicationGenerator.prototype.attributeExtensions;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationGenerator.prototype.baseUri;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.ISyndicationNode>} */
Windows.Web.Syndication.SyndicationGenerator.prototype.elementExtensions;
 /** @type {string} */
Windows.Web.Syndication.SyndicationGenerator.prototype.language;
 /** @type {string} */
Windows.Web.Syndication.SyndicationGenerator.prototype.nodeName;
 /** @type {string} */
Windows.Web.Syndication.SyndicationGenerator.prototype.nodeNamespace;
 /** @type {string} */
Windows.Web.Syndication.SyndicationGenerator.prototype.nodeValue;
 /** @type {string} */
Windows.Web.Syndication.SyndicationGenerator.prototype.text;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationGenerator.prototype.uri;
 /** @type {string} */
Windows.Web.Syndication.SyndicationGenerator.prototype.version;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param {Windows.Web.Syndication.SyndicationFormat} format The format of the data.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
Windows.Web.Syndication.SyndicationGenerator.prototype.getXmlDocument = function(format) {};

/**
 * @constructor
 * @struct
 * Creates a new SyndicationItem object with a title, content, and URI.
 * Creates a new SyndicationItem object.
 * @param {string=} title Title of the new item.
 * @param {!Windows.Web.Syndication.SyndicationContent=} content The content for this feed item.
 * @param {!Windows.Foundation.Uri=} uri The URI associated with this item.
 */
Windows.Web.Syndication.SyndicationItem = function(title, content, uri) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationAttribute>} */
Windows.Web.Syndication.SyndicationItem.prototype.attributeExtensions;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationPerson>} */
Windows.Web.Syndication.SyndicationItem.prototype.authors;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationItem.prototype.baseUri;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationCategory>} */
Windows.Web.Syndication.SyndicationItem.prototype.categories;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationItem.prototype.commentsUri;
 /** @type {!Windows.Web.Syndication.SyndicationContent} */
Windows.Web.Syndication.SyndicationItem.prototype.content;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationPerson>} */
Windows.Web.Syndication.SyndicationItem.prototype.contributors;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationItem.prototype.editMediaUri;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationItem.prototype.editUri;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.ISyndicationNode>} */
Windows.Web.Syndication.SyndicationItem.prototype.elementExtensions;
 /** @type {string} */
Windows.Web.Syndication.SyndicationItem.prototype.etag;
 /** @type {string} */
Windows.Web.Syndication.SyndicationItem.prototype.id;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationItem.prototype.itemUri;
 /** @type {string} */
Windows.Web.Syndication.SyndicationItem.prototype.language;
 /** @type {!Date} */
Windows.Web.Syndication.SyndicationItem.prototype.lastUpdatedTime;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationLink>} */
Windows.Web.Syndication.SyndicationItem.prototype.links;
 /** @type {string} */
Windows.Web.Syndication.SyndicationItem.prototype.nodeName;
 /** @type {string} */
Windows.Web.Syndication.SyndicationItem.prototype.nodeNamespace;
 /** @type {string} */
Windows.Web.Syndication.SyndicationItem.prototype.nodeValue;
 /** @type {!Date} */
Windows.Web.Syndication.SyndicationItem.prototype.publishedDate;
 /** @type {!Windows.Web.Syndication.ISyndicationText} */
Windows.Web.Syndication.SyndicationItem.prototype.rights;
 /** @type {!Windows.Web.Syndication.SyndicationFeed} */
Windows.Web.Syndication.SyndicationItem.prototype.source;
 /** @type {!Windows.Web.Syndication.ISyndicationText} */
Windows.Web.Syndication.SyndicationItem.prototype.summary;
 /** @type {!Windows.Web.Syndication.ISyndicationText} */
Windows.Web.Syndication.SyndicationItem.prototype.title;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param {Windows.Web.Syndication.SyndicationFormat} format The format of the data.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
Windows.Web.Syndication.SyndicationItem.prototype.getXmlDocument = function(format) {};

/**
 * Initializes the object from the given feed string, which can be in either RSS 2.0 or Atom 1.0 format.
 * @param {string} item The feed string, which can be in either RSS 2.0 or Atom 1.0 format.
 * @return {void}
 */
Windows.Web.Syndication.SyndicationItem.prototype.load = function(item) {};

/**
 * Initializes the object from the given DOM object, which can contain XML content in either RSS 2.0 or Atom 1.0 format.
 * @param {!Windows.Data.Xml.Dom.XmlDocument} itemDocument The DOM object, which can contain XML content in either RSS 2.0 or Atom 1.0 format.
 * @return {void}
 */
Windows.Web.Syndication.SyndicationItem.prototype.loadFromXml = function(itemDocument) {};

/**
 * @constructor
 * @struct
 * Creates a new SyndicationLink object.
 * Creates a new SyndicationLink object with a Uri, Relationship, Title, MediaType, and Length.
 * Creates a new SyndicationLink with a Uri.
 * @param {!Windows.Foundation.Uri=} uri The Uri value.
 * @param {string=} relationship The relationship type.
 * @param {string=} title The title of the syndication link.
 * @param {string=} mediaType The MediaType of the syndication link.
 * @param {number=} length The length, in bytes, of the syndication link.
 */
Windows.Web.Syndication.SyndicationLink = function(uri, relationship, title, mediaType, length) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationAttribute>} */
Windows.Web.Syndication.SyndicationLink.prototype.attributeExtensions;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationLink.prototype.baseUri;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.ISyndicationNode>} */
Windows.Web.Syndication.SyndicationLink.prototype.elementExtensions;
 /** @type {string} */
Windows.Web.Syndication.SyndicationLink.prototype.language;
 /** @type {number} */
Windows.Web.Syndication.SyndicationLink.prototype.length;
 /** @type {string} */
Windows.Web.Syndication.SyndicationLink.prototype.mediaType;
 /** @type {string} */
Windows.Web.Syndication.SyndicationLink.prototype.nodeName;
 /** @type {string} */
Windows.Web.Syndication.SyndicationLink.prototype.nodeNamespace;
 /** @type {string} */
Windows.Web.Syndication.SyndicationLink.prototype.nodeValue;
 /** @type {string} */
Windows.Web.Syndication.SyndicationLink.prototype.relationship;
 /** @type {string} */
Windows.Web.Syndication.SyndicationLink.prototype.resourceLanguage;
 /** @type {string} */
Windows.Web.Syndication.SyndicationLink.prototype.title;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationLink.prototype.uri;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param {Windows.Web.Syndication.SyndicationFormat} format The format of the data.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
Windows.Web.Syndication.SyndicationLink.prototype.getXmlDocument = function(format) {};

/**
 * @constructor
 * @struct
 * Creates a new SyndicationNode object with the specified NodeName, NodeNamespace, and NodeValue property values.
 * Creates a new SyndicationNode object.
 * @param {string=} nodeName The local name of the element. It must be valid according to XML 1.0.
 * @param {string=} nodeNamespace The namespace of the element.
 * @param {string=} nodeValue The text content of the element. If the element contains only child elements, this parameter is NULL.
 */
Windows.Web.Syndication.SyndicationNode = function(nodeName, nodeNamespace, nodeValue) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationAttribute>} */
Windows.Web.Syndication.SyndicationNode.prototype.attributeExtensions;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationNode.prototype.baseUri;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.ISyndicationNode>} */
Windows.Web.Syndication.SyndicationNode.prototype.elementExtensions;
 /** @type {string} */
Windows.Web.Syndication.SyndicationNode.prototype.language;
 /** @type {string} */
Windows.Web.Syndication.SyndicationNode.prototype.nodeName;
 /** @type {string} */
Windows.Web.Syndication.SyndicationNode.prototype.nodeNamespace;
 /** @type {string} */
Windows.Web.Syndication.SyndicationNode.prototype.nodeValue;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param {Windows.Web.Syndication.SyndicationFormat} format The format of the data.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
Windows.Web.Syndication.SyndicationNode.prototype.getXmlDocument = function(format) {};

/**
 * @constructor
 * @struct
 * Creates a SyndicationPerson object with the specified Name, Email, and Uri property values.
 * Creates a SyndicationPerson object.
 * Creates a SyndicationPerson object with the specified Name property value.
 * @param {string=} name The name of the SyndicationPerson . This parameter represents the atom:name element.
 * @param {string=} email Gets or sets the email address of the person. This property represents the atom:email element.
 * @param {!Windows.Foundation.Uri=} uri Gets or sets the URI of the person. This property represents the atom:uri element. It is the absolute URI resolved against the xml:base attribute, if it is present. If the href attribute is a relative URI string and there is no xml:base attribute, this property is NULL because relative URI is not supported by the runtime URI class.
 */
Windows.Web.Syndication.SyndicationPerson = function(name, email, uri) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationAttribute>} */
Windows.Web.Syndication.SyndicationPerson.prototype.attributeExtensions;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationPerson.prototype.baseUri;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.ISyndicationNode>} */
Windows.Web.Syndication.SyndicationPerson.prototype.elementExtensions;
 /** @type {string} */
Windows.Web.Syndication.SyndicationPerson.prototype.email;
 /** @type {string} */
Windows.Web.Syndication.SyndicationPerson.prototype.language;
 /** @type {string} */
Windows.Web.Syndication.SyndicationPerson.prototype.name;
 /** @type {string} */
Windows.Web.Syndication.SyndicationPerson.prototype.nodeName;
 /** @type {string} */
Windows.Web.Syndication.SyndicationPerson.prototype.nodeNamespace;
 /** @type {string} */
Windows.Web.Syndication.SyndicationPerson.prototype.nodeValue;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationPerson.prototype.uri;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param {Windows.Web.Syndication.SyndicationFormat} format The format of the data.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
Windows.Web.Syndication.SyndicationPerson.prototype.getXmlDocument = function(format) {};

/**
 * @constructor
 * @struct
 * Creates a new SyndicationText object with the specified Text and Type property values.
 * Creates a new SyndicationText object.
 * Creates a new SyndicationText object with the specified Text property value.
 * @param {string=} text The content of a text content construct like atom:title.
 * @param {Windows.Web.Syndication.SyndicationTextType=} type The type of the content. This value can be "text", "html", and "xhtml".
 */
Windows.Web.Syndication.SyndicationText = function(text, type) {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationAttribute>} */
Windows.Web.Syndication.SyndicationText.prototype.attributeExtensions;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.SyndicationText.prototype.baseUri;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.ISyndicationNode>} */
Windows.Web.Syndication.SyndicationText.prototype.elementExtensions;
 /** @type {string} */
Windows.Web.Syndication.SyndicationText.prototype.language;
 /** @type {string} */
Windows.Web.Syndication.SyndicationText.prototype.nodeName;
 /** @type {string} */
Windows.Web.Syndication.SyndicationText.prototype.nodeNamespace;
 /** @type {string} */
Windows.Web.Syndication.SyndicationText.prototype.nodeValue;
 /** @type {string} */
Windows.Web.Syndication.SyndicationText.prototype.text;
 /** @type {string} */
Windows.Web.Syndication.SyndicationText.prototype.type;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Web.Syndication.SyndicationText.prototype.xml;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param {Windows.Web.Syndication.SyndicationFormat} format The format of the data.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
Windows.Web.Syndication.SyndicationText.prototype.getXmlDocument = function(format) {};

/** @const */
Windows.Web.Syndication.SyndicationTextType = {};
/** @const {number} */
Windows.Web.Syndication.SyndicationTextType.text;
/** @const {number} */
Windows.Web.Syndication.SyndicationTextType.html;
/** @const {number} */
Windows.Web.Syndication.SyndicationTextType.xhtml;
/**
 * @record
 * @struct
 */
Windows.Web.Syndication.TransferProgress = function() {};
 /** @type {number} */
Windows.Web.Syndication.TransferProgress.prototype.bytesRetrieved;
 /** @type {number} */
Windows.Web.Syndication.TransferProgress.prototype.bytesSent;
 /** @type {number} */
Windows.Web.Syndication.TransferProgress.prototype.totalBytesToRetrieve;
 /** @type {number} */
Windows.Web.Syndication.TransferProgress.prototype.totalBytesToSend;
/**
 * @record
 * @struct
 */
Windows.Web.Syndication.RetrievalProgress = function() {};
 /** @type {number} */
Windows.Web.Syndication.RetrievalProgress.prototype.bytesRetrieved;
 /** @type {number} */
Windows.Web.Syndication.RetrievalProgress.prototype.totalBytesToRetrieve;
/**
 * @record
 * @struct
 */
Windows.Web.Syndication.ISyndicationNode = function() {};
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.SyndicationAttribute>} */
Windows.Web.Syndication.ISyndicationNode.prototype.attributeExtensions;
 /** @type {!Windows.Foundation.Uri} */
Windows.Web.Syndication.ISyndicationNode.prototype.baseUri;
 /** @type {!Windows.Foundation.Collections.IVector<!Windows.Web.Syndication.ISyndicationNode>} */
Windows.Web.Syndication.ISyndicationNode.prototype.elementExtensions;
 /** @type {string} */
Windows.Web.Syndication.ISyndicationNode.prototype.language;
 /** @type {string} */
Windows.Web.Syndication.ISyndicationNode.prototype.nodeName;
 /** @type {string} */
Windows.Web.Syndication.ISyndicationNode.prototype.nodeNamespace;
 /** @type {string} */
Windows.Web.Syndication.ISyndicationNode.prototype.nodeValue;

/**
 * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
 * @param {Windows.Web.Syndication.SyndicationFormat} format The format of the data.
 * @return {!Windows.Data.Xml.Dom.XmlDocument} The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
 */
Windows.Web.Syndication.ISyndicationNode.prototype.getXmlDocument = function(format) {};
/**
 * @extends {Windows.Web.Syndication.ISyndicationNode}
 * @record
 * @struct
 */
Windows.Web.Syndication.ISyndicationText = function() {};
 /** @type {string} */
Windows.Web.Syndication.ISyndicationText.prototype.text;
 /** @type {string} */
Windows.Web.Syndication.ISyndicationText.prototype.type;
 /** @type {!Windows.Data.Xml.Dom.XmlDocument} */
Windows.Web.Syndication.ISyndicationText.prototype.xml;
/**
 * @constructor
 * @struct
 */
Windows.Web.WebError = function() {};

/**
 * Gets a WebErrorStatus value based on an error encountered by a web service operation.
 * @param {number} hresult The error encountered by a web service operation represented as an hResult.
 * @return {Windows.Web.WebErrorStatus} The error status value for a web service operation.
 */
Windows.Web.WebError.getStatus = function(hresult) {};

/** @const */
Windows.Web.WebErrorStatus = {};
/** @const {number} */
Windows.Web.WebErrorStatus.unknown;
/** @const {number} */
Windows.Web.WebErrorStatus.certificateCommonNameIsIncorrect;
/** @const {number} */
Windows.Web.WebErrorStatus.certificateExpired;
/** @const {number} */
Windows.Web.WebErrorStatus.certificateContainsErrors;
/** @const {number} */
Windows.Web.WebErrorStatus.certificateRevoked;
/** @const {number} */
Windows.Web.WebErrorStatus.certificateIsInvalid;
/** @const {number} */
Windows.Web.WebErrorStatus.serverUnreachable;
/** @const {number} */
Windows.Web.WebErrorStatus.timeout;
/** @const {number} */
Windows.Web.WebErrorStatus.errorHttpInvalidServerResponse;
/** @const {number} */
Windows.Web.WebErrorStatus.connectionAborted;
/** @const {number} */
Windows.Web.WebErrorStatus.connectionReset;
/** @const {number} */
Windows.Web.WebErrorStatus.disconnected;
/** @const {number} */
Windows.Web.WebErrorStatus.httpToHttpsOnRedirection;
/** @const {number} */
Windows.Web.WebErrorStatus.httpsToHttpOnRedirection;
/** @const {number} */
Windows.Web.WebErrorStatus.cannotConnect;
/** @const {number} */
Windows.Web.WebErrorStatus.hostNameNotResolved;
/** @const {number} */
Windows.Web.WebErrorStatus.operationCanceled;
/** @const {number} */
Windows.Web.WebErrorStatus.redirectFailed;
/** @const {number} */
Windows.Web.WebErrorStatus.unexpectedStatusCode;
/** @const {number} */
Windows.Web.WebErrorStatus.unexpectedRedirection;
/** @const {number} */
Windows.Web.WebErrorStatus.unexpectedClientError;
/** @const {number} */
Windows.Web.WebErrorStatus.unexpectedServerError;
/** @const {number} */
Windows.Web.WebErrorStatus.multipleChoices;
/** @const {number} */
Windows.Web.WebErrorStatus.movedPermanently;
/** @const {number} */
Windows.Web.WebErrorStatus.found;
/** @const {number} */
Windows.Web.WebErrorStatus.seeOther;
/** @const {number} */
Windows.Web.WebErrorStatus.notModified;
/** @const {number} */
Windows.Web.WebErrorStatus.useProxy;
/** @const {number} */
Windows.Web.WebErrorStatus.temporaryRedirect;
/** @const {number} */
Windows.Web.WebErrorStatus.badRequest;
/** @const {number} */
Windows.Web.WebErrorStatus.unauthorized;
/** @const {number} */
Windows.Web.WebErrorStatus.paymentRequired;
/** @const {number} */
Windows.Web.WebErrorStatus.forbidden;
/** @const {number} */
Windows.Web.WebErrorStatus.notFound;
/** @const {number} */
Windows.Web.WebErrorStatus.methodNotAllowed;
/** @const {number} */
Windows.Web.WebErrorStatus.notAcceptable;
/** @const {number} */
Windows.Web.WebErrorStatus.proxyAuthenticationRequired;
/** @const {number} */
Windows.Web.WebErrorStatus.requestTimeout;
/** @const {number} */
Windows.Web.WebErrorStatus.conflict;
/** @const {number} */
Windows.Web.WebErrorStatus.gone;
/** @const {number} */
Windows.Web.WebErrorStatus.lengthRequired;
/** @const {number} */
Windows.Web.WebErrorStatus.preconditionFailed;
/** @const {number} */
Windows.Web.WebErrorStatus.requestEntityTooLarge;
/** @const {number} */
Windows.Web.WebErrorStatus.requestUriTooLong;
/** @const {number} */
Windows.Web.WebErrorStatus.unsupportedMediaType;
/** @const {number} */
Windows.Web.WebErrorStatus.requestedRangeNotSatisfiable;
/** @const {number} */
Windows.Web.WebErrorStatus.expectationFailed;
/** @const {number} */
Windows.Web.WebErrorStatus.internalServerError;
/** @const {number} */
Windows.Web.WebErrorStatus.notImplemented;
/** @const {number} */
Windows.Web.WebErrorStatus.badGateway;
/** @const {number} */
Windows.Web.WebErrorStatus.serviceUnavailable;
/** @const {number} */
Windows.Web.WebErrorStatus.gatewayTimeout;
/** @const {number} */
Windows.Web.WebErrorStatus.httpVersionNotSupported;
