/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/rbush/index.d.ts:
/** @const */
var rbush = {};
/**
 * @record
 * @struct
 */
rbush.BBox = function() {};
 /** @type {number} */
rbush.BBox.prototype.minX;
 /** @type {number} */
rbush.BBox.prototype.minY;
 /** @type {number} */
rbush.BBox.prototype.maxX;
 /** @type {number} */
rbush.BBox.prototype.maxY;
/**
 * @record
 * @struct
 */
rbush.RBush = function() {};

/**
 * Insert an item. To insert many items, use load().
 * @param {T} item
 * @return {!rbush.RBush}
 */
rbush.RBush.prototype.insert = function(item) {};

/**
 * Bulk-insert the given data into the tree.
 * 
 * Bulk insertion is usually ~2-3 times faster than inserting items one by one.
 * After bulk loading (bulk insertion into an empty tree), subsequent query
 * performance is also ~20-30% better.
 * 
 * Note that when you do bulk insertion into an existing tree, it bulk-loads
 * the given data into a separate tree and inserts the smaller tree into the
 * larger tree. This means that bulk insertion works very well for clustered
 * data (where items in one update are close to each other), but makes query
 * performance worse if the data is scattered.
 * @param {!Array<T>} items
 * @return {!rbush.RBush}
 */
rbush.RBush.prototype.load = function(items) {};

/**
 * Remove a previously inserted item.
 * 
 * By default, RBush removes objects by reference. However, you can pass a
 * custom equals function to compare by value for removal, which is useful
 * when you only have a copy of the object you need removed (e.g. loaded
 * from server).
 * @param {T} item
 * @param {function(T, T): boolean=} equals
 * @return {!rbush.RBush}
 */
rbush.RBush.prototype.remove = function(item, equals) {};

/**
 * Remove all items
 * @return {!rbush.RBush}
 */
rbush.RBush.prototype.clear = function() {};

/**
 * Returns an array of data items (points or rectangles) that the given
 * bounding box intersects.
 * 
 * Note that the search method accepts a bounding box in {minX, minY, maxX, maxY}
 * format regardless of the format specified in the constructor (which only
 * affects inserted objects).
 * @param {!rbush.BBox} bbox
 * @return {!Array<T>}
 */
rbush.RBush.prototype.search = function(bbox) {};

/**
 * Returns all items of the tree.
 * @return {!Array<T>}
 */
rbush.RBush.prototype.all = function() {};

/**
 * Returns true if there are any items intersecting the given bounding box,
 * otherwise false.
 * @param {!rbush.BBox} bbox
 * @return {boolean}
 */
rbush.RBush.prototype.collides = function(bbox) {};

/**
 * Export data as JSON object.
 * 
 * Importing and exporting as JSON allows you to use RBush on both the server
 * (using Node.js) and the browser combined, e.g. first indexing the data on
 * the server and and then importing the resulting tree data on the client
 * for searching.
 * 
 * Note that the nodeSize option passed to the constructor must be the same
 * in both trees for export/import to work properly.
 * @return {?}
 */
rbush.RBush.prototype.toJSON = function() {};

/**
 * Import previously exported data.
 * 
 * Importing and exporting as JSON allows you to use RBush on both the server
 * (using Node.js) and the browser combined, e.g. first indexing the data on
 * the server and and then importing the resulting tree data on the client
 * for searching.
 * 
 * Note that the nodeSize option passed to the constructor must be the same
 * in both trees for export/import to work properly.
 * @param {?} data
 * @return {!rbush.RBush}
 */
rbush.RBush.prototype.fromJSON = function(data) {};
/**
 * @record
 * @struct
 */
rbush.IRBush = function() {};

/* TODO: CallSignature: rbush */

/* TODO: CallSignature: rbush */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "rbush"
/** @const */
tsickle_declare_module.rbush = {};
 /** @type {!rbush.IRBush} */
tsickle_declare_module.rbush.temp;

/* TODO: ExportAssignment in tsickle_declare_module.rbush */
