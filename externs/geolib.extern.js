/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/geolib/index.d.ts:
/** @const */
var geolib = {};
/**
 * @record
 * @struct
 */
geolib.PositionAsDecimal = function() {};
 /** @type {number} */
geolib.PositionAsDecimal.prototype.latitude;
 /** @type {number} */
geolib.PositionAsDecimal.prototype.longitude;
/**
 * @record
 * @struct
 */
geolib.PositionAsSexadecimal = function() {};
 /** @type {string} */
geolib.PositionAsSexadecimal.prototype.latitude;
 /** @type {string} */
geolib.PositionAsSexadecimal.prototype.longitude;
/**
 * @extends {geolib.PositionAsDecimal}
 * @record
 * @struct
 */
geolib.PositionWithElevation = function() {};
 /** @type {number} */
geolib.PositionWithElevation.prototype.elevation;
/**
 * @extends {geolib.PositionAsDecimal}
 * @record
 * @struct
 */
geolib.PositionInTime = function() {};
 /** @type {number} */
geolib.PositionInTime.prototype.time;
/**
 * @record
 * @struct
 */
geolib.Bound = function() {};
 /** @type {number} */
geolib.Bound.prototype.minLat;
 /** @type {number} */
geolib.Bound.prototype.maxLat;
 /** @type {number} */
geolib.Bound.prototype.minLng;
 /** @type {number} */
geolib.Bound.prototype.maxLng;
 /** @type {number} */
geolib.Bound.prototype.minElev;
 /** @type {number} */
geolib.Bound.prototype.maxElev;
/**
 * @record
 * @struct
 */
geolib.CompassDirection = function() {};
 /** @type {string} */
geolib.CompassDirection.prototype.rough;
 /** @type {string} */
geolib.CompassDirection.prototype.exact;
/**
 * @record
 * @struct
 */
geolib.Distance = function() {};
 /** @type {number} */
geolib.Distance.prototype.latitude;
 /** @type {number} */
geolib.Distance.prototype.longitude;
 /** @type {number} */
geolib.Distance.prototype.distance;
 /** @type {string} */
geolib.Distance.prototype.key;
/**
 * @record
 * @struct
 */
geolib.SpeedOption = function() {};
 /** @type {string} */
geolib.SpeedOption.prototype.unit;

/**
 * Calculates the distance between two geo coordinates
 * 
 * Return value is always float and represents the distance in meters.
 * @param {(!geolib.PositionAsDecimal|!geolib.PositionAsSexadecimal)} start
 * @param {(!geolib.PositionAsDecimal|!geolib.PositionAsSexadecimal)} end
 * @param {number=} accuracy
 * @param {number=} precision
 * @return {number}
 */
geolib.getDistance = function(start, end, accuracy, precision) {};

/**
 * Calculates the distance between two geo coordinates but this method is far more inaccurate as compared to getDistance.
 * It can take up 2 to 3 arguments. start, end and accuracy can be defined in the same as in getDistance.
 * 
 * Return value is always float that represents the distance in meters.
 * @param {(!geolib.PositionAsDecimal|!geolib.PositionAsSexadecimal)} start
 * @param {(!geolib.PositionAsDecimal|!geolib.PositionAsSexadecimal)} end
 * @param {number=} accuracy
 * @return {number}
 */
geolib.getDistanceSimple = function(start, end, accuracy) {};

/**
 * Calculates the geographical center of all points in a collection of geo coordinates
 * Takes an object or array of coordinates and calculates the center of it.
 * @param {!Array<!geolib.PositionAsDecimal>} coords
 * @return {!geolib.PositionAsDecimal}
 */
geolib.getCenter = function(coords) {};

/**
 * Calculates the center of the bounds of geo coordinates. Takes an array of coordinates,
 * calculate the border of those, and gives back the center of that rectangle. On polygons
 * like political borders (eg. states), this may gives a closer result to human expectation,
 * than getCenter, because that function can be disturbed by uneven distribution of point in
 * different sides. Imagine the US state Oklahoma: getCenter on that gives a southern point,
 * because the southern border contains a lot more nodes, than the others.
 * @param {!Array<!geolib.PositionAsDecimal>} coords
 * @return {!geolib.PositionAsDecimal}
 */
geolib.getCenterOfBounds = function(coords) {};

/**
 * Calculates the bounds of geo coordinates.
 * 
 * Returns maximum and minimum, latitude, longitude, and elevation (if provided) in form of an object
 * @param {!Array<!geolib.PositionWithElevation>} coords
 * @return {!geolib.Bound}
 */
geolib.getBounds = function(coords) {};

/**
 * Checks whether a point is inside of a polygon or not. Note: the polygon coords must be in correct order!
 * 
 * Returns true or false
 * @param {!geolib.PositionAsDecimal} latlng
 * @param {!Array<!geolib.PositionAsDecimal>} polygon
 * @return {boolean}
 */
geolib.isPointInside = function(latlng, polygon) {};

/**
 * Similar to is point inside: checks whether a point is inside of a circle or not.
 * 
 * Returns true or false
 * @param {!geolib.PositionAsDecimal} latlng
 * @param {!geolib.PositionAsDecimal} center
 * @param {number} radius
 * @return {boolean}
 */
geolib.isPointInCircle = function(latlng, center, radius) {};

/**
 * Gets rhumb line bearing of two points. Find out about the difference between rhumb line and great circle bearing on Wikipedia.
 * Rhumb line should be fine in most cases: http://en.wikipedia.org/wiki/Rhumb_line#General_and_mathematical_description Function
 * is heavily based on Doug Vanderweide's great PHP version (licensed under GPL 3.0)
 * http://www.dougv.com/2009/07/13/calculating-the-bearing-and-compass-rose-direction-between-two-latitude-longitude-coordinates-in-php/
 * 
 * Returns calculated bearing as integer.
 * @param {!geolib.PositionAsDecimal} originLL
 * @param {!geolib.PositionAsDecimal} destLL
 * @return {number}
 */
geolib.getRhumbLineBearing = function(originLL, destLL) {};

/**
 * Gets great circle bearing of two points. See description of getRhumbLineBearing for more information.
 * 
 * Returns calculated bearing as integer
 * @param {!geolib.PositionAsDecimal} originLL
 * @param {!geolib.PositionAsDecimal} destLL
 * @return {number}
 */
geolib.getBearing = function(originLL, destLL) {};

/**
 * Gets the compass direction from an origin coordinate (originLL) to a destination coordinate (destLL).
 * Bearing mode. Can be either circle or rhumbline (default).
 * 
 * Returns an object with a rough (NESW) and an exact direction (NNE, NE, ENE, E, ESE, etc).
 * @param {!geolib.PositionAsDecimal} originLL
 * @param {!geolib.PositionAsDecimal} destLL
 * @param {string=} bearingMode
 * @return {!geolib.CompassDirection}
 */
geolib.getCompassDirection = function(originLL, destLL, bearingMode) {};

/**
 * Sorts an object or array of coords by distance from a reference coordinate
 * @param {!geolib.PositionAsDecimal} latlng
 * @param {!Array<!geolib.PositionAsDecimal>} coords
 * @return {!Array<!geolib.Distance>}
 */
geolib.orderByDistance = function(latlng, coords) {};

/**
 * Finds the nearest coordinate to a reference coordinate.
 * @param {!geolib.PositionAsDecimal} latlng
 * @param {!Array<!geolib.PositionAsDecimal>} coords
 * @param {number=} offset
 * @param {number=} limit
 * @return {!Array<!geolib.Distance>}
 */
geolib.findNearest = function(latlng, coords, offset, limit) {};

/**
 * Calculates the length of a collection of coordinates.
 * 
 * Returns the length of the path in meters
 * @param {!Array<!geolib.PositionAsDecimal>} coords
 * @return {number}
 */
geolib.getPathLength = function(coords) {};

/**
 * Calculates the speed between two points within a given time span.
 * 
 * Returns the speed in options.unit (default is km/h).
 * @param {!Array<!geolib.PositionInTime>} coords
 * @param {!geolib.SpeedOption=} option
 * @return {number}
 */
geolib.getSpeed = function(coords, option) {};

/**
 * Calculates if given point lies in a line formed by start and end
 * @param {!geolib.PositionAsDecimal} point
 * @param {!geolib.PositionAsDecimal} start
 * @param {!geolib.PositionAsDecimal} end
 * @return {boolean}
 */
geolib.isPointInLine = function(point, start, end) {};

/**
 * Converts a given distance (in meters) to another unit.
 * distance distance to be converted (source must be in meter). unit can be one of:
 * - m (meter)
 * - km (kilometers)
 * - cm (centimeters)
 * - mm (millimeters)
 * - mi (miles)
 * - sm (seamiles)
 * - ft (foot)
 * - in (inch)
 * - yd (yards)
 * @param {string} unit
 * @param {number} distance
 * @param {number=} round
 * @return {number}
 */
geolib.convertUnit = function(unit, distance, round) {};

/**
 * Converts a sexagesimal coordinate to decimal format
 * @param {string} coord
 * @return {number}
 */
geolib.sexagesimal2decimal = function(coord) {};

/**
 * Converts a decimal coordinate to sexagesimal format
 * @param {number} coord
 * @return {string}
 */
geolib.decimal2sexagesimal = function(coord) {};

/**
 * Returns the latitude for a given point and converts it to decimal.
 * Works with: latitude, lat, 1 (GeoJSON array)
 * @param {?} latlng
 * @return {number}
 */
geolib.latitude = function(latlng) {};

/**
 * Returns the longitude for a given point and converts it to decimal.
 * Works with: longitude, lng, lon, 0 (GeoJSON array)
 * @param {?} latlng
 * @return {number}
 */
geolib.longitude = function(latlng) {};

/**
 * Returns the elevation for a given point and converts it to decimal.
 * Works with: elevation, elev, alt, altitude, 2 (GeoJSON array)
 * @param {?} latlng
 * @return {number}
 */
geolib.elevation = function(latlng) {};

/**
 * Checks if a coordinate is already in decimal format and, if not, converts it to
 * @param {(string|number)} latlng
 * @return {number}
 */
geolib.useDecimal = function(latlng) {};

/**
 * Computes the destination point given an initial point, a distance (in meters) and a bearing (in degrees).
 * If no radius is given it defaults to the mean earth radius of 6371000 meter.
 * 
 * Returns an object: `{"latitude": destLat, "longitude": destLng}`
 * (Attention: this formula is not *100%* accurate (but very close though))
 * @param {!geolib.PositionAsDecimal} start
 * @param {number} distance
 * @param {number} bearing
 * @param {number=} radius
 * @return {!geolib.PositionAsDecimal}
 */
geolib.computeDestinationPoint = function(start, distance, bearing, radius) {};
