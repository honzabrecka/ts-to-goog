/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/lunr/index.d.ts:
/** @const */
var lunr = {};
 /** @type {string} */
lunr.version;

/**
 * A function for splitting a string into tokens ready to be inserted into
 * the search index. Uses `lunr.tokenizer.seperator` to split strings, change
 * the value of this property to change how strings are split into tokens.
 * 
 * \@module
 * @see lunr.tokenizer.seperator
 * @param {?} obj
 * @return {!Array<string>}
 */
lunr.tokenizer = function(obj) {};
/**
 * @record
 * @struct
 */
lunr.TokenizerFunction = function() {};

/* TODO: CallSignature: lunr */
 /** @type {(string|!RegExp)} */
lunr.tokenizer.seperator;
 /** @type {string} */
lunr.tokenizer.label;
 /** @type {!Object<string,!lunr.TokenizerFunction>} */
lunr.tokenizer.registeredFunctions;

/**
 * Register a tokenizer function.
 * 
 * Functions that are used as tokenizers should be registered if they are to be used with a serialised index.
 * 
 * Registering a function does not add it to an index, functions must still be associated with a specific index for them to be used when indexing and searching documents.
 * 
 * \@memberOf tokenizer
 * @param {!lunr.TokenizerFunction} fn
 * @param {string} label
 * @return {void}
 */
lunr.tokenizer.registerFunction = function(fn, label) {};

/**
 * Loads a previously serialised tokenizer.
 * 
 * A tokenizer function to be loaded must already be registered with lunr.tokenizer.
 * If the serialised tokenizer has not been registered then an error will be thrown.
 * 
 * \@memberOf tokenizer
 * @param {string} label
 * @return {!lunr.TokenizerFunction}
 */
lunr.tokenizer.load = function(label) {};

/**
 * lunr.stemmer is an english language stemmer, this is a JavaScript implementation of
 * the PorterStemmer taken from http://tartaurs.org/~martin
 * 
 * @param {string} token  The string to stem
 * @return {string}
 */
lunr.stemmer = function(token) {};

/**
 * lunr.stopWordFilter is an English language stop word list filter, any words contained
 * in the list will not be passed through the filter.
 * 
 * This is intended to be used in the Pipeline. If the token does not pass the filter then
 * undefined will be returned.
 * 
 * @param {string} token  The token to pass through the filter
 * @return {string}
 */
lunr.stopWordFilter = function(token) {};
 /** @type {!lunr.SortedSet<string>} */
lunr.stopWordFilter.stopWords;

/**
 * lunr.trimmer is a pipeline function for trimming non word characters from the beginning
 * and end of tokens before they enter the index.
 * 
 * This implementation may not work correctly for non latin characters and should either
 * be removed or adapted for use with languages with non-latin characters.
 * @param {string} token  The token to pass through the filter
 * @return {string}
 */
lunr.trimmer = function(token) {};
/**
 * @constructor
 * @struct
 */
lunr.EventEmitter = function() {};

/**
 * Can bind a single function to many different events in one call.
 * 
 * @param {string} eventName  The name(s) of events to bind this function to.
 * @param {!Function|string} handler_or_eventName2    The function to call when an event is fired. Binds a handler
 *                   function to a specific event(s).
 * @param {!Function|string=} handler_or_eventName3
 * @param {!Function|string=} handler_or_eventName4
 * @param {!Function|string=} handler_or_eventName5
 * @param {!Function=} handler
 * @return {void}
 */
lunr.EventEmitter.prototype.addListener = function(eventName, handler_or_eventName2, handler_or_eventName3, handler_or_eventName4, handler_or_eventName5, handler) {};

/**
 * Removes a handler function from a specific event.
 * 
 * @param {string} eventName  The name of the event to remove this function from.
 * @param {!Function} handler    The function to remove from an event.
 * @return {void}
 */
lunr.EventEmitter.prototype.removeListener = function(eventName, handler) {};

/**
 * Calls all functions bound to the given event.
 * 
 * Additional data can be passed to the event handler as arguments to emit after the event name.
 * 
 * @param {string} eventName The name of the event to emit.
 * @param {...?} args
 * @return {void}
 */
lunr.EventEmitter.prototype.emit = function(eventName, args) {};

/**
 * Checks whether a handler has ever been stored against an event.
 * 
 * @param {string} eventName  The name of the event to check.
 * @return {boolean}
 */
lunr.EventEmitter.prototype.hasHandler = function(eventName) {};
/**
 * @record
 * @struct
 */
lunr.IPipelineFunction = function() {};

/* TODO: CallSignature: lunr */

/* TODO: CallSignature: lunr */

/* TODO: CallSignature: lunr */
/**
 * @constructor
 * @struct
 */
lunr.Pipeline = function() {};
 /** @type {!Object<string,!Function>} */
lunr.Pipeline.prototype.registeredFunctions;

/**
 * Register a function with the pipeline.
 * 
 * Functions that are used in the pipeline should be registered if the pipeline needs to be
 * serialised, or a serialised pipeline needs to be loaded.
 * 
 * Registering a function does not add it to a pipeline, functions must still be added to instances
 * of the pipeline for them to be used when running a pipeline.
 * 
 * @param {!lunr.IPipelineFunction} fn     The function to check for.
 * @param {string} label  The label to register this function with
 * @return {void}
 */
lunr.Pipeline.prototype.registerFunction = function(fn, label) {};

/**
 * Warns if the function is not registered as a Pipeline function.
 * 
 * @param {!lunr.IPipelineFunction} fn  The function to check for.
 * @return {void}
 */
lunr.Pipeline.prototype.warnIfFunctionNotRegistered = function(fn) {};

/**
 * Adds new functions to the end of the pipeline.
 * 
 * Logs a warning if the function has not been registered.
 * 
 * @param {...!lunr.IPipelineFunction} functions  Any number of functions to add to the pipeline.
 * @return {void}
 */
lunr.Pipeline.prototype.add = function(functions) {};

/**
 * Adds a single function after a function that already exists in the pipeline.
 * 
 * Logs a warning if the function has not been registered.
 * 
 * @param {!lunr.IPipelineFunction} existingFn  A function that already exists in the pipeline.
 * @param {!lunr.IPipelineFunction} newFn       The new function to add to the pipeline.
 * @return {void}
 */
lunr.Pipeline.prototype.after = function(existingFn, newFn) {};

/**
 * Adds a single function before a function that already exists in the pipeline.
 * 
 * Logs a warning if the function has not been registered.
 * 
 * @param {!lunr.IPipelineFunction} existingFn  A function that already exists in the pipeline.
 * @param {!lunr.IPipelineFunction} newFn       The new function to add to the pipeline.
 * @return {void}
 */
lunr.Pipeline.prototype.before = function(existingFn, newFn) {};

/**
 * Removes a function from the pipeline.
 * 
 * @param {!lunr.IPipelineFunction} fn  The function to remove from the pipeline.
 * @return {void}
 */
lunr.Pipeline.prototype.remove = function(fn) {};

/**
 * Runs the current list of functions that make up the pipeline against
 * the passed tokens.
 * 
 * @param {!Array<string>} tokens  The tokens to run through the pipeline.
 * @return {!Array<string>}
 */
lunr.Pipeline.prototype.run = function(tokens) {};

/**
 * Resets the pipeline by removing any existing processors.
 * @return {void}
 */
lunr.Pipeline.prototype.reset = function() {};

/**
 * Returns a representation of the pipeline ready for serialisation.
 * @return {?}
 */
lunr.Pipeline.prototype.toJSON = function() {};

/**
 * Loads a previously serialised pipeline.
 * 
 * All functions to be loaded must already be registered with lunr.Pipeline. If any function from
 * the serialised data has not been registered then an error will be thrown.
 * 
 * @param {?} serialised  The serialised pipeline to load.
 * @return {!lunr.Pipeline}
 */
lunr.Pipeline.load = function(serialised) {};
/**
 * @constructor
 * @struct
 */
lunr.Vector = function() {};
 /** @type {!lunr.Node} */
lunr.Vector.prototype.list;

/**
 * Calculates the magnitude of this vector.
 * @return {number}
 */
lunr.Vector.prototype.magnitude = function() {};

/**
 * Calculates the dot product of this vector and another vector.
 * @param {!lunr.Vector} otherVector  The vector to compute the dot product with.
 * @return {number}
 */
lunr.Vector.prototype.dot = function(otherVector) {};

/**
 * Calculates the cosine similarity between this vector and another vector.
 * 
 * @param {!lunr.Vector} otherVector  The other vector to calculate the
 * @return {number}
 */
lunr.Vector.prototype.similarity = function(otherVector) {};

/**
 * @constructor
 * @struct
 * @param {number} idx   The index of the node in the vector.
 * @param {number} val   The data at this node in the vector.
 * @param {!lunr.Node} next  The node directly after this node in the vector.
 */
lunr.Node = function(idx, val, next) {};
 /** @type {number} */
lunr.Node.prototype.idx;
 /** @type {number} */
lunr.Node.prototype.val;
 /** @type {!lunr.Node} */
lunr.Node.prototype.next;
/**
 * @constructor
 * @struct
 */
lunr.SortedSet = function() {};
 /** @type {!Array<T>} */
lunr.SortedSet.prototype.elements;
 /** @type {number} */
lunr.SortedSet.prototype.length;

/**
 * Inserts new items into the set in the correct position to maintain the order.
 * 
 * @param {...T} values  The objects to add to this set.
 * @return {void}
 */
lunr.SortedSet.prototype.add = function(values) {};

/**
 * Converts this sorted set into an array.
 * @return {!Array<T>}
 */
lunr.SortedSet.prototype.toArray = function() {};

/**
 * Creates a new array with the results of calling a provided function on
 * every element in this sorted set.
 * 
 * Delegates to Array.prototype.map and has the same signature.
 * 
 * @param {!Function} fn   The function that is called on each element of the
 * @param {?} ctx  An optional object that can be used as the context
 * @return {!Array<T>}
 */
lunr.SortedSet.prototype.map = function(fn, ctx) {};

/**
 * Executes a provided function once per sorted set element.
 * 
 * Delegates to Array.prototype.forEach and has the same signature.
 * 
 * @param {!Function} fn   The function that is called on each element of the
 * @param {?} ctx  An optional object that can be used as the context
 * @return {?}
 */
lunr.SortedSet.prototype.forEach = function(fn, ctx) {};

/**
 * Returns the index at which a given element can be found in the sorted
 * set, or -1 if it is not present.
 * 
 * @param {T} elem   The object to locate in the sorted set.
 * @param {number=} start  An optional index at which to start searching from
 * @param {number=} end    An optional index at which to stop search from within
 * @return {number}
 */
lunr.SortedSet.prototype.indexOf = function(elem, start, end) {};

/**
 * Returns the position within the sorted set that an element should be
 * inserted at to maintain the current order of the set.
 * 
 * This function assumes that the element to search for does not already exist
 * in the sorted set.
 * 
 * @param {T} elem - The elem to find the position for in the set
 * @param {number=} start - An optional index at which to start searching from
 * @param {number=} end - An optional index at which to stop search from within
 * @return {number}
 */
lunr.SortedSet.prototype.locationFor = function(elem, start, end) {};

/**
 * Creates a new lunr.SortedSet that contains the elements in the
 * intersection of this set and the passed set.
 * 
 * @param {!lunr.SortedSet} otherSet  The set to intersect with this set.
 * @return {!lunr.SortedSet}
 */
lunr.SortedSet.prototype.intersect = function(otherSet) {};

/**
 * Creates a new lunr.SortedSet that contains the elements in the union of this
 * set and the passed set.
 * 
 * @param {!lunr.SortedSet} otherSet  The set to union with this set.
 * @return {!lunr.SortedSet}
 */
lunr.SortedSet.prototype.union = function(otherSet) {};

/**
 * Makes a copy of this set
 * @return {!lunr.SortedSet}
 */
lunr.SortedSet.prototype.clone = function() {};

/**
 * Returns a representation of the sorted set ready for serialisation.
 * @return {?}
 */
lunr.SortedSet.prototype.toJSON = function() {};

/**
 * Loads a previously serialised sorted set.
 * 
 * @template T
 * @param {!Array<T>} serialisedData  The serialised set to load.
 * @return {!lunr.SortedSet<T>}
 */
lunr.SortedSet.load = function(serialisedData) {};
/**
 * @record
 * @struct
 */
lunr.IIndexField = function() {};
 /** @type {string} */
lunr.IIndexField.prototype.name;
 /** @type {number} */
lunr.IIndexField.prototype.boost;
/**
 * @record
 * @struct
 */
lunr.IIndexSearchResult = function() {};
 /** @type {?} */
lunr.IIndexSearchResult.prototype.ref;
 /** @type {number} */
lunr.IIndexSearchResult.prototype.score;
/**
 * @constructor
 * @struct
 */
lunr.Index = function() {};
 /** @type {!lunr.EventEmitter} */
lunr.Index.prototype.eventEmitter;
 /** @type {!lunr.Store<string>} */
lunr.Index.prototype.documentStore;
 /** @type {!lunr.TokenStore} */
lunr.Index.prototype.tokenStore;
 /** @type {!lunr.SortedSet<string>} */
lunr.Index.prototype.corpusTokens;
 /** @type {!lunr.Pipeline} */
lunr.Index.prototype.pipeline;
 /** @type {!Array<!lunr.IIndexField>} */
lunr.Index.prototype._fields;
 /** @type {string} */
lunr.Index.prototype._ref;
 /** @type {!Object<string,string>} */
lunr.Index.prototype._idfCache;

/**
 * Bind a handler to events being emitted by the index.
 * 
 * The handler can be bound to many events at the same time.
 * 
 * @param {string} eventName  The name(s) of events to bind the function to.
 * @param {!Function|string} handler_or_eventName2    The function to call when an event is fired. Binds a handler
 *                   function to a specific event(s).
 * @param {!Function|string=} handler_or_eventName3
 * @param {!Function|string=} handler_or_eventName4
 * @param {!Function|string=} handler_or_eventName5
 * @param {!Function=} handler
 * @return {void}
 */
lunr.Index.prototype.on = function(eventName, handler_or_eventName2, handler_or_eventName3, handler_or_eventName4, handler_or_eventName5, handler) {};

/**
 * Removes a handler from an event being emitted by the index.
 * 
 * @param {string} eventName  The name of events to remove the function from.
 * @param {!Function} handler    The serialised set to load.
 * @return {void}
 */
lunr.Index.prototype.off = function(eventName, handler) {};

/**
 * Adds a field to the list of fields that will be searchable within documents in the index.
 * 
 * An optional boost param can be passed to affect how much tokens in this field rank in
 * search results, by default the boost value is 1.
 * 
 * Fields should be added before any documents are added to the index, fields that are added
 * after documents are added to the index will only apply to new documents added to the index.
 * 
 * @param {string} fieldName  The name of the field within the document that
 * @param {{boost: number}=} options    An optional boost that can be applied to terms in this field.
 * @return {!lunr.Index}
 */
lunr.Index.prototype.field = function(fieldName, options) {};

/**
 * Sets the property used to uniquely identify documents added to the index, by default this
 * property is 'id'.
 * 
 * This should only be changed before adding documents to the index, changing the ref property
 * without resetting the index can lead to unexpected results.
 * 
 * \@refName The property to use to uniquely identify the
 * @param {string} refName
 * @return {!lunr.Index}
 */
lunr.Index.prototype.ref = function(refName) {};

/**
 * Add a document to the index.
 * 
 * This is the way new documents enter the index, this function will run the fields from the
 * document through the index's pipeline and then add it to the index, it will then show up
 * in search results.
 * 
 * An 'add' event is emitted with the document that has been added and the index the document
 * has been added to. This event can be silenced by passing false as the second argument to add.
 * 
 * @param {?} doc        The document to add to the index.
 * @param {boolean=} emitEvent  Whether or not to emit events, default true.
 * @return {void}
 */
lunr.Index.prototype.add = function(doc, emitEvent) {};

/**
 * Removes a document from the index.
 * 
 * To make sure documents no longer show up in search results they can be removed from the
 * index using this method.
 * 
 * The document passed only needs to have the same ref property value as the document that was
 * added to the index, they could be completely different objects.
 * 
 * A 'remove' event is emitted with the document that has been removed and the index the
 * document has been removed from. This event can be silenced by passing false as the second
 * argument to remove.
 * 
 * @param {?} doc        The document to remove from the index.
 * @param {boolean=} emitEvent  Whether to emit remove events, defaults to true
 * @return {void}
 */
lunr.Index.prototype.remove = function(doc, emitEvent) {};

/**
 * Updates a document in the index.
 * 
 * When a document contained within the index gets updated, fields changed, added or removed,
 * to make sure it correctly matched against search queries, it should be updated in the index.
 * 
 * This method is just a wrapper around [[remove]] and [[add]].
 * 
 * An 'update' event is emitted with the document that has been updated and the index.
 * This event can be silenced by passing false as the second argument to update. Only an
 * update event will be fired, the 'add' and 'remove' events of the underlying calls are
 * silenced.
 * 
 * @param {?} doc        The document to update in the index.
 * @param {boolean=} emitEvent  Whether to emit update events, defaults to true
 * @return {void}
 */
lunr.Index.prototype.update = function(doc, emitEvent) {};

/**
 * Calculates the inverse document frequency for a token within the index.
 * 
 * @param {string} token  The token to calculate the idf of.
 * @return {string}
 */
lunr.Index.prototype.idf = function(token) {};

/**
 * Searches the index using the passed query.
 * 
 * Queries should be a string, multiple words are allowed and will lead to an AND based
 * query, e.g. idx.search('foo bar') will run a search for documents containing both
 * 'foo' and 'bar'.
 * 
 * All query tokens are passed through the same pipeline that document tokens are passed
 * through, so any language processing involved will be run on every query term.
 * 
 * Each query term is expanded, so that the term 'he' might be expanded to 'hello'
 * and 'help' if those terms were already included in the index.
 * 
 * Matching documents are returned as an array of objects, each object contains the
 * matching document ref, as set for this index, and the similarity score for this
 * document against the query.
 * 
 * @param {string} query  The query to search the index with.
 * @return {!Array<!lunr.IIndexSearchResult>}
 */
lunr.Index.prototype.search = function(query) {};

/**
 * Generates a vector containing all the tokens in the document matching the
 * passed documentRef.
 * 
 * The vector contains the tf-idf score for each token contained in the document with
 * the passed documentRef. The vector will contain an element for every token in the
 * indexes corpus, if the document does not contain that token the element will be 0.
 * 
 * @param {string} documentRef  The ref to find the document with.
 * @return {!lunr.Vector}
 */
lunr.Index.prototype.documentVector = function(documentRef) {};

/**
 * Returns a representation of the index ready for serialisation.
 * @return {?}
 */
lunr.Index.prototype.toJSON = function() {};

/**
 * Applies a plugin to the current index.
 * 
 * A plugin is a function that is called with the index as its context. Plugins can be
 * used to customise or extend the behaviour the index in some way. A plugin is just a
 * function, that encapsulated the custom behaviour that should be applied to the index.
 * 
 * The plugin function will be called with the index as its argument, additional arguments
 * can also be passed when calling use. The function will be called with the index as
 * its context.
 * 
 * Example:
 * 
 * ```javascript
 * var myPlugin = function(idx, arg1, arg2) {
 *     // `this` is the index to be extended
 *     // apply any extensions etc here.
 * };
 * 
 * var idx = lunr(function() {
 *     this.use(myPlugin, 'arg1', 'arg2');
 * });
 * ```
 * 
 * @param {!Function} plugin  The plugin to apply.
 * @param {...?} args
 * @return {void}
 */
lunr.Index.prototype.use = function(plugin, args) {};

/**
 * Loads a previously serialised index.
 * 
 * Issues a warning if the index being imported was serialised by a different version
 * of lunr.
 * 
 * @param {?} serialisedData  The serialised set to load.
 * @return {!lunr.Index}
 */
lunr.Index.load = function(serialisedData) {};
/**
 * @constructor
 * @struct
 */
lunr.Store = function() {};
 /** @type {!Object<string,!lunr.SortedSet<T>>} */
lunr.Store.prototype.store;
 /** @type {number} */
lunr.Store.prototype.length;

/**
 * Stores the given tokens in the store against the given id.
 * 
 * @param {string} id      The key used to store the tokens against.
 * @param {!lunr.SortedSet<T>} tokens  The tokens to store against the key.
 * @return {void}
 */
lunr.Store.prototype.set = function(id, tokens) {};

/**
 * Retrieves the tokens from the store for a given key.
 * 
 * @param {string} id  The key to lookup and retrieve from the store.
 * @return {!lunr.SortedSet<T>}
 */
lunr.Store.prototype.get = function(id) {};

/**
 * Checks whether the store contains a key.
 * 
 * @param {string} id  The id to look up in the store.
 * @return {boolean}
 */
lunr.Store.prototype.has = function(id) {};

/**
 * Removes the value for a key in the store.
 * 
 * @param {string} id  The id to remove from the store.
 * @return {void}
 */
lunr.Store.prototype.remove = function(id) {};

/**
 * Returns a representation of the store ready for serialisation.
 * @return {?}
 */
lunr.Store.prototype.toJSON = function() {};

/**
 * Loads a previously serialised store.
 * 
 * @template T
 * @param {?} serialisedData  The serialised store to load.
 * @return {!lunr.Store<T>}
 */
lunr.Store.load = function(serialisedData) {};
/**
 * @record
 * @struct
 */
lunr.ITokenDocument = function() {};
 /** @type {number} */
lunr.ITokenDocument.prototype.ref;
 /** @type {number} */
lunr.ITokenDocument.prototype.tf;
/**
 * @constructor
 * @struct
 */
lunr.TokenStore = function() {};
 /** @type {!Object<string,!lunr.TokenStore>} */
lunr.TokenStore.prototype.root;
 /** @type {!Object<string,!lunr.ITokenDocument>} */
lunr.TokenStore.prototype.docs;
 /** @type {number} */
lunr.TokenStore.prototype.length;

/**
 * Adds a new token doc pair to the store.
 * 
 * By default this function starts at the root of the current store, however it can
 * start at any node of any token store if required.
 * 
 * @param {string} token  The token to store the doc under
 * @param {!lunr.ITokenDocument} doc    The doc to store against the token
 * @param {!lunr.TokenStore=} root   An optional node at which to start looking for the
 * @return {void}
 */
lunr.TokenStore.prototype.add = function(token, doc, root) {};

/**
 * Checks whether this key is contained within this lunr.TokenStore.
 * 
 * @param {string} token  The token to check for
 * @return {boolean}
 */
lunr.TokenStore.prototype.has = function(token) {};

/**
 * Retrieve a node from the token store for a given token.
 * 
 * @param {string} token  The token to get the node for.
 * @return {!lunr.TokenStore}
 */
lunr.TokenStore.prototype.getNode = function(token) {};

/**
 * Retrieve the documents for a node for the given token.
 * 
 * By default this function starts at the root of the current store, however it can
 * start at any node of any token store if required.
 * 
 * @param {string} token  The token to get the documents for.
 * @param {!lunr.TokenStore} root   An optional node at which to start.
 * @return {!Object<string,!lunr.ITokenDocument>}
 */
lunr.TokenStore.prototype.get = function(token, root) {};

/**
 * @param {string} token
 * @param {!lunr.TokenStore} root
 * @return {number}
 */
lunr.TokenStore.prototype.count = function(token, root) {};

/**
 * Remove the document identified by ref from the token in the store.
 * 
 * @param {string} token  The token to get the documents for.
 * @param {string} ref    The ref of the document to remove from this token.
 * @return {void}
 */
lunr.TokenStore.prototype.remove = function(token, ref) {};

/**
 * Find all the possible suffixes of the passed token using tokens currently in
 * the store.
 * 
 * @param {string} token  The token to expand.
 * @param {!Array<string>=} memo
 * @return {!Array<string>}
 */
lunr.TokenStore.prototype.expand = function(token, memo) {};

/**
 * Returns a representation of the token store ready for serialisation.
 * @return {?}
 */
lunr.TokenStore.prototype.toJSON = function() {};

/**
 * Loads a previously serialised token store.
 * 
 * @param {?} serialisedData  The serialised token store to load.
 * @return {!lunr.TokenStore}
 */
lunr.TokenStore.load = function(serialisedData) {};
/** @const */
lunr.utils = {};

/**
 * Print a warning message to the console.
 * 
 * \@memberOf Utils
 * @param {?} message
 * @return {void}
 */
lunr.utils.warn = function(message) {};

/**
 * Convert an object to a string.
 * 
 * In the case of `null` and `undefined` the function returns
 * the empty string, in all other cases the result of calling
 * `toString` on the passed object is returned.
 * 
 * \@memberOf Utils
 * @param {?} obj
 * @return {string}
 */
lunr.utils.asString = function(obj) {};

/**
 * Convenience function for instantiating a new lunr index and configuring it with the default
 * pipeline functions and the passed config function.
 * 
 * When using this convenience function a new index will be created with the following functions
 * already in the pipeline:
 * 
 *  * lunr.StopWordFilter - filters out any stop words before they enter the index
 * 
 *  * lunr.stemmer - stems the tokens before entering the index.
 * 
 * Example:
 * 
 * ```javascript
 * var idx = lunr(function () {
 *     this.field('title', 10);
 *     this.field('tags', 100);
 *     this.field('body');
 * 
 *     this.ref('cid');
 * 
 *     this.pipeline.add(function () {
 *         // some custom pipeline function
 *     });
 * });
 * ```
 * @param {!Function} config
 * @return {!lunr.Index}
 */
function lunr(config) {}

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
