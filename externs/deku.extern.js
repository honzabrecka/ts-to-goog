/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/deku/index.d.ts:

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
/** @const */
var deku = {};
/**
 * @record
 * @struct
 */
deku.VirtualElement = function() {};
 /** @type {string} */
deku.VirtualElement.prototype.type;

/**
 * Create a DOM renderer using a container element.
 * Everything will be rendered inside of that container.
 * Returns a function that accepts new state that can replace what is currently rendered.
 * @param {!HTMLElement} el
 * @param {?=} dispatch
 * @return {?}
 */
deku.createApp = function(el, dispatch) {};
/** @const */
deku.dom = {};

/**
 * Create a real DOM element from a virtual element, recursively looping down.
 * When it finds custom elements it will render them, cache them, and keep going,
 * so they are treated like any other native element.
 * @template C
 * @param {!deku.VirtualElement} vnode
 * @param {string} path
 * @param {?} dispatch
 * @param {C} context
 * @return {!HTMLElement}
 */
deku.dom.create = function(vnode, path, dispatch, context) {};

/**
 * Modify a DOM element given an array of actions.
 * @template C, A
 * @param {?} dispatch
 * @param {C} context
 * @return {function(!HTMLElement, A): !HTMLElement}
 */
deku.dom.update = function(dispatch, context) {};
/** @const */
deku.string = {};

/**
 * Render a virtual element to a string. You can pass in an option state context object that will be given to all components.
 * @template C
 * @param {!deku.VirtualElement} vnode
 * @param {C=} context
 * @return {string}
 */
deku.string.render = function(vnode, context) {};

/**
 * This function lets us create virtual nodes using a simple syntax.
 * It is compatible with JSX transforms so you can use JSX to write nodes that will compile to this function.
 * @template A
 * @param {string|?} type
 * @param {A=} attributes
 * @param {...?} children
 * @return {!deku.VirtualElement}
 */
deku.element = function(type, attributes, children) {};
 /** @type {?} */
deku.h;
/** @const */
deku.diff = {};

/**
 * Compare two virtual nodes and return an array of changes to turn the left into the right.
 * @param {!deku.VirtualElement} prevNode
 * @param {!deku.VirtualElement} nextNode
 * @return {!Array<?>}
 */
deku.diff.diffNode = function(prevNode, nextNode) {};
/**
 * @constructor
 * @struct
 */
deku.diff.Actions = function() {};
 /** @type {!Array<string>} */
deku.diff.Actions.prototype._keys;
 /** @type {string} */
deku.diff.Actions.prototype._name;

/**
 * @param {string} a
 * @param {?} b
 * @param {?} c
 * @return {!deku.diff.Actions}
 */
deku.diff.Actions.setAttribute = function(a, b, c) {};

/**
 * @param {string} a
 * @param {?} b
 * @return {!deku.diff.Actions}
 */
deku.diff.Actions.removeAttribute = function(a, b) {};

/**
 * @param {?} a
 * @param {number} b
 * @param {string} c
 * @return {!deku.diff.Actions}
 */
deku.diff.Actions.insertChild = function(a, b, c) {};

/**
 * @param {number} a
 * @return {!deku.diff.Actions}
 */
deku.diff.Actions.removeChild = function(a) {};

/**
 * @param {number} a
 * @param {!Array<?>} b
 * @return {!deku.diff.Actions}
 */
deku.diff.Actions.updateChild = function(a, b) {};

/**
 * @param {!Array<?>} a
 * @return {!deku.diff.Actions}
 */
deku.diff.Actions.updateChildren = function(a) {};

/**
 * @param {number} a
 * @return {!deku.diff.Actions}
 */
deku.diff.Actions.insertBefore = function(a) {};

/**
 * @param {?} a
 * @param {?} b
 * @param {string} c
 * @return {!deku.diff.Actions}
 */
deku.diff.Actions.replaceNode = function(a, b, c) {};

/**
 * @param {?} a
 * @return {!deku.diff.Actions}
 */
deku.diff.Actions.removeNode = function(a) {};

/**
 * @return {!deku.diff.Actions}
 */
deku.diff.Actions.sameNode = function() {};

/**
 * @param {?} a
 * @param {?} b
 * @param {string} c
 * @return {!deku.diff.Actions}
 */
deku.diff.Actions.updateThunk = function(a, b, c) {};

/**
 * @param {?} pat
 * @param {!deku.diff.Actions} action
 * @return {?}
 */
deku.diff.Actions.case = function(pat, action) {};
/** @const */
deku.vnode = {};
 /** @type {?} */
deku.vnode.create;

/**
 * Text nodes are stored as objects to keep things simple
 * @param {string} text
 * @return {!deku.VirtualElement}
 */
deku.vnode.createTextElement = function(text) {};

/**
 * Lazily-rendered virtual nodes
 * @template P, T, O
 * @param {function(?): !deku.VirtualElement} fn
 * @param {string} key
 * @param {P} props
 * @param {!Array<T>} children
 * @param {O} options
 * @return {!deku.VirtualElement}
 */
deku.vnode.createThunkElement = function(fn, key, props, children, options) {};

/**
 * @return {!deku.VirtualElement}
 */
deku.vnode.createEmptyElement = function() {};

/**
 * @param {!deku.VirtualElement} vnode
 * @return {boolean}
 */
deku.vnode.isThunk = function(vnode) {};

/**
 * @param {!deku.VirtualElement} vnode
 * @return {boolean}
 */
deku.vnode.isText = function(vnode) {};

/**
 * @param {!deku.VirtualElement} vnode
 * @return {boolean}
 */
deku.vnode.isEmpty = function(vnode) {};

/**
 * @param {!deku.VirtualElement} prevNode
 * @param {!deku.VirtualElement} nextNode
 * @return {boolean}
 */
deku.vnode.isSameThunk = function(prevNode, nextNode) {};

/**
 * Create a node path, eg. (23,5,2,4) => '23.5.2.4'
 * @param {...(string|number)} paths
 * @return {string}
 */
deku.vnode.createPath = function(paths) {};
/**
 * @record
 * @struct
 */
function Model() {}
 /** @type {?} */
Model.prototype.props;
 /** @type {!Array<?>} */
Model.prototype.children;
 /** @type {string} */
Model.prototype.path;
 /** @type {?} */
Model.prototype.dispatch;
 /** @type {?} */
Model.prototype.context;
/**
 * @record
 * @struct
 */
function Component() {}
 /** @type {?} */
Component.prototype.render;
 /** @type {?} */
Component.prototype.onCreate;
 /** @type {?} */
Component.prototype.onUpdate;
 /** @type {?} */
Component.prototype.onRemove;

/** @typedef {?} */
var Thunk;

/** @typedef {?} */
var Render;

/** @typedef {?} */
var Dispatch;
