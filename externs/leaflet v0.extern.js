/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/leaflet v0/index.d.ts:
/** @const */
var L = {};

/** @typedef {(?|!Array<number>|{lat: number, lng: number})} */
L.LatLngExpression;

/** @typedef {(?|!Array<(?|!Array<number>|{lat: number, lng: number})>)} */
L.LatLngBoundsExpression;

/** @typedef {string} */
L.PositionString;
/**
 * @record
 * @struct
 */
L.AttributionOptions = function() {};
 /** @type {string} */
L.AttributionOptions.prototype.position;
 /** @type {string} */
L.AttributionOptions.prototype.prefix;

/**
 * Creates a Bounds object from two coordinates (usually top-left and bottom-right
 * corners).
 * Creates a Bounds object defined by the points it contains.
 * @param {?|!Array<?>} topLeft_or_points
 * @param {?=} bottomRight
 * @return {?}
 */
L.bounds = function(topLeft_or_points, bottomRight) {};
/**
 * @record
 * @struct
 */
L.BoundsStatic = function() {};

/* TODO: ConstructSignature: L */

/* TODO: ConstructSignature: L */
 /** @type {!L.BoundsStatic} */
L.Bounds;
 /** @type {?} */
L.Bounds.prototype.min;
 /** @type {?} */
L.Bounds.prototype.max;

/**
 * Extends the bounds to contain the given point.
 * @param {?} point
 * @return {void}
 */
L.Bounds.prototype.extend = function(point) {};

/**
 * Returns the center point of the bounds.
 * @return {?}
 */
L.Bounds.prototype.getCenter = function() {};

/**
 * Returns true if the rectangle contains the given one.
 * Returns true if the rectangle contains the given point.
 * @param {?} otherBounds_or_point
 * @return {boolean}
 */
L.Bounds.prototype.contains = function(otherBounds_or_point) {};

/**
 * Returns true if the rectangle intersects the given bounds.
 * @param {?} otherBounds
 * @return {boolean}
 */
L.Bounds.prototype.intersects = function(otherBounds) {};

/**
 * Returns true if the bounds are properly initialized.
 * @return {boolean}
 */
L.Bounds.prototype.isValid = function() {};

/**
 * Returns the size of the given bounds.
 * @return {?}
 */
L.Bounds.prototype.getSize = function() {};
/** @const */
L.Browser = {};
 /** @type {boolean} */
L.Browser.ie;
 /** @type {boolean} */
L.Browser.ie6;
 /** @type {boolean} */
L.Browser.ie7;
 /** @type {boolean} */
L.Browser.webkit;
 /** @type {boolean} */
L.Browser.webkit3d;
 /** @type {boolean} */
L.Browser.android;
 /** @type {boolean} */
L.Browser.android23;
 /** @type {boolean} */
L.Browser.mobile;
 /** @type {boolean} */
L.Browser.mobileWebkit;
 /** @type {boolean} */
L.Browser.mobileOpera;
 /** @type {boolean} */
L.Browser.touch;
 /** @type {boolean} */
L.Browser.msTouch;
 /** @type {boolean} */
L.Browser.retina;

/**
 * Instantiates a circle object given a geographical point, a radius in meters
 * and optionally an options object.
 * @param {(?|!Array<number>|{lat: number, lng: number})} latlng
 * @param {number} radius
 * @param {!L.PathOptions=} options
 * @return {?}
 */
L.circle = function(latlng, radius, options) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.CircleStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.CircleStatic} */
L.Circle;

/**
 * Returns the current geographical position of the circle.
 * @return {?}
 */
L.Circle.prototype.getLatLng = function() {};

/**
 * Returns the current radius of a circle. Units are in meters.
 * @return {number}
 */
L.Circle.prototype.getRadius = function() {};

/**
 * Sets the position of a circle to a new location.
 * @param {(?|!Array<number>|{lat: number, lng: number})} latlng
 * @return {?}
 */
L.Circle.prototype.setLatLng = function(latlng) {};

/**
 * Sets the radius of a circle. Units are in meters.
 * @param {number} radius
 * @return {?}
 */
L.Circle.prototype.setRadius = function(radius) {};

/**
 * Returns a GeoJSON representation of the circle (GeoJSON Point Feature).
 * @return {?}
 */
L.Circle.prototype.toGeoJSON = function() {};

/**
 * Instantiates a circle marker given a geographical point and optionally
 * an options object. The default radius is 10 and can be altered by passing a
 * "radius" member in the path options object.
 * @param {(?|!Array<number>|{lat: number, lng: number})} latlng
 * @param {!L.PathOptions=} options
 * @return {?}
 */
L.circleMarker = function(latlng, options) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.CircleMarkerStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.CircleMarkerStatic} */
L.CircleMarker;

/**
 * Sets the position of a circle marker to a new location.
 * @param {(?|!Array<number>|{lat: number, lng: number})} latlng
 * @return {?}
 */
L.CircleMarker.prototype.setLatLng = function(latlng) {};

/**
 * Sets the radius of a circle marker. Units are in pixels.
 * @param {number} radius
 * @return {?}
 */
L.CircleMarker.prototype.setRadius = function(radius) {};
/**
 * @record
 * @struct
 */
L.ClassExtendOptions = function() {};
 /** @type {!Function} */
L.ClassExtendOptions.prototype.initialize;
 /** @type {?} */
L.ClassExtendOptions.prototype.options;
 /** @type {?} */
L.ClassExtendOptions.prototype.includes;
 /** @type {?} */
L.ClassExtendOptions.prototype.static;

/* TODO: IndexSignature: L */
/**
 * @record
 * @struct
 */
L.ClassStatic = function() {};

/**
 * You use L.Class.extend to define new classes, but you can use the
 * same method on any class to inherit from it.
 * @template Options, NewClass
 * @param {!L.ClassExtendOptions} options
 * @return {?|function(new: (NewClass), Options): ?}
 */
L.ClassStatic.prototype.extend = function(options) {};

/**
 * You can also use the following shortcut when you just need to make
 * one additional method call.
 * @param {string} methodName
 * @param {...?} args
 * @return {void}
 */
L.ClassStatic.prototype.addInitHook = function(methodName, args) {};
/** @const */
L.Class = {};

/**
 * You use L.Class.extend to define new classes, but you can use the
 * same method on any class to inherit from it.
 * @param {!L.ClassExtendOptions} options
 * @return {?}
 */
L.Class.extend = function(options) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.ControlStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.Control.ZoomStatic} */
L.ControlStatic.prototype.Zoom;
 /** @type {!L.Control.AttributionStatic} */
L.ControlStatic.prototype.Attribution;
 /** @type {!L.Control.LayersStatic} */
L.ControlStatic.prototype.Layers;
 /** @type {!L.Control.ScaleStatic} */
L.ControlStatic.prototype.Scale;
 /** @type {!L.ControlStatic} */
L.Control;

/**
 * Sets the position of the control. See control positions.
 * @param {string} position
 * @return {?}
 */
L.Control.prototype.setPosition = function(position) {};

/**
 * Returns the current position of the control.
 * @return {string}
 */
L.Control.prototype.getPosition = function() {};

/**
 * Adds the control to the map.
 * @param {?} map
 * @return {?}
 */
L.Control.prototype.addTo = function(map) {};

/**
 * Removes the control from the map.
 * @param {?} map
 * @return {?}
 */
L.Control.prototype.removeFrom = function(map) {};

/**
 * Returns the HTML container of the control.
 * @return {!HTMLElement}
 */
L.Control.prototype.getContainer = function() {};

/**
 * Should contain code that creates all the neccessary DOM elements for the
 * control, adds listeners on relevant map events, and returns the element
 * containing the control. Called on map.addControl(control) or control.addTo(map).
 * @param {?} map
 * @return {!HTMLElement}
 */
L.Control.prototype.onAdd = function(map) {};

/**
 * Optional, should contain all clean up code (e.g. removes control's event
 * listeners). Called on map.removeControl(control) or control.removeFrom(map).
 * The control's DOM container is removed automatically.
 * @param {?} map
 * @return {void}
 */
L.Control.prototype.onRemove = function(map) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.Control.ZoomStatic = function() {};

/* TODO: ConstructSignature: L.Control */
/**
 * @record
 * @struct
 */
L.Control.Zoom = function() {};
/**
 * @record
 * @struct
 */
L.Control.ZoomOptions = function() {};
 /** @type {string} */
L.Control.ZoomOptions.prototype.position;
 /** @type {string} */
L.Control.ZoomOptions.prototype.zoomInText;
 /** @type {string} */
L.Control.ZoomOptions.prototype.zoomOutText;
 /** @type {string} */
L.Control.ZoomOptions.prototype.zoomInTitle;
 /** @type {string} */
L.Control.ZoomOptions.prototype.zoomOutTitle;
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.Control.AttributionStatic = function() {};

/* TODO: ConstructSignature: L.Control */
/**
 * @record
 * @struct
 */
L.Control.Attribution = function() {};

/**
 * Sets the text before the attributions.
 * @param {string} prefix
 * @return {!L.Control.Attribution}
 */
L.Control.Attribution.prototype.setPrefix = function(prefix) {};

/**
 * Adds an attribution text (e.g. 'Vector data &copy; CloudMade').
 * @param {string} text
 * @return {!L.Control.Attribution}
 */
L.Control.Attribution.prototype.addAttribution = function(text) {};

/**
 * Removes an attribution text.
 * @param {string} text
 * @return {!L.Control.Attribution}
 */
L.Control.Attribution.prototype.removeAttribution = function(text) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.Control.LayersStatic = function() {};

/* TODO: ConstructSignature: L.Control */
/**
 * @extends {L.IEventPowered}
 * @record
 * @struct
 */
L.Control.Layers = function() {};

/**
 * Adds a base layer (radio button entry) with the given name to the control.
 * @param {!L.ILayer} layer
 * @param {string} name
 * @return {!L.Control.Layers}
 */
L.Control.Layers.prototype.addBaseLayer = function(layer, name) {};

/**
 * Adds an overlay (checkbox entry) with the given name to the control.
 * @param {!L.ILayer} layer
 * @param {string} name
 * @return {!L.Control.Layers}
 */
L.Control.Layers.prototype.addOverlay = function(layer, name) {};

/**
 * Remove the given layer from the control.
 * @param {!L.ILayer} layer
 * @return {!L.Control.Layers}
 */
L.Control.Layers.prototype.removeLayer = function(layer) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {!L.Control.Layers}
 */
L.Control.Layers.prototype.addEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {!L.Control.Layers}
 */
L.Control.Layers.prototype.addOneTimeEventListener = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {!L.Control.Layers}
 */
L.Control.Layers.prototype.removeEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @return {boolean}
 */
L.Control.Layers.prototype.hasEventListeners = function(type) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {!L.Control.Layers}
 */
L.Control.Layers.prototype.fireEvent = function(type, data) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {!L.Control.Layers}
 */
L.Control.Layers.prototype.on = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {!L.Control.Layers}
 */
L.Control.Layers.prototype.once = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {!L.Control.Layers}
 */
L.Control.Layers.prototype.off = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {!L.Control.Layers}
 */
L.Control.Layers.prototype.fire = function(type, data) {};

/**
 * @return {!L.Control.Layers}
 */
L.Control.Layers.prototype.clearAllEventListeners = function() {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.Control.ScaleStatic = function() {};

/* TODO: ConstructSignature: L.Control */
/**
 * @record
 * @struct
 */
L.Control.Scale = function() {};
/**
 * @record
 * @struct
 */
L.control = function() {};

/* TODO: CallSignature: L */

/**
 * Creates a zoom control.
 * @param {!L.Control.ZoomOptions=} options
 * @return {!L.Control.Zoom}
 */
L.control.zoom = function(options) {};

/**
 * Creates an attribution control.
 * @param {!L.AttributionOptions=} options
 * @return {!L.Control.Attribution}
 */
L.control.attribution = function(options) {};

/**
 * Creates an attribution control with the given layers. Base layers will be
 * switched with radio buttons, while overlays will be switched with checkboxes.
 * @param {?=} baseLayers
 * @param {?=} overlays
 * @param {!L.LayersOptions=} options
 * @return {!L.Control.Layers}
 */
L.control.layers = function(baseLayers, overlays, options) {};

/**
 * Creates an scale control with the given options.
 * @param {!L.ScaleOptions=} options
 * @return {!L.Control.Scale}
 */
L.control.scale = function(options) {};
/**
 * @record
 * @struct
 */
L.ControlOptions = function() {};
 /** @type {string} */
L.ControlOptions.prototype.position;
/** @const */
L.CRS = {};
 /** @type {!L.ICRS} */
L.CRS.EPSG3857;
 /** @type {!L.ICRS} */
L.CRS.EPSG4326;
 /** @type {!L.ICRS} */
L.CRS.EPSG3395;
 /** @type {!L.ICRS} */
L.CRS.Simple;

/**
 * Creates a div icon instance with the given options.
 * @param {!L.DivIconOptions} options
 * @return {?}
 */
L.divIcon = function(options) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.DivIconStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.DivIconStatic} */
L.DivIcon;
/**
 * @record
 * @struct
 */
L.DivIconOptions = function() {};
 /** @type {(?|!Array<?>)} */
L.DivIconOptions.prototype.iconSize;
 /** @type {(?|!Array<?>)} */
L.DivIconOptions.prototype.iconAnchor;
 /** @type {string} */
L.DivIconOptions.prototype.className;
 /** @type {string} */
L.DivIconOptions.prototype.html;
 /** @type {(?|!Array<?>)} */
L.DivIconOptions.prototype.popupAnchor;
/**
 * @record
 * @struct
 */
L.DomEvent = function() {};

/**
 * Adds a listener fn to the element's DOM event of the specified type. this keyword
 * inside the listener will point to context, or to the element if not specified.
 * @param {!HTMLElement} el
 * @param {string} type
 * @param {function(!Event): void} fn
 * @param {?=} context
 * @return {?}
 */
L.DomEvent.prototype.addListener = function(el, type, fn, context) {};

/**
 * @param {!HTMLElement} el
 * @param {string} type
 * @param {function(!Event): void} fn
 * @param {?=} context
 * @return {?}
 */
L.DomEvent.prototype.on = function(el, type, fn, context) {};

/**
 * Removes an event listener from the element.
 * @param {!HTMLElement} el
 * @param {string} type
 * @param {function(!Event): void} fn
 * @param {?=} context
 * @return {?}
 */
L.DomEvent.prototype.removeListener = function(el, type, fn, context) {};

/**
 * @param {!HTMLElement} el
 * @param {string} type
 * @param {function(!Event): void} fn
 * @param {?=} context
 * @return {?}
 */
L.DomEvent.prototype.off = function(el, type, fn, context) {};

/**
 * Stop the given event from propagation to parent elements. Used inside the
 * listener functions:
 * L.DomEvent.addListener(div, 'click', function
 * (e) {
 * L.DomEvent.stopPropagation(e);
 * });
 * @param {!Event} e
 * @return {?}
 */
L.DomEvent.prototype.stopPropagation = function(e) {};

/**
 * Prevents the default action of the event from happening (such as following
 * a link in the href of the a element, or doing a POST request with page reload
 * when form is submitted). Use it inside listener functions.
 * @param {!Event} e
 * @return {?}
 */
L.DomEvent.prototype.preventDefault = function(e) {};

/**
 * Does stopPropagation and preventDefault at the same time.
 * @param {!Event} e
 * @return {?}
 */
L.DomEvent.prototype.stop = function(e) {};

/**
 * Adds stopPropagation to the element's 'click', 'doubleclick', 'mousedown'
 * and 'touchstart' events.
 * @param {!HTMLElement} el
 * @return {?}
 */
L.DomEvent.prototype.disableClickPropagation = function(el) {};

/**
 * Gets normalized mouse position from a DOM event relative to the container
 * or to the whole page if not specified.
 * @param {!Event} e
 * @param {!HTMLElement=} container
 * @return {?}
 */
L.DomEvent.prototype.getMousePosition = function(e, container) {};

/**
 * Gets normalized wheel delta from a mousewheel DOM event.
 * @param {!Event} e
 * @return {number}
 */
L.DomEvent.prototype.getWheelDelta = function(e) {};
 /** @type {?} */
L.DomEvent;
/** @const */
L.DomUtil = {};

/**
 * Returns an element with the given id if a string was passed, or just returns
 * the element if it was passed directly.
 * @param {string} id
 * @return {!HTMLElement}
 */
L.DomUtil.get = function(id) {};

/**
 * Returns the value for a certain style attribute on an element, including
 * computed values or values set through CSS.
 * @param {!HTMLElement} el
 * @param {string} style
 * @return {string}
 */
L.DomUtil.getStyle = function(el, style) {};

/**
 * Returns the offset to the viewport for the requested element.
 * @param {!HTMLElement} el
 * @return {?}
 */
L.DomUtil.getViewportOffset = function(el) {};

/**
 * Creates an element with tagName, sets the className, and optionally appends
 * it to container element.
 * @param {string} tagName
 * @param {string} className
 * @param {!HTMLElement=} container
 * @return {!HTMLElement}
 */
L.DomUtil.create = function(tagName, className, container) {};

/**
 * Makes sure text cannot be selected, for example during dragging.
 * @return {void}
 */
L.DomUtil.disableTextSelection = function() {};

/**
 * Makes text selection possible again.
 * @return {void}
 */
L.DomUtil.enableTextSelection = function() {};

/**
 * Returns true if the element class attribute contains name.
 * @param {!HTMLElement} el
 * @param {string} name
 * @return {boolean}
 */
L.DomUtil.hasClass = function(el, name) {};

/**
 * Adds name to the element's class attribute.
 * @param {!HTMLElement} el
 * @param {string} name
 * @return {void}
 */
L.DomUtil.addClass = function(el, name) {};

/**
 * Removes name from the element's class attribute.
 * @param {!HTMLElement} el
 * @param {string} name
 * @return {void}
 */
L.DomUtil.removeClass = function(el, name) {};

/**
 * Set the opacity of an element (including old IE support). Value must be from
 * 0 to 1.
 * @param {!HTMLElement} el
 * @param {number} value
 * @return {void}
 */
L.DomUtil.setOpacity = function(el, value) {};

/**
 * Goes through the array of style names and returns the first name that is a valid
 * style name for an element. If no such name is found, it returns false. Useful
 * for vendor-prefixed styles like transform.
 * @param {!Array<string>} props
 * @return {?}
 */
L.DomUtil.testProp = function(props) {};

/**
 * Returns a CSS transform string to move an element by the offset provided in
 * the given point. Uses 3D translate on WebKit for hardware-accelerated transforms
 * and 2D on other browsers.
 * @param {?} point
 * @return {string}
 */
L.DomUtil.getTranslateString = function(point) {};

/**
 * Returns a CSS transform string to scale an element (with the given scale origin).
 * @param {number} scale
 * @param {?} origin
 * @return {string}
 */
L.DomUtil.getScaleString = function(scale, origin) {};

/**
 * Sets the position of an element to coordinates specified by point, using
 * CSS translate or top/left positioning depending on the browser (used by
 * Leaflet internally to position its layers). Forces top/left positioning
 * if disable3D is true.
 * @param {!HTMLElement} el
 * @param {?} point
 * @param {boolean=} disable3D
 * @return {void}
 */
L.DomUtil.setPosition = function(el, point, disable3D) {};

/**
 * Returns the coordinates of an element previously positioned with setPosition.
 * @param {!HTMLElement} el
 * @return {?}
 */
L.DomUtil.getPosition = function(el) {};
 /** @type {string} */
L.DomUtil.TRANSITION;
 /** @type {string} */
L.DomUtil.TRANSFORM;
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.DraggableStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.DraggableStatic} */
L.Draggable;

/**
 * Enables the dragging ability.
 * @return {void}
 */
L.Draggable.prototype.enable = function() {};

/**
 * Disables the dragging ability.
 * @return {void}
 */
L.Draggable.prototype.disable = function() {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Draggable.prototype.addEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {?}
 */
L.Draggable.prototype.addOneTimeEventListener = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Draggable.prototype.removeEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @return {boolean}
 */
L.Draggable.prototype.hasEventListeners = function(type) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {?}
 */
L.Draggable.prototype.fireEvent = function(type, data) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Draggable.prototype.on = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {?}
 */
L.Draggable.prototype.once = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Draggable.prototype.off = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {?}
 */
L.Draggable.prototype.fire = function(type, data) {};

/**
 * @return {?}
 */
L.Draggable.prototype.clearAllEventListeners = function() {};

/**
 * Create a layer group, optionally given an initial set of layers.
 * @template T
 * @param {!Array<T>=} layers
 * @return {?<T>}
 */
L.featureGroup = function(layers) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.FeatureGroupStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.FeatureGroupStatic} */
L.FeatureGroup;

/**
 * Binds a popup with a particular HTML content to a click on any layer from the
 * group that has a bindPopup method.
 * @param {string} htmlContent
 * @param {!L.PopupOptions=} options
 * @return {?}
 */
L.FeatureGroup.prototype.bindPopup = function(htmlContent, options) {};

/**
 * Returns the LatLngBounds of the Feature Group (created from bounds and coordinates
 * of its children).
 * @return {?}
 */
L.FeatureGroup.prototype.getBounds = function() {};

/**
 * Sets the given path options to each layer of the group that has a setStyle method.
 * @param {!L.PathOptions} style
 * @return {?}
 */
L.FeatureGroup.prototype.setStyle = function(style) {};

/**
 * Brings the layer group to the top of all other layers.
 * @return {?}
 */
L.FeatureGroup.prototype.bringToFront = function() {};

/**
 * Brings the layer group to the bottom of all other layers.
 * @return {?}
 */
L.FeatureGroup.prototype.bringToBack = function() {};

/**
 * Should contain code that creates DOM elements for the overlay, adds them
 * to map panes where they should belong and puts listeners on relevant map events.
 * Called on map.addLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.FeatureGroup.prototype.onAdd = function(map) {};

/**
 * Should contain all clean up code that removes the overlay's elements from
 * the DOM and removes listeners previously added in onAdd. Called on map.removeLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.FeatureGroup.prototype.onRemove = function(map) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.FeatureGroup.prototype.addEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {?}
 */
L.FeatureGroup.prototype.addOneTimeEventListener = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.FeatureGroup.prototype.removeEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @return {boolean}
 */
L.FeatureGroup.prototype.hasEventListeners = function(type) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {?}
 */
L.FeatureGroup.prototype.fireEvent = function(type, data) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.FeatureGroup.prototype.on = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {?}
 */
L.FeatureGroup.prototype.once = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.FeatureGroup.prototype.off = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {?}
 */
L.FeatureGroup.prototype.fire = function(type, data) {};

/**
 * @return {?}
 */
L.FeatureGroup.prototype.clearAllEventListeners = function() {};

/**
 * Creates a GeoJSON layer. Optionally accepts an object in GeoJSON format
 * to display on the map (you can alternatively add it later with addData method)
 * and an options object.
 * @param {?=} geojson
 * @param {!L.GeoJSONOptions=} options
 * @return {?}
 */
L.geoJson = function(geojson, options) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.GeoJSONStatic = function() {};

/* TODO: ConstructSignature: L */

/**
 * Creates a layer from a given GeoJSON feature.
 * @param {?} featureData
 * @param {function(?, ?): !L.ILayer=} pointToLayer
 * @return {!L.ILayer}
 */
L.GeoJSONStatic.prototype.geometryToLayer = function(featureData, pointToLayer) {};

/**
 * Creates a LatLng object from an array of 2 numbers (latitude, longitude)
 * used in GeoJSON for points. If reverse is set to true, the numbers will be interpreted
 * as (longitude, latitude).
 * @param {!Array<number>} coords
 * @param {boolean=} reverse
 * @return {?}
 */
L.GeoJSONStatic.prototype.coordsToLatLng = function(coords, reverse) {};

/**
 * Creates a multidimensional array of LatLng objects from a GeoJSON coordinates
 * array. levelsDeep specifies the nesting level (0 is for an array of points,
 * 1 for an array of arrays of points, etc., 0 by default). If reverse is set to
 * true, the numbers will be interpreted as (longitude, latitude).
 * @param {!Array<?>} coords
 * @param {number=} levelsDeep
 * @param {boolean=} reverse
 * @return {!Array<?>}
 */
L.GeoJSONStatic.prototype.coordsToLatLngs = function(coords, levelsDeep, reverse) {};
 /** @type {!L.GeoJSONStatic} */
L.GeoJSON;

/**
 * Adds a GeoJSON object to the layer.
 * @param {?} data
 * @return {boolean}
 */
L.GeoJSON.prototype.addData = function(data) {};

/**
 * Changes styles of GeoJSON vector layers with the given style function.
 * Changes styles of GeoJSON vector layers with the given style options.
 * @param {function(?): ?|!L.PathOptions} style
 * @return {?}
 */
L.GeoJSON.prototype.setStyle = function(style) {};

/**
 * Resets the the given vector layer's style to the original GeoJSON style,
 * useful for resetting style after hover events.
 * @param {?} layer
 * @return {?}
 */
L.GeoJSON.prototype.resetStyle = function(layer) {};
/**
 * @record
 * @struct
 */
L.GeoJSONOptions = function() {};
 /** @type {function(?, ?): !L.ILayer} */
L.GeoJSONOptions.prototype.pointToLayer;
 /** @type {function(?): ?} */
L.GeoJSONOptions.prototype.style;
 /** @type {function(?, !L.ILayer): void} */
L.GeoJSONOptions.prototype.onEachFeature;
 /** @type {function(?, !L.ILayer): boolean} */
L.GeoJSONOptions.prototype.filter;
 /** @type {function(!Array<?>): !Array<?>} */
L.GeoJSONOptions.prototype.coordsToLatLng;

/**
 * Creates an icon instance with the given options.
 * @param {!L.IconOptions} options
 * @return {?}
 */
L.icon = function(options) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.IconStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {function(new: (!L.Icon.Default), !L.IconOptions): ?} */
L.IconStatic.prototype.Default;
 /** @type {!L.IconStatic} */
L.Icon;
/**
 * @record
 * @struct
 */
L.Icon.Default = function() {};
/**
 * @record
 * @struct
 */
L.IconOptions = function() {};
 /** @type {string} */
L.IconOptions.prototype.iconUrl;
 /** @type {string} */
L.IconOptions.prototype.iconRetinaUrl;
 /** @type {(?|!Array<?>)} */
L.IconOptions.prototype.iconSize;
 /** @type {(?|!Array<?>)} */
L.IconOptions.prototype.iconAnchor;
 /** @type {string} */
L.IconOptions.prototype.shadowUrl;
 /** @type {string} */
L.IconOptions.prototype.shadowRetinaUrl;
 /** @type {(?|!Array<?>)} */
L.IconOptions.prototype.shadowSize;
 /** @type {(?|!Array<?>)} */
L.IconOptions.prototype.shadowAnchor;
 /** @type {(?|!Array<?>)} */
L.IconOptions.prototype.popupAnchor;
 /** @type {string} */
L.IconOptions.prototype.className;
/**
 * @record
 * @struct
 */
L.IControl = function() {};

/**
 * Should contain code that creates all the neccessary DOM elements for the
 * control, adds listeners on relevant map events, and returns the element
 * containing the control. Called on map.addControl(control) or control.addTo(map).
 * @param {?} map
 * @return {!HTMLElement}
 */
L.IControl.prototype.onAdd = function(map) {};

/**
 * Optional, should contain all clean up code (e.g. removes control's event
 * listeners). Called on map.removeControl(control) or control.removeFrom(map).
 * The control's DOM container is removed automatically.
 * @param {?} map
 * @return {void}
 */
L.IControl.prototype.onRemove = function(map) {};
/**
 * @record
 * @struct
 */
L.ICRS = function() {};
 /** @type {!L.IProjection} */
L.ICRS.prototype.projection;
 /** @type {?} */
L.ICRS.prototype.transformation;
 /** @type {string} */
L.ICRS.prototype.code;

/**
 * Projects geographical coordinates on a given zoom into pixel coordinates.
 * @param {?} latlng
 * @param {number} zoom
 * @return {?}
 */
L.ICRS.prototype.latLngToPoint = function(latlng, zoom) {};

/**
 * The inverse of latLngToPoint. Projects pixel coordinates on a given zoom
 * into geographical coordinates.
 * @param {?} point
 * @param {number} zoom
 * @return {?}
 */
L.ICRS.prototype.pointToLatLng = function(point, zoom) {};

/**
 * Projects geographical coordinates into coordinates in units accepted
 * for this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
 * @param {?} latlng
 * @return {?}
 */
L.ICRS.prototype.project = function(latlng) {};

/**
 * Returns the scale used when transforming projected coordinates into pixel
 * coordinates for a particular zoom. For example, it returns 256 * 2^zoom for
 * Mercator-based CRS.
 * @param {number} zoom
 * @return {number}
 */
L.ICRS.prototype.scale = function(zoom) {};

/**
 * Returns the size of the world in pixels for a particular zoom.
 * @param {number} zoom
 * @return {?}
 */
L.ICRS.prototype.getSize = function(zoom) {};
/**
 * @record
 * @struct
 */
L.IEventPowered = function() {};

/**
 * Adds a listener function (fn) to a particular event type of the object. You
 * can optionally specify the context of the listener (object the this keyword
 * will point to). You can also pass several space-separated types (e.g. 'click
 * dblclick').
 * Adds a set of type/listener pairs, e.g. {click: onClick, mousemove: onMouseMove}
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {T}
 */
L.IEventPowered.prototype.addEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * The same as above except the listener will only get fired once and then removed.
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {T}
 */
L.IEventPowered.prototype.addOneTimeEventListener = function(type, fn, context) {};

/**
 * Removes a previously added listener function. If no function is specified,
 * it will remove all the listeners of that particular event from the object.
 * Removes a set of type/listener pairs.
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {T}
 */
L.IEventPowered.prototype.removeEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * Returns true if a particular event type has some listeners attached to it.
 * @param {string} type
 * @return {boolean}
 */
L.IEventPowered.prototype.hasEventListeners = function(type) {};

/**
 * Fires an event of the specified type. You can optionally provide an data object
 * — the first argument of the listener function will contain its properties.
 * @param {string} type
 * @param {?=} data
 * @return {T}
 */
L.IEventPowered.prototype.fireEvent = function(type, data) {};

/**
 * Removes all listeners to all events on the object.
 * @return {T}
 */
L.IEventPowered.prototype.clearAllEventListeners = function() {};

/**
 * Alias to addEventListener.
 * Alias to addEventListener.
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {T}
 */
L.IEventPowered.prototype.on = function(type_or_eventMap, fn_or_context, context) {};

/**
 * Alias to addOneTimeEventListener.
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {T}
 */
L.IEventPowered.prototype.once = function(type, fn, context) {};

/**
 * Alias to removeEventListener.
 * Alias to removeEventListener.
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {T}
 */
L.IEventPowered.prototype.off = function(type_or_eventMap, fn_or_context, context) {};

/**
 * Alias to fireEvent.
 * @param {string} type
 * @param {?=} data
 * @return {T}
 */
L.IEventPowered.prototype.fire = function(type, data) {};
/**
 * @record
 * @struct
 */
L.IHandler = function() {};

/**
 * Enables the handler.
 * @return {void}
 */
L.IHandler.prototype.enable = function() {};

/**
 * Disables the handler.
 * @return {void}
 */
L.IHandler.prototype.disable = function() {};

/**
 * Returns true if the handler is enabled.
 * @return {boolean}
 */
L.IHandler.prototype.enabled = function() {};
/**
 * @record
 * @struct
 */
L.Handler = function() {};

/**
 * @param {?} map
 * @return {void}
 */
L.Handler.prototype.initialize = function(map) {};
/**
 * @record
 * @struct
 */
L.ILayer = function() {};

/**
 * Should contain code that creates DOM elements for the overlay, adds them
 * to map panes where they should belong and puts listeners on relevant map events.
 * Called on map.addLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.ILayer.prototype.onAdd = function(map) {};

/**
 * Should contain all clean up code that removes the overlay's elements from
 * the DOM and removes listeners previously added in onAdd. Called on map.removeLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.ILayer.prototype.onRemove = function(map) {};
/** @const */
L.Mixin = {};
/**
 * @extends {L.IEventPowered}
 * @record
 * @struct
 */
L.Mixin.LeafletMixinEvents = function() {};
 /** @type {!L.Mixin.LeafletMixinEvents} */
L.Mixin.Events;

/**
 * Instantiates an image overlay object given the URL of the image and the geographical
 * bounds it is tied to.
 * @param {string} imageUrl
 * @param {?} bounds
 * @param {!L.ImageOverlayOptions=} options
 * @return {?}
 */
L.imageOverlay = function(imageUrl, bounds, options) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.ImageOverlayStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.ImageOverlayStatic} */
L.ImageOverlay;

/**
 * Adds the overlay to the map.
 * @param {?} map
 * @return {?}
 */
L.ImageOverlay.prototype.addTo = function(map) {};

/**
 * Sets the opacity of the overlay.
 * @param {number} opacity
 * @return {?}
 */
L.ImageOverlay.prototype.setOpacity = function(opacity) {};

/**
 * Changes the URL of the image.
 * @param {string} imageUrl
 * @return {?}
 */
L.ImageOverlay.prototype.setUrl = function(imageUrl) {};

/**
 * Brings the layer to the top of all overlays.
 * @return {?}
 */
L.ImageOverlay.prototype.bringToFront = function() {};

/**
 * Brings the layer to the bottom of all overlays.
 * @return {?}
 */
L.ImageOverlay.prototype.bringToBack = function() {};

/**
 * Should contain code that creates DOM elements for the overlay, adds them
 * to map panes where they should belong and puts listeners on relevant map events.
 * Called on map.addLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.ImageOverlay.prototype.onAdd = function(map) {};

/**
 * Should contain all clean up code that removes the overlay's elements from
 * the DOM and removes listeners previously added in onAdd. Called on map.removeLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.ImageOverlay.prototype.onRemove = function(map) {};
/**
 * @record
 * @struct
 */
L.ImageOverlayOptions = function() {};
 /** @type {number} */
L.ImageOverlayOptions.prototype.opacity;
/**
 * @record
 * @struct
 */
L.IProjection = function() {};

/**
 * Projects geographical coordinates into a 2D point.
 * @param {?} latlng
 * @return {?}
 */
L.IProjection.prototype.project = function(latlng) {};

/**
 * The inverse of project. Projects a 2D point into geographical location.
 * @param {?} point
 * @return {?}
 */
L.IProjection.prototype.unproject = function(point) {};
 /** @type {string} */
L.version;

/**
 * This method restores the L global variale to the original value it had
 * before Leaflet inclusion, and returns the real Leaflet namespace.
 * @return {?}
 */
L.noConflict = function() {};

/**
 * Creates an object representing a geographical point with the given latitude
 * and longitude.
 * Creates an object representing a geographical point with the given latitude
 * and longitude.
 * @param {number|(?|!Array<number>|{lat: number, lng: number})} latitude_or_coords
 * @param {number=} longitude
 * @return {?}
 */
L.latLng = function(latitude_or_coords, longitude) {};
/**
 * @record
 * @struct
 */
L.LatLngStatic = function() {};

/* TODO: ConstructSignature: L */

/* TODO: ConstructSignature: L */
 /** @type {number} */
L.LatLngStatic.prototype.DEG_TO_RAD;
 /** @type {number} */
L.LatLngStatic.prototype.RAD_TO_DEG;
 /** @type {number} */
L.LatLngStatic.prototype.MAX_MARGIN;
 /** @type {!L.LatLngStatic} */
L.LatLng;
 /** @type {number} */
L.LatLng.prototype.lat;
 /** @type {number} */
L.LatLng.prototype.lng;

/**
 * Returns the distance (in meters) to the given LatLng calculated using the
 * Haversine formula. See description on wikipedia
 * @param {(?|!Array<number>|{lat: number, lng: number})} otherLatlng
 * @return {number}
 */
L.LatLng.prototype.distanceTo = function(otherLatlng) {};

/**
 * Returns true if the given LatLng point is at the same position (within a small
 * margin of error).
 * @param {(?|!Array<number>|{lat: number, lng: number})} otherLatlng
 * @return {boolean}
 */
L.LatLng.prototype.equals = function(otherLatlng) {};

/**
 * Returns a string representation of the point (for debugging purposes).
 * @return {string}
 */
L.LatLng.prototype.toString = function() {};

/**
 * Returns a new LatLng object with the longitude wrapped around left and right
 * boundaries (-180 to 180 by default).
 * @param {number=} left
 * @param {number=} right
 * @return {?}
 */
L.LatLng.prototype.wrap = function(left, right) {};

/**
 * Creates a LatLngBounds object by defining south-west and north-east corners
 * of the rectangle.
 * Creates a LatLngBounds object defined by the geographical points it contains.
 * Very useful for zooming the map to fit a particular set of locations with fitBounds.
 * @param {(?|!Array<number>|{lat: number, lng: number})|(?|!Array<(?|!Array<number>|{lat: number, lng: number})>)} southWest_or_latlngs
 * @param {(?|!Array<number>|{lat: number, lng: number})=} northEast
 * @return {?}
 */
L.latLngBounds = function(southWest_or_latlngs, northEast) {};
/**
 * @record
 * @struct
 */
L.LatLngBoundsStatic = function() {};

/* TODO: ConstructSignature: L */

/* TODO: ConstructSignature: L */
 /** @type {!L.LatLngBoundsStatic} */
L.LatLngBounds;

/**
 * Extends the bounds to contain the given point.
 * Extends the bounds to contain the given bounds.
 * @param {(?|!Array<number>|{lat: number, lng: number})|(?|!Array<(?|!Array<number>|{lat: number, lng: number})>)} latlng
 * @return {?}
 */
L.LatLngBounds.prototype.extend = function(latlng) {};

/**
 * Returns the south-west point of the bounds.
 * @return {?}
 */
L.LatLngBounds.prototype.getSouthWest = function() {};

/**
 * Returns the north-east point of the bounds.
 * @return {?}
 */
L.LatLngBounds.prototype.getNorthEast = function() {};

/**
 * Returns the north-west point of the bounds.
 * @return {?}
 */
L.LatLngBounds.prototype.getNorthWest = function() {};

/**
 * Returns the south-east point of the bounds.
 * @return {?}
 */
L.LatLngBounds.prototype.getSouthEast = function() {};

/**
 * Returns the west longitude in degrees of the bounds.
 * @return {number}
 */
L.LatLngBounds.prototype.getWest = function() {};

/**
 * Returns the east longitude in degrees of the bounds.
 * @return {number}
 */
L.LatLngBounds.prototype.getEast = function() {};

/**
 * Returns the north latitude in degrees of the bounds.
 * @return {number}
 */
L.LatLngBounds.prototype.getNorth = function() {};

/**
 * Returns the south latitude in degrees of the bounds.
 * @return {number}
 */
L.LatLngBounds.prototype.getSouth = function() {};

/**
 * Returns the center point of the bounds.
 * @return {?}
 */
L.LatLngBounds.prototype.getCenter = function() {};

/**
 * Returns true if the rectangle contains the given one.
 * Returns true if the rectangle contains the given point.
 * @param {(?|!Array<(?|!Array<number>|{lat: number, lng: number})>)|(?|!Array<number>|{lat: number, lng: number})} otherBounds_or_latlng
 * @return {boolean}
 */
L.LatLngBounds.prototype.contains = function(otherBounds_or_latlng) {};

/**
 * Returns true if the rectangle intersects the given bounds.
 * @param {(?|!Array<(?|!Array<number>|{lat: number, lng: number})>)} otherBounds
 * @return {boolean}
 */
L.LatLngBounds.prototype.intersects = function(otherBounds) {};

/**
 * Returns true if the rectangle is equivalent (within a small margin of error)
 * to the given bounds.
 * @param {(?|!Array<(?|!Array<number>|{lat: number, lng: number})>)} otherBounds
 * @return {boolean}
 */
L.LatLngBounds.prototype.equals = function(otherBounds) {};

/**
 * Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat'
 * format. Useful for sending requests to web services that return geo data.
 * @return {string}
 */
L.LatLngBounds.prototype.toBBoxString = function() {};

/**
 * Returns bigger bounds created by extending the current bounds by a given
 * percentage in each direction.
 * @param {number} bufferRatio
 * @return {?}
 */
L.LatLngBounds.prototype.pad = function(bufferRatio) {};

/**
 * Returns true if the bounds are properly initialized.
 * @return {boolean}
 */
L.LatLngBounds.prototype.isValid = function() {};

/**
 * Create a layer group, optionally given an initial set of layers.
 * @template T
 * @param {!Array<T>=} layers
 * @return {?<T>}
 */
L.layerGroup = function(layers) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.LayerGroupStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.LayerGroupStatic} */
L.LayerGroup;

/**
 * Adds the group of layers to the map.
 * @param {?} map
 * @return {?}
 */
L.LayerGroup.prototype.addTo = function(map) {};

/**
 * Adds a given layer to the group.
 * @param {T} layer
 * @return {?}
 */
L.LayerGroup.prototype.addLayer = function(layer) {};

/**
 * Removes a given layer from the group.
 * Removes a given layer of the given id from the group.
 * @param {T|string} layer_or_id
 * @return {?}
 */
L.LayerGroup.prototype.removeLayer = function(layer_or_id) {};

/**
 * Returns true if the given layer is currently added to the group.
 * @param {T} layer
 * @return {boolean}
 */
L.LayerGroup.prototype.hasLayer = function(layer) {};

/**
 * Returns the layer with the given id.
 * @param {string} id
 * @return {T}
 */
L.LayerGroup.prototype.getLayer = function(id) {};

/**
 * Returns an array of all the layers added to the group.
 * @return {!Array<T>}
 */
L.LayerGroup.prototype.getLayers = function() {};

/**
 * Removes all the layers from the group.
 * @return {?}
 */
L.LayerGroup.prototype.clearLayers = function() {};

/**
 * Iterates over the layers of the group, optionally specifying context of
 * the iterator function.
 * @param {function(T): void} fn
 * @param {?=} context
 * @return {?}
 */
L.LayerGroup.prototype.eachLayer = function(fn, context) {};

/**
 * Returns a GeoJSON representation of the layer group (GeoJSON FeatureCollection).
 * Note: Descendent classes MultiPolygon & MultiPolyLine return `Feature`s, not `FeatureCollection`s
 * @return {?}
 */
L.LayerGroup.prototype.toGeoJSON = function() {};

/**
 * Should contain code that creates DOM elements for the overlay, adds them
 * to map panes where they should belong and puts listeners on relevant map events.
 * Called on map.addLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.LayerGroup.prototype.onAdd = function(map) {};

/**
 * Should contain all clean up code that removes the overlay's elements from
 * the DOM and removes listeners previously added in onAdd. Called on map.removeLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.LayerGroup.prototype.onRemove = function(map) {};
/**
 * @record
 * @struct
 */
L.LayersOptions = function() {};
 /** @type {string} */
L.LayersOptions.prototype.position;
 /** @type {boolean} */
L.LayersOptions.prototype.collapsed;
 /** @type {boolean} */
L.LayersOptions.prototype.autoZIndex;
/**
 * @extends {L.LeafletEvent}
 * @record
 * @struct
 */
L.LeafletErrorEvent = function() {};
 /** @type {string} */
L.LeafletErrorEvent.prototype.message;
 /** @type {number} */
L.LeafletErrorEvent.prototype.code;
/**
 * @record
 * @struct
 */
L.LeafletEvent = function() {};
 /** @type {string} */
L.LeafletEvent.prototype.type;
 /** @type {?} */
L.LeafletEvent.prototype.target;
/**
 * @extends {L.LeafletEvent}
 * @record
 * @struct
 */
L.LeafletGeoJSONEvent = function() {};
 /** @type {!L.ILayer} */
L.LeafletGeoJSONEvent.prototype.layer;
 /** @type {?} */
L.LeafletGeoJSONEvent.prototype.properties;
 /** @type {string} */
L.LeafletGeoJSONEvent.prototype.geometryType;
 /** @type {string} */
L.LeafletGeoJSONEvent.prototype.id;
/**
 * @extends {L.LeafletEvent}
 * @record
 * @struct
 */
L.LeafletLayerEvent = function() {};
 /** @type {!L.ILayer} */
L.LeafletLayerEvent.prototype.layer;
/**
 * @extends {L.LeafletEvent}
 * @record
 * @struct
 */
L.LeafletLayersControlEvent = function() {};
 /** @type {!L.ILayer} */
L.LeafletLayersControlEvent.prototype.layer;
 /** @type {string} */
L.LeafletLayersControlEvent.prototype.name;
/**
 * @extends {L.LeafletEvent}
 * @record
 * @struct
 */
L.LeafletLocationEvent = function() {};
 /** @type {?} */
L.LeafletLocationEvent.prototype.latlng;
 /** @type {?} */
L.LeafletLocationEvent.prototype.bounds;
 /** @type {number} */
L.LeafletLocationEvent.prototype.accuracy;
 /** @type {number} */
L.LeafletLocationEvent.prototype.altitude;
 /** @type {number} */
L.LeafletLocationEvent.prototype.altitudeAccuracy;
 /** @type {number} */
L.LeafletLocationEvent.prototype.heading;
 /** @type {number} */
L.LeafletLocationEvent.prototype.speed;
 /** @type {number} */
L.LeafletLocationEvent.prototype.timestamp;
/**
 * @extends {L.LeafletEvent}
 * @record
 * @struct
 */
L.LeafletMouseEvent = function() {};
 /** @type {?} */
L.LeafletMouseEvent.prototype.latlng;
 /** @type {?} */
L.LeafletMouseEvent.prototype.layerPoint;
 /** @type {?} */
L.LeafletMouseEvent.prototype.containerPoint;
 /** @type {!MouseEvent} */
L.LeafletMouseEvent.prototype.originalEvent;
/**
 * @extends {L.LeafletEvent}
 * @record
 * @struct
 */
L.LeafletPopupEvent = function() {};
 /** @type {?} */
L.LeafletPopupEvent.prototype.popup;
/**
 * @extends {L.LeafletEvent}
 * @record
 * @struct
 */
L.LeafletDragEndEvent = function() {};
 /** @type {number} */
L.LeafletDragEndEvent.prototype.distance;
/**
 * @extends {L.LeafletEvent}
 * @record
 * @struct
 */
L.LeafletResizeEvent = function() {};
 /** @type {?} */
L.LeafletResizeEvent.prototype.oldSize;
 /** @type {?} */
L.LeafletResizeEvent.prototype.newSize;
/**
 * @extends {L.LeafletEvent}
 * @record
 * @struct
 */
L.LeafletTileEvent = function() {};
 /** @type {!HTMLElement} */
L.LeafletTileEvent.prototype.tile;
 /** @type {string} */
L.LeafletTileEvent.prototype.url;
/** @const */
L.LineUtil = {};

/**
 * Dramatically reduces the number of points in a polyline while retaining
 * its shape and returns a new array of simplified points. Used for a huge performance
 * boost when processing/displaying Leaflet polylines for each zoom level
 * and also reducing visual noise. tolerance affects the amount of simplification
 * (lesser value means higher quality but slower and with more points). Also
 * released as a separated micro-library Simplify.js.
 * @param {!Array<?>} points
 * @param {number} tolerance
 * @return {!Array<?>}
 */
L.LineUtil.simplify = function(points, tolerance) {};

/**
 * Returns the distance between point p and segment p1 to p2.
 * @param {?} p
 * @param {?} p1
 * @param {?} p2
 * @return {number}
 */
L.LineUtil.pointToSegmentDistance = function(p, p1, p2) {};

/**
 * Returns the closest point from a point p on a segment p1 to p2.
 * @param {?} p
 * @param {?} p1
 * @param {?} p2
 * @return {?}
 */
L.LineUtil.closestPointOnSegment = function(p, p1, p2) {};

/**
 * Clips the segment a to b by rectangular bounds. Used by Leaflet to only show
 * polyline points that are on the screen or near, increasing performance. Returns
 * either false or a length-2 array of clipped points.
 * @param {?} a
 * @param {?} b
 * @param {?} bounds
 * @return {(boolean|!Array<?>)}
 */
L.LineUtil.clipSegment = function(a, b, bounds) {};
/**
 * @record
 * @struct
 */
L.LocateOptions = function() {};
 /** @type {boolean} */
L.LocateOptions.prototype.watch;
 /** @type {boolean} */
L.LocateOptions.prototype.setView;
 /** @type {number} */
L.LocateOptions.prototype.maxZoom;
 /** @type {number} */
L.LocateOptions.prototype.timeout;
 /** @type {number} */
L.LocateOptions.prototype.maximumAge;
 /** @type {boolean} */
L.LocateOptions.prototype.enableHighAccuracy;

/**
 * Instantiates a map object given a div element and optionally an
 * object literal with map options described below.
 * Instantiates a map object given a div element id and optionally an
 * object literal with map options described below.
 * @param {!HTMLElement|string} id
 * @param {!L.Map.MapOptions=} options
 * @return {?}
 */
L.map = function(id, options) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.MapStatic = function() {};

/* TODO: ConstructSignature: L */

/* TODO: ConstructSignature: L */
 /** @type {!L.MapStatic} */
L.Map;
 /** @type {!L.IHandler} */
L.Map.prototype.dragging;
 /** @type {!L.IHandler} */
L.Map.prototype.touchZoom;
 /** @type {!L.IHandler} */
L.Map.prototype.doubleClickZoom;
 /** @type {!L.IHandler} */
L.Map.prototype.scrollWheelZoom;
 /** @type {!L.IHandler} */
L.Map.prototype.boxZoom;
 /** @type {!L.IHandler} */
L.Map.prototype.keyboard;
 /** @type {!L.IHandler} */
L.Map.prototype.tap;
 /** @type {!L.Control.Zoom} */
L.Map.prototype.zoomControl;
 /** @type {!L.Control.Attribution} */
L.Map.prototype.attributionControl;
 /** @type {!L.Map.MapOptions} */
L.Map.prototype.options;

/**
 * Sets the view of the map (geographical center and zoom) with the given
 * animation options.
 * @param {(?|!Array<number>|{lat: number, lng: number})} center
 * @param {number=} zoom
 * @param {!L.Map.ZoomPanOptions=} options
 * @return {?}
 */
L.Map.prototype.setView = function(center, zoom, options) {};

/**
 * Sets the zoom of the map.
 * @param {number} zoom
 * @param {!L.Map.ZoomPanOptions=} options
 * @return {?}
 */
L.Map.prototype.setZoom = function(zoom, options) {};

/**
 * Increases the zoom of the map by delta (1 by default).
 * @param {number=} delta
 * @param {!L.Map.ZoomPanOptions=} options
 * @return {?}
 */
L.Map.prototype.zoomIn = function(delta, options) {};

/**
 * Decreases the zoom of the map by delta (1 by default).
 * @param {number=} delta
 * @param {!L.Map.ZoomPanOptions=} options
 * @return {?}
 */
L.Map.prototype.zoomOut = function(delta, options) {};

/**
 * Zooms the map while keeping a specified point on the map stationary
 * (e.g. used internally for scroll zoom and double-click zoom).
 * @param {(?|!Array<number>|{lat: number, lng: number})} latlng
 * @param {number} zoom
 * @param {!L.Map.ZoomPanOptions=} options
 * @return {?}
 */
L.Map.prototype.setZoomAround = function(latlng, zoom, options) {};

/**
 * Sets a map view that contains the given geographical bounds with the maximum
 * zoom level possible.
 * @param {?} bounds
 * @param {!L.Map.FitBoundsOptions=} options
 * @return {?}
 */
L.Map.prototype.fitBounds = function(bounds, options) {};

/**
 * Sets a map view that mostly contains the whole world with the maximum zoom
 * level possible.
 * @param {!L.Map.FitBoundsOptions=} options
 * @return {?}
 */
L.Map.prototype.fitWorld = function(options) {};

/**
 * Pans the map to a given center. Makes an animated pan if new center is not more
 * than one screen away from the current one.
 * @param {(?|!Array<number>|{lat: number, lng: number})} latlng
 * @param {!L.PanOptions=} options
 * @return {?}
 */
L.Map.prototype.panTo = function(latlng, options) {};

/**
 * Pans the map to the closest view that would lie inside the given bounds (if
 * it's not already).
 * @param {?} bounds
 * @return {?}
 */
L.Map.prototype.panInsideBounds = function(bounds) {};

/**
 * Pans the map by a given number of pixels (animated).
 * @param {?} point
 * @param {!L.PanOptions=} options
 * @return {?}
 */
L.Map.prototype.panBy = function(point, options) {};

/**
 * Checks if the map container size changed and updates the map if so — call it
 * after you've changed the map size dynamically, also animating pan by default.
 * If options.pan is false, panning will not occur.
 * Checks if the map container size changed and updates the map if so — call it
 * after you've changed the map size dynamically, also animating pan by default.
 * @param {!L.Map.ZoomPanOptions|boolean} options_or_animate
 * @return {?}
 */
L.Map.prototype.invalidateSize = function(options_or_animate) {};

/**
 * Restricts the map view to the given bounds (see map maxBounds option),
 * passing the given animation options through to `setView`, if required.
 * @param {?} bounds
 * @param {!L.Map.ZoomPanOptions=} options
 * @return {?}
 */
L.Map.prototype.setMaxBounds = function(bounds, options) {};

/**
 * Tries to locate the user using Geolocation API, firing locationfound event
 * with location data on success or locationerror event on failure, and optionally
 * sets the map view to the user location with respect to detection accuracy
 * (or to the world view if geolocation failed). See Locate options for more
 * details.
 * @param {!L.LocateOptions=} options
 * @return {?}
 */
L.Map.prototype.locate = function(options) {};

/**
 * Stops watching location previously initiated by map.locate({watch: true})
 * and aborts resetting the map view if map.locate was called with {setView: true}.
 * @return {?}
 */
L.Map.prototype.stopLocate = function() {};

/**
 * Destroys the map and clears all related event listeners.
 * @return {?}
 */
L.Map.prototype.remove = function() {};

/**
 * Returns the geographical center of the map view.
 * @return {?}
 */
L.Map.prototype.getCenter = function() {};

/**
 * Returns the current zoom of the map view.
 * @return {number}
 */
L.Map.prototype.getZoom = function() {};

/**
 * Returns the minimum zoom level of the map.
 * @return {number}
 */
L.Map.prototype.getMinZoom = function() {};

/**
 * Returns the maximum zoom level of the map.
 * @return {number}
 */
L.Map.prototype.getMaxZoom = function() {};

/**
 * Returns the LatLngBounds of the current map view.
 * @return {?}
 */
L.Map.prototype.getBounds = function() {};

/**
 * Returns the maximum zoom level on which the given bounds fit to the map view
 * in its entirety. If inside (optional) is set to true, the method instead returns
 * the minimum zoom level on which the map view fits into the given bounds in its
 * entirety.
 * @param {?} bounds
 * @param {boolean=} inside
 * @return {number}
 */
L.Map.prototype.getBoundsZoom = function(bounds, inside) {};

/**
 * Returns the current size of the map container.
 * @return {?}
 */
L.Map.prototype.getSize = function() {};

/**
 * Returns the bounds of the current map view in projected pixel coordinates
 * (sometimes useful in layer and overlay implementations).
 * @return {?}
 */
L.Map.prototype.getPixelBounds = function() {};

/**
 * Returns the projected pixel coordinates of the top left point of the map layer
 * (useful in custom layer and overlay implementations).
 * @return {?}
 */
L.Map.prototype.getPixelOrigin = function() {};

/**
 * Adds the given layer to the map. If optional insertAtTheBottom is set to true,
 * the layer is inserted under all others (useful when switching base tile layers).
 * @param {!L.ILayer} layer
 * @param {boolean=} insertAtTheBottom
 * @return {?}
 */
L.Map.prototype.addLayer = function(layer, insertAtTheBottom) {};

/**
 * Removes the given layer from the map.
 * @param {!L.ILayer} layer
 * @return {?}
 */
L.Map.prototype.removeLayer = function(layer) {};

/**
 * Returns true if the given layer is currently added to the map.
 * @param {!L.ILayer} layer
 * @return {boolean}
 */
L.Map.prototype.hasLayer = function(layer) {};

/**
 * Opens the specified popup while closing the previously opened (to make sure
 * only one is opened at one time for usability).
 * Creates a popup with the specified options and opens it in the given point
 * on a map.
 * Creates a popup with the specified options and opens it in the given point
 * on a map.
 * @param {?|string|!HTMLElement} popup_or_html_or_el
 * @param {(?|!Array<number>|{lat: number, lng: number})=} latlng
 * @param {!L.PopupOptions=} options
 * @return {?}
 */
L.Map.prototype.openPopup = function(popup_or_html_or_el, latlng, options) {};

/**
 * Closes the popup previously opened with openPopup (or the given one).
 * @param {?=} popup
 * @return {?}
 */
L.Map.prototype.closePopup = function(popup) {};

/**
 * Adds the given control to the map.
 * @param {!L.IControl} control
 * @return {?}
 */
L.Map.prototype.addControl = function(control) {};

/**
 * Removes the given control from the map.
 * @param {!L.IControl} control
 * @return {?}
 */
L.Map.prototype.removeControl = function(control) {};

/**
 * Returns the map layer point that corresponds to the given geographical coordinates
 * (useful for placing overlays on the map).
 * @param {(?|!Array<number>|{lat: number, lng: number})} latlng
 * @return {?}
 */
L.Map.prototype.latLngToLayerPoint = function(latlng) {};

/**
 * Returns the geographical coordinates of a given map layer point.
 * @param {?} point
 * @return {?}
 */
L.Map.prototype.layerPointToLatLng = function(point) {};

/**
 * Converts the point relative to the map container to a point relative to the
 * map layer.
 * @param {?} point
 * @return {?}
 */
L.Map.prototype.containerPointToLayerPoint = function(point) {};

/**
 * Converts the point relative to the map layer to a point relative to the map
 * container.
 * @param {?} point
 * @return {?}
 */
L.Map.prototype.layerPointToContainerPoint = function(point) {};

/**
 * Returns the map container point that corresponds to the given geographical
 * coordinates.
 * @param {(?|!Array<number>|{lat: number, lng: number})} latlng
 * @return {?}
 */
L.Map.prototype.latLngToContainerPoint = function(latlng) {};

/**
 * Returns the geographical coordinates of a given map container point.
 * @param {?} point
 * @return {?}
 */
L.Map.prototype.containerPointToLatLng = function(point) {};

/**
 * Projects the given geographical coordinates to absolute pixel coordinates
 * for the given zoom level (current zoom level by default).
 * @param {(?|!Array<number>|{lat: number, lng: number})} latlng
 * @param {number=} zoom
 * @return {?}
 */
L.Map.prototype.project = function(latlng, zoom) {};

/**
 * Projects the given absolute pixel coordinates to geographical coordinates
 * for the given zoom level (current zoom level by default).
 * @param {?} point
 * @param {number=} zoom
 * @return {?}
 */
L.Map.prototype.unproject = function(point, zoom) {};

/**
 * Returns the pixel coordinates of a mouse click (relative to the top left corner
 * of the map) given its event object.
 * @param {!L.LeafletMouseEvent} event
 * @return {?}
 */
L.Map.prototype.mouseEventToContainerPoint = function(event) {};

/**
 * Returns the pixel coordinates of a mouse click relative to the map layer given
 * its event object.
 * @param {!L.LeafletMouseEvent} event
 * @return {?}
 */
L.Map.prototype.mouseEventToLayerPoint = function(event) {};

/**
 * Returns the geographical coordinates of the point the mouse clicked on given
 * the click's event object.
 * @param {!L.LeafletMouseEvent} event
 * @return {?}
 */
L.Map.prototype.mouseEventToLatLng = function(event) {};

/**
 * Returns the container element of the map.
 * @return {!HTMLElement}
 */
L.Map.prototype.getContainer = function() {};

/**
 * Returns an object with different map panes (to render overlays in).
 * @return {!L.MapPanes}
 */
L.Map.prototype.getPanes = function() {};

/**
 * Runs the given callback when the map gets initialized with a place and zoom,
 * or immediately if it happened already, optionally passing a function context.
 * @param {function(?): void} fn
 * @param {?=} context
 * @return {?}
 */
L.Map.prototype.whenReady = function(fn, context) {};

/**
 * Iterates over the layers of the map, optionally specifying context
 * of the iterator function.
 * @param {function(!L.ILayer): void} fn
 * @param {?=} context
 * @return {?}
 */
L.Map.prototype.eachLayer = function(fn, context) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Map.prototype.addEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {?}
 */
L.Map.prototype.addOneTimeEventListener = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Map.prototype.removeEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @return {boolean}
 */
L.Map.prototype.hasEventListeners = function(type) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {?}
 */
L.Map.prototype.fireEvent = function(type, data) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Map.prototype.on = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {?}
 */
L.Map.prototype.once = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Map.prototype.off = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {?}
 */
L.Map.prototype.fire = function(type, data) {};

/**
 * @return {?}
 */
L.Map.prototype.clearAllEventListeners = function() {};
/**
 * @record
 * @struct
 */
L.Map.MapOptions = function() {};
 /** @type {?} */
L.Map.MapOptions.prototype.center;
 /** @type {number} */
L.Map.MapOptions.prototype.zoom;
 /** @type {!Array<!L.ILayer>} */
L.Map.MapOptions.prototype.layers;
 /** @type {number} */
L.Map.MapOptions.prototype.minZoom;
 /** @type {number} */
L.Map.MapOptions.prototype.maxZoom;
 /** @type {?} */
L.Map.MapOptions.prototype.maxBounds;
 /** @type {!L.ICRS} */
L.Map.MapOptions.prototype.crs;
 /** @type {boolean} */
L.Map.MapOptions.prototype.dragging;
 /** @type {boolean} */
L.Map.MapOptions.prototype.touchZoom;
 /** @type {boolean} */
L.Map.MapOptions.prototype.scrollWheelZoom;
 /** @type {boolean} */
L.Map.MapOptions.prototype.doubleClickZoom;
 /** @type {boolean} */
L.Map.MapOptions.prototype.boxZoom;
 /** @type {boolean} */
L.Map.MapOptions.prototype.tap;
 /** @type {number} */
L.Map.MapOptions.prototype.tapTolerance;
 /** @type {boolean} */
L.Map.MapOptions.prototype.trackResize;
 /** @type {boolean} */
L.Map.MapOptions.prototype.worldCopyJump;
 /** @type {boolean} */
L.Map.MapOptions.prototype.closePopupOnClick;
 /** @type {boolean} */
L.Map.MapOptions.prototype.keyboard;
 /** @type {number} */
L.Map.MapOptions.prototype.keyboardPanOffset;
 /** @type {number} */
L.Map.MapOptions.prototype.keyboardZoomOffset;
 /** @type {boolean} */
L.Map.MapOptions.prototype.inertia;
 /** @type {number} */
L.Map.MapOptions.prototype.inertiaDeceleration;
 /** @type {number} */
L.Map.MapOptions.prototype.inertiaMaxSpeed;
 /** @type {number} */
L.Map.MapOptions.prototype.inertiaThreshold;
 /** @type {boolean} */
L.Map.MapOptions.prototype.zoomControl;
 /** @type {boolean} */
L.Map.MapOptions.prototype.attributionControl;
 /** @type {boolean} */
L.Map.MapOptions.prototype.fadeAnimation;
 /** @type {boolean} */
L.Map.MapOptions.prototype.zoomAnimation;
 /** @type {number} */
L.Map.MapOptions.prototype.zoomAnimationThreshold;
 /** @type {boolean} */
L.Map.MapOptions.prototype.markerZoomAnimation;
 /** @type {boolean} */
L.Map.MapOptions.prototype.bounceAtZoomLimits;
/**
 * @record
 * @struct
 */
L.Map.ZoomOptions = function() {};
 /** @type {boolean} */
L.Map.ZoomOptions.prototype.animate;
/**
 * @record
 * @struct
 */
L.Map.ZoomPanOptions = function() {};
 /** @type {boolean} */
L.Map.ZoomPanOptions.prototype.reset;
 /** @type {!L.PanOptions} */
L.Map.ZoomPanOptions.prototype.pan;
 /** @type {!L.Map.ZoomOptions} */
L.Map.ZoomPanOptions.prototype.zoom;
 /** @type {boolean} */
L.Map.ZoomPanOptions.prototype.animate;
 /** @type {boolean} */
L.Map.ZoomPanOptions.prototype.debounceMoveend;
 /** @type {number} */
L.Map.ZoomPanOptions.prototype.duration;
 /** @type {number} */
L.Map.ZoomPanOptions.prototype.easeLinearity;
 /** @type {boolean} */
L.Map.ZoomPanOptions.prototype.noMoveStart;
/**
 * @extends {L.Map.ZoomPanOptions}
 * @record
 * @struct
 */
L.Map.FitBoundsOptions = function() {};
 /** @type {?} */
L.Map.FitBoundsOptions.prototype.paddingTopLeft;
 /** @type {?} */
L.Map.FitBoundsOptions.prototype.paddingBottomRight;
 /** @type {?} */
L.Map.FitBoundsOptions.prototype.padding;
 /** @type {number} */
L.Map.FitBoundsOptions.prototype.maxZoom;
/**
 * @record
 * @struct
 */
L.MapPanes = function() {};
 /** @type {!HTMLElement} */
L.MapPanes.prototype.mapPane;
 /** @type {!HTMLElement} */
L.MapPanes.prototype.tilePane;
 /** @type {!HTMLElement} */
L.MapPanes.prototype.objectsPane;
 /** @type {!HTMLElement} */
L.MapPanes.prototype.shadowPane;
 /** @type {!HTMLElement} */
L.MapPanes.prototype.overlayPane;
 /** @type {!HTMLElement} */
L.MapPanes.prototype.markerPane;
 /** @type {!HTMLElement} */
L.MapPanes.prototype.popupPane;

/**
 * Instantiates a Marker object given a geographical point and optionally
 * an options object.
 * @param {(?|!Array<number>|{lat: number, lng: number})} latlng
 * @param {!L.MarkerOptions=} options
 * @return {?}
 */
L.marker = function(latlng, options) {};
 /** @type {function(new: (?), (?|!Array<number>|{lat: number, lng: number}), !L.MarkerOptions): ?} */
L.Marker;
 /** @type {!L.IHandler} */
L.Marker.prototype.dragging;

/**
 * Adds the marker to the map.
 * @param {?} map
 * @return {?}
 */
L.Marker.prototype.addTo = function(map) {};

/**
 * Returns the current geographical position of the marker.
 * @return {?}
 */
L.Marker.prototype.getLatLng = function() {};

/**
 * Changes the marker position to the given point.
 * @param {(?|!Array<number>|{lat: number, lng: number})} latlng
 * @return {?}
 */
L.Marker.prototype.setLatLng = function(latlng) {};

/**
 * Changes the marker icon.
 * @param {?} icon
 * @return {?}
 */
L.Marker.prototype.setIcon = function(icon) {};

/**
 * Changes the zIndex offset of the marker.
 * @param {number} offset
 * @return {?}
 */
L.Marker.prototype.setZIndexOffset = function(offset) {};

/**
 * Changes the opacity of the marker.
 * @param {number} opacity
 * @return {?}
 */
L.Marker.prototype.setOpacity = function(opacity) {};

/**
 * Updates the marker position, useful if coordinates of its latLng object
 * were changed directly.
 * @return {?}
 */
L.Marker.prototype.update = function() {};

/**
 * Binds a popup with a particular HTML content to a click on this marker. You
 * can also open the bound popup with the Marker openPopup method.
 * Binds a popup with a particular HTML content to a click on this marker. You
 * can also open the bound popup with the Marker openPopup method.
 * Binds a popup with a particular HTML content to a click on this marker. You
 * can also open the bound popup with the Marker openPopup method.
 * @param {string|!HTMLElement|?} html_or_el_or_popup
 * @param {!L.PopupOptions=} options
 * @return {?}
 */
L.Marker.prototype.bindPopup = function(html_or_el_or_popup, options) {};

/**
 * Unbinds the popup previously bound to the marker with bindPopup.
 * @return {?}
 */
L.Marker.prototype.unbindPopup = function() {};

/**
 * Opens the popup previously bound by the bindPopup method.
 * @return {?}
 */
L.Marker.prototype.openPopup = function() {};

/**
 * Returns the popup previously bound by the bindPopup method.
 * @return {?}
 */
L.Marker.prototype.getPopup = function() {};

/**
 * Closes the bound popup of the marker if it's opened.
 * @return {?}
 */
L.Marker.prototype.closePopup = function() {};

/**
 * Toggles the popup previously bound by the bindPopup method.
 * @return {?}
 */
L.Marker.prototype.togglePopup = function() {};

/**
 * Sets an HTML content of the popup of this marker.
 * Sets an HTML content of the popup of this marker.
 * @param {string|!HTMLElement} html_or_el
 * @param {!L.PopupOptions=} options
 * @return {?}
 */
L.Marker.prototype.setPopupContent = function(html_or_el, options) {};

/**
 * Returns a GeoJSON representation of the marker (GeoJSON Point Feature).
 * @return {?}
 */
L.Marker.prototype.toGeoJSON = function() {};

/**
 * Should contain code that creates DOM elements for the overlay, adds them
 * to map panes where they should belong and puts listeners on relevant map events.
 * Called on map.addLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.Marker.prototype.onAdd = function(map) {};

/**
 * Should contain all clean up code that removes the overlay's elements from
 * the DOM and removes listeners previously added in onAdd. Called on map.removeLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.Marker.prototype.onRemove = function(map) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Marker.prototype.addEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {?}
 */
L.Marker.prototype.addOneTimeEventListener = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Marker.prototype.removeEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @return {boolean}
 */
L.Marker.prototype.hasEventListeners = function(type) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {?}
 */
L.Marker.prototype.fireEvent = function(type, data) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Marker.prototype.on = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {?}
 */
L.Marker.prototype.once = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Marker.prototype.off = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {?}
 */
L.Marker.prototype.fire = function(type, data) {};

/**
 * @return {?}
 */
L.Marker.prototype.clearAllEventListeners = function() {};
/**
 * @record
 * @struct
 */
L.MarkerOptions = function() {};
 /** @type {?} */
L.MarkerOptions.prototype.icon;
 /** @type {boolean} */
L.MarkerOptions.prototype.clickable;
 /** @type {boolean} */
L.MarkerOptions.prototype.draggable;
 /** @type {boolean} */
L.MarkerOptions.prototype.keyboard;
 /** @type {string} */
L.MarkerOptions.prototype.title;
 /** @type {string} */
L.MarkerOptions.prototype.alt;
 /** @type {number} */
L.MarkerOptions.prototype.zIndexOffset;
 /** @type {number} */
L.MarkerOptions.prototype.opacity;
 /** @type {boolean} */
L.MarkerOptions.prototype.riseOnHover;
 /** @type {number} */
L.MarkerOptions.prototype.riseOffset;

/**
 * Instantiates a multi-polyline object given an array of latlngs arrays (one
 * for each individual polygon) and optionally an options object (the same
 * as for MultiPolyline).
 * @param {!Array<!Array<?>>} latlngs
 * @param {!L.PolylineOptions=} options
 * @return {?}
 */
L.multiPolygon = function(latlngs, options) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.MultiPolygonStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.MultiPolygonStatic} */
L.MultiPolygon;

/**
 * Replace all polygons and their paths with the given array of arrays
 * of geographical points.
 * @param {!Array<!Array<?>>} latlngs
 * @return {?}
 */
L.MultiPolygon.prototype.setLatLngs = function(latlngs) {};

/**
 * Returns an array of arrays of geographical points in each polygon.
 * @return {!Array<!Array<?>>}
 */
L.MultiPolygon.prototype.getLatLngs = function() {};

/**
 * Opens the popup previously bound by bindPopup.
 * @return {?}
 */
L.MultiPolygon.prototype.openPopup = function() {};

/**
 * Returns a GeoJSON representation of the multipolygon (GeoJSON MultiPolygon Feature).
 * @return {?}
 */
L.MultiPolygon.prototype.toGeoJSON = function() {};

/**
 * Instantiates a multi-polyline object given an array of arrays of geographical
 * points (one for each individual polyline) and optionally an options object.
 * @param {!Array<!Array<?>>} latlngs
 * @param {!L.PolylineOptions=} options
 * @return {?}
 */
L.multiPolyline = function(latlngs, options) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.MultiPolylineStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.MultiPolylineStatic} */
L.MultiPolyline;

/**
 * Replace all polygons and their paths with the given array of arrays
 * of geographical points.
 * @param {!Array<!Array<?>>} latlngs
 * @return {?}
 */
L.MultiPolyline.prototype.setLatLngs = function(latlngs) {};

/**
 * Returns an array of arrays of geographical points in each polygon.
 * @return {!Array<!Array<?>>}
 */
L.MultiPolyline.prototype.getLatLngs = function() {};

/**
 * Opens the popup previously bound by bindPopup.
 * @return {?}
 */
L.MultiPolyline.prototype.openPopup = function() {};

/**
 * Returns a GeoJSON representation of the multipolyline (GeoJSON MultiLineString Feature).
 * @return {?}
 */
L.MultiPolyline.prototype.toGeoJSON = function() {};
/**
 * @record
 * @struct
 */
L.PanOptions = function() {};
 /** @type {boolean} */
L.PanOptions.prototype.animate;
 /** @type {number} */
L.PanOptions.prototype.duration;
 /** @type {number} */
L.PanOptions.prototype.easeLinearity;
 /** @type {boolean} */
L.PanOptions.prototype.noMoveStart;
/**
 * @extends {L.ILayer}
 * @extends {L.IEventPowered}
 * @record
 * @struct
 */
L.Path = function() {};

/**
 * Adds the layer to the map.
 * @param {?} map
 * @return {?}
 */
L.Path.prototype.addTo = function(map) {};

/**
 * Binds a popup with a particular HTML content to a click on this path.
 * Binds a popup with a particular HTML content to a click on this path.
 * Binds a popup with a particular HTML content to a click on this path.
 * @param {string|!HTMLElement|?} html_or_el_or_popup
 * @param {!L.PopupOptions=} options
 * @return {?}
 */
L.Path.prototype.bindPopup = function(html_or_el_or_popup, options) {};

/**
 * Unbinds the popup previously bound to the path with bindPopup.
 * @return {?}
 */
L.Path.prototype.unbindPopup = function() {};

/**
 * Opens the popup previously bound by the bindPopup method in the given point,
 * or in one of the path's points if not specified.
 * @param {(?|!Array<number>|{lat: number, lng: number})=} latlng
 * @return {?}
 */
L.Path.prototype.openPopup = function(latlng) {};

/**
 * Closes the path's bound popup if it is opened.
 * @return {?}
 */
L.Path.prototype.closePopup = function() {};

/**
 * Changes the appearance of a Path based on the options in the Path options object.
 * @param {!L.PathOptions} object
 * @return {?}
 */
L.Path.prototype.setStyle = function(object) {};

/**
 * Returns the LatLngBounds of the path.
 * @return {?}
 */
L.Path.prototype.getBounds = function() {};

/**
 * Brings the layer to the top of all path layers.
 * @return {?}
 */
L.Path.prototype.bringToFront = function() {};

/**
 * Brings the layer to the bottom of all path layers.
 * @return {?}
 */
L.Path.prototype.bringToBack = function() {};

/**
 * Redraws the layer. Sometimes useful after you changed the coordinates that
 * the path uses.
 * @return {?}
 */
L.Path.prototype.redraw = function() {};

/**
 * Should contain code that creates DOM elements for the overlay, adds them
 * to map panes where they should belong and puts listeners on relevant map events.
 * Called on map.addLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.Path.prototype.onAdd = function(map) {};

/**
 * Should contain all clean up code that removes the overlay's elements from
 * the DOM and removes listeners previously added in onAdd. Called on map.removeLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.Path.prototype.onRemove = function(map) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Path.prototype.addEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {?}
 */
L.Path.prototype.addOneTimeEventListener = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Path.prototype.removeEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @return {boolean}
 */
L.Path.prototype.hasEventListeners = function(type) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {?}
 */
L.Path.prototype.fireEvent = function(type, data) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Path.prototype.on = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {?}
 */
L.Path.prototype.once = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.Path.prototype.off = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {?}
 */
L.Path.prototype.fire = function(type, data) {};

/**
 * @return {?}
 */
L.Path.prototype.clearAllEventListeners = function() {};
 /** @type {boolean} */
L.Path.SVG;
 /** @type {boolean} */
L.Path.VML;
 /** @type {boolean} */
L.Path.CANVAS;
 /** @type {number} */
L.Path.CLIP_PADDING;
/**
 * @record
 * @struct
 */
L.PathOptions = function() {};
 /** @type {boolean} */
L.PathOptions.prototype.stroke;
 /** @type {string} */
L.PathOptions.prototype.color;
 /** @type {number} */
L.PathOptions.prototype.weight;
 /** @type {number} */
L.PathOptions.prototype.opacity;
 /** @type {boolean} */
L.PathOptions.prototype.fill;
 /** @type {string} */
L.PathOptions.prototype.fillColor;
 /** @type {number} */
L.PathOptions.prototype.fillOpacity;
 /** @type {string} */
L.PathOptions.prototype.dashArray;
 /** @type {string} */
L.PathOptions.prototype.lineCap;
 /** @type {string} */
L.PathOptions.prototype.lineJoin;
 /** @type {boolean} */
L.PathOptions.prototype.clickable;
 /** @type {string} */
L.PathOptions.prototype.pointerEvents;
 /** @type {string} */
L.PathOptions.prototype.className;
 /** @type {number} */
L.PathOptions.prototype.radius;

/**
 * Creates a Point object with the given x and y coordinates. If optional round
 * is set to true, rounds the x and y values.
 * @param {number} x
 * @param {number} y
 * @param {boolean=} round
 * @return {?}
 */
L.point = function(x, y, round) {};
/**
 * @record
 * @struct
 */
L.PointStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.PointStatic} */
L.Point;
 /** @type {number} */
L.Point.prototype.x;
 /** @type {number} */
L.Point.prototype.y;

/**
 * Returns the result of addition of the current and the given points.
 * @param {?} otherPoint
 * @return {?}
 */
L.Point.prototype.add = function(otherPoint) {};

/**
 * Returns the result of subtraction of the given point from the current.
 * @param {?} otherPoint
 * @return {?}
 */
L.Point.prototype.subtract = function(otherPoint) {};

/**
 * Returns the result of multiplication of the current point by the given number.
 * @param {number} number
 * @return {?}
 */
L.Point.prototype.multiplyBy = function(number) {};

/**
 * Returns the result of division of the current point by the given number. If
 * optional round is set to true, returns a rounded result.
 * @param {number} number
 * @param {boolean=} round
 * @return {?}
 */
L.Point.prototype.divideBy = function(number, round) {};

/**
 * Returns the distance between the current and the given points.
 * @param {?} otherPoint
 * @return {number}
 */
L.Point.prototype.distanceTo = function(otherPoint) {};

/**
 * Returns a copy of the current point.
 * @return {?}
 */
L.Point.prototype.clone = function() {};

/**
 * Returns a copy of the current point with rounded coordinates.
 * @return {?}
 */
L.Point.prototype.round = function() {};

/**
 * Returns true if the given point has the same coordinates.
 * @param {?} otherPoint
 * @return {boolean}
 */
L.Point.prototype.equals = function(otherPoint) {};

/**
 * Returns a string representation of the point for debugging purposes.
 * @return {string}
 */
L.Point.prototype.toString = function() {};

/**
 * Instantiates a polygon object given an array of geographical points and
 * optionally an options object (the same as for Polyline). You can also create
 * a polygon with holes by passing an array of arrays of latlngs, with the first
 * latlngs array representing the exterior ring while the remaining represent
 * the holes inside.
 * @param {(?|!Array<(?|!Array<number>|{lat: number, lng: number})>)} latlngs
 * @param {!L.PolylineOptions=} options
 * @return {?}
 */
L.polygon = function(latlngs, options) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.PolygonStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.PolygonStatic} */
L.Polygon;

/**
 * Instantiates a polyline object given an array of geographical points and
 * optionally an options object.
 * @param {(?|!Array<(?|!Array<number>|{lat: number, lng: number})>)} latlngs
 * @param {!L.PolylineOptions=} options
 * @return {?}
 */
L.polyline = function(latlngs, options) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.PolylineStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.PolylineStatic} */
L.Polyline;

/**
 * Adds a given point to the polyline.
 * @param {(?|!Array<number>|{lat: number, lng: number})} latlng
 * @return {?}
 */
L.Polyline.prototype.addLatLng = function(latlng) {};

/**
 * Replaces all the points in the polyline with the given array of geographical
 * points.
 * @param {(?|!Array<(?|!Array<number>|{lat: number, lng: number})>)} latlngs
 * @return {?}
 */
L.Polyline.prototype.setLatLngs = function(latlngs) {};

/**
 * Returns an array of the points in the path.
 * @return {!Array<?>}
 */
L.Polyline.prototype.getLatLngs = function() {};

/**
 * Allows adding, removing or replacing points in the polyline. Syntax is the
 * same as in Array#splice. Returns the array of removed points (if any).
 * @param {number} index
 * @param {number} pointsToRemove
 * @param {...?} latlngs
 * @return {!Array<?>}
 */
L.Polyline.prototype.spliceLatLngs = function(index, pointsToRemove, latlngs) {};

/**
 * Returns the LatLngBounds of the polyline.
 * @return {?}
 */
L.Polyline.prototype.getBounds = function() {};

/**
 * Returns a GeoJSON representation of the polyline (GeoJSON LineString Feature).
 * @return {?}
 */
L.Polyline.prototype.toGeoJSON = function() {};
/**
 * @extends {L.PathOptions}
 * @record
 * @struct
 */
L.PolylineOptions = function() {};
 /** @type {number} */
L.PolylineOptions.prototype.smoothFactor;
 /** @type {boolean} */
L.PolylineOptions.prototype.noClip;
/** @const */
L.PolyUtil = {};

/**
 * Clips the polygon geometry defined by the given points by rectangular bounds.
 * Used by Leaflet to only show polygon points that are on the screen or near,
 * increasing performance. Note that polygon points needs different algorithm
 * for clipping than polyline, so there's a seperate method for it.
 * @param {!Array<?>} points
 * @param {?} bounds
 * @return {!Array<?>}
 */
L.PolyUtil.clipPolygon = function(points, bounds) {};

/**
 * Instantiates a Popup object given an optional options object that describes
 * its appearance and location and an optional object that is used to tag the
 * popup with a reference to the source object to which it refers.
 * @param {!L.PopupOptions=} options
 * @param {?=} source
 * @return {?}
 */
L.popup = function(options, source) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.PopupStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.PopupStatic} */
L.Popup;

/**
 * Adds the popup to the map.
 * @param {?} map
 * @return {?}
 */
L.Popup.prototype.addTo = function(map) {};

/**
 * Adds the popup to the map and closes the previous one. The same as map.openPopup(popup).
 * @param {?} map
 * @return {?}
 */
L.Popup.prototype.openOn = function(map) {};

/**
 * Sets the geographical point where the popup will open.
 * @param {(?|!Array<number>|{lat: number, lng: number})} latlng
 * @return {?}
 */
L.Popup.prototype.setLatLng = function(latlng) {};

/**
 * Returns the geographical point of popup.
 * @return {?}
 */
L.Popup.prototype.getLatLng = function() {};

/**
 * Sets the HTML content of the popup.
 * Sets the HTML content of the popup.
 * @param {string|!HTMLElement} html_or_el
 * @return {?}
 */
L.Popup.prototype.setContent = function(html_or_el) {};

/**
 * Returns the content of the popup.
 * @return {!HTMLElement}
 */
L.Popup.prototype.getContent = function() {};

/**
 * Should contain code that creates DOM elements for the overlay, adds them
 * to map panes where they should belong and puts listeners on relevant map events.
 * Called on map.addLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.Popup.prototype.onAdd = function(map) {};

/**
 * Should contain all clean up code that removes the overlay's elements from
 * the DOM and removes listeners previously added in onAdd. Called on map.removeLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.Popup.prototype.onRemove = function(map) {};

/**
 * Updates the popup content, layout and position. Useful for updating the popup after
 * something inside changed, e.g. image loaded.
 * @return {?}
 */
L.Popup.prototype.update = function() {};
/**
 * @record
 * @struct
 */
L.PopupOptions = function() {};
 /** @type {number} */
L.PopupOptions.prototype.maxWidth;
 /** @type {number} */
L.PopupOptions.prototype.minWidth;
 /** @type {number} */
L.PopupOptions.prototype.maxHeight;
 /** @type {boolean} */
L.PopupOptions.prototype.autoPan;
 /** @type {boolean} */
L.PopupOptions.prototype.keepInView;
 /** @type {boolean} */
L.PopupOptions.prototype.closeButton;
 /** @type {?} */
L.PopupOptions.prototype.offset;
 /** @type {?} */
L.PopupOptions.prototype.autoPanPaddingTopLeft;
 /** @type {?} */
L.PopupOptions.prototype.autoPanPaddingBottomRight;
 /** @type {?} */
L.PopupOptions.prototype.autoPanPadding;
 /** @type {boolean} */
L.PopupOptions.prototype.zoomAnimation;
 /** @type {boolean} */
L.PopupOptions.prototype.closeOnClick;
 /** @type {string} */
L.PopupOptions.prototype.className;
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.PosAnimationStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.PosAnimationStatic} */
L.PosAnimation;

/**
 * Run an animation of a given element to a new position, optionally setting
 * duration in seconds (0.25 by default) and easing linearity factor (3rd argument
 * of the cubic bezier curve, 0.5 by default)
 * @param {!HTMLElement} element
 * @param {?} newPos
 * @param {number=} duration
 * @param {number=} easeLinearity
 * @return {?}
 */
L.PosAnimation.prototype.run = function(element, newPos, duration, easeLinearity) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.PosAnimation.prototype.addEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {?}
 */
L.PosAnimation.prototype.addOneTimeEventListener = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.PosAnimation.prototype.removeEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @return {boolean}
 */
L.PosAnimation.prototype.hasEventListeners = function(type) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {?}
 */
L.PosAnimation.prototype.fireEvent = function(type, data) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.PosAnimation.prototype.on = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {?}
 */
L.PosAnimation.prototype.once = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.PosAnimation.prototype.off = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {?}
 */
L.PosAnimation.prototype.fire = function(type, data) {};

/**
 * @return {?}
 */
L.PosAnimation.prototype.clearAllEventListeners = function() {};
/** @const */
L.Projection = {};
 /** @type {!L.IProjection} */
L.Projection.SphericalMercator;
 /** @type {!L.IProjection} */
L.Projection.Mercator;
 /** @type {!L.IProjection} */
L.Projection.LonLat;

/**
 * Instantiates a rectangle object with the given geographical bounds and
 * optionally an options object.
 * @param {?} bounds
 * @param {!L.PathOptions=} options
 * @return {?}
 */
L.rectangle = function(bounds, options) {};
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.RectangleStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.RectangleStatic} */
L.Rectangle;

/**
 * Redraws the rectangle with the passed bounds.
 * @param {?} bounds
 * @return {?}
 */
L.Rectangle.prototype.setBounds = function(bounds) {};
/**
 * @record
 * @struct
 */
L.ScaleOptions = function() {};
 /** @type {string} */
L.ScaleOptions.prototype.position;
 /** @type {number} */
L.ScaleOptions.prototype.maxWidth;
 /** @type {boolean} */
L.ScaleOptions.prototype.metric;
 /** @type {boolean} */
L.ScaleOptions.prototype.imperial;
 /** @type {boolean} */
L.ScaleOptions.prototype.updateWhenIdle;
/**
 * @extends {L.ClassStatic}
 * @record
 * @struct
 */
L.TileLayerStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {function(new: (!L.TileLayer.WMS), string, !L.WMSOptions): ?} */
L.TileLayerStatic.prototype.WMS;
 /** @type {function(new: (!L.TileLayer.Canvas), !L.TileLayerOptions): ?} */
L.TileLayerStatic.prototype.Canvas;
 /** @type {!L.TileLayerStatic} */
L.TileLayer;

/**
 * Adds the layer to the map.
 * @param {?} map
 * @return {?}
 */
L.TileLayer.prototype.addTo = function(map) {};

/**
 * Brings the tile layer to the top of all tile layers.
 * @return {?}
 */
L.TileLayer.prototype.bringToFront = function() {};

/**
 * Brings the tile layer to the bottom of all tile layers.
 * @return {?}
 */
L.TileLayer.prototype.bringToBack = function() {};

/**
 * Changes the opacity of the tile layer.
 * @param {number} opacity
 * @return {?}
 */
L.TileLayer.prototype.setOpacity = function(opacity) {};

/**
 * Sets the zIndex of the tile layer.
 * @param {number} zIndex
 * @return {?}
 */
L.TileLayer.prototype.setZIndex = function(zIndex) {};

/**
 * Causes the layer to clear all the tiles and request them again.
 * @return {?}
 */
L.TileLayer.prototype.redraw = function() {};

/**
 * Updates the layer's URL template and redraws it.
 * @param {string} urlTemplate
 * @return {?}
 */
L.TileLayer.prototype.setUrl = function(urlTemplate) {};

/**
 * Returns the HTML element that contains the tiles for this layer.
 * @return {!HTMLElement}
 */
L.TileLayer.prototype.getContainer = function() {};

/**
 * Should contain code that creates DOM elements for the overlay, adds them
 * to map panes where they should belong and puts listeners on relevant map events.
 * Called on map.addLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.TileLayer.prototype.onAdd = function(map) {};

/**
 * Should contain all clean up code that removes the overlay's elements from
 * the DOM and removes listeners previously added in onAdd. Called on map.removeLayer(layer).
 * @param {?} map
 * @return {void}
 */
L.TileLayer.prototype.onRemove = function(map) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.TileLayer.prototype.addEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {?}
 */
L.TileLayer.prototype.addOneTimeEventListener = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.TileLayer.prototype.removeEventListener = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @return {boolean}
 */
L.TileLayer.prototype.hasEventListeners = function(type) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {?}
 */
L.TileLayer.prototype.fireEvent = function(type, data) {};

/**
 * @param {string|?} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.TileLayer.prototype.on = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {function(!L.LeafletEvent): void} fn
 * @param {?=} context
 * @return {?}
 */
L.TileLayer.prototype.once = function(type, fn, context) {};

/**
 * @param {string|?=} type_or_eventMap
 * @param {function(!L.LeafletEvent): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.TileLayer.prototype.off = function(type_or_eventMap, fn_or_context, context) {};

/**
 * @param {string} type
 * @param {?=} data
 * @return {?}
 */
L.TileLayer.prototype.fire = function(type, data) {};

/**
 * @return {?}
 */
L.TileLayer.prototype.clearAllEventListeners = function() {};
/**
 * @record
 * @struct
 */
L.TileLayer.WMS = function() {};

/**
 * Merges an object with the new parameters and re-requests tiles on the current
 * screen (unless noRedraw was set to true).
 * @param {!L.TileLayer.WMS} params
 * @param {boolean=} noRedraw
 * @return {!L.TileLayer.WMS}
 */
L.TileLayer.WMS.prototype.setParams = function(params, noRedraw) {};
/**
 * @record
 * @struct
 */
L.TileLayer.Canvas = function() {};

/**
 * You need to define this method after creating the instance to draw tiles;
 * canvas is the actual canvas tile on which you can draw, tilePoint represents
 * the tile numbers, and zoom is the current zoom.
 * @param {!HTMLCanvasElement} canvas
 * @param {?} tilePoint
 * @param {number} zoom
 * @return {!L.TileLayer.Canvas}
 */
L.TileLayer.Canvas.prototype.drawTile = function(canvas, tilePoint, zoom) {};

/**
 * Calling redraw will cause the drawTile method to be called for all tiles.
 * May be used for updating dynamic content drawn on the Canvas
 * @return {!L.TileLayer.Canvas}
 */
L.TileLayer.Canvas.prototype.redraw = function() {};
/**
 * @record
 * @struct
 */
L.TileLayerFactory = function() {};

/* TODO: CallSignature: L */

/**
 * Instantiates a WMS tile layer object given a base URL of the WMS service and
 * a WMS parameters/options object.
 * @param {string} baseUrl
 * @param {!L.WMSOptions} options
 * @return {!L.TileLayer.WMS}
 */
L.TileLayerFactory.prototype.wms = function(baseUrl, options) {};

/**
 * Instantiates a Canvas tile layer object given an options object (optionally).
 * @param {!L.TileLayerOptions=} options
 * @return {!L.TileLayer.Canvas}
 */
L.TileLayerFactory.prototype.canvas = function(options) {};
 /** @type {!L.TileLayerFactory} */
L.tileLayer;
/**
 * @record
 * @struct
 */
L.TileLayerOptions = function() {};
 /** @type {number} */
L.TileLayerOptions.prototype.minZoom;
 /** @type {number} */
L.TileLayerOptions.prototype.maxZoom;
 /** @type {number} */
L.TileLayerOptions.prototype.maxNativeZoom;
 /** @type {number} */
L.TileLayerOptions.prototype.tileSize;
 /** @type {(string|!Array<string>)} */
L.TileLayerOptions.prototype.subdomains;
 /** @type {string} */
L.TileLayerOptions.prototype.errorTileUrl;
 /** @type {string} */
L.TileLayerOptions.prototype.attribution;
 /** @type {boolean} */
L.TileLayerOptions.prototype.tms;
 /** @type {boolean} */
L.TileLayerOptions.prototype.continuousWorld;
 /** @type {boolean} */
L.TileLayerOptions.prototype.noWrap;
 /** @type {number} */
L.TileLayerOptions.prototype.zoomOffset;
 /** @type {boolean} */
L.TileLayerOptions.prototype.zoomReverse;
 /** @type {number} */
L.TileLayerOptions.prototype.opacity;
 /** @type {number} */
L.TileLayerOptions.prototype.zIndex;
 /** @type {boolean} */
L.TileLayerOptions.prototype.unloadInvisibleTiles;
 /** @type {boolean} */
L.TileLayerOptions.prototype.updateWhenIdle;
 /** @type {boolean} */
L.TileLayerOptions.prototype.detectRetina;
 /** @type {boolean} */
L.TileLayerOptions.prototype.reuseTiles;
 /** @type {?} */
L.TileLayerOptions.prototype.bounds;

/* TODO: IndexSignature: L */
/**
 * @record
 * @struct
 */
L.TransformationStatic = function() {};

/* TODO: ConstructSignature: L */
 /** @type {!L.TransformationStatic} */
L.Transformation;

/**
 * Returns a transformed point, optionally multiplied by the given scale.
 * Only accepts real L.Point instances, not arrays.
 * @param {?} point
 * @param {number=} scale
 * @return {?}
 */
L.Transformation.prototype.transform = function(point, scale) {};

/**
 * Returns the reverse transformation of the given point, optionally divided
 * by the given scale. Only accepts real L.Point instances, not arrays.
 * @param {?} point
 * @param {number=} scale
 * @return {?}
 */
L.Transformation.prototype.untransform = function(point, scale) {};
/** @const */
L.Util = {};

/**
 * Merges the properties of the src object (or multiple objects) into dest object
 * and returns the latter. Has an L.extend shortcut.
 * @param {?} dest
 * @param {...?} sources
 * @return {?}
 */
L.Util.extend = function(dest, sources) {};

/**
 * Returns a function which executes function fn with the given scope obj (so
 * that this keyword refers to obj inside the function code). Has an L.bind shortcut.
 * @template T
 * @param {T} fn
 * @param {?} obj
 * @return {T}
 */
L.Util.bind = function(fn, obj) {};

/**
 * Applies a unique key to the object and returns that key. Has an L.stamp shortcut.
 * @param {?} obj
 * @return {string}
 */
L.Util.stamp = function(obj) {};

/**
 * Returns a wrapper around the function fn that makes sure it's called not more
 * often than a certain time interval time, but as fast as possible otherwise
 * (for example, it is used for checking and requesting new tiles while dragging
 * the map), optionally passing the scope (context) in which the function will
 * be called.
 * @template T
 * @param {T} fn
 * @param {number} time
 * @param {?=} context
 * @return {T}
 */
L.Util.limitExecByInterval = function(fn, time, context) {};

/**
 * Returns a function which always returns false.
 * @return {function(): boolean}
 */
L.Util.falseFn = function() {};

/**
 * Returns the number num rounded to digits decimals.
 * @param {number} num
 * @param {number} digits
 * @return {number}
 */
L.Util.formatNum = function(num, digits) {};

/**
 * Trims and splits the string on whitespace and returns the array of parts.
 * @param {string} str
 * @return {!Array<string>}
 */
L.Util.splitWords = function(str) {};

/**
 * Merges the given properties to the options of the obj object, returning the
 * resulting options. See Class options. Has an L.setOptions shortcut.
 * @param {?} obj
 * @param {?} options
 * @return {?}
 */
L.Util.setOptions = function(obj, options) {};

/**
 * Converts an object into a parameter URL string, e.g. {a: "foo", b: "bar"}
 * translates to '?a=foo&b=bar'.
 * @param {?} obj
 * @return {string}
 */
L.Util.getParamString = function(obj) {};

/**
 * Simple templating facility, creates a string by applying the values of the
 * data object of a form {a: 'foo', b: 'bar', …} to a template string of the form
 * 'Hello {a}, {b}' — in this example you will get 'Hello foo, bar'.
 * @param {string} str
 * @param {?} data
 * @return {string}
 */
L.Util.template = function(str, data) {};

/**
 * Returns true if the given object is an array.
 * @param {?} obj
 * @return {boolean}
 */
L.Util.isArray = function(obj) {};

/**
 * Trims the whitespace from both ends of the string and returns the result.
 * @param {string} str
 * @return {string}
 */
L.Util.trim = function(str) {};
 /** @type {string} */
L.Util.emptyImageUrl;
/**
 * @record
 * @struct
 */
L.WMSOptions = function() {};
 /** @type {string} */
L.WMSOptions.prototype.layers;
 /** @type {string} */
L.WMSOptions.prototype.styles;
 /** @type {string} */
L.WMSOptions.prototype.format;
 /** @type {boolean} */
L.WMSOptions.prototype.transparent;
 /** @type {string} */
L.WMSOptions.prototype.version;
 /** @type {boolean} */
var L_PREFER_CANVAS;
 /** @type {boolean} */
var L_NO_TOUCH;
 /** @type {boolean} */
var L_DISABLE_3D;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "leaflet"
/** @const */
tsickle_declare_module.leaflet = {};

/* TODO: ExportAssignment in tsickle_declare_module.leaflet */
