/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/connect/index.d.ts:

/* TODO: ImportDeclaration in  */

/**
 * Create a new connect server.
 * @return {!createServer.Server}
 */
function createServer() {}

/** @typedef {(function(!IncomingMessage, !ServerResponse): void|function(!IncomingMessage, !ServerResponse, !Function): void|function(!Error, !IncomingMessage, !ServerResponse, !Function): void|!Server)} */
createServer.ServerHandle;

/** @typedef {function(!IncomingMessage, !ServerResponse): void} */
createServer.SimpleHandleFunction;

/** @typedef {function(!IncomingMessage, !ServerResponse, !Function): void} */
createServer.NextHandleFunction;

/** @typedef {function(!Error, !IncomingMessage, !ServerResponse, !Function): void} */
createServer.ErrorHandleFunction;

/** @typedef {(function(!IncomingMessage, !ServerResponse): void|function(!IncomingMessage, !ServerResponse, !Function): void|function(!Error, !IncomingMessage, !ServerResponse, !Function): void)} */
createServer.HandleFunction;
/**
 * @record
 * @struct
 */
createServer.ServerStackItem = function() {};
 /** @type {string} */
createServer.ServerStackItem.prototype.route;
 /** @type {(function(!IncomingMessage, !ServerResponse): void|function(!IncomingMessage, !ServerResponse, !Function): void|function(!Error, !IncomingMessage, !ServerResponse, !Function): void|!Server)} */
createServer.ServerStackItem.prototype.handle;
/**
 * @record
 * @struct
 */
createServer.Server = function() {};

/* TODO: CallSignature: createServer */
 /** @type {string} */
createServer.Server.prototype.route;
 /** @type {!Array<!createServer.ServerStackItem>} */
createServer.Server.prototype.stack;

/**
 * Utilize the given middleware `handle` to the given `route`,
 * defaulting to _/_. This "route" is the mount-point for the
 * middleware, when given a value other than _/_ the middleware
 * is only effective when that segment is present in the request's
 * pathname.
 * 
 * For example if we were to mount a function at _/admin_, it would
 * be invoked on _/admin_, and _/admin/settings_, however it would
 * not be invoked for _/_, or _/posts_.
 * 
 * @param {(function(!IncomingMessage, !ServerResponse): void|function(!IncomingMessage, !ServerResponse, !Function): void|function(!Error, !IncomingMessage, !ServerResponse, !Function): void)|string} fn_or_route
 * @param {(function(!IncomingMessage, !ServerResponse): void|function(!IncomingMessage, !ServerResponse, !Function): void|function(!Error, !IncomingMessage, !ServerResponse, !Function): void)=} fn
 * @return {!createServer.Server}
 */
createServer.Server.prototype.use = function(fn_or_route, fn) {};

/**
 * Handle server requests, punting them down
 * the middleware stack.
 * 
 * @param {!IncomingMessage} req
 * @param {!ServerResponse} res
 * @param {!Function} next
 * @return {void}
 */
createServer.Server.prototype.handle = function(req, res, next) {};

/**
 * Listen for connections.
 * 
 * This method takes the same arguments
 * as node's `http.Server#listen()`.
 * 
 * HTTP and HTTPS:
 * 
 * If you run your application both as HTTP
 * and HTTPS you may wrap them individually,
 * since your Connect "server" is really just
 * a JavaScript `Function`.
 * 
 *      var connect = require('connect')
 *        , http = require('http')
 *        , https = require('https');
 * 
 *      var app = connect();
 * 
 *      http.createServer(app).listen(80);
 *      https.createServer(options, app).listen(443);
 * 
 * \@api public
 * @param {number|string|?} port_or_path_or_handle
 * @param {string|!Function=} hostname_or_callback_or_listeningListener
 * @param {number|!Function=} backlog_or_callback
 * @param {!Function=} callback
 * @return {!Server}
 */
createServer.Server.prototype.listen = function(port_or_path_or_handle, hostname_or_callback_or_listeningListener, backlog_or_callback, callback) {};

/* TODO: ExportAssignment in  */
