/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/codemirror/index.d.ts:

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */

/**
 * @param {!HTMLElement|function(!HTMLElement): void} host_or_callback
 * @param {!CodeMirror.EditorConfiguration=} options
 * @return {!CodeMirror.Editor}
 */
function CodeMirror(host_or_callback, options) {}
 /** @type {!CodeMirror.DocConstructor} */
CodeMirror.Doc;
 /** @type {!CodeMirror.PositionConstructor} */
CodeMirror.Pos;
 /** @type {?} */
CodeMirror.Pass;

/**
 * @param {!HTMLTextAreaElement} host
 * @param {!CodeMirror.EditorConfiguration=} options
 * @return {!CodeMirror.EditorFromTextArea}
 */
CodeMirror.fromTextArea = function(host, options) {};
 /** @type {string} */
CodeMirror.version;

/**
 * If you want to define extra methods in terms of the CodeMirror API, it is possible to use defineExtension.
 * This will cause the given value(usually a method) to be added to all CodeMirror instances created from then on.
 * @param {string} name
 * @param {?} value
 * @return {void}
 */
CodeMirror.defineExtension = function(name, value) {};

/**
 * Like defineExtension, but the method will be added to the interface for Doc objects instead.
 * @param {string} name
 * @param {?} value
 * @return {void}
 */
CodeMirror.defineDocExtension = function(name, value) {};

/**
 * Similarly, defineOption can be used to define new options for CodeMirror.
 * The updateFunc will be called with the editor instance and the new value when an editor is initialized,
 * and whenever the option is modified through setOption.
 * @param {string} name
 * @param {?} default_
 * @param {!Function} updateFunc
 * @return {void}
 */
CodeMirror.defineOption = function(name, default_, updateFunc) {};

/**
 * If your extention just needs to run some code whenever a CodeMirror instance is initialized, use CodeMirror.defineInitHook.
 * Give it a function as its only argument, and from then on, that function will be called (with the instance as argument)
 * whenever a new CodeMirror instance is initialized.
 * @param {!Function} func
 * @return {void}
 */
CodeMirror.defineInitHook = function(func) {};

/**
 * Registers a helper value with the given name in the given namespace (type). This is used to define functionality
 * that may be looked up by mode. Will create (if it doesn't already exist) a property on the CodeMirror object for
 * the given type, pointing to an object that maps names to values. I.e. after doing
 * CodeMirror.registerHelper("hint", "foo", myFoo), the value CodeMirror.hint.foo will point to myFoo.
 * @param {string} namespace
 * @param {string} name
 * @param {?} helper
 * @return {void}
 */
CodeMirror.registerHelper = function(namespace, name, helper) {};

/**
 * Fired whenever a change occurs to the document. changeObj has a similar type as the object passed to the editor's "change" event,
 * but it never has a next property, because document change events are not batched (whereas editor change events are).
 * See the description of the same event on editor instances.
 * Fired whenever the cursor or selection in this document changes.
 * Equivalent to the event by the same name as fired on editor instances.
 * Will be fired when the line object is deleted. A line object is associated with the start of the line.
 * Mostly useful when you need to find out when your gutter markers on a given line are removed.
 * Fires when the line's text content is changed in any way (but the line is not deleted outright).
 * The change object is similar to the one passed to change event on the editor object.
 * Fired when the cursor enters the marked range. From this event handler, the editor state may be inspected but not modified,
 * with the exception that the range on which the event fires may be cleared.
 * Fired when the range is cleared, either through cursor movement in combination with clearOnEnter or through a call to its clear() method.
 * Will only be fired once per handle. Note that deleting the range through text editing does not fire this event,
 * because an undo action might bring the range back into existence.
 * Fired when the last part of the marker is removed from the document by editing operations.
 * Fired when, after the marker was removed by editing, a undo operation brought the marker back.
 * Fired whenever the editor re-adds the widget to the DOM. This will happen once right after the widget is added (if it is scrolled into view),
 * and then again whenever it is scrolled out of view and back in again, or when changes to the editor options
 * or the line the widget is on require the widget to be redrawn.
 * @param {?|!CodeMirror.LineHandle|!CodeMirror.TextMarker|!CodeMirror.LineWidget} element_or_doc_or_line_or_marker
 * @param {string} eventName
 * @param {!Function|function(?, !CodeMirror.EditorChange): void|function(?, !CodeMirror.EditorChangeCancellable): void|function(!CodeMirror.Editor): void|function(!CodeMirror.Editor, {head: !CodeMirror.Position, anchor: !CodeMirror.Position}): void|function(): void|function(!CodeMirror.LineHandle, !CodeMirror.EditorChange): void} handler
 * @return {void}
 */
CodeMirror.on = function(element_or_doc_or_line_or_marker, eventName, handler) {};

/**
 * @param {?|!CodeMirror.LineHandle|!CodeMirror.TextMarker|!CodeMirror.LineWidget} element_or_doc_or_line_or_marker
 * @param {string} eventName
 * @param {!Function|function(?, !CodeMirror.EditorChange): void|function(?, !CodeMirror.EditorChangeCancellable): void|function(!CodeMirror.Editor): void|function(!CodeMirror.Editor, {head: !CodeMirror.Position, anchor: !CodeMirror.Position}): void|function(): void|function(!CodeMirror.LineHandle, !CodeMirror.EditorChange): void} handler
 * @return {void}
 */
CodeMirror.off = function(element_or_doc_or_line_or_marker, eventName, handler) {};

/**
 * Various CodeMirror-related objects emit events, which allow client code to react to various situations.
 * Handlers for such events can be registered with the on and off methods on the objects that the event fires on.
 * To fire your own events, use CodeMirror.signal(target, name, args...), where target is a non-DOM-node object.
 * @param {?} target
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
CodeMirror.signal = function(target, name, args) {};

/** @typedef {string} */
CodeMirror.DOMEvent;
/**
 * @record
 * @struct
 */
CodeMirror.Editor = function() {};
 /** @type {?} */
CodeMirror.Editor.prototype.state;

/**
 * Tells you whether the editor currently has focus.
 * @return {boolean}
 */
CodeMirror.Editor.prototype.hasFocus = function() {};

/**
 * Used to find the target position for horizontal cursor motion.start is a { line , ch } object,
 * amount an integer(may be negative), and unit one of the string "char", "column", or "word".
 * Will return a position that is produced by moving amount times the distance specified by unit.
 * When visually is true , motion in right - to - left text will be visual rather than logical.
 * When the motion was clipped by hitting the end or start of the document, the returned value will have a hitSide property set to true.
 * @param {!CodeMirror.Position} start
 * @param {number} amount
 * @param {string} unit
 * @param {boolean} visually
 * @return {{line: number, ch: number, hitSide: boolean}}
 */
CodeMirror.Editor.prototype.findPosH = function(start, amount, unit, visually) {};

/**
 * Similar to findPosH , but used for vertical motion.unit may be "line" or "page".
 * The other arguments and the returned value have the same interpretation as they have in findPosH.
 * @param {!CodeMirror.Position} start
 * @param {number} amount
 * @param {string} unit
 * @return {{line: number, ch: number, hitSide: boolean}}
 */
CodeMirror.Editor.prototype.findPosV = function(start, amount, unit) {};

/**
 * Returns the start and end of the 'word' (the stretch of letters, whitespace, or punctuation) at the given position.
 * @param {!CodeMirror.Position} pos
 * @return {!CodeMirror.Range}
 */
CodeMirror.Editor.prototype.findWordAt = function(pos) {};

/**
 * Change the configuration of the editor. option should the name of an option, and value should be a valid value for that option.
 * @param {string} option
 * @param {?} value
 * @return {void}
 */
CodeMirror.Editor.prototype.setOption = function(option, value) {};

/**
 * Retrieves the current value of the given option for this editor instance.
 * @param {string} option
 * @return {?}
 */
CodeMirror.Editor.prototype.getOption = function(option) {};

/**
 * Attach an additional keymap to the editor.
 * This is mostly useful for add - ons that need to register some key handlers without trampling on the extraKeys option.
 * Maps added in this way have a higher precedence than the extraKeys and keyMap options, and between them,
 * the maps added earlier have a lower precedence than those added later, unless the bottom argument was passed,
 * in which case they end up below other keymaps added with this method.
 * @param {?} map
 * @param {boolean=} bottom
 * @return {void}
 */
CodeMirror.Editor.prototype.addKeyMap = function(map, bottom) {};

/**
 * Disable a keymap added with addKeyMap.Either pass in the keymap object itself , or a string,
 * which will be compared against the name property of the active keymaps.
 * @param {?} map
 * @return {void}
 */
CodeMirror.Editor.prototype.removeKeyMap = function(map) {};

/**
 * Enable a highlighting overlay.This is a stateless mini - mode that can be used to add extra highlighting.
 * For example, the search add - on uses it to highlight the term that's currently being searched.
 * mode can be a mode spec or a mode object (an object with a token method). The options parameter is optional. If given, it should be an object.
 * Currently, only the opaque option is recognized. This defaults to off, but can be given to allow the overlay styling, when not null,
 * to override the styling of the base mode entirely, instead of the two being applied together.
 * @param {?} mode
 * @param {?=} options
 * @return {void}
 */
CodeMirror.Editor.prototype.addOverlay = function(mode, options) {};

/**
 * Pass this the exact argument passed for the mode parameter to addOverlay to remove an overlay again.
 * @param {?} mode
 * @return {void}
 */
CodeMirror.Editor.prototype.removeOverlay = function(mode) {};

/**
 * Retrieve the currently active document from an editor.
 * @return {?}
 */
CodeMirror.Editor.prototype.getDoc = function() {};

/**
 * Attach a new document to the editor. Returns the old document, which is now no longer associated with an editor.
 * @param {?} doc
 * @return {?}
 */
CodeMirror.Editor.prototype.swapDoc = function(doc) {};

/**
 * Get the content of the current editor document. You can pass it an optional argument to specify the string to be used to separate lines (defaults to "\n").
 * @param {string=} seperator
 * @return {string}
 */
CodeMirror.Editor.prototype.getValue = function(seperator) {};

/**
 * Set the content of the current editor document.
 * @param {string} content
 * @return {void}
 */
CodeMirror.Editor.prototype.setValue = function(content) {};

/**
 * Sets the gutter marker for the given gutter (identified by its CSS class, see the gutters option) to the given value.
 * Value can be either null, to clear the marker, or a DOM element, to set it. The DOM element will be shown in the specified gutter next to the specified line.
 * @param {?} line
 * @param {string} gutterID
 * @param {!HTMLElement} value
 * @return {!CodeMirror.LineHandle}
 */
CodeMirror.Editor.prototype.setGutterMarker = function(line, gutterID, value) {};

/**
 * Remove all gutter markers in the gutter with the given ID.
 * @param {string} gutterID
 * @return {void}
 */
CodeMirror.Editor.prototype.clearGutter = function(gutterID) {};

/**
 * Set a CSS class name for the given line.line can be a number or a line handle.
 * where determines to which element this class should be applied, can can be one of "text" (the text element, which lies in front of the selection),
 * "background"(a background element that will be behind the selection),
 * or "wrap" (the wrapper node that wraps all of the line's elements, including gutter elements).
 * class should be the name of the class to apply.
 * @param {?} line
 * @param {string} where
 * @param {string} _class_
 * @return {!CodeMirror.LineHandle}
 */
CodeMirror.Editor.prototype.addLineClass = function(line, where, _class_) {};

/**
 * Remove a CSS class from a line.line can be a line handle or number.
 * where should be one of "text", "background", or "wrap"(see addLineClass).
 * class can be left off to remove all classes for the specified node, or be a string to remove only a specific class.
 * @param {?} line
 * @param {string} where
 * @param {string=} class_
 * @return {!CodeMirror.LineHandle}
 */
CodeMirror.Editor.prototype.removeLineClass = function(line, where, class_) {};

/**
 * Compute the line at the given pixel height.
 * 
 * `mode` is the relative element to use to compute this line - defaults to 'page' if not specified
 * @param {number} height
 * @param {string=} mode
 * @return {number}
 */
CodeMirror.Editor.prototype.lineAtHeight = function(height, mode) {};

/**
 * Returns the line number, text content, and marker status of the given line, which can be either a number or a line handle.
 * @param {?} line
 * @return {{line: ?, handle: ?, text: string, gutterMarkers: ?, textClass: string, bgClass: string, wrapClass: string, widgets: ?}}
 */
CodeMirror.Editor.prototype.lineInfo = function(line) {};

/**
 * Puts node, which should be an absolutely positioned DOM node, into the editor, positioned right below the given { line , ch } position.
 * When scrollIntoView is true, the editor will ensure that the entire node is visible (if possible).
 * To remove the widget again, simply use DOM methods (move it somewhere else, or call removeChild on its parent).
 * @param {!CodeMirror.Position} pos
 * @param {!HTMLElement} node
 * @param {boolean} scrollIntoView
 * @return {void}
 */
CodeMirror.Editor.prototype.addWidget = function(pos, node, scrollIntoView) {};

/**
 * Adds a line widget, an element shown below a line, spanning the whole of the editor's width, and moving the lines below it downwards.
 * line should be either an integer or a line handle, and node should be a DOM node, which will be displayed below the given line.
 * options, when given, should be an object that configures the behavior of the widget.
 * Note that the widget node will become a descendant of nodes with CodeMirror-specific CSS classes, and those classes might in some cases affect it.
 * @param {?} line
 * @param {!HTMLElement} node
 * @param {{coverGutter: boolean, noHScroll: boolean, above: boolean, showIfHidden: boolean}=} options
 * @return {!CodeMirror.LineWidget}
 */
CodeMirror.Editor.prototype.addLineWidget = function(line, node, options) {};

/**
 * Programatically set the size of the editor (overriding the applicable CSS rules).
 * width and height height can be either numbers(interpreted as pixels) or CSS units ("100%", for example).
 * You can pass null for either of them to indicate that that dimension should not be changed.
 * @param {?} width
 * @param {?} height
 * @return {void}
 */
CodeMirror.Editor.prototype.setSize = function(width, height) {};

/**
 * Scroll the editor to a given(pixel) position.Both arguments may be left as null or undefined to have no effect.
 * @param {number=} x
 * @param {number=} y
 * @return {void}
 */
CodeMirror.Editor.prototype.scrollTo = function(x, y) {};

/**
 * Get an { left , top , width , height , clientWidth , clientHeight } object that represents the current scroll position, the size of the scrollable area,
 * and the size of the visible area(minus scrollbars).
 * @return {!CodeMirror.ScrollInfo}
 */
CodeMirror.Editor.prototype.getScrollInfo = function() {};

/**
 * Scrolls the given element into view. pos is a { line , ch } position, referring to a given character, null, to refer to the cursor.
 * The margin parameter is optional. When given, it indicates the amount of pixels around the given area that should be made visible as well.
 * Scrolls the given element into view. pos is a { left , top , right , bottom } object, in editor-local coordinates.
 * The margin parameter is optional. When given, it indicates the amount of pixels around the given area that should be made visible as well.
 * Scrolls the given element into view. pos is a { line, ch } object, in editor-local coordinates.
 * The margin parameter is optional. When given, it indicates the amount of pixels around the given area that should be made visible as well.
 * Scrolls the given element into view. pos is a { from, to } object, in editor-local coordinates.
 * The margin parameter is optional. When given, it indicates the amount of pixels around the given area that should be made visible as well.
 * @param {!CodeMirror.Position|{left: number, top: number, right: number, bottom: number}|{line: number, ch: number}|{from: !CodeMirror.Position, to: !CodeMirror.Position}} pos
 * @param {number=} margin
 * @return {void}
 */
CodeMirror.Editor.prototype.scrollIntoView = function(pos, margin) {};

/**
 * Returns an { left , top , bottom } object containing the coordinates of the cursor position.
 * If mode is "local" , they will be relative to the top-left corner of the editable document.
 * If it is "page" or not given, they are relative to the top-left corner of the page.
 * where is a boolean indicating whether you want the start(true) or the end(false) of the selection.
 * Returns an { left , top , bottom } object containing the coordinates of the cursor position.
 * If mode is "local" , they will be relative to the top-left corner of the editable document.
 * If it is "page" or not given, they are relative to the top-left corner of the page.
 * where specifies the precise position at which you want to measure.
 * @param {boolean|!CodeMirror.Position} where
 * @param {string} mode
 * @return {{left: number, top: number, bottom: number}}
 */
CodeMirror.Editor.prototype.cursorCoords = function(where, mode) {};

/**
 * Returns the position and dimensions of an arbitrary character.pos should be a { line , ch } object.
 * This differs from cursorCoords in that it'll give the size of the whole character,
 * rather than just the position that the cursor would have when it would sit at that position.
 * @param {!CodeMirror.Position} pos
 * @param {string} mode
 * @return {{left: number, right: number, top: number, bottom: number}}
 */
CodeMirror.Editor.prototype.charCoords = function(pos, mode) {};

/**
 * Given an { left , top } object , returns the { line , ch } position that corresponds to it.
 * The optional mode parameter determines relative to what the coordinates are interpreted. It may be "window" , "page"(the default) , or "local".
 * @param {{left: number, top: number}} object
 * @param {string=} mode
 * @return {!CodeMirror.Position}
 */
CodeMirror.Editor.prototype.coordsChar = function(object, mode) {};

/**
 * Returns the line height of the default font for the editor.
 * @return {number}
 */
CodeMirror.Editor.prototype.defaultTextHeight = function() {};

/**
 * Returns the pixel width of an 'x' in the default font for the editor.
 * (Note that for non - monospace fonts , this is mostly useless, and even for monospace fonts, non - ascii characters might have a different width).
 * @return {number}
 */
CodeMirror.Editor.prototype.defaultCharWidth = function() {};

/**
 * Returns a { from , to } object indicating the start (inclusive) and end (exclusive) of the currently rendered part of the document.
 * In big documents, when most content is scrolled out of view, CodeMirror will only render the visible part, and a margin around it.
 * See also the viewportChange event.
 * @return {{from: number, to: number}}
 */
CodeMirror.Editor.prototype.getViewport = function() {};

/**
 * If your code does something to change the size of the editor element (window resizes are already listened for), or unhides it,
 * you should probably follow up by calling this method to ensure CodeMirror is still looking as intended.
 * @return {void}
 */
CodeMirror.Editor.prototype.refresh = function() {};

/**
 * Retrieves information about the token the current mode found before the given position (a {line, ch} object).
 * @param {!CodeMirror.Position} pos
 * @return {{start: number, end: number, string: string, type: string, state: ?}}
 */
CodeMirror.Editor.prototype.getTokenAt = function(pos) {};

/**
 * Returns the mode's parser state, if any, at the end of the given line number.
 * If no line number is given, the state at the end of the document is returned.
 * This can be useful for storing parsing errors in the state, or getting other kinds of contextual information for a line.
 * @param {number=} line
 * @return {?}
 */
CodeMirror.Editor.prototype.getStateAfter = function(line) {};

/**
 * CodeMirror internally buffers changes and only updates its DOM structure after it has finished performing some operation.
 * If you need to perform a lot of operations on a CodeMirror instance, you can call this method with a function argument.
 * It will call the function, buffering up all changes, and only doing the expensive update after the function returns.
 * This can be a lot faster. The return value from this method will be the return value of your function.
 * @template T
 * @param {function(): T} fn
 * @return {T}
 */
CodeMirror.Editor.prototype.operation = function(fn) {};

/**
 * Adjust the indentation of the given line.
 * The second argument (which defaults to "smart") may be one of:
 * "prev" Base indentation on the indentation of the previous line.
 * "smart" Use the mode's smart indentation if available, behave like "prev" otherwise.
 * "add" Increase the indentation of the line by one indent unit.
 * "subtract" Reduce the indentation of the line.
 * @param {number} line
 * @param {string=} dir
 * @return {void}
 */
CodeMirror.Editor.prototype.indentLine = function(line, dir) {};

/**
 * Give the editor focus.
 * @return {void}
 */
CodeMirror.Editor.prototype.focus = function() {};

/**
 * Returns the hidden textarea used to read input.
 * @return {!HTMLTextAreaElement}
 */
CodeMirror.Editor.prototype.getInputField = function() {};

/**
 * Returns the DOM node that represents the editor, and controls its size. Remove this from your tree to delete an editor instance.
 * @return {!HTMLElement}
 */
CodeMirror.Editor.prototype.getWrapperElement = function() {};

/**
 * Returns the DOM node that is responsible for the scrolling of the editor.
 * @return {!HTMLElement}
 */
CodeMirror.Editor.prototype.getScrollerElement = function() {};

/**
 * Fetches the DOM node that contains the editor gutters.
 * @return {!HTMLElement}
 */
CodeMirror.Editor.prototype.getGutterElement = function() {};

/**
 * Events are registered with the on method (and removed with the off method).
 * These are the events that fire on the instance object. The name of the event is followed by the arguments that will be passed to the handler.
 * The instance argument always refers to the editor instance.
 * Fires every time the content of the editor is changed.
 * Like the "change" event, but batched per operation, passing an
 * array containing all the changes that happened in the operation.
 * This event is fired after the operation finished, and display
 * changes it makes will trigger a new operation.
 * This event is fired before a change is applied, and its handler may choose to modify or cancel the change.
 * The changeObj never has a next property, since this is fired for each individual change, and not batched per operation.
 * Note: you may not do anything from a "beforeChange" handler that would cause changes to the document or its visualization.
 * Doing so will, since this handler is called directly from the bowels of the CodeMirror implementation,
 * probably cause the editor to become corrupted.
 * Will be fired when the cursor or selection moves, or any change is made to the editor content.
 * This event is fired before the selection is moved. Its handler may modify the resulting selection head and anchor.
 * Handlers for this event have the same restriction as "beforeChange" handlers � they should not do anything to directly update the state of the editor.
 * Fires whenever the view port of the editor changes (due to scrolling, editing, or any other factor).
 * The from and to arguments give the new start and end of the viewport.
 * Fires when the editor gutter (the line-number area) is clicked. Will pass the editor instance as first argument,
 * the (zero-based) number of the line that was clicked as second argument, the CSS class of the gutter that was clicked as third argument,
 * and the raw mousedown event object as fourth argument.
 * Fires whenever the editor is focused.
 * Fires whenever the editor is unfocused.
 * Fires when the editor is scrolled.
 * Will be fired whenever CodeMirror updates its DOM display.
 * Fired whenever a line is (re-)rendered to the DOM. Fired right after the DOM element is built, before it is added to the document.
 * The handler may mess with the style of the resulting element, or add event handlers, but should not try to change the state of the editor.
 * Fires when one of the DOM events fires.
 * @param {string} eventName
 * @param {function(!CodeMirror.Editor): void|function(!CodeMirror.Editor, !CodeMirror.EditorChangeLinkedList): void|function(!CodeMirror.Editor, !Array<!CodeMirror.EditorChangeLinkedList>): void|function(!CodeMirror.Editor, !CodeMirror.EditorChangeCancellable): void|function(!CodeMirror.Editor, {head: !CodeMirror.Position, anchor: !CodeMirror.Position}): void|function(!CodeMirror.Editor, number, number): void|function(!CodeMirror.Editor, number, string, !Event): void|function(!CodeMirror.Editor, !CodeMirror.LineHandle, !HTMLElement): void|function(!CodeMirror.Editor, !Event): void} handler
 * @return {void}
 */
CodeMirror.Editor.prototype.on = function(eventName, handler) {};

/**
 * @param {string} eventName
 * @param {function(!CodeMirror.Editor): void|function(!CodeMirror.Editor, !CodeMirror.EditorChangeLinkedList): void|function(!CodeMirror.Editor, !Array<!CodeMirror.EditorChangeLinkedList>): void|function(!CodeMirror.Editor, !CodeMirror.EditorChangeCancellable): void|function(!CodeMirror.Editor, {head: !CodeMirror.Position, anchor: !CodeMirror.Position}): void|function(!CodeMirror.Editor, number, number): void|function(!CodeMirror.Editor, number, string, !Event): void|function(!CodeMirror.Editor, !CodeMirror.LineHandle, !HTMLElement): void|function(!CodeMirror.Editor, !Event): void} handler
 * @return {void}
 */
CodeMirror.Editor.prototype.off = function(eventName, handler) {};
/**
 * @extends {CodeMirror.Editor}
 * @record
 * @struct
 */
CodeMirror.EditorFromTextArea = function() {};

/**
 * Copy the content of the editor into the textarea.
 * @return {void}
 */
CodeMirror.EditorFromTextArea.prototype.save = function() {};

/**
 * Remove the editor, and restore the original textarea (with the editor's current content).
 * @return {void}
 */
CodeMirror.EditorFromTextArea.prototype.toTextArea = function() {};

/**
 * Returns the textarea that the instance was based on.
 * @return {!HTMLTextAreaElement}
 */
CodeMirror.EditorFromTextArea.prototype.getTextArea = function() {};
/**
 * @record
 * @struct
 */
CodeMirror.DocConstructor = function() {};

/* TODO: ConstructSignature: CodeMirror */

/* TODO: CallSignature: CodeMirror */
 /** @type {?} */
CodeMirror.Doc.prototype.state;

/**
 * Get the current editor content. You can pass it an optional argument to specify the string to be used to separate lines (defaults to "\n").
 * @param {string=} seperator
 * @return {string}
 */
CodeMirror.Doc.prototype.getValue = function(seperator) {};

/**
 * Set the editor content.
 * @param {string} content
 * @return {void}
 */
CodeMirror.Doc.prototype.setValue = function(content) {};

/**
 * Get the text between the given points in the editor, which should be {line, ch} objects.
 * An optional third argument can be given to indicate the line separator string to use (defaults to "\n").
 * @param {!CodeMirror.Position} from
 * @param {!CodeMirror.Position} to
 * @param {string=} seperator
 * @return {string}
 */
CodeMirror.Doc.prototype.getRange = function(from, to, seperator) {};

/**
 * Replace the part of the document between from and to with the given string.
 * from and to must be {line, ch} objects. to can be left off to simply insert the string at position from.
 * @param {string} replacement
 * @param {!CodeMirror.Position} from
 * @param {!CodeMirror.Position=} to
 * @param {string=} origin
 * @return {void}
 */
CodeMirror.Doc.prototype.replaceRange = function(replacement, from, to, origin) {};

/**
 * Get the content of line n.
 * @param {number} n
 * @return {string}
 */
CodeMirror.Doc.prototype.getLine = function(n) {};

/**
 * Set the content of line n.
 * @param {number} n
 * @param {string} text
 * @return {void}
 */
CodeMirror.Doc.prototype.setLine = function(n, text) {};

/**
 * Remove the given line from the document.
 * @param {number} n
 * @return {void}
 */
CodeMirror.Doc.prototype.removeLine = function(n) {};

/**
 * Get the number of lines in the editor.
 * @return {number}
 */
CodeMirror.Doc.prototype.lineCount = function() {};

/**
 * Get the first line of the editor. This will usually be zero but for linked sub-views,
 * or documents instantiated with a non-zero first line, it might return other values.
 * @return {number}
 */
CodeMirror.Doc.prototype.firstLine = function() {};

/**
 * Get the last line of the editor. This will usually be lineCount() - 1, but for linked sub-views, it might return other values.
 * @return {number}
 */
CodeMirror.Doc.prototype.lastLine = function() {};

/**
 * Fetches the line handle for the given line number.
 * @param {number} num
 * @return {!CodeMirror.LineHandle}
 */
CodeMirror.Doc.prototype.getLineHandle = function(num) {};

/**
 * Given a line handle, returns the current position of that line (or null when it is no longer in the document).
 * @param {!CodeMirror.LineHandle} handle
 * @return {number}
 */
CodeMirror.Doc.prototype.getLineNumber = function(handle) {};

/**
 * Iterate over the whole document, and call f for each line, passing the line handle.
 * This is a faster way to visit a range of line handlers than calling getLineHandle for each of them.
 * Note that line handles have a text property containing the line's content (as a string).
 * Iterate over the range from start up to (not including) end, and call f for each line, passing the line handle.
 * This is a faster way to visit a range of line handlers than calling getLineHandle for each of them.
 * Note that line handles have a text property containing the line's content (as a string).
 * @param {function(!CodeMirror.LineHandle): void|number} f_or_start
 * @param {number=} end
 * @param {function(!CodeMirror.LineHandle): void=} f
 * @return {void}
 */
CodeMirror.Doc.prototype.eachLine = function(f_or_start, end, f) {};

/**
 * Set the editor content as 'clean', a flag that it will retain until it is edited, and which will be set again when such an edit is undone again.
 * Useful to track whether the content needs to be saved.
 * @return {void}
 */
CodeMirror.Doc.prototype.markClean = function() {};

/**
 * Returns whether the document is currently clean (not modified since initialization or the last call to markClean).
 * @return {boolean}
 */
CodeMirror.Doc.prototype.isClean = function() {};

/**
 * Get the currently selected code.
 * @return {string}
 */
CodeMirror.Doc.prototype.getSelection = function() {};

/**
 * Replace the selection with the given string. By default, the new selection will span the inserted text.
 * The optional collapse argument can be used to change this � passing "start" or "end" will collapse the selection to the start or end of the inserted text.
 * @param {string} replacement
 * @param {string=} collapse
 * @return {void}
 */
CodeMirror.Doc.prototype.replaceSelection = function(replacement, collapse) {};

/**
 * start is a an optional string indicating which end of the selection to return.
 * It may be "start" , "end" , "head"(the side of the selection that moves when you press shift + arrow),
 * or "anchor"(the fixed side of the selection).Omitting the argument is the same as passing "head".A { line , ch } object will be returned.
 * @param {string=} start
 * @return {!CodeMirror.Position}
 */
CodeMirror.Doc.prototype.getCursor = function(start) {};

/**
 * Retrieves a list of all current selections. These will always be sorted, and never overlap (overlapping selections are merged).
 * Each object in the array contains anchor and head properties referring to {line, ch} objects.
 * @return {!Array<{anchor: !CodeMirror.Position, head: !CodeMirror.Position}>}
 */
CodeMirror.Doc.prototype.listSelections = function() {};

/**
 * Return true if any text is selected.
 * @return {boolean}
 */
CodeMirror.Doc.prototype.somethingSelected = function() {};

/**
 * Set the cursor position.You can either pass a single { line , ch } object , or the line and the character as two separate parameters.
 * @param {!CodeMirror.Position} pos
 * @return {void}
 */
CodeMirror.Doc.prototype.setCursor = function(pos) {};

/**
 * Set the selection range.anchor and head should be { line , ch } objects.head defaults to anchor when not given.
 * @param {!CodeMirror.Position} anchor
 * @param {!CodeMirror.Position} head
 * @return {void}
 */
CodeMirror.Doc.prototype.setSelection = function(anchor, head) {};

/**
 * Similar to setSelection , but will, if shift is held or the extending flag is set,
 * move the head of the selection while leaving the anchor at its current place.
 * pos2 is optional , and can be passed to ensure a region (for example a word or paragraph) will end up selected
 * (in addition to whatever lies between that region and the current anchor).
 * @param {!CodeMirror.Position} from
 * @param {!CodeMirror.Position=} to
 * @return {void}
 */
CodeMirror.Doc.prototype.extendSelection = function(from, to) {};

/**
 * Sets or clears the 'extending' flag , which acts similar to the shift key,
 * in that it will cause cursor movement and calls to extendSelection to leave the selection anchor in place.
 * @param {boolean} value
 * @return {void}
 */
CodeMirror.Doc.prototype.setExtending = function(value) {};

/**
 * Retrieve the editor associated with a document. May return null.
 * @return {!CodeMirror.Editor}
 */
CodeMirror.Doc.prototype.getEditor = function() {};

/**
 * Create an identical copy of the given doc. When copyHistory is true , the history will also be copied.Can not be called directly on an editor.
 * @param {boolean} copyHistory
 * @return {?}
 */
CodeMirror.Doc.prototype.copy = function(copyHistory) {};

/**
 * Create a new document that's linked to the target document. Linked documents will stay in sync (changes to one are also applied to the other) until unlinked.
 * @param {{sharedHist: boolean, from: number, to: number, mode: ?}} options
 * @return {?}
 */
CodeMirror.Doc.prototype.linkedDoc = function(options) {};

/**
 * Break the link between two documents. After calling this , changes will no longer propagate between the documents,
 * and, if they had a shared history, the history will become separate.
 * @param {?} doc
 * @return {void}
 */
CodeMirror.Doc.prototype.unlinkDoc = function(doc) {};

/**
 * Will call the given function for all documents linked to the target document. It will be passed two arguments,
 * the linked document and a boolean indicating whether that document shares history with the target.
 * @param {function(?, boolean): void} fn
 * @return {void}
 */
CodeMirror.Doc.prototype.iterLinkedDocs = function(fn) {};

/**
 * Undo one edit (if any undo events are stored).
 * @return {void}
 */
CodeMirror.Doc.prototype.undo = function() {};

/**
 * Redo one undone edit.
 * @return {void}
 */
CodeMirror.Doc.prototype.redo = function() {};

/**
 * Returns an object with {undo, redo } properties , both of which hold integers , indicating the amount of stored undo and redo operations.
 * @return {{undo: number, redo: number}}
 */
CodeMirror.Doc.prototype.historySize = function() {};

/**
 * Clears the editor's undo history.
 * @return {void}
 */
CodeMirror.Doc.prototype.clearHistory = function() {};

/**
 * Get a(JSON - serializeable) representation of the undo history.
 * @return {?}
 */
CodeMirror.Doc.prototype.getHistory = function() {};

/**
 * Replace the editor's undo history with the one provided, which must be a value as returned by getHistory.
 * Note that this will have entirely undefined results if the editor content isn't also the same as it was when getHistory was called.
 * @param {?} history
 * @return {void}
 */
CodeMirror.Doc.prototype.setHistory = function(history) {};

/**
 * Can be used to mark a range of text with a specific CSS class name. from and to should be { line , ch } objects.
 * @param {!CodeMirror.Position} from
 * @param {!CodeMirror.Position} to
 * @param {!CodeMirror.TextMarkerOptions=} options
 * @return {!CodeMirror.TextMarker}
 */
CodeMirror.Doc.prototype.markText = function(from, to, options) {};

/**
 * Inserts a bookmark, a handle that follows the text around it as it is being edited, at the given position.
 * A bookmark has two methods find() and clear(). The first returns the current position of the bookmark, if it is still in the document,
 * and the second explicitly removes the bookmark.
 * @param {!CodeMirror.Position} pos
 * @param {{widget: !HTMLElement, insertLeft: boolean}=} options
 * @return {!CodeMirror.TextMarker}
 */
CodeMirror.Doc.prototype.setBookmark = function(pos, options) {};

/**
 * Returns an array of all the bookmarks and marked ranges found between the given positions.
 * @param {!CodeMirror.Position} from
 * @param {!CodeMirror.Position} to
 * @return {!Array<!CodeMirror.TextMarker>}
 */
CodeMirror.Doc.prototype.findMarks = function(from, to) {};

/**
 * Returns an array of all the bookmarks and marked ranges present at the given position.
 * @param {!CodeMirror.Position} pos
 * @return {!Array<!CodeMirror.TextMarker>}
 */
CodeMirror.Doc.prototype.findMarksAt = function(pos) {};

/**
 * Returns an array containing all marked ranges in the document.
 * @return {!Array<!CodeMirror.TextMarker>}
 */
CodeMirror.Doc.prototype.getAllMarks = function() {};

/**
 * Gets the mode object for the editor. Note that this is distinct from getOption("mode"), which gives you the mode specification,
 * rather than the resolved, instantiated mode object.
 * @return {?}
 */
CodeMirror.Doc.prototype.getMode = function() {};

/**
 * Calculates and returns a { line , ch } object for a zero-based index whose value is relative to the start of the editor's text.
 * If the index is out of range of the text then the returned object is clipped to start or end of the text respectively.
 * @param {number} index
 * @return {!CodeMirror.Position}
 */
CodeMirror.Doc.prototype.posFromIndex = function(index) {};

/**
 * The reverse of posFromIndex.
 * @param {!CodeMirror.Position} object
 * @return {number}
 */
CodeMirror.Doc.prototype.indexFromPos = function(object) {};
/**
 * @record
 * @struct
 */
CodeMirror.LineHandle = function() {};
 /** @type {string} */
CodeMirror.LineHandle.prototype.text;
/**
 * @record
 * @struct
 */
CodeMirror.ScrollInfo = function() {};
 /** @type {?} */
CodeMirror.ScrollInfo.prototype.left;
 /** @type {?} */
CodeMirror.ScrollInfo.prototype.top;
 /** @type {?} */
CodeMirror.ScrollInfo.prototype.width;
 /** @type {?} */
CodeMirror.ScrollInfo.prototype.height;
 /** @type {?} */
CodeMirror.ScrollInfo.prototype.clientWidth;
 /** @type {?} */
CodeMirror.ScrollInfo.prototype.clientHeight;
/**
 * @record
 * @struct
 */
CodeMirror.TextMarker = function() {};

/**
 * Remove the mark.
 * @return {void}
 */
CodeMirror.TextMarker.prototype.clear = function() {};

/**
 * Returns a {from, to} object (both holding document positions), indicating the current position of the marked range,
 * or undefined if the marker is no longer in the document.
 * @return {!CodeMirror.Range}
 */
CodeMirror.TextMarker.prototype.find = function() {};

/**
 * Returns an object representing the options for the marker. If copyWidget is given true, it will clone the value of the replacedWith option, if any.
 * @param {boolean} copyWidget
 * @return {!CodeMirror.TextMarkerOptions}
 */
CodeMirror.TextMarker.prototype.getOptions = function(copyWidget) {};
/**
 * @record
 * @struct
 */
CodeMirror.LineWidget = function() {};

/**
 * Removes the widget.
 * @return {void}
 */
CodeMirror.LineWidget.prototype.clear = function() {};

/**
 * Call this if you made some change to the widget's DOM node that might affect its height.
 * It'll force CodeMirror to update the height of the line that contains the widget.
 * @return {void}
 */
CodeMirror.LineWidget.prototype.changed = function() {};
/**
 * @record
 * @struct
 */
CodeMirror.EditorChange = function() {};
 /** @type {!CodeMirror.Position} */
CodeMirror.EditorChange.prototype.from;
 /** @type {!CodeMirror.Position} */
CodeMirror.EditorChange.prototype.to;
 /** @type {!Array<string>} */
CodeMirror.EditorChange.prototype.text;
 /** @type {!Array<string>} */
CodeMirror.EditorChange.prototype.removed;
 /** @type {string} */
CodeMirror.EditorChange.prototype.origin;
/**
 * @extends {CodeMirror.EditorChange}
 * @record
 * @struct
 */
CodeMirror.EditorChangeLinkedList = function() {};
 /** @type {!CodeMirror.EditorChangeLinkedList} */
CodeMirror.EditorChangeLinkedList.prototype.next;
/**
 * @extends {CodeMirror.EditorChange}
 * @record
 * @struct
 */
CodeMirror.EditorChangeCancellable = function() {};

/**
 * may be used to modify the change. All three arguments to update are optional, and can be left off to leave the existing value for that field intact.
 * @param {!CodeMirror.Position=} from
 * @param {!CodeMirror.Position=} to
 * @param {string=} text
 * @return {void}
 */
CodeMirror.EditorChangeCancellable.prototype.update = function(from, to, text) {};

/**
 * @return {void}
 */
CodeMirror.EditorChangeCancellable.prototype.cancel = function() {};
/**
 * @record
 * @struct
 */
CodeMirror.PositionConstructor = function() {};

/* TODO: ConstructSignature: CodeMirror */

/* TODO: CallSignature: CodeMirror */
/**
 * @record
 * @struct
 */
CodeMirror.Range = function() {};
 /** @type {!CodeMirror.Position} */
CodeMirror.Range.prototype.anchor;
 /** @type {!CodeMirror.Position} */
CodeMirror.Range.prototype.head;

/**
 * @return {!CodeMirror.Position}
 */
CodeMirror.Range.prototype.from = function() {};

/**
 * @return {!CodeMirror.Position}
 */
CodeMirror.Range.prototype.to = function() {};
/**
 * @record
 * @struct
 */
CodeMirror.Position = function() {};
 /** @type {number} */
CodeMirror.Position.prototype.ch;
 /** @type {number} */
CodeMirror.Position.prototype.line;
/**
 * @record
 * @struct
 */
CodeMirror.EditorConfiguration = function() {};
 /** @type {?} */
CodeMirror.EditorConfiguration.prototype.value;
 /** @type {?} */
CodeMirror.EditorConfiguration.prototype.mode;
 /** @type {string} */
CodeMirror.EditorConfiguration.prototype.theme;
 /** @type {number} */
CodeMirror.EditorConfiguration.prototype.indentUnit;
 /** @type {boolean} */
CodeMirror.EditorConfiguration.prototype.smartIndent;
 /** @type {number} */
CodeMirror.EditorConfiguration.prototype.tabSize;
 /** @type {boolean} */
CodeMirror.EditorConfiguration.prototype.indentWithTabs;
 /** @type {boolean} */
CodeMirror.EditorConfiguration.prototype.electricChars;
 /** @type {boolean} */
CodeMirror.EditorConfiguration.prototype.rtlMoveVisually;
 /** @type {string} */
CodeMirror.EditorConfiguration.prototype.keyMap;
 /** @type {?} */
CodeMirror.EditorConfiguration.prototype.extraKeys;
 /** @type {boolean} */
CodeMirror.EditorConfiguration.prototype.lineWrapping;
 /** @type {boolean} */
CodeMirror.EditorConfiguration.prototype.lineNumbers;
 /** @type {number} */
CodeMirror.EditorConfiguration.prototype.firstLineNumber;
 /** @type {function(number): string} */
CodeMirror.EditorConfiguration.prototype.lineNumberFormatter;
 /** @type {!Array<string>} */
CodeMirror.EditorConfiguration.prototype.gutters;
 /** @type {boolean} */
CodeMirror.EditorConfiguration.prototype.fixedGutter;
 /** @type {?} */
CodeMirror.EditorConfiguration.prototype.readOnly;
 /** @type {boolean} */
CodeMirror.EditorConfiguration.prototype.showCursorWhenSelecting;
 /** @type {number} */
CodeMirror.EditorConfiguration.prototype.undoDepth;
 /** @type {number} */
CodeMirror.EditorConfiguration.prototype.historyEventDelay;
 /** @type {number} */
CodeMirror.EditorConfiguration.prototype.tabindex;
 /** @type {boolean} */
CodeMirror.EditorConfiguration.prototype.autofocus;
 /** @type {boolean} */
CodeMirror.EditorConfiguration.prototype.dragDrop;
 /** @type {function(!CodeMirror.Editor, !Event): boolean} */
CodeMirror.EditorConfiguration.prototype.onDragEvent;
 /** @type {function(!CodeMirror.Editor, !Event): boolean} */
CodeMirror.EditorConfiguration.prototype.onKeyEvent;
 /** @type {number} */
CodeMirror.EditorConfiguration.prototype.cursorBlinkRate;
 /** @type {number} */
CodeMirror.EditorConfiguration.prototype.cursorHeight;
 /** @type {number} */
CodeMirror.EditorConfiguration.prototype.workTime;
 /** @type {number} */
CodeMirror.EditorConfiguration.prototype.workDelay;
 /** @type {number} */
CodeMirror.EditorConfiguration.prototype.pollInterval;
 /** @type {boolean} */
CodeMirror.EditorConfiguration.prototype.flattenSpans;
 /** @type {number} */
CodeMirror.EditorConfiguration.prototype.maxHighlightLength;
 /** @type {number} */
CodeMirror.EditorConfiguration.prototype.viewportMargin;
 /** @type {(boolean|!CodeMirror.LintOptions)} */
CodeMirror.EditorConfiguration.prototype.lint;
 /** @type {string} */
CodeMirror.EditorConfiguration.prototype.placeholder;
/**
 * @record
 * @struct
 */
CodeMirror.TextMarkerOptions = function() {};
 /** @type {string} */
CodeMirror.TextMarkerOptions.prototype.className;
 /** @type {boolean} */
CodeMirror.TextMarkerOptions.prototype.inclusiveLeft;
 /** @type {boolean} */
CodeMirror.TextMarkerOptions.prototype.inclusiveRight;
 /** @type {boolean} */
CodeMirror.TextMarkerOptions.prototype.atomic;
 /** @type {boolean} */
CodeMirror.TextMarkerOptions.prototype.collapsed;
 /** @type {boolean} */
CodeMirror.TextMarkerOptions.prototype.clearOnEnter;
 /** @type {boolean} */
CodeMirror.TextMarkerOptions.prototype.clearWhenEmpty;
 /** @type {!HTMLElement} */
CodeMirror.TextMarkerOptions.prototype.replacedWith;
 /** @type {boolean} */
CodeMirror.TextMarkerOptions.prototype.handleMouseEvents;
 /** @type {boolean} */
CodeMirror.TextMarkerOptions.prototype.readOnly;
 /** @type {boolean} */
CodeMirror.TextMarkerOptions.prototype.addToHistory;
 /** @type {string} */
CodeMirror.TextMarkerOptions.prototype.startStyle;
 /** @type {string} */
CodeMirror.TextMarkerOptions.prototype.endStyle;
 /** @type {string} */
CodeMirror.TextMarkerOptions.prototype.css;
 /** @type {string} */
CodeMirror.TextMarkerOptions.prototype.title;
 /** @type {boolean} */
CodeMirror.TextMarkerOptions.prototype.shared;
/**
 * @record
 * @struct
 */
CodeMirror.StringStream = function() {};
 /** @type {number} */
CodeMirror.StringStream.prototype.lastColumnPos;
 /** @type {number} */
CodeMirror.StringStream.prototype.lastColumnValue;
 /** @type {number} */
CodeMirror.StringStream.prototype.lineStart;
 /** @type {number} */
CodeMirror.StringStream.prototype.pos;
 /** @type {number} */
CodeMirror.StringStream.prototype.start;
 /** @type {string} */
CodeMirror.StringStream.prototype.string;
 /** @type {number} */
CodeMirror.StringStream.prototype.tabSize;

/**
 * Returns true only if the stream is at the end of the line.
 * @return {boolean}
 */
CodeMirror.StringStream.prototype.eol = function() {};

/**
 * Returns true only if the stream is at the start of the line.
 * @return {boolean}
 */
CodeMirror.StringStream.prototype.sol = function() {};

/**
 * Returns the next character in the stream without advancing it. Will return an null at the end of the line.
 * @return {string}
 */
CodeMirror.StringStream.prototype.peek = function() {};

/**
 * Returns the next character in the stream and advances it. Also returns null when no more characters are available.
 * @return {string}
 */
CodeMirror.StringStream.prototype.next = function() {};

/**
 * match can be a character, a regular expression, or a function that takes a character and returns a boolean.
 * If the next character in the stream 'matches' the given argument, it is consumed and returned.
 * Otherwise, undefined is returned.
 * @param {string|!RegExp|function(string): boolean} match
 * @return {string}
 */
CodeMirror.StringStream.prototype.eat = function(match) {};

/**
 * Repeatedly calls eat with the given argument, until it fails. Returns true if any characters were eaten.
 * @param {string|!RegExp|function(string): boolean} match
 * @return {boolean}
 */
CodeMirror.StringStream.prototype.eatWhile = function(match) {};

/**
 * Shortcut for eatWhile when matching white-space.
 * @return {boolean}
 */
CodeMirror.StringStream.prototype.eatSpace = function() {};

/**
 * Moves the position to the end of the line.
 * @return {void}
 */
CodeMirror.StringStream.prototype.skipToEnd = function() {};

/**
 * Skips to the next occurrence of the given character, if found on the current line (doesn't advance the stream if
 * the character does not occur on the line).
 * 
 * Returns true if the character was found.
 * @param {string} ch
 * @return {boolean}
 */
CodeMirror.StringStream.prototype.skipTo = function(ch) {};

/**
 * Act like a multi-character eat - if consume is true or not given - or a look-ahead that doesn't update the stream
 * position - if it is false. pattern can be either a string or a regular expression starting with ^. When it is a
 * string, caseFold can be set to true to make the match case-insensitive. When successfully matching a regular
 * expression, the returned value will be the array returned by match, in case you need to extract matched groups.
 * @param {string|!RegExp} pattern
 * @param {boolean=} consume
 * @param {boolean=} caseFold
 * @return {boolean|!Array<string>}
 */
CodeMirror.StringStream.prototype.match = function(pattern, consume, caseFold) {};

/**
 * Backs up the stream n characters. Backing it up further than the start of the current token will cause things to
 * break, so be careful.
 * @param {number} n
 * @return {void}
 */
CodeMirror.StringStream.prototype.backUp = function(n) {};

/**
 * Returns the column (taking into account tabs) at which the current token starts.
 * @return {number}
 */
CodeMirror.StringStream.prototype.column = function() {};

/**
 * Tells you how far the current line has been indented, in spaces. Corrects for tab characters.
 * @return {number}
 */
CodeMirror.StringStream.prototype.indentation = function() {};

/**
 * Get the string between the start of the current token and the current stream position.
 * @return {string}
 */
CodeMirror.StringStream.prototype.current = function() {};
/**
 * @record
 * @struct
 */
CodeMirror.Mode = function() {};
 /** @type {function(): T} */
CodeMirror.Mode.prototype.startState;
 /** @type {function(T): void} */
CodeMirror.Mode.prototype.blankLine;
 /** @type {function(T): T} */
CodeMirror.Mode.prototype.copyState;
 /** @type {function(T, string): number} */
CodeMirror.Mode.prototype.indent;
 /** @type {string} */
CodeMirror.Mode.prototype.lineComment;
 /** @type {string} */
CodeMirror.Mode.prototype.blockCommentStart;
 /** @type {string} */
CodeMirror.Mode.prototype.blockCommentEnd;
 /** @type {string} */
CodeMirror.Mode.prototype.blockCommentLead;
 /** @type {string} */
CodeMirror.Mode.prototype.electricChars;
 /** @type {!RegExp} */
CodeMirror.Mode.prototype.electricinput;

/**
 * This function should read one token from the stream it is given as an argument, optionally update its state,
 * and return a style string, or null for tokens that do not have to be styled. Multiple styles can be returned, separated by spaces.
 * @param {!CodeMirror.StringStream} stream
 * @param {T} state
 * @return {string}
 */
CodeMirror.Mode.prototype.token = function(stream, state) {};
/**
 * @record
 * @struct
 */
CodeMirror.ModeFactory = function() {};

/* TODO: CallSignature: CodeMirror */

/**
 * id will be the id for the defined mode. Typically, you should use this second argument to defineMode as your module scope function
 * (modes should not leak anything into the global scope!), i.e. write your whole mode inside this function.
 * id will be the id for the defined mode. Typically, you should use this second argument to defineMode as your module scope function
 * (modes should not leak anything into the global scope!), i.e. write your whole mode inside this function.
 * @template T
 * @param {string} id
 * @param {!CodeMirror.ModeFactory<?>|!CodeMirror.ModeFactory<T>} modefactory
 * @return {void}
 */
CodeMirror.defineMode = function(id, modefactory) {};

/**
 * The first argument is a configuration object as passed to the mode constructor function, and the second argument
 * is a mode specification as in the EditorConfiguration mode option.
 * @template T
 * @param {!CodeMirror.EditorConfiguration} config
 * @param {?} mode
 * @return {!CodeMirror.Mode<T>}
 */
CodeMirror.getMode = function(config, mode) {};

/**
 * Utility function from the overlay.js addon that allows modes to be combined. The mode given as the base argument takes care of
 * most of the normal mode functionality, but a second (typically simple) mode is used, which can override the style of text.
 * Both modes get to parse all of the text, but when both assign a non-null style to a piece of code, the overlay wins, unless
 * the combine argument was true and not overridden, or state.overlay.combineTokens was true, in which case the styles are combined.
 * @template T, S
 * @param {!CodeMirror.Mode<T>} base
 * @param {!CodeMirror.Mode<S>} overlay
 * @param {boolean=} combine
 * @return {!CodeMirror.Mode<?>}
 */
CodeMirror.overlayMode = function(base, overlay, combine) {};
/**
 * @record
 * @struct
 */
CodeMirror.LintStateOptions = function() {};
 /** @type {boolean} */
CodeMirror.LintStateOptions.prototype.async;
 /** @type {boolean} */
CodeMirror.LintStateOptions.prototype.hasGutters;
/**
 * @extends {CodeMirror.LintStateOptions}
 * @record
 * @struct
 */
CodeMirror.LintOptions = function() {};
 /** @type {(!CodeMirror.Linter|!CodeMirror.AsyncLinter)} */
CodeMirror.LintOptions.prototype.getAnnotations;
/**
 * @record
 * @struct
 */
CodeMirror.Linter = function() {};

/* TODO: CallSignature: CodeMirror */
/**
 * @record
 * @struct
 */
CodeMirror.AsyncLinter = function() {};

/* TODO: CallSignature: CodeMirror */
/**
 * @record
 * @struct
 */
CodeMirror.UpdateLintingCallback = function() {};

/* TODO: CallSignature: CodeMirror */
/**
 * @record
 * @struct
 */
CodeMirror.Annotation = function() {};
 /** @type {!CodeMirror.Position} */
CodeMirror.Annotation.prototype.from;
 /** @type {string} */
CodeMirror.Annotation.prototype.message;
 /** @type {string} */
CodeMirror.Annotation.prototype.severity;
 /** @type {!CodeMirror.Position} */
CodeMirror.Annotation.prototype.to;

/**
 * A function that calculates either a two-way or three-way merge between different sets of content.
 * @param {!HTMLElement} element
 * @param {!CodeMirror.MergeView.MergeViewEditorConfiguration=} options
 * @return {!CodeMirror.MergeView.MergeViewEditor}
 */
CodeMirror.MergeView = function(element, options) {};
/**
 * @extends {CodeMirror.EditorConfiguration}
 * @record
 * @struct
 */
CodeMirror.MergeView.MergeViewEditorConfiguration = function() {};
 /** @type {boolean} */
CodeMirror.MergeView.MergeViewEditorConfiguration.prototype.allowEditingOriginals;
 /** @type {(number|boolean)} */
CodeMirror.MergeView.MergeViewEditorConfiguration.prototype.collapseIdentical;
 /** @type {string} */
CodeMirror.MergeView.MergeViewEditorConfiguration.prototype.connect;
 /** @type {?} */
CodeMirror.MergeView.MergeViewEditorConfiguration.prototype.orig;
 /** @type {?} */
CodeMirror.MergeView.MergeViewEditorConfiguration.prototype.origLeft;
 /** @type {?} */
CodeMirror.MergeView.MergeViewEditorConfiguration.prototype.origRight;
 /** @type {boolean} */
CodeMirror.MergeView.MergeViewEditorConfiguration.prototype.revertButtons;
 /** @type {boolean} */
CodeMirror.MergeView.MergeViewEditorConfiguration.prototype.showDifferences;

/**
 * Callback for when stretches of unchanged text are collapsed.
 * @param {!CodeMirror.MergeView.MergeViewEditor} mergeView
 * @param {number} line
 * @param {number} size
 * @param {!CodeMirror.TextMarker} mark
 * @return {void}
 */
CodeMirror.MergeView.MergeViewEditorConfiguration.prototype.onCollapse = function(mergeView, line, size, mark) {};
/**
 * @extends {CodeMirror.Editor}
 * @record
 * @struct
 */
CodeMirror.MergeView.MergeViewEditor = function() {};
 /** @type {!CodeMirror.MergeView.DiffView} */
CodeMirror.MergeView.MergeViewEditor.prototype.left;
 /** @type {!CodeMirror.MergeView.DiffView} */
CodeMirror.MergeView.MergeViewEditor.prototype.right;

/**
 * Returns the editor instance.
 * @return {!CodeMirror.Editor}
 */
CodeMirror.MergeView.MergeViewEditor.prototype.editor = function() {};

/**
 * @return {!CodeMirror.MergeView.MergeViewDiffChunk}
 */
CodeMirror.MergeView.MergeViewEditor.prototype.leftChunks = function() {};

/**
 * @return {!CodeMirror.Editor}
 */
CodeMirror.MergeView.MergeViewEditor.prototype.leftOriginal = function() {};

/**
 * @return {!CodeMirror.MergeView.MergeViewDiffChunk}
 */
CodeMirror.MergeView.MergeViewEditor.prototype.rightChunks = function() {};

/**
 * @return {!CodeMirror.Editor}
 */
CodeMirror.MergeView.MergeViewEditor.prototype.rightOriginal = function() {};

/**
 * Sets whether or not the merge view should show the differences between the editor views.
 * @param {boolean} showDifferences
 * @return {void}
 */
CodeMirror.MergeView.MergeViewEditor.prototype.setShowDifferences = function(showDifferences) {};
/**
 * @record
 * @struct
 */
CodeMirror.MergeView.MergeViewDiffChunk = function() {};
 /** @type {number} */
CodeMirror.MergeView.MergeViewDiffChunk.prototype.editFrom;
 /** @type {number} */
CodeMirror.MergeView.MergeViewDiffChunk.prototype.editTo;
 /** @type {number} */
CodeMirror.MergeView.MergeViewDiffChunk.prototype.origFrom;
 /** @type {number} */
CodeMirror.MergeView.MergeViewDiffChunk.prototype.origTo;
/**
 * @record
 * @struct
 */
CodeMirror.MergeView.DiffView = function() {};

/**
 * Forces the view to reload.
 * @return {function(string): void}
 */
CodeMirror.MergeView.DiffView.prototype.forceUpdate = function() {};

/**
 * Sets whether or not the merge view should show the differences between the editor views.
 * @param {boolean} showDifferences
 * @return {void}
 */
CodeMirror.MergeView.DiffView.prototype.setShowDifferences = function(showDifferences) {};
