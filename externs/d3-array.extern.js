/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/d3-array/index.d.ts:

/** @typedef {(string|number|boolean|!Date)} */
var Primitive;
/**
 * @record
 * @struct
 */
function Numeric() {}

/**
 * @return {number}
 */
Numeric.prototype.valueOf = function() {};

/**
 * Return the maximum value in the array of strings using natural order.
 * Return the maximum value in the array of numbers using natural order.
 * Return the maximum value in the array using natural order and a projection function to map values to strings.
 * Return the maximum value in the array using natural order and a projection function to map values to easily-sorted values.
 * @template T, U
 * @param {!ArrayLike<string>|!ArrayLike<?>} array
 * @param {?=} accessor
 * @return {string|?}
 */
function max(array, accessor) {}

/**
 * Return the minimum value in the array using natural order.
 * Return the minimum value in the array using natural order.
 * Return the minimum value in the array using natural order.
 * Return the minimum value in the array using natural order.
 * @template T, U
 * @param {!ArrayLike<string>|!ArrayLike<?>} array
 * @param {?=} accessor
 * @return {string|?}
 */
function min(array, accessor) {}

/**
 * Return the min and max simultaneously.
 * Return the min and max simultaneously.
 * Return the min and max simultaneously.
 * Return the min and max simultaneously.
 * @template T, U
 * @param {!ArrayLike<string>|!ArrayLike<?>} array
 * @param {?=} accessor
 * @return {!Array<?>}
 */
function extent(array, accessor) {}

/**
 * Return the mean of an array of numbers
 * @template T
 * @param {!ArrayLike<?>} array
 * @param {?=} accessor
 * @return {number}
 */
function mean(array, accessor) {}

/**
 * Return the median of an array of numbers
 * @template T
 * @param {!ArrayLike<?>} array
 * @param {?=} accessor
 * @return {number}
 */
function median(array, accessor) {}

/**
 * Returns the p-quantile of an array of numbers
 * @template T
 * @param {!ArrayLike<?>} array
 * @param {number} p
 * @param {?=} accessor
 * @return {number}
 */
function quantile(array, p, accessor) {}

/**
 * Compute the sum of an array of numbers.
 * Compute the sum of an array, using the given accessor to convert values to numbers.
 * @template T
 * @param {!ArrayLike<?>} array
 * @param {?=} accessor
 * @return {number}
 */
function sum(array, accessor) {}

/**
 * Compute the standard deviation, defined as the square root of the bias-corrected variance, of the given array of numbers.
 * Compute the standard deviation, defined as the square root of the bias-corrected variance, of the given array,
 * using the given accessor to convert values to numbers.
 * @template T
 * @param {!ArrayLike<?>} array
 * @param {?=} accessor
 * @return {number}
 */
function deviation(array, accessor) {}

/**
 * Compute an unbiased estimator of the population variance of the given array of numbers.
 * Compute an unbiased estimator of the population variance of the given array,
 * using the given accessor to convert values to numbers.
 * @template T
 * @param {!ArrayLike<?>} array
 * @param {?=} accessor
 * @return {number}
 */
function variance(array, accessor) {}

/**
 * @template T
 * @param {!ArrayLike<number>|!ArrayLike<?>} array
 * @param {?=} comparator
 * @return {number}
 */
function scan(array, comparator) {}

/**
 * @param {!ArrayLike<number>|!ArrayLike<string>|!ArrayLike<!Date>} array
 * @param {number|string|!Date} x
 * @param {number=} lo
 * @param {number=} hi
 * @return {number}
 */
function bisectLeft(array, x, lo, hi) {}

/**
 * @param {!ArrayLike<number>|!ArrayLike<string>|!ArrayLike<!Date>} array
 * @param {number|string|!Date} x
 * @param {number=} lo
 * @param {number=} hi
 * @return {number}
 */
function bisectRight(array, x, lo, hi) {}
 /** @type {?} */
var bisect;
/**
 * @record
 * @struct
 */
function Bisector() {}

/**
 * @param {!ArrayLike<?>} array
 * @param {?} x
 * @param {number=} lo
 * @param {number=} hi
 * @return {number}
 */
Bisector.prototype.left = function(array, x, lo, hi) {};

/**
 * @param {!ArrayLike<?>} array
 * @param {?} x
 * @param {number=} lo
 * @param {number=} hi
 * @return {number}
 */
Bisector.prototype.right = function(array, x, lo, hi) {};

/**
 * @template T, U
 * @param {?} comparator_or_accessor
 * @return {?}
 */
function bisector(comparator_or_accessor) {}

/**
 * Compares two primitive values for sorting (in ascending order).
 * @param {(string|number|boolean|!Date)} a
 * @param {(string|number|boolean|!Date)} b
 * @return {number}
 */
function ascending(a, b) {}

/**
 * Compares two primitive values for sorting (in ascending order).
 * @param {(string|number|boolean|!Date)} a
 * @param {(string|number|boolean|!Date)} b
 * @return {number}
 */
function descending(a, b) {}

/**
 * Returns the Cartesian product of the two arrays a and b.
 * For each element i in the specified array a and each element j in the specified array b, in order,
 * it creates a two-element array for each pair.
 * 
 * Returns the Cartesian product of the two arrays a and b.
 * For each element i in the specified array a and each element j in the specified array b, in order,
 * invokes the specified reducer function passing the element i and element j.
 * 
 * @template S, T, U
 * @param {!ArrayLike<?>} a First input array.
 * @param {!ArrayLike<?>} b Second input array.
 * @param {?=} reducer A reducer function taking as input an element from "a" and "b" and returning a reduced value.
 * @return {!Array<!Array<?>>|!Array<?>}
 */
function cross(a, b, reducer) {}

/**
 * Merges the specified arrays into a single array.
 * @template T
 * @param {!ArrayLike<!ArrayLike<?>>} arrays
 * @return {!Array<?>}
 */
function merge(arrays) {}

/**
 * For each adjacent pair of elements in the specified array, returns a new array of tuples of elements i and i - 1.
 * Returns the empty array if the input array has fewer than two elements.
 * 
 * For each adjacent pair of elements in the specified array, in order, invokes the specified reducer function passing the element i and element i - 1.
 * Returns the resulting array of pair-wise reduced elements.
 * Returns the empty array if the input array has fewer than two elements.
 * 
 * @template T, U
 * @param {!ArrayLike<?>} array Array of input elements
 * @param {?=} reducer A reducer function taking as input to adjecent elements of the input array and returning a reduced value.
 * @return {!Array<!Array<?>>|!Array<?>}
 */
function pairs(array, reducer) {}

/**
 * Given the specified array, return an array corresponding to the list of indices in 'keys'.
 * Given the specified object, return an array corresponding to the list of property names in 'keys'.
 * @template T
 * @param {?} array_or_object
 * @param {!ArrayLike<number>|!ArrayLike<string>} keys
 * @return {!Array<?>}
 */
function permute(array_or_object, keys) {}

/**
 * Generates a 0-based numeric sequence. The output range does not include 'stop'.
 * Generates a numeric sequence starting from the given start and stop values. 'step' defaults to 1. The output range does not include 'stop'.
 * @param {number} stop_or_start
 * @param {number=} stop
 * @param {number=} step
 * @return {!Array<number>}
 */
function range(stop_or_start, stop, step) {}

/**
 * Randomizes the order of the specified array using the Fisher–Yates shuffle.
 * @template T
 * @param {!Array<?>|!Int8Array|!Uint8Array|!Uint8ClampedArray|!Int16Array|!Uint16Array|!Int32Array|!Uint32Array|!Float32Array|!Float64Array} array
 * @param {number=} lo
 * @param {number=} hi
 * @return {!Array<?>|!Int8Array|!Uint8Array|!Uint8ClampedArray|!Int16Array|!Uint16Array|!Int32Array|!Uint32Array|!Float32Array|!Float64Array}
 */
function shuffle(array, lo, hi) {}

/**
 * Generate an array of approximately count + 1 uniformly-spaced, nicely-rounded values between start and stop (inclusive).
 * Each value is a power of ten multiplied by 1, 2 or 5. See also d3.tickIncrement, d3.tickStep and linear.ticks.
 * 
 * Ticks are inclusive in the sense that they may include the specified start and stop values if (and only if) they are exact,
 * nicely-rounded values consistent with the inferred step. More formally, each returned tick t satisfies start ≤ t and t ≤ stop.
 * 
 * @param {number} start Start value for ticks
 * @param {number} stop Stop value for ticks
 * @param {number} count count + 1 is the approximate number of ticks to be returned by d3.ticks.
 * @return {!Array<number>}
 */
function ticks(start, stop, count) {}

/**
 * Returns the difference between adjacent tick values if the same arguments were passed to d3.ticks:
 * a nicely-rounded value that is a power of ten multiplied by 1, 2 or 5.
 * 
 * Like d3.tickStep, except requires that start is always less than or equal to step, and if the tick step for the given start,
 * stop and count would be less than one, returns the negative inverse tick step instead.
 * 
 * This method is always guaranteed to return an integer, and is used by d3.ticks to avoid guarantee that the returned tick values
 * are represented as precisely as possible in IEEE 754 floating point.
 * 
 * @param {number} start Start value for ticks
 * @param {number} stop Stop value for ticks
 * @param {number} count count + 1 is the approximate number of ticks to be returned by d3.ticks.
 * @return {number}
 */
function tickIncrement(start, stop, count) {}

/**
 * Returns the difference between adjacent tick values if the same arguments were passed to d3.ticks:
 * a nicely-rounded value that is a power of ten multiplied by 1, 2 or 5.
 * 
 * Note that due to the limited precision of IEEE 754 floating point, the returned value may not be exact decimals;
 * use d3-format to format numbers for human consumption.
 * 
 * @param {number} start Start value for ticks
 * @param {number} stop Stop value for ticks
 * @param {number} count count + 1 is the approximate number of ticks to be returned by d3.ticks.
 * @return {number}
 */
function tickStep(start, stop, count) {}

/**
 * Transpose a matrix provided in Array of Arrays format.
 * @template T
 * @param {!ArrayLike<!ArrayLike<?>>} matrix
 * @return {!Array<!Array<?>>}
 */
function transpose(matrix) {}

/**
 * Returns an array of arrays, where the ith array contains the ith element from each of the argument arrays.
 * The returned array is truncated in length to the shortest array in arrays. If arrays contains only a single array, the returned array
 * contains one-element arrays. With no arguments, the returned array is empty.
 * @template T
 * @param {...!ArrayLike<?>} arrays
 * @return {!Array<!Array<?>>}
 */
function zip(arrays) {}
/**
 * @record
 * @struct
 */
function Bin() {}
 /** @type {?} */
Bin.prototype.x0;
 /** @type {?} */
Bin.prototype.x1;

/** @typedef {?} */
var ThresholdCountGenerator;

/** @typedef {?} */
var ThresholdArrayGenerator;
/**
 * @record
 * @struct
 */
function HistogramGenerator() {}

/* TODO: CallSignature:  */

/**
 * @param {?=} valueAccessor
 * @return {?}
 */
HistogramGenerator.prototype.value = function(valueAccessor) {};

/**
 * @param {!Array<?>|?=} domain_or_domainAccessor
 * @return {?}
 */
HistogramGenerator.prototype.domain = function(domain_or_domainAccessor) {};

/**
 * Divide the domain uniformly into approximately count bins. IMPORTANT: This threshold
 * setting approach only works, when the materialized values are numbers!
 * 
 * Any threshold values outside the domain are ignored. The first bin.x0 is always equal to the minimum domain value,
 * and the last bin.x1 is always equal to the maximum domain value.
 * 
 * Set a threshold accessor function, which returns the desired number of bins.
 * Divides the domain uniformly into approximately count bins. IMPORTANT: This threshold
 * setting approach only works, when the materialized values are numbers!
 * 
 * Any threshold values outside the domain are ignored. The first bin.x0 is always equal to the minimum domain value,
 * and the last bin.x1 is always equal to the maximum domain value.
 * 
 * Set the array of values to be used as thresholds in determining the bins.
 * 
 * Any threshold values outside the domain are ignored. The first bin.x0 is always equal to the minimum domain value,
 * and the last bin.x1 is always equal to the maximum domain value.
 * 
 * Set a threshold accessor function, which returns the array of values to be used as
 * thresholds in determining the bins.
 * 
 * Any threshold values outside the domain are ignored. The first bin.x0 is always equal to the minimum domain value,
 * and the last bin.x1 is always equal to the maximum domain value.
 * 
 * @param {number|?|!ArrayLike<?>=} count_or_thresholds The desired number of uniform bins. / A function which accepts as arguments the array of materialized values, and
 * optionally the domain minimum and maximum. The function calcutates and returns the suggested
 * number of bins. / Array of threshold values used for binning. The elements must
 * be of the same type as the materialized values of the histogram. / A function which accepts as arguments the array of materialized values, and
 * optionally the domain minimum and maximum. The function calcutates and returns the array of values to be used as
 * thresholds in determining the bins.
 * @return {?}
 */
HistogramGenerator.prototype.thresholds = function(count_or_thresholds) {};

/**
 * @template Datum, Value
 * @return {?}
 */
function histogram() {}

/**
 * @param {!ArrayLike<number>} values
 * @param {number} min
 * @param {number} max
 * @return {number}
 */
function thresholdFreedmanDiaconis(values, min, max) {}

/**
 * @param {!ArrayLike<number>} values
 * @param {number} min
 * @param {number} max
 * @return {number}
 */
function thresholdScott(values, min, max) {}

/**
 * @param {!ArrayLike<number>} values
 * @return {number}
 */
function thresholdSturges(values) {}
