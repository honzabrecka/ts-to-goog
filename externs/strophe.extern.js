/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/strophe/index.d.ts:
/** @const */
var Strophe = {};
 /** @type {string} */
Strophe.VERSION;
 /** @type {{HTTPBIND: string, BOSH: string, CLIENT: string, AUTH: string, ROSTER: string, PROFILE: string, DISCO_INFO: string, DISCO_ITEMS: string, MUC: string, SASL: string, STREAM: string, FRAMING: string, BIND: string, SESSION: string, VERSION: string, STANZAS: string, XHTML_IM: string, XHTML: string}} */
Strophe.NS;

/** @const */
Strophe.Status = {};
/** @const {number} */
Strophe.Status.ERROR;
/** @const {number} */
Strophe.Status.CONNECTING;
/** @const {number} */
Strophe.Status.CONNFAIL;
/** @const {number} */
Strophe.Status.AUTHENTICATING;
/** @const {number} */
Strophe.Status.AUTHFAIL;
/** @const {number} */
Strophe.Status.CONNECTED;
/** @const {number} */
Strophe.Status.DISCONNECTED;
/** @const {number} */
Strophe.Status.DISCONNECTING;
/** @const {number} */
Strophe.Status.ATTACHED;
/** @const {number} */
Strophe.Status.REDIRECT;
/** @const {number} */
Strophe.Status.CONNTIMEOUT;

/** @const */
Strophe.LogLevel = {};
/** @const {number} */
Strophe.LogLevel.DEBUG;
/** @const {number} */
Strophe.LogLevel.INFO;
/** @const {number} */
Strophe.LogLevel.WARN;
/** @const {number} */
Strophe.LogLevel.ERROR;
/** @const {number} */
Strophe.LogLevel.FATAL;

/**
 * Function: addNamespace
 *  This function is used to extend the current namespaces in
 *  Strophe.NS.  It takes a key and a value with the key being the
 *  name of the new namespace, with its actual value.
 *  For example:
 *  Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
 * 
 *  Parameters:
 *    (String) name - The name under which the namespace will be
 *      referenced under Strophe.NS
 *    (String) value - The actual namespace.
 * @param {string} name
 * @param {string} value
 * @return {void}
 */
Strophe.addNamespace = function(name, value) {};

/**
 * Function: forEachChild
 *  Map a function over some or all child elements of a given element.
 * 
 *  This is a small convenience function for mapping a function over
 *  some or all of the children of an element.  If elemName is null, all
 *  children will be passed to the function, otherwise only children
 *  whose tag names match elemName will be passed.
 * 
 *  Parameters:
 *    (XMLElement) elem - The element to operate on.
 *    (String) elemName - The child element tag name filter.
 *    (Function) func - The function to apply to each child.  This
 *      function should take a single argument, a DOM element.
 * @param {!Element} elem
 * @param {string} elemName
 * @param {function(!Element): ?} func
 * @return {void}
 */
Strophe.forEachChild = function(elem, elemName, func) {};

/**
 * Function: isTagEqual
 *  Compare an element's tag name with a string.
 * 
 *  This function is case sensitive.
 * 
 *  Parameters:
 *    (XMLElement) el - A DOM element.
 *    (String) name - The element name.
 * 
 *  Returns:
 *    true if the element's tag name matches _el_, and false
 *    otherwise.
 * @param {!Element} el
 * @param {string} name
 * @return {boolean}
 */
Strophe.isTagEqual = function(el, name) {};

/**
 * Function: xmlGenerator
 *  Get the DOM document to generate elements.
 * 
 *  Returns:
 *    The currently used DOM document.
 * @return {!Document}
 */
Strophe.xmlGenerator = function() {};

/**
 * Function: xmlElement
 *  Create an XML DOM element.
 * 
 *  This function creates an XML DOM element correctly across all
 *  implementations. Note that these are not HTML DOM elements, which
 *  aren't appropriate for XMPP stanzas.
 * 
 *  Parameters:
 *    (String) name - The name for the element.
 *    (Array|Object) attrs - An optional array or object containing
 *      key/value pairs to use as element attributes. The object should
 *      be in the format {'key': 'value'} or {key: 'value'}. The array
 *      should have the format [['key1', 'value1'], ['key2', 'value2']].
 *    (String) text - The text child data for the element.
 * 
 *  Returns:
 *    A new XML DOM element.
 * @param {string} name
 * @param {?|string=} attrs_or_text
 * @param {string|?=} text_or_attrs
 * @return {!Element}
 */
Strophe.xmlElement = function(name, attrs_or_text, text_or_attrs) {};

/**
 * @param {string} text
 * @return {string}
 */
Strophe.xmlescape = function(text) {};

/**
 * @param {string} text
 * @return {string}
 */
Strophe.xmlunescape = function(text) {};

/**
 * Function: xmlTextNode
 *  Creates an XML DOM text node.
 * 
 *  Provides a cross implementation version of document.createTextNode.
 * 
 *  Parameters:
 *    (String) text - The content of the text node.
 * 
 *  Returns:
 *    A new XML DOM text node.
 * @param {string} text
 * @return {!Text}
 */
Strophe.xmlTextNode = function(text) {};

/**
 * Function: xmlHtmlNode
 *  Creates an XML DOM html node.
 * 
 *  Parameters:
 *    (String) html - The content of the html node.
 * 
 *  Returns:
 *    A new XML DOM text node.
 * @param {string} html
 * @return {!Document}
 */
Strophe.xmlHtmlNode = function(html) {};

/**
 * Function: getText
 *  Get the concatenation of all text children of an element.
 * 
 *  Parameters:
 *    (XMLElement) elem - A DOM element.
 * 
 *  Returns:
 *    A String with the concatenated text of all text element children.
 * @param {!Element} elem
 * @return {string}
 */
Strophe.getText = function(elem) {};

/**
 * Function: copyElement
 *  Copy an XML DOM element.
 * 
 *  This function copies a DOM element and all its descendants and returns
 *  the new copy.
 * 
 *  Parameters:
 *    (XMLElement) elem - A DOM element.
 * 
 *  Returns:
 *    A new, copied DOM element tree.
 * @param {!Element} elem
 * @return {!Element}
 */
Strophe.copyElement = function(elem) {};

/**
 * Function: createHtml
 *  Copy an HTML DOM element into an XML DOM.
 * 
 *  This function copies a DOM element and all its descendants and returns
 *  the new copy.
 * 
 *  Parameters:
 *    (Element) elem - A DOM element.
 * 
 *  Returns:
 *    A new, copied DOM element tree.
 * @param {!Element} elem
 * @return {!Element}
 */
Strophe.createHtml = function(elem) {};

/**
 * Function: escapeNode
 *  Escape the node part (also called local part) of a JID.
 * 
 *  Parameters:
 *    (String) node - A node (or local part).
 * 
 *  Returns:
 *    An escaped node (or local part).
 * @param {string} node
 * @return {string}
 */
Strophe.escapeNode = function(node) {};

/**
 * Function: unescapeNode
 *  Unescape a node part (also called local part) of a JID.
 * 
 *  Parameters:
 *    (String) node - A node (or local part).
 * 
 *  Returns:
 *    An unescaped node (or local part).
 * @param {string} node
 * @return {string}
 */
Strophe.unescapeNode = function(node) {};

/**
 * Function: getNodeFromJid
 *  Get the node portion of a JID String.
 * 
 *  Parameters:
 *    (String) jid - A JID.
 * 
 *  Returns:
 *    A String containing the node.
 * @param {string} jid
 * @return {string}
 */
Strophe.getNodeFromJid = function(jid) {};

/**
 * Function: getDomainFromJid
 *  Get the domain portion of a JID String.
 * 
 *  Parameters:
 *    (String) jid - A JID.
 * 
 *  Returns:
 *    A String containing the domain.
 * @param {string} jid
 * @return {string}
 */
Strophe.getDomainFromJid = function(jid) {};

/**
 * Function: getResourceFromJid
 *  Get the resource portion of a JID String.
 * 
 *  Parameters:
 *    (String) jid - A JID.
 * 
 *  Returns:
 *    A String containing the resource.
 * @param {string} jid
 * @return {string}
 */
Strophe.getResourceFromJid = function(jid) {};

/**
 * Function: getBareJidFromJid
 *  Get the bare JID from a JID String.
 * 
 *  Parameters:
 *    (String) jid - A JID.
 * 
 *  Returns:
 *    A String containing the bare JID.
 * @param {string} jid
 * @return {string}
 */
Strophe.getBareJidFromJid = function(jid) {};

/**
 * Function: log
 *  User overrideable logging function.
 * 
 *  This function is called whenever the Strophe library calls any
 *  of the logging functions.  The default implementation of this
 *  function does nothing.  If client code wishes to handle the logging
 *  messages, it should override this with
 *  > Strophe.log = function (level, msg) {
 *  >   (user code here)
 *  > };
 * 
 *  Please note that data sent and received over the wire is logged
 *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().
 * 
 *  The different levels and their meanings are
 * 
 *    DEBUG - Messages useful for debugging purposes.
 *    INFO - Informational messages.  This is mostly information like
 *      'disconnect was called' or 'SASL auth succeeded'.
 *    WARN - Warnings about potential problems.  This is mostly used
 *      to report transient connection errors like request timeouts.
 *    ERROR - Some error occurred.
 *    FATAL - A non-recoverable fatal error occurred.
 * 
 *  Parameters:
 *    (Integer) level - The log level of the log message.  This will
 *      be one of the values in Strophe.LogLevel.
 *    (String) msg - The log message.
 * @param {Strophe.LogLevel} level
 * @param {string} msg
 * @return {void}
 */
Strophe.log = function(level, msg) {};

/**
 * Functions: debug, info, warn, error
 *  Log a message at the appropriate Strophe.LogLevel
 * 
 *  Parameters:
 *    (String) msg - The log message.
 * @param {string} msg
 * @return {void}
 */
Strophe.debug = function(msg) {};

/**
 * @param {string} msg
 * @return {void}
 */
Strophe.info = function(msg) {};

/**
 * @param {string} msg
 * @return {void}
 */
Strophe.warn = function(msg) {};

/**
 * @param {string} msg
 * @return {void}
 */
Strophe.error = function(msg) {};

/**
 * @param {string} msg
 * @return {void}
 */
Strophe.fatal = function(msg) {};

/**
 * Function: serialize
 *  Render a DOM element and all descendants to a String.
 * 
 *  Parameters:
 *    (XMLElement) elem - A DOM element.
 * 
 *  Returns:
 *    The serialized element tree as a String.
 * @param {(!Element|!Strophe.Builder)} elem
 * @return {string}
 */
Strophe.serialize = function(elem) {};

/**
 * Function: addConnectionPlugin
 *  Extends the Strophe.Connection object with the given plugin.
 * 
 *  Parameters:
 *    (String) name - The name of the extension.
 *    (Object) ptype - The plugin's prototype.
 * @param {string} name
 * @param {?} ptype
 * @return {void}
 */
Strophe.addConnectionPlugin = function(name, ptype) {};

/**
 * @constructor
 * @struct
 * Constructor: Strophe.Builder
 *  Create a Strophe.Builder object.
 * 
 *  The attributes should be passed in object notation.  For example
 *  > var b = new Builder('message', {to: 'you', from: 'me'});
 *  or
 *  > var b = new Builder('messsage', {'xml:lang': 'en'});
 * 
 *  Parameters:
 *    (String) name - The name of the root element.
 *    (Object) attrs - The attributes for the root element in object notation.
 * 
 *  Returns:
 *    A new Strophe.Builder.
 * @param {string} name
 * @param {?=} attrs
 */
Strophe.Builder = function(name, attrs) {};

/**
 * Function: tree
 *  Return the DOM tree.
 * 
 *  This function returns the current DOM tree as an element object.  This
 *  is suitable for passing to functions like Strophe.Connection.send().
 * 
 *  Returns:
 *    The DOM tree as a element object.
 * @return {!Element}
 */
Strophe.Builder.prototype.tree = function() {};

/**
 * Function: toString
 *  Serialize the DOM tree to a String.
 * 
 *  This function returns a string serialization of the current DOM
 *  tree.  It is often used internally to pass data to a
 *  Strophe.Request object.
 * 
 *  Returns:
 *    The serialized DOM tree in a String.
 * @return {string}
 */
Strophe.Builder.prototype.toString = function() {};

/**
 * Function: up
 *  Make the current parent element the new current element.
 * 
 *  This function is often used after c() to traverse back up the tree.
 *  For example, to add two children to the same element
 *  > builder.c('child1', {}).up().c('child2', {});
 * 
 *  Returns:
 *    The Stophe.Builder object.
 * @return {!Strophe.Builder}
 */
Strophe.Builder.prototype.up = function() {};

/**
 * Function: attrs
 *  Add or modify attributes of the current element.
 * 
 *  The attributes should be passed in object notation.  This function
 *  does not move the current element pointer.
 * 
 *  Parameters:
 *    (Object) moreattrs - The attributes to add/modify in object notation.
 * 
 *  Returns:
 *    The Strophe.Builder object.
 * @param {?} moreattrs
 * @return {!Strophe.Builder}
 */
Strophe.Builder.prototype.attrs = function(moreattrs) {};

/**
 * Function: c
 *  Add a child to the current element and make it the new current
 *  element.
 * 
 *  This function moves the current element pointer to the child,
 *  unless text is provided.  If you need to add another child, it
 *  is necessary to use up() to go back to the parent in the tree.
 * 
 *  Parameters:
 *    (String) name - The name of the child.
 *    (Object) attrs - The attributes of the child in object notation.
 *    (String) text - The text to add to the child.
 * 
 *  Returns:
 *    The Strophe.Builder object.
 * @param {string} name
 * @param {?=} attrs
 * @param {string=} text
 * @return {!Strophe.Builder}
 */
Strophe.Builder.prototype.c = function(name, attrs, text) {};

/**
 * Function: cnode
 *  Add a child to the current element and make it the new current
 *  element.
 * 
 *  This function is the same as c() except that instead of using a
 *  name and an attributes object to create the child it uses an
 *  existing DOM element object.
 * 
 *  Parameters:
 *    (XMLElement) elem - A DOM element.
 * 
 *  Returns:
 *    The Strophe.Builder object.
 * @param {!Node} elem
 * @return {!Strophe.Builder}
 */
Strophe.Builder.prototype.cnode = function(elem) {};

/**
 * Function: t
 *  Add a child text element.
 * 
 *  This *does not* make the child the new current element since there
 *  are no children of text elements.
 * 
 *  Parameters:
 *    (String) text - The text data to append to the current element.
 * 
 *  Returns:
 *    The Strophe.Builder object.
 * @param {string} text
 * @return {!Strophe.Builder}
 */
Strophe.Builder.prototype.t = function(text) {};

/**
 * Function: h
 *  Replace current element contents with the HTML passed in.
 * 
 *  This *does not* make the child the new current element
 * 
 *  Parameters:
 *    (String) html - The html to insert as contents of current element.
 * 
 *  Returns:
 *    The Strophe.Builder object.
 * @param {string} html
 * @return {!Strophe.Builder}
 */
Strophe.Builder.prototype.h = function(html) {};
/**
 * @record
 * @struct
 */
Strophe.ConnectionOptions = function() {};
 /** @type {boolean} */
Strophe.ConnectionOptions.prototype.keepalive;
 /** @type {string} */
Strophe.ConnectionOptions.prototype.protocol;
 /** @type {boolean} */
Strophe.ConnectionOptions.prototype.sync;

/**
 * @constructor
 * @struct
 * Constructor: Strophe.Connection
 *  Create and initialize a Strophe.Connection object.
 * 
 *  The transport-protocol for this connection will be chosen automatically
 *  based on the given service parameter. URLs starting with "ws://" or
 *  "wss://" will use WebSockets, URLs starting with "http://", "https://"
 *  or without a protocol will use BOSH.
 * 
 *  To make Strophe connect to the current host you can leave out the protocol
 *  and host part and just pass the path, e.g.
 * 
 *  > var conn = new Strophe.Connection("/http-bind/");
 * 
 *  WebSocket options:
 * 
 *  If you want to connect to the current host with a WebSocket connection you
 *  can tell Strophe to use WebSockets through a "protocol" attribute in the
 *  optional options parameter. Valid values are "ws" for WebSocket and "wss"
 *  for Secure WebSocket.
 *  So to connect to "wss://CURRENT_HOSTNAME/xmpp-websocket" you would call
 * 
 *  > var conn = new Strophe.Connection("/xmpp-websocket/", {protocol: "wss"});
 * 
 *  Note that relative URLs _NOT_ starting with a "/" will also include the path
 *  of the current site.
 * 
 *  Also because downgrading security is not permitted by browsers, when using
 *  relative URLs both BOSH and WebSocket connections will use their secure
 *  variants if the current connection to the site is also secure (https).
 * 
 *  BOSH options:
 * 
 *  by adding "sync" to the options, you can control if requests will
 *  be made synchronously or not. The default behaviour is asynchronous.
 *  If you want to make requests synchronous, make "sync" evaluate to true:
 *  > var conn = new Strophe.Connection("/http-bind/", {sync: true});
 *  You can also toggle this on an already established connection:
 *  > conn.options.sync = true;
 * 
 * 
 *  Parameters:
 *    (String) service - The BOSH or WebSocket service URL.
 *    (Object) options - A hash of configuration options
 * 
 *  Returns:
 *    A new Strophe.Connection object.
 * @param {string} service
 * @param {!Strophe.ConnectionOptions=} options
 */
Strophe.Connection = function(service, options) {};
 /** @type {string} */
Strophe.Connection.prototype.jid;
 /** @type {string} */
Strophe.Connection.prototype.authzid;
 /** @type {string} */
Strophe.Connection.prototype.pass;
 /** @type {string} */
Strophe.Connection.prototype.authcid;
 /** @type {string} */
Strophe.Connection.prototype.domain;
 /** @type {string} */
Strophe.Connection.prototype.servtype;
 /** @type {number} */
Strophe.Connection.prototype.maxRetries;

/**
 * Function: reset
 *  Reset the connection.
 * 
 *  This function should be called after a connection is disconnected
 *  before that connection is reused.
 * @return {void}
 */
Strophe.Connection.prototype.reset = function() {};

/**
 * Function: pause
 *  Pause the request manager.
 * 
 *  This will prevent Strophe from sending any more requests to the
 *  server.  This is very useful for temporarily pausing
 *  BOSH-Connections while a lot of send() calls are happening quickly.
 *  This causes Strophe to send the data in a single request, saving
 *  many request trips.
 * @return {void}
 */
Strophe.Connection.prototype.pause = function() {};

/**
 * Function: resume
 *  Resume the request manager.
 * 
 *  This resumes after pause() has been called.
 * @return {void}
 */
Strophe.Connection.prototype.resume = function() {};

/**
 * Function: getUniqueId
 *  Generate a unique ID for use in <iq/> elements.
 * 
 *  All <iq/> stanzas are required to have unique id attributes.  This
 *  function makes creating these easy.  Each connection instance has
 *  a counter which starts from zero, and the value of this counter
 *  plus a colon followed by the suffix becomes the unique id. If no
 *  suffix is supplied, the counter is used as the unique id.
 * 
 *  Suffixes are used to make debugging easier when reading the stream
 *  data, and their use is recommended.  The counter resets to 0 for
 *  every new connection for the same reason.  For connections to the
 *  same server that authenticate the same way, all the ids should be
 *  the same, which makes it easy to see changes.  This is useful for
 *  automated testing as well.
 * 
 *  Parameters:
 *    (String) suffix - A optional suffix to append to the id.
 * 
 *  Returns:
 *    A unique string to be used for the id attribute.
 * @param {(string|number)=} suffix
 * @return {string}
 */
Strophe.Connection.prototype.getUniqueId = function(suffix) {};

/**
 * Function: connect
 *  Starts the connection process.
 * 
 *  As the connection process proceeds, the user supplied callback will
 *  be triggered multiple times with status updates.  The callback
 *  should take two arguments - the status code and the error condition.
 * 
 *  The status code will be one of the values in the Strophe.Status
 *  constants.  The error condition will be one of the conditions
 *  defined in RFC 3920 or the condition 'strophe-parsererror'.
 * 
 *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant
 *  for BOSH connections. Please see XEP 124 for a more detailed explanation
 *  of the optional parameters.
 * 
 *  Parameters:
 *    (String) jid - The user's JID.  This may be a bare JID,
 *      or a full JID.  If a node is not supplied, SASL ANONYMOUS
 *      authentication will be attempted.
 *    (String) pass - The user's password.
 *    (Function) callback - The connect callback function.
 *    (Integer) wait - The optional HTTPBIND wait value.  This is the
 *      time the server will wait before returning an empty result for
 *      a request.  The default setting of 60 seconds is recommended.
 *    (Integer) hold - The optional HTTPBIND hold value.  This is the
 *      number of connections the server will hold at one time.  This
 *      should almost always be set to 1 (the default).
 *    (String) route - The optional route value.
 * @param {string=} jid
 * @param {string=} pass
 * @param {function(Strophe.Status, string): ?=} callback
 * @param {number=} wait
 * @param {number=} hold
 * @param {string=} route
 * @return {void}
 */
Strophe.Connection.prototype.connect = function(jid, pass, callback, wait, hold, route) {};

/**
 * Function: restore
 * Attempt to restore a cached BOSH session.
 * 
 * This function is only useful in conjunction with providing the
 * “keepalive”:true option when instantiating a new Strophe.Connection.
 * When “keepalive” is set to true, Strophe will cache the BOSH tokens
 * RID (Request ID) and SID (Session ID) and then when this function is called,
 * it will attempt to restore the session from those cached tokens.
 * This function must therefore be called instead of connect or attach.
 * For an example on how to use it, please see examples/restore.js
 * 
 * Parameters:
 *    (String) jid - The user’s JID.  This may be a bare JID or a full JID.
 *    (Function) callback - The connect callback function.
 *    (Integer) wait - The optional HTTPBIND wait value.
 *      This is the time the server will wait before returning an empty result for a request.
 *      The default setting of 60 seconds is recommended.
 *    (Integer) hold - The optional HTTPBIND hold value.
 *      This is the number of connections the server will hold at one time.
 *      This should almost always be set to 1 (the default).
 *    (Integer) wind - The optional HTTBIND window value.
 *      This is the allowed range of request ids that are valid.
 *      The default is 5.
 * @param {string=} jid
 * @param {function(Strophe.Status, string): ?=} callback
 * @param {number=} wait
 * @param {number=} hold
 * @param {string=} route
 * @return {void}
 */
Strophe.Connection.prototype.restore = function(jid, callback, wait, hold, route) {};

/**
 * Function: attach
 *  Attach to an already created and authenticated BOSH session.
 * 
 *  This function is provided to allow Strophe to attach to BOSH
 *  sessions which have been created externally, perhaps by a Web
 *  application.  This is often used to support auto-login type features
 *  without putting user credentials into the page.
 * 
 *  Parameters:
 *    (String) jid - The full JID that is bound by the session.
 *    (String) sid - The SID of the BOSH session.
 *    (String) rid - The current RID of the BOSH session.  This RID
 *      will be used by the next request.
 *    (Function) callback The connect callback function.
 *    (Integer) wait - The optional HTTPBIND wait value.  This is the
 *      time the server will wait before returning an empty result for
 *      a request.  The default setting of 60 seconds is recommended.
 *      Other settings will require tweaks to the Strophe.TIMEOUT value.
 *    (Integer) hold - The optional HTTPBIND hold value.  This is the
 *      number of connections the server will hold at one time.  This
 *      should almost always be set to 1 (the default).
 *    (Integer) wind - The optional HTTBIND window value.  This is the
 *      allowed range of request ids that are valid.  The default is 5.
 * @param {string} jid
 * @param {string} sid
 * @param {string} rid
 * @param {function(Strophe.Status, string): ?=} callback
 * @param {number=} wait
 * @param {number=} hold
 * @param {number=} wind
 * @return {void}
 */
Strophe.Connection.prototype.attach = function(jid, sid, rid, callback, wait, hold, wind) {};

/**
 * Function: xmlInput
 *  User overrideable function that receives XML data coming into the
 *  connection.
 * 
 *  The default function does nothing.  User code can override this with
 *  > Strophe.Connection.xmlInput = function (elem) {
 *  >   (user code)
 *  > };
 * 
 *  Due to limitations of current Browsers' XML-Parsers the opening and closing
 *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
 * 
 *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
 *  <Strophe.Bosh.strip> if you want to strip this tag.
 * 
 *  Parameters:
 *    (XMLElement) elem - The XML data received by the connection.
 * @param {!Element} elem
 * @return {void}
 */
Strophe.Connection.prototype.xmlInput = function(elem) {};

/**
 * Function: xmlOutput
 *  User overrideable function that receives XML data sent to the
 *  connection.
 * 
 *  The default function does nothing.  User code can override this with
 *  > Strophe.Connection.xmlOutput = function (elem) {
 *  >   (user code)
 *  > };
 * 
 *  Due to limitations of current Browsers' XML-Parsers the opening and closing
 *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
 * 
 *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
 *  <Strophe.Bosh.strip> if you want to strip this tag.
 * 
 *  Parameters:
 *    (XMLElement) elem - The XMLdata sent by the connection.
 * @param {!Element} elem
 * @return {void}
 */
Strophe.Connection.prototype.xmlOutput = function(elem) {};

/**
 * Function: rawInput
 *  User overrideable function that receives raw data coming into the
 *  connection.
 * 
 *  The default function does nothing.  User code can override this with
 *  > Strophe.Connection.rawInput = function (data) {
 *  >   (user code)
 *  > };
 * 
 *  Parameters:
 *    (String) data - The data received by the connection.
 * @param {string} data
 * @return {void}
 */
Strophe.Connection.prototype.rawInput = function(data) {};

/**
 * Function: rawOutput
 *  User overrideable function that receives raw data sent to the
 *  connection.
 * 
 *  The default function does nothing.  User code can override this with
 *  > Strophe.Connection.rawOutput = function (data) {
 *  >   (user code)
 *  > };
 * 
 *  Parameters:
 *    (String) data - The data sent by the connection.
 * @param {string} data
 * @return {void}
 */
Strophe.Connection.prototype.rawOutput = function(data) {};

/**
 * Function: send
 *  Send a stanza.
 * 
 *  This function is called to push data onto the send queue to
 *  go out over the wire.  Whenever a request is sent to the BOSH
 *  server, all pending data is sent and the queue is flushed.
 * 
 *  Parameters:
 *    (XMLElement |
 *     [XMLElement] |
 *     Strophe.Builder) elem - The stanza to send.
 * @param {(!Element|!Strophe.Builder|!Array<!Element>)} elem
 * @return {void}
 */
Strophe.Connection.prototype.send = function(elem) {};

/**
 * Function: flush
 *  Immediately send any pending outgoing data.
 * 
 *  Normally send() queues outgoing data until the next idle period
 *  (100ms), which optimizes network use in the common cases when
 *  several send()s are called in succession. flush() can be used to
 *  immediately send all pending data.
 * @return {void}
 */
Strophe.Connection.prototype.flush = function() {};

/**
 * Function: sendIQ
 *  Helper function to send IQ stanzas.
 * 
 *  Parameters:
 *    (XMLElement) elem - The stanza to send.
 *    (Function) callback - The callback function for a successful request.
 *    (Function) errback - The callback function for a failed or timed
 *      out request.  On timeout, the stanza will be null.
 *    (Integer) timeout - The time specified in milliseconds for a
 *      timeout to occur.
 * 
 *  Returns:
 *    The id used to send the IQ.
 * @param {(!Element|!Strophe.Builder)} elem
 * @param {function(!Element): ?=} callback
 * @param {function(!Element): ?=} errback
 * @param {number=} timeout
 * @return {string}
 */
Strophe.Connection.prototype.sendIQ = function(elem, callback, errback, timeout) {};

/**
 * Function: addTimedHandler
 *  Add a timed handler to the connection.
 * 
 *  This function adds a timed handler.  The provided handler will
 *  be called every period milliseconds until it returns false,
 *  the connection is terminated, or the handler is removed.  Handlers
 *  that wish to continue being invoked should return true.
 * 
 *  Because of method binding it is necessary to save the result of
 *  this function if you wish to remove a handler with
 *  deleteTimedHandler().
 * 
 *  Note that user handlers are not active until authentication is
 *  successful.
 * 
 *  Parameters:
 *    (Integer) period - The period of the handler.
 *    (Function) handler - The callback function.
 * 
 *  Returns:
 *    A reference to the handler that can be used to remove it.
 * @param {number} period
 * @param {function(): boolean} handler
 * @return {?}
 */
Strophe.Connection.prototype.addTimedHandler = function(period, handler) {};

/**
 * Function: deleteTimedHandler
 *  Delete a timed handler for a connection.
 * 
 *  This function removes a timed handler from the connection.  The
 *  handRef parameter is *not* the function passed to addTimedHandler(),
 *  but is the reference returned from addTimedHandler().
 * 
 *  Parameters:
 *    (Strophe.TimedHandler) handRef - The handler reference.
 * @param {?} handRef
 * @return {void}
 */
Strophe.Connection.prototype.deleteTimedHandler = function(handRef) {};

/**
 * Function: addHandler
 *  Add a stanza handler for the connection.
 * 
 *  This function adds a stanza handler to the connection.  The
 *  handler callback will be called for any stanza that matches
 *  the parameters.  Note that if multiple parameters are supplied,
 *  they must all match for the handler to be invoked.
 * 
 *  The handler will receive the stanza that triggered it as its argument.
 *  *The handler should return true if it is to be invoked again;
 *  returning false will remove the handler after it returns.*
 * 
 *  As a convenience, the ns parameters applies to the top level element
 *  and also any of its immediate children.  This is primarily to make
 *  matching /iq/query elements easy.
 * 
 *  The options argument contains handler matching flags that affect how
 *  matches are determined. Currently the only flag is matchBare (a
 *  boolean). When matchBare is true, the from parameter and the from
 *  attribute on the stanza will be matched as bare JIDs instead of
 *  full JIDs. To use this, pass {matchBare: true} as the value of
 *  options. The default value for matchBare is false.
 * 
 *  The return value should be saved if you wish to remove the handler
 *  with deleteHandler().
 * 
 *  Parameters:
 *    (Function) handler - The user callback.
 *    (String) ns - The namespace to match.
 *    (String) name - The stanza name to match.
 *    (String) type - The stanza type attribute to match.
 *    (String) id - The stanza id attribute to match.
 *    (String) from - The stanza from attribute to match.
 *    (String) options - The handler options
 * 
 *  Returns:
 *    A reference to the handler that can be used to remove it.
 * @param {function(!Element): boolean} handler
 * @param {string} ns
 * @param {string} name
 * @param {string=} type
 * @param {string=} id
 * @param {string=} from
 * @param {{matchBare: boolean}=} options
 * @return {?}
 */
Strophe.Connection.prototype.addHandler = function(handler, ns, name, type, id, from, options) {};

/**
 * Function: deleteHandler
 *  Delete a stanza handler for a connection.
 * 
 *  This function removes a stanza handler from the connection.  The
 *  handRef parameter is *not* the function passed to addHandler(),
 *  but is the reference returned from addHandler().
 * 
 *  Parameters:
 *    (Strophe.Handler) handRef - The handler reference.
 * @param {?} handRef
 * @return {void}
 */
Strophe.Connection.prototype.deleteHandler = function(handRef) {};

/**
 * Function: disconnect
 *  Start the graceful disconnection process.
 * 
 *  This function starts the disconnection process.  This process starts
 *  by sending unavailable presence and sending BOSH body of type
 *  terminate.  A timeout handler makes sure that disconnection happens
 *  even if the BOSH server does not respond.
 *  If the Connection object isn't connected, at least tries to abort all pending requests
 *  so the connection object won't generate successful requests (which were already opened).
 * 
 *  The user supplied connection callback will be notified of the
 *  progress as this process happens.
 * 
 *  Parameters:
 *    (String) reason - The reason the disconnect is occuring.
 * @param {string} reason
 * @return {void}
 */
Strophe.Connection.prototype.disconnect = function(reason) {};
/**
 * @record
 * @struct
 */
Strophe.SASLMechanism = function() {};
 /** @type {number} */
Strophe.SASLMechanism.prototype.priority;

/**
 *  Function: test
 *  Checks if mechanism able to run.
 *  To disable a mechanism, make this return false;
 * 
 *  To disable plain authentication run
 *  > Strophe.SASLPlain.test = function() {
 *  >   return false;
 *  > }
 * 
 *  See <SASL mechanisms> for a list of available mechanisms.
 * 
 *  Parameters:
 *    (Strophe.Connection) connection - Target Connection.
 * 
 *  Returns:
 *    (Boolean) If mechanism was able to run.
 * @param {!Strophe.Connection} connection
 * @return {boolean}
 */
Strophe.SASLMechanism.prototype.test = function(connection) {};
 /** @type {!Strophe.SASLMechanism} */
Strophe.SASLAnonymous;
 /** @type {!Strophe.SASLMechanism} */
Strophe.SASLPlain;
 /** @type {!Strophe.SASLMechanism} */
Strophe.SASLSHA1;
 /** @type {!Strophe.SASLMechanism} */
Strophe.SASLMD5;

/**
 * Function: $build
 *  Create a Strophe.Builder.
 *  This is an alias for 'new Strophe.Builder(name, attrs)'.
 * 
 *  Parameters:
 *    (String) name - The root element name.
 *    (Object) attrs - The attributes for the root element in object notation.
 * 
 *  Returns:
 *    A new Strophe.Builder object.
 * @param {string} name
 * @param {?=} attrs
 * @return {!Strophe.Builder}
 */
function $build(name, attrs) {}

/**
 * Function: $msg
 *  Create a Strophe.Builder with a <message/> element as the root.
 * 
 *  Parmaeters:
 *    (Object) attrs - The <message/> element attributes in object notation.
 * 
 *  Returns:
 *    A new Strophe.Builder object.
 * @param {?=} attrs
 * @return {!Strophe.Builder}
 */
function $msg(attrs) {}

/**
 * Function: $iq
 *  Create a Strophe.Builder with an <iq/> element as the root.
 * 
 *  Parameters:
 *    (Object) attrs - The <iq/> element attributes in object notation.
 * 
 *  Returns:
 *    A new Strophe.Builder object.
 * @param {?=} attrs
 * @return {!Strophe.Builder}
 */
function $iq(attrs) {}

/**
 * Function: $pres
 *  Create a Strophe.Builder with a <presence/> element as the root.
 * 
 *  Parameters:
 *    (Object) attrs - The <presence/> element attributes in object notation.
 * 
 *  Returns:
 *    A new Strophe.Builder object.
 * @param {?=} attrs
 * @return {!Strophe.Builder}
 */
function $pres(attrs) {}
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "strophe"
/** @const */
tsickle_declare_module.strophe = {};

/* TODO: ExportAssignment in tsickle_declare_module.strophe */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "Strophe"
/** @const */
tsickle_declare_module.Strophe = {};

/* TODO: ExportAssignment in tsickle_declare_module.Strophe */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "$build"
/** @const */
tsickle_declare_module._build = {};

/* TODO: ExportAssignment in tsickle_declare_module._build */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "$msg"
/** @const */
tsickle_declare_module._msg = {};

/* TODO: ExportAssignment in tsickle_declare_module._msg */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "$iq"
/** @const */
tsickle_declare_module._iq = {};

/* TODO: ExportAssignment in tsickle_declare_module._iq */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "$pres"
/** @const */
tsickle_declare_module._pres = {};

/* TODO: ExportAssignment in tsickle_declare_module._pres */
