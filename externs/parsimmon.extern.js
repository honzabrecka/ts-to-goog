/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/parsimmon/index.d.ts:

/**
 * **NOTE:** You probably will never need to use this function. Most parsing
 * can be accomplished using `Parsimmon.regexp` and combination with
 * `Parsimmon.seq` and `Parsimmon.alt`.
 * 
 * You can add a primitive parser (similar to the included ones) by using
 * `Parsimmon(fn)`. This is an example of how to create a parser that matches
 * any character except the one provided:
 * 
 * ```javascript
 * function notChar(char) {
 *   return Parsimmon(function(input, i) {
 *     if (input.charAt(i) !== char) {
 *       return Parsimmon.makeSuccess(i + 1, input.charAt(i));
 *     }
 *     return Parsimmon.makeFailure(i, 'anything different than "' + char + '"');
 *   });
 * }
 * ```
 * 
 * This parser can then be used and composed the same way all the existing
 * ones are used and composed, for example:
 * 
 * ```javascript
 * var parser =
 *   Parsimmon.seq(
 *     Parsimmon.string('a'),
 *     notChar('b').times(5)
 *   );
 * parser.parse('accccc');
 * //=> {status: true, value: ['a', ['c', 'c', 'c', 'c', 'c']]}
 * ```
 * @template T
 * @param {function(string, number): (!Parsimmon.Failure|!Parsimmon.Success<T>)} fn
 * @return {?<T>}
 */
function Parsimmon(fn) {}

/** @typedef {string} */
Parsimmon.StreamType;
/**
 * @record
 * @struct
 */
Parsimmon.Index = function() {};
 /** @type {number} */
Parsimmon.Index.prototype.offset;
 /** @type {number} */
Parsimmon.Index.prototype.line;
 /** @type {number} */
Parsimmon.Index.prototype.column;
/**
 * @record
 * @struct
 */
Parsimmon.Mark = function() {};
 /** @type {!Parsimmon.Index} */
Parsimmon.Mark.prototype.start;
 /** @type {!Parsimmon.Index} */
Parsimmon.Mark.prototype.end;
 /** @type {T} */
Parsimmon.Mark.prototype.value;

/** @typedef {(!Parsimmon.Success<T>|!Parsimmon.Failure)} */
Parsimmon.Result;
/**
 * @record
 * @struct
 */
Parsimmon.Success = function() {};
 /** @type {boolean} */
Parsimmon.Success.prototype.status;
 /** @type {T} */
Parsimmon.Success.prototype.value;
/**
 * @record
 * @struct
 */
Parsimmon.Failure = function() {};
 /** @type {boolean} */
Parsimmon.Failure.prototype.status;
 /** @type {!Array<string>} */
Parsimmon.Failure.prototype.expected;
 /** @type {!Parsimmon.Index} */
Parsimmon.Failure.prototype.index;
/**
 * @record
 * @struct
 */
Parsimmon.Parser = function() {};

/**
 * parse the string
 * @param {string} input
 * @return {(!Parsimmon.Failure|!Parsimmon.Success<T>)}
 */
Parsimmon.Parser.prototype.parse = function(input) {};

/**
 * Like parser.parse(input) but either returns the parsed value or throws
 * an error on failure. The error object contains additional properties
 * about the error.
 * @param {string} input
 * @return {T}
 */
Parsimmon.Parser.prototype.tryParse = function(input) {};

/**
 * returns a new parser which tries parser, and if it fails uses otherParser.
 * @template U
 * @param {?<U>} otherParser
 * @return {?<(T|U)>}
 */
Parsimmon.Parser.prototype.or = function(otherParser) {};

/**
 * returns a new parser which tries parser, and on success calls the given function
 * with the result of the parse, which is expected to return another parser, which
 * will be tried next
 * @template U
 * @param {function(T): ?<U>} next
 * @return {?<U>}
 */
Parsimmon.Parser.prototype.chain = function(next) {};

/**
 * returns a new parser which tries parser, and on success calls the given function
 * with the result of the parse, which is expected to return another parser.
 * @template U
 * @param {function(T): ?<U>|?<U>} call_or_anotherParser
 * @return {?<U>}
 */
Parsimmon.Parser.prototype.then = function(call_or_anotherParser) {};

/**
 * transforms the output of parser with the given function.
 * @template U
 * @param {function(T): U} call
 * @return {?<U>}
 */
Parsimmon.Parser.prototype.map = function(call) {};

/**
 * returns a new parser with the same behavior, but which yields aResult.
 * @template U
 * @param {U} aResult
 * @return {?<U>}
 */
Parsimmon.Parser.prototype.result = function(aResult) {};

/**
 * returns a new parser that returns the fallback value if the first parser failed.
 * @template U
 * @param {U} fallbackValue
 * @return {?<(T|U)>}
 */
Parsimmon.Parser.prototype.fallback = function(fallbackValue) {};

/**
 * expects otherParser after parser, but preserves the yield value of parser.
 * @template U
 * @param {?<U>} otherParser
 * @return {?}
 */
Parsimmon.Parser.prototype.skip = function(otherParser) {};

/**
 * Returns a parser that looks for anything but whatever anotherParser wants to
 * parse, and does not consume it. Yields the same result as parser. Equivalent to
 * parser.skip(Parsimmon.notFollowedBy(anotherParser)).
 * @param {?<?>} anotherParser
 * @return {?}
 */
Parsimmon.Parser.prototype.notFollowedBy = function(anotherParser) {};

/**
 * Returns a parser that looks for whatever arg wants to parse, but does not
 * consume it. Yields the same result as parser. Equivalent to
 * parser.skip(Parsimmon.lookahead(anotherParser)).
 * @param {(string|!RegExp|?<?>)} arg
 * @return {?}
 */
Parsimmon.Parser.prototype.lookahead = function(arg) {};

/**
 * expects parser zero or more times, and yields an array of the results.
 * @return {?<!Array<T>>}
 */
Parsimmon.Parser.prototype.many = function() {};

/**
 * expects parser exactly n times, and yields an array of the results.
 * @param {number} n_or_min
 * @param {number=} max
 * @return {?<!Array<T>>}
 */
Parsimmon.Parser.prototype.times = function(n_or_min, max) {};

/**
 * expects parser at most n times. Yields an array of the results.
 * @param {number} n
 * @return {?<!Array<T>>}
 */
Parsimmon.Parser.prototype.atMost = function(n) {};

/**
 * expects parser at least n times. Yields an array of the results.
 * @param {number} n
 * @return {?<!Array<T>>}
 */
Parsimmon.Parser.prototype.atLeast = function(n) {};

/**
 * returns a new parser whose failure message is the passed description.
 * @return {?<!Parsimmon.Mark<T>>}
 */
Parsimmon.Parser.prototype.mark = function() {};

/**
 * Returns a new parser whose failure message is description.
 * For example, string('x').desc('the letter x') will indicate that 'the letter x' was expected.
 * @param {string} description
 * @return {?}
 */
Parsimmon.Parser.prototype.desc = function(description) {};

/**
 * Alias of `Parsimmon(fn)` for backwards compatibility.
 * @template T
 * @param {function(string, number): (!Parsimmon.Failure|!Parsimmon.Success<T>)} fn
 * @return {?<T>}
 */
Parsimmon.Parser = function(fn) {};

/**
 * To be used inside of Parsimmon(fn). Generates an object describing how
 * far the successful parse went (index), and what value it created doing
 * so. See documentation for Parsimmon(fn).
 * @template T
 * @param {number} index
 * @param {T} value
 * @return {!Parsimmon.Success<T>}
 */
Parsimmon.makeSuccess = function(index, value) {};

/**
 * To be used inside of Parsimmon(fn). Generates an object describing how
 * far the unsuccessful parse went (index), and what kind of syntax it
 * expected to see (expectation). See documentation for Parsimmon(fn).
 * @param {number} furthest
 * @param {string} expectation
 * @return {!Parsimmon.Failure}
 */
Parsimmon.makeFailure = function(furthest, expectation) {};

/**
 * Returns true if obj is a Parsimmon parser, otherwise false.
 * @param {?} obj
 * @return {boolean}
 */
Parsimmon.isParser = function(obj) {};

/**
 * is a parser that expects to find "my-string", and will yield the same.
 * @param {string} string
 * @return {?<string>}
 */
Parsimmon.string = function(string) {};

/**
 * Returns a parser that looks for exactly one character from string, and yields that character.
 * @param {string} string
 * @return {?<string>}
 */
Parsimmon.oneOf = function(string) {};

/**
 * Returns a parser that looks for exactly one character NOT from string, and yields that character.
 * @param {string} string
 * @return {?<string>}
 */
Parsimmon.noneOf = function(string) {};

/**
 * Returns a parser that looks for a match to the regexp and yields the given match group
 * (defaulting to the entire match). The regexp will always match starting at the current
 * parse location. The regexp may only use the following flags: imu. Any other flag will
 * result in an error being thrown.
 * @param {!RegExp} myregex
 * @param {number=} group
 * @return {?<string>}
 */
Parsimmon.regexp = function(myregex, group) {};

/**
 * This was the original name for Parsimmon.regexp, but now it is just an alias.
 * @param {!RegExp} myregex
 * @param {number=} group
 * @return {?<string>}
 */
Parsimmon.regex = function(myregex, group) {};

/**
 * Parses using parser, but does not consume what it parses. Yields null if the parser
 * does not match the input. Otherwise it fails.
 * @param {?<?>} parser
 * @return {?<null>}
 */
Parsimmon.notFollowedBy = function(parser) {};

/**
 * Parses using arg, but does not consume what it parses. Yields an empty string.
 * @param {(string|!RegExp|?<?>)} arg
 * @return {?<string>}
 */
Parsimmon.lookahead = function(arg) {};

/**
 * Returns a parser that doesn't consume any of the string, and yields result.
 * @template U
 * @param {U} result
 * @return {?<U>}
 */
Parsimmon.succeed = function(result) {};

/**
 * This is an alias for Parsimmon.succeed(result).
 * @template U
 * @param {U} result
 * @return {?<U>}
 */
Parsimmon.of = function(result) {};

/**
 * accepts a variable number of parsers that it expects to find in order, yielding an array of the results.
 * @template T, U, V, W, X, Y, Z
 * @param {...?<T>|?<?>} p1_or_parsers
 * @return {?<!Array<?>>|?<!Array<T>>}
 */
Parsimmon.seq = function(p1_or_parsers) {};

/**
 * Takes the string passed to parser.parse(string) and the error returned from
 * parser.parse(string) and turns it into a human readable error message string.
 * Note that there are certainly better ways to format errors, so feel free to write your own.
 * @template T
 * @param {string} string
 * @param {(!Parsimmon.Failure|!Parsimmon.Success<T>)} error
 * @return {string}
 */
Parsimmon.formatError = function(string, error) {};

/**
 * Matches all parsers sequentially, and passes their results as the arguments to a function.
 * Similar to calling Parsimmon.seq and then .map, but the values are not put in an array.
 * @template T, U, V, W, X, Y, Z, A, B
 * @param {?<T>} p1
 * @param {function(T): U|?<U>} cb_or_p2
 * @param {function(T, U): V|?<V>=} cb_or_p3
 * @param {function(T, U, V): W|?<W>=} cb_or_p4
 * @param {function(T, U, V, W): X|?<X>=} cb_or_p5
 * @param {function(T, U, V, W, X): Y|?<Y>=} cb_or_p6
 * @param {function(T, U, V, W, X, Y): Z|?<Z>=} cb_or_p7
 * @param {function(T, U, V, W, X, Y, Z): A|?<A>=} cb_or_p8
 * @param {function(T, U, V, W, X, Y, Z, A): B=} cb
 * @return {?<U>|?<V>|?<W>|?<X>|?<Y>|?<Z>|?<A>|?<B>}
 */
Parsimmon.seqMap = function(p1, cb_or_p2, cb_or_p3, cb_or_p4, cb_or_p5, cb_or_p6, cb_or_p7, cb_or_p8, cb) {};

/** @typedef {function(number, U): (!Parsimmon.Failure|!Parsimmon.Success<U>)} */
Parsimmon.SuccessFunctionType;

/** @typedef {function(number, string): (!Parsimmon.Failure|!Parsimmon.Success<U>)} */
Parsimmon.FailureFunctionType;

/** @typedef {function(string, number): (!Parsimmon.Failure|!Parsimmon.Success<U>)} */
Parsimmon.ParseFunctionType;

/**
 * allows to add custom primitive parsers.
 * @template U
 * @param {function(function(number, U): (!Parsimmon.Failure|!Parsimmon.Success<U>), function(number, string): (!Parsimmon.Failure|!Parsimmon.Success<U>)): function(string, number): (!Parsimmon.Failure|!Parsimmon.Success<U>)} parsingFunction
 * @return {?<U>}
 */
Parsimmon.custom = function(parsingFunction) {};

/**
 * accepts a variable number of parsers, and yields the value of the first one that succeeds,
 * backtracking in between.
 * @template U
 * @param {...?<U>|?<?>} parsers
 * @return {?<U>|?<?>}
 */
Parsimmon.alt = function(parsers) {};

/**
 * Accepts two parsers, and expects zero or more matches for content, separated by separator, yielding an array.
 * @template T, U
 * @param {?<T>} content
 * @param {?<U>} separator
 * @return {?<!Array<T>>}
 */
Parsimmon.sepBy = function(content, separator) {};

/**
 * This is the same as Parsimmon.sepBy, but matches the content parser at least once.
 * @template T, U
 * @param {?<T>} content
 * @param {?<U>} separator
 * @return {?<!Array<T>>}
 */
Parsimmon.sepBy1 = function(content, separator) {};

/**
 * accepts a function that returns a parser, which is evaluated the first time the parser is used.
 * This is useful for referencing parsers that haven't yet been defined.
 * @template U
 * @param {function(): ?<U>|string} f_or_description
 * @param {function(): ?<U>=} f
 * @return {?<U>}
 */
Parsimmon.lazy = function(f_or_description, f) {};

/**
 * fail paring with a message
 * @param {string} message
 * @return {?<?>}
 */
Parsimmon.fail = function(message) {};
 /** @type {?<string>} */
Parsimmon.letter;
 /** @type {?<string>} */
Parsimmon.letters;
 /** @type {?<string>} */
Parsimmon.digit;
 /** @type {?<string>} */
Parsimmon.digits;
 /** @type {?<string>} */
Parsimmon.whitespace;
 /** @type {?<string>} */
Parsimmon.optWhitespace;
 /** @type {?<string>} */
Parsimmon.any;
 /** @type {?<string>} */
Parsimmon.all;
 /** @type {?<undefined>} */
Parsimmon.eof;
 /** @type {?<!Parsimmon.Index>} */
Parsimmon.index;

/**
 * Returns a parser that yield a single character if it passes the predicate
 * @param {function(string): boolean} predicate
 * @return {?<string>}
 */
Parsimmon.test = function(predicate) {};

/**
 * Returns a parser yield a string containing all the next characters that pass the predicate
 * @param {function(string): boolean} predicate
 * @return {?<string>}
 */
Parsimmon.takeWhile = function(predicate) {};

/* TODO: ExportAssignment in  */
