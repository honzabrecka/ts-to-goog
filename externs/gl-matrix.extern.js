/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/gl-matrix/index.d.ts:
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "gl-matrix"
/** @const */
tsickle_declare_module.gl_matrix = {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.gl_matrix.vec2 = function() {};
 /** @type {number} */
tsickle_declare_module.gl_matrix.vec2.prototype.typeVec2;

/**
 * Creates a new, empty vec2
 * 
 * @return {!vec2} a new 2D vector
 */
tsickle_declare_module.gl_matrix.vec2.create = function() {};

/**
 * Creates a new vec2 initialized with values from an existing vector
 * 
 * @param {(!vec2|!Array<number>)} a a vector to clone
 * @return {!vec2} a new 2D vector
 */
tsickle_declare_module.gl_matrix.vec2.clone = function(a) {};

/**
 * Creates a new vec2 initialized with the given values
 * 
 * @param {number} x X component
 * @param {number} y Y component
 * @return {!vec2} a new 2D vector
 */
tsickle_declare_module.gl_matrix.vec2.fromValues = function(x, y) {};

/**
 * Copy the values from one vec2 to another
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the source vector
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.copy = function(out, a) {};

/**
 * Set the components of a vec2 to the given values
 * 
 * @param {!vec2} out the receiving vector
 * @param {number} x X component
 * @param {number} y Y component
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.set = function(out, x, y) {};

/**
 * Adds two vec2's
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.add = function(out, a, b) {};

/**
 * Subtracts vector b from vector a
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.subtract = function(out, a, b) {};

/**
 * Subtracts vector b from vector a
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.sub = function(out, a, b) {};

/**
 * Multiplies two vec2's
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.multiply = function(out, a, b) {};

/**
 * Multiplies two vec2's
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.mul = function(out, a, b) {};

/**
 * Divides two vec2's
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.divide = function(out, a, b) {};

/**
 * Divides two vec2's
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.div = function(out, a, b) {};

/**
 * Math.ceil the components of a vec2
 * 
 * @param {!vec2} out
 * @param {(!vec2|!Array<number>)} a
 * @return {!vec2}
 */
tsickle_declare_module.gl_matrix.vec2.ceil = function(out, a) {};

/**
 * Math.floor the components of a vec2
 * 
 * @param {!vec2} out
 * @param {(!vec2|!Array<number>)} a
 * @return {!vec2}
 */
tsickle_declare_module.gl_matrix.vec2.floor = function(out, a) {};

/**
 * Returns the minimum of two vec2's
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.min = function(out, a, b) {};

/**
 * Returns the maximum of two vec2's
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.max = function(out, a, b) {};

/**
 * Math.round the components of a vec2
 * 
 * @param {!vec2} out
 * @param {(!vec2|!Array<number>)} a
 * @return {!vec2}
 */
tsickle_declare_module.gl_matrix.vec2.round = function(out, a) {};

/**
 * Scales a vec2 by a scalar number
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the vector to scale
 * @param {number} b amount to scale the vector by
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.scale = function(out, a, b) {};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @param {number} scale the amount to scale b by before adding
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.scaleAndAdd = function(out, a, b, scale) {};

/**
 * Calculates the euclidian distance between two vec2's
 * 
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {number} distance between a and b
 */
tsickle_declare_module.gl_matrix.vec2.distance = function(a, b) {};

/**
 * Calculates the euclidian distance between two vec2's
 * 
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {number} distance between a and b
 */
tsickle_declare_module.gl_matrix.vec2.dist = function(a, b) {};

/**
 * Calculates the squared euclidian distance between two vec2's
 * 
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {number} squared distance between a and b
 */
tsickle_declare_module.gl_matrix.vec2.squaredDistance = function(a, b) {};

/**
 * Calculates the squared euclidian distance between two vec2's
 * 
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {number} squared distance between a and b
 */
tsickle_declare_module.gl_matrix.vec2.sqrDist = function(a, b) {};

/**
 * Calculates the length of a vec2
 * 
 * @param {(!vec2|!Array<number>)} a vector to calculate length of
 * @return {number} length of a
 */
tsickle_declare_module.gl_matrix.vec2.length = function(a) {};

/**
 * Calculates the length of a vec2
 * 
 * @param {(!vec2|!Array<number>)} a vector to calculate length of
 * @return {number} length of a
 */
tsickle_declare_module.gl_matrix.vec2.len = function(a) {};

/**
 * Calculates the squared length of a vec2
 * 
 * @param {(!vec2|!Array<number>)} a vector to calculate squared length of
 * @return {number} squared length of a
 */
tsickle_declare_module.gl_matrix.vec2.squaredLength = function(a) {};

/**
 * Calculates the squared length of a vec2
 * 
 * @param {(!vec2|!Array<number>)} a vector to calculate squared length of
 * @return {number} squared length of a
 */
tsickle_declare_module.gl_matrix.vec2.sqrLen = function(a) {};

/**
 * Negates the components of a vec2
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a vector to negate
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.negate = function(out, a) {};

/**
 * Returns the inverse of the components of a vec2
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a vector to invert
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.inverse = function(out, a) {};

/**
 * Normalize a vec2
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a vector to normalize
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.normalize = function(out, a) {};

/**
 * Calculates the dot product of two vec2's
 * 
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {number} dot product of a and b
 */
tsickle_declare_module.gl_matrix.vec2.dot = function(a, b) {};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.cross = function(out, a, b) {};

/**
 * Performs a linear interpolation between two vec2's
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the first operand
 * @param {(!vec2|!Array<number>)} b the second operand
 * @param {number} t interpolation amount between the two inputs
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.lerp = function(out, a, b, t) {};

/**
 * Generates a random unit vector
 * 
 * Generates a random vector with the given scale
 * 
 * @param {!vec2} out the receiving vector
 * @param {number=} scale Length of the resulting vector. If ommitted, a unit vector will be returned
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.random = function(out, scale) {};

/**
 * Transforms the vec2 with a mat2
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the vector to transform
 * @param {!mat2} m matrix to transform with
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.transformMat2 = function(out, a, m) {};

/**
 * Transforms the vec2 with a mat2d
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the vector to transform
 * @param {!mat2d} m matrix to transform with
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.transformMat2d = function(out, a, m) {};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the vector to transform
 * @param {!mat3} m matrix to transform with
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.transformMat3 = function(out, a, m) {};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 * 
 * @param {!vec2} out the receiving vector
 * @param {(!vec2|!Array<number>)} a the vector to transform
 * @param {!mat4} m matrix to transform with
 * @return {!vec2} out
 */
tsickle_declare_module.gl_matrix.vec2.transformMat4 = function(out, a, m) {};

/**
 * Perform some operation over an array of vec2s.
 * 
 * Perform some operation over an array of vec2s.
 * 
 * @param {!Float32Array} a the array of vectors to iterate over
 * @param {number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {number} offset Number of elements to skip at the beginning of the array
 * @param {number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {function((!vec2|!Array<number>), (!vec2|!Array<number>), ?): void|function((!vec2|!Array<number>), (!vec2|!Array<number>)): void} fn Function to call for each vector in the array
 * @param {?=} arg additional argument to pass to fn
 * @return {!Float32Array} a
 */
tsickle_declare_module.gl_matrix.vec2.forEach = function(a, stride, offset, count, fn, arg) {};

/**
 * Returns a string representation of a vector
 * 
 * @param {(!vec2|!Array<number>)} a vector to represent as a string
 * @return {string} string representation of the vector
 */
tsickle_declare_module.gl_matrix.vec2.str = function(a) {};

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 * 
 * @param {(!vec2|!Array<number>)} a
 * @param {(!vec2|!Array<number>)} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.vec2.exactEquals = function(a, b) {};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 * 
 * @param {(!vec2|!Array<number>)} a
 * @param {(!vec2|!Array<number>)} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.vec2.equals = function(a, b) {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.gl_matrix.vec3 = function() {};
 /** @type {number} */
tsickle_declare_module.gl_matrix.vec3.prototype.typeVec3;

/**
 * Creates a new, empty vec3
 * 
 * @return {!vec3} a new 3D vector
 */
tsickle_declare_module.gl_matrix.vec3.create = function() {};

/**
 * Creates a new vec3 initialized with values from an existing vector
 * 
 * @param {(!Array<number>|!vec3)} a vector to clone
 * @return {!vec3} a new 3D vector
 */
tsickle_declare_module.gl_matrix.vec3.clone = function(a) {};

/**
 * Creates a new vec3 initialized with the given values
 * 
 * @param {number} x X component
 * @param {number} y Y component
 * @param {number} z Z component
 * @return {!vec3} a new 3D vector
 */
tsickle_declare_module.gl_matrix.vec3.fromValues = function(x, y, z) {};

/**
 * Copy the values from one vec3 to another
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the source vector
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.copy = function(out, a) {};

/**
 * Set the components of a vec3 to the given values
 * 
 * @param {!vec3} out the receiving vector
 * @param {number} x X component
 * @param {number} y Y component
 * @param {number} z Z component
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.set = function(out, x, y, z) {};

/**
 * Adds two vec3's
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.add = function(out, a, b) {};

/**
 * Subtracts vector b from vector a
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.subtract = function(out, a, b) {};

/**
 * Subtracts vector b from vector a
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.sub = function(out, a, b) {};

/**
 * Multiplies two vec3's
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.multiply = function(out, a, b) {};

/**
 * Multiplies two vec3's
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.mul = function(out, a, b) {};

/**
 * Divides two vec3's
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.divide = function(out, a, b) {};

/**
 * Divides two vec3's
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.div = function(out, a, b) {};

/**
 * Math.ceil the components of a vec3
 * 
 * @param {!vec3} out
 * @param {(!Array<number>|!vec3)} a
 * @return {!vec3}
 */
tsickle_declare_module.gl_matrix.vec3.ceil = function(out, a) {};

/**
 * Math.floor the components of a vec3
 * 
 * @param {!vec3} out
 * @param {(!Array<number>|!vec3)} a
 * @return {!vec3}
 */
tsickle_declare_module.gl_matrix.vec3.floor = function(out, a) {};

/**
 * Returns the minimum of two vec3's
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.min = function(out, a, b) {};

/**
 * Returns the maximum of two vec3's
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.max = function(out, a, b) {};

/**
 * Math.round the components of a vec3
 * 
 * @param {!vec3} out
 * @param {(!Array<number>|!vec3)} a
 * @return {!vec3}
 */
tsickle_declare_module.gl_matrix.vec3.round = function(out, a) {};

/**
 * Scales a vec3 by a scalar number
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the vector to scale
 * @param {number} b amount to scale the vector by
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.scale = function(out, a, b) {};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @param {number} scale the amount to scale b by before adding
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.scaleAndAdd = function(out, a, b, scale) {};

/**
 * Calculates the euclidian distance between two vec3's
 * 
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {number} distance between a and b
 */
tsickle_declare_module.gl_matrix.vec3.distance = function(a, b) {};

/**
 * Calculates the euclidian distance between two vec3's
 * 
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {number} distance between a and b
 */
tsickle_declare_module.gl_matrix.vec3.dist = function(a, b) {};

/**
 * Calculates the squared euclidian distance between two vec3's
 * 
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {number} squared distance between a and b
 */
tsickle_declare_module.gl_matrix.vec3.squaredDistance = function(a, b) {};

/**
 * Calculates the squared euclidian distance between two vec3's
 * 
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {number} squared distance between a and b
 */
tsickle_declare_module.gl_matrix.vec3.sqrDist = function(a, b) {};

/**
 * Calculates the length of a vec3
 * 
 * @param {(!Array<number>|!vec3)} a vector to calculate length of
 * @return {number} length of a
 */
tsickle_declare_module.gl_matrix.vec3.length = function(a) {};

/**
 * Calculates the length of a vec3
 * 
 * @param {(!Array<number>|!vec3)} a vector to calculate length of
 * @return {number} length of a
 */
tsickle_declare_module.gl_matrix.vec3.len = function(a) {};

/**
 * Calculates the squared length of a vec3
 * 
 * @param {(!Array<number>|!vec3)} a vector to calculate squared length of
 * @return {number} squared length of a
 */
tsickle_declare_module.gl_matrix.vec3.squaredLength = function(a) {};

/**
 * Calculates the squared length of a vec3
 * 
 * @param {(!Array<number>|!vec3)} a vector to calculate squared length of
 * @return {number} squared length of a
 */
tsickle_declare_module.gl_matrix.vec3.sqrLen = function(a) {};

/**
 * Negates the components of a vec3
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a vector to negate
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.negate = function(out, a) {};

/**
 * Returns the inverse of the components of a vec3
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a vector to invert
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.inverse = function(out, a) {};

/**
 * Normalize a vec3
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a vector to normalize
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.normalize = function(out, a) {};

/**
 * Calculates the dot product of two vec3's
 * 
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {number} dot product of a and b
 */
tsickle_declare_module.gl_matrix.vec3.dot = function(a, b) {};

/**
 * Computes the cross product of two vec3's
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.cross = function(out, a, b) {};

/**
 * Performs a linear interpolation between two vec3's
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the first operand
 * @param {(!Array<number>|!vec3)} b the second operand
 * @param {number} t interpolation amount between the two inputs
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.lerp = function(out, a, b, t) {};

/**
 * Performs a hermite interpolation with two control points
 * 
 * @param {!vec3} out
 * @param {(!Array<number>|!vec3)} a
 * @param {(!Array<number>|!vec3)} b
 * @param {(!Array<number>|!vec3)} c
 * @param {(!Array<number>|!vec3)} d
 * @param {number} t
 * @return {!vec3}
 */
tsickle_declare_module.gl_matrix.vec3.hermite = function(out, a, b, c, d, t) {};

/**
 * Performs a bezier interpolation with two control points
 * 
 * @param {!vec3} out
 * @param {(!Array<number>|!vec3)} a
 * @param {(!Array<number>|!vec3)} b
 * @param {(!Array<number>|!vec3)} c
 * @param {(!Array<number>|!vec3)} d
 * @param {number} t
 * @return {!vec3}
 */
tsickle_declare_module.gl_matrix.vec3.bezier = function(out, a, b, c, d, t) {};

/**
 * Generates a random unit vector
 * 
 * Generates a random vector with the given scale
 * 
 * @param {!vec3} out the receiving vector
 * @param {number=} scale
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.random = function(out, scale) {};

/**
 * Transforms the vec3 with a mat3.
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the vector to transform
 * @param {!mat3} m the 3x3 matrix to transform with
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.transformMat3 = function(out, a, m) {};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the vector to transform
 * @param {!mat4} m matrix to transform with
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.transformMat4 = function(out, a, m) {};

/**
 * Transforms the vec3 with a quat
 * 
 * @param {!vec3} out the receiving vector
 * @param {(!Array<number>|!vec3)} a the vector to transform
 * @param {!quat} q quaternion to transform with
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.transformQuat = function(out, a, q) {};

/**
 * Rotate a 3D vector around the x-axis
 * @param {!vec3} out The receiving vec3
 * @param {(!Array<number>|!vec3)} a The vec3 point to rotate
 * @param {(!Array<number>|!vec3)} b The origin of the rotation
 * @param {number} c The angle of rotation
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.rotateX = function(out, a, b, c) {};

/**
 * Rotate a 3D vector around the y-axis
 * @param {!vec3} out The receiving vec3
 * @param {(!Array<number>|!vec3)} a The vec3 point to rotate
 * @param {(!Array<number>|!vec3)} b The origin of the rotation
 * @param {number} c The angle of rotation
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.rotateY = function(out, a, b, c) {};

/**
 * Rotate a 3D vector around the z-axis
 * @param {!vec3} out The receiving vec3
 * @param {(!Array<number>|!vec3)} a The vec3 point to rotate
 * @param {(!Array<number>|!vec3)} b The origin of the rotation
 * @param {number} c The angle of rotation
 * @return {!vec3} out
 */
tsickle_declare_module.gl_matrix.vec3.rotateZ = function(out, a, b, c) {};

/**
 * Perform some operation over an array of vec3s.
 * 
 * Perform some operation over an array of vec3s.
 * 
 * @param {!Float32Array} a the array of vectors to iterate over
 * @param {number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {number} offset Number of elements to skip at the beginning of the array
 * @param {number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {function((!Array<number>|!vec3), (!Array<number>|!vec3), ?): void|function((!Array<number>|!vec3), (!Array<number>|!vec3)): void} fn Function to call for each vector in the array
 * @param {?=} arg additional argument to pass to fn
 * @return {!Float32Array} a
 */
tsickle_declare_module.gl_matrix.vec3.forEach = function(a, stride, offset, count, fn, arg) {};

/**
 * Get the angle between two 3D vectors
 * @param {(!Array<number>|!vec3)} a The first operand
 * @param {(!Array<number>|!vec3)} b The second operand
 * @return {number} The angle in radians
 */
tsickle_declare_module.gl_matrix.vec3.angle = function(a, b) {};

/**
 * Returns a string representation of a vector
 * 
 * @param {(!Array<number>|!vec3)} a vector to represent as a string
 * @return {string} string representation of the vector
 */
tsickle_declare_module.gl_matrix.vec3.str = function(a) {};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 * 
 * @param {(!Array<number>|!vec3)} a
 * @param {(!Array<number>|!vec3)} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.vec3.exactEquals = function(a, b) {};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 * 
 * @param {(!Array<number>|!vec3)} a
 * @param {(!Array<number>|!vec3)} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.vec3.equals = function(a, b) {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.gl_matrix.vec4 = function() {};
 /** @type {number} */
tsickle_declare_module.gl_matrix.vec4.prototype.typeVec3;

/**
 * Creates a new, empty vec4
 * 
 * @return {!vec4} a new 4D vector
 */
tsickle_declare_module.gl_matrix.vec4.create = function() {};

/**
 * Creates a new vec4 initialized with values from an existing vector
 * 
 * @param {(!Array<number>|!vec4)} a vector to clone
 * @return {!vec4} a new 4D vector
 */
tsickle_declare_module.gl_matrix.vec4.clone = function(a) {};

/**
 * Creates a new vec4 initialized with the given values
 * 
 * @param {number} x X component
 * @param {number} y Y component
 * @param {number} z Z component
 * @param {number} w W component
 * @return {!vec4} a new 4D vector
 */
tsickle_declare_module.gl_matrix.vec4.fromValues = function(x, y, z, w) {};

/**
 * Copy the values from one vec4 to another
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the source vector
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.copy = function(out, a) {};

/**
 * Set the components of a vec4 to the given values
 * 
 * @param {!vec4} out the receiving vector
 * @param {number} x X component
 * @param {number} y Y component
 * @param {number} z Z component
 * @param {number} w W component
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.set = function(out, x, y, z, w) {};

/**
 * Adds two vec4's
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.add = function(out, a, b) {};

/**
 * Subtracts vector b from vector a
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.subtract = function(out, a, b) {};

/**
 * Subtracts vector b from vector a
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.sub = function(out, a, b) {};

/**
 * Multiplies two vec4's
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.multiply = function(out, a, b) {};

/**
 * Multiplies two vec4's
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.mul = function(out, a, b) {};

/**
 * Divides two vec4's
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.divide = function(out, a, b) {};

/**
 * Divides two vec4's
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.div = function(out, a, b) {};

/**
 * Math.ceil the components of a vec4
 * 
 * @param {!vec4} out
 * @param {(!Array<number>|!vec4)} a
 * @return {!vec4}
 */
tsickle_declare_module.gl_matrix.vec4.ceil = function(out, a) {};

/**
 * Math.floor the components of a vec4
 * 
 * @param {!vec4} out
 * @param {(!Array<number>|!vec4)} a
 * @return {!vec4}
 */
tsickle_declare_module.gl_matrix.vec4.floor = function(out, a) {};

/**
 * Returns the minimum of two vec4's
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.min = function(out, a, b) {};

/**
 * Returns the maximum of two vec4's
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.max = function(out, a, b) {};

/**
 * Math.round the components of a vec4
 * 
 * @param {!vec4} out
 * @param {(!Array<number>|!vec4)} a
 * @return {!vec4}
 */
tsickle_declare_module.gl_matrix.vec4.round = function(out, a) {};

/**
 * Scales a vec4 by a scalar number
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the vector to scale
 * @param {number} b amount to scale the vector by
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.scale = function(out, a, b) {};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @param {number} scale the amount to scale b by before adding
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.scaleAndAdd = function(out, a, b, scale) {};

/**
 * Calculates the euclidian distance between two vec4's
 * 
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @return {number} distance between a and b
 */
tsickle_declare_module.gl_matrix.vec4.distance = function(a, b) {};

/**
 * Calculates the euclidian distance between two vec4's
 * 
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @return {number} distance between a and b
 */
tsickle_declare_module.gl_matrix.vec4.dist = function(a, b) {};

/**
 * Calculates the squared euclidian distance between two vec4's
 * 
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @return {number} squared distance between a and b
 */
tsickle_declare_module.gl_matrix.vec4.squaredDistance = function(a, b) {};

/**
 * Calculates the squared euclidian distance between two vec4's
 * 
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @return {number} squared distance between a and b
 */
tsickle_declare_module.gl_matrix.vec4.sqrDist = function(a, b) {};

/**
 * Calculates the length of a vec4
 * 
 * @param {(!Array<number>|!vec4)} a vector to calculate length of
 * @return {number} length of a
 */
tsickle_declare_module.gl_matrix.vec4.length = function(a) {};

/**
 * Calculates the length of a vec4
 * 
 * @param {(!Array<number>|!vec4)} a vector to calculate length of
 * @return {number} length of a
 */
tsickle_declare_module.gl_matrix.vec4.len = function(a) {};

/**
 * Calculates the squared length of a vec4
 * 
 * @param {(!Array<number>|!vec4)} a vector to calculate squared length of
 * @return {number} squared length of a
 */
tsickle_declare_module.gl_matrix.vec4.squaredLength = function(a) {};

/**
 * Calculates the squared length of a vec4
 * 
 * @param {(!Array<number>|!vec4)} a vector to calculate squared length of
 * @return {number} squared length of a
 */
tsickle_declare_module.gl_matrix.vec4.sqrLen = function(a) {};

/**
 * Negates the components of a vec4
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a vector to negate
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.negate = function(out, a) {};

/**
 * Returns the inverse of the components of a vec4
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a vector to invert
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.inverse = function(out, a) {};

/**
 * Normalize a vec4
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a vector to normalize
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.normalize = function(out, a) {};

/**
 * Calculates the dot product of two vec4's
 * 
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @return {number} dot product of a and b
 */
tsickle_declare_module.gl_matrix.vec4.dot = function(a, b) {};

/**
 * Performs a linear interpolation between two vec4's
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the first operand
 * @param {(!Array<number>|!vec4)} b the second operand
 * @param {number} t interpolation amount between the two inputs
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.lerp = function(out, a, b, t) {};

/**
 * Generates a random unit vector
 * 
 * Generates a random vector with the given scale
 * 
 * @param {!vec4} out the receiving vector
 * @param {number=} scale length of the resulting vector. If ommitted, a unit vector will be returned
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.random = function(out, scale) {};

/**
 * Transforms the vec4 with a mat4.
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the vector to transform
 * @param {!mat4} m matrix to transform with
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.transformMat4 = function(out, a, m) {};

/**
 * Transforms the vec4 with a quat
 * 
 * @param {!vec4} out the receiving vector
 * @param {(!Array<number>|!vec4)} a the vector to transform
 * @param {!quat} q quaternion to transform with
 * @return {!vec4} out
 */
tsickle_declare_module.gl_matrix.vec4.transformQuat = function(out, a, q) {};

/**
 * Perform some operation over an array of vec4s.
 * 
 * Perform some operation over an array of vec4s.
 * 
 * @param {!Float32Array} a the array of vectors to iterate over
 * @param {number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {number} offset Number of elements to skip at the beginning of the array
 * @param {number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {function((!Array<number>|!vec4), (!Array<number>|!vec4), ?): void|function((!Array<number>|!vec4), (!Array<number>|!vec4)): void} fn Function to call for each vector in the array
 * @param {?=} arg additional argument to pass to fn
 * @return {!Float32Array} a
 */
tsickle_declare_module.gl_matrix.vec4.forEach = function(a, stride, offset, count, fn, arg) {};

/**
 * Returns a string representation of a vector
 * 
 * @param {(!Array<number>|!vec4)} a vector to represent as a string
 * @return {string} string representation of the vector
 */
tsickle_declare_module.gl_matrix.vec4.str = function(a) {};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 * 
 * @param {(!Array<number>|!vec4)} a
 * @param {(!Array<number>|!vec4)} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.vec4.exactEquals = function(a, b) {};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 * 
 * @param {(!Array<number>|!vec4)} a
 * @param {(!Array<number>|!vec4)} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.vec4.equals = function(a, b) {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.gl_matrix.mat2 = function() {};
 /** @type {number} */
tsickle_declare_module.gl_matrix.mat2.prototype.typeMat2;

/**
 * Creates a new identity mat2
 * 
 * @return {!mat2} a new 2x2 matrix
 */
tsickle_declare_module.gl_matrix.mat2.create = function() {};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 * 
 * @param {!mat2} a matrix to clone
 * @return {!mat2} a new 2x2 matrix
 */
tsickle_declare_module.gl_matrix.mat2.clone = function(a) {};

/**
 * Copy the values from one mat2 to another
 * 
 * @param {!mat2} out the receiving matrix
 * @param {!mat2} a the source matrix
 * @return {!mat2} out
 */
tsickle_declare_module.gl_matrix.mat2.copy = function(out, a) {};

/**
 * Set a mat2 to the identity matrix
 * 
 * @param {!mat2} out the receiving matrix
 * @return {!mat2} out
 */
tsickle_declare_module.gl_matrix.mat2.identity = function(out) {};

/**
 * Create a new mat2 with the given values
 * 
 * @param {number} m00
 * @param {number} m01
 * @param {number} m10
 * @param {number} m11
 * @return {!mat2}
 */
tsickle_declare_module.gl_matrix.mat2.fromValues = function(m00, m01, m10, m11) {};

/**
 * Set the components of a mat2 to the given values
 * 
 * @param {!mat2} out
 * @param {number} m00
 * @param {number} m01
 * @param {number} m10
 * @param {number} m11
 * @return {!mat2}
 */
tsickle_declare_module.gl_matrix.mat2.set = function(out, m00, m01, m10, m11) {};

/**
 * Transpose the values of a mat2
 * 
 * @param {!mat2} out the receiving matrix
 * @param {!mat2} a the source matrix
 * @return {!mat2} out
 */
tsickle_declare_module.gl_matrix.mat2.transpose = function(out, a) {};

/**
 * Inverts a mat2
 * 
 * @param {!mat2} out the receiving matrix
 * @param {!mat2} a the source matrix
 * @return {!mat2} out
 */
tsickle_declare_module.gl_matrix.mat2.invert = function(out, a) {};

/**
 * Calculates the adjugate of a mat2
 * 
 * @param {!mat2} out the receiving matrix
 * @param {!mat2} a the source matrix
 * @return {!mat2} out
 */
tsickle_declare_module.gl_matrix.mat2.adjoint = function(out, a) {};

/**
 * Calculates the determinant of a mat2
 * 
 * @param {!mat2} a the source matrix
 * @return {number} determinant of a
 */
tsickle_declare_module.gl_matrix.mat2.determinant = function(a) {};

/**
 * Multiplies two mat2's
 * 
 * @param {!mat2} out the receiving matrix
 * @param {!mat2} a the first operand
 * @param {!mat2} b the second operand
 * @return {!mat2} out
 */
tsickle_declare_module.gl_matrix.mat2.multiply = function(out, a, b) {};

/**
 * Multiplies two mat2's
 * 
 * @param {!mat2} out the receiving matrix
 * @param {!mat2} a the first operand
 * @param {!mat2} b the second operand
 * @return {!mat2} out
 */
tsickle_declare_module.gl_matrix.mat2.mul = function(out, a, b) {};

/**
 * Rotates a mat2 by the given angle
 * 
 * @param {!mat2} out the receiving matrix
 * @param {!mat2} a the matrix to rotate
 * @param {number} rad the angle to rotate the matrix by
 * @return {!mat2} out
 */
tsickle_declare_module.gl_matrix.mat2.rotate = function(out, a, rad) {};

/**
 * Scales the mat2 by the dimensions in the given vec2
 * 
 * @param {!mat2} out the receiving matrix
 * @param {!mat2} a the matrix to rotate
 * @param {(!vec2|!Array<number>)} v the vec2 to scale the matrix by
 * @return {!mat2} out
 * 
 */
tsickle_declare_module.gl_matrix.mat2.scale = function(out, a, v) {};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 * 
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 * 
 * @param {!mat2} out
 * @param {number} rad
 * @return {!mat2}
 */
tsickle_declare_module.gl_matrix.mat2.fromRotation = function(out, rad) {};

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 * 
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 * 
 * @param {!mat2} out
 * @param {(!vec2|!Array<number>)} v
 * @return {!mat2}
 */
tsickle_declare_module.gl_matrix.mat2.fromScaling = function(out, v) {};

/**
 * Returns a string representation of a mat2
 * 
 * @param {!mat2} a matrix to represent as a string
 * @return {string} string representation of the matrix
 */
tsickle_declare_module.gl_matrix.mat2.str = function(a) {};

/**
 * Returns Frobenius norm of a mat2
 * 
 * @param {!mat2} a the matrix to calculate Frobenius norm of
 * @return {number} Frobenius norm
 */
tsickle_declare_module.gl_matrix.mat2.frob = function(a) {};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {!mat2} L the lower triangular matrix
 * @param {!mat2} D the diagonal matrix
 * @param {!mat2} U the upper triangular matrix
 * @param {!mat2} a the input matrix to factorize
 * @return {!mat2}
 */
tsickle_declare_module.gl_matrix.mat2.LDU = function(L, D, U, a) {};

/**
 * Adds two mat2's
 * 
 * @param {!mat2} out
 * @param {!mat2} a
 * @param {!mat2} b
 * @return {!mat2}
 */
tsickle_declare_module.gl_matrix.mat2.add = function(out, a, b) {};

/**
 * Subtracts matrix b from matrix a
 * 
 * @param {!mat2} out
 * @param {!mat2} a
 * @param {!mat2} b
 * @return {!mat2}
 */
tsickle_declare_module.gl_matrix.mat2.subtract = function(out, a, b) {};

/**
 * Subtracts matrix b from matrix a
 * 
 * @param {!mat2} out
 * @param {!mat2} a
 * @param {!mat2} b
 * @return {!mat2}
 */
tsickle_declare_module.gl_matrix.mat2.sub = function(out, a, b) {};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 * 
 * @param {!mat2} a
 * @param {!mat2} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.mat2.exactEquals = function(a, b) {};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 * 
 * @param {!mat2} a
 * @param {!mat2} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.mat2.equals = function(a, b) {};

/**
 * Multiply each element of the matrix by a scalar.
 * 
 * @param {!mat2} out
 * @param {!mat2} a
 * @param {number} b
 * @return {!mat2}
 */
tsickle_declare_module.gl_matrix.mat2.multiplyScalar = function(out, a, b) {};

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 * 
 * @param {!mat2} out
 * @param {!mat2} a
 * @param {!mat2} b
 * @param {number} scale
 * @return {!mat2}
 */
tsickle_declare_module.gl_matrix.mat2.multiplyScalarAndAdd = function(out, a, b, scale) {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.gl_matrix.mat2d = function() {};
 /** @type {number} */
tsickle_declare_module.gl_matrix.mat2d.prototype.typeMat2d;

/**
 * Creates a new identity mat2d
 * 
 * @return {!mat2d} a new 2x3 matrix
 */
tsickle_declare_module.gl_matrix.mat2d.create = function() {};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 * 
 * @param {!mat2d} a matrix to clone
 * @return {!mat2d} a new 2x3 matrix
 */
tsickle_declare_module.gl_matrix.mat2d.clone = function(a) {};

/**
 * Copy the values from one mat2d to another
 * 
 * @param {!mat2d} out the receiving matrix
 * @param {!mat2d} a the source matrix
 * @return {!mat2d} out
 */
tsickle_declare_module.gl_matrix.mat2d.copy = function(out, a) {};

/**
 * Set a mat2d to the identity matrix
 * 
 * @param {!mat2d} out the receiving matrix
 * @return {!mat2d} out
 */
tsickle_declare_module.gl_matrix.mat2d.identity = function(out) {};

/**
 * Create a new mat2d with the given values
 * 
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @param {number} d
 * @param {number} tx
 * @param {number} ty
 * @return {!mat2d}
 */
tsickle_declare_module.gl_matrix.mat2d.fromValues = function(a, b, c, d, tx, ty) {};

/**
 * Set the components of a mat2d to the given values
 * 
 * @param {!mat2d} out
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @param {number} d
 * @param {number} tx
 * @param {number} ty
 * @return {!mat2d}
 */
tsickle_declare_module.gl_matrix.mat2d.set = function(out, a, b, c, d, tx, ty) {};

/**
 * Inverts a mat2d
 * 
 * @param {!mat2d} out the receiving matrix
 * @param {!mat2d} a the source matrix
 * @return {!mat2d} out
 */
tsickle_declare_module.gl_matrix.mat2d.invert = function(out, a) {};

/**
 * Calculates the determinant of a mat2d
 * 
 * @param {!mat2d} a the source matrix
 * @return {number} determinant of a
 */
tsickle_declare_module.gl_matrix.mat2d.determinant = function(a) {};

/**
 * Multiplies two mat2d's
 * 
 * @param {!mat2d} out the receiving matrix
 * @param {!mat2d} a the first operand
 * @param {!mat2d} b the second operand
 * @return {!mat2d} out
 */
tsickle_declare_module.gl_matrix.mat2d.multiply = function(out, a, b) {};

/**
 * Multiplies two mat2d's
 * 
 * @param {!mat2d} out the receiving matrix
 * @param {!mat2d} a the first operand
 * @param {!mat2d} b the second operand
 * @return {!mat2d} out
 */
tsickle_declare_module.gl_matrix.mat2d.mul = function(out, a, b) {};

/**
 * Rotates a mat2d by the given angle
 * 
 * @param {!mat2d} out the receiving matrix
 * @param {!mat2d} a the matrix to rotate
 * @param {number} rad the angle to rotate the matrix by
 * @return {!mat2d} out
 */
tsickle_declare_module.gl_matrix.mat2d.rotate = function(out, a, rad) {};

/**
 * Scales the mat2d by the dimensions in the given vec2
 * 
 * @param {!mat2d} out the receiving matrix
 * @param {!mat2d} a the matrix to translate
 * @param {(!vec2|!Array<number>)} v the vec2 to scale the matrix by
 * @return {!mat2d} out
 * 
 */
tsickle_declare_module.gl_matrix.mat2d.scale = function(out, a, v) {};

/**
 * Translates the mat2d by the dimensions in the given vec2
 * 
 * @param {!mat2d} out the receiving matrix
 * @param {!mat2d} a the matrix to translate
 * @param {(!vec2|!Array<number>)} v the vec2 to translate the matrix by
 * @return {!mat2d} out
 * 
 */
tsickle_declare_module.gl_matrix.mat2d.translate = function(out, a, v) {};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 * 
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 * 
 * @param {!mat2d} out
 * @param {number} rad
 * @return {!mat2d}
 */
tsickle_declare_module.gl_matrix.mat2d.fromRotation = function(out, rad) {};

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 * 
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 * 
 * @param {!mat2d} out
 * @param {(!vec2|!Array<number>)} v
 * @return {!mat2d}
 */
tsickle_declare_module.gl_matrix.mat2d.fromScaling = function(out, v) {};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 * 
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 * 
 * @param {!mat2d} out
 * @param {(!vec2|!Array<number>)} v
 * @return {!mat2d}
 */
tsickle_declare_module.gl_matrix.mat2d.fromTranslation = function(out, v) {};

/**
 * Returns a string representation of a mat2d
 * 
 * @param {!mat2d} a matrix to represent as a string
 * @return {string} string representation of the matrix
 */
tsickle_declare_module.gl_matrix.mat2d.str = function(a) {};

/**
 * Returns Frobenius norm of a mat2d
 * 
 * @param {!mat2d} a the matrix to calculate Frobenius norm of
 * @return {number} Frobenius norm
 */
tsickle_declare_module.gl_matrix.mat2d.frob = function(a) {};

/**
 * Adds two mat2d's
 * 
 * @param {!mat2d} out
 * @param {!mat2d} a
 * @param {!mat2d} b
 * @return {!mat2d}
 */
tsickle_declare_module.gl_matrix.mat2d.add = function(out, a, b) {};

/**
 * Subtracts matrix b from matrix a
 * 
 * @param {!mat2d} out
 * @param {!mat2d} a
 * @param {!mat2d} b
 * @return {!mat2d}
 */
tsickle_declare_module.gl_matrix.mat2d.subtract = function(out, a, b) {};

/**
 * Subtracts matrix b from matrix a
 * 
 * @param {!mat2d} out
 * @param {!mat2d} a
 * @param {!mat2d} b
 * @return {!mat2d}
 */
tsickle_declare_module.gl_matrix.mat2d.sub = function(out, a, b) {};

/**
 * Multiply each element of the matrix by a scalar.
 * 
 * @param {!mat2d} out
 * @param {!mat2d} a
 * @param {number} b
 * @return {!mat2d}
 */
tsickle_declare_module.gl_matrix.mat2d.multiplyScalar = function(out, a, b) {};

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 * 
 * @param {!mat2d} out
 * @param {!mat2d} a
 * @param {!mat2d} b
 * @param {number} scale
 * @return {!mat2d}
 */
tsickle_declare_module.gl_matrix.mat2d.multiplyScalarAndAdd = function(out, a, b, scale) {};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 * 
 * @param {!mat2d} a
 * @param {!mat2d} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.mat2d.exactEquals = function(a, b) {};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 * 
 * @param {!mat2d} a
 * @param {!mat2d} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.mat2d.equals = function(a, b) {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.gl_matrix.mat3 = function() {};
 /** @type {number} */
tsickle_declare_module.gl_matrix.mat3.prototype.typeMat3;

/**
 * Creates a new identity mat3
 * 
 * @return {!mat3} a new 3x3 matrix
 */
tsickle_declare_module.gl_matrix.mat3.create = function() {};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 * 
 * @param {!mat3} out
 * @param {!mat4} a
 * @return {!mat3}
 */
tsickle_declare_module.gl_matrix.mat3.fromMat4 = function(out, a) {};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 * 
 * @param {!mat3} a matrix to clone
 * @return {!mat3} a new 3x3 matrix
 */
tsickle_declare_module.gl_matrix.mat3.clone = function(a) {};

/**
 * Copy the values from one mat3 to another
 * 
 * @param {!mat3} out the receiving matrix
 * @param {!mat3} a the source matrix
 * @return {!mat3} out
 */
tsickle_declare_module.gl_matrix.mat3.copy = function(out, a) {};

/**
 * Create a new mat3 with the given values
 * 
 * @param {number} m00
 * @param {number} m01
 * @param {number} m02
 * @param {number} m10
 * @param {number} m11
 * @param {number} m12
 * @param {number} m20
 * @param {number} m21
 * @param {number} m22
 * @return {!mat3}
 */
tsickle_declare_module.gl_matrix.mat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {};

/**
 * Set the components of a mat3 to the given values
 * 
 * @param {!mat3} out
 * @param {number} m00
 * @param {number} m01
 * @param {number} m02
 * @param {number} m10
 * @param {number} m11
 * @param {number} m12
 * @param {number} m20
 * @param {number} m21
 * @param {number} m22
 * @return {!mat3}
 */
tsickle_declare_module.gl_matrix.mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {};

/**
 * Set a mat3 to the identity matrix
 * 
 * @param {!mat3} out the receiving matrix
 * @return {!mat3} out
 */
tsickle_declare_module.gl_matrix.mat3.identity = function(out) {};

/**
 * Transpose the values of a mat3
 * 
 * @param {!mat3} out the receiving matrix
 * @param {!mat3} a the source matrix
 * @return {!mat3} out
 */
tsickle_declare_module.gl_matrix.mat3.transpose = function(out, a) {};

/**
 * Inverts a mat3
 * 
 * @param {!mat3} out the receiving matrix
 * @param {!mat3} a the source matrix
 * @return {!mat3} out
 */
tsickle_declare_module.gl_matrix.mat3.invert = function(out, a) {};

/**
 * Calculates the adjugate of a mat3
 * 
 * @param {!mat3} out the receiving matrix
 * @param {!mat3} a the source matrix
 * @return {!mat3} out
 */
tsickle_declare_module.gl_matrix.mat3.adjoint = function(out, a) {};

/**
 * Calculates the determinant of a mat3
 * 
 * @param {!mat3} a the source matrix
 * @return {number} determinant of a
 */
tsickle_declare_module.gl_matrix.mat3.determinant = function(a) {};

/**
 * Multiplies two mat3's
 * 
 * @param {!mat3} out the receiving matrix
 * @param {!mat3} a the first operand
 * @param {!mat3} b the second operand
 * @return {!mat3} out
 */
tsickle_declare_module.gl_matrix.mat3.multiply = function(out, a, b) {};

/**
 * Multiplies two mat3's
 * 
 * @param {!mat3} out the receiving matrix
 * @param {!mat3} a the first operand
 * @param {!mat3} b the second operand
 * @return {!mat3} out
 */
tsickle_declare_module.gl_matrix.mat3.mul = function(out, a, b) {};

/**
 * Translate a mat3 by the given vector
 * 
 * @param {!mat3} out the receiving matrix
 * @param {!mat3} a the matrix to translate
 * @param {(!Array<number>|!vec3)} v vector to translate by
 * @return {!mat3} out
 */
tsickle_declare_module.gl_matrix.mat3.translate = function(out, a, v) {};

/**
 * Rotates a mat3 by the given angle
 * 
 * @param {!mat3} out the receiving matrix
 * @param {!mat3} a the matrix to rotate
 * @param {number} rad the angle to rotate the matrix by
 * @return {!mat3} out
 */
tsickle_declare_module.gl_matrix.mat3.rotate = function(out, a, rad) {};

/**
 * Scales the mat3 by the dimensions in the given vec2
 * 
 * @param {!mat3} out the receiving matrix
 * @param {!mat3} a the matrix to rotate
 * @param {(!vec2|!Array<number>)} v the vec2 to scale the matrix by
 * @return {!mat3} out
 * 
 */
tsickle_declare_module.gl_matrix.mat3.scale = function(out, a, v) {};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 * 
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 * 
 * @param {!mat3} out
 * @param {(!vec2|!Array<number>)} v
 * @return {!mat3}
 */
tsickle_declare_module.gl_matrix.mat3.fromTranslation = function(out, v) {};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 * 
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 * 
 * @param {!mat3} out
 * @param {number} rad
 * @return {!mat3}
 */
tsickle_declare_module.gl_matrix.mat3.fromRotation = function(out, rad) {};

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 * 
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 * 
 * @param {!mat3} out
 * @param {(!vec2|!Array<number>)} v
 * @return {!mat3}
 */
tsickle_declare_module.gl_matrix.mat3.fromScaling = function(out, v) {};

/**
 * Copies the values from a mat2d into a mat3
 * 
 * @param {!mat3} out the receiving matrix
 * @param {!mat2d} a
 * @return {!mat3} out
 * 
 */
tsickle_declare_module.gl_matrix.mat3.fromMat2d = function(out, a) {};

/**
 * Calculates a 3x3 matrix from the given quaternion
 * 
 * @param {!mat3} out mat3 receiving operation result
 * @param {!quat} q Quaternion to create matrix from
 * 
 * @return {!mat3} out
 */
tsickle_declare_module.gl_matrix.mat3.fromQuat = function(out, q) {};

/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 * 
 * @param {!mat3} out mat3 receiving operation result
 * @param {!mat4} a Mat4 to derive the normal matrix from
 * 
 * @return {!mat3} out
 */
tsickle_declare_module.gl_matrix.mat3.normalFromMat4 = function(out, a) {};

/**
 * Returns a string representation of a mat3
 * 
 * @param {!mat3} mat matrix to represent as a string
 * @return {string} string representation of the matrix
 */
tsickle_declare_module.gl_matrix.mat3.str = function(mat) {};

/**
 * Returns Frobenius norm of a mat3
 * 
 * @param {!mat3} a the matrix to calculate Frobenius norm of
 * @return {number} Frobenius norm
 */
tsickle_declare_module.gl_matrix.mat3.frob = function(a) {};

/**
 * Adds two mat3's
 * 
 * @param {!mat3} out
 * @param {!mat3} a
 * @param {!mat3} b
 * @return {!mat3}
 */
tsickle_declare_module.gl_matrix.mat3.add = function(out, a, b) {};

/**
 * Subtracts matrix b from matrix a
 * 
 * @param {!mat3} out
 * @param {!mat3} a
 * @param {!mat3} b
 * @return {!mat3}
 */
tsickle_declare_module.gl_matrix.mat3.subtract = function(out, a, b) {};

/**
 * Subtracts matrix b from matrix a
 * 
 * @param {!mat3} out
 * @param {!mat3} a
 * @param {!mat3} b
 * @return {!mat3}
 */
tsickle_declare_module.gl_matrix.mat3.sub = function(out, a, b) {};

/**
 * Multiply each element of the matrix by a scalar.
 * 
 * @param {!mat3} out
 * @param {!mat3} a
 * @param {number} b
 * @return {!mat3}
 */
tsickle_declare_module.gl_matrix.mat3.multiplyScalar = function(out, a, b) {};

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 * 
 * @param {!mat3} out
 * @param {!mat3} a
 * @param {!mat3} b
 * @param {number} scale
 * @return {!mat3}
 */
tsickle_declare_module.gl_matrix.mat3.multiplyScalarAndAdd = function(out, a, b, scale) {};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 * 
 * @param {!mat3} a
 * @param {!mat3} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.mat3.exactEquals = function(a, b) {};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 * 
 * @param {!mat3} a
 * @param {!mat3} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.mat3.equals = function(a, b) {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.gl_matrix.mat4 = function() {};
 /** @type {number} */
tsickle_declare_module.gl_matrix.mat4.prototype.typeMat4;

/**
 * Creates a new identity mat4
 * 
 * @return {!mat4} a new 4x4 matrix
 */
tsickle_declare_module.gl_matrix.mat4.create = function() {};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 * 
 * @param {!mat4} a matrix to clone
 * @return {!mat4} a new 4x4 matrix
 */
tsickle_declare_module.gl_matrix.mat4.clone = function(a) {};

/**
 * Copy the values from one mat4 to another
 * 
 * @param {!mat4} out the receiving matrix
 * @param {!mat4} a the source matrix
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.copy = function(out, a) {};

/**
 * Create a new mat4 with the given values
 * 
 * @param {number} m00
 * @param {number} m01
 * @param {number} m02
 * @param {number} m03
 * @param {number} m10
 * @param {number} m11
 * @param {number} m12
 * @param {number} m13
 * @param {number} m20
 * @param {number} m21
 * @param {number} m22
 * @param {number} m23
 * @param {number} m30
 * @param {number} m31
 * @param {number} m32
 * @param {number} m33
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {};

/**
 * Set the components of a mat4 to the given values
 * 
 * @param {!mat4} out
 * @param {number} m00
 * @param {number} m01
 * @param {number} m02
 * @param {number} m03
 * @param {number} m10
 * @param {number} m11
 * @param {number} m12
 * @param {number} m13
 * @param {number} m20
 * @param {number} m21
 * @param {number} m22
 * @param {number} m23
 * @param {number} m30
 * @param {number} m31
 * @param {number} m32
 * @param {number} m33
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {};

/**
 * Set a mat4 to the identity matrix
 * 
 * @param {!mat4} out the receiving matrix
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.identity = function(out) {};

/**
 * Transpose the values of a mat4
 * 
 * @param {!mat4} out the receiving matrix
 * @param {!mat4} a the source matrix
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.transpose = function(out, a) {};

/**
 * Inverts a mat4
 * 
 * @param {!mat4} out the receiving matrix
 * @param {!mat4} a the source matrix
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.invert = function(out, a) {};

/**
 * Calculates the adjugate of a mat4
 * 
 * @param {!mat4} out the receiving matrix
 * @param {!mat4} a the source matrix
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.adjoint = function(out, a) {};

/**
 * Calculates the determinant of a mat4
 * 
 * @param {!mat4} a the source matrix
 * @return {number} determinant of a
 */
tsickle_declare_module.gl_matrix.mat4.determinant = function(a) {};

/**
 * Multiplies two mat4's
 * 
 * @param {!mat4} out the receiving matrix
 * @param {!mat4} a the first operand
 * @param {!mat4} b the second operand
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.multiply = function(out, a, b) {};

/**
 * Multiplies two mat4's
 * 
 * @param {!mat4} out the receiving matrix
 * @param {!mat4} a the first operand
 * @param {!mat4} b the second operand
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.mul = function(out, a, b) {};

/**
 * Translate a mat4 by the given vector
 * 
 * @param {!mat4} out the receiving matrix
 * @param {!mat4} a the matrix to translate
 * @param {(!Array<number>|!vec3)} v vector to translate by
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.translate = function(out, a, v) {};

/**
 * Scales the mat4 by the dimensions in the given vec3
 * 
 * @param {!mat4} out the receiving matrix
 * @param {!mat4} a the matrix to scale
 * @param {(!Array<number>|!vec3)} v the vec3 to scale the matrix by
 * @return {!mat4} out
 * 
 */
tsickle_declare_module.gl_matrix.mat4.scale = function(out, a, v) {};

/**
 * Rotates a mat4 by the given angle
 * 
 * @param {!mat4} out the receiving matrix
 * @param {!mat4} a the matrix to rotate
 * @param {number} rad the angle to rotate the matrix by
 * @param {(!Array<number>|!vec3)} axis the axis to rotate around
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.rotate = function(out, a, rad, axis) {};

/**
 * Rotates a matrix by the given angle around the X axis
 * 
 * @param {!mat4} out the receiving matrix
 * @param {!mat4} a the matrix to rotate
 * @param {number} rad the angle to rotate the matrix by
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.rotateX = function(out, a, rad) {};

/**
 * Rotates a matrix by the given angle around the Y axis
 * 
 * @param {!mat4} out the receiving matrix
 * @param {!mat4} a the matrix to rotate
 * @param {number} rad the angle to rotate the matrix by
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.rotateY = function(out, a, rad) {};

/**
 * Rotates a matrix by the given angle around the Z axis
 * 
 * @param {!mat4} out the receiving matrix
 * @param {!mat4} a the matrix to rotate
 * @param {number} rad the angle to rotate the matrix by
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.rotateZ = function(out, a, rad) {};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 * 
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 * 
 * @param {!mat4} out
 * @param {(!Array<number>|!vec3)} v
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.fromTranslation = function(out, v) {};

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 * 
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 * 
 * @param {!mat4} out
 * @param {(!Array<number>|!vec3)} v
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.fromScaling = function(out, v) {};

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 * 
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 * 
 * @param {!mat4} out
 * @param {number} rad
 * @param {(!Array<number>|!vec3)} axis
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.fromRotation = function(out, rad, axis) {};

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 * 
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 * 
 * @param {!mat4} out
 * @param {number} rad
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.fromXRotation = function(out, rad) {};

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 * 
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 * 
 * @param {!mat4} out
 * @param {number} rad
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.fromYRotation = function(out, rad) {};

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 * 
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 * 
 * @param {!mat4} out
 * @param {number} rad
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.fromZRotation = function(out, rad) {};

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 * 
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 * 
 * @param {!mat4} out mat4 receiving operation result
 * @param {!quat} q Rotation quaternion
 * @param {(!Array<number>|!vec3)} v Translation vector
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.fromRotationTranslation = function(out, q, v) {};

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param {!vec3} out
 * @param {!mat4} mat
 * @return {!vec3}
 */
tsickle_declare_module.gl_matrix.mat4.getTranslation = function(out, mat) {};

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {!quat} out
 * @param {!mat4} mat
 * @return {!quat}
 */
tsickle_declare_module.gl_matrix.mat4.getRotation = function(out, mat) {};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 * 
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 * 
 * @param {!mat4} out mat4 receiving operation result
 * @param {!quat} q Rotation quaternion
 * @param {(!Array<number>|!vec3)} v Translation vector
 * @param {(!Array<number>|!vec3)} s Scaling vector
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.fromRotationTranslationScale = function(out, q, v, s) {};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 * 
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 * 
 * @param {!mat4} out
 * @param {!quat} q
 * @param {(!Array<number>|!vec3)} v
 * @param {(!Array<number>|!vec3)} s
 * @param {(!Array<number>|!vec3)} o
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.fromRotationTranslationScaleOrigin = function(out, q, v, s, o) {};

/**
 * Calculates a 4x4 matrix from the given quaternion
 * 
 * 
 * @param {!mat4} out
 * @param {!quat} q
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.fromQuat = function(out, q) {};

/**
 * Generates a frustum matrix with the given bounds
 * 
 * @param {!mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.frustum = function(out, left, right, bottom, top, near, far) {};

/**
 * Generates a perspective projection matrix with the given bounds
 * 
 * @param {!mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.perspective = function(out, fovy, aspect, near, far) {};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experimental WebVR API.
 * 
 * @param {!mat4} out
 * @param {{upDegrees: number, downDegrees: number, leftDegrees: number, rightDegrees: number}} fov
 * @param {number} near
 * @param {number} far
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.perspectiveFromFieldOfView = function(out, fov, near, far) {};

/**
 * Generates a orthogonal projection matrix with the given bounds
 * 
 * @param {!mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.ortho = function(out, left, right, bottom, top, near, far) {};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 * 
 * @param {!mat4} out mat4 frustum matrix will be written into
 * @param {(!Array<number>|!vec3)} eye Position of the viewer
 * @param {(!Array<number>|!vec3)} center Point the viewer is looking at
 * @param {(!Array<number>|!vec3)} up vec3 pointing up
 * @return {!mat4} out
 */
tsickle_declare_module.gl_matrix.mat4.lookAt = function(out, eye, center, up) {};

/**
 * Returns a string representation of a mat4
 * 
 * @param {!mat4} mat matrix to represent as a string
 * @return {string} string representation of the matrix
 */
tsickle_declare_module.gl_matrix.mat4.str = function(mat) {};

/**
 * Returns Frobenius norm of a mat4
 * 
 * @param {!mat4} a the matrix to calculate Frobenius norm of
 * @return {number} Frobenius norm
 */
tsickle_declare_module.gl_matrix.mat4.frob = function(a) {};

/**
 * Adds two mat4's
 * 
 * @param {!mat4} out
 * @param {!mat4} a
 * @param {!mat4} b
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.add = function(out, a, b) {};

/**
 * Subtracts matrix b from matrix a
 * 
 * @param {!mat4} out
 * @param {!mat4} a
 * @param {!mat4} b
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.subtract = function(out, a, b) {};

/**
 * Subtracts matrix b from matrix a
 * 
 * @param {!mat4} out
 * @param {!mat4} a
 * @param {!mat4} b
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.sub = function(out, a, b) {};

/**
 * Multiply each element of the matrix by a scalar.
 * 
 * @param {!mat4} out
 * @param {!mat4} a
 * @param {number} b
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.multiplyScalar = function(out, a, b) {};

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 * 
 * @param {!mat4} out
 * @param {!mat4} a
 * @param {!mat4} b
 * @param {number} scale
 * @return {!mat4}
 */
tsickle_declare_module.gl_matrix.mat4.multiplyScalarAndAdd = function(out, a, b, scale) {};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 * 
 * @param {!mat4} a
 * @param {!mat4} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.mat4.exactEquals = function(a, b) {};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 * 
 * @param {!mat4} a
 * @param {!mat4} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.mat4.equals = function(a, b) {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.gl_matrix.quat = function() {};
 /** @type {number} */
tsickle_declare_module.gl_matrix.quat.prototype.typeQuat;

/**
 * Creates a new identity quat
 * 
 * @return {!quat} a new quaternion
 */
tsickle_declare_module.gl_matrix.quat.create = function() {};

/**
 * Creates a new quat initialized with values from an existing quaternion
 * 
 * @param {!quat} a quaternion to clone
 * @return {!quat} a new quaternion
 */
tsickle_declare_module.gl_matrix.quat.clone = function(a) {};

/**
 * Creates a new quat initialized with the given values
 * 
 * @param {number} x X component
 * @param {number} y Y component
 * @param {number} z Z component
 * @param {number} w W component
 * @return {!quat} a new quaternion
 */
tsickle_declare_module.gl_matrix.quat.fromValues = function(x, y, z, w) {};

/**
 * Copy the values from one quat to another
 * 
 * @param {!quat} out the receiving quaternion
 * @param {!quat} a the source quaternion
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.copy = function(out, a) {};

/**
 * Set the components of a quat to the given values
 * 
 * @param {!quat} out the receiving quaternion
 * @param {number} x X component
 * @param {number} y Y component
 * @param {number} z Z component
 * @param {number} w W component
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.set = function(out, x, y, z, w) {};

/**
 * Set a quat to the identity quaternion
 * 
 * @param {!quat} out the receiving quaternion
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.identity = function(out) {};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 * 
 * Both vectors are assumed to be unit length.
 * 
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 * 
 * Both vectors are assumed to be unit length.
 * 
 * @param {!quat} out the receiving quaternion.
 * @param {(!Array<number>|!vec3)} a the initial vector
 * @param {(!Array<number>|!vec3)} b the destination vector
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.rotationTo = function(out, a, b) {};

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 * 
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 * 
 * @param {!quat} out the receiving quat
 * @param {(!Array<number>|!vec3)} view  the vector representing the viewing direction
 * @param {(!Array<number>|!vec3)} right the vector representing the local "right" direction
 * @param {(!Array<number>|!vec3)} up    the vector representing the local "up" direction
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.setAxes = function(out, view, right, up) {};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 * 
 * @param {!quat} out the receiving quaternion
 * @param {(!Array<number>|!vec3)} axis the axis around which to rotate
 * @param {number} rad the angle in radians
 * @return {!quat} out
 * 
 */
tsickle_declare_module.gl_matrix.quat.setAxisAngle = function(out, axis, rad) {};

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param {(!Array<number>|!vec3)} out_axis
 * @param {!quat} q
 * @return {number}
 */
tsickle_declare_module.gl_matrix.quat.getAxisAngle = function(out_axis, q) {};

/**
 * Adds two quat's
 * 
 * @param {!quat} out the receiving quaternion
 * @param {!quat} a the first operand
 * @param {!quat} b the second operand
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.add = function(out, a, b) {};

/**
 * Multiplies two quat's
 * 
 * @param {!quat} out the receiving quaternion
 * @param {!quat} a the first operand
 * @param {!quat} b the second operand
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.multiply = function(out, a, b) {};

/**
 * Multiplies two quat's
 * 
 * @param {!quat} out the receiving quaternion
 * @param {!quat} a the first operand
 * @param {!quat} b the second operand
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.mul = function(out, a, b) {};

/**
 * Scales a quat by a scalar number
 * 
 * @param {!quat} out the receiving vector
 * @param {!quat} a the vector to scale
 * @param {number} b amount to scale the vector by
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.scale = function(out, a, b) {};

/**
 * Calculates the length of a quat
 * 
 * @param {!quat} a vector to calculate length of
 * @return {number} length of a
 */
tsickle_declare_module.gl_matrix.quat.length = function(a) {};

/**
 * Calculates the length of a quat
 * 
 * @param {!quat} a vector to calculate length of
 * @return {number} length of a
 */
tsickle_declare_module.gl_matrix.quat.len = function(a) {};

/**
 * Calculates the squared length of a quat
 * 
 * @param {!quat} a vector to calculate squared length of
 * @return {number} squared length of a
 */
tsickle_declare_module.gl_matrix.quat.squaredLength = function(a) {};

/**
 * Calculates the squared length of a quat
 * 
 * @param {!quat} a vector to calculate squared length of
 * @return {number} squared length of a
 */
tsickle_declare_module.gl_matrix.quat.sqrLen = function(a) {};

/**
 * Normalize a quat
 * 
 * @param {!quat} out the receiving quaternion
 * @param {!quat} a quaternion to normalize
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.normalize = function(out, a) {};

/**
 * Calculates the dot product of two quat's
 * 
 * @param {!quat} a the first operand
 * @param {!quat} b the second operand
 * @return {number} dot product of a and b
 */
tsickle_declare_module.gl_matrix.quat.dot = function(a, b) {};

/**
 * Performs a linear interpolation between two quat's
 * 
 * @param {!quat} out the receiving quaternion
 * @param {!quat} a the first operand
 * @param {!quat} b the second operand
 * @param {number} t interpolation amount between the two inputs
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.lerp = function(out, a, b, t) {};

/**
 * Performs a spherical linear interpolation between two quat
 * 
 * @param {!quat} out the receiving quaternion
 * @param {!quat} a the first operand
 * @param {!quat} b the second operand
 * @param {number} t interpolation amount between the two inputs
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.slerp = function(out, a, b, t) {};

/**
 * Performs a spherical linear interpolation with two control points
 * 
 * @param {!quat} out
 * @param {!quat} a
 * @param {!quat} b
 * @param {!quat} c
 * @param {!quat} d
 * @param {number} t
 * @return {!quat}
 */
tsickle_declare_module.gl_matrix.quat.sqlerp = function(out, a, b, c, d, t) {};

/**
 * Calculates the inverse of a quat
 * 
 * @param {!quat} out the receiving quaternion
 * @param {!quat} a quat to calculate inverse of
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.invert = function(out, a) {};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 * 
 * @param {!quat} out the receiving quaternion
 * @param {!quat} a quat to calculate conjugate of
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.conjugate = function(out, a) {};

/**
 * Returns a string representation of a quaternion
 * 
 * @param {!quat} a quat to represent as a string
 * @return {string} string representation of the quat
 */
tsickle_declare_module.gl_matrix.quat.str = function(a) {};

/**
 * Rotates a quaternion by the given angle about the X axis
 * 
 * @param {!quat} out quat receiving operation result
 * @param {!quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.rotateX = function(out, a, rad) {};

/**
 * Rotates a quaternion by the given angle about the Y axis
 * 
 * @param {!quat} out quat receiving operation result
 * @param {!quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.rotateY = function(out, a, rad) {};

/**
 * Rotates a quaternion by the given angle about the Z axis
 * 
 * @param {!quat} out quat receiving operation result
 * @param {!quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.rotateZ = function(out, a, rad) {};

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 * 
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 * 
 * @param {!quat} out the receiving quaternion
 * @param {!mat3} m rotation matrix
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.fromMat3 = function(out, m) {};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 * 
 * @param {!quat} out the receiving quaternion
 * @param {!quat} a quat to calculate W component of
 * @return {!quat} out
 */
tsickle_declare_module.gl_matrix.quat.calculateW = function(out, a) {};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 * 
 * @param {!quat} a
 * @param {!quat} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.quat.exactEquals = function(a, b) {};

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 * 
 * @param {!quat} a
 * @param {!quat} b
 * @return {boolean}
 */
tsickle_declare_module.gl_matrix.quat.equals = function(a, b) {};
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "gl-matrix/src/gl-matrix/vec2"
/** @const */
tsickle_declare_module.gl_matrix_src_gl_matrix_vec_ = {};

/* TODO: ImportDeclaration in tsickle_declare_module.gl_matrix_src_gl_matrix_vec_ */

/* TODO: ExportAssignment in tsickle_declare_module.gl_matrix_src_gl_matrix_vec_ */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "gl-matrix/src/gl-matrix/vec3"
/** @const */
tsickle_declare_module.gl_matrix_src_gl_matrix_vec_ = {};

/* TODO: ImportDeclaration in tsickle_declare_module.gl_matrix_src_gl_matrix_vec_ */

/* TODO: ExportAssignment in tsickle_declare_module.gl_matrix_src_gl_matrix_vec_ */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "gl-matrix/src/gl-matrix/vec4"
/** @const */
tsickle_declare_module.gl_matrix_src_gl_matrix_vec_ = {};

/* TODO: ImportDeclaration in tsickle_declare_module.gl_matrix_src_gl_matrix_vec_ */

/* TODO: ExportAssignment in tsickle_declare_module.gl_matrix_src_gl_matrix_vec_ */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "gl-matrix/src/gl-matrix/mat2"
/** @const */
tsickle_declare_module.gl_matrix_src_gl_matrix_mat_ = {};

/* TODO: ImportDeclaration in tsickle_declare_module.gl_matrix_src_gl_matrix_mat_ */

/* TODO: ExportAssignment in tsickle_declare_module.gl_matrix_src_gl_matrix_mat_ */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "gl-matrix/src/gl-matrix/mat2d"
/** @const */
tsickle_declare_module.gl_matrix_src_gl_matrix_mat_d = {};

/* TODO: ImportDeclaration in tsickle_declare_module.gl_matrix_src_gl_matrix_mat_d */

/* TODO: ExportAssignment in tsickle_declare_module.gl_matrix_src_gl_matrix_mat_d */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "gl-matrix/src/gl-matrix/mat3"
/** @const */
tsickle_declare_module.gl_matrix_src_gl_matrix_mat_ = {};

/* TODO: ImportDeclaration in tsickle_declare_module.gl_matrix_src_gl_matrix_mat_ */

/* TODO: ExportAssignment in tsickle_declare_module.gl_matrix_src_gl_matrix_mat_ */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "gl-matrix/src/gl-matrix/mat4"
/** @const */
tsickle_declare_module.gl_matrix_src_gl_matrix_mat_ = {};

/* TODO: ImportDeclaration in tsickle_declare_module.gl_matrix_src_gl_matrix_mat_ */

/* TODO: ExportAssignment in tsickle_declare_module.gl_matrix_src_gl_matrix_mat_ */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "gl-matrix/src/gl-matrix/quat"
/** @const */
tsickle_declare_module.gl_matrix_src_gl_matrix_quat = {};

/* TODO: ImportDeclaration in tsickle_declare_module.gl_matrix_src_gl_matrix_quat */

/* TODO: ExportAssignment in tsickle_declare_module.gl_matrix_src_gl_matrix_quat */
