/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/webmidi/index.d.ts:

/**
 * When invoked, returns a Promise object representing a request for access to MIDI
 * devices on the user's system.
 * @param {!WebMidi.MIDIOptions=} options
 * @return {!Promise<!WebMidi.MIDIAccess>}
 */
Navigator.prototype.requestMIDIAccess = function(options) {};
/** @const */
var WebMidi = {};
/**
 * @record
 * @struct
 */
WebMidi.MIDIOptions = function() {};
 /** @type {boolean} */
WebMidi.MIDIOptions.prototype.sysex;

/** @typedef {!Map<string, !WebMidi.MIDIInput>} */
WebMidi.MIDIInputMap;

/** @typedef {!Map<string, !WebMidi.MIDIOutput>} */
WebMidi.MIDIOutputMap;
/**
 * @record
 * @struct
 */
WebMidi.MIDIAccess = function() {};
 /** @type {!Map<string, !WebMidi.MIDIInput>} */
WebMidi.MIDIAccess.prototype.inputs;
 /** @type {!Map<string, !WebMidi.MIDIOutput>} */
WebMidi.MIDIAccess.prototype.outputs;
 /** @type {boolean} */
WebMidi.MIDIAccess.prototype.sysexEnabled;

/**
 * The handler called when a new port is connected or an existing port changes the
 * state attribute.
 * @param {!WebMidi.MIDIConnectionEvent} e
 * @return {void}
 */
WebMidi.MIDIAccess.prototype.onstatechange = function(e) {};

/** @typedef {string} */
WebMidi.MIDIPortType;

/** @typedef {string} */
WebMidi.MIDIPortDeviceState;

/** @typedef {string} */
WebMidi.MIDIPortConnectionState;
/**
 * @record
 * @struct
 */
WebMidi.MIDIPort = function() {};
 /** @type {string} */
WebMidi.MIDIPort.prototype.id;
 /** @type {string} */
WebMidi.MIDIPort.prototype.manufacturer;
 /** @type {string} */
WebMidi.MIDIPort.prototype.name;
 /** @type {string} */
WebMidi.MIDIPort.prototype.type;
 /** @type {string} */
WebMidi.MIDIPort.prototype.version;
 /** @type {string} */
WebMidi.MIDIPort.prototype.state;
 /** @type {string} */
WebMidi.MIDIPort.prototype.connection;

/**
 * The handler called when an existing port changes its state or connection
 * attributes.
 * @param {!WebMidi.MIDIConnectionEvent} e
 * @return {void}
 */
WebMidi.MIDIPort.prototype.onstatechange = function(e) {};

/**
 * Makes the MIDI device corresponding to the MIDIPort explicitly available. Note
 * that this call is NOT required in order to use the MIDIPort - calling send() on
 * a MIDIOutput or attaching a MIDIMessageEvent handler on a MIDIInputPort will
 * cause an implicit open().
 * 
 * When invoked, this method returns a Promise object representing a request for
 * access to the given MIDI port on the user's system.
 * @return {!Promise<!WebMidi.MIDIPort>}
 */
WebMidi.MIDIPort.prototype.open = function() {};

/**
 * Makes the MIDI device corresponding to the MIDIPort
 * explicitly unavailable (subsequently changing the state from "open" to
 * "connected"). Note that successful invocation of this method will result in MIDI
 * messages no longer being delivered to MIDIMessageEvent handlers on a
 * MIDIInputPort (although setting a new handler will cause an implicit open()).
 * 
 * When invoked, this method returns a Promise object representing a request for
 * access to the given MIDI port on the user's system. When the port has been
 * closed (and therefore, in exclusive access systems, the port is available to
 * other applications), the vended Promise is resolved. If the port is
 * disconnected, the Promise is rejected.
 * @return {!Promise<!WebMidi.MIDIPort>}
 */
WebMidi.MIDIPort.prototype.close = function() {};
/**
 * @extends {WebMidi.MIDIPort}
 * @record
 * @struct
 */
WebMidi.MIDIInput = function() {};

/**
 * @param {!WebMidi.MIDIMessageEvent} e
 * @return {void}
 */
WebMidi.MIDIInput.prototype.onmidimessage = function(e) {};
/**
 * @extends {WebMidi.MIDIPort}
 * @record
 * @struct
 */
WebMidi.MIDIOutput = function() {};

/**
 * Enqueues the message to be sent to the corresponding MIDI port.
 * @param {!Array<number>} data The data to be enqueued, with each sequence entry representing a single byte of data.
 * @param {number=} timestamp The time at which to begin sending the data to the port. If timestamp is set
 * to zero (or another time in the past), the data is to be sent as soon as
 * possible.
 * @return {void}
 */
WebMidi.MIDIOutput.prototype.send = function(data, timestamp) {};

/**
 * Clears any pending send data that has not yet been sent from the MIDIOutput 's
 * queue. The implementation will need to ensure the MIDI stream is left in a good
 * state, so if the output port is in the middle of a sysex message, a sysex
 * termination byte (0xf7) should be sent.
 * @return {void}
 */
WebMidi.MIDIOutput.prototype.clear = function() {};
/**
 * @record
 * @struct
 */
WebMidi.MIDIMessageEvent = function() {};
 /** @type {number} */
WebMidi.MIDIMessageEvent.prototype.receivedTime;
 /** @type {!Uint8Array} */
WebMidi.MIDIMessageEvent.prototype.data;
/**
 * @extends {EventInit}
 * @record
 * @struct
 */
WebMidi.MIDIMessageEventInit = function() {};
 /** @type {number} */
WebMidi.MIDIMessageEventInit.prototype.receivedTime;
 /** @type {!Uint8Array} */
WebMidi.MIDIMessageEventInit.prototype.data;
/**
 * @record
 * @struct
 */
WebMidi.MIDIConnectionEvent = function() {};
 /** @type {!WebMidi.MIDIPort} */
WebMidi.MIDIConnectionEvent.prototype.port;
/**
 * @extends {EventInit}
 * @record
 * @struct
 */
WebMidi.MIDIConnectionEventInit = function() {};
 /** @type {!WebMidi.MIDIPort} */
WebMidi.MIDIConnectionEventInit.prototype.port;
