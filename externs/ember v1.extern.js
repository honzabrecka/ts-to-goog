/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/ember v1/index.d.ts:
/** @const */
var EmberStates = {};
/**
 * @record
 * @struct
 */
EmberStates.Transition = function() {};
 /** @type {string} */
EmberStates.Transition.prototype.targetName;
 /** @type {string} */
EmberStates.Transition.prototype.urlMethod;
 /** @type {?} */
EmberStates.Transition.prototype.intent;
 /** @type {?} */
EmberStates.Transition.prototype.params;
 /** @type {?} */
EmberStates.Transition.prototype.pivotHandler;
 /** @type {number} */
EmberStates.Transition.prototype.resolveIndex;
 /** @type {?} */
EmberStates.Transition.prototype.handlerInfos;
 /** @type {?} */
EmberStates.Transition.prototype.resolvedModels;
 /** @type {boolean} */
EmberStates.Transition.prototype.isActive;
 /** @type {?} */
EmberStates.Transition.prototype.state;
 /** @type {?} */
EmberStates.Transition.prototype.queryParams;
 /** @type {boolean} */
EmberStates.Transition.prototype.queryParamsOnly;
 /** @type {boolean} */
EmberStates.Transition.prototype.isTransition;
 /** @type {!Ember.RSVP.Promise} */
EmberStates.Transition.prototype.promise;
 /** @type {?} */
EmberStates.Transition.prototype.data;

/**
 * A standard promise hook that resolves if the transition
 * succeeds and rejects if it fails/redirects/aborts.
 * Forwards to the internal `promise` property which you can
 * use in situations where you want to pass around a thennable,
 * but not the Transition itself.
 * \@arg {Function} onFulfilled
 * \@arg {Function} onRejected
 * \@arg {String} label optional string for labeling the promise. Useful for tooling.
 * @param {!Function} onFulfilled
 * @param {!Function=} onRejected
 * @param {string=} label
 * @return {!Ember.RSVP.Promise}
 */
EmberStates.Transition.prototype.then = function(onFulfilled, onRejected, label) {};

/**
 * Forwards to the internal `promise` property which you can
 * use in situations where you want to pass around a thennable,
 * but not the Transition itself.
 * \@method catch
 * \@arg {Function} onRejection
 * \@arg {String} label optional string for labeling the promise.
 * Useful for tooling.
 * @param {!Function} onRejection
 * @param {string=} label
 * @return {!Ember.RSVP.Promise}
 */
EmberStates.Transition.prototype.catch = function(onRejection, label) {};

/**
 * Forwards to the internal `promise` property which you can
 * use in situations where you want to pass around a thennable,
 * but not the Transition itself.
 * \@method finally
 * \@arg {Function} callback
 * \@arg {String} label optional string for labeling the promise.
 * Useful for tooling.
 * @param {!Function} callback
 * @param {string=} label
 * @return {!Ember.RSVP.Promise}
 */
EmberStates.Transition.prototype.finally = function(callback, label) {};

/**
 * Aborts the Transition. Note you can also implicitly abort a transition
 * by initiating another transition while a previous one is underway.
 * @return {!EmberStates.Transition}
 */
EmberStates.Transition.prototype.abort = function() {};

/**
 * @param {!Ember.StateManager} manager
 * @param {!Array<?>} contexts
 * @return {void}
 */
EmberStates.Transition.prototype.normalize = function(manager, contexts) {};

/**
 * Retries a previously-aborted transition (making sure to abort the
 * transition if it's still active). Returns a new transition that
 * represents the new attempt to transition.
 * @return {!EmberStates.Transition}
 */
EmberStates.Transition.prototype.retry = function() {};

/**
 * Sets the URL-changing method to be employed at the end of a
 * successful transition. By default, a new Transition will just
 * use `updateURL`, but passing 'replace' to this method will
 * cause the URL to update using 'replaceWith' instead. Omitting
 * a parameter will disable the URL change, allowing for transitions
 * that don't update the URL at completion (this is also used for
 * handleURL, since the URL has already changed before the
 * transition took place).
 * \@arg {String} method the type of URL-changing method to use
 * at the end of a transition. Accepted values are 'replace',
 * falsy values, or any other non-falsy value (which is
 * interpreted as an updateURL transition).
 * @param {string} method
 * @return {!EmberStates.Transition}
 */
EmberStates.Transition.prototype.method = function(method) {};

/**
 * Fires an event on the current list of resolved/resolving
 * handlers within this transition. Useful for firing events
 * on route hierarchies that haven't fully been entered yet.
 * Note: This method is also aliased as `send`
 * \@arg {Boolean} [ignoreFailure=false] a boolean specifying whether unhandled events throw an error
 * \@arg {String} name the name of the event to fire
 * Fires an event on the current list of resolved/resolving
 * handlers within this transition. Useful for firing events
 * on route hierarchies that haven't fully been entered yet.
 * Note: This method is also aliased as `send`
 * \@arg {String} name the name of the event to fire
 * @param {boolean|string} ignoreFailure_or_eventName
 * @param {string=} eventName
 * @return {void}
 */
EmberStates.Transition.prototype.trigger = function(ignoreFailure_or_eventName, eventName) {};

/**
 * Transitions are aborted and their promises rejected
 * when redirects occur; this method returns a promise
 * that will follow any redirects that occur and fulfill
 * with the value fulfilled by any redirecting transitions
 * that occur.
 * value that the final redirecting transition fulfills with
 * @return {!Ember.RSVP.Promise}
 */
EmberStates.Transition.prototype.followRedirects = function() {};
/** @const */
var EmberTesting = {};
/** @const */
EmberTesting.Test = {};
/**
 * @constructor
 * @struct
 */
EmberTesting.Test.Adapter = function() {};

/**
 * @return {void}
 */
EmberTesting.Test.Adapter.prototype.asyncEnd = function() {};

/**
 * @return {void}
 */
EmberTesting.Test.Adapter.prototype.asyncStart = function() {};

/**
 * @param {string} error
 * @return {void}
 */
EmberTesting.Test.Adapter.prototype.exception = function(error) {};
/**
 * @extends {EmberTesting.Test.Adapter}
 * @constructor
 * @struct
 */
EmberTesting.Test.QUnitAdapter = function() {};

/**
 * @param {...string} args
 * @return {!Function}
 */
Function.prototype.observes = function(args) {};

/**
 * @param {...string} args
 * @return {!Function}
 */
Function.prototype.observesBefore = function(args) {};

/**
 * @param {...string} args
 * @return {!Function}
 */
Function.prototype.on = function(args) {};

/**
 * @param {...string} args
 * @return {!Function}
 */
Function.prototype.property = function(args) {};

/**
 * @return {string}
 */
String.prototype.camelize = function() {};

/**
 * @return {string}
 */
String.prototype.capitalize = function() {};

/**
 * @return {string}
 */
String.prototype.classify = function() {};

/**
 * @return {string}
 */
String.prototype.dasherize = function() {};

/**
 * @return {string}
 */
String.prototype.decamelize = function() {};

/**
 * @param {...string} args
 * @return {string}
 */
String.prototype.fmt = function(args) {};

/**
 * @return {?}
 */
String.prototype.htmlSafe = function() {};

/**
 * @param {...string} args
 * @return {string}
 */
String.prototype.loc = function(args) {};

/**
 * @return {string}
 */
String.prototype.underscore = function() {};

/**
 * @return {!Array<string>}
 */
String.prototype.w = function() {};
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Array.prototype.reject;

/* TODO: PropertySignature: '[]' */

/* TODO: PropertySignature: '@each' */
 /** @type {boolean} */
Array.prototype.Boolean;
 /** @type {?} */
Array.prototype.firstObject;
 /** @type {boolean} */
Array.prototype.hasEnumerableObservers;
 /** @type {?} */
Array.prototype.lastObject;
 /** @type {!ModifyObserver} */
Array.prototype.addObserver;

/**
 * @param {!Array<?>} arr
 * @return {void}
 */
Array.prototype.constructor = function(arr) {};

/**
 * @return {void}
 */
Array.prototype.activate = function() {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions=} opts
 * @return {!Array<?>}
 */
Array.prototype.addArrayObserver = function(target, opts) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Array<?>}
 */
Array.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Array.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Array.prototype.anyBy = function(key, value) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Array.prototype.arrayContentDidChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Array.prototype.arrayContentWillChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {boolean}
 */
Array.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Array.prototype.clear = function() {};

/**
 * @return {!Array<?>}
 */
Array.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Array.prototype.contains = function(obj) {};

/**
 * @param {number|!Ember.Enumerable} start_or_removing
 * @param {number|!Ember.Enumerable} removing_or_adding
 * @param {number|!Ember.Enumerable=} adding
 * @return {?}
 */
Array.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {number|!Ember.Enumerable} removing
 * @param {number|!Ember.Enumerable} adding
 * @return {!Array<?>}
 */
Array.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Array.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Array.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {boolean}
 */
Array.prototype.everyProperty = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {!Array<?>}
 */
Array.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Array.prototype.filterBy = function(key, value) {};

/**
 * Returns the first item in the array for which the callback returns true.
 * This method works similar to the `filter()` method defined in JavaScript 1.6
 * except that it will stop working on the array once a match is found.
 * The callback method you provide should have the following signature (all
 * parameters are optional):
 * ```javascript
 * function(item, index, enumerable);
 * ```
 * - `item` is the current item in the iteration.
 * - `index` is the current index in the iteration.
 * - `enumerable` is the enumerable object itself.
 * It should return the `true` to include the item in the results, `false`
 * otherwise.
 * Note that in addition to a callback, you can also pass an optional target
 * object that will be set as `this` on the context. This is a good way
 * to give your iterator function access to the current object.
 * \@arg callback The callback to execute
 * \@arg {Object} [target] The target object to use
 * @param {!Function} callback
 * @param {?=} target
 * @return {?}
 */
Array.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Array.prototype.findBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {?}
 */
Array.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Array.prototype.getEach = function(key) {};

/**
 * @param {?} object
 * @param {number=} startAt
 * @return {number}
 */
Array.prototype.indexOf = function(object, startAt) {};

/**
 * @param {number} idx
 * @param {?} object
 * @return {!Array<?>}
 */
Array.prototype.insertAt = function(idx, object) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Array.prototype.invoke = function(methodName, args) {};

/**
 * @param {?} object
 * @param {number=} startAt
 * @return {number}
 */
Array.prototype.lastIndexOf = function(object, startAt) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {!Array<?>}
 */
Array.prototype.map = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Array.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Array.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {number} idx
 * @return {?}
 */
Array.prototype.objectAt = function(idx) {};

/**
 * @param {...number} args
 * @return {!Array<?>}
 */
Array.prototype.objectsAt = function(args) {};

/**
 * @return {?}
 */
Array.prototype.popObject = function() {};

/**
 * @param {?} obj
 * @return {?}
 */
Array.prototype.pushObject = function(obj) {};

/**
 * @param {...?} args
 * @return {!Array<?>}
 */
Array.prototype.pushObjects = function(args) {};

/**
 * @param {!ReduceCallback} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Array.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Array.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Array<?>}
 */
Array.prototype.removeArrayObserver = function(target, opts) {};

/**
 * @param {number} start
 * @param {number} len
 * @return {?}
 */
Array.prototype.removeAt = function(start, len) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Array<?>}
 */
Array.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {number} idx
 * @param {number} amt
 * @param {!Array<?>} objects
 * @return {void}
 */
Array.prototype.replace = function(idx, amt, objects) {};

/**
 * @return {!Array<?>}
 */
Array.prototype.reverseObjects = function() {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Array.prototype.setEach = function(key, value) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Array.prototype.setObjects = function(objects) {};

/**
 * @return {?}
 */
Array.prototype.shiftObject = function() {};

/**
 * @param {number=} beginIndex
 * @param {number=} endIndex
 * @return {!Array<?>}
 */
Array.prototype.slice = function(beginIndex, endIndex) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Array.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Array.prototype.toArray = function() {};

/**
 * @return {!Array<?>}
 */
Array.prototype.uniq = function() {};

/**
 * @param {?} object
 * @return {?}
 */
Array.prototype.unshiftObject = function(object) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Array.prototype.unshiftObjects = function(objects) {};

/**
 * @param {?} value
 * @return {!Array<?>}
 */
Array.prototype.without = function(value) {};

/**
 * @param {?} object
 * @return {?}
 */
Array.prototype.addObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Array<?>}
 */
Array.prototype.addObjects = function(objects) {};

/**
 * @param {?} object
 * @return {?}
 */
Array.prototype.removeObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Array<?>}
 */
Array.prototype.removeObjects = function(objects) {};

/**
 * @return {!Array<?>}
 */
Array.prototype.beginPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Array.prototype.cacheFor = function(keyName) {};

/**
 * @param {string} keyName
 * @param {number=} decrement
 * @return {number}
 */
Array.prototype.decrementProperty = function(keyName, decrement) {};

/**
 * @return {!Array<?>}
 */
Array.prototype.endPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Array.prototype.get = function(keyName) {};

/**
 * @param {...string|!Array<string>} args_or_keys
 * @return {!Object}
 */
Array.prototype.getProperties = function(args_or_keys) {};

/**
 * @param {string} keyName
 * @param {?} defaultValue
 * @return {?}
 */
Array.prototype.getWithDefault = function(keyName, defaultValue) {};

/**
 * @param {string} key
 * @return {boolean}
 */
Array.prototype.hasObserverFor = function(key) {};

/**
 * @param {string} keyName
 * @param {number=} increment
 * @return {number}
 */
Array.prototype.incrementProperty = function(keyName, increment) {};

/**
 * @param {string} keyName
 * @return {!Array<?>}
 */
Array.prototype.notifyPropertyChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Array<?>}
 */
Array.prototype.propertyDidChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Array<?>}
 */
Array.prototype.propertyWillChange = function(keyName) {};

/**
 * @param {string} key
 * @param {?} target
 * @param {string|!Function} method
 * @return {!Ember.Observable}
 */
Array.prototype.removeObserver = function(key, target, method) {};

/**
 * @param {string} keyName
 * @param {?} value
 * @return {!Array<?>}
 */
Array.prototype.set = function(keyName, value) {};

/**
 * @param {!Object} hash
 * @return {!Array<?>}
 */
Array.prototype.setProperties = function(hash) {};

/**
 * @param {string} keyName
 * @return {?}
 */
Array.prototype.toggleProperty = function(keyName) {};

/**
 * @param {boolean} deep
 * @return {!Array<?>}
 */
Array.prototype.copy = function(deep) {};

/**
 * @return {!Array<?>}
 */
Array.prototype.frozenCopy = function() {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Array.prototype.isAny = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Array.prototype.isEvery = function(key, value) {};
/**
 * @record
 * @struct
 */
function ApplicationCreateArguments() {}
 /** @type {!Object} */
ApplicationCreateArguments.prototype.customEvents;
 /** @type {string} */
ApplicationCreateArguments.prototype.rootElement;
 /** @type {boolean} */
ApplicationCreateArguments.prototype.LOG_TRANSITIONS;
 /** @type {boolean} */
ApplicationCreateArguments.prototype.LOG_TRANSITIONS_INTERNAL;
/**
 * @record
 * @struct
 */
function ApplicationInitializerArguments() {}
 /** @type {string} */
ApplicationInitializerArguments.prototype.name;
 /** @type {!ApplicationInitializerFunction} */
ApplicationInitializerArguments.prototype.initialize;
/**
 * @record
 * @struct
 */
function ApplicationInitializerFunction() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function CoreObjectArguments() {}
 /** @type {!Function} */
CoreObjectArguments.prototype.init;
 /** @type {!Function} */
CoreObjectArguments.prototype.willDestroy;

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function EnumerableConfigurationOptions() {}
 /** @type {boolean} */
EnumerableConfigurationOptions.prototype.willChange;
 /** @type {boolean} */
EnumerableConfigurationOptions.prototype.didChange;
/**
 * @record
 * @struct
 */
function ItemIndexEnumerableCallbackTarget() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ItemIndexEnumerableCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ReduceCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function TransitionsHash() {}
 /** @type {!Array<?>} */
TransitionsHash.prototype.contexts;
 /** @type {!Array<!Ember.State>} */
TransitionsHash.prototype.exitStates;
 /** @type {!Array<!Ember.State>} */
TransitionsHash.prototype.enterStates;
 /** @type {!Ember.State} */
TransitionsHash.prototype.resolveState;
/**
 * @record
 * @struct
 */
function ActionsHash() {}
 /** @type {!Function} */
ActionsHash.prototype.willTransition;
 /** @type {!Function} */
ActionsHash.prototype.error;
/**
 * @record
 * @struct
 */
function DisconnectOutletOptions() {}
 /** @type {string} */
DisconnectOutletOptions.prototype.outlet;
 /** @type {string} */
DisconnectOutletOptions.prototype.parentView;
/**
 * @record
 * @struct
 */
function RenderOptions() {}
 /** @type {string} */
RenderOptions.prototype.into;
 /** @type {string} */
RenderOptions.prototype.controller;
 /** @type {?} */
RenderOptions.prototype.model;
 /** @type {string} */
RenderOptions.prototype.outlet;
 /** @type {string} */
RenderOptions.prototype.view;
/**
 * @record
 * @struct
 */
function ModifyObserver() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
/** @const */
var Ember = {};
 /** @type {!JQueryStatic<!HTMLElement>} */
Ember.$;

/**
 * Creates an Ember.NativeArray from an Array like object. Does not modify the original object.
 * Ember.A is not needed if Ember.EXTEND_PROTOTYPES is true (the default value). However, it is
 * recommended that you use Ember.A when creating addons for ember or when you can not garentee
 * that Ember.EXTEND_PROTOTYPES will be true.
 * 
 * @param {!Array<?>=} arr
 * @return {!Ember.NativeArray}
 */
Ember.A = function(arr) {};
/**
 * @constructor
 * @struct
 */
Ember.ActionHandlerMixin = function() {};
 /** @type {!ActionsHash} */
Ember.ActionHandlerMixin.prototype.actions;

/**
 * Triggers a named action on the ActionHandler
 * 
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.ActionHandlerMixin.prototype.send = function(name, args) {};
/**
 * @extends {Ember.Namespace}
 * @constructor
 * @struct
 */
Ember.Application = function() {};
 /** @type {boolean} */
Ember.Application.isClass;
 /** @type {boolean} */
Ember.Application.isMethod;
 /** @type {!Object} */
Ember.Application.prototype.customEvents;
 /** @type {!Ember.EventDispatcher} */
Ember.Application.prototype.eventDispatcher;
 /** @type {!Ember.DefaultResolver} */
Ember.Application.prototype.resolver;
 /** @type {!HTMLElement} */
Ember.Application.prototype.rootElement;
 /** @type {!Function} */
Ember.Application.prototype.ready;
 /** @type {!Ember.Router} */
Ember.Application.prototype.Router;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Application.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Application.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.Application.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.Application.metaForProperty = function(key) {};

/**
 * @param {!ApplicationInitializerArguments=} args
 * @return {void}
 */
Ember.Application.initializer = function(args) {};

/**
 * Call advanceReadiness after any asynchronous setup logic has completed.
 * Each call to deferReadiness must be matched by a call to advanceReadiness
 * or the application will never become ready and routing will not begin.
 * 
 * @return {void}
 */
Ember.Application.prototype.advanceReadiness = function() {};

/**
 * Use this to defer readiness until some condition is true.
 * This allows you to perform asynchronous setup logic and defer
 * booting your application until the setup has finished.
 * However, if the setup requires a loading UI, it might be better
 * to use the router for this purpose.
 * @return {void}
 */
Ember.Application.prototype.deferReadiness = function() {};

/**
 * defines an injection or typeInjection
 * 
 * @param {string} factoryNameOrType
 * @param {string} property
 * @param {string} injectionName
 * @return {void}
 */
Ember.Application.prototype.inject = function(factoryNameOrType, property, injectionName) {};

/**
 * This injects the test helpers into the window's scope. If a function of the
 * same name has already been defined it will be cached (so that it can be reset
 * if the helper is removed with `unregisterHelper` or `removeTestHelpers`).
 * Any callbacks registered with `onInjectHelpers` will be called once the
 * helpers have been injected.
 * 
 * @return {void}
 */
Ember.Application.prototype.injectTestHelpers = function() {};

/**
 * registers a factory for later injection
 * @param {string} fullName type:name (e.g., 'model:user')
 * @param {!Function} factory (e.g., App.Person)
 * 
 * @param {!Object=} options
 * @return {void}
 */
Ember.Application.prototype.register = function(fullName, factory, options) {};

/**
 * This removes all helpers that have been registered, and resets and functions
 * that were overridden by the helpers.
 * 
 * @return {void}
 */
Ember.Application.prototype.removeTestHelpers = function() {};

/**
 * Reset the application. This is typically used only in tests.
 * 
 * @return {void}
 */
Ember.Application.prototype.reset = function() {};

/**
 * This hook defers the readiness of the application, so that you can start
 * the app when your tests are ready to run. It also sets the router's
 * location to 'none', so that the window's location will not be modified
 * (preventing both accidental leaking of state between tests and interference
 * with your testing framework).
 * 
 * @return {void}
 */
Ember.Application.prototype.setupForTesting = function() {};
/**
 * @extends {Ember.Enumerable}
 * @constructor
 * @struct
 */
Ember.Array = function() {};
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.Array.prototype.map;
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.Array.prototype.reject;

/* TODO: PropertyDeclaration: Ember.'@each' */
 /** @type {boolean} */
Ember.Array.prototype.Boolean;

/* TODO: PropertyDeclaration: Ember.'[]' */
 /** @type {?} */
Ember.Array.prototype.firstObject;
 /** @type {boolean} */
Ember.Array.prototype.hasEnumerableObservers;
 /** @type {?} */
Ember.Array.prototype.lastObject;
 /** @type {number} */
Ember.Array.prototype.length;

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions=} opts
 * @return {!Array<?>}
 */
Ember.Array.prototype.addArrayObserver = function(target, opts) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Enumerable}
 */
Ember.Array.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Array.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Array.prototype.anyBy = function(key, value) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.Array.prototype.arrayContentDidChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.Array.prototype.arrayContentWillChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Array.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Ember.Array.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Array.prototype.contains = function(obj) {};

/**
 * @param {number|!Ember.Enumerable} start_or_removing
 * @param {number|!Ember.Enumerable} removing_or_adding
 * @param {number|!Ember.Enumerable=} adding
 * @return {?}
 */
Ember.Array.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {number|!Ember.Enumerable} removing
 * @param {number|!Ember.Enumerable} adding
 * @return {!Ember.Enumerable}
 */
Ember.Array.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Array.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Array.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Array.prototype.everyProperty = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {!Array<?>}
 */
Ember.Array.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.Array.prototype.filterBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {?}
 */
Ember.Array.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Ember.Array.prototype.findBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {?}
 */
Ember.Array.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.Array.prototype.getEach = function(key) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.Array.prototype.indexOf = function(object, startAt) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.Array.prototype.invoke = function(methodName, args) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.Array.prototype.lastIndexOf = function(object, startAt) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.Array.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Ember.Array.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {number} idx
 * @return {?}
 */
Ember.Array.prototype.objectAt = function(idx) {};

/**
 * @param {...number} args
 * @return {!Array<?>}
 */
Ember.Array.prototype.objectsAt = function(args) {};

/**
 * @param {!ReduceCallback} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Ember.Array.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.Array.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Array<?>}
 */
Ember.Array.prototype.removeArrayObserver = function(target, opts) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Enumerable}
 */
Ember.Array.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Ember.Array.prototype.setEach = function(key, value) {};

/**
 * @param {number=} beginIndex
 * @param {number=} endIndex
 * @return {!Array<?>}
 */
Ember.Array.prototype.slice = function(beginIndex, endIndex) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Array.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Ember.Array.prototype.toArray = function() {};

/**
 * @return {!Ember.Enumerable}
 */
Ember.Array.prototype.uniq = function() {};

/**
 * @param {?} value
 * @return {!Ember.Enumerable}
 */
Ember.Array.prototype.without = function(value) {};
/**
 * @extends {Ember.ArrayProxy}
 * @extends {Ember.SortableMixin}
 * @extends {Ember.ControllerMixin}
 * @constructor
 * @struct
 */
Ember.ArrayController = function() {};
 /** @type {boolean} */
Ember.ArrayController.isClass;
 /** @type {boolean} */
Ember.ArrayController.isMethod;
 /** @type {?} */
Ember.ArrayController.prototype.arrangedContent;
 /** @type {string} */
Ember.ArrayController.prototype.itemController;
 /** @type {boolean} */
Ember.ArrayController.prototype.sortAscending;
 /** @type {!Ember.Comparable} */
Ember.ArrayController.prototype.sortFunction;
 /** @type {!Array<?>} */
Ember.ArrayController.prototype.sortProperties;
 /** @type {!Object} */
Ember.ArrayController.prototype.controllers;
 /** @type {!Array<string>} */
Ember.ArrayController.prototype.needs;
 /** @type {?} */
Ember.ArrayController.prototype.target;
 /** @type {?} */
Ember.ArrayController.prototype.model;
 /** @type {?} */
Ember.ArrayController.prototype.queryParams;
 /** @type {!Object} */
Ember.ArrayController.prototype.actions;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.ArrayController.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.ArrayController.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.ArrayController.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.ArrayController.metaForProperty = function(key) {};

/**
 * @param {?} object
 * @return {string}
 */
Ember.ArrayController.prototype.lookupItemController = function(object) {};

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.ArrayController.prototype.replaceRoute = function(name, args) {};

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.ArrayController.prototype.transitionToRoute = function(name, args) {};

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.ArrayController.prototype.send = function(name, args) {};
 /** @type {{map: !ItemIndexEnumerableCallbackTarget, forEach: function(!Function, ?): ?, indexOf: function(?, number): number}} */
Ember.ArrayPolyfills;
/**
 * @extends {Ember.Object}
 * @extends {Ember.MutableArray}
 * @constructor
 * @struct
 */
Ember.ArrayProxy = function() {};
 /** @type {boolean} */
Ember.ArrayProxy.isClass;
 /** @type {boolean} */
Ember.ArrayProxy.isMethod;
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.ArrayProxy.prototype.map;
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.ArrayProxy.prototype.reject;

/* TODO: PropertyDeclaration: Ember.'[]' */

/* TODO: PropertyDeclaration: Ember.'@each' */
 /** @type {boolean} */
Ember.ArrayProxy.prototype.Boolean;
 /** @type {?} */
Ember.ArrayProxy.prototype.firstObject;
 /** @type {boolean} */
Ember.ArrayProxy.prototype.hasEnumerableObservers;
 /** @type {?} */
Ember.ArrayProxy.prototype.lastObject;
 /** @type {number} */
Ember.ArrayProxy.prototype.length;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.ArrayProxy.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.ArrayProxy.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.ArrayProxy.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.ArrayProxy.metaForProperty = function(key) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions=} opts
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.addArrayObserver = function(target, opts) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Enumerable}
 */
Ember.ArrayProxy.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.anyBy = function(key, value) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.arrayContentDidChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.arrayContentWillChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.clear = function() {};

/**
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.contains = function(obj) {};

/**
 * @param {number|!Ember.Enumerable} start_or_removing
 * @param {number|!Ember.Enumerable} removing_or_adding
 * @param {number|!Ember.Enumerable=} adding
 * @return {?}
 */
Ember.ArrayProxy.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {number|!Ember.Enumerable} removing
 * @param {number|!Ember.Enumerable} adding
 * @return {!Ember.Enumerable}
 */
Ember.ArrayProxy.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.everyProperty = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.filterBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {?}
 */
Ember.ArrayProxy.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Ember.ArrayProxy.prototype.findBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {?}
 */
Ember.ArrayProxy.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.getEach = function(key) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.ArrayProxy.prototype.indexOf = function(object, startAt) {};

/**
 * @param {number} idx
 * @param {?} object
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.insertAt = function(idx, object) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.invoke = function(methodName, args) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.ArrayProxy.prototype.lastIndexOf = function(object, startAt) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Ember.ArrayProxy.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {number} idx
 * @return {?}
 */
Ember.ArrayProxy.prototype.objectAt = function(idx) {};

/**
 * @param {number} idx
 * @return {?}
 */
Ember.ArrayProxy.prototype.objectAtContent = function(idx) {};

/**
 * @param {...number} args
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.objectsAt = function(args) {};

/**
 * @return {?}
 */
Ember.ArrayProxy.prototype.popObject = function() {};

/**
 * @param {?} obj
 * @return {?}
 */
Ember.ArrayProxy.prototype.pushObject = function(obj) {};

/**
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.pushObjects = function(args) {};

/**
 * @param {!ReduceCallback} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Ember.ArrayProxy.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.removeArrayObserver = function(target, opts) {};

/**
 * @param {number} start
 * @param {number} len
 * @return {?}
 */
Ember.ArrayProxy.prototype.removeAt = function(start, len) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Enumerable}
 */
Ember.ArrayProxy.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {number} idx
 * @param {number} amt
 * @param {!Array<?>} objects
 * @return {?}
 */
Ember.ArrayProxy.prototype.replace = function(idx, amt, objects) {};

/**
 * @param {number} idx
 * @param {number} amt
 * @param {!Array<?>} objects
 * @return {void}
 */
Ember.ArrayProxy.prototype.replaceContent = function(idx, amt, objects) {};

/**
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.reverseObjects = function() {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Ember.ArrayProxy.prototype.setEach = function(key, value) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.setObjects = function(objects) {};

/**
 * @return {?}
 */
Ember.ArrayProxy.prototype.shiftObject = function() {};

/**
 * @param {number=} beginIndex
 * @param {number=} endIndex
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.slice = function(beginIndex, endIndex) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.toArray = function() {};

/**
 * @return {!Ember.Enumerable}
 */
Ember.ArrayProxy.prototype.uniq = function() {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.ArrayProxy.prototype.unshiftObject = function(object) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.unshiftObjects = function(objects) {};

/**
 * @param {?} value
 * @return {!Ember.Enumerable}
 */
Ember.ArrayProxy.prototype.without = function(value) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.ArrayProxy.prototype.addObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.ArrayProxy.prototype.addObjects = function(objects) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.ArrayProxy.prototype.removeObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.ArrayProxy.prototype.removeObjects = function(objects) {};
 /** @type {boolean} */
Ember.BOOTED;

/**
 * @constructor
 * @struct
 * @param {string} toPath
 * @param {string} fromPath
 */
Ember.Binding = function(toPath, fromPath) {};

/**
 * @param {?} obj
 * @return {!Ember.Binding}
 */
Ember.Binding.prototype.connect = function(obj) {};

/**
 * @return {!Ember.Binding}
 */
Ember.Binding.prototype.copy = function() {};

/**
 * @param {?} obj
 * @return {!Ember.Binding}
 */
Ember.Binding.prototype.disconnect = function(obj) {};

/**
 * @param {string} path
 * @return {!Ember.Binding}
 */
Ember.Binding.prototype.from = function(path) {};

/**
 * @param {string} from
 * @param {boolean=} flag
 * @return {!Ember.Binding}
 */
Ember.Binding.oneWay = function(from, flag) {};

/**
 * @param {string|!Array<?>} path_or_pathTuple
 * @return {!Ember.Binding}
 */
Ember.Binding.prototype.to = function(path_or_pathTuple) {};

/**
 * @return {string}
 */
Ember.Binding.prototype.toString = function() {};
/**
 * @extends {Ember.View}
 * @extends {Ember.TargetActionSupport}
 * @constructor
 * @struct
 */
Ember.Button = function() {};
 /** @type {boolean} */
Ember.Button.isClass;
 /** @type {boolean} */
Ember.Button.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Button.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Button.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.Button.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.Button.metaForProperty = function(key) {};

/**
 * @param {!Object} opts
 * @return {boolean}
 */
Ember.Button.prototype.triggerAction = function(opts) {};
/**
 * @extends {Ember.View}
 * @constructor
 * @struct
 */
Ember.Checkbox = function() {};
 /** @type {boolean} */
Ember.Checkbox.isClass;
 /** @type {boolean} */
Ember.Checkbox.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Checkbox.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Checkbox.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.Checkbox.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.Checkbox.metaForProperty = function(key) {};
/**
 * @extends {Ember.ContainerView}
 * @constructor
 * @struct
 */
Ember.CollectionView = function() {};
 /** @type {!Object} */
Ember.CollectionView.CONTAINER_MAP;
 /** @type {!Array<?>} */
Ember.CollectionView.prototype.content;
 /** @type {!Ember.View} */
Ember.CollectionView.prototype.emptyView;
 /** @type {!Ember.View} */
Ember.CollectionView.prototype.itemViewClass;

/**
 * @param {!Array<?>} content
 * @param {number} start
 * @param {number} removed
 * @param {number} added
 * @return {void}
 */
Ember.CollectionView.prototype.arrayDidChange = function(content, start, removed, added) {};

/**
 * @param {!Array<?>} content
 * @param {number} start
 * @param {number} removed
 * @return {void}
 */
Ember.CollectionView.prototype.arrayWillChange = function(content, start, removed) {};

/**
 * @param {!Object} viewClass
 * @param {!Object=} attrs
 * @return {!Ember.CollectionView}
 */
Ember.CollectionView.prototype.createChildView = function(viewClass, attrs) {};

/**
 * @return {!Ember.CollectionView}
 */
Ember.CollectionView.prototype.destroy = function() {};

/**
 * @return {void}
 */
Ember.CollectionView.prototype.init = function() {};
/**
 * @constructor
 * @struct
 */
Ember.Comparable = function() {};

/**
 * @param {?} a
 * @param {?} b
 * @return {number}
 */
Ember.Comparable.prototype.compare = function(a, b) {};
/**
 * @extends {Ember.View}
 * @constructor
 * @struct
 */
Ember.Component = function() {};
 /** @type {boolean} */
Ember.Component.isClass;
 /** @type {boolean} */
Ember.Component.isMethod;
 /** @type {!Ember.Controller} */
Ember.Component.prototype.targetObject;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Component.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Component.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.Component.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.Component.metaForProperty = function(key) {};

/**
 * @param {string} action
 * @param {?} context
 * @return {void}
 */
Ember.Component.prototype.sendAction = function(action, context) {};
/**
 * @constructor
 * @struct
 */
Ember.ComputedProperty = function() {};

/**
 * @param {boolean=} aFlag
 * @return {!Ember.ComputedProperty}
 */
Ember.ComputedProperty.prototype.cacheable = function(aFlag) {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.ComputedProperty.prototype.get = function(keyName) {};

/**
 * @param {!Object} meta
 * @return {!Ember.ComputedProperty}
 */
Ember.ComputedProperty.prototype.meta = function(meta) {};

/**
 * @param {...string} args
 * @return {!Ember.ComputedProperty}
 */
Ember.ComputedProperty.prototype.property = function(args) {};

/**
 * @return {!Ember.ComputedProperty}
 */
Ember.ComputedProperty.prototype.readOnly = function() {};

/**
 * @param {string} keyName
 * @param {?} newValue
 * @param {string} oldValue
 * @return {?}
 */
Ember.ComputedProperty.prototype.set = function(keyName, newValue, oldValue) {};

/**
 * @return {!Ember.ComputedProperty}
 */
Ember.ComputedProperty.prototype.volatile = function() {};

/**
 * @constructor
 * @struct
 * @param {!Ember.Container} parent
 */
Ember.Container = function(parent) {};
 /** @type {!Ember.Container} */
Ember.Container.prototype.parent;
 /** @type {!Array<?>} */
Ember.Container.prototype.children;
 /** @type {!Function} */
Ember.Container.prototype.resolver;
 /** @type {!Object} */
Ember.Container.prototype.registry;
 /** @type {!Object} */
Ember.Container.prototype.cache;
 /** @type {!Object} */
Ember.Container.prototype.typeInjections;
 /** @type {!Object} */
Ember.Container.prototype.injections;

/**
 * @return {!Ember.Container}
 */
Ember.Container.prototype.child = function() {};

/**
 * @param {!Object} object
 * @param {string} key
 * @param {?} value
 * @return {void}
 */
Ember.Container.prototype.set = function(object, key, value) {};

/**
 * registers a factory for later injection
 * @param {string} fullName type:name (e.g., 'model:user')
 * @param {!Function} factory (e.g., App.Person)
 * 
 * @param {!Object=} options
 * @return {void}
 */
Ember.Container.prototype.register = function(fullName, factory, options) {};

/**
 * @param {string} fullName
 * @return {void}
 */
Ember.Container.prototype.unregister = function(fullName) {};

/**
 * @param {string} fullName
 * @return {!Function}
 */
Ember.Container.prototype.resolve = function(fullName) {};

/**
 * @param {string} fullName
 * @return {string}
 */
Ember.Container.prototype.describe = function(fullName) {};

/**
 * @param {string} fullName
 * @return {string}
 */
Ember.Container.prototype.normalize = function(fullName) {};

/**
 * @param {?} factory
 * @param {string} fullName
 * @return {!Function}
 */
Ember.Container.prototype.makeToString = function(factory, fullName) {};

/**
 * @param {string} fullName
 * @param {!Object=} options
 * @return {?}
 */
Ember.Container.prototype.lookup = function(fullName, options) {};

/**
 * @param {string} fullName
 * @return {?}
 */
Ember.Container.prototype.lookupFactory = function(fullName) {};

/**
 * @param {string} fullName
 * @return {boolean}
 */
Ember.Container.prototype.has = function(fullName) {};

/**
 * @param {string} type
 * @param {!Object} options
 * @return {void}
 */
Ember.Container.prototype.optionsForType = function(type, options) {};

/**
 * @param {string} type
 * @param {!Object} options
 * @return {void}
 */
Ember.Container.prototype.options = function(type, options) {};

/**
 * @param {string} factoryName
 * @param {string} property
 * @param {string} injectionName
 * @return {void}
 */
Ember.Container.prototype.injection = function(factoryName, property, injectionName) {};

/**
 * @param {string} factoryName
 * @param {string} property
 * @param {string} injectionName
 * @return {void}
 */
Ember.Container.prototype.factoryInjection = function(factoryName, property, injectionName) {};

/**
 * @return {void}
 */
Ember.Container.prototype.destroy = function() {};

/**
 * @return {void}
 */
Ember.Container.prototype.reset = function() {};
/**
 * @extends {Ember.View}
 * @constructor
 * @struct
 */
Ember.ContainerView = function() {};
 /** @type {boolean} */
Ember.ContainerView.isClass;
 /** @type {boolean} */
Ember.ContainerView.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.ContainerView.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.ContainerView.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.ContainerView.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.ContainerView.metaForProperty = function(key) {};
/**
 * @extends {Ember.Object}
 * @extends {Ember.ControllerMixin}
 * @constructor
 * @struct
 */
Ember.Controller = function() {};
 /** @type {!Object} */
Ember.Controller.prototype.controllers;
 /** @type {?} */
Ember.Controller.prototype.model;
 /** @type {!Array<string>} */
Ember.Controller.prototype.needs;
 /** @type {?} */
Ember.Controller.prototype.queryParams;
 /** @type {?} */
Ember.Controller.prototype.target;
 /** @type {!ActionsHash} */
Ember.Controller.prototype.actions;

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.Controller.prototype.replaceRoute = function(name, args) {};

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.Controller.prototype.transitionToRoute = function(name, args) {};

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.Controller.prototype.send = function(name, args) {};
/**
 * @extends {Ember.ActionHandlerMixin}
 * @constructor
 * @struct
 */
Ember.ControllerMixin = function() {};
 /** @type {!Object} */
Ember.ControllerMixin.prototype.controllers;
 /** @type {?} */
Ember.ControllerMixin.prototype.model;
 /** @type {!Array<string>} */
Ember.ControllerMixin.prototype.needs;
 /** @type {?} */
Ember.ControllerMixin.prototype.queryParams;
 /** @type {?} */
Ember.ControllerMixin.prototype.target;

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.ControllerMixin.prototype.replaceRoute = function(name, args) {};

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.ControllerMixin.prototype.transitionToRoute = function(name, args) {};
/**
 * @constructor
 * @struct
 */
Ember.Copyable = function() {};

/**
 * @param {boolean} deep
 * @return {!Ember.Copyable}
 */
Ember.Copyable.prototype.copy = function(deep) {};

/**
 * @return {!Ember.Copyable}
 */
Ember.Copyable.prototype.frozenCopy = function() {};
/**
 * @constructor
 * @struct
 */
Ember.CoreObject = function() {};
 /** @type {!Array<?>} */
Ember.CoreObject.prototype.concatenatedProperties;
 /** @type {boolean} */
Ember.CoreObject.prototype.isDestroyed;
 /** @type {boolean} */
Ember.CoreObject.prototype.isDestroying;
 /** @type {boolean} */
Ember.CoreObject.isClass;
 /** @type {boolean} */
Ember.CoreObject.isMethod;

/**
 * An overridable method called when objects are instantiated. By default,
 * does nothing unless it is overridden during class definition.
 * \@method init
 * 
 * @return {void}
 */
Ember.CoreObject.prototype.init = function() {};

/**
 * Destroys an object by setting the `isDestroyed` flag and removing its
 * metadata, which effectively destroys observers and bindings.
 * If you try to set a property on a destroyed object, an exception will be
 * raised.
 * Note that destruction is scheduled for the end of the run loop and does not
 * happen immediately.  It will set an isDestroying flag immediately.
 * \@method destroy
 * @return {!Ember.CoreObject}
 */
Ember.CoreObject.prototype.destroy = function() {};

/**
 * Override to implement teardown.
 * \@method willDestroy
 * @return {void}
 */
Ember.CoreObject.prototype.willDestroy = function() {};

/**
 * Returns a string representation which attempts to provide more information than Javascript's toString
 * typically does, in a generic way for all Ember objects (e.g., "<App.Person:ember1024>").
 * \@method toString
 * 
 * @return {string}
 */
Ember.CoreObject.prototype.toString = function() {};

/**
 * Creates a new subclass.
 * \@method extend
 * 
 * Creates a new subclass.
 * \@method extend
 * 
 * @template T
 * @param {!CoreObjectArguments|!Ember.Mixin=} args_or_mixins
 * @param {!CoreObjectArguments=} args
 * @return {T}
 */
Ember.CoreObject.extend = function(args_or_mixins, args) {};

/**
 * Creates a new subclass.
 * \@method extend
 * Non-static method because Ember classes aren't currently 'real' TypeScript classes.
 * 
 * Creates a new subclass.
 * \@method extend
 * Non-static method because Ember classes aren't currently 'real' TypeScript classes.
 * 
 * @template T
 * @param {!CoreObjectArguments|!Ember.Mixin=} args_or_mixins
 * @param {!CoreObjectArguments=} args
 * @return {T}
 */
Ember.CoreObject.prototype.extend = function(args_or_mixins, args) {};

/**
 * Equivalent to doing extend(arguments).create(). If possible use the normal create method instead.
 * \@method createWithMixins
 * @template T
 * @param {!Object=} args
 * @return {T}
 */
Ember.CoreObject.createWithMixins = function(args) {};

/**
 * Creates an instance of the class.
 * \@method create
 * @template T
 * @param {!Object=} args
 * @return {T}
 */
Ember.CoreObject.create = function(args) {};

/**
 * Augments a constructor's prototype with additional properties and functions.
 * To add functions and properties to the constructor itself, see reopenClass.
 * \@method reopen
 * 
 * @template T
 * @param {!Object=} args
 * @return {T}
 */
Ember.CoreObject.reopen = function(args) {};

/**
 * Augments a constructor's own properties and functions.
 * To add functions and properties to instances of a constructor by extending the
 * constructor's prototype see reopen.
 * \@method reopenClass
 * 
 * @template T
 * @param {!Object=} args
 * @return {T}
 */
Ember.CoreObject.reopenClass = function(args) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.CoreObject.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.CoreObject.detectInstance = function(obj) {};

/**
 * Returns the original hash that was passed to meta().
 * \@method metaForProperty
 * @param {string} key {String} property name
 * 
 * @return {!Object}
 */
Ember.CoreObject.metaForProperty = function(key) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * \@method eachComputedProperty
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.CoreObject.eachComputedProperty = function(callback, binding) {};
/**
 * @extends {Ember.Object}
 * @extends {Ember.ActionHandlerMixin}
 * @constructor
 * @struct
 */
Ember.CoreView = function() {};
 /** @type {boolean} */
Ember.CoreView.isClass;
 /** @type {boolean} */
Ember.CoreView.isMethod;
 /** @type {!ActionsHash} */
Ember.CoreView.prototype.actions;
 /** @type {!Ember.CoreView} */
Ember.CoreView.prototype.parentView;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.CoreView.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.CoreView.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.CoreView.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.CoreView.metaForProperty = function(key) {};

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.CoreView.prototype.send = function(name, args) {};
/**
 * @constructor
 * @struct
 */
Ember.DAG = function() {};
 /** @type {!Array<?>} */
Ember.DAG.prototype.names;
 /** @type {!Object} */
Ember.DAG.prototype.vertices;

/**
 * @param {string} name
 * @return {?}
 */
Ember.DAG.prototype.add = function(name) {};

/**
 * @param {string} name
 * @param {?} value
 * @return {void}
 */
Ember.DAG.prototype.map = function(name, value) {};

/**
 * @param {string} fromName
 * @param {string} toName
 * @return {void}
 */
Ember.DAG.prototype.addEdge = function(fromName, toName) {};

/**
 * @param {!Function} fn
 * @return {void}
 */
Ember.DAG.prototype.topsort = function(fn) {};

/**
 * @param {string} name
 * @param {?} value
 * @param {?} before
 * @param {?} after
 * @return {void}
 */
Ember.DAG.prototype.addEdges = function(name, value, before, after) {};

/**
 * @param {string} name
 * @return {!Function}
 */
Ember.DEFAULT_GETTER_FUNCTION = function(name) {};
/**
 * @constructor
 * @struct
 */
Ember.DefaultResolver = function() {};
 /** @type {!Ember.Application} */
Ember.DefaultResolver.prototype.namespace;

/**
 * @param {string} fullName
 * @return {!Object}
 */
Ember.DefaultResolver.prototype.resolve = function(fullName) {};
/**
 * @constructor
 * @struct
 */
Ember.Deferred = function() {};

/**
 * @param {?} value
 * @return {void}
 */
Ember.Deferred.prototype.reject = function(value) {};

/**
 * @param {?} value
 * @return {void}
 */
Ember.Deferred.prototype.resolve = function(value) {};

/**
 * @param {!Function} resolve
 * @param {!Function} reject
 * @return {void}
 */
Ember.Deferred.prototype.then = function(resolve, reject) {};
/**
 * @extends {Ember.Mixin}
 * @constructor
 * @struct
 */
Ember.DeferredMixin = function() {};

/**
 * @param {?} value
 * @return {void}
 */
Ember.DeferredMixin.prototype.reject = function(value) {};

/**
 * @param {?} value
 * @return {void}
 */
Ember.DeferredMixin.prototype.resolve = function(value) {};

/**
 * @param {!Function} resolve
 * @param {!Function} reject
 * @return {void}
 */
Ember.DeferredMixin.prototype.then = function(resolve, reject) {};
/**
 * @constructor
 * @struct
 */
Ember.Descriptor = function() {};
 /** @type {!Object} */
Ember.EMPTY_META;
 /** @type {!Object} */
Ember.ENV;
 /** @type {boolean} */
Ember.EXTEND_PROTOTYPES;
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.EachProxy = function() {};
 /** @type {boolean} */
Ember.EachProxy.isClass;
 /** @type {boolean} */
Ember.EachProxy.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.EachProxy.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.EachProxy.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.EachProxy.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.EachProxy.metaForProperty = function(key) {};

/**
 * @param {string} keyName
 * @param {?} value
 * @return {!Array<?>}
 */
Ember.EachProxy.prototype.unknownProperty = function(keyName, value) {};
/**
 * @constructor
 * @struct
 */
Ember.Enumerable = function() {};
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.Enumerable.prototype.map;
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.Enumerable.prototype.reject;

/* TODO: PropertyDeclaration: Ember.'[]' */
 /** @type {?} */
Ember.Enumerable.prototype.firstObject;
 /** @type {boolean} */
Ember.Enumerable.prototype.hasEnumerableObservers;
 /** @type {?} */
Ember.Enumerable.prototype.lastObject;

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Enumerable}
 */
Ember.Enumerable.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Enumerable.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Enumerable.prototype.anyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Enumerable.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Enumerable.prototype.contains = function(obj) {};

/**
 * @param {number|!Ember.Enumerable} start_or_removing
 * @param {number|!Ember.Enumerable} removing_or_adding
 * @param {number|!Ember.Enumerable=} adding
 * @return {?}
 */
Ember.Enumerable.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {number|!Ember.Enumerable} removing
 * @param {number|!Ember.Enumerable} adding
 * @return {!Ember.Enumerable}
 */
Ember.Enumerable.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Enumerable.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Enumerable.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Enumerable.prototype.everyProperty = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.filterBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {?}
 */
Ember.Enumerable.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Ember.Enumerable.prototype.findBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {?}
 */
Ember.Enumerable.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.getEach = function(key) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.invoke = function(methodName, args) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Ember.Enumerable.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {!ReduceCallback} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Ember.Enumerable.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Enumerable}
 */
Ember.Enumerable.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Ember.Enumerable.prototype.setEach = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Enumerable.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.toArray = function() {};

/**
 * @return {!Ember.Enumerable}
 */
Ember.Enumerable.prototype.uniq = function() {};

/**
 * @param {?} value
 * @return {!Ember.Enumerable}
 */
Ember.Enumerable.prototype.without = function(value) {};
 /** @type {!Object} */
Ember.EnumerableUtils;
 /** @type {?} */
Ember.Error;
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.EventDispatcher = function() {};
 /** @type {boolean} */
Ember.EventDispatcher.isClass;
 /** @type {boolean} */
Ember.EventDispatcher.isMethod;
 /** @type {!Object} */
Ember.EventDispatcher.prototype.events;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.EventDispatcher.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.EventDispatcher.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.EventDispatcher.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.EventDispatcher.metaForProperty = function(key) {};
/**
 * @constructor
 * @struct
 */
Ember.Evented = function() {};

/**
 * @param {string} name
 * @return {boolean}
 */
Ember.Evented.prototype.has = function(name) {};

/**
 * @param {string} name
 * @param {?} target
 * @param {!Function} method
 * @return {!Ember.Evented}
 */
Ember.Evented.prototype.off = function(name, target, method) {};

/**
 * @param {string} name
 * @param {?} target
 * @param {!Function} method
 * @return {!Ember.Evented}
 */
Ember.Evented.prototype.on = function(name, target, method) {};

/**
 * @param {string} name
 * @param {?} target
 * @param {!Function} method
 * @return {!Ember.Evented}
 */
Ember.Evented.prototype.one = function(name, target, method) {};

/**
 * @param {string} name
 * @param {...string} args
 * @return {void}
 */
Ember.Evented.prototype.trigger = function(name, args) {};
 /** @type {string} */
Ember.FROZEN_ERROR;
/**
 * @constructor
 * @struct
 */
Ember.Freezable = function() {};
 /** @type {boolean} */
Ember.Freezable.prototype.isFrozen;

/**
 * @return {!Ember.Freezable}
 */
Ember.Freezable.prototype.freeze = function() {};
 /** @type {string} */
Ember.GUID_KEY;
/** @const */
Ember.Handlebars = {};

/**
 * @param {string|?} string_or_environment
 * @param {?=} options
 * @param {?=} context
 * @param {?=} asObject
 * @return {!Function|?}
 */
Ember.Handlebars.compile = function(string_or_environment, options, context, asObject) {};

/**
 * @param {?} root
 * @param {string} path
 * @param {!Object=} options
 * @return {?}
 */
Ember.Handlebars.get = function(root, path, options) {};

/**
 * @param {string} name
 * @param {!Function|!Ember.View} func_or_view
 * @param {string=} dependentKeys
 * @return {void}
 */
Ember.Handlebars.helper = function(name, func_or_view, dependentKeys) {};
/**
 * @constructor
 * @struct
 */
Ember.Handlebars.helpers = function() {};

/**
 * @param {string} actionName
 * @param {?} context
 * @param {!Object=} options
 * @return {void}
 */
Ember.Handlebars.helpers.prototype.action = function(actionName, context, options) {};

/**
 * @param {!Object=} options
 * @return {string}
 */
Ember.Handlebars.helpers.prototype.bindAttr = function(options) {};

/**
 * @param {string} outletName
 * @param {!Object} view
 * @return {void}
 */
Ember.Handlebars.helpers.prototype.connectOutlet = function(outletName, view) {};

/**
 * @param {string} path
 * @param {string} modelPath
 * @param {!Object=} options
 * @return {string}
 */
Ember.Handlebars.helpers.prototype.control = function(path, modelPath, options) {};

/**
 * @param {string} property
 * @return {void}
 */
Ember.Handlebars.helpers.prototype.debugger = function(property) {};

/**
 * @param {string} outletName
 * @return {void}
 */
Ember.Handlebars.helpers.prototype.disconnectOutlet = function(outletName) {};

/**
 * @param {string} name
 * @param {string} path
 * @param {!Object=} options
 * @return {void}
 */
Ember.Handlebars.helpers.prototype.each = function(name, path, options) {};

/**
 * @param {!Function} context
 * @param {!Object=} options
 * @return {string}
 */
Ember.Handlebars.helpers.prototype.if = function(context, options) {};

/**
 * @return {void}
 */
Ember.Handlebars.helpers.prototype.init = function() {};

/**
 * @param {!Object=} options
 * @return {void}
 */
Ember.Handlebars.helpers.prototype.input = function(options) {};

/**
 * @param {string} routeName
 * @param {?} context
 * @param {!Object=} options
 * @return {string}
 */
Ember.Handlebars.helpers.prototype.linkTo = function(routeName, context, options) {};

/**
 * @param {string} str
 * @return {void}
 */
Ember.Handlebars.helpers.prototype.loc = function(str) {};

/**
 * @param {string} property
 * @return {void}
 */
Ember.Handlebars.helpers.prototype.log = function(property) {};

/**
 * @param {string} property
 * @return {string}
 */
Ember.Handlebars.helpers.prototype.outlet = function(property) {};

/**
 * @param {string} partialName
 * @return {void}
 */
Ember.Handlebars.helpers.prototype.partial = function(partialName) {};

/**
 * @param {string} name
 * @param {string=} context
 * @param {!Object=} options
 * @return {string}
 */
Ember.Handlebars.helpers.prototype.render = function(name, context, options) {};

/**
 * @param {!Object=} options
 * @return {void}
 */
Ember.Handlebars.helpers.prototype.textarea = function(options) {};

/**
 * @param {string} property
 * @return {string}
 */
Ember.Handlebars.helpers.prototype.unbound = function(property) {};

/**
 * @param {!Function} context
 * @param {!Object=} options
 * @return {string}
 */
Ember.Handlebars.helpers.prototype.unless = function(context, options) {};

/**
 * @param {string} path
 * @param {!Object=} options
 * @return {string}
 */
Ember.Handlebars.helpers.prototype.view = function(path, options) {};

/**
 * @param {!Function} context
 * @param {!Object=} options
 * @return {string}
 */
Ember.Handlebars.helpers.prototype.with = function(context, options) {};

/**
 * @param {!Object=} options
 * @return {string}
 */
Ember.Handlebars.helpers.prototype.yield = function(options) {};

/**
 * @param {string} string
 * @return {void}
 */
Ember.Handlebars.precompile = function(string) {};

/**
 * @param {string} name
 * @param {!Function} func
 * @param {string=} dependentKeys
 * @return {void}
 */
Ember.Handlebars.registerBoundHelper = function(name, func, dependentKeys) {};
/**
 * @constructor
 * @struct
 */
Ember.Handlebars.Compiler = function() {};
/**
 * @constructor
 * @struct
 */
Ember.Handlebars.JavaScriptCompiler = function() {};

/**
 * @param {string} name
 * @param {!Function} fn
 * @param {boolean=} inverse
 * @return {void}
 */
Ember.Handlebars.registerHelper = function(name, fn, inverse) {};

/**
 * @param {string} name
 * @param {?} str
 * @return {void}
 */
Ember.Handlebars.registerPartial = function(name, str) {};

/**
 * @return {?}
 */
Ember.Handlebars.K = function() {};

/**
 * @param {?} objec
 * @return {?}
 */
Ember.Handlebars.createFrame = function(objec) {};

/**
 * @param {string} message
 * @return {void}
 */
Ember.Handlebars.Exception = function(message) {};

/**
 * @constructor
 * @struct
 * @param {string} str
 */
Ember.Handlebars.SafeString = function(str) {};

/**
 * @return {string}
 */
Ember.Handlebars.SafeString.toString = function() {};

/**
 * @param {string} string
 * @return {?}
 */
Ember.Handlebars.parse = function(string) {};

/**
 * @param {?} ast
 * @return {void}
 */
Ember.Handlebars.print = function(ast) {};
 /** @type {{assert: function(?): void, debug: function(!Array<?>): void, error: function(!Array<?>): void, info: function(!Array<?>): void, log: function(!Array<?>): void, warn: function(!Array<?>): void}} */
Ember.Handlebars.logger;

/**
 * @param {string} level
 * @param {string} str
 * @return {void}
 */
Ember.Handlebars.log = function(level, str) {};
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.HashLocation = function() {};
 /** @type {boolean} */
Ember.HashLocation.isClass;
 /** @type {boolean} */
Ember.HashLocation.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.HashLocation.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.HashLocation.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.HashLocation.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.HashLocation.metaForProperty = function(key) {};
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.HistoryLocation = function() {};
 /** @type {boolean} */
Ember.HistoryLocation.isClass;
 /** @type {boolean} */
Ember.HistoryLocation.isMethod;
 /** @type {string} */
Ember.HistoryLocation.prototype.rootURL;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.HistoryLocation.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.HistoryLocation.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.HistoryLocation.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.HistoryLocation.metaForProperty = function(key) {};
 /** @type {!RegExp} */
Ember.IS_BINDING;
/**
 * @constructor
 * @struct
 */
Ember.Instrumentation = function() {};

/**
 * @param {?} obj
 * @param {...!Array<?>|string} list_or_args
 * @return {!Object}
 */
Ember.Instrumentation.prototype.getProperties = function(obj, list_or_args) {};

/**
 * @param {string} name
 * @param {?} payload
 * @param {!Function} callback
 * @param {?} binding
 * @return {void}
 */
Ember.Instrumentation.prototype.instrument = function(name, payload, callback, binding) {};

/**
 * @return {void}
 */
Ember.Instrumentation.prototype.reset = function() {};

/**
 * @param {string} pattern
 * @param {?} object
 * @return {void}
 */
Ember.Instrumentation.prototype.subscribe = function(pattern, object) {};

/**
 * @param {?} subscriber
 * @return {void}
 */
Ember.Instrumentation.prototype.unsubscribe = function(subscriber) {};
 /** @type {!Function} */
Ember.K;
 /** @type {boolean} */
Ember.LOG_BINDINGS;
 /** @type {boolean} */
Ember.LOG_STACKTRACE_ON_DEPRECATION;
 /** @type {boolean} */
Ember.LOG_VERSION;
/**
 * @extends {Ember.View}
 * @constructor
 * @struct
 */
Ember.LinkView = function() {};
 /** @type {boolean} */
Ember.LinkView.isClass;
 /** @type {boolean} */
Ember.LinkView.isMethod;
 /** @type {?} */
Ember.LinkView.prototype.active;
 /** @type {string} */
Ember.LinkView.prototype.activeClass;
 /** @type {?} */
Ember.LinkView.prototype.attributeBindings;
 /** @type {!Array<string>} */
Ember.LinkView.prototype.classNameBindings;
 /** @type {?} */
Ember.LinkView.prototype.disabled;
 /** @type {string} */
Ember.LinkView.prototype.disabledClass;
 /** @type {string} */
Ember.LinkView.prototype.eventName;
 /** @type {?} */
Ember.LinkView.prototype.href;
 /** @type {?} */
Ember.LinkView.prototype.loading;
 /** @type {string} */
Ember.LinkView.prototype.loadingClass;
 /** @type {string} */
Ember.LinkView.prototype.loadingHref;
 /** @type {?} */
Ember.LinkView.prototype.rel;
 /** @type {boolean} */
Ember.LinkView.prototype.replace;
 /** @type {?} */
Ember.LinkView.prototype.title;
 /** @type {!Function} */
Ember.LinkView.prototype.click;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.LinkView.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.LinkView.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.LinkView.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.LinkView.metaForProperty = function(key) {};

/**
 * @return {void}
 */
Ember.LinkView.prototype.init = function() {};
/**
 * @constructor
 * @struct
 */
Ember.Location = function() {};

/**
 * @param {!Object=} options
 * @return {?}
 */
Ember.Location.prototype.create = function(options) {};

/**
 * @param {string} name
 * @param {?} implementation
 * @return {void}
 */
Ember.Location.prototype.registerImplementation = function(name, implementation) {};
 /** @type {{assert: function(?): void, debug: function(!Array<?>): void, error: function(!Array<?>): void, info: function(!Array<?>): void, log: function(!Array<?>): void, warn: function(!Array<?>): void}} */
Ember.Logger;

/**
 * @param {string} value
 * @return {void}
 */
Ember.MANDATORY_SETTER_FUNCTION = function(value) {};
 /** @type {string} */
Ember.META_KEY;
/**
 * @constructor
 * @struct
 */
Ember.Map = function() {};
 /** @type {number} */
Ember.Map.prototype.length;

/**
 * @return {!Ember.Map}
 */
Ember.Map.prototype.copy = function() {};

/**
 * @return {!Ember.Map}
 */
Ember.Map.create = function() {};

/**
 * @param {!Function} callback
 * @param {?} self
 * @return {void}
 */
Ember.Map.prototype.forEach = function(callback, self) {};

/**
 * @param {?} key
 * @return {?}
 */
Ember.Map.prototype.get = function(key) {};

/**
 * @param {?} key
 * @return {boolean}
 */
Ember.Map.prototype.has = function(key) {};

/**
 * @param {?} key
 * @return {boolean}
 */
Ember.Map.prototype.remove = function(key) {};

/**
 * @param {?} key
 * @param {?} value
 * @return {void}
 */
Ember.Map.prototype.set = function(key, value) {};
/**
 * @extends {Ember.Map}
 * @constructor
 * @struct
 */
Ember.MapWithDefault = function() {};

/**
 * @return {!Ember.MapWithDefault}
 */
Ember.MapWithDefault.prototype.copy = function() {};

/**
 * @return {!Ember.MapWithDefault}
 */
Ember.MapWithDefault.create = function() {};
/**
 * @constructor
 * @struct
 */
Ember.Mixin = function() {};

/**
 * @param {?} obj
 * @return {?}
 */
Ember.Mixin.prototype.apply = function(obj) {};

/**
 * Creates an instance of the class.
 * @template T
 * @param {...!CoreObjectArguments} args
 * @return {T}
 */
Ember.Mixin.create = function(args) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Mixin.prototype.detect = function(obj) {};

/**
 * @template T
 * @param {!Object=} args
 * @return {T}
 */
Ember.Mixin.prototype.reopen = function(args) {};
/**
 * @extends {Ember.Array}
 * @extends {Ember.MutableEnumberable}
 * @constructor
 * @struct
 */
Ember.MutableArray = function() {};
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.MutableArray.prototype.map;
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.MutableArray.prototype.reject;

/* TODO: PropertyDeclaration: Ember.'[]' */

/* TODO: PropertyDeclaration: Ember.'@each' */
 /** @type {boolean} */
Ember.MutableArray.prototype.Boolean;
 /** @type {?} */
Ember.MutableArray.prototype.firstObject;
 /** @type {boolean} */
Ember.MutableArray.prototype.hasEnumerableObservers;
 /** @type {?} */
Ember.MutableArray.prototype.lastObject;
 /** @type {number} */
Ember.MutableArray.prototype.length;

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions=} opts
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.addArrayObserver = function(target, opts) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Enumerable}
 */
Ember.MutableArray.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.MutableArray.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableArray.prototype.anyBy = function(key, value) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.arrayContentDidChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.arrayContentWillChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableArray.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.clear = function() {};

/**
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.MutableArray.prototype.contains = function(obj) {};

/**
 * @param {number|!Ember.Enumerable} start_or_removing
 * @param {number|!Ember.Enumerable} removing_or_adding
 * @param {number|!Ember.Enumerable=} adding
 * @return {?}
 */
Ember.MutableArray.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {number|!Ember.Enumerable} removing
 * @param {number|!Ember.Enumerable} adding
 * @return {!Ember.Enumerable}
 */
Ember.MutableArray.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.MutableArray.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableArray.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableArray.prototype.everyProperty = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.filterBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {?}
 */
Ember.MutableArray.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Ember.MutableArray.prototype.findBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {?}
 */
Ember.MutableArray.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.getEach = function(key) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.MutableArray.prototype.indexOf = function(object, startAt) {};

/**
 * @param {number} idx
 * @param {?} object
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.insertAt = function(idx, object) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.invoke = function(methodName, args) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.MutableArray.prototype.lastIndexOf = function(object, startAt) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Ember.MutableArray.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {number} idx
 * @return {?}
 */
Ember.MutableArray.prototype.objectAt = function(idx) {};

/**
 * @param {...number} args
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.objectsAt = function(args) {};

/**
 * @return {?}
 */
Ember.MutableArray.prototype.popObject = function() {};

/**
 * @param {?} obj
 * @return {?}
 */
Ember.MutableArray.prototype.pushObject = function(obj) {};

/**
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.pushObjects = function(args) {};

/**
 * @param {!ReduceCallback} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Ember.MutableArray.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.removeArrayObserver = function(target, opts) {};

/**
 * @param {number} start
 * @param {number} len
 * @return {?}
 */
Ember.MutableArray.prototype.removeAt = function(start, len) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Enumerable}
 */
Ember.MutableArray.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {number} idx
 * @param {number} amt
 * @param {!Array<?>} objects
 * @return {?}
 */
Ember.MutableArray.prototype.replace = function(idx, amt, objects) {};

/**
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.reverseObjects = function() {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Ember.MutableArray.prototype.setEach = function(key, value) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.setObjects = function(objects) {};

/**
 * @return {?}
 */
Ember.MutableArray.prototype.shiftObject = function() {};

/**
 * @param {number=} beginIndex
 * @param {number=} endIndex
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.slice = function(beginIndex, endIndex) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.MutableArray.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.toArray = function() {};

/**
 * @return {!Ember.Enumerable}
 */
Ember.MutableArray.prototype.uniq = function() {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.MutableArray.prototype.unshiftObject = function(object) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.unshiftObjects = function(objects) {};

/**
 * @param {?} value
 * @return {!Ember.Enumerable}
 */
Ember.MutableArray.prototype.without = function(value) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.MutableArray.prototype.addObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.MutableArray.prototype.addObjects = function(objects) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.MutableArray.prototype.removeObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.MutableArray.prototype.removeObjects = function(objects) {};
/**
 * @extends {Ember.Enumerable}
 * @constructor
 * @struct
 */
Ember.MutableEnumberable = function() {};
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.MutableEnumberable.prototype.map;
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.MutableEnumberable.prototype.reject;

/* TODO: PropertyDeclaration: Ember.'[]' */
 /** @type {?} */
Ember.MutableEnumberable.prototype.firstObject;
 /** @type {boolean} */
Ember.MutableEnumberable.prototype.hasEnumerableObservers;
 /** @type {?} */
Ember.MutableEnumberable.prototype.lastObject;

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Enumerable}
 */
Ember.MutableEnumberable.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.MutableEnumberable.prototype.addObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.MutableEnumberable.prototype.addObjects = function(objects) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.anyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.contains = function(obj) {};

/**
 * @param {number|!Ember.Enumerable} start_or_removing
 * @param {number|!Ember.Enumerable} removing_or_adding
 * @param {number|!Ember.Enumerable=} adding
 * @return {?}
 */
Ember.MutableEnumberable.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {number|!Ember.Enumerable} removing
 * @param {number|!Ember.Enumerable} adding
 * @return {!Ember.Enumerable}
 */
Ember.MutableEnumberable.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.everyProperty = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.filterBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {?}
 */
Ember.MutableEnumberable.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Ember.MutableEnumberable.prototype.findBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {?}
 */
Ember.MutableEnumberable.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.getEach = function(key) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.invoke = function(methodName, args) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Ember.MutableEnumberable.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {!ReduceCallback} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Ember.MutableEnumberable.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Enumerable}
 */
Ember.MutableEnumberable.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.MutableEnumberable.prototype.removeObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.MutableEnumberable.prototype.removeObjects = function(objects) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Ember.MutableEnumberable.prototype.setEach = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.toArray = function() {};

/**
 * @return {!Ember.Enumerable}
 */
Ember.MutableEnumberable.prototype.uniq = function() {};

/**
 * @param {?} value
 * @return {!Ember.Enumerable}
 */
Ember.MutableEnumberable.prototype.without = function(value) {};
 /** @type {string} */
Ember.NAME_KEY;
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.Namespace = function() {};
 /** @type {boolean} */
Ember.Namespace.isClass;
 /** @type {boolean} */
Ember.Namespace.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Namespace.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Namespace.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.Namespace.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.Namespace.metaForProperty = function(key) {};

/**
 * @constructor
 * @struct
 * @param {!Array<?>} arr
 */
Ember.NativeArray = function(arr) {};
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.NativeArray.prototype.map;
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.NativeArray.prototype.reject;

/* TODO: PropertyDeclaration: Ember.'[]' */

/* TODO: PropertyDeclaration: Ember.'@each' */
 /** @type {boolean} */
Ember.NativeArray.prototype.Boolean;
 /** @type {?} */
Ember.NativeArray.prototype.firstObject;
 /** @type {boolean} */
Ember.NativeArray.prototype.hasEnumerableObservers;
 /** @type {?} */
Ember.NativeArray.prototype.lastObject;
 /** @type {number} */
Ember.NativeArray.prototype.length;
 /** @type {!ModifyObserver} */
Ember.NativeArray.prototype.addObserver;

/**
 * @return {void}
 */
Ember.NativeArray.activate = function() {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions=} opts
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.addArrayObserver = function(target, opts) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Enumerable}
 */
Ember.NativeArray.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.NativeArray.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.NativeArray.prototype.anyBy = function(key, value) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.arrayContentDidChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.arrayContentWillChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {boolean}
 */
Ember.NativeArray.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.clear = function() {};

/**
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.NativeArray.prototype.contains = function(obj) {};

/**
 * @param {number|!Ember.Enumerable} start_or_removing
 * @param {number|!Ember.Enumerable} removing_or_adding
 * @param {number|!Ember.Enumerable=} adding
 * @return {?}
 */
Ember.NativeArray.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {number|!Ember.Enumerable} removing
 * @param {number|!Ember.Enumerable} adding
 * @return {!Ember.Enumerable}
 */
Ember.NativeArray.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.NativeArray.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.NativeArray.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {boolean}
 */
Ember.NativeArray.prototype.everyProperty = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.filterBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {?}
 */
Ember.NativeArray.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Ember.NativeArray.prototype.findBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {?}
 */
Ember.NativeArray.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.getEach = function(key) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.NativeArray.prototype.indexOf = function(object, startAt) {};

/**
 * @param {number} idx
 * @param {?} object
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.insertAt = function(idx, object) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.invoke = function(methodName, args) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.NativeArray.prototype.lastIndexOf = function(object, startAt) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Ember.NativeArray.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {number} idx
 * @return {?}
 */
Ember.NativeArray.prototype.objectAt = function(idx) {};

/**
 * @param {...number} args
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.objectsAt = function(args) {};

/**
 * @return {?}
 */
Ember.NativeArray.prototype.popObject = function() {};

/**
 * @param {?} obj
 * @return {?}
 */
Ember.NativeArray.prototype.pushObject = function(obj) {};

/**
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.pushObjects = function(args) {};

/**
 * @param {!ReduceCallback} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Ember.NativeArray.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.removeArrayObserver = function(target, opts) {};

/**
 * @param {number} start
 * @param {number} len
 * @return {?}
 */
Ember.NativeArray.prototype.removeAt = function(start, len) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Enumerable}
 */
Ember.NativeArray.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {number} idx
 * @param {number} amt
 * @param {!Array<?>} objects
 * @return {?}
 */
Ember.NativeArray.prototype.replace = function(idx, amt, objects) {};

/**
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.reverseObjects = function() {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Ember.NativeArray.prototype.setEach = function(key, value) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.setObjects = function(objects) {};

/**
 * @return {?}
 */
Ember.NativeArray.prototype.shiftObject = function() {};

/**
 * @param {number=} beginIndex
 * @param {number=} endIndex
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.slice = function(beginIndex, endIndex) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.NativeArray.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.toArray = function() {};

/**
 * @return {!Ember.Enumerable}
 */
Ember.NativeArray.prototype.uniq = function() {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.NativeArray.prototype.unshiftObject = function(object) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.unshiftObjects = function(objects) {};

/**
 * @param {?} value
 * @return {!Ember.Enumerable}
 */
Ember.NativeArray.prototype.without = function(value) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.NativeArray.prototype.addObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.NativeArray.prototype.addObjects = function(objects) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.NativeArray.prototype.removeObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.NativeArray.prototype.removeObjects = function(objects) {};

/**
 * @return {!Ember.Observable}
 */
Ember.NativeArray.prototype.beginPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.NativeArray.prototype.cacheFor = function(keyName) {};

/**
 * @param {string} keyName
 * @param {number=} decrement
 * @return {number}
 */
Ember.NativeArray.prototype.decrementProperty = function(keyName, decrement) {};

/**
 * @return {!Ember.Observable}
 */
Ember.NativeArray.prototype.endPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.NativeArray.prototype.get = function(keyName) {};

/**
 * @param {...string|!Array<string>} args_or_keys
 * @return {!Object}
 */
Ember.NativeArray.prototype.getProperties = function(args_or_keys) {};

/**
 * @param {string} keyName
 * @param {?} defaultValue
 * @return {?}
 */
Ember.NativeArray.prototype.getWithDefault = function(keyName, defaultValue) {};

/**
 * @param {string} key
 * @return {boolean}
 */
Ember.NativeArray.prototype.hasObserverFor = function(key) {};

/**
 * @param {string} keyName
 * @param {number=} increment
 * @return {number}
 */
Ember.NativeArray.prototype.incrementProperty = function(keyName, increment) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.NativeArray.prototype.notifyPropertyChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.NativeArray.prototype.propertyDidChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.NativeArray.prototype.propertyWillChange = function(keyName) {};

/**
 * @param {string} key
 * @param {?} target
 * @param {string|!Function} method
 * @return {void}
 */
Ember.NativeArray.prototype.removeObserver = function(key, target, method) {};

/**
 * @param {string} keyName
 * @param {?} value
 * @return {!Ember.Observable}
 */
Ember.NativeArray.prototype.set = function(keyName, value) {};

/**
 * @param {!Object} hash
 * @return {!Ember.Observable}
 */
Ember.NativeArray.prototype.setProperties = function(hash) {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.NativeArray.prototype.toggleProperty = function(keyName) {};

/**
 * @param {boolean} deep
 * @return {!Ember.Copyable}
 */
Ember.NativeArray.prototype.copy = function(deep) {};

/**
 * @return {!Ember.Copyable}
 */
Ember.NativeArray.prototype.frozenCopy = function() {};
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.NoneLocation = function() {};
 /** @type {boolean} */
Ember.NoneLocation.isClass;
 /** @type {boolean} */
Ember.NoneLocation.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.NoneLocation.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.NoneLocation.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.NoneLocation.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.NoneLocation.metaForProperty = function(key) {};
 /** @type {!Array<string>} */
Ember.ORDER_DEFINITION;
/**
 * @extends {Ember.CoreObject}
 * @extends {Ember.Observable}
 * @constructor
 * @struct
 */
Ember.Object = function() {};
 /** @type {!ModifyObserver} */
Ember.Object.prototype.addObserver;

/**
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.beginPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.Object.prototype.cacheFor = function(keyName) {};

/**
 * @param {string} keyName
 * @param {number=} decrement
 * @return {number}
 */
Ember.Object.prototype.decrementProperty = function(keyName, decrement) {};

/**
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.endPropertyChanges = function() {};

/**
 * Retrieves the value of a property from the object
 * Retrieves the value of a property from the object
 * @template T
 * @param {string} keyName
 * @return {?|T}
 */
Ember.Object.prototype.get = function(keyName) {};

/**
 * @param {...string|!Array<string>} args_or_keys
 * @return {!Object}
 */
Ember.Object.prototype.getProperties = function(args_or_keys) {};

/**
 * @param {string} keyName
 * @param {?} defaultValue
 * @return {?}
 */
Ember.Object.prototype.getWithDefault = function(keyName, defaultValue) {};

/**
 * @param {string} key
 * @return {boolean}
 */
Ember.Object.prototype.hasObserverFor = function(key) {};

/**
 * @param {string} keyName
 * @param {number=} increment
 * @return {number}
 */
Ember.Object.prototype.incrementProperty = function(keyName, increment) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.notifyPropertyChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.propertyDidChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.propertyWillChange = function(keyName) {};

/**
 * @param {string} key
 * @param {?} target
 * @param {string|!Function} method
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.removeObserver = function(key, target, method) {};

/**
 * @param {string} keyName
 * @param {?} value
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.set = function(keyName, value) {};

/**
 * @param {!Object} hash
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.setProperties = function(hash) {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.Object.prototype.toggleProperty = function(keyName) {};
/**
 * @extends {Ember.ObjectProxy}
 * @extends {Ember.ControllerMixin}
 * @constructor
 * @struct
 */
Ember.ObjectController = function() {};
 /** @type {!Ember.Object} */
Ember.ObjectController.prototype.controllers;
 /** @type {!Array<string>} */
Ember.ObjectController.prototype.needs;
 /** @type {?} */
Ember.ObjectController.prototype.target;
 /** @type {?} */
Ember.ObjectController.prototype.model;
 /** @type {?} */
Ember.ObjectController.prototype.queryParams;
 /** @type {!Object} */
Ember.ObjectController.prototype.actions;

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.ObjectController.prototype.replaceRoute = function(name, args) {};

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.ObjectController.prototype.transitionToRoute = function(name, args) {};

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.ObjectController.prototype.send = function(name, args) {};
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.ObjectProxy = function() {};
 /** @type {boolean} */
Ember.ObjectProxy.isClass;
 /** @type {boolean} */
Ember.ObjectProxy.isMethod;
 /** @type {!Ember.Object} */
Ember.ObjectProxy.prototype.content;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.ObjectProxy.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.ObjectProxy.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.ObjectProxy.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.ObjectProxy.metaForProperty = function(key) {};
/**
 * @constructor
 * @struct
 */
Ember.Observable = function() {};
 /** @type {!ModifyObserver} */
Ember.Observable.prototype.addObserver;

/**
 * @return {!Ember.Observable}
 */
Ember.Observable.prototype.beginPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.Observable.prototype.cacheFor = function(keyName) {};

/**
 * @param {string} keyName
 * @param {number=} decrement
 * @return {number}
 */
Ember.Observable.prototype.decrementProperty = function(keyName, decrement) {};

/**
 * @return {!Ember.Observable}
 */
Ember.Observable.prototype.endPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.Observable.prototype.get = function(keyName) {};

/**
 * @param {...string|!Array<string>} args_or_keys
 * @return {!Object}
 */
Ember.Observable.prototype.getProperties = function(args_or_keys) {};

/**
 * @param {string} keyName
 * @param {?} defaultValue
 * @return {?}
 */
Ember.Observable.prototype.getWithDefault = function(keyName, defaultValue) {};

/**
 * @param {string} key
 * @return {boolean}
 */
Ember.Observable.prototype.hasObserverFor = function(key) {};

/**
 * @param {string} keyName
 * @param {number=} increment
 * @return {number}
 */
Ember.Observable.prototype.incrementProperty = function(keyName, increment) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Observable.prototype.notifyPropertyChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Observable.prototype.propertyDidChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Observable.prototype.propertyWillChange = function(keyName) {};

/**
 * @param {string} key
 * @param {!Object} target
 * @param {string|!Function} method
 * @return {void}
 */
Ember.Observable.prototype.removeObserver = function(key, target, method) {};

/**
 * @param {string} keyName
 * @param {?} value
 * @return {!Ember.Observable}
 */
Ember.Observable.prototype.set = function(keyName, value) {};

/**
 * @param {!Object} hash
 * @return {!Ember.Observable}
 */
Ember.Observable.prototype.setProperties = function(hash) {};

/**
 * Set the value of a boolean property to the opposite of its current value.
 * @param {string} keyName
 * @return {boolean}
 */
Ember.Observable.prototype.toggleProperty = function(keyName) {};
/**
 * @constructor
 * @struct
 */
Ember.OrderedSet = function() {};

/**
 * @param {?} obj
 * @return {void}
 */
Ember.OrderedSet.prototype.add = function(obj) {};

/**
 * @return {void}
 */
Ember.OrderedSet.prototype.clear = function() {};

/**
 * @return {!Ember.OrderedSet}
 */
Ember.OrderedSet.prototype.copy = function() {};

/**
 * @return {!Ember.OrderedSet}
 */
Ember.OrderedSet.create = function() {};

/**
 * @param {!Function} fn
 * @param {?} self
 * @return {void}
 */
Ember.OrderedSet.prototype.forEach = function(fn, self) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.OrderedSet.prototype.has = function(obj) {};

/**
 * @return {boolean}
 */
Ember.OrderedSet.prototype.isEmpty = function() {};

/**
 * @param {?} obj
 * @return {void}
 */
Ember.OrderedSet.prototype.remove = function(obj) {};

/**
 * @return {!Array<?>}
 */
Ember.OrderedSet.prototype.toArray = function() {};
/** @const */
Ember.RSVP = {};
/**
 * @record
 * @struct
 */
Ember.RSVP.PromiseResolve = function() {};

/* TODO: CallSignature: Ember.RSVP */
/**
 * @record
 * @struct
 */
Ember.RSVP.PromiseReject = function() {};

/* TODO: CallSignature: Ember.RSVP */
/**
 * @record
 * @struct
 */
Ember.RSVP.PromiseResolverFunction = function() {};

/* TODO: CallSignature: Ember.RSVP */

/**
 * @constructor
 * @struct
 * Promise objects represent the eventual result of an asynchronous operation. The
 * primary way of interacting with a promise is through its `then` method, which
 * registers callbacks to receive either a promise's eventual value or the reason
 * why the promise cannot be fulfilled.
 * Useful for tooling.
 * @param {!Ember.RSVP.PromiseResolverFunction} resolver
 * @param {string=} label
 */
Ember.RSVP.Promise = function(resolver, label) {};

/**
 * The primary way of interacting with a promise is through its `then` method,
 * which registers callbacks to receive either a promise's eventual value or the
 * reason why the promise cannot be fulfilled.
 * \@method then
 * Useful for tooling.
 * @param {!Function=} onFulfilled
 * @param {!Function=} onRejected
 * @return {!Ember.RSVP.Promise}
 */
Ember.RSVP.Promise.prototype.then = function(onFulfilled, onRejected) {};

/**
 * `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
 * as the catch block of a try/catch statement.
 * \@method catch
 * Useful for tooling.
 * @param {!Function} onRejection
 * @param {string=} label
 * @return {!Ember.RSVP.Promise}
 */
Ember.RSVP.Promise.prototype.catch = function(onRejection, label) {};

/**
 * `finally` will be invoked regardless of the promise's fate just as native
 * try/catch/finally behaves
 * \@method finally
 * Useful for tooling.
 * @param {!Function} callback
 * @param {string=} label
 * @return {!Ember.RSVP.Promise}
 */
Ember.RSVP.Promise.prototype.finally = function(callback, label) {};
/**
 * @constructor
 * @struct
 */
Ember.RenderBuffer = function() {};
 /** @type {!Array<?>} */
Ember.RenderBuffer.prototype.classes;
 /** @type {!Object} */
Ember.RenderBuffer.prototype.elementAttributes;
 /** @type {string} */
Ember.RenderBuffer.prototype.elementId;
 /** @type {!Object} */
Ember.RenderBuffer.prototype.elementProperties;
 /** @type {!Object} */
Ember.RenderBuffer.prototype.elementStyle;
 /** @type {string} */
Ember.RenderBuffer.prototype.elementTag;
 /** @type {!Ember.RenderBuffer} */
Ember.RenderBuffer.prototype.parentBuffer;

/**
 * @param {string} className
 * @return {!Ember.RenderBuffer}
 */
Ember.RenderBuffer.prototype.addClass = function(className) {};

/**
 * @param {string} name
 * @param {?} value
 * @return {?}
 */
Ember.RenderBuffer.prototype.attr = function(name, value) {};

/**
 * @return {!HTMLElement}
 */
Ember.RenderBuffer.prototype.element = function() {};

/**
 * @param {string} id
 * @return {!Ember.RenderBuffer}
 */
Ember.RenderBuffer.prototype.id = function(id) {};

/**
 * @param {string} name
 * @param {string} value
 * @return {?}
 */
Ember.RenderBuffer.prototype.prop = function(name, value) {};

/**
 * @param {string} string
 * @return {!Ember.RenderBuffer}
 */
Ember.RenderBuffer.prototype.push = function(string) {};

/**
 * @param {string} name
 * @return {!Ember.RenderBuffer}
 */
Ember.RenderBuffer.prototype.removeAttr = function(name) {};

/**
 * @param {string} name
 * @return {!Ember.RenderBuffer}
 */
Ember.RenderBuffer.prototype.removeProp = function(name) {};

/**
 * @return {string}
 */
Ember.RenderBuffer.prototype.string = function() {};

/**
 * @param {string} name
 * @param {string} value
 * @return {!Ember.RenderBuffer}
 */
Ember.RenderBuffer.prototype.style = function(name, value) {};
/**
 * @extends {Ember.Object}
 * @extends {Ember.ActionHandlerMixin}
 * @extends {Ember.Evented}
 * @constructor
 * @struct
 */
Ember.Route = function() {};
 /** @type {boolean} */
Ember.Route.isClass;
 /** @type {boolean} */
Ember.Route.isMethod;
 /** @type {!Function} */
Ember.Route.prototype.activate;
 /** @type {!Ember.Controller} */
Ember.Route.prototype.controller;
 /** @type {string} */
Ember.Route.prototype.controllerName;
 /** @type {!Function} */
Ember.Route.prototype.deactivate;
 /** @type {!Object} */
Ember.Route.prototype.queryParams;
 /** @type {string} */
Ember.Route.prototype.templateName;
 /** @type {string} */
Ember.Route.prototype.viewName;
 /** @type {!ActionsHash} */
Ember.Route.prototype.actions;

/**
 * This hook is called after this route's model has resolved.
 * It follows identical async/promise semantics to `beforeModel`
 * but is provided the route's resolved model in addition to
 * the `transition`, and is therefore suited to performing
 * logic that can only take place after the model has already
 * resolved.
 * Refer to documentation for `beforeModel` for a description
 * of transition-pausing semantics when a promise is returned
 * from this hook.
 * \@method afterModel
 * or its resolved value if it was a promise
 * a promise, the transition will pause until the transition
 * resolves. Otherwise, non-promise return values are not
 * utilized in any way.
 * @param {?} resolvedModel
 * @param {!EmberStates.Transition} transition
 * @return {!Ember.RSVP.Promise}
 */
Ember.Route.prototype.afterModel = function(resolvedModel, transition) {};

/**
 * This hook is the first of the route entry validation hooks
 * called when an attempt is made to transition into a route
 * or one of its children. It is called before `model` and
 * `afterModel`, and is appropriate for cases when:
 * 1) A decision can be made to redirect elsewhere without
 * needing to resolve the model first.
 * 2) Any async operations need to occur first before the
 * model is attempted to be resolved.
 * This hook is provided the current `transition` attempt
 * as a parameter, which can be used to `.abort()` the transition,
 * save it for a later `.retry()`, or retrieve values set
 * on it from a previous hook. You can also just call
 * `this.transitionTo` to another route to implicitly
 * abort the `transition`.
 * You can return a promise from this hook to pause the
 * transition until the promise resolves (or rejects). This could
 * be useful, for instance, for retrieving async code from
 * the server that is required to enter a route.
 * \@method beforeModel
 * a promise, the transition will pause until the transition
 * resolves. Otherwise, non-promise return values are not
 * utilized in any way.
 * @param {!EmberStates.Transition} transition
 * @return {!Ember.RSVP.Promise}
 */
Ember.Route.prototype.beforeModel = function(transition) {};

/**
 * Returns the controller for a particular route or name.
 * The controller instance must already have been created, either through entering the
 * associated route or using `generateController`.
 * \@method controllerFor
 * @param {string} name
 * @return {!Ember.Controller}
 */
Ember.Route.prototype.controllerFor = function(name) {};

/**
 * Deserializes value of the query parameter based on defaultValueType
 * \@method deserializeQueryParam
 * @param {?} value
 * @param {string} urlKey
 * @param {string} defaultValueType
 * @return {?}
 */
Ember.Route.prototype.deserializeQueryParam = function(value, urlKey, defaultValueType) {};

/**
 * Disconnects a view that has been rendered into an outlet.
 * You may pass any or all of the following options to `disconnectOutlet`:
 * `outlet`: the name of the outlet to clear (default: 'main')
 * `parentView`: the name of the view containing the outlet to clear
 * (default: the view rendered by the parent route)
 * \@method disconnectOutlet
 * @param {(string|!DisconnectOutletOptions)} options
 * @return {void}
 */
Ember.Route.prototype.disconnectOutlet = function(options) {};

/**
 * \@method findModel
 * @param {string} type
 * @param {?} value
 * @return {?}
 */
Ember.Route.prototype.findModel = function(type, value) {};

/**
 * Generates a controller for a route.
 * If the optional model is passed then the controller type is determined automatically,
 * e.g., an ArrayController for arrays.
 * \@method generateController
 * @param {string} name
 * @param {!Object} model
 * @return {!Ember.Controller}
 */
Ember.Route.prototype.generateController = function(name, model) {};

/**
 * Perform a synchronous transition into another route without attempting
 * to resolve promises, update the URL, or abort any currently active
 * asynchronous transitions (i.e. regular transitions caused by
 * `transitionTo` or URL changes).
 * This method is handy for performing intermediate transitions on the
 * way to a final destination route, and is called internally by the
 * default implementations of the `error` and `loading` handlers.
 * \@method intermediateTransitionTo
 * to the route.
 * \@since 1.2.0
 * @param {string} name
 * @param {...?} models
 * @return {void}
 */
Ember.Route.prototype.intermediateTransitionTo = function(name, models) {};

/**
 * A hook you can implement to convert the URL into the model for
 * this route.
 * \@method model
 * a promise is returned, the transition will pause until
 * the promise resolves, and the resolved value of the promise
 * will be used as the model for this route.
 * @param {!Object} params
 * @param {!EmberStates.Transition} transition
 * @return {?}
 */
Ember.Route.prototype.model = function(params, transition) {};

/**
 * Returns the model of a parent (or any ancestor) route
 * in a route hierarchy.  During a transition, all routes
 * must resolve a model object, and if a route
 * needs access to a parent route's model in order to
 * resolve a model (or just reuse the model from a parent),
 * it can call `this.modelFor(theNameOfParentRoute)` to
 * retrieve it.
 * \@method modelFor
 * @param {string} name
 * @return {!Object}
 */
Ember.Route.prototype.modelFor = function(name) {};

/**
 * Retrieves parameters, for current route using the state.params
 * variable and getQueryParamsFor, using the supplied routeName.
 * \@method paramsFor
 * @param {string} name
 * @return {?}
 */
Ember.Route.prototype.paramsFor = function(name) {};

/**
 * Refresh the model on this route and any child routes, firing the
 * `beforeModel`, `model`, and `afterModel` hooks in a similar fashion
 * to how routes are entered when transitioning in from other route.
 * The current route params (e.g. `article_id`) will be passed in
 * to the respective model hooks, and if a different model is returned,
 * `setupController` and associated route hooks will re-fire as well.
 * An example usage of this method is re-querying the server for the
 * latest information using the same parameters as when the route
 * was first entered.
 * Note that this will cause `model` hooks to fire even on routes
 * that were provided a model object when the route was initially
 * entered.
 * \@method refresh
 * attempted transition
 * \@since 1.4.0
 * @return {!EmberStates.Transition}
 */
Ember.Route.prototype.redirect = function() {};

/**
 * Refresh the model on this route and any child routes, firing the
 * `beforeModel`, `model`, and `afterModel` hooks in a similar fashion
 * to how routes are entered when transitioning in from other route.
 * The current route params (e.g. `article_id`) will be passed in
 * to the respective model hooks, and if a different model is returned,
 * `setupController` and associated route hooks will re-fire as well.
 * An example usage of this method is re-querying the server for the
 * latest information using the same parameters as when the route
 * was first entered.
 * Note that this will cause `model` hooks to fire even on routes
 * that were provided a model object when the route was initially
 * entered.
 * \@method refresh
 * attempted transition
 * \@since 1.4.0
 * @return {!EmberStates.Transition}
 */
Ember.Route.prototype.refresh = function() {};

/**
 * `render` is used to render a template into a region of another template
 * (indicated by an `{{outlet}}`). `render` is used both during the entry
 * phase of routing (via the `renderTemplate` hook) and later in response to
 * user interaction.
 * \@method render
 * referenced by name. Defaults to the parent template
 * Defaults to 'main'
 * referenced by name or as a controller instance. Defaults to the Route's paired controller
 * Defaults to the return value of the Route's model hook
 * @param {string} name
 * @param {!RenderOptions=} options
 * @return {void}
 */
Ember.Route.prototype.render = function(name, options) {};

/**
 * A hook you can use to render the template for the current route.
 * This method is called with the controller for the current route and the
 * model supplied by the `model` hook. By default, it renders the route's
 * template, configured with the controller for the route.
 * This method can be overridden to set up and render additional or
 * alternative templates.
 * \@method renderTemplate
 * @param {!Ember.Controller} controller
 * @param {!Object} model
 * @return {void}
 */
Ember.Route.prototype.renderTemplate = function(controller, model) {};

/**
 * Transition into another route while replacing the current URL, if possible.
 * This will replace the current history entry instead of adding a new one.
 * Beside that, it is identical to `transitionTo` in all other respects. See
 * 'transitionTo' for additional information regarding multiple models.
 * \@method replaceWith
 * transitioning to the route.
 * attempted transition
 * @param {string} name
 * @param {...?} models
 * @return {void}
 */
Ember.Route.prototype.replaceWith = function(name, models) {};

/**
 * A hook you can use to reset controller values either when the model
 * changes or the route is exiting.
 * \@method resetController
 * \@since 1.7.0
 * @param {!Ember.Controller} controller
 * @param {boolean} isExiting
 * @param {?} transition
 * @return {void}
 */
Ember.Route.prototype.resetController = function(controller, isExiting, transition) {};

/**
 * A hook you can implement to convert the route's model into parameters
 * for the URL.
 * The default `serialize` method will insert the model's `id` into the
 * route's dynamic segment (in this case, `:post_id`) if the segment contains '_id'.
 * If the route has multiple dynamic segments or does not contain '_id', `serialize`
 * will return `Ember.getProperties(model, params)`
 * This method is called when `transitionTo` is called with a context
 * in order to populate the URL.
 * \@method serialize
 * route (in the example, `['post_id']`.
 * @param {!Object} model
 * @param {!Array<string>} params
 * @return {string}
 */
Ember.Route.prototype.serialize = function(model, params) {};

/**
 * Serializes value of the query parameter based on defaultValueType
 * \@method serializeQueryParam
 * @param {?} value
 * @param {string} urlKey
 * @param {string} defaultValueType
 * @return {string}
 */
Ember.Route.prototype.serializeQueryParam = function(value, urlKey, defaultValueType) {};

/**
 * Serializes the query parameter key
 * \@method serializeQueryParamKey
 * @param {string} controllerPropertyName
 * @return {string}
 */
Ember.Route.prototype.serializeQueryParamKey = function(controllerPropertyName) {};

/**
 * A hook you can use to setup the controller for the current route.
 * This method is called with the controller for the current route and the
 * model supplied by the `model` hook.
 * By default, the `setupController` hook sets the `model` property of
 * the controller to the `model`.
 * If you implement the `setupController` hook in your Route, it will
 * prevent this default behavior. If you want to preserve that behavior
 * when implementing your `setupController` function, make sure to call
 * `_super`
 * \@method setupController
 * @param {!Ember.Controller} controller
 * @param {!Object} model
 * @return {void}
 */
Ember.Route.prototype.setupController = function(controller, model) {};

/**
 * Store property provides a hook for data persistence libraries to inject themselves.
 * By default, this store property provides the exact same functionality previously
 * in the model hook.
 * Currently, the required interface is:
 * `store.find(modelName, findArguments)`
 * \@method store
 * @param {?} store
 * @return {?}
 */
Ember.Route.prototype.store = function(store) {};

/**
 * Transition the application into another route. The route may
 * be either a single route or route path
 * \@method transitionTo
 * transitioning to the route.
 * containing a mapping of query parameters
 * attempted transition
 * @param {string} name
 * @param {...?} object
 * @return {!EmberStates.Transition}
 */
Ember.Route.prototype.transitionTo = function(name, object) {};

/**
 * Sends an action to the router, which will delegate it to the currently
 * active route hierarchy per the bubbling rules explained under actions
 * \@method send
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.Route.prototype.send = function(name, args) {};

/**
 * Subscribes to a named event with given function.
 * An optional target can be passed in as the 2nd argument that will
 * be set as the "this" for the callback. This is a good way to give your
 * function access to the object triggering the event. When the target
 * parameter is used the callback becomes the third argument.
 * \@method on
 * @param {string} name
 * @param {?} target
 * @param {!Function} method
 * @return {!Ember.Evented} this
 */
Ember.Route.prototype.on = function(name, target, method) {};

/**
 * Subscribes a function to a named event and then cancels the subscription
 * after the first time the event is triggered. It is good to use ``one`` when
 * you only care about the first time an event has taken place.
 * This function takes an optional 2nd argument that will become the "this"
 * value for the callback. If this argument is passed then the 3rd argument
 * becomes the function.
 * \@method one
 * @param {string} name
 * @param {?} target
 * @param {!Function} method
 * @return {!Ember.Evented} this
 */
Ember.Route.prototype.one = function(name, target, method) {};

/**
 * Triggers a named event for the object. Any additional arguments
 * will be passed as parameters to the functions that are subscribed to the
 * event.
 * \@method trigger
 * @param {string} name
 * @param {...string} args
 * @return {void}
 */
Ember.Route.prototype.trigger = function(name, args) {};

/**
 * Cancels subscription for given name, target, and method.
 * \@method off
 * @param {string} name
 * @param {?} target
 * @param {!Function} method
 * @return {!Ember.Evented} this
 */
Ember.Route.prototype.off = function(name, target, method) {};

/**
 * Checks to see if object has any subscriptions for named event.
 * \@method has
 * @param {string} name
 * @return {boolean}
 */
Ember.Route.prototype.has = function(name) {};
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.Router = function() {};
 /** @type {boolean} */
Ember.Router.isClass;
 /** @type {boolean} */
Ember.Router.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Router.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Router.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.Router.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.Router.metaForProperty = function(key) {};

/**
 * @param {!Function} callback
 * @return {!Ember.Router}
 */
Ember.Router.prototype.map = function(callback) {};
/**
 * @constructor
 * @struct
 */
Ember.RouterDSL = function() {};

/**
 * @param {string} name
 * @param {!Object|!Function=} options_or_callback
 * @param {!Function=} callback
 * @return {void}
 */
Ember.RouterDSL.prototype.resource = function(name, options_or_callback, callback) {};

/**
 * @param {string} name
 * @param {!Object=} options
 * @return {void}
 */
Ember.RouterDSL.prototype.route = function(name, options) {};
 /** @type {boolean} */
Ember.SHIM_ES5;
 /** @type {boolean} */
Ember.STRINGS;
/**
 * @extends {Ember.View}
 * @constructor
 * @struct
 */
Ember.Select = function() {};
 /** @type {boolean} */
Ember.Select.isClass;
 /** @type {boolean} */
Ember.Select.isMethod;
 /** @type {!Array<?>} */
Ember.Select.prototype.content;
 /** @type {!Ember.View} */
Ember.Select.prototype.groupView;
 /** @type {boolean} */
Ember.Select.prototype.multiple;
 /** @type {string} */
Ember.Select.prototype.optionGroupPath;
 /** @type {string} */
Ember.Select.prototype.optionLabelPath;
 /** @type {string} */
Ember.Select.prototype.optionValuePath;
 /** @type {!Ember.View} */
Ember.Select.prototype.optionView;
 /** @type {string} */
Ember.Select.prototype.prompt;
 /** @type {?} */
Ember.Select.prototype.selection;
 /** @type {string} */
Ember.Select.prototype.value;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Select.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Select.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.Select.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.Select.metaForProperty = function(key) {};
/**
 * @extends {Ember.View}
 * @constructor
 * @struct
 */
Ember.SelectOption = function() {};
 /** @type {boolean} */
Ember.SelectOption.isClass;
 /** @type {boolean} */
Ember.SelectOption.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.SelectOption.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.SelectOption.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.SelectOption.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.SelectOption.metaForProperty = function(key) {};
/**
 * @extends {Ember.CoreObject}
 * @extends {Ember.MutableEnumberable}
 * @extends {Ember.Copyable}
 * @extends {Ember.Freezable}
 * @constructor
 * @struct
 */
Ember.Set = function() {};
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.Set.prototype.map;
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.Set.prototype.reject;

/* TODO: PropertyDeclaration: Ember.'[]' */
 /** @type {?} */
Ember.Set.prototype.firstObject;
 /** @type {boolean} */
Ember.Set.prototype.hasEnumerableObservers;
 /** @type {?} */
Ember.Set.prototype.lastObject;
 /** @type {boolean} */
Ember.Set.prototype.isFrozen;
 /** @type {number} */
Ember.Set.prototype.length;

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Set}
 */
Ember.Set.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.Set.prototype.addObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.Set}
 */
Ember.Set.prototype.addObjects = function(objects) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Set.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Set.prototype.anyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Set.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Ember.Set.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Set.prototype.contains = function(obj) {};

/**
 * @param {number|!Ember.Enumerable} start_or_removing
 * @param {number|!Ember.Enumerable} removing_or_adding
 * @param {number|!Ember.Enumerable=} adding
 * @return {?}
 */
Ember.Set.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {number|!Ember.Enumerable} removing
 * @param {number|!Ember.Enumerable} adding
 * @return {!Ember.Set}
 */
Ember.Set.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Set.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Set.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Set.prototype.everyProperty = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {!Array<?>}
 */
Ember.Set.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.Set.prototype.filterBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {?}
 */
Ember.Set.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Ember.Set.prototype.findBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {?}
 */
Ember.Set.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.Set.prototype.getEach = function(key) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.Set.prototype.invoke = function(methodName, args) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.Set.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Ember.Set.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {!ReduceCallback} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Ember.Set.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.Set.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Set}
 */
Ember.Set.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.Set.prototype.removeObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.Set}
 */
Ember.Set.prototype.removeObjects = function(objects) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Ember.Set.prototype.setEach = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Set.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Ember.Set.prototype.toArray = function() {};

/**
 * @return {!Ember.Set}
 */
Ember.Set.prototype.uniq = function() {};

/**
 * @param {?} value
 * @return {!Ember.Set}
 */
Ember.Set.prototype.without = function(value) {};

/**
 * @param {boolean} deep
 * @return {!Ember.Set}
 */
Ember.Set.prototype.copy = function(deep) {};

/**
 * @return {!Ember.Set}
 */
Ember.Set.prototype.frozenCopy = function() {};

/**
 * @return {!Ember.Set}
 */
Ember.Set.prototype.freeze = function() {};

/**
 * @param {?} obj
 * @return {!Ember.Set}
 */
Ember.Set.prototype.add = function(obj) {};

/**
 * @param {...?} args
 * @return {!Ember.Set}
 */
Ember.Set.prototype.addEach = function(args) {};

/**
 * @return {!Ember.Set}
 */
Ember.Set.prototype.clear = function() {};

/**
 * @param {!Ember.Set} obj
 * @return {boolean}
 */
Ember.Set.prototype.isEqual = function(obj) {};

/**
 * @return {?}
 */
Ember.Set.prototype.pop = function() {};

/**
 * @param {?} obj
 * @return {!Ember.Set}
 */
Ember.Set.prototype.push = function(obj) {};

/**
 * @param {?} obj
 * @return {!Ember.Set}
 */
Ember.Set.prototype.remove = function(obj) {};

/**
 * @param {...?} args
 * @return {!Ember.Set}
 */
Ember.Set.prototype.removeEach = function(args) {};

/**
 * @return {?}
 */
Ember.Set.prototype.shift = function() {};

/**
 * @param {?} obj
 * @return {!Ember.Set}
 */
Ember.Set.prototype.unshift = function(obj) {};
/**
 * @extends {Ember.MutableEnumberable}
 * @constructor
 * @struct
 */
Ember.SortableMixin = function() {};
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.SortableMixin.prototype.map;
 /** @type {!ItemIndexEnumerableCallbackTarget} */
Ember.SortableMixin.prototype.reject;

/* TODO: PropertyDeclaration: Ember.'[]' */
 /** @type {?} */
Ember.SortableMixin.prototype.arrangedContent;
 /** @type {?} */
Ember.SortableMixin.prototype.firstObject;
 /** @type {boolean} */
Ember.SortableMixin.prototype.hasEnumerableObservers;
 /** @type {?} */
Ember.SortableMixin.prototype.lastObject;
 /** @type {boolean} */
Ember.SortableMixin.prototype.sortAscending;
 /** @type {!Ember.Comparable} */
Ember.SortableMixin.prototype.sortFunction;
 /** @type {!Array<?>} */
Ember.SortableMixin.prototype.sortProperties;

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Enumerable}
 */
Ember.SortableMixin.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.SortableMixin.prototype.addObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.SortableMixin.prototype.addObjects = function(objects) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.SortableMixin.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.SortableMixin.prototype.anyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.SortableMixin.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Ember.SortableMixin.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.SortableMixin.prototype.contains = function(obj) {};

/**
 * @param {number|!Ember.Enumerable} start_or_removing
 * @param {number|!Ember.Enumerable} removing_or_adding
 * @param {number|!Ember.Enumerable=} adding
 * @return {?}
 */
Ember.SortableMixin.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {number|!Ember.Enumerable} removing
 * @param {number|!Ember.Enumerable} adding
 * @return {!Ember.Enumerable}
 */
Ember.SortableMixin.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.SortableMixin.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.SortableMixin.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.SortableMixin.prototype.everyProperty = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {!Array<?>}
 */
Ember.SortableMixin.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.SortableMixin.prototype.filterBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?} target
 * @return {?}
 */
Ember.SortableMixin.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Ember.SortableMixin.prototype.findBy = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {?}
 */
Ember.SortableMixin.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.SortableMixin.prototype.getEach = function(key) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.SortableMixin.prototype.invoke = function(methodName, args) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.SortableMixin.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Ember.SortableMixin.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {!ReduceCallback} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Ember.SortableMixin.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.SortableMixin.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {!EnumerableConfigurationOptions} opts
 * @return {!Ember.Enumerable}
 */
Ember.SortableMixin.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.SortableMixin.prototype.removeObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.SortableMixin.prototype.removeObjects = function(objects) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Ember.SortableMixin.prototype.setEach = function(key, value) {};

/**
 * @param {!Function} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.SortableMixin.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Ember.SortableMixin.prototype.toArray = function() {};

/**
 * @return {!Ember.Enumerable}
 */
Ember.SortableMixin.prototype.uniq = function() {};

/**
 * @param {?} value
 * @return {!Ember.Enumerable}
 */
Ember.SortableMixin.prototype.without = function(value) {};
/**
 * @extends {Ember.Object}
 * @extends {Ember.Evented}
 * @constructor
 * @struct
 */
Ember.State = function() {};
 /** @type {boolean} */
Ember.State.isClass;
 /** @type {boolean} */
Ember.State.isMethod;
 /** @type {boolean} */
Ember.State.prototype.hasContext;
 /** @type {boolean} */
Ember.State.prototype.isLeaf;
 /** @type {string} */
Ember.State.prototype.name;
 /** @type {!Ember.State} */
Ember.State.prototype.parentState;
 /** @type {string} */
Ember.State.prototype.path;
 /** @type {!Function} */
Ember.State.prototype.enter;
 /** @type {!Function} */
Ember.State.prototype.exit;
 /** @type {!Function} */
Ember.State.prototype.setup;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.State.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.State.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.State.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.State.metaForProperty = function(key) {};

/**
 * @param {string} name
 * @return {boolean}
 */
Ember.State.prototype.has = function(name) {};

/**
 * @param {string} name
 * @param {?} target
 * @param {!Function} method
 * @return {!Ember.State}
 */
Ember.State.prototype.off = function(name, target, method) {};

/**
 * @param {string} name
 * @param {?} target
 * @param {!Function} method
 * @return {!Ember.State}
 */
Ember.State.prototype.on = function(name, target, method) {};

/**
 * @param {string} name
 * @param {?} target
 * @param {!Function} method
 * @return {!Ember.State}
 */
Ember.State.prototype.one = function(name, target, method) {};

/**
 * @param {string} name
 * @param {...string} args
 * @return {void}
 */
Ember.State.prototype.trigger = function(name, args) {};

/**
 * @param {!Object} stateManager
 * @param {string} path
 * @return {!Object}
 */
Ember.State.prototype.getPathsCache = function(stateManager, path) {};

/**
 * @return {void}
 */
Ember.State.prototype.init = function() {};

/**
 * @param {!Object} stateManager
 * @param {string} path
 * @param {?} transitions
 * @return {void}
 */
Ember.State.prototype.setPathsCache = function(stateManager, path, transitions) {};

/**
 * @param {string} target
 * @return {void}
 */
Ember.State.transitionTo = function(target) {};
/**
 * @extends {Ember.State}
 * @constructor
 * @struct
 */
Ember.StateManager = function() {};
 /** @type {boolean} */
Ember.StateManager.isClass;
 /** @type {boolean} */
Ember.StateManager.isMethod;
 /** @type {string} */
Ember.StateManager.prototype.currentPath;
 /** @type {!Ember.State} */
Ember.StateManager.prototype.currentState;
 /** @type {boolean} */
Ember.StateManager.prototype.errorOnUnhandledEvents;
 /** @type {string} */
Ember.StateManager.prototype.transitionEvent;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.StateManager.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.StateManager.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.StateManager.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.StateManager.metaForProperty = function(key) {};

/**
 * @param {!Ember.State} currentState
 * @param {string} path
 * @return {!TransitionsHash}
 */
Ember.StateManager.prototype.contextFreeTransition = function(currentState, path) {};

/**
 * @param {!TransitionsHash} transition
 * @return {void}
 */
Ember.StateManager.prototype.enterState = function(transition) {};

/**
 * @param {string} name
 * @return {!Ember.State}
 */
Ember.StateManager.prototype.getState = function(name) {};

/**
 * @param {!Ember.State} root
 * @param {string} path
 * @return {!Ember.State}
 */
Ember.StateManager.prototype.getStateByPath = function(root, path) {};

/**
 * @param {!Ember.State} state
 * @param {string} key
 * @return {?}
 */
Ember.StateManager.prototype.getStateMeta = function(state, key) {};

/**
 * @param {!Ember.State} root
 * @param {string} path
 * @return {!Array<!Ember.State>}
 */
Ember.StateManager.prototype.getStatesInPath = function(root, path) {};

/**
 * @param {string} path
 * @param {?} context
 * @return {void}
 */
Ember.StateManager.prototype.goToState = function(path, context) {};

/**
 * @param {string} event
 * @return {void}
 */
Ember.StateManager.prototype.send = function(event) {};

/**
 * @param {!Ember.State} state
 * @param {string} key
 * @param {?} value
 * @return {?}
 */
Ember.StateManager.prototype.setStateMeta = function(state, key, value) {};

/**
 * @param {!Ember.State} state
 * @return {!Object}
 */
Ember.StateManager.prototype.stateMetaFor = function(state) {};

/**
 * @param {string} path
 * @param {?} context
 * @return {void}
 */
Ember.StateManager.prototype.transitionTo = function(path, context) {};

/**
 * @param {!TransitionsHash} transitions
 * @return {void}
 */
Ember.StateManager.prototype.triggerSetupContext = function(transitions) {};

/**
 * @param {!Ember.StateManager} manager
 * @param {string} event
 * @return {?}
 */
Ember.StateManager.prototype.unhandledEvent = function(manager, event) {};
/** @const */
Ember.String = {};

/**
 * @param {string} str
 * @return {string}
 */
Ember.String.camelize = function(str) {};

/**
 * @param {string} str
 * @return {string}
 */
Ember.String.capitalize = function(str) {};

/**
 * @param {string} str
 * @return {string}
 */
Ember.String.classify = function(str) {};

/**
 * @param {string} str
 * @return {string}
 */
Ember.String.dasherize = function(str) {};

/**
 * @param {string} str
 * @return {string}
 */
Ember.String.decamelize = function(str) {};

/**
 * @param {...string} args
 * @return {string}
 */
Ember.String.fmt = function(args) {};

/**
 * @param {string} str
 * @return {void}
 */
Ember.String.htmlSafe = function(str) {};

/**
 * @param {...string} args
 * @return {string}
 */
Ember.String.loc = function(args) {};

/**
 * @param {string} str
 * @return {string}
 */
Ember.String.underscore = function(str) {};

/**
 * @param {string} str
 * @return {!Array<string>}
 */
Ember.String.w = function(str) {};
 /** @type {!Object} */
Ember.TEMPLATES;
/**
 * @constructor
 * @struct
 */
Ember.TargetActionSupport = function() {};

/**
 * @param {!Object} opts
 * @return {boolean}
 */
Ember.TargetActionSupport.prototype.triggerAction = function(opts) {};
/**
 * @constructor
 * @struct
 */
Ember.Test = function() {};
 /** @type {!Ember.Object} */
Ember.Test.adapter;
 /** @type {!Object} */
Ember.Test.prototype.testHelpers;

/**
 * @param {string} selector
 * @return {!Ember.RSVP.Promise}
 */
Ember.Test.prototype.click = function(selector) {};

/**
 * @param {string} selector
 * @param {string} text
 * @return {!Ember.RSVP.Promise}
 */
Ember.Test.prototype.fillin = function(selector, text) {};

/**
 * @param {string} selector
 * @return {?<!HTMLElement>}
 */
Ember.Test.prototype.find = function(selector) {};

/**
 * @param {string} selector
 * @return {?<!HTMLElement>}
 */
Ember.Test.prototype.findWithAssert = function(selector) {};

/**
 * @return {void}
 */
Ember.Test.prototype.injectTestHelpers = function() {};

/**
 * @param {string} selector
 * @param {string} type
 * @param {number} keyCode
 * @return {!Ember.RSVP.Promise}
 */
Ember.Test.prototype.keyEvent = function(selector, type, keyCode) {};

/**
 * @param {!Function} callback
 * @return {void}
 */
Ember.Test.oninjectHelpers = function(callback) {};

/**
 * @param {!Function} resolver
 * @return {!Ember.RSVP.Promise}
 */
Ember.Test.promise = function(resolver) {};

/**
 * @param {string} name
 * @param {!Function} helperMethod
 * @return {void}
 */
Ember.Test.registerHelper = function(name, helperMethod) {};

/**
 * @return {void}
 */
Ember.Test.prototype.removeTestHelpers = function() {};

/**
 * @return {void}
 */
Ember.Test.prototype.setupForTesting = function() {};

/**
 * @param {string} name
 * @return {void}
 */
Ember.Test.unregisterHelper = function(name) {};

/**
 * @param {string} url
 * @return {!Ember.RSVP.Promise}
 */
Ember.Test.prototype.visit = function(url) {};

/**
 * @param {?} value
 * @return {!Ember.RSVP.Promise}
 */
Ember.Test.prototype.wait = function(value) {};
/**
 * @extends {Ember.View}
 * @extends {Ember.TextSupport}
 * @constructor
 * @struct
 */
Ember.TextArea = function() {};
 /** @type {boolean} */
Ember.TextArea.isClass;
 /** @type {boolean} */
Ember.TextArea.isMethod;
 /** @type {string} */
Ember.TextArea.prototype.action;
 /** @type {boolean} */
Ember.TextArea.prototype.bubbles;
 /** @type {string} */
Ember.TextArea.prototype.onEvent;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.TextArea.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.TextArea.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.TextArea.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.TextArea.metaForProperty = function(key) {};

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextArea.prototype.cancel = function(event) {};

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextArea.prototype.focusIn = function(event) {};

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextArea.prototype.focusOut = function(event) {};

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextArea.prototype.insertNewLine = function(event) {};

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextArea.prototype.keyPress = function(event) {};
/**
 * @extends {Ember.View}
 * @extends {Ember.TextSupport}
 * @constructor
 * @struct
 */
Ember.TextField = function() {};
 /** @type {boolean} */
Ember.TextField.isClass;
 /** @type {boolean} */
Ember.TextField.isMethod;
 /** @type {string} */
Ember.TextField.prototype.action;
 /** @type {boolean} */
Ember.TextField.prototype.bubbles;
 /** @type {string} */
Ember.TextField.prototype.onEvent;
 /** @type {string} */
Ember.TextField.prototype.pattern;
 /** @type {string} */
Ember.TextField.prototype.size;
 /** @type {string} */
Ember.TextField.prototype.type;
 /** @type {string} */
Ember.TextField.prototype.value;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.TextField.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.TextField.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.TextField.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.TextField.metaForProperty = function(key) {};

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextField.prototype.cancel = function(event) {};

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextField.prototype.focusIn = function(event) {};

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextField.prototype.focusOut = function(event) {};

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextField.prototype.insertNewLine = function(event) {};

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextField.prototype.keyPress = function(event) {};
/**
 * @constructor
 * @struct
 */
Ember.TextSupport = function() {};
 /** @type {string} */
Ember.TextSupport.prototype.action;
 /** @type {boolean} */
Ember.TextSupport.prototype.bubbles;
 /** @type {string} */
Ember.TextSupport.prototype.onEvent;

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextSupport.prototype.cancel = function(event) {};

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextSupport.prototype.focusIn = function(event) {};

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextSupport.prototype.focusOut = function(event) {};

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextSupport.prototype.insertNewLine = function(event) {};

/**
 * @param {!Function} event
 * @return {void}
 */
Ember.TextSupport.prototype.keyPress = function(event) {};
 /** @type {string} */
Ember.VERSION;
/**
 * @extends {Ember.CoreView}
 * @constructor
 * @struct
 */
Ember.View = function() {};
 /** @type {boolean} */
Ember.View.isClass;
 /** @type {boolean} */
Ember.View.isMethod;
 /** @type {string} */
Ember.View.prototype.ariaRole;
 /** @type {?} */
Ember.View.prototype.attributeBindings;
 /** @type {!Array<string>} */
Ember.View.prototype.classNameBindings;
 /** @type {!Array<string>} */
Ember.View.prototype.classNames;
 /** @type {?} */
Ember.View.prototype.context;
 /** @type {?} */
Ember.View.prototype.controller;
 /** @type {!HTMLElement} */
Ember.View.prototype.element;
 /** @type {boolean} */
Ember.View.prototype.isView;
 /** @type {boolean} */
Ember.View.prototype.isVisible;
 /** @type {!Function} */
Ember.View.prototype.layout;
 /** @type {string} */
Ember.View.prototype.layoutName;
 /** @type {!Ember.View} */
Ember.View.prototype.nearestChildOf;
 /** @type {!Ember.View} */
Ember.View.prototype.nearestOfType;
 /** @type {!Ember.View} */
Ember.View.prototype.nearestWithProperty;
 /** @type {string} */
Ember.View.prototype.tagName;
 /** @type {!Function} */
Ember.View.prototype.template;
 /** @type {string} */
Ember.View.prototype.templateName;
 /** @type {!Object} */
Ember.View.prototype.templates;
 /** @type {!Object} */
Ember.View.prototype.views;
 /** @type {!Function} */
Ember.View.prototype.didInsertElement;
 /** @type {!Function} */
Ember.View.prototype.parentViewDidChange;
 /** @type {!Function} */
Ember.View.prototype.willClearRender;
 /** @type {!Function} */
Ember.View.prototype.willDestroyElement;
 /** @type {!Function} */
Ember.View.prototype.willInsertElement;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.View.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.View.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {!Function} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.View.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.View.metaForProperty = function(key) {};

/**
 * @return {?<!HTMLElement>}
 */
Ember.View.prototype.$ = function() {};

/**
 * @return {!Ember.View}
 */
Ember.View.prototype.append = function() {};

/**
 * @param {string|!HTMLElement|?<!HTMLElement>} A
 * @return {!Ember.View}
 */
Ember.View.prototype.appendTo = function(A) {};

/**
 * @param {!Object|string} viewClass
 * @param {!Object=} attrs
 * @return {!Ember.View}
 */
Ember.View.prototype.createChildView = function(viewClass, attrs) {};

/**
 * @return {!Ember.View}
 */
Ember.View.prototype.createElement = function() {};

/**
 * @return {!Ember.View}
 */
Ember.View.prototype.destroy = function() {};

/**
 * @return {!Ember.View}
 */
Ember.View.prototype.destroyElement = function() {};

/**
 * @param {!HTMLElement} parentElement
 * @return {!HTMLElement}
 */
Ember.View.prototype.findElementInParentElement = function(parentElement) {};

/**
 * @return {!Ember.View}
 */
Ember.View.prototype.remove = function() {};

/**
 * @return {!Ember.View}
 */
Ember.View.prototype.removeAllChildren = function() {};

/**
 * @param {!Ember.View} view
 * @return {!Ember.View}
 */
Ember.View.prototype.removeChild = function(view) {};

/**
 * @return {!Ember.View}
 */
Ember.View.prototype.removeFromParent = function() {};

/**
 * @param {!Ember.RenderBuffer} buffer
 * @return {void}
 */
Ember.View.prototype.render = function(buffer) {};

/**
 * @param {string|!HTMLElement|?<!HTMLElement>} A
 * @return {!Ember.View}
 */
Ember.View.prototype.replaceIn = function(A) {};

/**
 * @return {void}
 */
Ember.View.prototype.rerender = function() {};
/**
 * @extends {Ember.Mixin}
 * @constructor
 * @struct
 */
Ember.ViewTargetActionSupport = function() {};
 /** @type {?} */
Ember.ViewTargetActionSupport.prototype.target;
 /** @type {?} */
Ember.ViewTargetActionSupport.prototype.actionContext;
 /** @type {!Object} */
Ember.ViewUtils;

/**
 * @param {?} obj
 * @param {string} path
 * @param {?} target
 * @param {!Function} method
 * @return {?}
 */
Ember.addBeforeObserver = function(obj, path, target, method) {};

/**
 * @param {?} obj
 * @param {string} eventName
 * @param {?|!Function} target_or_func
 * @param {!Function|string} method
 * @param {boolean=} once
 * @return {void}
 */
Ember.addListener = function(obj, eventName, target_or_func, method, once) {};
 /** @type {!ModifyObserver} */
Ember.addObserver;
 /** @type {function(string, !Function): !Function} */
Ember.alias;

/**
 * @param {string} methodName
 * @return {!Ember.Descriptor}
 */
Ember.aliasMethod = function(methodName) {};
 /** @type {boolean} */
Ember.anyUnprocessedMixins;

/**
 * @param {string} desc
 * @param {boolean} test
 * @return {void}
 */
Ember.assert = function(desc, test) {};

/**
 * @param {!Function} func
 * @param {string} propertyName
 * @return {!Function}
 */
Ember.beforeObserver = function(func, propertyName) {};

/**
 * @param {?} obj
 * @param {string} path
 * @return {!Array<string>}
 */
Ember.beforeObserversFor = function(obj, path) {};

/**
 * @return {void}
 */
Ember.beginPropertyChanges = function() {};

/**
 * @param {?} obj
 * @param {string} to
 * @param {string} from
 * @return {!Ember.Binding}
 */
Ember.bind = function(obj, to, from) {};

/**
 * @param {?} obj
 * @param {string} key
 * @return {?}
 */
Ember.cacheFor = function(obj, key) {};

/**
 * @param {?} obj
 * @param {string} methodName
 * @return {boolean}
 */
Ember.canInvoke = function(obj, methodName) {};

/**
 * @param {!Function} callback
 * @param {?=} binding
 * @return {void}
 */
Ember.changeProperties = function(callback, binding) {};

/**
 * @param {?} v
 * @param {?} w
 * @return {number}
 */
Ember.compare = function(v, w) {};
 /** @type {?} */
Ember.computed;
 /** @type {!Object} */
Ember.config;

/**
 * @param {!Ember.Container} container
 * @param {string} controllerName
 * @param {!Object=} lookupOptions
 * @return {!Ember.Controller}
 */
Ember.controllerFor = function(container, controllerName, lookupOptions) {};

/**
 * @param {?} obj
 * @param {boolean} deep
 * @return {?}
 */
Ember.copy = function(obj, deep) {};

/**
 * Creates an instance of the CoreObject class.
 * @param {!Object=} tsickle_arguments
 * @return {!Ember.CoreObject}
 */
Ember.create = function(tsickle_arguments) {};

/**
 * @param {string} message
 * @return {void}
 */
Ember.debug = function(message) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @param {!Object} desc
 * @return {void}
 */
Ember.defineProperty = function(obj, keyName, desc) {};

/**
 * @param {string} message
 * @param {boolean=} test
 * @return {void}
 */
Ember.deprecate = function(message, test) {};

/**
 * @param {string} message
 * @param {!Function} func
 * @return {!Function}
 */
Ember.deprecateFunc = function(message, func) {};

/**
 * @param {?} obj
 * @return {void}
 */
Ember.destroy = function(obj) {};
 /** @type {function(string, !Function): !Function} */
Ember.empty;

/**
 * @return {void}
 */
Ember.endPropertyChanges = function() {};

/**
 * @param {?} obj
 * @return {void}
 */
Ember.finishChains = function(obj) {};

/**
 * @return {void}
 */
Ember.flushPendingChains = function() {};

/**
 * @param {!Ember.Container} container
 * @param {string} controllerName
 * @param {?} context
 * @return {!Ember.Controller}
 */
Ember.generateController = function(container, controllerName, context) {};

/**
 * @param {?} obj
 * @param {string=} prefix
 * @return {string}
 */
Ember.generateGuid = function(obj, prefix) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @return {?}
 */
Ember.get = function(obj, keyName) {};

/**
 * @param {?} obj
 * @param {string} property
 * @return {?}
 */
Ember.getMeta = function(obj, property) {};
 /** @type {function(string, !Function): !Function} */
Ember.getPath;

/**
 * @param {string} root
 * @param {string} key
 * @param {?} defaultValue
 * @return {?}
 */
Ember.getWithDefault = function(root, key, defaultValue) {};

/**
 * @param {?} obj
 * @return {string}
 */
Ember.guidFor = function(obj) {};

/**
 * @param {!Function} func
 * @param {?} context
 * @return {?}
 */
Ember.handleErrors = function(func, context) {};

/**
 * @param {?} context
 * @param {string} name
 * @return {boolean}
 */
Ember.hasListeners = function(context, name) {};

/**
 * @param {string} prop
 * @return {boolean}
 */
Ember.hasOwnProperty = function(prop) {};

/**
 * @param {!Function} func
 * @param {...?} propertyNames
 * @return {!Function}
 */
Ember.immediateObserver = function(func, propertyNames) {};
 /** @type {!Object} */
Ember.imports;

/**
 * @param {?} obj
 * @return {string}
 */
Ember.inspect = function(obj) {};

/**
 * @param {string} name
 * @param {?} payload
 * @param {!Function} callback
 * @param {?} binding
 * @return {void}
 */
Ember.instrument = function(name, payload, callback, binding) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.isArray = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.isEmpty = function(obj) {};

/**
 * @param {?} a
 * @param {?} b
 * @return {boolean}
 */
Ember.isEqual = function(a, b) {};

/**
 * @param {string} path
 * @return {boolean}
 */
Ember.isGlobalPath = function(path) {};
 /** @type {boolean} */
Ember.isNamespace;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.isNone = function(obj) {};

/**
 * @param {!Object} obj
 * @return {boolean}
 */
Ember.isPrototypeOf = function(obj) {};

/**
 * @param {?} obj
 * @param {string} key
 * @return {boolean}
 */
Ember.isWatching = function(obj, key) {};

/**
 * @param {?} obj
 * @return {!Array<?>}
 */
Ember.keys = function(obj) {};

/**
 * @param {?} obj
 * @param {string} eventName
 * @param {!Array<?>} otherActions
 * @return {!Array<?>}
 */
Ember.listenersDiff = function(obj, eventName, otherActions) {};

/**
 * @param {?} obj
 * @param {string} eventName
 * @return {!Array<?>}
 */
Ember.listenersFor = function(obj, eventName) {};

/**
 * @param {?} obj
 * @param {string} eventName
 * @param {!Array<?>} otherActions
 * @return {void}
 */
Ember.listenersUnion = function(obj, eventName, otherActions) {};
 /** @type {!Object} */
Ember.lookup;

/**
 * @param {?} obj
 * @return {!Array<?>}
 */
Ember.makeArray = function(obj) {};

/**
 * @param {?} original
 * @param {?} updates
 * @return {?}
 */
Ember.merge = function(original, updates) {};

/**
 * @param {?} obj
 * @param {boolean=} writable
 * @return {!Object}
 */
Ember.meta = function(obj, writable) {};

/**
 * @param {?} obj
 * @param {string} path
 * @param {boolean=} writable
 * @return {?}
 */
Ember.metaPath = function(obj, path, writable) {};

/**
 * @param {?} obj
 * @param {...?} args
 * @return {?}
 */
Ember.mixin = function(obj, args) {};
 /** @type {function(string, !Function): !Function} */
Ember.none;

/**
 * @param {?} target
 * @param {string} path
 * @return {!Array<?>}
 */
Ember.normalizeTuple = function(target, path) {};

/**
 * @param {...?} args
 * @return {!Function}
 */
Ember.observer = function(args) {};

/**
 * @param {?} obj
 * @param {string} path
 * @return {!Array<?>}
 */
Ember.observersFor = function(obj, path) {};

/**
 * @param {string} name
 * @param {!Function} callback
 * @return {void}
 */
Ember.onLoad = function(name, callback) {};

/**
 * @param {?} obj
 * @param {string} to
 * @param {string} from
 * @return {!Ember.Binding}
 */
Ember.oneWay = function(obj, to, from) {};
 /** @type {!Error} */
Ember.onError;

/**
 * @param {?} obj
 * @param {string} keyName
 * @param {?} m
 * @return {boolean}
 */
Ember.overrideChains = function(obj, keyName, m) {};
 /** @type {{addBeforeObserver: !ModifyObserver, addObserver: !ModifyObserver, defineProperty: function(?, string, !Object): void, removeBeforeObserver: !ModifyObserver, removeObserver: !ModifyObserver, hasPropertyAccessors: boolean}} */
Ember.platform;

/**
 * @param {?} obj
 * @param {string} keyName
 * @return {void}
 */
Ember.propertyDidChange = function(obj, keyName) {};

/**
 * @param {string} prop
 * @return {boolean}
 */
Ember.propertyIsEnumerable = function(prop) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @return {void}
 */
Ember.propertyWillChange = function(obj, keyName) {};

/**
 * @param {?} obj
 * @param {string} path
 * @param {?} target
 * @param {!Function} method
 * @return {?}
 */
Ember.removeBeforeObserver = function(obj, path, target, method) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @param {?} node
 * @return {void}
 */
Ember.removeChainWatcher = function(obj, keyName, node) {};

/**
 * @param {?} obj
 * @param {string} eventName
 * @param {?|!Function} target_or_func
 * @param {!Function|string} method
 * @return {void}
 */
Ember.removeListener = function(obj, eventName, target_or_func, method) {};

/**
 * @param {?} obj
 * @param {string} path
 * @param {?} target
 * @param {!Function} method
 * @return {?}
 */
Ember.removeObserver = function(obj, path, target, method) {};

/**
 * @return {!Ember.Descriptor}
 */
Ember.required = function() {};

/**
 * @param {?} obj
 * @return {void}
 */
Ember.rewatch = function(obj) {};
 /** @type {?} */
Ember.run;

/**
 * @param {string} name
 * @param {?} object
 * @return {void}
 */
Ember.runLoadHooks = function(name, object) {};

/**
 * @param {?} obj
 * @param {string} eventName
 * @param {!Array<?>=} params
 * @param {!Array<?>=} actions
 * @return {boolean}
 */
Ember.sendEvent = function(obj, eventName, params, actions) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @param {?} value
 * @return {?}
 */
Ember.set = function(obj, keyName, value) {};

/**
 * @param {?} obj
 * @param {string} property
 * @param {?} value
 * @return {void}
 */
Ember.setMeta = function(obj, property, value) {};
 /** @type {function(string, !Function): !Function} */
Ember.setPath;

/**
 * @param {?} self
 * @param {!Object} hash
 * @return {?}
 */
Ember.setProperties = function(self, hash) {};

/**
 * @param {string} pattern
 * @param {?} object
 * @return {void}
 */
Ember.subscribe = function(pattern, object) {};

/**
 * @return {string}
 */
Ember.toLocaleString = function() {};

/**
 * @return {string}
 */
Ember.toString = function() {};

/**
 * @param {!Function} tryable
 * @param {!Function} catchable
 * @param {!Function} finalizer
 * @param {?=} binding
 * @return {?}
 */
Ember.tryCatchFinally = function(tryable, catchable, finalizer, binding) {};

/**
 * @param {!Function} tryable
 * @param {!Function} finalizer
 * @param {?=} binding
 * @return {?}
 */
Ember.tryFinally = function(tryable, finalizer, binding) {};

/**
 * @param {?} obj
 * @param {string} methodName
 * @param {!Array<?>=} args
 * @return {?}
 */
Ember.tryInvoke = function(obj, methodName, args) {};

/**
 * @param {?} obj
 * @param {string} path
 * @param {?} value
 * @return {void}
 */
Ember.trySet = function(obj, path, value) {};
 /** @type {function(string, !Function): !Function} */
Ember.trySetPath;

/**
 * @param {?} item
 * @return {string}
 */
Ember.typeOf = function(item) {};

/**
 * @param {?} obj
 * @param {string} keyPath
 * @return {void}
 */
Ember.unwatch = function(obj, keyPath) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @return {void}
 */
Ember.unwatchKey = function(obj, keyName) {};

/**
 * @param {?} obj
 * @param {string} keyPath
 * @return {void}
 */
Ember.unwatchPath = function(obj, keyPath) {};
 /** @type {number} */
Ember.uuid;

/**
 * @return {!Object}
 */
Ember.valueOf = function() {};

/**
 * @param {string} message
 * @param {boolean=} test
 * @return {void}
 */
Ember.warn = function(message, test) {};

/**
 * @param {?} obj
 * @param {string} keyPath
 * @return {void}
 */
Ember.watch = function(obj, keyPath) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @return {void}
 */
Ember.watchKey = function(obj, keyName) {};

/**
 * @param {?} obj
 * @param {string} keyPath
 * @return {void}
 */
Ember.watchPath = function(obj, keyPath) {};

/**
 * @param {!Object} obj
 * @return {!Array<?>}
 */
Ember.watchedEvents = function(obj) {};

/**
 * @param {!Function} func
 * @param {!Function} superFunc
 * @return {!Function}
 */
Ember.wrap = function(func, superFunc) {};
/** @const */
var Em = {};
 /** @type {!JQueryStatic<!HTMLElement>} */
Em.$;
 /** @type {function(!Array<?>): !Ember.NativeArray} */
Em.A;
/**
 * @extends {Ember.ActionHandlerMixin}
 * @constructor
 * @struct
 */
Em.ActionHandlerMixin = function() {};
/**
 * @extends {Ember.Application}
 * @constructor
 * @struct
 */
Em.Application = function() {};
/**
 * @extends {Ember.Array}
 * @constructor
 * @struct
 */
Em.Array = function() {};
/**
 * @extends {Ember.ArrayController}
 * @constructor
 * @struct
 */
Em.ArrayController = function() {};
 /** @type {{map: !ItemIndexEnumerableCallbackTarget, forEach: function(!Function, ?): ?, indexOf: function(?, number): number}} */
Em.ArrayPolyfills;
/**
 * @extends {Ember.ArrayProxy}
 * @constructor
 * @struct
 */
Em.ArrayProxy = function() {};
 /** @type {boolean} */
Em.BOOTED;
/**
 * @extends {Ember.Binding}
 * @constructor
 * @struct
 */
Em.Binding = function() {};
/**
 * @extends {Ember.Button}
 * @constructor
 * @struct
 */
Em.Button = function() {};
/**
 * @extends {Ember.Checkbox}
 * @constructor
 * @struct
 */
Em.Checkbox = function() {};
/**
 * @extends {Ember.CollectionView}
 * @constructor
 * @struct
 */
Em.CollectionView = function() {};
/**
 * @extends {Ember.Comparable}
 * @constructor
 * @struct
 */
Em.Comparable = function() {};
/**
 * @extends {Ember.Component}
 * @constructor
 * @struct
 */
Em.Component = function() {};
/**
 * @extends {Ember.ComputedProperty}
 * @constructor
 * @struct
 */
Em.ComputedProperty = function() {};
/**
 * @extends {Ember.Container}
 * @constructor
 * @struct
 */
Em.Container = function() {};
/**
 * @extends {Ember.ContainerView}
 * @constructor
 * @struct
 */
Em.ContainerView = function() {};
/**
 * @extends {Ember.Controller}
 * @constructor
 * @struct
 */
Em.Controller = function() {};
/**
 * @extends {Ember.ControllerMixin}
 * @constructor
 * @struct
 */
Em.ControllerMixin = function() {};
/**
 * @extends {Ember.Copyable}
 * @constructor
 * @struct
 */
Em.Copyable = function() {};
/**
 * @extends {Ember.CoreObject}
 * @constructor
 * @struct
 */
Em.CoreObject = function() {};
/**
 * @extends {Ember.CoreView}
 * @constructor
 * @struct
 */
Em.CoreView = function() {};
/**
 * @extends {Ember.DAG}
 * @constructor
 * @struct
 */
Em.DAG = function() {};
 /** @type {function(string): !Function} */
Em.DEFAULT_GETTER_FUNCTION;
/**
 * @extends {Ember.DefaultResolver}
 * @constructor
 * @struct
 */
Em.DefaultResolver = function() {};
/**
 * @extends {Ember.Deferred}
 * @constructor
 * @struct
 */
Em.Deffered = function() {};
/**
 * @extends {Ember.DeferredMixin}
 * @constructor
 * @struct
 */
Em.DeferredMixin = function() {};
/**
 * @extends {Ember.Descriptor}
 * @constructor
 * @struct
 */
Em.Descriptor = function() {};
 /** @type {!Object} */
Em.EMPTY_META;
 /** @type {!Object} */
Em.ENV;
 /** @type {boolean} */
Em.EXTEND_PROTOTYPES;
/**
 * @extends {Ember.EachProxy}
 * @constructor
 * @struct
 */
Em.EachProxy = function() {};
/**
 * @extends {Ember.Enumerable}
 * @constructor
 * @struct
 */
Em.Enumerable = function() {};
 /** @type {!Object} */
Em.EnumerableUtils;
 /** @type {?} */
Em.Error;
/**
 * @extends {Ember.EventDispatcher}
 * @constructor
 * @struct
 */
Em.EventDispatcher = function() {};
/**
 * @extends {Ember.Evented}
 * @constructor
 * @struct
 */
Em.Evented = function() {};
 /** @type {string} */
Em.FROZEN_ERROR;
/**
 * @extends {Ember.Freezable}
 * @constructor
 * @struct
 */
Em.Freezable = function() {};
 /** @type {string} */
Em.GUID_KEY;
/** @const */
Em.Handlebars = {};
 /** @type {?} */
Em.Handlebars.compile;
 /** @type {function(?, string, !Object): ?} */
Em.Handlebars.get;
 /** @type {?} */
Em.Handlebars.helper;
/**
 * @extends {Ember.Handlebars.helpers}
 * @constructor
 * @struct
 */
Em.Handlebars.helpers = function() {};
 /** @type {function(string): void} */
Em.Handlebars.precompile;
 /** @type {function(string, !Function, string): void} */
Em.Handlebars.registerBoundHelper;
/**
 * @extends {Ember.Handlebars.Compiler}
 * @constructor
 * @struct
 */
Em.Handlebars.Compiler = function() {};
/**
 * @extends {Ember.Handlebars.JavaScriptCompiler}
 * @constructor
 * @struct
 */
Em.Handlebars.JavaScriptCompiler = function() {};
 /** @type {function(string, !Function, boolean): void} */
Em.Handlebars.registerHelper;
 /** @type {function(string, ?): void} */
Em.Handlebars.registerPartial;
 /** @type {function(): ?} */
Em.Handlebars.K;
 /** @type {function(?): ?} */
Em.Handlebars.createFrame;
 /** @type {function(string): void} */
Em.Handlebars.Exception;
/**
 * @extends {Ember.Handlebars.SafeString}
 * @constructor
 * @struct
 */
Em.Handlebars.SafeString = function() {};
 /** @type {function(string): ?} */
Em.Handlebars.parse;
 /** @type {function(?): void} */
Em.Handlebars.print;
 /** @type {{assert: function(?): void, debug: function(!Array<?>): void, error: function(!Array<?>): void, info: function(!Array<?>): void, log: function(!Array<?>): void, warn: function(!Array<?>): void}} */
Em.Handlebars.logger;
 /** @type {function(string, string): void} */
Em.Handlebars.log;
/**
 * @extends {Ember.HashLocation}
 * @constructor
 * @struct
 */
Em.HashLocation = function() {};
/**
 * @extends {Ember.HistoryLocation}
 * @constructor
 * @struct
 */
Em.HistoryLocation = function() {};
 /** @type {!RegExp} */
Em.IS_BINDING;
/**
 * @extends {Ember.Instrumentation}
 * @constructor
 * @struct
 */
Em.Instrumentation = function() {};
 /** @type {!Function} */
Em.K;
 /** @type {boolean} */
Em.LOG_BINDINGS;
 /** @type {boolean} */
Em.LOG_STACKTRACE_ON_DEPRECATION;
 /** @type {boolean} */
Em.LOG_VERSION;
/**
 * @extends {Ember.LinkView}
 * @constructor
 * @struct
 */
Em.LinkView = function() {};
/**
 * @extends {Ember.Location}
 * @constructor
 * @struct
 */
Em.Location = function() {};
 /** @type {{assert: function(?): void, debug: function(!Array<?>): void, error: function(!Array<?>): void, info: function(!Array<?>): void, log: function(!Array<?>): void, warn: function(!Array<?>): void}} */
Em.Logger;
 /** @type {function(string): void} */
Em.MANDATORY_SETTER_FUNCTION;
 /** @type {string} */
Em.META_KEY;
/**
 * @extends {Ember.Map}
 * @constructor
 * @struct
 */
Em.Map = function() {};
/**
 * @extends {Ember.MapWithDefault}
 * @constructor
 * @struct
 */
Em.MapWithDefault = function() {};
/**
 * @extends {Ember.Mixin}
 * @constructor
 * @struct
 */
Em.Mixin = function() {};
/**
 * @extends {Ember.MutableArray}
 * @constructor
 * @struct
 */
Em.MutableArray = function() {};
/**
 * @extends {Ember.MutableEnumberable}
 * @constructor
 * @struct
 */
Em.MutableEnumerable = function() {};
 /** @type {string} */
Em.NAME_KEY;
/**
 * @extends {Ember.Namespace}
 * @constructor
 * @struct
 */
Em.Namespace = function() {};
/**
 * @extends {Ember.NativeArray}
 * @constructor
 * @struct
 */
Em.NativeArray = function() {};
/**
 * @extends {Ember.NoneLocation}
 * @constructor
 * @struct
 */
Em.NoneLocation = function() {};
 /** @type {!Array<string>} */
Em.ORDER_DEFINITION;
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Em.Object = function() {};
/**
 * @extends {Ember.ObjectController}
 * @constructor
 * @struct
 */
Em.ObjectController = function() {};
/**
 * @extends {Ember.ObjectProxy}
 * @constructor
 * @struct
 */
Em.ObjectProxy = function() {};
/**
 * @extends {Ember.Observable}
 * @constructor
 * @struct
 */
Em.Observable = function() {};
/**
 * @extends {Ember.OrderedSet}
 * @constructor
 * @struct
 */
Em.OrderedSet = function() {};
/** @const */
Em.RSVP = {};
/**
 * @extends {Ember.RSVP.PromiseResolve}
 * @record
 * @struct
 */
Em.RSVP.PromiseResolve = function() {};
/**
 * @extends {Ember.RSVP.PromiseReject}
 * @record
 * @struct
 */
Em.RSVP.PromiseReject = function() {};
/**
 * @extends {Ember.RSVP.PromiseResolverFunction}
 * @record
 * @struct
 */
Em.RSVP.PromiseResolverFunction = function() {};
/**
 * @extends {Ember.RSVP.Promise}
 * @constructor
 * @struct
 */
Em.RSVP.Promise = function() {};
/**
 * @extends {Ember.RenderBuffer}
 * @constructor
 * @struct
 */
Em.RenderBuffer = function() {};
/**
 * @extends {Ember.Route}
 * @constructor
 * @struct
 */
Em.Route = function() {};
/**
 * @extends {Ember.Router}
 * @constructor
 * @struct
 */
Em.Router = function() {};
/**
 * @extends {Ember.RouterDSL}
 * @constructor
 * @struct
 */
Em.RouterDSL = function() {};
 /** @type {boolean} */
Em.SHIM_ES5;
 /** @type {boolean} */
Em.STRINGS;
/**
 * @extends {Ember.Select}
 * @constructor
 * @struct
 */
Em.Select = function() {};
/**
 * @extends {Ember.SelectOption}
 * @constructor
 * @struct
 */
Em.SelectOption = function() {};
/**
 * @extends {Ember.Set}
 * @constructor
 * @struct
 */
Em.Set = function() {};
/**
 * @extends {Ember.SortableMixin}
 * @constructor
 * @struct
 */
Em.SortableMixin = function() {};
/**
 * @extends {Ember.State}
 * @constructor
 * @struct
 */
Em.State = function() {};
/**
 * @extends {Ember.StateManager}
 * @constructor
 * @struct
 */
Em.StateManager = function() {};
/** @const */
Em.String = {};
 /** @type {function(string): string} */
Em.String.camelize;
 /** @type {function(string): string} */
Em.String.capitalize;
 /** @type {function(string): string} */
Em.String.classify;
 /** @type {function(string): string} */
Em.String.dasherize;
 /** @type {function(string): string} */
Em.String.decamelize;
 /** @type {function(!Array<string>): string} */
Em.String.fmt;
 /** @type {function(string): void} */
Em.String.htmlSafe;
 /** @type {function(!Array<string>): string} */
Em.String.loc;
 /** @type {function(string): string} */
Em.String.underscore;
 /** @type {function(string): !Array<string>} */
Em.String.w;
 /** @type {!Object} */
Em.TEMPLATES;
/**
 * @extends {Ember.TargetActionSupport}
 * @constructor
 * @struct
 */
Em.TargetActionSupport = function() {};
/**
 * @extends {Ember.Test}
 * @constructor
 * @struct
 */
Em.Test = function() {};
/**
 * @extends {Ember.TextArea}
 * @constructor
 * @struct
 */
Em.TextArea = function() {};
/**
 * @extends {Ember.TextField}
 * @constructor
 * @struct
 */
Em.TextField = function() {};
/**
 * @extends {Ember.TextSupport}
 * @constructor
 * @struct
 */
Em.TextSupport = function() {};
 /** @type {string} */
Em.VERSION;
/**
 * @extends {Ember.View}
 * @constructor
 * @struct
 */
Em.View = function() {};
/**
 * @extends {Ember.ViewTargetActionSupport}
 * @constructor
 * @struct
 */
Em.ViewTargetActionSupport = function() {};
 /** @type {!Object} */
Em.ViewUtils;
 /** @type {function(?, string, ?, !Function): ?} */
Em.addBeforeObserver;
 /** @type {?} */
Em.addListener;
 /** @type {!ModifyObserver} */
Em.addObserver;
 /** @type {function(string, !Function): !Function} */
Em.alias;
 /** @type {function(string): !Ember.Descriptor} */
Em.aliasMethod;
 /** @type {boolean} */
Em.anyUnprocessedMixins;
 /** @type {function(string, boolean): void} */
Em.assert;
 /** @type {function(!Function, string): !Function} */
Em.beforeObserver;
 /** @type {function(?, string): !Array<string>} */
Em.beforeObserversFor;
 /** @type {function(): void} */
Em.beginPropertyChanges;
 /** @type {function(?, string, string): !Ember.Binding} */
Em.bind;
 /** @type {function(?, string): ?} */
Em.cacheFor;
 /** @type {function(?, string): boolean} */
Em.canInvoke;
 /** @type {function(!Function, ?): void} */
Em.changeProperties;
 /** @type {function(?, ?): number} */
Em.compare;
 /** @type {?} */
Em.computed;
 /** @type {!Object} */
Em.config;
 /** @type {function(!Ember.Container, string, !Object): !Ember.Controller} */
Em.controllerFor;
 /** @type {function(?, boolean): ?} */
Em.copy;
 /** @type {function(!Object): !Ember.CoreObject} */
Em.create;
 /** @type {function(string): void} */
Em.debug;
 /** @type {function(?, string, !Object): void} */
Em.defineProperty;
 /** @type {function(string, boolean): void} */
Em.deprecate;
 /** @type {function(string, !Function): !Function} */
Em.deprecateFunc;
 /** @type {function(?): void} */
Em.destroy;
 /** @type {function(string, !Function): !Function} */
Em.empty;
 /** @type {function(): void} */
Em.endPropertyChanges;
 /** @type {function(?): void} */
Em.finishChains;
 /** @type {function(): void} */
Em.flushPendingChains;
 /** @type {function(!Ember.Container, string, ?): !Ember.Controller} */
Em.generateController;
 /** @type {function(?, string): string} */
Em.generateGuid;
 /** @type {function(?, string): ?} */
Em.get;
 /** @type {function(?, string): ?} */
Em.getMeta;
 /** @type {function(string, !Function): !Function} */
Em.getPath;
 /** @type {function(string, string, ?): ?} */
Em.getWithDefault;
 /** @type {function(?): string} */
Em.guidFor;
 /** @type {function(!Function, ?): ?} */
Em.handleErrors;
 /** @type {function(?, string): boolean} */
Em.hasListeners;
 /** @type {function(string): boolean} */
Em.hasOwnProperty;
 /** @type {function(!Function, !Array<?>): !Function} */
Em.immediateObserver;
 /** @type {!Object} */
Em.imports;
 /** @type {function(?): string} */
Em.inspect;
 /** @type {function(string, ?, !Function, ?): void} */
Em.instrument;
 /** @type {function(?): boolean} */
Em.isArray;
 /** @type {function(?): boolean} */
Em.isEmpty;
 /** @type {function(?, ?): boolean} */
Em.isEqual;
 /** @type {function(string): boolean} */
Em.isGlobalPath;
 /** @type {boolean} */
Em.isNamespace;
 /** @type {function(?): boolean} */
Em.isNone;
 /** @type {function(!Object): boolean} */
Em.isPrototypeOf;
 /** @type {function(?, string): boolean} */
Em.isWatching;
 /** @type {function(?): !Array<?>} */
Em.keys;
 /** @type {function(?, string, !Array<?>): !Array<?>} */
Em.listenersDiff;
 /** @type {function(?, string): !Array<?>} */
Em.listenersFor;
 /** @type {function(?, string, !Array<?>): void} */
Em.listenersUnion;
 /** @type {!Object} */
Em.lookup;
 /** @type {function(?): !Array<?>} */
Em.makeArray;
 /** @type {function(?, ?): ?} */
Em.merge;
 /** @type {function(?, boolean): !Object} */
Em.meta;
 /** @type {function(?, string, boolean): ?} */
Em.metaPath;
 /** @type {function(?, !Array<?>): ?} */
Em.mixin;
 /** @type {function(string, !Function): !Function} */
Em.none;
 /** @type {function(?, string): !Array<?>} */
Em.normalizeTuple;
 /** @type {function(!Array<?>): !Function} */
Em.observer;
 /** @type {function(?, string): !Array<?>} */
Em.observersFor;
 /** @type {function(string, !Function): void} */
Em.onLoad;
 /** @type {function(?, string, string): !Ember.Binding} */
Em.oneWay;
 /** @type {!Error} */
Em.onError;
 /** @type {function(?, string, ?): boolean} */
Em.overrideChains;
 /** @type {{addBeforeObserver: !ModifyObserver, addObserver: !ModifyObserver, defineProperty: function(?, string, !Object): void, removeBeforeObserver: !ModifyObserver, removeObserver: !ModifyObserver, hasPropertyAccessors: boolean}} */
Em.platform;
 /** @type {function(?, string): void} */
Em.propertyDidChange;
 /** @type {function(string): boolean} */
Em.propertyIsEnumerable;
 /** @type {function(?, string): void} */
Em.propertyWillChange;
 /** @type {function(?, string, ?, !Function): ?} */
Em.removeBeforeObserver;
 /** @type {function(?, string, ?): void} */
Em.removeChainWatcher;
 /** @type {?} */
Em.removeListener;
 /** @type {function(?, string, ?, !Function): ?} */
Em.removeObserver;
 /** @type {function(): !Ember.Descriptor} */
Em.required;
 /** @type {function(?): void} */
Em.rewatch;
 /** @type {?} */
Em.run;
 /** @type {function(string, ?): void} */
Em.runLoadHooks;
 /** @type {function(?, string, !Array<?>, !Array<?>): boolean} */
Em.sendEvent;
 /** @type {function(?, string, ?): ?} */
Em.set;
 /** @type {function(?, string, ?): void} */
Em.setMeta;
 /** @type {function(string, !Function): !Function} */
Em.setPath;
 /** @type {function(?, !Object): ?} */
Em.setProperties;
 /** @type {function(string, ?): void} */
Em.subscribe;
 /** @type {function(): string} */
Em.toLocaleString;
 /** @type {function(): string} */
Em.toString;
 /** @type {function(!Function, !Function, !Function, ?): ?} */
Em.tryCatchFinally;
 /** @type {function(!Function, !Function, ?): ?} */
Em.tryFinally;
 /** @type {function(?, string, !Array<?>): ?} */
Em.tryInvoke;
 /** @type {function(?, string, ?): void} */
Em.trySet;
 /** @type {function(string, !Function): !Function} */
Em.trySetPath;
 /** @type {function(?): string} */
Em.typeOf;
 /** @type {function(?, string): void} */
Em.unwatch;
 /** @type {function(?, string): void} */
Em.unwatchKey;
 /** @type {function(?, string): void} */
Em.unwatchPath;
 /** @type {number} */
Em.uuid;
 /** @type {function(): !Object} */
Em.valueOf;
 /** @type {function(string, boolean): void} */
Em.warn;
 /** @type {function(?, string): void} */
Em.watch;
 /** @type {function(?, string): void} */
Em.watchKey;
 /** @type {function(?, string): void} */
Em.watchPath;
 /** @type {function(!Object): !Array<?>} */
Em.watchedEvents;
 /** @type {function(!Function, !Function): !Function} */
Em.wrap;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "Ember"
/** @const */
tsickle_declare_module.Ember = {};
 /** @type {!JQueryStatic<!HTMLElement>} */
tsickle_declare_module.Ember.$;
 /** @type {function(!Array<?>): !Ember.NativeArray} */
tsickle_declare_module.Ember.A;
/**
 * @extends {Ember.ActionHandlerMixin}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.ActionHandlerMixin = function() {};
/**
 * @extends {Ember.Application}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Application = function() {};
/**
 * @extends {Ember.Array}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Array = function() {};
/**
 * @extends {Ember.ArrayController}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.ArrayController = function() {};
 /** @type {{map: !ItemIndexEnumerableCallbackTarget, forEach: function(!Function, ?): ?, indexOf: function(?, number): number}} */
tsickle_declare_module.Ember.ArrayPolyfills;
/**
 * @extends {Ember.ArrayProxy}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.ArrayProxy = function() {};
 /** @type {boolean} */
tsickle_declare_module.Ember.BOOTED;
/**
 * @extends {Ember.Binding}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Binding = function() {};
/**
 * @extends {Ember.Button}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Button = function() {};
/**
 * @extends {Ember.Checkbox}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Checkbox = function() {};
/**
 * @extends {Ember.CollectionView}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.CollectionView = function() {};
/**
 * @extends {Ember.Comparable}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Comparable = function() {};
/**
 * @extends {Ember.Component}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Component = function() {};
/**
 * @extends {Ember.ComputedProperty}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.ComputedProperty = function() {};
/**
 * @extends {Ember.Container}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Container = function() {};
/**
 * @extends {Ember.ContainerView}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.ContainerView = function() {};
/**
 * @extends {Ember.Controller}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Controller = function() {};
/**
 * @extends {Ember.ControllerMixin}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.ControllerMixin = function() {};
/**
 * @extends {Ember.Copyable}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Copyable = function() {};
/**
 * @extends {Ember.CoreObject}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.CoreObject = function() {};
/**
 * @extends {Ember.CoreView}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.CoreView = function() {};
/**
 * @extends {Ember.DAG}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.DAG = function() {};
 /** @type {function(string): !Function} */
tsickle_declare_module.Ember.DEFAULT_GETTER_FUNCTION;
/**
 * @extends {Ember.DefaultResolver}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.DefaultResolver = function() {};
/**
 * @extends {Ember.Deferred}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Deffered = function() {};
/**
 * @extends {Ember.DeferredMixin}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.DeferredMixin = function() {};
/**
 * @extends {Ember.Descriptor}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Descriptor = function() {};
 /** @type {!Object} */
tsickle_declare_module.Ember.EMPTY_META;
 /** @type {!Object} */
tsickle_declare_module.Ember.ENV;
 /** @type {boolean} */
tsickle_declare_module.Ember.EXTEND_PROTOTYPES;
/**
 * @extends {Ember.EachProxy}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.EachProxy = function() {};
/**
 * @extends {Ember.Enumerable}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Enumerable = function() {};
 /** @type {!Object} */
tsickle_declare_module.Ember.EnumerableUtils;
 /** @type {?} */
tsickle_declare_module.Ember.Error;
/**
 * @extends {Ember.EventDispatcher}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.EventDispatcher = function() {};
/**
 * @extends {Ember.Evented}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Evented = function() {};
 /** @type {string} */
tsickle_declare_module.Ember.FROZEN_ERROR;
/**
 * @extends {Ember.Freezable}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Freezable = function() {};
 /** @type {string} */
tsickle_declare_module.Ember.GUID_KEY;
/** @const */
tsickle_declare_module.Ember.Handlebars = {};
 /** @type {?} */
tsickle_declare_module.Ember.Handlebars.compile;
 /** @type {function(?, string, !Object): ?} */
tsickle_declare_module.Ember.Handlebars.get;
 /** @type {?} */
tsickle_declare_module.Ember.Handlebars.helper;
/**
 * @extends {Ember.Handlebars.helpers}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Handlebars.helpers = function() {};
 /** @type {function(string): void} */
tsickle_declare_module.Ember.Handlebars.precompile;
 /** @type {function(string, !Function, string): void} */
tsickle_declare_module.Ember.Handlebars.registerBoundHelper;
/**
 * @extends {Ember.Handlebars.Compiler}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Handlebars.Compiler = function() {};
/**
 * @extends {Ember.Handlebars.JavaScriptCompiler}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Handlebars.JavaScriptCompiler = function() {};
 /** @type {function(string, !Function, boolean): void} */
tsickle_declare_module.Ember.Handlebars.registerHelper;
 /** @type {function(string, ?): void} */
tsickle_declare_module.Ember.Handlebars.registerPartial;
 /** @type {function(): ?} */
tsickle_declare_module.Ember.Handlebars.K;
 /** @type {function(?): ?} */
tsickle_declare_module.Ember.Handlebars.createFrame;
 /** @type {function(string): void} */
tsickle_declare_module.Ember.Handlebars.Exception;
/**
 * @extends {Ember.Handlebars.SafeString}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Handlebars.SafeString = function() {};
 /** @type {function(string): ?} */
tsickle_declare_module.Ember.Handlebars.parse;
 /** @type {function(?): void} */
tsickle_declare_module.Ember.Handlebars.print;
 /** @type {{assert: function(?): void, debug: function(!Array<?>): void, error: function(!Array<?>): void, info: function(!Array<?>): void, log: function(!Array<?>): void, warn: function(!Array<?>): void}} */
tsickle_declare_module.Ember.Handlebars.logger;
 /** @type {function(string, string): void} */
tsickle_declare_module.Ember.Handlebars.log;
/**
 * @extends {Ember.HashLocation}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.HashLocation = function() {};
/**
 * @extends {Ember.HistoryLocation}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.HistoryLocation = function() {};
 /** @type {!RegExp} */
tsickle_declare_module.Ember.IS_BINDING;
/**
 * @extends {Ember.Instrumentation}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Instrumentation = function() {};
 /** @type {!Function} */
tsickle_declare_module.Ember.K;
 /** @type {boolean} */
tsickle_declare_module.Ember.LOG_BINDINGS;
 /** @type {boolean} */
tsickle_declare_module.Ember.LOG_STACKTRACE_ON_DEPRECATION;
 /** @type {boolean} */
tsickle_declare_module.Ember.LOG_VERSION;
/**
 * @extends {Ember.LinkView}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.LinkView = function() {};
/**
 * @extends {Ember.Location}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Location = function() {};
 /** @type {{assert: function(?): void, debug: function(!Array<?>): void, error: function(!Array<?>): void, info: function(!Array<?>): void, log: function(!Array<?>): void, warn: function(!Array<?>): void}} */
tsickle_declare_module.Ember.Logger;
 /** @type {function(string): void} */
tsickle_declare_module.Ember.MANDATORY_SETTER_FUNCTION;
 /** @type {string} */
tsickle_declare_module.Ember.META_KEY;
/**
 * @extends {Ember.Map}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Map = function() {};
/**
 * @extends {Ember.MapWithDefault}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.MapWithDefault = function() {};
/**
 * @extends {Ember.Mixin}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Mixin = function() {};
/**
 * @extends {Ember.MutableArray}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.MutableArray = function() {};
/**
 * @extends {Ember.MutableEnumberable}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.MutableEnumerable = function() {};
 /** @type {string} */
tsickle_declare_module.Ember.NAME_KEY;
/**
 * @extends {Ember.Namespace}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Namespace = function() {};
/**
 * @extends {Ember.NativeArray}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.NativeArray = function() {};
/**
 * @extends {Ember.NoneLocation}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.NoneLocation = function() {};
 /** @type {!Array<string>} */
tsickle_declare_module.Ember.ORDER_DEFINITION;
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Object = function() {};
/**
 * @extends {Ember.ObjectController}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.ObjectController = function() {};
/**
 * @extends {Ember.ObjectProxy}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.ObjectProxy = function() {};
/**
 * @extends {Ember.Observable}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Observable = function() {};
/**
 * @extends {Ember.OrderedSet}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.OrderedSet = function() {};
/** @const */
tsickle_declare_module.Ember.RSVP = {};
/**
 * @extends {Ember.RSVP.PromiseResolve}
 * @record
 * @struct
 */
tsickle_declare_module.Ember.RSVP.PromiseResolve = function() {};
/**
 * @extends {Ember.RSVP.PromiseReject}
 * @record
 * @struct
 */
tsickle_declare_module.Ember.RSVP.PromiseReject = function() {};
/**
 * @extends {Ember.RSVP.PromiseResolverFunction}
 * @record
 * @struct
 */
tsickle_declare_module.Ember.RSVP.PromiseResolverFunction = function() {};
/**
 * @extends {Ember.RSVP.Promise}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.RSVP.Promise = function() {};
/**
 * @extends {Ember.RenderBuffer}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.RenderBuffer = function() {};
/**
 * @extends {Ember.Route}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Route = function() {};
/**
 * @extends {Ember.Router}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Router = function() {};
/**
 * @extends {Ember.RouterDSL}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.RouterDSL = function() {};
 /** @type {boolean} */
tsickle_declare_module.Ember.SHIM_ES5;
 /** @type {boolean} */
tsickle_declare_module.Ember.STRINGS;
/**
 * @extends {Ember.Select}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Select = function() {};
/**
 * @extends {Ember.SelectOption}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.SelectOption = function() {};
/**
 * @extends {Ember.Set}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Set = function() {};
/**
 * @extends {Ember.SortableMixin}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.SortableMixin = function() {};
/**
 * @extends {Ember.State}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.State = function() {};
/**
 * @extends {Ember.StateManager}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.StateManager = function() {};
/** @const */
tsickle_declare_module.Ember.String = {};
 /** @type {function(string): string} */
tsickle_declare_module.Ember.String.camelize;
 /** @type {function(string): string} */
tsickle_declare_module.Ember.String.capitalize;
 /** @type {function(string): string} */
tsickle_declare_module.Ember.String.classify;
 /** @type {function(string): string} */
tsickle_declare_module.Ember.String.dasherize;
 /** @type {function(string): string} */
tsickle_declare_module.Ember.String.decamelize;
 /** @type {function(!Array<string>): string} */
tsickle_declare_module.Ember.String.fmt;
 /** @type {function(string): void} */
tsickle_declare_module.Ember.String.htmlSafe;
 /** @type {function(!Array<string>): string} */
tsickle_declare_module.Ember.String.loc;
 /** @type {function(string): string} */
tsickle_declare_module.Ember.String.underscore;
 /** @type {function(string): !Array<string>} */
tsickle_declare_module.Ember.String.w;
 /** @type {!Object} */
tsickle_declare_module.Ember.TEMPLATES;
/**
 * @extends {Ember.TargetActionSupport}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.TargetActionSupport = function() {};
/**
 * @extends {Ember.Test}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.Test = function() {};
/**
 * @extends {Ember.TextArea}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.TextArea = function() {};
/**
 * @extends {Ember.TextField}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.TextField = function() {};
/**
 * @extends {Ember.TextSupport}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.TextSupport = function() {};
 /** @type {string} */
tsickle_declare_module.Ember.VERSION;
/**
 * @extends {Ember.View}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.View = function() {};
/**
 * @extends {Ember.ViewTargetActionSupport}
 * @constructor
 * @struct
 */
tsickle_declare_module.Ember.ViewTargetActionSupport = function() {};
 /** @type {!Object} */
tsickle_declare_module.Ember.ViewUtils;
 /** @type {function(?, string, ?, !Function): ?} */
tsickle_declare_module.Ember.addBeforeObserver;
 /** @type {?} */
tsickle_declare_module.Ember.addListener;
 /** @type {!ModifyObserver} */
tsickle_declare_module.Ember.addObserver;
 /** @type {function(string, !Function): !Function} */
tsickle_declare_module.Ember.alias;
 /** @type {function(string): !Ember.Descriptor} */
tsickle_declare_module.Ember.aliasMethod;
 /** @type {boolean} */
tsickle_declare_module.Ember.anyUnprocessedMixins;
 /** @type {function(string, boolean): void} */
tsickle_declare_module.Ember.assert;
 /** @type {function(!Function, string): !Function} */
tsickle_declare_module.Ember.beforeObserver;
 /** @type {function(?, string): !Array<string>} */
tsickle_declare_module.Ember.beforeObserversFor;
 /** @type {function(): void} */
tsickle_declare_module.Ember.beginPropertyChanges;
 /** @type {function(?, string, string): !Ember.Binding} */
tsickle_declare_module.Ember.bind;
 /** @type {function(?, string): ?} */
tsickle_declare_module.Ember.cacheFor;
 /** @type {function(?, string): boolean} */
tsickle_declare_module.Ember.canInvoke;
 /** @type {function(!Function, ?): void} */
tsickle_declare_module.Ember.changeProperties;
 /** @type {function(?, ?): number} */
tsickle_declare_module.Ember.compare;
 /** @type {?} */
tsickle_declare_module.Ember.computed;
 /** @type {!Object} */
tsickle_declare_module.Ember.config;
 /** @type {function(!Ember.Container, string, !Object): !Ember.Controller} */
tsickle_declare_module.Ember.controllerFor;
 /** @type {function(?, boolean): ?} */
tsickle_declare_module.Ember.copy;
 /** @type {function(!Object): !Ember.CoreObject} */
tsickle_declare_module.Ember.create;
 /** @type {function(string): void} */
tsickle_declare_module.Ember.debug;
 /** @type {function(?, string, !Object): void} */
tsickle_declare_module.Ember.defineProperty;
 /** @type {function(string, boolean): void} */
tsickle_declare_module.Ember.deprecate;
 /** @type {function(string, !Function): !Function} */
tsickle_declare_module.Ember.deprecateFunc;
 /** @type {function(?): void} */
tsickle_declare_module.Ember.destroy;
 /** @type {function(string, !Function): !Function} */
tsickle_declare_module.Ember.empty;
 /** @type {function(): void} */
tsickle_declare_module.Ember.endPropertyChanges;
 /** @type {function(?): void} */
tsickle_declare_module.Ember.finishChains;
 /** @type {function(): void} */
tsickle_declare_module.Ember.flushPendingChains;
 /** @type {function(!Ember.Container, string, ?): !Ember.Controller} */
tsickle_declare_module.Ember.generateController;
 /** @type {function(?, string): string} */
tsickle_declare_module.Ember.generateGuid;
 /** @type {function(?, string): ?} */
tsickle_declare_module.Ember.get;
 /** @type {function(?, string): ?} */
tsickle_declare_module.Ember.getMeta;
 /** @type {function(string, !Function): !Function} */
tsickle_declare_module.Ember.getPath;
 /** @type {function(string, string, ?): ?} */
tsickle_declare_module.Ember.getWithDefault;
 /** @type {function(?): string} */
tsickle_declare_module.Ember.guidFor;
 /** @type {function(!Function, ?): ?} */
tsickle_declare_module.Ember.handleErrors;
 /** @type {function(?, string): boolean} */
tsickle_declare_module.Ember.hasListeners;
 /** @type {function(string): boolean} */
tsickle_declare_module.Ember.hasOwnProperty;
 /** @type {function(!Function, !Array<?>): !Function} */
tsickle_declare_module.Ember.immediateObserver;
 /** @type {!Object} */
tsickle_declare_module.Ember.imports;
 /** @type {function(?): string} */
tsickle_declare_module.Ember.inspect;
 /** @type {function(string, ?, !Function, ?): void} */
tsickle_declare_module.Ember.instrument;
 /** @type {function(?): boolean} */
tsickle_declare_module.Ember.isArray;
 /** @type {function(?): boolean} */
tsickle_declare_module.Ember.isEmpty;
 /** @type {function(?, ?): boolean} */
tsickle_declare_module.Ember.isEqual;
 /** @type {function(string): boolean} */
tsickle_declare_module.Ember.isGlobalPath;
 /** @type {boolean} */
tsickle_declare_module.Ember.isNamespace;
 /** @type {function(?): boolean} */
tsickle_declare_module.Ember.isNone;
 /** @type {function(!Object): boolean} */
tsickle_declare_module.Ember.isPrototypeOf;
 /** @type {function(?, string): boolean} */
tsickle_declare_module.Ember.isWatching;
 /** @type {function(?): !Array<?>} */
tsickle_declare_module.Ember.keys;
 /** @type {function(?, string, !Array<?>): !Array<?>} */
tsickle_declare_module.Ember.listenersDiff;
 /** @type {function(?, string): !Array<?>} */
tsickle_declare_module.Ember.listenersFor;
 /** @type {function(?, string, !Array<?>): void} */
tsickle_declare_module.Ember.listenersUnion;
 /** @type {!Object} */
tsickle_declare_module.Ember.lookup;
 /** @type {function(?): !Array<?>} */
tsickle_declare_module.Ember.makeArray;
 /** @type {function(?, ?): ?} */
tsickle_declare_module.Ember.merge;
 /** @type {function(?, boolean): !Object} */
tsickle_declare_module.Ember.meta;
 /** @type {function(?, string, boolean): ?} */
tsickle_declare_module.Ember.metaPath;
 /** @type {function(?, !Array<?>): ?} */
tsickle_declare_module.Ember.mixin;
 /** @type {function(string, !Function): !Function} */
tsickle_declare_module.Ember.none;
 /** @type {function(?, string): !Array<?>} */
tsickle_declare_module.Ember.normalizeTuple;
 /** @type {function(!Array<?>): !Function} */
tsickle_declare_module.Ember.observer;
 /** @type {function(?, string): !Array<?>} */
tsickle_declare_module.Ember.observersFor;
 /** @type {function(string, !Function): void} */
tsickle_declare_module.Ember.onLoad;
 /** @type {function(?, string, string): !Ember.Binding} */
tsickle_declare_module.Ember.oneWay;
 /** @type {!Error} */
tsickle_declare_module.Ember.onError;
 /** @type {function(?, string, ?): boolean} */
tsickle_declare_module.Ember.overrideChains;
 /** @type {{addBeforeObserver: !ModifyObserver, addObserver: !ModifyObserver, defineProperty: function(?, string, !Object): void, removeBeforeObserver: !ModifyObserver, removeObserver: !ModifyObserver, hasPropertyAccessors: boolean}} */
tsickle_declare_module.Ember.platform;
 /** @type {function(?, string): void} */
tsickle_declare_module.Ember.propertyDidChange;
 /** @type {function(string): boolean} */
tsickle_declare_module.Ember.propertyIsEnumerable;
 /** @type {function(?, string): void} */
tsickle_declare_module.Ember.propertyWillChange;
 /** @type {function(?, string, ?, !Function): ?} */
tsickle_declare_module.Ember.removeBeforeObserver;
 /** @type {function(?, string, ?): void} */
tsickle_declare_module.Ember.removeChainWatcher;
 /** @type {?} */
tsickle_declare_module.Ember.removeListener;
 /** @type {function(?, string, ?, !Function): ?} */
tsickle_declare_module.Ember.removeObserver;
 /** @type {function(): !Ember.Descriptor} */
tsickle_declare_module.Ember.required;
 /** @type {function(?): void} */
tsickle_declare_module.Ember.rewatch;
 /** @type {?} */
tsickle_declare_module.Ember.run;
 /** @type {function(string, ?): void} */
tsickle_declare_module.Ember.runLoadHooks;
 /** @type {function(?, string, !Array<?>, !Array<?>): boolean} */
tsickle_declare_module.Ember.sendEvent;
 /** @type {function(?, string, ?): ?} */
tsickle_declare_module.Ember.set;
 /** @type {function(?, string, ?): void} */
tsickle_declare_module.Ember.setMeta;
 /** @type {function(string, !Function): !Function} */
tsickle_declare_module.Ember.setPath;
 /** @type {function(?, !Object): ?} */
tsickle_declare_module.Ember.setProperties;
 /** @type {function(string, ?): void} */
tsickle_declare_module.Ember.subscribe;
 /** @type {function(): string} */
tsickle_declare_module.Ember.toLocaleString;
 /** @type {function(): string} */
tsickle_declare_module.Ember.toString;
 /** @type {function(!Function, !Function, !Function, ?): ?} */
tsickle_declare_module.Ember.tryCatchFinally;
 /** @type {function(!Function, !Function, ?): ?} */
tsickle_declare_module.Ember.tryFinally;
 /** @type {function(?, string, !Array<?>): ?} */
tsickle_declare_module.Ember.tryInvoke;
 /** @type {function(?, string, ?): void} */
tsickle_declare_module.Ember.trySet;
 /** @type {function(string, !Function): !Function} */
tsickle_declare_module.Ember.trySetPath;
 /** @type {function(?): string} */
tsickle_declare_module.Ember.typeOf;
 /** @type {function(?, string): void} */
tsickle_declare_module.Ember.unwatch;
 /** @type {function(?, string): void} */
tsickle_declare_module.Ember.unwatchKey;
 /** @type {function(?, string): void} */
tsickle_declare_module.Ember.unwatchPath;
 /** @type {number} */
tsickle_declare_module.Ember.uuid;
 /** @type {function(): !Object} */
tsickle_declare_module.Ember.valueOf;
 /** @type {function(string, boolean): void} */
tsickle_declare_module.Ember.warn;
 /** @type {function(?, string): void} */
tsickle_declare_module.Ember.watch;
 /** @type {function(?, string): void} */
tsickle_declare_module.Ember.watchKey;
 /** @type {function(?, string): void} */
tsickle_declare_module.Ember.watchPath;
 /** @type {function(!Object): !Array<?>} */
tsickle_declare_module.Ember.watchedEvents;
 /** @type {function(!Function, !Function): !Function} */
tsickle_declare_module.Ember.wrap;
