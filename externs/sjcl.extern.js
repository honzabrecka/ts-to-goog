/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/sjcl/index.d.ts:

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
/** @const */
var sjcl = {};
 /** @type {!sjcl.BigNumberStatic} */
sjcl.bn;
 /** @type {!sjcl.BitArrayStatic} */
sjcl.bitArray;
 /** @type {!sjcl.SjclCodecs} */
sjcl.codec;
 /** @type {!sjcl.SjclHashes} */
sjcl.hash;
 /** @type {!sjcl.SjclExceptions} */
sjcl.exception;
 /** @type {!sjcl.SjclCiphers} */
sjcl.cipher;
 /** @type {!sjcl.SjclModes} */
sjcl.mode;
 /** @type {!sjcl.SjclMisc} */
sjcl.misc;
 /** @type {!sjcl.SjclEllipticCurveCryptography} */
sjcl.ecc;
 /** @type {!sjcl.SjclRandom} */
sjcl.random;
 /** @type {!sjcl.SjclRandomStatic} */
sjcl.prng;
 /** @type {!sjcl.SjclKeyExchange} */
sjcl.keyexchange;
 /** @type {!sjcl.SjclJson} */
sjcl.json;
 /** @type {!sjcl.SjclConveninceEncryptor} */
sjcl.encrypt;
 /** @type {!sjcl.SjclConveninceDecryptor} */
sjcl.decrypt;
/**
 * @record
 * @struct
 */
sjcl.BigNumber = function() {};
 /** @type {number} */
sjcl.BigNumber.prototype.radix;
 /** @type {number} */
sjcl.BigNumber.prototype.maxMul;
 /** @type {!sjcl.TypeHelpers.BigNumberBinaryOperator} */
sjcl.BigNumber.prototype.initWith;
 /** @type {!sjcl.TypeHelpers.BigNumberBinaryOperator} */
sjcl.BigNumber.prototype.addM;
 /** @type {!sjcl.TypeHelpers.BigNumberBinaryOperator} */
sjcl.BigNumber.prototype.subM;
 /** @type {!sjcl.TypeHelpers.BigNumberBinaryOperator} */
sjcl.BigNumber.prototype.mod;
 /** @type {!sjcl.TypeHelpers.BigNumberBinaryOperator} */
sjcl.BigNumber.prototype.inverseMod;
 /** @type {!sjcl.TypeHelpers.BigNumberBinaryOperator} */
sjcl.BigNumber.prototype.add;
 /** @type {!sjcl.TypeHelpers.BigNumberBinaryOperator} */
sjcl.BigNumber.prototype.sub;
 /** @type {!sjcl.TypeHelpers.BigNumberBinaryOperator} */
sjcl.BigNumber.prototype.mul;
 /** @type {!sjcl.TypeHelpers.BigNumberTrinaryOperator} */
sjcl.BigNumber.prototype.mulmod;
 /** @type {!sjcl.TypeHelpers.BigNumberTrinaryOperator} */
sjcl.BigNumber.prototype.powermod;

/**
 * @return {!sjcl.BigNumber}
 */
sjcl.BigNumber.prototype.copy = function() {};

/**
 * @param {number|!sjcl.BigNumber} that
 * @return {boolean}
 */
sjcl.BigNumber.prototype.equals = function(that) {};

/**
 * @param {number} index
 * @return {number}
 */
sjcl.BigNumber.prototype.getLimb = function(index) {};

/**
 * @param {number|!sjcl.BigNumber} that
 * @return {boolean}
 */
sjcl.BigNumber.prototype.greaterEquals = function(that) {};

/**
 * @return {string}
 */
sjcl.BigNumber.prototype.toString = function() {};

/**
 * @return {!sjcl.BigNumber}
 */
sjcl.BigNumber.prototype.doubleM = function() {};

/**
 * @return {!sjcl.BigNumber}
 */
sjcl.BigNumber.prototype.halveM = function() {};

/**
 * @return {!sjcl.BigNumber}
 */
sjcl.BigNumber.prototype.square = function() {};

/**
 * @param {number|!sjcl.BigNumber|!Array<number>} n_or_a
 * @return {!sjcl.BigNumber}
 */
sjcl.BigNumber.prototype.power = function(n_or_a) {};

/**
 * @return {!sjcl.BigNumber}
 */
sjcl.BigNumber.prototype.trim = function() {};

/**
 * @return {!sjcl.BigNumber}
 */
sjcl.BigNumber.prototype.reduce = function() {};

/**
 * @return {!sjcl.BigNumber}
 */
sjcl.BigNumber.prototype.fullReduce = function() {};

/**
 * @return {!sjcl.BigNumber}
 */
sjcl.BigNumber.prototype.normalize = function() {};

/**
 * @return {!sjcl.BigNumber}
 */
sjcl.BigNumber.prototype.cnormalize = function() {};

/**
 * @param {number=} len
 * @return {!sjcl.BitArray}
 */
sjcl.BigNumber.prototype.toBits = function(len) {};

/**
 * @return {number}
 */
sjcl.BigNumber.prototype.bitLength = function() {};
/**
 * @record
 * @struct
 */
sjcl.BigNumberStatic = function() {};

/* TODO: ConstructSignature: sjcl */

/* TODO: ConstructSignature: sjcl */

/* TODO: ConstructSignature: sjcl */

/* TODO: ConstructSignature: sjcl */
 /** @type {!sjcl.TypeHelpers.Bind1<number>} */
sjcl.BigNumberStatic.prototype.random;
 /** @type {{p127: !sjcl.PseudoMersennePrimeStatic, p25519: !sjcl.PseudoMersennePrimeStatic, p192k: !sjcl.PseudoMersennePrimeStatic, p224k: !sjcl.PseudoMersennePrimeStatic, p256k: !sjcl.PseudoMersennePrimeStatic, p192: !sjcl.PseudoMersennePrimeStatic, p224: !sjcl.PseudoMersennePrimeStatic, p256: !sjcl.PseudoMersennePrimeStatic, p384: !sjcl.PseudoMersennePrimeStatic, p521: !sjcl.PseudoMersennePrimeStatic}} */
sjcl.BigNumberStatic.prototype.prime;

/**
 * @param {!sjcl.BitArray} bits
 * @return {!sjcl.BigNumber}
 */
sjcl.BigNumberStatic.prototype.fromBits = function(bits) {};

/**
 * @param {number} exponent
 * @param {!Array<!Array<number>>} coeff
 * @return {!sjcl.PseudoMersennePrimeStatic}
 */
sjcl.BigNumberStatic.prototype.pseudoMersennePrime = function(exponent, coeff) {};
/**
 * @extends {sjcl.BigNumber}
 * @record
 * @struct
 */
sjcl.PseudoMersennePrime = function() {};

/**
 * @return {!sjcl.PseudoMersennePrime}
 */
sjcl.PseudoMersennePrime.prototype.reduce = function() {};

/**
 * @return {!sjcl.PseudoMersennePrime}
 */
sjcl.PseudoMersennePrime.prototype.fullReduce = function() {};

/**
 * @return {!sjcl.PseudoMersennePrime}
 */
sjcl.PseudoMersennePrime.prototype.inverse = function() {};
/**
 * @extends {sjcl.BigNumberStatic}
 * @record
 * @struct
 */
sjcl.PseudoMersennePrimeStatic = function() {};

/* TODO: ConstructSignature: sjcl */

/* TODO: ConstructSignature: sjcl */

/* TODO: ConstructSignature: sjcl */

/* TODO: ConstructSignature: sjcl */
/**
 * @record
 * @struct
 */
sjcl.BitArray = function() {};
/**
 * @record
 * @struct
 */
sjcl.BitArrayStatic = function() {};

/**
 * @param {!sjcl.BitArray} a
 * @param {number} bstart
 * @param {number} bend
 * @return {!sjcl.BitArray}
 */
sjcl.BitArrayStatic.prototype.bitSlice = function(a, bstart, bend) {};

/**
 * @param {!sjcl.BitArray} a
 * @param {number} bstart
 * @param {number} blenth
 * @return {number}
 */
sjcl.BitArrayStatic.prototype.extract = function(a, bstart, blenth) {};

/**
 * @param {!sjcl.BitArray} a1
 * @param {!sjcl.BitArray} a2
 * @return {!sjcl.BitArray}
 */
sjcl.BitArrayStatic.prototype.concat = function(a1, a2) {};

/**
 * @param {!sjcl.BitArray} a
 * @return {number}
 */
sjcl.BitArrayStatic.prototype.bitLength = function(a) {};

/**
 * @param {!sjcl.BitArray} a
 * @param {number} len
 * @return {!sjcl.BitArray}
 */
sjcl.BitArrayStatic.prototype.clamp = function(a, len) {};

/**
 * @param {number} len
 * @param {number} x
 * @param {number=} _end
 * @return {number}
 */
sjcl.BitArrayStatic.prototype.partial = function(len, x, _end) {};

/**
 * @param {number} x
 * @return {number}
 */
sjcl.BitArrayStatic.prototype.getPartial = function(x) {};

/**
 * @param {!sjcl.BitArray} a
 * @param {!sjcl.BitArray} b
 * @return {boolean}
 */
sjcl.BitArrayStatic.prototype.equal = function(a, b) {};

/**
 * @param {!sjcl.BitArray} a
 * @param {number} shift
 * @param {number=} carry
 * @param {!sjcl.BitArray=} out
 * @return {!sjcl.BitArray}
 */
sjcl.BitArrayStatic.prototype._shiftRight = function(a, shift, carry, out) {};

/**
 * @param {!Array<number>} x
 * @param {!Array<number>} y
 * @return {!Array<number>}
 */
sjcl.BitArrayStatic.prototype._xor4 = function(x, y) {};
/**
 * @record
 * @struct
 */
sjcl.SjclCodec = function() {};

/**
 * @param {!sjcl.BitArray} bits
 * @return {T}
 */
sjcl.SjclCodec.prototype.fromBits = function(bits) {};

/**
 * @param {T} value
 * @return {!sjcl.BitArray}
 */
sjcl.SjclCodec.prototype.toBits = function(value) {};
/**
 * @record
 * @struct
 */
sjcl.SjclCodecs = function() {};
 /** @type {!sjcl.SjclCodec<string>} */
sjcl.SjclCodecs.prototype.utf8String;
 /** @type {!sjcl.SjclCodec<string>} */
sjcl.SjclCodecs.prototype.hex;
 /** @type {!sjcl.SjclCodec<!Array<number>>} */
sjcl.SjclCodecs.prototype.bytes;
 /** @type {!sjcl.SjclCodec<string>} */
sjcl.SjclCodecs.prototype.base64;
 /** @type {!sjcl.SjclCodec<string>} */
sjcl.SjclCodecs.prototype.base64url;
/**
 * @record
 * @struct
 */
sjcl.SjclHash = function() {};

/**
 * @return {!sjcl.SjclHash}
 */
sjcl.SjclHash.prototype.reset = function() {};

/**
 * @param {string|!sjcl.BitArray} data
 * @return {!sjcl.SjclHash}
 */
sjcl.SjclHash.prototype.update = function(data) {};

/**
 * @return {!sjcl.BitArray}
 */
sjcl.SjclHash.prototype.finalize = function() {};
/**
 * @record
 * @struct
 */
sjcl.SjclHashStatic = function() {};

/* TODO: ConstructSignature: sjcl */

/**
 * @param {string|!sjcl.BitArray} data
 * @return {!sjcl.BitArray}
 */
sjcl.SjclHashStatic.prototype.hash = function(data) {};
/**
 * @record
 * @struct
 */
sjcl.SjclHashes = function() {};
 /** @type {!sjcl.SjclHashStatic} */
sjcl.SjclHashes.prototype.sha1;
 /** @type {!sjcl.SjclHashStatic} */
sjcl.SjclHashes.prototype.sha256;
 /** @type {!sjcl.SjclHashStatic} */
sjcl.SjclHashes.prototype.sha512;
/**
 * @record
 * @struct
 */
sjcl.SjclExceptions = function() {};
 /** @type {!sjcl.SjclExceptionFactory} */
sjcl.SjclExceptions.prototype.corrupt;
 /** @type {!sjcl.SjclExceptionFactory} */
sjcl.SjclExceptions.prototype.invalid;
 /** @type {!sjcl.SjclExceptionFactory} */
sjcl.SjclExceptions.prototype.bug;
 /** @type {!sjcl.SjclExceptionFactory} */
sjcl.SjclExceptions.prototype.notReady;
/**
 * @record
 * @struct
 */
sjcl.SjclExceptionFactory = function() {};

/* TODO: ConstructSignature: sjcl */
/**
 * @record
 * @struct
 */
sjcl.SjclCiphers = function() {};
 /** @type {!sjcl.SjclCipherStatic} */
sjcl.SjclCiphers.prototype.aes;
/**
 * @record
 * @struct
 */
sjcl.SjclCipher = function() {};

/**
 * @param {!Array<number>} data
 * @return {!Array<number>}
 */
sjcl.SjclCipher.prototype.encrypt = function(data) {};

/**
 * @param {!Array<number>} data
 * @return {!Array<number>}
 */
sjcl.SjclCipher.prototype.decrypt = function(data) {};
/**
 * @record
 * @struct
 */
sjcl.SjclCipherStatic = function() {};

/* TODO: ConstructSignature: sjcl */
/**
 * @record
 * @struct
 */
sjcl.SjclModes = function() {};
 /** @type {!sjcl.SjclGCMMode} */
sjcl.SjclModes.prototype.gcm;
 /** @type {!sjcl.SjclCCMMode} */
sjcl.SjclModes.prototype.ccm;
 /** @type {!sjcl.SjclOCB2Mode} */
sjcl.SjclModes.prototype.ocb2;
 /** @type {!sjcl.SjclCBCMode} */
sjcl.SjclModes.prototype.cbc;
/**
 * @record
 * @struct
 */
sjcl.SjclGCMMode = function() {};

/**
 * @param {!sjcl.SjclCipher} prp
 * @param {!sjcl.BitArray} plaintext
 * @param {!sjcl.BitArray} iv
 * @param {!sjcl.BitArray=} adata
 * @param {number=} tlen
 * @return {!sjcl.BitArray}
 */
sjcl.SjclGCMMode.prototype.encrypt = function(prp, plaintext, iv, adata, tlen) {};

/**
 * @param {!sjcl.SjclCipher} prp
 * @param {!sjcl.BitArray} ciphertext
 * @param {!sjcl.BitArray} iv
 * @param {!sjcl.BitArray=} adata
 * @param {number=} tlen
 * @return {!sjcl.BitArray}
 */
sjcl.SjclGCMMode.prototype.decrypt = function(prp, ciphertext, iv, adata, tlen) {};
/**
 * @record
 * @struct
 */
sjcl.SjclCCMMode = function() {};

/**
 * @param {!sjcl.SjclCipher} prp
 * @param {!sjcl.BitArray} plaintext
 * @param {!sjcl.BitArray} iv
 * @param {!sjcl.BitArray=} adata
 * @param {number=} tlen
 * @return {!sjcl.BitArray}
 */
sjcl.SjclCCMMode.prototype.encrypt = function(prp, plaintext, iv, adata, tlen) {};

/**
 * @param {!sjcl.SjclCipher} prp
 * @param {!sjcl.BitArray} ciphertext
 * @param {!sjcl.BitArray} iv
 * @param {!sjcl.BitArray=} adata
 * @param {number=} tlen
 * @return {!sjcl.BitArray}
 */
sjcl.SjclCCMMode.prototype.decrypt = function(prp, ciphertext, iv, adata, tlen) {};
/**
 * @record
 * @struct
 */
sjcl.SjclOCB2Mode = function() {};

/**
 * @param {!sjcl.SjclCipher} prp
 * @param {!sjcl.BitArray} plaintext
 * @param {!sjcl.BitArray} iv
 * @param {!sjcl.BitArray=} adata
 * @param {number=} tlen
 * @param {boolean=} premac
 * @return {!sjcl.BitArray}
 */
sjcl.SjclOCB2Mode.prototype.encrypt = function(prp, plaintext, iv, adata, tlen, premac) {};

/**
 * @param {!sjcl.SjclCipher} prp
 * @param {!sjcl.BitArray} ciphertext
 * @param {!sjcl.BitArray} iv
 * @param {!sjcl.BitArray=} adata
 * @param {number=} tlen
 * @param {boolean=} premac
 * @return {!sjcl.BitArray}
 */
sjcl.SjclOCB2Mode.prototype.decrypt = function(prp, ciphertext, iv, adata, tlen, premac) {};

/**
 * @param {!sjcl.SjclCipher} prp
 * @param {!sjcl.BitArray} adata
 * @return {!Array<number>}
 */
sjcl.SjclOCB2Mode.prototype.pmac = function(prp, adata) {};
/**
 * @record
 * @struct
 */
sjcl.SjclCBCMode = function() {};

/**
 * @param {!sjcl.SjclCipher} prp
 * @param {!sjcl.BitArray} plaintext
 * @param {!sjcl.BitArray} iv
 * @param {!sjcl.BitArray=} adata
 * @return {!sjcl.BitArray}
 */
sjcl.SjclCBCMode.prototype.encrypt = function(prp, plaintext, iv, adata) {};

/**
 * @param {!sjcl.SjclCipher} prp
 * @param {!sjcl.BitArray} ciphertext
 * @param {!sjcl.BitArray} iv
 * @param {!sjcl.BitArray=} adata
 * @return {!sjcl.BitArray}
 */
sjcl.SjclCBCMode.prototype.decrypt = function(prp, ciphertext, iv, adata) {};
/**
 * @record
 * @struct
 */
sjcl.Pbkdf2Params = function() {};
 /** @type {number} */
sjcl.Pbkdf2Params.prototype.iter;
 /** @type {!sjcl.BitArray} */
sjcl.Pbkdf2Params.prototype.salt;
/**
 * @record
 * @struct
 */
sjcl.SjclMisc = function() {};
 /** @type {!sjcl.SjclHmacStatic} */
sjcl.SjclMisc.prototype.hmac;

/**
 * @param {string|!sjcl.BitArray} password
 * @param {string|!sjcl.BitArray} salt
 * @param {number=} count
 * @param {number=} length
 * @param {!sjcl.SjclPseudorandomFunctionFamilyStatic=} Prff
 * @return {!sjcl.BitArray}
 */
sjcl.SjclMisc.prototype.pbkdf2 = function(password, salt, count, length, Prff) {};

/**
 * @param {string} password
 * @param {!sjcl.Pbkdf2Params=} obj
 * @return {{key: !sjcl.BitArray, salt: !sjcl.BitArray}}
 */
sjcl.SjclMisc.prototype.cachedPbkdf2 = function(password, obj) {};
/**
 * @constructor
 * @struct
 */
sjcl.SjclPseudorandomFunctionFamily = function() {};

/**
 * @param {string|!sjcl.BitArray} data
 * @return {!sjcl.BitArray}
 */
sjcl.SjclPseudorandomFunctionFamily.prototype.encrypt = function(data) {};
/**
 * @record
 * @struct
 */
sjcl.SjclHmac = function() {};

/**
 * @param {string|!sjcl.BitArray} data
 * @return {!sjcl.BitArray}
 */
sjcl.SjclHmac.prototype.mac = function(data) {};

/**
 * @return {void}
 */
sjcl.SjclHmac.prototype.reset = function() {};

/**
 * @param {string|!sjcl.BitArray} data
 * @return {void}
 */
sjcl.SjclHmac.prototype.update = function(data) {};

/**
 * @return {!sjcl.BitArray}
 */
sjcl.SjclHmac.prototype.digest = function() {};
/**
 * @record
 * @struct
 */
sjcl.SjclPseudorandomFunctionFamilyStatic = function() {};

/* TODO: ConstructSignature: sjcl */
/**
 * @record
 * @struct
 */
sjcl.SjclHmacStatic = function() {};

/* TODO: ConstructSignature: sjcl */
/**
 * @record
 * @struct
 */
sjcl.SjclEllipticCurveCryptography = function() {};
 /** @type {!sjcl.SjclEllipticalPointStatic} */
sjcl.SjclEllipticCurveCryptography.prototype.point;
 /** @type {!sjcl.SjclPointJacobianStatic} */
sjcl.SjclEllipticCurveCryptography.prototype.pointJac;
 /** @type {!sjcl.SjclEllipticalCurveStatic} */
sjcl.SjclEllipticCurveCryptography.prototype.curve;
 /** @type {{c192: !sjcl.SjclEllipticalCurve, c224: !sjcl.SjclEllipticalCurve, c256: !sjcl.SjclEllipticalCurve, c384: !sjcl.SjclEllipticalCurve, k192: !sjcl.SjclEllipticalCurve, k224: !sjcl.SjclEllipticalCurve, k256: !sjcl.SjclEllipticalCurve}} */
sjcl.SjclEllipticCurveCryptography.prototype.curves;
 /** @type {!sjcl.SjclECCBasic} */
sjcl.SjclEllipticCurveCryptography.prototype.basicKey;
 /** @type {!sjcl.SjclElGamal} */
sjcl.SjclEllipticCurveCryptography.prototype.elGamal;
 /** @type {!sjcl.SjclEcdsa} */
sjcl.SjclEllipticCurveCryptography.prototype.ecdsa;
/**
 * @record
 * @struct
 */
sjcl.SjclEllipticalPoint = function() {};

/**
 * @return {!sjcl.SjclPointJacobian}
 */
sjcl.SjclEllipticalPoint.prototype.toJac = function() {};

/**
 * @param {!sjcl.BigNumber} k
 * @return {!sjcl.SjclEllipticalPoint}
 */
sjcl.SjclEllipticalPoint.prototype.mult = function(k) {};

/**
 * @param {!sjcl.BigNumber} k
 * @param {!sjcl.BigNumber} k2
 * @param {!sjcl.SjclEllipticalPoint} affine2
 * @return {!sjcl.SjclEllipticalPoint}
 */
sjcl.SjclEllipticalPoint.prototype.mult2 = function(k, k2, affine2) {};

/**
 * @return {!Array<!sjcl.SjclEllipticalPoint>}
 */
sjcl.SjclEllipticalPoint.prototype.multiples = function() {};

/**
 * @return {boolean}
 */
sjcl.SjclEllipticalPoint.prototype.isValid = function() {};

/**
 * @return {!sjcl.BitArray}
 */
sjcl.SjclEllipticalPoint.prototype.toBits = function() {};
/**
 * @record
 * @struct
 */
sjcl.SjclEllipticalPointStatic = function() {};

/* TODO: ConstructSignature: sjcl */
/**
 * @record
 * @struct
 */
sjcl.SjclPointJacobian = function() {};

/**
 * @param {!sjcl.SjclEllipticalPoint} T
 * @return {!sjcl.SjclPointJacobian}
 */
sjcl.SjclPointJacobian.prototype.add = function(T) {};

/**
 * @return {!sjcl.SjclPointJacobian}
 */
sjcl.SjclPointJacobian.prototype.doubl = function() {};

/**
 * @return {!sjcl.SjclEllipticalPoint}
 */
sjcl.SjclPointJacobian.prototype.toAffine = function() {};

/**
 * @param {!sjcl.BigNumber} k
 * @param {!sjcl.SjclEllipticalPoint} affine
 * @return {!sjcl.SjclPointJacobian}
 */
sjcl.SjclPointJacobian.prototype.mult = function(k, affine) {};

/**
 * @param {!sjcl.BigNumber} k1
 * @param {!sjcl.SjclEllipticalPoint} affine
 * @param {!sjcl.BigNumber} k2
 * @param {!sjcl.SjclEllipticalPoint} affine2
 * @return {!sjcl.SjclPointJacobian}
 */
sjcl.SjclPointJacobian.prototype.mult2 = function(k1, affine, k2, affine2) {};

/**
 * @return {boolean}
 */
sjcl.SjclPointJacobian.prototype.isValid = function() {};
/**
 * @record
 * @struct
 */
sjcl.SjclPointJacobianStatic = function() {};

/* TODO: ConstructSignature: sjcl */
/**
 * @record
 * @struct
 */
sjcl.SjclEllipticalCurve = function() {};

/**
 * @param {!sjcl.BitArray} bits
 * @return {!sjcl.SjclEllipticalPoint}
 */
sjcl.SjclEllipticalCurve.prototype.fromBits = function(bits) {};
/**
 * @record
 * @struct
 */
sjcl.SjclEllipticalCurveStatic = function() {};

/* TODO: ConstructSignature: sjcl */
/**
 * @record
 * @struct
 */
sjcl.SjclKeyPair = function() {};
 /** @type {P} */
sjcl.SjclKeyPair.prototype.pub;
 /** @type {S} */
sjcl.SjclKeyPair.prototype.sec;
/**
 * @record
 * @struct
 */
sjcl.SjclKeysGenerator = function() {};

/* TODO: CallSignature: sjcl */

/* TODO: CallSignature: sjcl */
/**
 * @record
 * @struct
 */
sjcl.SjclECCPublicKeyData = function() {};
 /** @type {!sjcl.BitArray} */
sjcl.SjclECCPublicKeyData.prototype.x;
 /** @type {!sjcl.BitArray} */
sjcl.SjclECCPublicKeyData.prototype.y;
/**
 * @constructor
 * @struct
 */
sjcl.SjclECCPublicKey = function() {};

/**
 * @return {!sjcl.SjclECCPublicKeyData}
 */
sjcl.SjclECCPublicKey.prototype.get = function() {};
/**
 * @constructor
 * @struct
 */
sjcl.SjclECCSecretKey = function() {};

/**
 * @return {!sjcl.BitArray}
 */
sjcl.SjclECCSecretKey.prototype.get = function() {};
/**
 * @record
 * @struct
 */
sjcl.SjclECCPublicKeyFactory = function() {};

/* TODO: ConstructSignature: sjcl */

/* TODO: ConstructSignature: sjcl */
/**
 * @record
 * @struct
 */
sjcl.SjclECCSecretKeyFactory = function() {};

/* TODO: ConstructSignature: sjcl */
/**
 * @record
 * @struct
 */
sjcl.SjclECCBasic = function() {};
 /** @type {!sjcl.SjclECCPublicKeyFactory<!sjcl.SjclECCPublicKey>} */
sjcl.SjclECCBasic.prototype.publicKey;
 /** @type {!sjcl.SjclECCSecretKeyFactory<!sjcl.SjclECCSecretKey>} */
sjcl.SjclECCBasic.prototype.secretKey;

/**
 * @param {string} cn
 * @return {!sjcl.SjclKeysGenerator<!sjcl.SjclECCPublicKey, !sjcl.SjclECCSecretKey>}
 */
sjcl.SjclECCBasic.prototype.generateKeys = function(cn) {};
/**
 * @extends {sjcl.SjclECCPublicKey}
 * @constructor
 * @struct
 */
sjcl.SjclElGamalPublicKey = function() {};

/**
 * @param {number} paranoia
 * @return {{key: !sjcl.BitArray, tag: !sjcl.BitArray}}
 */
sjcl.SjclElGamalPublicKey.prototype.kem = function(paranoia) {};
/**
 * @extends {sjcl.SjclECCSecretKey}
 * @constructor
 * @struct
 */
sjcl.SjclElGamalSecretKey = function() {};

/**
 * @param {!sjcl.BitArray} tag
 * @return {!sjcl.BitArray}
 */
sjcl.SjclElGamalSecretKey.prototype.unkem = function(tag) {};

/**
 * @param {!sjcl.SjclECCPublicKey} pk
 * @return {!sjcl.BitArray}
 */
sjcl.SjclElGamalSecretKey.prototype.dh = function(pk) {};
/**
 * @record
 * @struct
 */
sjcl.SjclElGamal = function() {};
 /** @type {!sjcl.SjclECCPublicKeyFactory<!sjcl.SjclElGamalPublicKey>} */
sjcl.SjclElGamal.prototype.publicKey;
 /** @type {!sjcl.SjclECCSecretKeyFactory<!sjcl.SjclElGamalSecretKey>} */
sjcl.SjclElGamal.prototype.secretKey;
 /** @type {!sjcl.SjclKeysGenerator<!sjcl.SjclElGamalPublicKey, !sjcl.SjclElGamalSecretKey>} */
sjcl.SjclElGamal.prototype.generateKeys;
/**
 * @extends {sjcl.SjclECCPublicKey}
 * @constructor
 * @struct
 */
sjcl.SjclEcdsaPublicKey = function() {};

/**
 * @param {!sjcl.BitArray} hash
 * @param {!sjcl.BitArray} rs
 * @param {boolean} fakeLegacyVersion
 * @return {boolean}
 */
sjcl.SjclEcdsaPublicKey.prototype.verify = function(hash, rs, fakeLegacyVersion) {};
/**
 * @extends {sjcl.SjclECCSecretKey}
 * @constructor
 * @struct
 */
sjcl.SjclEcdsaSecretKey = function() {};

/**
 * @param {!sjcl.BitArray} hash
 * @param {number} paranoia
 * @param {boolean} fakeLegacyVersion
 * @param {!sjcl.BigNumber=} fixedKForTesting
 * @return {!sjcl.BitArray}
 */
sjcl.SjclEcdsaSecretKey.prototype.sign = function(hash, paranoia, fakeLegacyVersion, fixedKForTesting) {};
/**
 * @record
 * @struct
 */
sjcl.SjclEcdsa = function() {};
 /** @type {!sjcl.SjclECCPublicKeyFactory<!sjcl.SjclEcdsaPublicKey>} */
sjcl.SjclEcdsa.prototype.publicKey;
 /** @type {!sjcl.SjclECCSecretKeyFactory<!sjcl.SjclEcdsaSecretKey>} */
sjcl.SjclEcdsa.prototype.secretKey;
 /** @type {!sjcl.SjclKeysGenerator<!sjcl.SjclEcdsaPublicKey, !sjcl.SjclEcdsaSecretKey>} */
sjcl.SjclEcdsa.prototype.generateKeys;
/**
 * @record
 * @struct
 */
sjcl.SjclRandom = function() {};

/**
 * @param {number} nwords
 * @param {number=} paranoia
 * @return {!sjcl.BitArray}
 */
sjcl.SjclRandom.prototype.randomWords = function(nwords, paranoia) {};

/**
 * @param {number} paranoia
 * @param {string} allowZeroParanoia
 * @return {void}
 */
sjcl.SjclRandom.prototype.setDefaultParanoia = function(paranoia, allowZeroParanoia) {};

/**
 * @param {number|!Array<number>|string} data
 * @param {number} estimatedEntropy
 * @param {string} source
 * @return {void}
 */
sjcl.SjclRandom.prototype.addEntropy = function(data, estimatedEntropy, source) {};

/**
 * @param {number=} paranoia
 * @return {boolean}
 */
sjcl.SjclRandom.prototype.isReady = function(paranoia) {};

/**
 * @param {number=} paranoia
 * @return {number}
 */
sjcl.SjclRandom.prototype.getProgress = function(paranoia) {};

/**
 * @return {void}
 */
sjcl.SjclRandom.prototype.startCollectors = function() {};

/**
 * @return {void}
 */
sjcl.SjclRandom.prototype.stopCollectors = function() {};

/**
 * @param {string} name
 * @param {!Function} cb
 * @return {void}
 */
sjcl.SjclRandom.prototype.addEventListener = function(name, cb) {};

/**
 * @param {string} name
 * @param {!Function} cb
 * @return {void}
 */
sjcl.SjclRandom.prototype.removeEventListener = function(name, cb) {};
/**
 * @record
 * @struct
 */
sjcl.SjclRandomStatic = function() {};

/* TODO: ConstructSignature: sjcl */
/**
 * @record
 * @struct
 */
sjcl.SjclKeyExchange = function() {};
 /** @type {!sjcl.SecureRemotePassword} */
sjcl.SjclKeyExchange.prototype.srp;
/**
 * @record
 * @struct
 */
sjcl.SjclSRPGroup = function() {};
 /** @type {!sjcl.BigNumber} */
sjcl.SjclSRPGroup.prototype.N;
 /** @type {!sjcl.BigNumber} */
sjcl.SjclSRPGroup.prototype.g;
/**
 * @record
 * @struct
 */
sjcl.SecureRemotePassword = function() {};

/**
 * @param {string} username
 * @param {string} password
 * @param {!sjcl.BitArray} salt
 * @param {!sjcl.SjclSRPGroup} group
 * @return {!sjcl.BitArray}
 */
sjcl.SecureRemotePassword.prototype.makeVerifier = function(username, password, salt, group) {};

/**
 * @param {string} username
 * @param {string} password
 * @param {!sjcl.BitArray} salt
 * @return {!sjcl.BitArray}
 */
sjcl.SecureRemotePassword.prototype.makeX = function(username, password, salt) {};

/**
 * @param {string|number} i
 * @return {!sjcl.SjclSRPGroup}
 */
sjcl.SecureRemotePassword.prototype.knownGroup = function(i) {};
/**
 * @record
 * @struct
 */
sjcl.SjclCipherParams = function() {};
 /** @type {number} */
sjcl.SjclCipherParams.prototype.v;
 /** @type {number} */
sjcl.SjclCipherParams.prototype.iter;
 /** @type {number} */
sjcl.SjclCipherParams.prototype.ks;
 /** @type {number} */
sjcl.SjclCipherParams.prototype.ts;
 /** @type {string} */
sjcl.SjclCipherParams.prototype.mode;
 /** @type {string} */
sjcl.SjclCipherParams.prototype.adata;
 /** @type {string} */
sjcl.SjclCipherParams.prototype.cipher;
/**
 * @extends {sjcl.SjclCipherParams}
 * @record
 * @struct
 */
sjcl.SjclCipherEncryptParams = function() {};
 /** @type {!sjcl.BitArray} */
sjcl.SjclCipherEncryptParams.prototype.salt;
 /** @type {!sjcl.BitArray} */
sjcl.SjclCipherEncryptParams.prototype.iv;
/**
 * @extends {sjcl.SjclCipherParams}
 * @record
 * @struct
 */
sjcl.SjclCipherDecryptParams = function() {};
 /** @type {!sjcl.BitArray} */
sjcl.SjclCipherDecryptParams.prototype.salt;
 /** @type {!sjcl.BitArray} */
sjcl.SjclCipherDecryptParams.prototype.iv;
/**
 * @extends {sjcl.SjclCipherEncryptParams}
 * @record
 * @struct
 */
sjcl.SjclCipherEncrypted = function() {};
 /** @type {!sjcl.BitArray} */
sjcl.SjclCipherEncrypted.prototype.kemtag;
 /** @type {!sjcl.BitArray} */
sjcl.SjclCipherEncrypted.prototype.ct;
/**
 * @extends {sjcl.SjclCipherEncrypted}
 * @record
 * @struct
 */
sjcl.SjclCipherDecrypted = function() {};
 /** @type {!sjcl.BitArray} */
sjcl.SjclCipherDecrypted.prototype.key;
/**
 * @record
 * @struct
 */
sjcl.SjclConveninceEncryptor = function() {};

/* TODO: CallSignature: sjcl */

/* TODO: CallSignature: sjcl */

/* TODO: CallSignature: sjcl */
/**
 * @record
 * @struct
 */
sjcl.SjclConveninceDecryptor = function() {};

/* TODO: CallSignature: sjcl */

/* TODO: CallSignature: sjcl */

/* TODO: CallSignature: sjcl */

/* TODO: CallSignature: sjcl */
/**
 * @record
 * @struct
 */
sjcl.SjclJson = function() {};
 /** @type {!sjcl.SjclConveninceEncryptor} */
sjcl.SjclJson.prototype.encrypt;
 /** @type {!sjcl.SjclConveninceDecryptor} */
sjcl.SjclJson.prototype.decrypt;

/**
 * @param {!Object} obj
 * @return {string}
 */
sjcl.SjclJson.prototype.encode = function(obj) {};

/**
 * @param {string} obj
 * @return {!Object}
 */
sjcl.SjclJson.prototype.decode = function(obj) {};
/** @const */
sjcl.TypeHelpers = {};
/**
 * @record
 * @struct
 */
sjcl.TypeHelpers.One = function() {};

/* TODO: CallSignature: sjcl.TypeHelpers */
/**
 * @extends {sjcl.TypeHelpers.One}
 * @extends {sjcl.TypeHelpers.One}
 * @extends {sjcl.TypeHelpers.One}
 * @record
 * @struct
 */
sjcl.TypeHelpers.BigNumberBinaryOperator = function() {};
/**
 * @record
 * @struct
 */
sjcl.TypeHelpers.Two = function() {};

/* TODO: CallSignature: sjcl.TypeHelpers */
/**
 * @extends {sjcl.TypeHelpers.Two}
 * @extends {sjcl.TypeHelpers.Two}
 * @extends {sjcl.TypeHelpers.Two}
 * @record
 * @struct
 */
sjcl.TypeHelpers.Bind1 = function() {};
/**
 * @extends {sjcl.TypeHelpers.Bind1}
 * @extends {sjcl.TypeHelpers.Bind1}
 * @extends {sjcl.TypeHelpers.Bind1}
 * @record
 * @struct
 */
sjcl.TypeHelpers.BigNumberTrinaryOperator = function() {};
