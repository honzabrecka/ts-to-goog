/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/chroma-js/index.d.ts:
/** @const */
var Chroma = {};
/**
 * @record
 * @struct
 */
Chroma.ColorSpaces = function() {};
 /** @type {!Array<?>} */
Chroma.ColorSpaces.prototype.rgb;
 /** @type {!Array<?>} */
Chroma.ColorSpaces.prototype.rgba;
 /** @type {!Array<?>} */
Chroma.ColorSpaces.prototype.hsl;
 /** @type {!Array<?>} */
Chroma.ColorSpaces.prototype.hsv;
 /** @type {!Array<?>} */
Chroma.ColorSpaces.prototype.hsi;
 /** @type {!Array<?>} */
Chroma.ColorSpaces.prototype.lab;
 /** @type {!Array<?>} */
Chroma.ColorSpaces.prototype.lch;
 /** @type {!Array<?>} */
Chroma.ColorSpaces.prototype.hcl;
 /** @type {!Array<?>} */
Chroma.ColorSpaces.prototype.cmyk;
 /** @type {!Array<?>} */
Chroma.ColorSpaces.prototype.gl;
/**
 * @record
 * @struct
 */
Chroma.ChromaStatic = function() {};

/* TODO: CallSignature: Chroma */

/* TODO: CallSignature: Chroma */

/* TODO: CallSignature: Chroma */

/* TODO: CallSignature: Chroma */
 /** @type {{OrRd: !Array<string>, PuBu: !Array<string>, BuPu: !Array<string>, Oranges: !Array<string>, BuGn: !Array<string>, YlOrBr: !Array<string>, YlGn: !Array<string>, Reds: !Array<string>, RdPu: !Array<string>, Greens: !Array<string>, YlGnBu: !Array<string>, Purples: !Array<string>, GnBu: !Array<string>, Greys: !Array<string>, YlOrRd: !Array<string>, PuRd: !Array<string>, Blues: !Array<string>, PuBuGn: !Array<string>, Spectral: !Array<string>, RdYlGn: !Array<string>, RdBu: !Array<string>, PiYG: !Array<string>, PRGn: !Array<string>, RdYlBu: !Array<string>, BrBG: !Array<string>, RdGy: !Array<string>, PuOr: !Array<string>, Set2: !Array<string>, Accent: !Array<string>, Set1: !Array<string>, Set3: !Array<string>, Dark2: !Array<string>, Paired: !Array<string>, Pastel2: !Array<string>, Pastel1: !Array<string>}} */
Chroma.ChromaStatic.prototype.brewer;

/**
 * Create a color from a hex or string representation (as supported in CSS).
 * 
 * This is an alias of chroma.css().
 * 
 * @param {string} color The string to convert to a color.
 * @return {?} the color object.
 */
Chroma.ChromaStatic.prototype.hex = function(color) {};

/**
 * @param {number} h
 * @param {number} s
 * @param {number} l
 * @return {?}
 */
Chroma.ChromaStatic.prototype.hsl = function(h, s, l) {};

/**
 * @param {number} h
 * @param {number} s
 * @param {number} v
 * @return {?}
 */
Chroma.ChromaStatic.prototype.hsv = function(h, s, v) {};

/**
 * @param {number} lightness
 * @param {number} a
 * @param {number} b
 * @param {number=} alpha
 * @return {?}
 */
Chroma.ChromaStatic.prototype.lab = function(lightness, a, b, alpha) {};

/**
 * @param {number} l
 * @param {number} c
 * @param {number} h
 * @return {?}
 */
Chroma.ChromaStatic.prototype.lch = function(l, c, h) {};

/**
 * @param {number} r
 * @param {number} g
 * @param {number} b
 * @return {?}
 */
Chroma.ChromaStatic.prototype.rgb = function(r, g, b) {};

/**
 * GL is a variant of RGB(A), with the only difference that the components are normalized to the range of 0..1.
 * @param {number} red
 * @param {number} green
 * @param {number} blue
 * @param {number=} alpha
 * @return {?}
 */
Chroma.ChromaStatic.prototype.gl = function(red, green, blue, alpha) {};

/**
 * Returns a color from the color temperature scale.
 * light 2000K, bright sunlight 6000K.
 * Based on Neil Bartlett's implementation.
 * https://github.com/neilbartlett/color-temperature
 * @param {number} t
 * @return {?}
 */
Chroma.ChromaStatic.prototype.temperature = function(t) {};

/**
 * Mixes two colors. The mix ratio is a value between 0 and 1.
 * The color mixing produces different results based the color space used for interpolation.
 * \@example chroma.mix('red', 'blue', 0.25) // => #bf0040
 * \@example chroma.mix('red', 'blue', 0.5, 'hsl') // => #ff00ff
 * @param {(string|?)} color1
 * @param {(string|?)} color2
 * @param {number=} f
 * @param {string=} colorSpace
 * @return {?}
 */
Chroma.ChromaStatic.prototype.mix = function(color1, color2, f, colorSpace) {};

/**
 * Alias for {\@see mix}.
 * @param {(string|?)} color1
 * @param {(string|?)} color2
 * @param {number=} f
 * @param {string=} colorSpace
 * @return {?}
 */
Chroma.ChromaStatic.prototype.interpolate = function(color1, color2, f, colorSpace) {};

/**
 * Similar to {\@link mix}, but accepts more than two colors. Simple averaging of R,G,B components and the alpha
 * channel.
 * @param {!Array<(string|?)>} colors
 * @param {string=} colorSpace
 * @return {?}
 */
Chroma.ChromaStatic.prototype.average = function(colors, colorSpace) {};

/**
 * Blends two colors using RGB channel-wise blend functions.
 * @param {(string|?)} color1
 * @param {(string|?)} color2
 * @param {string} blendMode
 * @return {?}
 */
Chroma.ChromaStatic.prototype.blend = function(color1, color2, blendMode) {};

/**
 * Returns a random color.
 * @return {?}
 */
Chroma.ChromaStatic.prototype.random = function() {};

/**
 * Computes the WCAG contrast ratio between two colors.
 * A minimum contrast of 4.5:1 is recommended {\@link https://www.w3.org/TR/WCAG20-TECHS/G18.html}
 * to ensure that text is still readable against a background color.
 * @param {(string|?)} color1
 * @param {(string|?)} color2
 * @return {number}
 */
Chroma.ChromaStatic.prototype.contrast = function(color1, color2) {};

/**
 * Computes the eucledian distance between two colors in a given color space (default is 'lab').
 * {\@link https://en.wikipedia.org/wiki/Euclidean_distance#Three_dimensions}
 * @param {(string|?)} color1
 * @param {(string|?)} color2
 * @param {string=} colorSpace
 * @return {?}
 */
Chroma.ChromaStatic.prototype.distance = function(color1, color2, colorSpace) {};

/**
 * Computes color difference {\@link https://en.wikipedia.org/wiki/Color_difference#CMC_l:c_.281984.29} as
 * developed by the Colour Measurement Committee of the Society of Dyers and Colourists (CMC) in 1984.
 * The implementation is adapted from Bruce Lindbloom.
 * {\@link https://web.archive.org/web/20160306044036/http://www.brucelindbloom.com/javascript/ColorDiff.js}
 * The parameters L (default 1) and C (default 1) are weighting factors for lightness and chromacity.
 * @param {(string|?)} color1
 * @param {(string|?)} color2
 * @param {number=} L
 * @param {number=} C
 * @return {?}
 */
Chroma.ChromaStatic.prototype.deltaE = function(color1, color2, L, C) {};

/**
 * Helper function that computes class breaks based on data.
 * Mode:
 *  <li>equidistant <code>'e'</code> breaks are computed by dividing the total range of the data into n groups
 *  of equal size.
 *  <li>quantile <code>'q'</code> input domain is divided by quantile ranges.
 *  <li>logarithmic <code>'l'</code> breaks are equidistant breaks but on a logarithmic scale.
 *  <li>k-means <code>'k'</code> breaks use the 1-dimensional
 *  [k-means clustering algorithm]{\@link https://en.wikipedia.org/wiki/K-means_clustering} to find (roughly) n
 *  groups of "similar" values. Note that this k-means implementation does not guarantee to find exactly n groups.
 * @param {!Array<number>} data
 * @param {string} mode
 * @param {number} c
 * @return {!Array<number>}
 */
Chroma.ChromaStatic.prototype.limits = function(data, mode, c) {};

/**
 * Returns a function that
 * [bezier-interpolates]{\@link https://www.vis4.net/blog/posts/mastering-multi-hued-color-scales/} between
 * colors in Lab space. The input range of the function is [0..1].
 * You can convert it to a scale instance by calling <code>chroma.bezier(...).scale()</code>
 * @param {!Array<string>} colors
 * @return {?}
 */
Chroma.ChromaStatic.prototype.bezier = function(colors) {};

/**
 * @param {(string|?)|!Array<(string|?)>=} name_or_colors
 * @return {!Chroma.Scale<?>}
 */
Chroma.ChromaStatic.prototype.scale = function(name_or_colors) {};

/**
 * @return {!Chroma.Cubehelix}
 */
Chroma.ChromaStatic.prototype.cubehelix = function() {};

/**
 * @param {number} c
 * @param {number} m
 * @param {number} y
 * @param {number} k
 * @return {?}
 */
Chroma.ChromaStatic.prototype.cmyk = function(c, m, y, k) {};

/**
 * @param {string} col
 * @return {?}
 */
Chroma.ChromaStatic.prototype.css = function(col) {};

/** @typedef {?} */
Chroma.Color;
/**
 * @record
 * @struct
 */
Chroma.Scale = function() {};

/* TODO: CallSignature: Chroma */

/* TODO: CallSignature: Chroma */

/**
 * @param {!Array<number>=} d
 * @param {number=} n
 * @param {string=} mode
 * @return {Scale}
 */
Chroma.Scale.prototype.domain = function(d, n, mode) {};

/**
 * @param {string} mode
 * @return {Scale}
 */
Chroma.Scale.prototype.mode = function(mode) {};

/**
 * @param {boolean} use
 * @return {boolean}
 */
Chroma.Scale.prototype.cache = function(use) {};

/**
 * @param {boolean=} enable
 * @return {Scale}
 */
Chroma.Scale.prototype.correctLightness = function(enable) {};

/**
 * @param {(number|!Array<number>)} p
 * @return {Scale}
 */
Chroma.Scale.prototype.padding = function(p) {};

/**
 * You can call scale.colors(n) to quickly grab `c` equi-distant colors from a color scale. If called with no
 * arguments, scale.colors returns the original array of colors used to create the scale.
 * @template K
 * @param {number=} c
 * @param {string|K=} format
 * @return {!Array<string>|!Array<?>|!Array<number>}
 */
Chroma.Scale.prototype.colors = function(c, format) {};

/**
 * If you want the scale function to return a distinct set of colors instead of a continuous gradient, you can
 * use scale.classes. If you pass a number the scale will broken into equi-distant classes.
 * You can also define custom class breaks by passing them as array
 * @param {(number|!Array<number>)} c
 * @return {Scale}
 */
Chroma.Scale.prototype.classes = function(c) {};

/**
 * Set out format for scale() call. Passing null will result in a scale which outputs colors.
 * @template K
 * @param {null|K} format
 * @return {!Chroma.Scale<?>}
 */
Chroma.Scale.prototype.out = function(format) {};
/**
 * @record
 * @struct
 */
Chroma.Cubehelix = function() {};

/**
 * Set start color for hue rotation, default=300
 * @param {number} s
 * @return {!Chroma.Cubehelix}
 */
Chroma.Cubehelix.prototype.start = function(s) {};

/**
 * number (and direction) of hue rotations (e.g. 1=360°, 1.5=`540°``), default=-1.5
 * @param {number} r
 * @return {!Chroma.Cubehelix}
 */
Chroma.Cubehelix.prototype.rotations = function(r) {};

/**
 * gamma factor can be used to emphasise low or high intensity values, default=1
 * @param {number} g
 * @return {!Chroma.Cubehelix}
 */
Chroma.Cubehelix.prototype.gamma = function(g) {};

/**
 * lightness range: default: [0,1] (black -> white)
 * @param {!Array<number>} l
 * @return {!Chroma.Cubehelix}
 */
Chroma.Cubehelix.prototype.lightness = function(l) {};

/**
 * You can call cubehelix.scale() to use the cube-helix through the chroma.scale interface.
 * @return {!Chroma.Scale<?>}
 */
Chroma.Cubehelix.prototype.scale = function() {};
 /** @type {!Chroma.ChromaStatic} */
var chroma;

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
