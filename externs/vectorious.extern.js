/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/vectorious/index.d.ts:

/**
 * @constructor
 * @struct
 * \@method constructor
 * @desc Creates a two-dimensional `Vector` from the supplied arguments.
 * 
 * @param {!Array<number>} data
 */
function Vector(data) {}

/**
 * Static method. Adds two vectors `a` and `b` together.
 * 
 * @param {?} a
 * @param {?} v
 * @return {?}
 */
Vector.add = function(a, v) {};

/**
 * Adds `vector` to the current vector.
 * 
 * @param {?} vector
 * @return {?}
 */
Vector.prototype.add = function(vector) {};

/**
 * Static method. Subtracts the vector `b` from vector `a`.
 * 
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
Vector.subtract = function(a, b) {};

/**
 * Subtracts `vector` from the current vector.
 * 
 * @param {?} vector
 * @return {?}
 */
Vector.prototype.subtract = function(vector) {};

/**
 * Static method. Multiplies all elements of `vector` with a specified `scalar`.
 * 
 * @param {?} vector
 * @param {number} scalar
 * @return {?}
 */
Vector.scale = function(vector, scalar) {};

/**
 * Multiplies all elements of current vector with a specified `scalar`.
 * 
 * @param {number} scalar
 * @return {?}
 */
Vector.prototype.scale = function(scalar) {};

/**
 * Static method. Normalizes `vector`, i.e. divides all elements with the magnitude.
 * 
 * @param {?} vector
 * @return {?}
 */
Vector.normalize = function(vector) {};

/**
 * Normalizes current vector.
 * 
 * @return {?}
 */
Vector.prototype.normalize = function() {};

/**
 * Static method. Projects the vector `a` onto the vector `b` using
 * the projection formula `(b * (a * b / b * b))`.
 * 
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
Vector.project = function(a, b) {};

/**
 * Projects the current vector onto `vector` using
 * the projection formula `(b * (a * b / b * b))`.
 * 
 * @param {?} vector
 * @return {?}
 */
Vector.prototype.project = function(vector) {};

/**
 * Static method. Creates a vector containing zeros (`0`) of `count` size, takes
 * an optional `type` argument which should be an instance of `TypedArray`.
 * 
 * @param {number} count
 * @param {?=} type
 * @return {?}
 */
Vector.zeros = function(count, type) {};

/**
 * Static method. Creates a vector containing ones (`1`) of `count` size, takes
 * an optional `type` argument which should be an instance of `TypedArray`.
 * 
 * @param {number} count
 * @param {?=} type
 * @return {?}
 */
Vector.ones = function(count, type) {};

/**
 * Static method. Creates a vector containing a range (can be either ascending or descending)
 * of numbers specified by the arguments provided (e.g. `Vector.range(0, .5, 2)`
 * gives a vector containing all numbers in the interval `[0, 2)` separated by
 * steps of `0.5`), takes an optional `type` argument which should be an instance of
 * `TypedArray`.
 * 
 * @param {number} start
 * @param {number} end_or_step
 * @param {number=} end
 * @return {?}
 */
Vector.range = function(start, end_or_step, end) {};

/**
 * Static method. Creates a vector of `count` elements containing random
 * values according to a normal distribution, takes an optional `type`
 * argument which should be an instance of `TypedArray`.
 * 
 * @param {number} count
 * @param {number=} deviation
 * @param {number=} mean
 * @param {?=} type
 * @return {?}
 */
Vector.random = function(count, deviation, mean, type) {};

/**
 * Static method. Performs dot multiplication with two vectors `a` and `b`.
 * 
 * @param {?} a
 * @param {?} b
 * @return {number}
 */
Vector.dot = function(a, b) {};

/**
 * Performs dot multiplication with current vector and `vector`
 * 
 * @param {?} vector
 * @return {number}
 */
Vector.prototype.dot = function(vector) {};

/**
 * Calculates the magnitude of a vector (also called L2 norm or Euclidean length).
 * 
 * @return {number}
 */
Vector.prototype.magnitude = function() {};

/**
 * Static method. Determines the angle between two vectors `a` and `b`.
 * 
 * @param {?} a
 * @param {?} b
 * @return {number}
 */
Vector.angle = function(a, b) {};

/**
 * Determines the angle between the current vector and `vector`.
 * 
 * @param {?} vector
 * @return {number}
 */
Vector.prototype.angle = function(vector) {};

/**
 * Static method. Checks the equality of two vectors `a` and `b`.
 * 
 * @param {?} a
 * @param {?} b
 * @return {boolean}
 */
Vector.equals = function(a, b) {};

/**
 * Checks the equality of the current vector and `vector`.
 * 
 * @param {?} vector
 * @return {boolean}
 */
Vector.prototype.equals = function(vector) {};

/**
 * Gets the element at `index` from current vector.
 * 
 * @param {number} index
 * @return {number}
 */
Vector.prototype.get = function(index) {};

/**
 * Gets the minimum value (smallest) element of current vector.
 * 
 * @return {number}
 */
Vector.prototype.min = function() {};

/**
 * Gets the maximum value (largest) element of current vector.
 * 
 * @return {number}
 */
Vector.prototype.max = function() {};

/**
 * Sets the element at `index` to `value`.
 * 
 * @param {number} index
 * @param {number} value
 * @return {?}
 */
Vector.prototype.set = function(index, value) {};

/**
 * Static method. Combines two vectors `a` and `b` (appends `b` to `a`).
 * 
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
Vector.combine = function(a, b) {};

/**
 * Combines the current vector with `vector`
 * 
 * @param {?} vector
 * @return {?}
 */
Vector.prototype.combine = function(vector) {};

/**
 * Pushes a new `value` into current vector.
 * 
 * @param {number} value
 * @return {?}
 */
Vector.prototype.push = function(value) {};

/**
 * Maps a function `callback` to all elements of current vector.
 * 
 * @param {?} callback
 * @return {?}
 */
Vector.prototype.map = function(callback) {};

/**
 * Functional version of for-looping the vector, is equivalent
 * to `Array.prototype.forEach`.
 * 
 * @param {?} callback
 * @return {?}
 */
Vector.prototype.each = function(callback) {};

/**
 * Equivalent to `TypedArray.prototype.reduce`.
 * 
 * @param {?} callback
 * @param {number=} initialValue
 * @return {number}
 */
Vector.prototype.reduce = function(callback, initialValue) {};

/**
 * Converts current vector into a readable formatted string.
 * 
 * @return {string}
 */
Vector.prototype.toString = function() {};

/**
 * Converts current vector into a JavaScript array.
 * 
 * @return {!Array<number>}
 */
Vector.prototype.toArray = function() {};

/**
 * @constructor
 * @struct
 * \@method constructor
 * @desc Creates a `Matrix` from the supplied arguments.
 * 
 * @param {!Array<!Array<number>>} data
 * @param {?=} options
 */
function Matrix(data, options) {}
 /** @type {?} */
Matrix.prototype.T;
 /** @type {!Array<number>} */
Matrix.prototype.shape;

/**
 * @param {?} data
 * @param {!Array<number>} shape
 * @return {?}
 */
Matrix.fromTypedArray = function(data, shape) {};

/**
 * @param {!Array<!Array<number>>} data
 * @return {?}
 */
Matrix.fromArray = function(data) {};

/**
 * Static method. Adds two matrices `a` and `b` together.
 * 
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
Matrix.add = function(a, b) {};

/**
 * Adds `matrix` to current matrix.
 * 
 * @param {?} matrix
 * @return {?}
 */
Matrix.prototype.add = function(matrix) {};

/**
 * Static method. Subtracts the matrix `b` from matrix `a`.
 * 
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
Matrix.subtract = function(a, b) {};

/**
 * Subtracts `matrix` from current matrix.
 * 
 * @param {?} matrix
 * @return {?}
 */
Matrix.prototype.subtract = function(matrix) {};

/**
 * Static method. Multiplies all elements of a matrix `a` with a specified `scalar`.
 * 
 * @param {?} matrix
 * @param {number} scalar
 * @return {?}
 */
Matrix.scale = function(matrix, scalar) {};

/**
 * Multiplies all elements of current matrix with a specified `scalar`.
 * 
 * @param {number} scalar
 * @return {?}
 */
Matrix.prototype.scale = function(scalar) {};

/**
 * Static method. Hadamard product of matrices
 * 
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
Matrix.product = function(a, b) {};

/**
 * Hadamard product of matrices
 * 
 * @param {?} matrix
 * @return {?}
 */
Matrix.prototype.product = function(matrix) {};

/**
 * Static method. Creates an `i x j` matrix containing zeros (`0`), takes an
 * optional `type` argument which should be an instance of `TypedArray`.
 * 
 * @param {number} i
 * @param {number} j
 * @param {?=} type
 * @return {?}
 */
Matrix.zeros = function(i, j, type) {};

/**
 * Static method. Creates an `i x j` matrix containing ones (`1`), takes an
 * optional `type` argument which should be an instance of `TypedArray`.
 * 
 * @param {number} i
 * @param {number} j
 * @param {?=} type
 * @return {?}
 */
Matrix.ones = function(i, j, type) {};

/**
 * Static method. Creates an `i x j` matrix containing random values
 * according to a normal distribution, takes an optional `type` argument
 * which should be an instance of `TypedArray`.
 * 
 * @param {number} i
 * @param {number} j
 * @param {number=} deviation
 * @param {number=} mean
 * @param {?=} type
 * @return {?}
 */
Matrix.random = function(i, j, deviation, mean, type) {};

/**
 * Static method. Multiplies two matrices `a` and `b` of matching dimensions.
 * 
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
Matrix.multiply = function(a, b) {};

/**
 * Multiplies two matrices `a` and `b` of matching dimensions.
 * 
 * @param {?} matrix
 * @return {?}
 */
Matrix.prototype.multiply = function(matrix) {};

/**
 * Transposes a matrix (mirror across the diagonal).
 * 
 * @return {?}
 */
Matrix.prototype.transpose = function() {};

/**
 * Determines the inverse of any invertible square matrix using
 * Gaussian elimination.
 * 
 * @return {?}
 */
Matrix.prototype.inverse = function() {};

/**
 * Performs Gaussian elimination on a matrix.
 * 
 * @return {?}
 */
Matrix.prototype.gauss = function() {};

/**
 * Performs full LU decomposition on a matrix.
 * triangular resultant matrix `U` and the pivot array `ipiv`
 * 
 * @return {!Array<number>}
 */
Matrix.prototype.lu = function() {};

/**
 * Static method. Performs LU factorization on current matrix.
 * factorized and the corresponding pivot Int32Array
 * 
 * @param {?} matrix
 * @return {!Array<?>}
 */
Matrix.plu = function(matrix) {};

/**
 * Performs LU factorization on current matrix.
 * corresponding pivot Int32Array
 * 
 * @return {!Array<?>}
 */
Matrix.prototype.plu = function() {};

/**
 * Solves an LU factorized matrix with the supplied right hand side(s)
 * 
 * @param {?} rhs
 * @param {!Int32Array} ipiv
 * @return {?}
 */
Matrix.prototype.lusolve = function(rhs, ipiv) {};

/**
 * Solves AX = B using LU factorization, where A is the current matrix and
 * B is a Vector/Matrix containing the right hand side(s) of the equation.
 * 
 * @param {?} rhs
 * @return {?}
 */
Matrix.prototype.solve = function(rhs) {};

/**
 * Static method. Augments two matrices `a` and `b` of matching dimensions
 * (appends `b` to `a`).
 * 
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
Matrix.augment = function(a, b) {};

/**
 * Augments `matrix` with current matrix.
 * 
 * @param {?} matrix
 * @return {?}
 */
Matrix.prototype.augment = function(matrix) {};

/**
 * Static method. Creates an identity matrix of `size`, takes an optional `type` argument
 * which should be an instance of `TypedArray`.
 * 
 * @param {number} size
 * @param {?=} type
 * @return {?}
 */
Matrix.identity = function(size, type) {};

/**
 * Static method. Creates a magic square matrix of `size`, takes an optional `type` argument
 * which should be an instance of `TypedArray`.
 * 
 * @param {number} size
 * @param {?=} type
 * @return {?}
 */
Matrix.magic = function(size, type) {};

/**
 * Gets the diagonal of a matrix.
 * 
 * @return {?}
 */
Matrix.prototype.diag = function() {};

/**
 * Gets the determinant of any square matrix using LU factorization.
 * 
 * @return {number}
 */
Matrix.prototype.determinant = function() {};

/**
 * Gets the trace of the matrix (the sum of all diagonal elements).
 * 
 * @return {number}
 */
Matrix.prototype.trace = function() {};

/**
 * Static method. Checks the equality of two matrices `a` and `b`.
 * 
 * @param {?} a
 * @param {?} b
 * @return {boolean}
 */
Matrix.equals = function(a, b) {};

/**
 * Checks the equality of `matrix` and current matrix.
 * 
 * @param {?} matrix
 * @return {boolean}
 */
Matrix.prototype.equals = function(matrix) {};

/**
 * Gets the value of the element in row `i`, column `j` of current matrix
 * 
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
Matrix.prototype.get = function(i, j) {};

/**
 * Sets the element at row `i`, column `j` to value
 * 
 * @param {number} i
 * @param {number} j
 * @param {number} value
 * @return {?}
 */
Matrix.prototype.set = function(i, j, value) {};

/**
 * Swaps two rows `i` and `j` in a matrix
 * 
 * @param {number} i
 * @param {number} j
 * @return {?}
 */
Matrix.prototype.swap = function(i, j) {};

/**
 * Maps a function `callback` to all elements of a copy of current matrix.
 * 
 * @param {?} callback
 * @return {?}
 */
Matrix.prototype.map = function(callback) {};

/**
 * Functional version of for-looping the elements in a matrix, is
 * equivalent to `Array.prototype.forEach`.
 * 
 * @param {?} callback
 * @return {?}
 */
Matrix.prototype.each = function(callback) {};

/**
 * Equivalent to `TypedArray.prototype.reduce`.
 * 
 * @param {?} callback
 * @param {number=} initialValue
 * @return {number}
 */
Matrix.prototype.reduce = function(callback, initialValue) {};

/**
 * Finds the rank of the matrix using row echelon form
 * 
 * @return {number}
 */
Matrix.prototype.rank = function() {};

/**
 * Static method. Finds the rank of a matrix using row echelon form
 * 
 * @param {?} matrix
 * @return {number}
 */
Matrix.rank = function(matrix) {};

/**
 * Converts current matrix into a readable formatted string
 * 
 * @return {string}
 */
Matrix.prototype.toString = function() {};

/**
 * Converts current matrix into a two-dimensional array
 * 
 * @return {!Array<!Array<number>>}
 */
Matrix.prototype.toArray = function() {};
/**
 * @constructor
 * @struct
 */
function BLAS() {}
