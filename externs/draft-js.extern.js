/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/draft-js/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/** @typedef {!React.KeyboardEvent<!Object>} */
var SyntheticKeyboardEvent;

/** @typedef {!React.SyntheticEvent<!Object>} */
var SyntheticEvent;

/* TODO: NamespaceExportDeclaration in  */
/** @const */
var Draft = {};
/** @const */
Draft.Component = {};
/** @const */
Draft.Component.Base = {};

/* TODO: ImportEqualsDeclaration in Draft.Component.Base */

/* TODO: ImportEqualsDeclaration in Draft.Component.Base */

/* TODO: ImportEqualsDeclaration in Draft.Component.Base */

/* TODO: ImportEqualsDeclaration in Draft.Component.Base */

/* TODO: ImportEqualsDeclaration in Draft.Component.Base */

/* TODO: ImportEqualsDeclaration in Draft.Component.Base */

/* TODO: ImportEqualsDeclaration in Draft.Component.Base */

/* TODO: ImportEqualsDeclaration in Draft.Component.Base */

/* TODO: ImportEqualsDeclaration in Draft.Component.Base */

/** @typedef {?} */
Draft.Component.Base.DraftBlockRenderMap;

/** @typedef {string} */
Draft.Component.Base.EditorCommand;
/**
 * @extends {React.Component}
 * @constructor
 * @struct
 */
Draft.Component.Base.DraftEditor = function() {};

/**
 * @return {void}
 */
Draft.Component.Base.DraftEditor.prototype.focus = function() {};

/**
 * @return {void}
 */
Draft.Component.Base.DraftEditor.prototype.blur = function() {};
/**
 * @record
 * @struct
 */
Draft.Component.Base.DraftEditorProps = function() {};
 /** @type {!Draft.Model.ImmutableData.EditorState} */
Draft.Component.Base.DraftEditorProps.prototype.editorState;
 /** @type {string} */
Draft.Component.Base.DraftEditorProps.prototype.placeholder;
 /** @type {string} */
Draft.Component.Base.DraftEditorProps.prototype.textAlignment;
 /** @type {?} */
Draft.Component.Base.DraftEditorProps.prototype.customStyleMap;
 /** @type {function(?): !Object} */
Draft.Component.Base.DraftEditorProps.prototype.customStyleFn;
 /** @type {boolean} */
Draft.Component.Base.DraftEditorProps.prototype.readOnly;
 /** @type {boolean} */
Draft.Component.Base.DraftEditorProps.prototype.spellCheck;
 /** @type {boolean} */
Draft.Component.Base.DraftEditorProps.prototype.stripPastedStyles;
 /** @type {number} */
Draft.Component.Base.DraftEditorProps.prototype.tabIndex;
 /** @type {string} */
Draft.Component.Base.DraftEditorProps.prototype.autoCapitalize;
 /** @type {string} */
Draft.Component.Base.DraftEditorProps.prototype.autoComplete;
 /** @type {string} */
Draft.Component.Base.DraftEditorProps.prototype.autoCorrect;
 /** @type {string} */
Draft.Component.Base.DraftEditorProps.prototype.ariaActiveDescendantID;
 /** @type {string} */
Draft.Component.Base.DraftEditorProps.prototype.ariaAutoComplete;
 /** @type {string} */
Draft.Component.Base.DraftEditorProps.prototype.ariaDescribedBy;
 /** @type {boolean} */
Draft.Component.Base.DraftEditorProps.prototype.ariaExpanded;
 /** @type {boolean} */
Draft.Component.Base.DraftEditorProps.prototype.ariaHasPopup;
 /** @type {string} */
Draft.Component.Base.DraftEditorProps.prototype.ariaLabel;
 /** @type {string} */
Draft.Component.Base.DraftEditorProps.prototype.ariaOwneeID;
 /** @type {string} */
Draft.Component.Base.DraftEditorProps.prototype.webDriverTestID;
 /** @type {?} */
Draft.Component.Base.DraftEditorProps.prototype.blockRenderMap;

/**
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @return {void}
 */
Draft.Component.Base.DraftEditorProps.prototype.onChange = function(editorState) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentBlock} block
 * @return {?}
 */
Draft.Component.Base.DraftEditorProps.prototype.blockRendererFn = function(block) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentBlock} block
 * @return {string}
 */
Draft.Component.Base.DraftEditorProps.prototype.blockStyleFn = function(block) {};

/**
 * @param {!React.KeyboardEvent<!Object>} e
 * @return {string}
 */
Draft.Component.Base.DraftEditorProps.prototype.keyBindingFn = function(e) {};

/**
 * @param {!React.KeyboardEvent<!Object>} e
 * @return {string}
 */
Draft.Component.Base.DraftEditorProps.prototype.handleReturn = function(e) {};

/**
 * @param {string} command
 * @return {string}
 */
Draft.Component.Base.DraftEditorProps.prototype.handleKeyCommand = function(command) {};

/**
 * @param {string} chars
 * @return {string}
 */
Draft.Component.Base.DraftEditorProps.prototype.handleBeforeInput = function(chars) {};

/**
 * @param {string} text
 * @param {string=} html
 * @return {string}
 */
Draft.Component.Base.DraftEditorProps.prototype.handlePastedText = function(text, html) {};

/**
 * @param {!Array<!Blob>} files
 * @return {string}
 */
Draft.Component.Base.DraftEditorProps.prototype.handlePastedFiles = function(files) {};

/**
 * @param {!Draft.Model.ImmutableData.SelectionState} selection
 * @param {!Array<!Blob>} files
 * @return {string}
 */
Draft.Component.Base.DraftEditorProps.prototype.handleDroppedFiles = function(selection, files) {};

/**
 * @param {!Draft.Model.ImmutableData.SelectionState} selection
 * @param {!Object} dataTransfer
 * @param {string} isInternal
 * @return {string}
 */
Draft.Component.Base.DraftEditorProps.prototype.handleDrop = function(selection, dataTransfer, isInternal) {};

/**
 * Non-cancelable event triggers.
 * @param {!React.KeyboardEvent<!Object>} e
 * @return {void}
 */
Draft.Component.Base.DraftEditorProps.prototype.onEscape = function(e) {};

/**
 * @param {!React.KeyboardEvent<!Object>} e
 * @return {void}
 */
Draft.Component.Base.DraftEditorProps.prototype.onTab = function(e) {};

/**
 * @param {!React.KeyboardEvent<!Object>} e
 * @return {void}
 */
Draft.Component.Base.DraftEditorProps.prototype.onUpArrow = function(e) {};

/**
 * @param {!React.KeyboardEvent<!Object>} e
 * @return {void}
 */
Draft.Component.Base.DraftEditorProps.prototype.onDownArrow = function(e) {};

/**
 * @param {!React.SyntheticEvent<!Object>} e
 * @return {void}
 */
Draft.Component.Base.DraftEditorProps.prototype.onBlur = function(e) {};

/**
 * @param {!React.SyntheticEvent<!Object>} e
 * @return {void}
 */
Draft.Component.Base.DraftEditorProps.prototype.onFocus = function(e) {};

/** @typedef {string} */
Draft.Component.Base.DraftTextAlignment;
/** @const */
Draft.Component.Components = {};
/**
 * @extends {React.Component}
 * @constructor
 * @struct
 */
Draft.Component.Components.DraftEditorBlock = function() {};
/** @const */
Draft.Component.Selection = {};
/**
 * @record
 * @struct
 */
Draft.Component.Selection.FakeClientRect = function() {};
 /** @type {number} */
Draft.Component.Selection.FakeClientRect.prototype.left;
 /** @type {number} */
Draft.Component.Selection.FakeClientRect.prototype.width;
 /** @type {number} */
Draft.Component.Selection.FakeClientRect.prototype.right;
 /** @type {number} */
Draft.Component.Selection.FakeClientRect.prototype.top;
 /** @type {number} */
Draft.Component.Selection.FakeClientRect.prototype.bottom;
 /** @type {number} */
Draft.Component.Selection.FakeClientRect.prototype.height;

/**
 * Return the bounding ClientRect for the visible DOM selection, if any.
 * In cases where there are no selected ranges or the bounding rect is
 * temporarily invalid, return null.
 * @param {?} global
 * @return {!Draft.Component.Selection.FakeClientRect}
 */
Draft.Component.Selection.getVisibleSelectionRect = function(global) {};
/** @const */
Draft.Component.Utils = {};

/* TODO: ImportEqualsDeclaration in Draft.Component.Utils */
/**
 * @constructor
 * @struct
 */
Draft.Component.Utils.KeyBindingUtil = function() {};

/**
 * Check whether the ctrlKey modifier is *not* being used in conjunction with
 * the altKey modifier. If they are combined, the result is an `altGraph`
 * key modifier, which should not be handled by this set of key bindings.
 * @param {!React.KeyboardEvent<!Object>} e
 * @return {boolean}
 */
Draft.Component.Utils.KeyBindingUtil.isCtrlKeyCommand = function(e) {};

/**
 * @param {!React.KeyboardEvent<!Object>} e
 * @return {boolean}
 */
Draft.Component.Utils.KeyBindingUtil.isOptionKeyCommand = function(e) {};

/**
 * @param {!React.KeyboardEvent<!Object>} e
 * @return {boolean}
 */
Draft.Component.Utils.KeyBindingUtil.hasCommandModifier = function(e) {};

/**
 * Retrieve a bound key command for the given event.
 * @param {!React.KeyboardEvent<!Object>} e
 * @return {string}
 */
Draft.Component.Utils.getDefaultKeyBinding = function(e) {};
/** @const */
Draft.Model = {};
/** @const */
Draft.Model.Constants = {};

/** @typedef {string} */
Draft.Model.Constants.DraftEditorCommand;

/** @typedef {string} */
Draft.Model.Constants.DraftDragType;

/** @typedef {string} */
Draft.Model.Constants.DraftBlockType;

/** @typedef {string} */
Draft.Model.Constants.DraftRemovalDirection;

/** @typedef {string} */
Draft.Model.Constants.DraftHandleValue;
/** @const */
Draft.Model.Decorators = {};

/* TODO: ImportEqualsDeclaration in Draft.Model.Decorators */
/**
 * @record
 * @struct
 */
Draft.Model.Decorators.DraftDecoratorType = function() {};

/**
 * Given a `ContentBlock`, return an immutable List of decorator keys.
 * @param {!Draft.Model.ImmutableData.ContentBlock} block
 * @return {?}
 */
Draft.Model.Decorators.DraftDecoratorType.prototype.getDecorations = function(block) {};

/**
 * Given a decorator key, return the component to use when rendering
 * this decorated range.
 * @param {string} key
 * @return {!Function}
 */
Draft.Model.Decorators.DraftDecoratorType.prototype.getComponentForKey = function(key) {};

/**
 * Given a decorator key, optionally return the props to use when rendering
 * this decorated range.
 * @param {string} key
 * @return {?}
 */
Draft.Model.Decorators.DraftDecoratorType.prototype.getPropsForKey = function(key) {};
/**
 * @record
 * @struct
 */
Draft.Model.Decorators.DraftDecorator = function() {};
 /** @type {function(!Draft.Model.ImmutableData.ContentBlock, function(number, number): void, !Draft.Model.ImmutableData.ContentState): void} */
Draft.Model.Decorators.DraftDecorator.prototype.strategy;
 /** @type {!Function} */
Draft.Model.Decorators.DraftDecorator.prototype.component;
 /** @type {!Object} */
Draft.Model.Decorators.DraftDecorator.prototype.props;

/**
 * @constructor
 * @struct
 * @param {!Array<!Draft.Model.Decorators.DraftDecorator>} decorators
 */
Draft.Model.Decorators.CompositeDraftDecorator = function(decorators) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentBlock} block
 * @return {?}
 */
Draft.Model.Decorators.CompositeDraftDecorator.prototype.getDecorations = function(block) {};

/**
 * @param {string} key
 * @return {!Function}
 */
Draft.Model.Decorators.CompositeDraftDecorator.prototype.getComponentForKey = function(key) {};

/**
 * @param {string} key
 * @return {!Object}
 */
Draft.Model.Decorators.CompositeDraftDecorator.prototype.getPropsForKey = function(key) {};
/** @const */
Draft.Model.Encoding = {};

/* TODO: ImportEqualsDeclaration in Draft.Model.Encoding */

/* TODO: ImportEqualsDeclaration in Draft.Model.Encoding */

/* TODO: ImportEqualsDeclaration in Draft.Model.Encoding */

/* TODO: ImportEqualsDeclaration in Draft.Model.Encoding */

/* TODO: ImportEqualsDeclaration in Draft.Model.Encoding */

/* TODO: ImportEqualsDeclaration in Draft.Model.Encoding */
/**
 * @record
 * @struct
 */
Draft.Model.Encoding.EntityRange = function() {};
 /** @type {number} */
Draft.Model.Encoding.EntityRange.prototype.key;
 /** @type {number} */
Draft.Model.Encoding.EntityRange.prototype.offset;
 /** @type {number} */
Draft.Model.Encoding.EntityRange.prototype.length;
/**
 * @record
 * @struct
 */
Draft.Model.Encoding.InlineStyleRange = function() {};
 /** @type {string} */
Draft.Model.Encoding.InlineStyleRange.prototype.style;
 /** @type {number} */
Draft.Model.Encoding.InlineStyleRange.prototype.offset;
 /** @type {number} */
Draft.Model.Encoding.InlineStyleRange.prototype.length;
/**
 * @record
 * @struct
 */
Draft.Model.Encoding.RawDraftEntity = function() {};
 /** @type {string} */
Draft.Model.Encoding.RawDraftEntity.prototype.type;
 /** @type {string} */
Draft.Model.Encoding.RawDraftEntity.prototype.mutability;
 /** @type {!Object<string,?>} */
Draft.Model.Encoding.RawDraftEntity.prototype.data;
/**
 * @record
 * @struct
 */
Draft.Model.Encoding.RawDraftContentBlock = function() {};
 /** @type {string} */
Draft.Model.Encoding.RawDraftContentBlock.prototype.key;
 /** @type {string} */
Draft.Model.Encoding.RawDraftContentBlock.prototype.type;
 /** @type {string} */
Draft.Model.Encoding.RawDraftContentBlock.prototype.text;
 /** @type {number} */
Draft.Model.Encoding.RawDraftContentBlock.prototype.depth;
 /** @type {!Array<!Draft.Model.Encoding.InlineStyleRange>} */
Draft.Model.Encoding.RawDraftContentBlock.prototype.inlineStyleRanges;
 /** @type {!Array<!Draft.Model.Encoding.EntityRange>} */
Draft.Model.Encoding.RawDraftContentBlock.prototype.entityRanges;
 /** @type {!Object} */
Draft.Model.Encoding.RawDraftContentBlock.prototype.data;
/**
 * @record
 * @struct
 */
Draft.Model.Encoding.RawDraftContentState = function() {};
 /** @type {!Array<!Draft.Model.Encoding.RawDraftContentBlock>} */
Draft.Model.Encoding.RawDraftContentState.prototype.blocks;
 /** @type {!Object<string,!Draft.Model.Encoding.RawDraftEntity>} */
Draft.Model.Encoding.RawDraftContentState.prototype.entityMap;

/**
 * @param {string} html
 * @param {!Function=} DOMBuilder
 * @param {?=} blockRenderMap
 * @return {{contentBlocks: !Array<!Draft.Model.ImmutableData.ContentBlock>, entityMap: ?}}
 */
Draft.Model.Encoding.convertFromHTMLtoContentBlocks = function(html, DOMBuilder, blockRenderMap) {};

/**
 * @param {!Draft.Model.Encoding.RawDraftContentState} rawState
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.Encoding.convertFromRawToDraftState = function(rawState) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @return {!Draft.Model.Encoding.RawDraftContentState}
 */
Draft.Model.Encoding.convertFromDraftStateToRaw = function(contentState) {};
/** @const */
Draft.Model.Entity = {};

/** @typedef {string} */
Draft.Model.Entity.ComposedEntityType;

/** @typedef {string} */
Draft.Model.Entity.DraftEntityType;

/** @typedef {string} */
Draft.Model.Entity.DraftEntityMutability;
/**
 * @constructor
 * @struct
 */
Draft.Model.Entity.DraftEntity = function() {};

/**
 * Create a DraftEntityInstance and store it for later retrieval.
 * 
 * A random key string will be generated and returned. This key may
 * be used to track the entity's usage in a ContentBlock, and for
 * retrieving data about the entity at render time.
 * @param {string} type
 * @param {string} mutability
 * @param {!Object=} data
 * @return {string}
 */
Draft.Model.Entity.DraftEntity.create = function(type, mutability, data) {};

/**
 * Add an existing DraftEntityInstance to the DraftEntity map. This is
 * useful when restoring instances from the server.
 * @param {!Draft.Model.Entity.DraftEntityInstance} instance
 * @return {string}
 */
Draft.Model.Entity.DraftEntity.add = function(instance) {};

/**
 * Retrieve the entity corresponding to the supplied key string.
 * @param {string} key
 * @return {!Draft.Model.Entity.DraftEntityInstance}
 */
Draft.Model.Entity.DraftEntity.get = function(key) {};

/**
 * Entity instances are immutable. If you need to update the data for an
 * instance, this method will merge your data updates and return a new
 * instance.
 * @param {string} key
 * @param {!Object<string,?>} toMerge
 * @return {!Draft.Model.Entity.DraftEntityInstance}
 */
Draft.Model.Entity.DraftEntity.mergeData = function(key, toMerge) {};

/**
 * Completely replace the data for a given instance.
 * @param {string} key
 * @param {!Object<string,?>} newData
 * @return {!Draft.Model.Entity.DraftEntityInstance}
 */
Draft.Model.Entity.DraftEntity.replaceData = function(key, newData) {};
/**
 * @record
 * @struct
 */
Draft.Model.Entity.DraftEntityInstance = function() {};

/**
 * @return {string}
 */
Draft.Model.Entity.DraftEntityInstance.prototype.getType = function() {};

/**
 * @return {string}
 */
Draft.Model.Entity.DraftEntityInstance.prototype.getMutability = function() {};

/**
 * @return {?}
 */
Draft.Model.Entity.DraftEntityInstance.prototype.getData = function() {};
/** @const */
Draft.Model.ImmutableData = {};

/* TODO: ImportEqualsDeclaration in Draft.Model.ImmutableData */

/* TODO: ImportEqualsDeclaration in Draft.Model.ImmutableData */

/* TODO: ImportEqualsDeclaration in Draft.Model.ImmutableData */

/* TODO: ImportEqualsDeclaration in Draft.Model.ImmutableData */

/** @typedef {?} */
Draft.Model.ImmutableData.DraftInlineStyle;

/** @typedef {?} */
Draft.Model.ImmutableData.BlockMap;
 /** @type {?} */
Draft.Model.ImmutableData.Record;
/**
 * @record
 * @struct
 */
Draft.Model.ImmutableData.DraftBlockRenderConfig = function() {};
 /** @type {string} */
Draft.Model.ImmutableData.DraftBlockRenderConfig.prototype.element;
 /** @type {!React.ReactElement<?>} */
Draft.Model.ImmutableData.DraftBlockRenderConfig.prototype.wrapper;
/**
 * @constructor
 * @struct
 */
Draft.Model.ImmutableData.EditorState = function() {};

/**
 * @param {!Draft.Model.Decorators.DraftDecoratorType=} decorator
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.ImmutableData.EditorState.createEmpty = function(decorator) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @param {!Draft.Model.Decorators.DraftDecoratorType=} decorator
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.ImmutableData.EditorState.createWithContent = function(contentState, decorator) {};

/**
 * @param {!Object} config
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.ImmutableData.EditorState.create = function(config) {};

/**
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @param {!Object} put
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.ImmutableData.EditorState.set = function(editorState, put) {};

/**
 * Incorporate native DOM selection changes into the EditorState. This
 * method can be used when we simply want to accept whatever the DOM
 * has given us to represent selection, and we do not need to re-render
 * the editor.
 * 
 * To forcibly move the DOM selection, see `EditorState.forceSelection`.
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @param {!Draft.Model.ImmutableData.SelectionState} selection
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.ImmutableData.EditorState.acceptSelection = function(editorState, selection) {};

/**
 * At times, we need to force the DOM selection to be where we
 * need it to be. This can occur when the anchor or focus nodes
 * are non-text nodes, for instance. In this case, we want to trigger
 * a re-render of the editor, which in turn forces selection into
 * the correct place in the DOM. The `forceSelection` method
 * accomplishes this.
 * 
 * This method should be used in cases where you need to explicitly
 * move the DOM selection from one place to another without a change
 * in ContentState.
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @param {!Draft.Model.ImmutableData.SelectionState} selection
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.ImmutableData.EditorState.forceSelection = function(editorState, selection) {};

/**
 * Move selection to the end of the editor without forcing focus.
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.ImmutableData.EditorState.moveSelectionToEnd = function(editorState) {};

/**
 * Force focus to the end of the editor. This is useful in scenarios
 * where we want to programmatically focus the input and it makes sense
 * to allow the user to continue working seamlessly.
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.ImmutableData.EditorState.moveFocusToEnd = function(editorState) {};

/**
 * Push the current ContentState onto the undo stack if it should be
 * considered a boundary state, and set the provided ContentState as the
 * new current content.
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @param {string} changeType
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.ImmutableData.EditorState.push = function(editorState, contentState, changeType) {};

/**
 * Make the top ContentState in the undo stack the new current content and
 * push the current content onto the redo stack.
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.ImmutableData.EditorState.undo = function(editorState) {};

/**
 * Make the top ContentState in the redo stack the new current content and
 * push the current content onto the undo stack.
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.ImmutableData.EditorState.redo = function(editorState) {};

/**
 * @return {!Object}
 */
Draft.Model.ImmutableData.EditorState.prototype.toJS = function() {};

/**
 * @return {boolean}
 */
Draft.Model.ImmutableData.EditorState.prototype.getAllowUndo = function() {};

/**
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.ImmutableData.EditorState.prototype.getCurrentContent = function() {};

/**
 * @return {?}
 */
Draft.Model.ImmutableData.EditorState.prototype.getUndoStack = function() {};

/**
 * @return {?}
 */
Draft.Model.ImmutableData.EditorState.prototype.getRedoStack = function() {};

/**
 * @return {!Draft.Model.ImmutableData.SelectionState}
 */
Draft.Model.ImmutableData.EditorState.prototype.getSelection = function() {};

/**
 * @return {!Draft.Model.Decorators.DraftDecoratorType}
 */
Draft.Model.ImmutableData.EditorState.prototype.getDecorator = function() {};

/**
 * @return {boolean}
 */
Draft.Model.ImmutableData.EditorState.prototype.isInCompositionMode = function() {};

/**
 * @return {boolean}
 */
Draft.Model.ImmutableData.EditorState.prototype.mustForceSelection = function() {};

/**
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.ImmutableData.EditorState.prototype.getNativelyRenderedContent = function() {};

/**
 * @return {string}
 */
Draft.Model.ImmutableData.EditorState.prototype.getLastChangeType = function() {};

/**
 * While editing, the user may apply inline style commands with a collapsed
 * cursor, intending to type text that adopts the specified style. In this
 * case, we track the specified style as an "override" that takes precedence
 * over the inline style of the text adjacent to the cursor.
 * 
 * If null, there is no override in place.
 * @return {?}
 */
Draft.Model.ImmutableData.EditorState.prototype.getInlineStyleOverride = function() {};

/**
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @param {?} inlineStyleOverride
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.ImmutableData.EditorState.setInlineStyleOverride = function(editorState, inlineStyleOverride) {};

/**
 * Get the appropriate inline style for the editor state. If an
 * override is in place, use it. Otherwise, the current style is
 * based on the location of the selection state.
 * @return {?}
 */
Draft.Model.ImmutableData.EditorState.prototype.getCurrentInlineStyle = function() {};

/**
 * @param {string} blockKey
 * @return {?}
 */
Draft.Model.ImmutableData.EditorState.prototype.getBlockTree = function(blockKey) {};

/**
 * @return {boolean}
 */
Draft.Model.ImmutableData.EditorState.prototype.isSelectionAtStartOfContent = function() {};

/**
 * @return {boolean}
 */
Draft.Model.ImmutableData.EditorState.prototype.isSelectionAtEndOfContent = function() {};

/**
 * @return {?}
 */
Draft.Model.ImmutableData.EditorState.prototype.getDirectionMap = function() {};
/**
 * @constructor
 * @struct
 */
Draft.Model.ImmutableData.ContentBlock = function() {};

/**
 * @return {string}
 */
Draft.Model.ImmutableData.ContentBlock.prototype.getKey = function() {};

/**
 * @return {string}
 */
Draft.Model.ImmutableData.ContentBlock.prototype.getType = function() {};

/**
 * @return {string}
 */
Draft.Model.ImmutableData.ContentBlock.prototype.getText = function() {};

/**
 * @return {?}
 */
Draft.Model.ImmutableData.ContentBlock.prototype.getCharacterList = function() {};

/**
 * @return {number}
 */
Draft.Model.ImmutableData.ContentBlock.prototype.getLength = function() {};

/**
 * @return {number}
 */
Draft.Model.ImmutableData.ContentBlock.prototype.getDepth = function() {};

/**
 * @return {?}
 */
Draft.Model.ImmutableData.ContentBlock.prototype.getData = function() {};

/**
 * @param {number} offset
 * @return {?}
 */
Draft.Model.ImmutableData.ContentBlock.prototype.getInlineStyleAt = function(offset) {};

/**
 * @param {number} offset
 * @return {string}
 */
Draft.Model.ImmutableData.ContentBlock.prototype.getEntityAt = function(offset) {};

/**
 * Execute a callback for every contiguous range of styles within the block.
 * @param {function(!Draft.Model.ImmutableData.CharacterMetadata): boolean} filterFn
 * @param {function(number, number): void} callback
 * @return {void}
 */
Draft.Model.ImmutableData.ContentBlock.prototype.findStyleRanges = function(filterFn, callback) {};

/**
 * Execute a callback for every contiguous range of entities within the block.
 * @param {function(!Draft.Model.ImmutableData.CharacterMetadata): boolean} filterFn
 * @param {function(number, number): void} callback
 * @return {void}
 */
Draft.Model.ImmutableData.ContentBlock.prototype.findEntityRanges = function(filterFn, callback) {};
/**
 * @constructor
 * @struct
 */
Draft.Model.ImmutableData.ContentState = function() {};

/**
 * @param {!Array<!Draft.Model.ImmutableData.ContentBlock>} blocks
 * @param {?} entityMap
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.ImmutableData.ContentState.createFromBlockArray = function(blocks, entityMap) {};

/**
 * @param {string} text
 * @param {string=} delimiter
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.ImmutableData.ContentState.createFromText = function(text, delimiter) {};

/**
 * @param {string} type
 * @param {string} mutability
 * @param {!Object=} data
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.ImmutableData.ContentState.prototype.createEntity = function(type, mutability, data) {};

/**
 * @param {string} key
 * @return {!Draft.Model.Entity.DraftEntityInstance}
 */
Draft.Model.ImmutableData.ContentState.prototype.getEntity = function(key) {};

/**
 * @return {string}
 */
Draft.Model.ImmutableData.ContentState.prototype.getLastCreatedEntityKey = function() {};

/**
 * @param {string} key
 * @param {!Object<string,?>} toMerge
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.ImmutableData.ContentState.prototype.mergeEntityData = function(key, toMerge) {};

/**
 * @return {?}
 */
Draft.Model.ImmutableData.ContentState.prototype.getBlockMap = function() {};

/**
 * @return {!Draft.Model.ImmutableData.SelectionState}
 */
Draft.Model.ImmutableData.ContentState.prototype.getSelectionBefore = function() {};

/**
 * @return {!Draft.Model.ImmutableData.SelectionState}
 */
Draft.Model.ImmutableData.ContentState.prototype.getSelectionAfter = function() {};

/**
 * @param {string} key
 * @return {!Draft.Model.ImmutableData.ContentBlock}
 */
Draft.Model.ImmutableData.ContentState.prototype.getBlockForKey = function(key) {};

/**
 * @param {string} key
 * @return {string}
 */
Draft.Model.ImmutableData.ContentState.prototype.getKeyBefore = function(key) {};

/**
 * @param {string} key
 * @return {string}
 */
Draft.Model.ImmutableData.ContentState.prototype.getKeyAfter = function(key) {};

/**
 * @param {string} key
 * @return {!Draft.Model.ImmutableData.ContentBlock}
 */
Draft.Model.ImmutableData.ContentState.prototype.getBlockAfter = function(key) {};

/**
 * @param {string} key
 * @return {!Draft.Model.ImmutableData.ContentBlock}
 */
Draft.Model.ImmutableData.ContentState.prototype.getBlockBefore = function(key) {};

/**
 * @return {!Array<!Draft.Model.ImmutableData.ContentBlock>}
 */
Draft.Model.ImmutableData.ContentState.prototype.getBlocksAsArray = function() {};

/**
 * @return {!Draft.Model.ImmutableData.ContentBlock}
 */
Draft.Model.ImmutableData.ContentState.prototype.getFirstBlock = function() {};

/**
 * @return {!Draft.Model.ImmutableData.ContentBlock}
 */
Draft.Model.ImmutableData.ContentState.prototype.getLastBlock = function() {};

/**
 * @param {string=} delimiter
 * @return {string}
 */
Draft.Model.ImmutableData.ContentState.prototype.getPlainText = function(delimiter) {};

/**
 * @return {boolean}
 */
Draft.Model.ImmutableData.ContentState.prototype.hasText = function() {};
/**
 * @constructor
 * @struct
 */
Draft.Model.ImmutableData.SelectionState = function() {};

/**
 * @param {string} key
 * @return {!Draft.Model.ImmutableData.SelectionState}
 */
Draft.Model.ImmutableData.SelectionState.createEmpty = function(key) {};

/**
 * @return {string}
 */
Draft.Model.ImmutableData.SelectionState.prototype.serialize = function() {};

/**
 * @return {string}
 */
Draft.Model.ImmutableData.SelectionState.prototype.getAnchorKey = function() {};

/**
 * @return {number}
 */
Draft.Model.ImmutableData.SelectionState.prototype.getAnchorOffset = function() {};

/**
 * @return {string}
 */
Draft.Model.ImmutableData.SelectionState.prototype.getFocusKey = function() {};

/**
 * @return {number}
 */
Draft.Model.ImmutableData.SelectionState.prototype.getFocusOffset = function() {};

/**
 * @return {boolean}
 */
Draft.Model.ImmutableData.SelectionState.prototype.getIsBackward = function() {};

/**
 * @return {boolean}
 */
Draft.Model.ImmutableData.SelectionState.prototype.getHasFocus = function() {};

/**
 * Return whether the specified range overlaps with an edge of the
 * SelectionState.
 * @param {string} blockKey
 * @param {number} start
 * @param {number} end
 * @return {boolean}
 */
Draft.Model.ImmutableData.SelectionState.prototype.hasEdgeWithin = function(blockKey, start, end) {};

/**
 * @return {boolean}
 */
Draft.Model.ImmutableData.SelectionState.prototype.isCollapsed = function() {};

/**
 * @return {string}
 */
Draft.Model.ImmutableData.SelectionState.prototype.getStartKey = function() {};

/**
 * @return {number}
 */
Draft.Model.ImmutableData.SelectionState.prototype.getStartOffset = function() {};

/**
 * @return {string}
 */
Draft.Model.ImmutableData.SelectionState.prototype.getEndKey = function() {};

/**
 * @return {number}
 */
Draft.Model.ImmutableData.SelectionState.prototype.getEndOffset = function() {};
/**
 * @constructor
 * @struct
 */
Draft.Model.ImmutableData.CharacterMetadata = function() {};

/**
 * @param {!Draft.Model.ImmutableData.CharacterMetadata} record
 * @param {string} style
 * @return {!Draft.Model.ImmutableData.CharacterMetadata}
 */
Draft.Model.ImmutableData.CharacterMetadata.applyStyle = function(record, style) {};

/**
 * @param {!Draft.Model.ImmutableData.CharacterMetadata} record
 * @param {string} style
 * @return {!Draft.Model.ImmutableData.CharacterMetadata}
 */
Draft.Model.ImmutableData.CharacterMetadata.removeStyle = function(record, style) {};

/**
 * @param {!Draft.Model.ImmutableData.CharacterMetadata} record
 * @param {string=} entityKey
 * @return {!Draft.Model.ImmutableData.CharacterMetadata}
 */
Draft.Model.ImmutableData.CharacterMetadata.applyEntity = function(record, entityKey) {};

/**
 * Use this function instead of the `CharacterMetadata` constructor.
 * Since most content generally uses only a very small number of
 * style/entity permutations, we can reuse these objects as often as
 * possible.
 * @param {!Draft.Model.ImmutableData.CharacterMetadataConfig=} config
 * @return {!Draft.Model.ImmutableData.CharacterMetadata}
 */
Draft.Model.ImmutableData.CharacterMetadata.create = function(config) {};

/**
 * @return {?}
 */
Draft.Model.ImmutableData.CharacterMetadata.prototype.getStyle = function() {};

/**
 * @return {string}
 */
Draft.Model.ImmutableData.CharacterMetadata.prototype.getEntity = function() {};

/**
 * @param {string} style
 * @return {boolean}
 */
Draft.Model.ImmutableData.CharacterMetadata.prototype.hasStyle = function(style) {};
/**
 * @record
 * @struct
 */
Draft.Model.ImmutableData.CharacterMetadataConfig = function() {};
 /** @type {?} */
Draft.Model.ImmutableData.CharacterMetadataConfig.prototype.style;
 /** @type {string} */
Draft.Model.ImmutableData.CharacterMetadataConfig.prototype.entity;

/** @typedef {string} */
Draft.Model.ImmutableData.EditorChangeType;
/**
 * @record
 * @struct
 */
Draft.Model.ImmutableData.BlockMapBuilder = function() {};

/**
 * @param {!Array<!Draft.Model.ImmutableData.ContentBlock>} blocks
 * @return {?}
 */
Draft.Model.ImmutableData.BlockMapBuilder.prototype.createFromArray = function(blocks) {};
 /** @type {?} */
Draft.Model.ImmutableData.DefaultDraftBlockRenderMap;
 /** @type {?} */
Draft.Model.ImmutableData.DefaultDraftInlineStyle;
/** @const */
Draft.Model.Keys = {};

/**
 * @return {string}
 */
Draft.Model.Keys.generateRandomKey = function() {};
/** @const */
Draft.Model.Modifier = {};

/* TODO: ImportEqualsDeclaration in Draft.Model.Modifier */

/* TODO: ImportEqualsDeclaration in Draft.Model.Modifier */

/* TODO: ImportEqualsDeclaration in Draft.Model.Modifier */

/* TODO: ImportEqualsDeclaration in Draft.Model.Modifier */

/* TODO: ImportEqualsDeclaration in Draft.Model.Modifier */

/* TODO: ImportEqualsDeclaration in Draft.Model.Modifier */

/* TODO: ImportEqualsDeclaration in Draft.Model.Modifier */

/* TODO: ImportEqualsDeclaration in Draft.Model.Modifier */

/** @typedef {?} */
Draft.Model.Modifier.URI;
/**
 * @constructor
 * @struct
 */
Draft.Model.Modifier.AtomicBlockUtils = function() {};

/**
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @param {string} entityKey
 * @param {string} character
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.Modifier.AtomicBlockUtils.insertAtomicBlock = function(editorState, entityKey, character) {};
/**
 * @constructor
 * @struct
 */
Draft.Model.Modifier.DraftModifier = function() {};

/**
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @param {!Draft.Model.ImmutableData.SelectionState} rangeToReplace
 * @param {string} text
 * @param {?=} inlineStyle
 * @param {string=} entityKey
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.Modifier.DraftModifier.replaceText = function(contentState, rangeToReplace, text, inlineStyle, entityKey) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @param {!Draft.Model.ImmutableData.SelectionState} targetRange
 * @param {string} text
 * @param {?=} inlineStyle
 * @param {string=} entityKey
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.Modifier.DraftModifier.insertText = function(contentState, targetRange, text, inlineStyle, entityKey) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @param {!Draft.Model.ImmutableData.SelectionState} removalRange
 * @param {!Draft.Model.ImmutableData.SelectionState} targetRange
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.Modifier.DraftModifier.moveText = function(contentState, removalRange, targetRange) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @param {!Draft.Model.ImmutableData.SelectionState} targetRange
 * @param {?} fragment
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.Modifier.DraftModifier.replaceWithFragment = function(contentState, targetRange, fragment) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @param {!Draft.Model.ImmutableData.SelectionState} rangeToRemove
 * @param {string} removalDirection
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.Modifier.DraftModifier.removeRange = function(contentState, rangeToRemove, removalDirection) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @param {!Draft.Model.ImmutableData.SelectionState} selectionState
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.Modifier.DraftModifier.splitBlock = function(contentState, selectionState) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @param {!Draft.Model.ImmutableData.SelectionState} selectionState
 * @param {string} inlineStyle
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.Modifier.DraftModifier.applyInlineStyle = function(contentState, selectionState, inlineStyle) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @param {!Draft.Model.ImmutableData.SelectionState} selectionState
 * @param {string} inlineStyle
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.Modifier.DraftModifier.removeInlineStyle = function(contentState, selectionState, inlineStyle) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @param {!Draft.Model.ImmutableData.SelectionState} selectionState
 * @param {string} blockType
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.Modifier.DraftModifier.setBlockType = function(contentState, selectionState, blockType) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @param {!Draft.Model.ImmutableData.SelectionState} selectionState
 * @param {?} blockData
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.Modifier.DraftModifier.setBlockData = function(contentState, selectionState, blockData) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @param {!Draft.Model.ImmutableData.SelectionState} selectionState
 * @param {?} blockData
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.Modifier.DraftModifier.mergeBlockData = function(contentState, selectionState, blockData) {};

/**
 * @param {!Draft.Model.ImmutableData.ContentState} contentState
 * @param {!Draft.Model.ImmutableData.SelectionState} selectionState
 * @param {string} entityKey
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.Modifier.DraftModifier.applyEntity = function(contentState, selectionState, entityKey) {};
/**
 * @constructor
 * @struct
 */
Draft.Model.Modifier.RichTextEditorUtil = function() {};

/**
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @return {boolean}
 */
Draft.Model.Modifier.RichTextEditorUtil.currentBlockContainsLink = function(editorState) {};

/**
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @return {string}
 */
Draft.Model.Modifier.RichTextEditorUtil.getCurrentBlockType = function(editorState) {};

/**
 * @param {?} uri
 * @return {!Object}
 */
Draft.Model.Modifier.RichTextEditorUtil.getDataObjectForLinkURL = function(uri) {};

/**
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @param {string} command
 * @return {!Draft.Model.ImmutableData.EditorState|null}
 */
Draft.Model.Modifier.RichTextEditorUtil.handleKeyCommand = function(editorState, command) {};

/**
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.Modifier.RichTextEditorUtil.insertSoftNewline = function(editorState) {};

/**
 * For collapsed selections at the start of styled blocks, backspace should
 * just remove the existing style.
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.Modifier.RichTextEditorUtil.onBackspace = function(editorState) {};

/**
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.Modifier.RichTextEditorUtil.onDelete = function(editorState) {};

/**
 * @param {!React.KeyboardEvent<!Object>} event
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @param {number} maxDepth
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.Modifier.RichTextEditorUtil.onTab = function(event, editorState, maxDepth) {};

/**
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @param {string} blockType
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.Modifier.RichTextEditorUtil.toggleBlockType = function(editorState, blockType) {};

/**
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.Modifier.RichTextEditorUtil.toggleCode = function(editorState) {};

/**
 * Toggle the specified inline style for the selection. If the
 * user's selection is collapsed, apply or remove the style for the
 * internal state. If it is not collapsed, apply the change directly
 * to the document state.
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @param {string} inlineStyle
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.Modifier.RichTextEditorUtil.toggleInlineStyle = function(editorState, inlineStyle) {};

/**
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @param {!Draft.Model.ImmutableData.SelectionState} targetSelection
 * @param {string} entityKey
 * @return {!Draft.Model.ImmutableData.EditorState}
 */
Draft.Model.Modifier.RichTextEditorUtil.toggleLink = function(editorState, targetSelection, entityKey) {};

/**
 * When a collapsed cursor is at the start of an empty styled block, allow
 * certain key commands (newline, backspace) to simply change the
 * style of the block instead of the default behavior.
 * @param {!Draft.Model.ImmutableData.EditorState} editorState
 * @return {!Draft.Model.ImmutableData.ContentState}
 */
Draft.Model.Modifier.RichTextEditorUtil.tryToRemoveBlockStyle = function(editorState) {};

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ExportDeclaration in  */
