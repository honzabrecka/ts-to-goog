/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/qunit v1/index.d.ts:
/**
 * @record
 * @struct
 */
function DoneCallbackObject() {}
 /** @type {number} */
DoneCallbackObject.prototype.failed;
 /** @type {number} */
DoneCallbackObject.prototype.passed;
 /** @type {number} */
DoneCallbackObject.prototype.total;
 /** @type {number} */
DoneCallbackObject.prototype.runtime;
/**
 * @record
 * @struct
 */
function LogCallbackObject() {}
 /** @type {boolean} */
LogCallbackObject.prototype.result;
 /** @type {!Object} */
LogCallbackObject.prototype.actual;
 /** @type {!Object} */
LogCallbackObject.prototype.expected;
 /** @type {string} */
LogCallbackObject.prototype.message;
 /** @type {string} */
LogCallbackObject.prototype.source;
/**
 * @record
 * @struct
 */
function ModuleStartCallbackObject() {}
 /** @type {string} */
ModuleStartCallbackObject.prototype.name;
/**
 * @record
 * @struct
 */
function ModuleDoneCallbackObject() {}
 /** @type {string} */
ModuleDoneCallbackObject.prototype.name;
 /** @type {number} */
ModuleDoneCallbackObject.prototype.failed;
 /** @type {number} */
ModuleDoneCallbackObject.prototype.passed;
 /** @type {number} */
ModuleDoneCallbackObject.prototype.total;
/**
 * @record
 * @struct
 */
function TestDoneCallbackObject() {}
 /** @type {string} */
TestDoneCallbackObject.prototype.name;
 /** @type {string} */
TestDoneCallbackObject.prototype.module;
 /** @type {number} */
TestDoneCallbackObject.prototype.failed;
 /** @type {number} */
TestDoneCallbackObject.prototype.passed;
 /** @type {number} */
TestDoneCallbackObject.prototype.total;
 /** @type {number} */
TestDoneCallbackObject.prototype.duration;
/**
 * @record
 * @struct
 */
function TestStartCallbackObject() {}
 /** @type {string} */
TestStartCallbackObject.prototype.name;
 /** @type {string} */
TestStartCallbackObject.prototype.module;
/**
 * @record
 * @struct
 */
function Config() {}
 /** @type {boolean} */
Config.prototype.altertitle;
 /** @type {boolean} */
Config.prototype.autostart;
 /** @type {!Object} */
Config.prototype.current;
 /** @type {boolean} */
Config.prototype.reorder;
 /** @type {boolean} */
Config.prototype.requireExpects;
 /** @type {number} */
Config.prototype.testTimeout;
 /** @type {!Array<!URLConfigItem>} */
Config.prototype.urlConfig;
 /** @type {?} */
Config.prototype.done;
/**
 * @record
 * @struct
 */
function URLConfigItem() {}
 /** @type {string} */
URLConfigItem.prototype.id;
 /** @type {string} */
URLConfigItem.prototype.label;
 /** @type {string} */
URLConfigItem.prototype.tooltip;
/**
 * @record
 * @struct
 */
function LifecycleObject() {}
 /** @type {function(!QUnitAssert): void} */
LifecycleObject.prototype.setup;
 /** @type {function(!QUnitAssert): void} */
LifecycleObject.prototype.teardown;
 /** @type {function(!QUnitAssert): void} */
LifecycleObject.prototype.beforeEach;
 /** @type {function(!QUnitAssert): void} */
LifecycleObject.prototype.afterEach;

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function QUnitAssert() {}
 /** @type {?} */
QUnitAssert.prototype.assert;
 /** @type {?} */
QUnitAssert.prototype.current_testEnvironment;
 /** @type {?} */
QUnitAssert.prototype.jsDump;

/**
 * Instruct QUnit to wait for an asynchronous operation.
 * 
 * When your test has any asynchronous exit points, call assert.async() to get a unique
 * resolution callback for each async operation. The callback returned from assert.async()
 * will throw an Error if is invoked more than once.
 * @return {function(): void}
 */
QUnitAssert.prototype.async = function() {};

/**
 * A deep recursive comparison assertion, working on primitive types, arrays, objects, 
 * regular expressions, dates and functions.
 * 
 * The deepEqual() assertion can be used just like equal() when comparing the value of 
 * objects, such that { key: value } is equal to { key: value }. For non-scalar values, 
 * identity will be disregarded by deepEqual.
 * 
 * @param {?} actual Object or Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
QUnitAssert.prototype.deepEqual = function(actual, expected, message) {};

/**
 * A non-strict comparison assertion, roughly equivalent to JUnit assertEquals.
 * 
 * The equal assertion uses the simple comparison operator (==) to compare the actual 
 * and expected arguments. When they are equal, the assertion passes: any; otherwise, it fails. 
 * When it fails, both actual and expected values are displayed in the test result, 
 * in addition to a given message.
 * 
 * @param {?} actual Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
QUnitAssert.prototype.equal = function(actual, expected, message) {};

/**
 * Specify how many assertions are expected to run within a test.
 * 
 * To ensure that an explicit number of assertions are run within any test, use 
 * expect( number ) to register an expected count. If the number of assertions 
 * run does not match the expected count, the test will fail.
 * 
 * @param {number} amount Number of assertions in this test.
 * @return {?}
 */
QUnitAssert.prototype.expect = function(amount) {};

/**
 * An inverted deep recursive comparison assertion, working on primitive types, 
 * arrays, objects, regular expressions, dates and functions.
 * 
 * The notDeepEqual() assertion can be used just like equal() when comparing the 
 * value of objects, such that { key: value } is equal to { key: value }. For non-scalar 
 * values, identity will be disregarded by notDeepEqual.
 * 
 * @param {?} actual Object or Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
QUnitAssert.prototype.notDeepEqual = function(actual, expected, message) {};

/**
 * A non-strict comparison assertion, checking for inequality.
 * 
 * The notEqual assertion uses the simple inverted comparison operator (!=) to compare 
 * the actual and expected arguments. When they aren't equal, the assertion passes: any; 
 * otherwise, it fails. When it fails, both actual and expected values are displayed 
 * in the test result, in addition to a given message.
 * 
 * @param {?} actual Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
QUnitAssert.prototype.notEqual = function(actual, expected, message) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} message
 * @return {?}
 */
QUnitAssert.prototype.notPropEqual = function(actual, expected, message) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} message
 * @return {?}
 */
QUnitAssert.prototype.propEqual = function(actual, expected, message) {};

/**
 * A non-strict comparison assertion, checking for inequality.
 * 
 * The notStrictEqual assertion uses the strict inverted comparison operator (!==) 
 * to compare the actual and expected arguments. When they aren't equal, the assertion 
 * passes: any; otherwise, it fails. When it fails, both actual and expected values are 
 * displayed in the test result, in addition to a given message.
 * 
 * @param {?} actual Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
QUnitAssert.prototype.notStrictEqual = function(actual, expected, message) {};

/**
 * A boolean assertion, equivalent to CommonJS’s assert.ok() and JUnit’s assertTrue(). 
 * Passes if the first argument is truthy.
 * 
 * The most basic assertion in QUnit, ok() requires just one argument. If the argument 
 * evaluates to true, the assertion passes; otherwise, it fails. If a second message 
 * argument is provided, it will be displayed in place of the result.
 * 
 * @param {?} state Expression being tested
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
QUnitAssert.prototype.ok = function(state, message) {};

/**
 * A strict type and value comparison assertion.
 * 
 * The strictEqual() assertion provides the most rigid comparison of type and value with 
 * the strict equality operator (===)
 * 
 * @param {?} actual Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
QUnitAssert.prototype.strictEqual = function(actual, expected, message) {};

/**
 * Assertion to test if a callback throws an exception when run.
 * 
 * When testing code that is expected to throw an exception based on a specific set of 
 * circumstances, use throws() to catch the error object for testing and comparison.
 * 
 * @param {function(): ?} block Function to execute
 * @param {?|string=} expected_or_message Error Object to compare / A short description of the assertion
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
QUnitAssert.prototype.throws = function(block, expected_or_message, message) {};

/**
 * Alias of throws.
 * 
 * In very few environments, like Closure Compiler, throws is considered a reserved word
 * and will cause an error. For that case, an alias is bundled called raises. It has the
 * same signature and behaviour, just a different name.
 * 
 * Alias of throws.
 * 
 * In very few environments, like Closure Compiler, throws is considered a reserved word
 * and will cause an error. For that case, an alias is bundled called raises. It has the
 * same signature and behaviour, just a different name.
 * 
 * @param {function(): ?} block Function to execute
 * @param {?|string=} expected_or_message Error Object to compare / A short description of the assertion
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
QUnitAssert.prototype.raises = function(block, expected_or_message, message) {};
/**
 * @extends {QUnitAssert}
 * @record
 * @struct
 */
function QUnitStatic() {}
 /** @type {!Config} */
QUnitStatic.prototype.config;

/**
 * Start running tests again after the testrunner was stopped. See stop().
 * 
 * When your async test has multiple exit points, call start() for the corresponding number of stop() increments.
 * 
 * @param {number=} decrement Optional argument to merge multiple start() calls into one. Use with multiple corrsponding stop() calls.
 * @return {?}
 */
QUnitStatic.prototype.start = function(decrement) {};

/**
 * Stop the testrunner to wait for async tests to run. Call start() to continue.
 * 
 * When your async test has multiple exit points, call stop() with the increment argument, corresponding to the number of start() calls you need.
 * 
 * On Blackberry 5.0, window.stop is a native read-only function. If you deal with that browser, use QUnit.stop() instead, which will work anywhere.
 * 
 * @param {number=} increment
 * @return {?}
 */
QUnitStatic.prototype.stop = function(increment) {};

/**
 * Register a callback to fire whenever the test suite begins.
 * 
 * QUnit.begin() is called once before running any tests. (a better would've been QUnit.start, 
 * but thats already in use elsewhere and can't be changed.)
 * 
 * @param {function(): ?} callback Callback to execute
 * @return {?}
 */
QUnitStatic.prototype.begin = function(callback) {};

/**
 * Register a callback to fire whenever the test suite ends.
 * 
 * @param {function(!DoneCallbackObject): ?} callback Callback to execute.
 * @return {?}
 */
QUnitStatic.prototype.done = function(callback) {};

/**
 * Register a callback to fire whenever an assertion completes.
 * 
 * This is one of several callbacks QUnit provides. Its intended for integration scenarios like 
 * PhantomJS or Jenkins. The properties of the details argument are listed below as options.
 * 
 * @param {function(!LogCallbackObject): ?} callback Callback to execute.
 * @return {?}
 */
QUnitStatic.prototype.log = function(callback) {};

/**
 * Register a callback to fire whenever a module ends.
 * 
 * @param {function(!ModuleDoneCallbackObject): ?} callback Callback to execute.
 * @return {?}
 */
QUnitStatic.prototype.moduleDone = function(callback) {};

/**
 * Register a callback to fire whenever a module begins.
 * 
 * @param {function(!ModuleStartCallbackObject): ?} callback Callback to execute.
 * @return {?}
 */
QUnitStatic.prototype.moduleStart = function(callback) {};

/**
 * Register a callback to fire whenever a test ends.
 * 
 * @param {function(!TestDoneCallbackObject): ?} callback Callback to execute.
 * @return {?}
 */
QUnitStatic.prototype.testDone = function(callback) {};

/**
 * Register a callback to fire whenever a test begins.
 * 
 * @param {function(!TestStartCallbackObject): ?} callback Callback to execute.
 * @return {?}
 */
QUnitStatic.prototype.testStart = function(callback) {};

/**
 * Add an asynchronous test to run. The test must include a call to start().
 * 
 * For testing asynchronous code, asyncTest will automatically stop the test runner 
 * and wait for your code to call start() to continue.
 * 
 * Add an asynchronous test to run. The test must include a call to start().
 * 
 * For testing asynchronous code, asyncTest will automatically stop the test runner 
 * and wait for your code to call start() to continue.
 * 
 * @param {string} name Title of unit being tested
 * @param {number|function(!QUnitAssert): ?} expected_or_test Number of assertions in this test / Function to close over assertions
 * @param {function(!QUnitAssert): ?=} test Function to close over assertions
 * @return {?}
 */
QUnitStatic.prototype.asyncTest = function(name, expected_or_test, test) {};

/**
 * Specify how many assertions are expected to run within a test.
 * 
 * To ensure that an explicit number of assertions are run within any test, use 
 * expect( number ) to register an expected count. If the number of assertions 
 * run does not match the expected count, the test will fail.
 * 
 * \@depricated since version 1.16
 * @param {number} amount Number of assertions in this test.
 * @return {?}
 */
QUnitStatic.prototype.expect = function(amount) {};

/**
 * Copy the properties defined by the mixin object into the target object.
 * 
 * This method will modify the target object to contain the "own" properties defined 
 * by the mixin. If the mixin object specifies the value of any attribute as undefined, 
 * this property will instead be removed from the target object.
 * 
 * @param {?} target An object whose properties are to be modified
 * @param {?} mixin An object describing which properties should be modified
 * @return {?}
 */
QUnitStatic.prototype.extend = function(target, mixin) {};

/**
 * Group related tests under a single label.
 * 
 * All tests that occur after a call to module() will be grouped into that module. 
 * The test names will all be preceded by the module name in the test results. 
 * You can then use that module name to select tests to run.
 * 
 * @param {string} name Label for this group of tests
 * @param {!LifecycleObject=} lifecycle Callbacks to run before and after each test
 * @return {?}
 */
QUnitStatic.prototype.module = function(name, lifecycle) {};

/**
 * Add a test to run.
 * 
 * When testing the most common, synchronous code, use test().
 * The assert argument to the callback contains all of QUnit's assertion methods. 
 * If you are avoiding using any of QUnit's globals, you can use the assert 
 * argument instead.
 * 
 * @param {string} title Title of unit being tested
 * @param {number|function(!QUnitAssert): ?} expected_or_test Number of assertions in this test / Function to close over assertions
 * @param {function(!QUnitAssert): ?=} test Function to close over assertions
 * @return {?}
 */
QUnitStatic.prototype.test = function(title, expected_or_test, test) {};

/**
 * https://github.com/jquery/qunit/blob/master/qunit/qunit.js#L1568
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
QUnitStatic.prototype.equiv = function(a, b) {};

/**
 * https://github.com/jquery/qunit/blob/master/qunit/qunit.js#L897
 * @param {?} result
 * @param {?} actual
 * @param {?} expected
 * @param {string} message
 * @return {?}
 */
QUnitStatic.prototype.push = function(result, actual, expected, message) {};

/**
 * https://github.com/jquery/qunit/blob/master/qunit/qunit.js#L839
 * @return {?}
 */
QUnitStatic.prototype.reset = function() {};

/**
 * A deep recursive comparison assertion, working on primitive types, arrays, objects, 
 * regular expressions, dates and functions.
 * 
 * The deepEqual() assertion can be used just like equal() when comparing the value of 
 * objects, such that { key: value } is equal to { key: value }. For non-scalar values, 
 * identity will be disregarded by deepEqual.
 * 
 * @param {?} actual Object or Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
function deepEqual(actual, expected, message) {}

/**
 * A non-strict comparison assertion, roughly equivalent to JUnit assertEquals.
 * 
 * The equal assertion uses the simple comparison operator (==) to compare the actual 
 * and expected arguments. When they are equal, the assertion passes: any; otherwise, it fails. 
 * When it fails, both actual and expected values are displayed in the test result, 
 * in addition to a given message.
 * 
 * @param {?} actual Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
function equal(actual, expected, message) {}

/**
 * An inverted deep recursive comparison assertion, working on primitive types, 
 * arrays, objects, regular expressions, dates and functions.
 * 
 * The notDeepEqual() assertion can be used just like equal() when comparing the 
 * value of objects, such that { key: value } is equal to { key: value }. For non-scalar 
 * values, identity will be disregarded by notDeepEqual.
 * 
 * @param {?} actual Object or Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
function notDeepEqual(actual, expected, message) {}

/**
 * A non-strict comparison assertion, checking for inequality.
 * 
 * The notEqual assertion uses the simple inverted comparison operator (!=) to compare 
 * the actual and expected arguments. When they aren't equal, the assertion passes; 
 * otherwise, it fails. When it fails, both actual and expected values are displayed 
 * in the test result, in addition to a given message.
 * 
 * @param {?} actual Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
function notEqual(actual, expected, message) {}

/**
 * A non-strict comparison assertion, checking for inequality.
 * 
 * The notStrictEqual assertion uses the strict inverted comparison operator (!==) 
 * to compare the actual and expected arguments. When they aren't equal, the assertion 
 * passes; otherwise, it fails. When it fails, both actual and expected values are 
 * displayed in the test result, in addition to a given message.
 * 
 * @param {?} actual Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
function notStrictEqual(actual, expected, message) {}

/**
 * A boolean assertion, equivalent to CommonJS’s assert.ok() and JUnit’s assertTrue(). 
 * Passes if the first argument is truthy.
 * 
 * The most basic assertion in QUnit, ok() requires just one argument. If the argument 
 * evaluates to true, the assertion passes; otherwise, it fails. If a second message 
 * argument is provided, it will be displayed in place of the result.
 * 
 * @param {?} state Expression being tested
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
function ok(state, message) {}

/**
 * A strict type and value comparison assertion.
 * 
 * The strictEqual() assertion provides the most rigid comparison of type and value with 
 * the strict equality operator (===)
 * 
 * @param {?} actual Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
function strictEqual(actual, expected, message) {}

/**
 * Assertion to test if a callback throws an exception when run.
 * 
 * When testing code that is expected to throw an exception based on a specific set of 
 * circumstances, use throws() to catch the error object for testing and comparison.
 * 
 * @param {function(): ?} block Function to execute
 * @param {?|string=} expected_or_message Error Object to compare / A short description of the assertion
 * @param {string=} message A short description of the assertion
 * @return {?}
 */
function throws(block, expected_or_message, message) {}

/**
 * Start running tests again after the testrunner was stopped. See stop().
 * 
 * When your async test has multiple exit points, call start() for the corresponding number of stop() increments.
 * 
 * @param {number=} decrement Optional argument to merge multiple start() calls into one. Use with multiple corrsponding stop() calls.
 * @return {?}
 */
function start(decrement) {}

/**
 * Register a callback to fire whenever the test suite begins.
 * 
 * QUnit.begin() is called once before running any tests. (a better would've been QUnit.start, 
 * but thats already in use elsewhere and can't be changed.)
 * 
 * @param {function(): ?} callback Callback to execute
 * @return {?}
 */
function begin(callback) {}

/**
 * Register a callback to fire whenever the test suite ends.
 * 
 * @param {function(!DoneCallbackObject): ?} callback Callback to execute.
 * @return {?}
 */
function done(callback) {}

/**
 * Register a callback to fire whenever an assertion completes.
 * 
 * This is one of several callbacks QUnit provides. Its intended for integration scenarios like 
 * PhantomJS or Jenkins. The properties of the details argument are listed below as options.
 * 
 * @param {function(!LogCallbackObject): ?} callback Callback to execute.
 * @return {?}
 */
function log(callback) {}

/**
 * Register a callback to fire whenever a module ends.
 * 
 * @param {function(!ModuleDoneCallbackObject): ?} callback Callback to execute.
 * @return {?}
 */
function moduleDone(callback) {}

/**
 * Register a callback to fire whenever a module begins.
 * 
 * @param {function(string): ?} callback Callback to execute.
 * @return {?}
 */
function moduleStart(callback) {}

/**
 * Register a callback to fire whenever a test ends.
 * 
 * @param {function(!TestDoneCallbackObject): ?} callback Callback to execute.
 * @return {?}
 */
function testDone(callback) {}

/**
 * Register a callback to fire whenever a test begins.
 * 
 * @param {function(!TestStartCallbackObject): ?} callback Callback to execute.
 * @return {?}
 */
function testStart(callback) {}

/**
 * Add an asynchronous test to run. The test must include a call to start().
 * 
 * For testing asynchronous code, asyncTest will automatically stop the test runner 
 * and wait for your code to call start() to continue.
 * 
 * Add an asynchronous test to run. The test must include a call to start().
 * 
 * For testing asynchronous code, asyncTest will automatically stop the test runner 
 * and wait for your code to call start() to continue.
 * 
 * @param {string} name Title of unit being tested
 * @param {?|function(!QUnitAssert): ?=} expected_or_test Number of assertions in this test / Function to close over assertions
 * @param {function(!QUnitAssert): ?=} test Function to close over assertions
 * @return {?}
 */
function asyncTest(name, expected_or_test, test) {}

/**
 * Specify how many assertions are expected to run within a test.
 * 
 * To ensure that an explicit number of assertions are run within any test, use 
 * expect( number ) to register an expected count. If the number of assertions 
 * run does not match the expected count, the test will fail.
 * 
 * \@depricated since version 1.16
 * @param {number} amount Number of assertions in this test.
 * @return {?}
 */
function expect(amount) {}

/**
 * Add a test to run.
 * 
 * When testing the most common, synchronous code, use test().
 * The assert argument to the callback contains all of QUnit's assertion methods. 
 * If you are avoiding using any of QUnit's globals, you can use the assert 
 * argument instead.
 * 
 * @param {string} title Title of unit being tested
 * @param {number|function(!QUnitAssert): ?} expected_or_test Number of assertions in this test / Function to close over assertions
 * @param {function(!QUnitAssert): ?=} test Function to close over assertions
 * @return {?}
 */
function test(title, expected_or_test, test) {}

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} message
 * @return {?}
 */
function notPropEqual(actual, expected, message) {}

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} message
 * @return {?}
 */
function propEqual(actual, expected, message) {}

/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function equiv(a, b) {}
 /** @type {?} */
var raises;
 /** @type {!QUnitStatic} */
var QUnit;
