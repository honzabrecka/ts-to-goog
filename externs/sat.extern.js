/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/sat/index.d.ts:
/** @const */
var SAT = {};

/**
 * @constructor
 * @struct
 * @param {number} x
 * @param {number} y
 */
SAT.Vector = function(x, y) {};
 /** @type {number} */
SAT.Vector.prototype.x;
 /** @type {number} */
SAT.Vector.prototype.y;

/**
 * @param {!SAT.Vector} other
 * @return {!SAT.Vector}
 */
SAT.Vector.prototype.copy = function(other) {};

/**
 * @return {!SAT.Vector}
 */
SAT.Vector.prototype.clone = function() {};

/**
 * @return {!SAT.Vector}
 */
SAT.Vector.prototype.perp = function() {};

/**
 * @param {number} angle
 * @return {!SAT.Vector}
 */
SAT.Vector.prototype.rotate = function(angle) {};

/**
 * @return {!SAT.Vector}
 */
SAT.Vector.prototype.reverse = function() {};

/**
 * @return {!SAT.Vector}
 */
SAT.Vector.prototype.normalize = function() {};

/**
 * @param {!SAT.Vector} other
 * @return {!SAT.Vector}
 */
SAT.Vector.prototype.add = function(other) {};

/**
 * @param {!SAT.Vector} other
 * @return {!SAT.Vector}
 */
SAT.Vector.prototype.sub = function(other) {};

/**
 * @param {number} x
 * @param {number} y
 * @return {!SAT.Vector}
 */
SAT.Vector.prototype.scale = function(x, y) {};

/**
 * @param {!SAT.Vector} other
 * @return {!SAT.Vector}
 */
SAT.Vector.prototype.project = function(other) {};

/**
 * @param {!SAT.Vector} other
 * @return {!SAT.Vector}
 */
SAT.Vector.prototype.projectN = function(other) {};

/**
 * @param {!SAT.Vector} axis
 * @return {!SAT.Vector}
 */
SAT.Vector.prototype.reflect = function(axis) {};

/**
 * @param {!SAT.Vector} axis
 * @return {!SAT.Vector}
 */
SAT.Vector.prototype.reflectN = function(axis) {};

/**
 * @param {!SAT.Vector} other
 * @return {number}
 */
SAT.Vector.prototype.dot = function(other) {};

/**
 * @return {number}
 */
SAT.Vector.prototype.len2 = function() {};

/**
 * @return {number}
 */
SAT.Vector.prototype.len = function() {};

/**
 * @constructor
 * @struct
 * @param {!SAT.Vector} pos
 * @param {number} r
 */
SAT.Circle = function(pos, r) {};
 /** @type {!SAT.Vector} */
SAT.Circle.prototype.pos;
 /** @type {number} */
SAT.Circle.prototype.r;

/**
 * @constructor
 * @struct
 * @param {!SAT.Vector} pos
 * @param {!Array<!SAT.Vector>} points
 */
SAT.Polygon = function(pos, points) {};
 /** @type {!SAT.Vector} */
SAT.Polygon.prototype.pos;
 /** @type {!Array<!SAT.Vector>} */
SAT.Polygon.prototype.points;
 /** @type {number} */
SAT.Polygon.prototype.angle;
 /** @type {!SAT.Vector} */
SAT.Polygon.prototype.offset;
 /** @type {!Array<!SAT.Vector>} */
SAT.Polygon.prototype.calcPoints;
 /** @type {!Array<!SAT.Vector>} */
SAT.Polygon.prototype.edges;
 /** @type {!Array<!SAT.Vector>} */
SAT.Polygon.prototype.normals;

/**
 * @param {!Array<!SAT.Vector>} points
 * @return {!SAT.Polygon}
 */
SAT.Polygon.prototype.setPoints = function(points) {};

/**
 * @param {number} angle
 * @return {!SAT.Polygon}
 */
SAT.Polygon.prototype.setAngle = function(angle) {};

/**
 * @param {!SAT.Vector} offset
 * @return {!SAT.Polygon}
 */
SAT.Polygon.prototype.setOffset = function(offset) {};

/**
 * @return {!SAT.Polygon}
 */
SAT.Polygon.prototype.recalc = function() {};

/**
 * @param {number} angle
 * @return {!SAT.Polygon}
 */
SAT.Polygon.prototype.rotate = function(angle) {};

/**
 * @param {number} x
 * @param {number} y
 * @return {!SAT.Polygon}
 */
SAT.Polygon.prototype.translate = function(x, y) {};

/**
 * @return {!SAT.Polygon}
 */
SAT.Polygon.prototype.getAABB = function() {};

/**
 * @constructor
 * @struct
 * @param {!SAT.Vector} pos
 * @param {number} width
 * @param {number} height
 */
SAT.Box = function(pos, width, height) {};
 /** @type {!SAT.Vector} */
SAT.Box.prototype.pos;
 /** @type {number} */
SAT.Box.prototype.w;
 /** @type {number} */
SAT.Box.prototype.h;

/**
 * @return {!SAT.Polygon}
 */
SAT.Box.prototype.toPolygon = function() {};

/**
 * @constructor
 * @struct
 */
SAT.Response = function() {};
 /** @type {?} */
SAT.Response.prototype.a;
 /** @type {?} */
SAT.Response.prototype.b;
 /** @type {number} */
SAT.Response.prototype.overlap;
 /** @type {!SAT.Vector} */
SAT.Response.prototype.overlapN;
 /** @type {!SAT.Vector} */
SAT.Response.prototype.overlapV;
 /** @type {boolean} */
SAT.Response.prototype.aInB;
 /** @type {boolean} */
SAT.Response.prototype.bInA;

/**
 * @return {!SAT.Response}
 */
SAT.Response.prototype.clear = function() {};

/**
 * @param {!SAT.Vector} p
 * @param {!SAT.Circle} c
 * @return {boolean}
 */
SAT.pointInCircle = function(p, c) {};

/**
 * @param {!SAT.Vector} p
 * @param {!SAT.Polygon} poly
 * @return {boolean}
 */
SAT.pointInPolygon = function(p, poly) {};

/**
 * if a {response} is to be calculated in the event of a collision, pass in a cleared {Response} object.
 * @param {!SAT.Circle} a
 * @param {!SAT.Circle} b
 * @param {!SAT.Response=} response
 * @return {boolean}
 */
SAT.testCircleCircle = function(a, b, response) {};

/**
 * be calculated in the event of a collision, pass in a cleared {Response} object.
 * @param {!SAT.Polygon} polygon
 * @param {!SAT.Circle} circle
 * @param {!SAT.Response=} response
 * @return {boolean}
 */
SAT.testPolygonCircle = function(polygon, circle, response) {};

/**
 * be calculated in the event of a collision, pass in a cleared {Response} object.
 * @param {!SAT.Circle} circle
 * @param {!SAT.Polygon} polygon
 * @param {!SAT.Response=} response
 * @return {boolean}
 */
SAT.testCirclePolygon = function(circle, polygon, response) {};

/**
 * if a response is to be calculated in the event of a collision, pass in a cleared {Response} object.
 * @param {!SAT.Polygon} a
 * @param {!SAT.Polygon} b
 * @param {!SAT.Response=} response
 * @return {boolean}
 */
SAT.testPolygonPolygon = function(a, b, response) {};
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "sat"
/** @const */
tsickle_declare_module.sat = {};

/* TODO: ExportAssignment in tsickle_declare_module.sat */
