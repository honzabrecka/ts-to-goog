/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/maker.js/index.d.ts:
/** @const */
var MakerJs = {};
 /** @type {string} */
MakerJs.version;
 /** @type {{BrowserUI: string, NodeJs: string, WebWorker: string, Unknown: string}} */
MakerJs.environmentTypes;
 /** @type {string} */
MakerJs.environment;
 /** @type {{Centimeter: string, Foot: string, Inch: string, Meter: string, Millimeter: string}} */
MakerJs.unitType;

/**
 * Numeric rounding
 * 
 * Example: round to 3 decimal places
 * ```
 * makerjs.round(3.14159, .001); //returns 3.142
 * ```
 * 
 * @param {number} n The number to round off.
 * @param {number=} accuracy Optional exemplar of number of decimal places.
 * @return {number}
 */
MakerJs.round = function(n, accuracy) {};

/**
 * Create a string representation of a route array.
 * 
 * @param {!Array<string>} route Array of strings which are segments of a route.
 * @return {string} String of the flattened array.
 */
MakerJs.createRouteKey = function(route) {};

/**
 * Travel along a route inside of a model to extract a specific node in its tree.
 * 
 * @param {!MakerJs.IModel} modelContext Model to travel within.
 * @param {(string|!Array<string>)} routeKeyOrRoute String of a flattened route, or a string array of route segments.
 * @return {{path: (!MakerJs.IModel|!MakerJs.IPath), offset: !MakerJs.IPoint}} Model or Path object within the modelContext tree.
 */
MakerJs.travel = function(modelContext, routeKeyOrRoute) {};

/**
 * Clone an object.
 * 
 * @template T
 * @param {T} objectToClone The object to clone.
 * @return {T} A new clone of the original object.
 */
MakerJs.cloneObject = function(objectToClone) {};

/**
 * Copy the properties from one object to another object.
 * 
 * Example:
 * ```
 * makerjs.extendObject({ abc: 123 }, { xyz: 789 }); //returns { abc: 123, xyz: 789 }
 * ```
 * 
 * @param {!Object} target The object to extend. It will receive the new properties.
 * @param {!Object} other An object containing properties to merge in.
 * @return {!Object} The original object after merging.
 */
MakerJs.extendObject = function(target, other) {};

/**
 * Test to see if a variable is a function.
 * 
 * @param {?} value The object to test.
 * @return {boolean} True if the object is a function type.
 */
MakerJs.isFunction = function(value) {};

/**
 * Test to see if a variable is a number.
 * 
 * @param {?} value The object to test.
 * @return {boolean} True if the object is a number type.
 */
MakerJs.isNumber = function(value) {};

/**
 * Test to see if a variable is an object.
 * 
 * @param {?} value The object to test.
 * @return {boolean} True if the object is an object type.
 */
MakerJs.isObject = function(value) {};
/**
 * @record
 * @struct
 */
MakerJs.IPoint = function() {};

/* TODO: IndexSignature: MakerJs */

/**
 * Test to see if an object implements the required properties of a point.
 * 
 * @param {?} item The item to test.
 * @return {boolean}
 */
MakerJs.isPoint = function(item) {};
/**
 * @record
 * @struct
 */
MakerJs.IMeasure = function() {};
 /** @type {!MakerJs.IPoint} */
MakerJs.IMeasure.prototype.low;
 /** @type {!MakerJs.IPoint} */
MakerJs.IMeasure.prototype.high;
/**
 * @extends {MakerJs.IMeasure}
 * @record
 * @struct
 */
MakerJs.IMeasureWithCenter = function() {};
 /** @type {!MakerJs.IPoint} */
MakerJs.IMeasureWithCenter.prototype.center;
/**
 * @record
 * @struct
 */
MakerJs.IMeasureMap = function() {};

/* TODO: IndexSignature: MakerJs */
/**
 * @record
 * @struct
 */
MakerJs.IPath = function() {};

/* TODO: PropertySignature: MakerJs."type" */
 /** @type {!MakerJs.IPoint} */
MakerJs.IPath.prototype.origin;
 /** @type {string} */
MakerJs.IPath.prototype.layer;

/**
 * Test to see if an object implements the required properties of a path.
 * 
 * @param {?} item The item to test.
 * @return {boolean}
 */
MakerJs.isPath = function(item) {};
/**
 * @extends {MakerJs.IPath}
 * @record
 * @struct
 */
MakerJs.IPathLine = function() {};
 /** @type {!MakerJs.IPoint} */
MakerJs.IPathLine.prototype.end;

/**
 * Test to see if an object implements the required properties of a line.
 * 
 * @param {?} item The item to test.
 * @return {boolean}
 */
MakerJs.isPathLine = function(item) {};
/**
 * @extends {MakerJs.IPath}
 * @record
 * @struct
 */
MakerJs.IPathCircle = function() {};
 /** @type {number} */
MakerJs.IPathCircle.prototype.radius;

/**
 * Test to see if an object implements the required properties of a circle.
 * 
 * @param {?} item The item to test.
 * @return {boolean}
 */
MakerJs.isPathCircle = function(item) {};
/**
 * @extends {MakerJs.IPathCircle}
 * @record
 * @struct
 */
MakerJs.IPathArc = function() {};
 /** @type {number} */
MakerJs.IPathArc.prototype.startAngle;
 /** @type {number} */
MakerJs.IPathArc.prototype.endAngle;

/**
 * Test to see if an object implements the required properties of an arc.
 * 
 * @param {?} item The item to test.
 * @return {boolean}
 */
MakerJs.isPathArc = function(item) {};
/**
 * @extends {MakerJs.IPathLine}
 * @record
 * @struct
 */
MakerJs.IPathBezierSeed = function() {};
 /** @type {!Array<!MakerJs.IPoint>} */
MakerJs.IPathBezierSeed.prototype.controls;
 /** @type {!MakerJs.IBezierRange} */
MakerJs.IPathBezierSeed.prototype.parentRange;
/**
 * @record
 * @struct
 */
MakerJs.IBezierRange = function() {};
 /** @type {number} */
MakerJs.IBezierRange.prototype.startT;
 /** @type {number} */
MakerJs.IBezierRange.prototype.endT;
/**
 * @extends {MakerJs.IPathArc}
 * @record
 * @struct
 */
MakerJs.IPathArcInBezierCurve = function() {};
 /** @type {!MakerJs.IBezierRange} */
MakerJs.IPathArcInBezierCurve.prototype.bezierData;

/**
 * Test to see if an object implements the required properties of an arc in a bezier curve.
 * 
 * @param {?} item The item to test.
 * @return {boolean}
 */
MakerJs.isPathArcInBezierCurve = function(item) {};
/**
 * @record
 * @struct
 */
MakerJs.IPathFunctionMap = function() {};

/* TODO: IndexSignature: MakerJs */
/**
 * @record
 * @struct
 */
MakerJs.IPathOriginFunctionMap = function() {};

/* TODO: IndexSignature: MakerJs */
 /** @type {{Line: string, Circle: string, Arc: string, BezierSeed: string}} */
MakerJs.pathType;
/**
 * @record
 * @struct
 */
MakerJs.ISlope = function() {};
 /** @type {boolean} */
MakerJs.ISlope.prototype.hasSlope;
 /** @type {number} */
MakerJs.ISlope.prototype.slope;
 /** @type {!MakerJs.IPathLine} */
MakerJs.ISlope.prototype.line;
 /** @type {number} */
MakerJs.ISlope.prototype.yIntercept;
/**
 * @record
 * @struct
 */
MakerJs.IPathIntersectionBaseOptions = function() {};
 /** @type {boolean} */
MakerJs.IPathIntersectionBaseOptions.prototype.excludeTangents;
 /** @type {boolean} */
MakerJs.IPathIntersectionBaseOptions.prototype.out_AreOverlapped;
/**
 * @extends {MakerJs.IPathIntersectionBaseOptions}
 * @record
 * @struct
 */
MakerJs.IPathIntersectionOptions = function() {};
 /** @type {!MakerJs.IPoint} */
MakerJs.IPathIntersectionOptions.prototype.path1Offset;
 /** @type {!MakerJs.IPoint} */
MakerJs.IPathIntersectionOptions.prototype.path2Offset;
/**
 * @record
 * @struct
 */
MakerJs.IPathIntersection = function() {};
 /** @type {!Array<!MakerJs.IPoint>} */
MakerJs.IPathIntersection.prototype.intersectionPoints;
 /** @type {!Array<number>} */
MakerJs.IPathIntersection.prototype.path1Angles;
 /** @type {!Array<number>} */
MakerJs.IPathIntersection.prototype.path2Angles;
/**
 * @record
 * @struct
 */
MakerJs.IPointMatchOptions = function() {};
 /** @type {number} */
MakerJs.IPointMatchOptions.prototype.pointMatchingDistance;
/**
 * @extends {MakerJs.IPointMatchOptions}
 * @record
 * @struct
 */
MakerJs.ICombineOptions = function() {};
 /** @type {boolean} */
MakerJs.ICombineOptions.prototype.trimDeadEnds;
 /** @type {!MakerJs.IPoint} */
MakerJs.ICombineOptions.prototype.farPoint;
 /** @type {!MakerJs.measure.Atlas} */
MakerJs.ICombineOptions.prototype.measureA;
 /** @type {!MakerJs.measure.Atlas} */
MakerJs.ICombineOptions.prototype.measureB;
/**
 * @extends {MakerJs.IPointMatchOptions}
 * @record
 * @struct
 */
MakerJs.IFindLoopsOptions = function() {};
 /** @type {boolean} */
MakerJs.IFindLoopsOptions.prototype.removeFromOriginal;
/**
 * @record
 * @struct
 */
MakerJs.ISimplifyOptions = function() {};
 /** @type {number} */
MakerJs.ISimplifyOptions.prototype.pointMatchingDistance;
 /** @type {number} */
MakerJs.ISimplifyOptions.prototype.scalarMatchingDistance;
/**
 * @extends {MakerJs.IPath}
 * @record
 * @struct
 */
MakerJs.IPathDirectional = function() {};
 /** @type {!Array<!MakerJs.IPoint>} */
MakerJs.IPathDirectional.prototype.endPoints;
 /** @type {boolean} */
MakerJs.IPathDirectional.prototype.reversed;
/**
 * @record
 * @struct
 */
MakerJs.IPathMap = function() {};

/* TODO: IndexSignature: MakerJs */
/**
 * @record
 * @struct
 */
MakerJs.IModelMap = function() {};

/* TODO: IndexSignature: MakerJs */
/**
 * @record
 * @struct
 */
MakerJs.IModel = function() {};
 /** @type {!MakerJs.IPoint} */
MakerJs.IModel.prototype.origin;

/* TODO: PropertySignature: MakerJs."type" */
 /** @type {!MakerJs.IPathMap} */
MakerJs.IModel.prototype.paths;
 /** @type {!MakerJs.IModelMap} */
MakerJs.IModel.prototype.models;
 /** @type {string} */
MakerJs.IModel.prototype.units;
 /** @type {string} */
MakerJs.IModel.prototype.notes;
 /** @type {string} */
MakerJs.IModel.prototype.layer;
 /** @type {!Object<string,?>} */
MakerJs.IModel.prototype.exporterOptions;
/**
 * @record
 * @struct
 */
MakerJs.IModelPathCallback = function() {};

/* TODO: CallSignature: MakerJs */

/**
 * Test to see if an object implements the required properties of a model.
 * @param {?} item
 * @return {boolean}
 */
MakerJs.isModel = function(item) {};
/**
 * @record
 * @struct
 */
MakerJs.IRefPathIdInModel = function() {};
 /** @type {!MakerJs.IModel} */
MakerJs.IRefPathIdInModel.prototype.modelContext;
 /** @type {string} */
MakerJs.IRefPathIdInModel.prototype.pathId;
/**
 * @record
 * @struct
 */
MakerJs.IRouteOffset = function() {};
 /** @type {string} */
MakerJs.IRouteOffset.prototype.layer;
 /** @type {!MakerJs.IPoint} */
MakerJs.IRouteOffset.prototype.offset;
 /** @type {!Array<string>} */
MakerJs.IRouteOffset.prototype.route;
 /** @type {string} */
MakerJs.IRouteOffset.prototype.routeKey;
/**
 * @extends {MakerJs.IRefPathIdInModel}
 * @extends {MakerJs.IRouteOffset}
 * @record
 * @struct
 */
MakerJs.IWalkPath = function() {};
 /** @type {!MakerJs.IPath} */
MakerJs.IWalkPath.prototype.pathContext;
/**
 * @record
 * @struct
 */
MakerJs.IWalkPathCallback = function() {};

/* TODO: CallSignature: MakerJs */
/**
 * @record
 * @struct
 */
MakerJs.IWalkPathBooleanCallback = function() {};

/* TODO: CallSignature: MakerJs */
/**
 * @record
 * @struct
 */
MakerJs.IChainLink = function() {};
 /** @type {!MakerJs.IWalkPath} */
MakerJs.IChainLink.prototype.walkedPath;
 /** @type {boolean} */
MakerJs.IChainLink.prototype.reversed;
 /** @type {!Array<!MakerJs.IPoint>} */
MakerJs.IChainLink.prototype.endPoints;
 /** @type {number} */
MakerJs.IChainLink.prototype.pathLength;
/**
 * @record
 * @struct
 */
MakerJs.IChain = function() {};
 /** @type {!Array<!MakerJs.IChainLink>} */
MakerJs.IChain.prototype.links;
 /** @type {boolean} */
MakerJs.IChain.prototype.endless;
 /** @type {number} */
MakerJs.IChain.prototype.pathLength;

/**
 * Test to see if an object implements the required properties of a chain.
 * 
 * @param {?} item The item to test.
 * @return {boolean}
 */
MakerJs.isChain = function(item) {};
/**
 * @record
 * @struct
 */
MakerJs.IChainCallback = function() {};

/* TODO: CallSignature: MakerJs */
/**
 * @extends {MakerJs.IPointMatchOptions}
 * @record
 * @struct
 */
MakerJs.IFindChainsOptions = function() {};
 /** @type {boolean} */
MakerJs.IFindChainsOptions.prototype.byLayers;
 /** @type {boolean} */
MakerJs.IFindChainsOptions.prototype.shallow;
/**
 * @record
 * @struct
 */
MakerJs.IRefModelInModel = function() {};
 /** @type {!MakerJs.IModel} */
MakerJs.IRefModelInModel.prototype.parentModel;
 /** @type {string} */
MakerJs.IRefModelInModel.prototype.childId;
 /** @type {!MakerJs.IModel} */
MakerJs.IRefModelInModel.prototype.childModel;
/**
 * @extends {MakerJs.IRefModelInModel}
 * @extends {MakerJs.IRouteOffset}
 * @record
 * @struct
 */
MakerJs.IWalkModel = function() {};
/**
 * @record
 * @struct
 */
MakerJs.IWalkModelCallback = function() {};

/* TODO: CallSignature: MakerJs */
/**
 * @record
 * @struct
 */
MakerJs.IWalkModelCancellableCallback = function() {};

/* TODO: CallSignature: MakerJs */
/**
 * @record
 * @struct
 */
MakerJs.IWalkOptions = function() {};
 /** @type {!MakerJs.IWalkPathCallback} */
MakerJs.IWalkOptions.prototype.onPath;
 /** @type {!MakerJs.IWalkModelCancellableCallback} */
MakerJs.IWalkOptions.prototype.beforeChildWalk;
 /** @type {!MakerJs.IWalkModelCallback} */
MakerJs.IWalkOptions.prototype.afterChildWalk;
/**
 * @record
 * @struct
 */
MakerJs.IMetaParameter = function() {};
 /** @type {string} */
MakerJs.IMetaParameter.prototype.title;
 /** @type {string} */
MakerJs.IMetaParameter.prototype.type;
 /** @type {number} */
MakerJs.IMetaParameter.prototype.min;
 /** @type {number} */
MakerJs.IMetaParameter.prototype.max;
 /** @type {number} */
MakerJs.IMetaParameter.prototype.step;
 /** @type {?} */
MakerJs.IMetaParameter.prototype.value;
/**
 * @record
 * @struct
 */
MakerJs.IKit = function() {};

/* TODO: ConstructSignature: MakerJs */
 /** @type {!Array<!MakerJs.IMetaParameter>} */
MakerJs.IKit.prototype.metaParameters;
 /** @type {string} */
MakerJs.IKit.prototype.notes;
/** @const */
MakerJs.angle = {};

/**
 * Ensures an angle is not greater than 360
 * 
 * \@retiurns Same polar angle but not greater than 360 degrees.
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number}
 */
MakerJs.angle.noRevolutions = function(angleInDegrees) {};

/**
 * Convert an angle from degrees to radians.
 * 
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
MakerJs.angle.toRadians = function(angleInDegrees) {};

/**
 * Convert an angle from radians to degrees.
 * 
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
MakerJs.angle.toDegrees = function(angleInRadians) {};

/**
 * Get an arc's end angle, ensured to be greater than its start angle.
 * 
 * @param {!MakerJs.IPathArc} arc An arc path object.
 * @return {number} End angle of arc.
 */
MakerJs.angle.ofArcEnd = function(arc) {};

/**
 * Get the angle in the middle of an arc's start and end angles.
 * 
 * @param {!MakerJs.IPathArc} arc An arc path object.
 * @param {number=} ratio Optional number between 0 and 1 specifying percentage between start and end angles. Default is .5
 * @return {number} Middle angle of arc.
 */
MakerJs.angle.ofArcMiddle = function(arc, ratio) {};

/**
 * Total angle of an arc between its start and end angles.
 * 
 * @param {!MakerJs.IPathArc} arc The arc to measure.
 * @return {number} Angle of arc.
 */
MakerJs.angle.ofArcSpan = function(arc) {};

/**
 * Angle of a line path.
 * 
 * @param {!MakerJs.IPathLine} line The line path to find the angle of.
 * @return {number} Angle of the line path, in degrees.
 */
MakerJs.angle.ofLineInDegrees = function(line) {};

/**
 * Angle of a line through a point, in degrees.
 * 
 * @param {!MakerJs.IPoint} origin Point of origin of the angle.
 * @param {!MakerJs.IPoint} pointToFindAngle The point to find the angle.
 * @return {number} Angle of the line throught the point, in degrees.
 */
MakerJs.angle.ofPointInDegrees = function(origin, pointToFindAngle) {};

/**
 * Angle of a line through a point, in radians.
 * 
 * @param {!MakerJs.IPoint} origin Point of origin of the angle.
 * @param {!MakerJs.IPoint} pointToFindAngle The point to find the angle.
 * @return {number} Angle of the line throught the point, in radians.
 */
MakerJs.angle.ofPointInRadians = function(origin, pointToFindAngle) {};

/**
 * Mirror an angle on either or both x and y axes.
 * 
 * @param {number} angleInDegrees The angle to mirror.
 * @param {boolean} mirrorX Boolean to mirror on the x axis.
 * @param {boolean} mirrorY Boolean to mirror on the y axis.
 * @return {number} Mirrored angle.
 */
MakerJs.angle.mirror = function(angleInDegrees, mirrorX, mirrorY) {};
/** @const */
MakerJs.point = {};

/**
 * Add two points together and return the result as a new point object.
 * 
 * @param {!MakerJs.IPoint} a First point.
 * @param {!MakerJs.IPoint} b Second point.
 * @param {boolean=} subtract Optional boolean to subtract instead of add.
 * @return {!MakerJs.IPoint} A new point object.
 */
MakerJs.point.add = function(a, b, subtract) {};

/**
 * Get the average of two points.
 * 
 * @param {!MakerJs.IPoint} a First point.
 * @param {!MakerJs.IPoint} b Second point.
 * @return {!MakerJs.IPoint} New point object which is the average of a and b.
 */
MakerJs.point.average = function(a, b) {};

/**
 * Clone a point into a new point.
 * 
 * @param {!MakerJs.IPoint} pointToClone The point to clone.
 * @return {!MakerJs.IPoint} A new point with same values as the original.
 */
MakerJs.point.clone = function(pointToClone) {};

/**
 * From an array of points, find the closest point to a given reference point.
 * 
 * @param {!MakerJs.IPoint} referencePoint The reference point.
 * @param {!Array<!MakerJs.IPoint>} pointOptions Array of points to choose from.
 * @return {!MakerJs.IPoint} The first closest point from the pointOptions.
 */
MakerJs.point.closest = function(referencePoint, pointOptions) {};

/**
 * Get a point from its polar coordinates.
 * 
 * @param {number} angleInRadians The angle of the polar coordinate, in radians.
 * @param {number} radius The radius of the polar coordinate.
 * @return {!MakerJs.IPoint} A new point object.
 */
MakerJs.point.fromPolar = function(angleInRadians, radius) {};

/**
 * Get a point on a circle or arc path, at a given angle.
 * @param {number} angleInDegrees The angle at which you want to find the point, in degrees.
 * @param {!MakerJs.IPathCircle} circle A circle or arc.
 * @return {!MakerJs.IPoint} A new point object.
 */
MakerJs.point.fromAngleOnCircle = function(angleInDegrees, circle) {};

/**
 * Get the two end points of an arc path.
 * 
 * @param {!MakerJs.IPathArc} arc The arc path object.
 * @return {!Array<!MakerJs.IPoint>} Array with 2 elements: [0] is the point object corresponding to the start angle, [1] is the point object corresponding to the end angle.
 */
MakerJs.point.fromArc = function(arc) {};

/**
 * Get the two end points of a path.
 * 
 * @param {!MakerJs.IPath} pathContext The path object.
 * @param {!MakerJs.IPoint=} pathOffset
 * @return {!Array<!MakerJs.IPoint>} Array with 2 elements: [0] is the point object corresponding to the origin, [1] is the point object corresponding to the end.
 */
MakerJs.point.fromPathEnds = function(pathContext, pathOffset) {};

/**
 * Calculates the intersection of slopes of two lines.
 * 
 * @param {!MakerJs.IPathLine} lineA First line to use for slope.
 * @param {!MakerJs.IPathLine} lineB Second line to use for slope.
 * @param {!MakerJs.IPathIntersectionBaseOptions=} options Optional IPathIntersectionOptions.
 * @return {!MakerJs.IPoint} point of intersection of the two slopes, or null if the slopes did not intersect.
 */
MakerJs.point.fromSlopeIntersection = function(lineA, lineB, options) {};

/**
 * Get the middle point of a path.
 * 
 * @param {!MakerJs.IPath} pathContext The path object.
 * @param {number=} ratio Optional ratio (between 0 and 1) of point along the path. Default is .5 for middle.
 * @return {!MakerJs.IPoint} Point on the path, in the middle of the path.
 */
MakerJs.point.middle = function(pathContext, ratio) {};

/**
 * Create a clone of a point, mirrored on either or both x and y axes.
 * 
 * @param {!MakerJs.IPoint} pointToMirror The point to mirror.
 * @param {boolean} mirrorX Boolean to mirror on the x axis.
 * @param {boolean} mirrorY Boolean to mirror on the y axis.
 * @return {!MakerJs.IPoint} Mirrored point.
 */
MakerJs.point.mirror = function(pointToMirror, mirrorX, mirrorY) {};

/**
 * Round the values of a point.
 * 
 * @param {!MakerJs.IPoint} pointContext The point to serialize.
 * @param {number=} accuracy Optional exemplar number of decimal places.
 * @return {!MakerJs.IPoint} A new point with the values rounded.
 */
MakerJs.point.rounded = function(pointContext, accuracy) {};

/**
 * Rotate a point.
 * 
 * @param {!MakerJs.IPoint} pointToRotate The point to rotate.
 * @param {number} angleInDegrees The amount of rotation, in degrees.
 * @param {!MakerJs.IPoint=} rotationOrigin The center point of rotation.
 * @return {!MakerJs.IPoint} A new point.
 */
MakerJs.point.rotate = function(pointToRotate, angleInDegrees, rotationOrigin) {};

/**
 * Scale a point's coordinates.
 * 
 * @param {!MakerJs.IPoint} pointToScale The point to scale.
 * @param {number} scaleValue The amount of scaling.
 * @return {!MakerJs.IPoint} A new point.
 */
MakerJs.point.scale = function(pointToScale, scaleValue) {};

/**
 * Distort a point's coordinates.
 * 
 * @param {!MakerJs.IPoint} pointToDistort The point to distort.
 * @param {number} scaleX The amount of x scaling.
 * @param {number} scaleY The amount of y scaling.
 * @return {!MakerJs.IPoint} A new point.
 */
MakerJs.point.distort = function(pointToDistort, scaleX, scaleY) {};

/**
 * Subtract a point from another point, and return the result as a new point. Shortcut to Add(a, b, subtract = true).
 * 
 * @param {!MakerJs.IPoint} a First point.
 * @param {!MakerJs.IPoint} b Second point.
 * @return {!MakerJs.IPoint} A new point object.
 */
MakerJs.point.subtract = function(a, b) {};

/**
 * A point at 0,0 coordinates.
 * NOTE: It is important to call this as a method, with the empty parentheses.
 * 
 * @return {!MakerJs.IPoint} A new point.
 */
MakerJs.point.zero = function() {};
/** @const */
MakerJs.path = {};

/**
 * Create a clone of a path. This is faster than cloneObject.
 * 
 * @param {!MakerJs.IPath} pathToClone The path to clone.
 * @return {!MakerJs.IPath} Cloned path.
 */
MakerJs.path.clone = function(pathToClone) {};

/**
 * Create a clone of a path, mirrored on either or both x and y axes.
 * 
 * @param {!MakerJs.IPath} pathToMirror The path to mirror.
 * @param {boolean} mirrorX Boolean to mirror on the x axis.
 * @param {boolean} mirrorY Boolean to mirror on the y axis.
 * @return {!MakerJs.IPath} Mirrored path.
 */
MakerJs.path.mirror = function(pathToMirror, mirrorX, mirrorY) {};

/**
 * Move a path to an absolute point.
 * 
 * @param {!MakerJs.IPath} pathToMove The path to move.
 * @param {!MakerJs.IPoint} origin The new origin for the path.
 * @return {!MakerJs.IPath} The original path (for cascading).
 */
MakerJs.path.move = function(pathToMove, origin) {};

/**
 * Move a path's origin by a relative amount.
 * 
 * @param {!MakerJs.IPath} pathToMove The path to move.
 * @param {!MakerJs.IPoint} delta The x & y adjustments as a point object.
 * @param {boolean=} subtract Optional boolean to subtract instead of add.
 * @return {!MakerJs.IPath} The original path (for cascading).
 */
MakerJs.path.moveRelative = function(pathToMove, delta, subtract) {};

/**
 * Move some paths relatively during a task execution, then unmove them.
 * 
 * @param {!Array<!MakerJs.IPath>} pathsToMove The paths to move.
 * @param {!Array<!MakerJs.IPoint>} deltas The x & y adjustments as a point object array.
 * @param {!Function} task The function to call while the paths are temporarily moved.
 * @return {void}
 */
MakerJs.path.moveTemporary = function(pathsToMove, deltas, task) {};

/**
 * Rotate a path.
 * 
 * @param {!MakerJs.IPath} pathToRotate The path to rotate.
 * @param {number} angleInDegrees The amount of rotation, in degrees.
 * @param {!MakerJs.IPoint=} rotationOrigin The center point of rotation.
 * @return {!MakerJs.IPath} The original path (for cascading).
 */
MakerJs.path.rotate = function(pathToRotate, angleInDegrees, rotationOrigin) {};

/**
 * Scale a path.
 * 
 * @param {!MakerJs.IPath} pathToScale The path to scale.
 * @param {number} scaleValue The amount of scaling.
 * @return {!MakerJs.IPath} The original path (for cascading).
 */
MakerJs.path.scale = function(pathToScale, scaleValue) {};

/**
 * Distort a path - scale x and y individually.
 * 
 * @param {!MakerJs.IPath} pathToDistort The path to distort.
 * @param {number} scaleX The amount of x scaling.
 * @param {number} scaleY The amount of y scaling.
 * @return {(!MakerJs.IModel|!MakerJs.IPath)} A new IModel (for circles and arcs) or IPath (for lines and bezier seeds).
 */
MakerJs.path.distort = function(pathToDistort, scaleX, scaleY) {};

/**
 * Connect 2 lines at their slope intersection point.
 * 
 * @param {!MakerJs.IPathLine} lineA First line to converge.
 * @param {!MakerJs.IPathLine} lineB Second line to converge.
 * @param {boolean=} useOriginA Optional flag to converge the origin point of lineA instead of the end point.
 * @param {boolean=} useOriginB Optional flag to converge the origin point of lineB instead of the end point.
 * @return {!MakerJs.IPoint}
 */
MakerJs.path.converge = function(lineA, lineB, useOriginA, useOriginB) {};

/**
 * Get points along a path.
 * 
 * @param {!MakerJs.IPath} pathContext Path to get points from.
 * @param {number} numberOfPoints Number of points to divide the path.
 * @return {!Array<!MakerJs.IPoint>} Array of points which are on the path spread at a uniform interval.
 */
MakerJs.path.toPoints = function(pathContext, numberOfPoints) {};

/**
 * Get key points (a minimal a number of points) along a path.
 * 
 * @param {!MakerJs.IPath} pathContext Path to get points from.
 * @param {number=} maxArcFacet Optional maximum length between points on an arc or circle.
 * @return {!Array<!MakerJs.IPoint>} Array of points which are on the path.
 */
MakerJs.path.toKeyPoints = function(pathContext, maxArcFacet) {};

/**
 * Center a path at [0, 0].
 * 
 * @param {!MakerJs.IPath} pathToCenter The path to center.
 * @return {!MakerJs.IPath}
 */
MakerJs.path.center = function(pathToCenter) {};

/**
 * Move a path so its bounding box begins at [0, 0].
 * 
 * @param {!MakerJs.IPath} pathToZero The path to zero.
 * @return {!MakerJs.IPath}
 */
MakerJs.path.zero = function(pathToZero) {};

/**
 * Breaks a path in two. The supplied path will end at the supplied pointOfBreak,
 * a new path is returned which begins at the pointOfBreak and ends at the supplied path's initial end point.
 * For Circle, the original path will be converted in place to an Arc, and null is returned.
 * 
 * @param {!MakerJs.IPath} pathToBreak The path to break.
 * @param {!MakerJs.IPoint} pointOfBreak The point at which to break the path.
 * @return {!MakerJs.IPath} A new path of the same type, when path type is line or arc. Returns null for circle.
 */
MakerJs.path.breakAtPoint = function(pathToBreak, pointOfBreak) {};
/** @const */
MakerJs.paths = {};

/**
 * @constructor
 * @struct
 * Class for arc path, created from origin point, radius, start angle, and end angle.
 * 
 * Class for arc path, created from 2 points, radius, large Arc flag, and clockwise flag.
 * 
 * Class for arc path, created from 2 points and optional boolean flag indicating clockwise.
 * 
 * Class for arc path, created from 3 points.
 * 
 * @param {!MakerJs.IPoint} origin_or_pointA The center point of the arc. / First end point of the arc.
 * @param {number|!MakerJs.IPoint} radius_or_pointB The radius of the arc. / Second end point of the arc. / Middle point on the arc.
 * @param {number|boolean|!MakerJs.IPoint=} startAngle_or_radius_or_clockwise_or_pointC The start angle of the arc. / The radius of the arc. / Boolean flag to indicate clockwise direction. / Second end point of the arc.
 * @param {number|boolean=} endAngle_or_largeArc The end angle of the arc. / Boolean flag to indicate clockwise direction.
 * @param {boolean=} clockwise Boolean flag to indicate clockwise direction.
 */
MakerJs.paths.Arc = function(origin_or_pointA, radius_or_pointB, startAngle_or_radius_or_clockwise_or_pointC, endAngle_or_largeArc, clockwise) {};
 /** @type {!MakerJs.IPoint} */
MakerJs.paths.Arc.prototype.origin;
 /** @type {number} */
MakerJs.paths.Arc.prototype.radius;
 /** @type {number} */
MakerJs.paths.Arc.prototype.startAngle;
 /** @type {number} */
MakerJs.paths.Arc.prototype.endAngle;
 /** @type {string} */
MakerJs.paths.Arc.prototype.type;

/**
 * @constructor
 * @struct
 * Class for circle path, created from radius. Origin will be [0, 0].
 * 
 * Example:
 * ```
 * var c = new makerjs.paths.Circle(7);
 * ```
 * 
 * Class for circle path, created from origin point and radius.
 * 
 * Example:
 * ```
 * var c = new makerjs.paths.Circle([10, 10], 7);
 * ```
 * 
 * Class for circle path, created from 2 points.
 * 
 * Example:
 * ```
 * var c = new makerjs.paths.Circle([5, 15], [25, 15]);
 * ```
 * 
 * Class for circle path, created from 3 points.
 * 
 * Example:
 * ```
 * var c = new makerjs.paths.Circle([0, 0], [0, 10], [20, 0]);
 * ```
 * 
 * @param {number|!MakerJs.IPoint} radius_or_origin_or_pointA The radius of the circle. / The center point of the circle. / First point on the circle.
 * @param {number|!MakerJs.IPoint=} radius_or_pointB The radius of the circle. / Second point on the circle.
 * @param {!MakerJs.IPoint=} pointC Third point on the circle.
 */
MakerJs.paths.Circle = function(radius_or_origin_or_pointA, radius_or_pointB, pointC) {};
 /** @type {string} */
MakerJs.paths.Circle.prototype.type;
 /** @type {!MakerJs.IPoint} */
MakerJs.paths.Circle.prototype.origin;
 /** @type {number} */
MakerJs.paths.Circle.prototype.radius;

/**
 * @constructor
 * @struct
 * Class for line path, constructed from array of 2 points.
 * 
 * Class for line path, constructed from 2 points.
 * 
 * @param {!Array<!MakerJs.IPoint>|!MakerJs.IPoint} points_or_origin Array of 2 points. / The origin point of the line.
 * @param {!MakerJs.IPoint=} end The end point of the line.
 */
MakerJs.paths.Line = function(points_or_origin, end) {};
 /** @type {string} */
MakerJs.paths.Line.prototype.type;
 /** @type {!MakerJs.IPoint} */
MakerJs.paths.Line.prototype.origin;
 /** @type {!MakerJs.IPoint} */
MakerJs.paths.Line.prototype.end;

/**
 * @constructor
 * @struct
 * @param {!MakerJs.IPathArc} arc
 */
MakerJs.paths.Chord = function(arc) {};
 /** @type {string} */
MakerJs.paths.Chord.prototype.type;
 /** @type {!MakerJs.IPoint} */
MakerJs.paths.Chord.prototype.origin;
 /** @type {!MakerJs.IPoint} */
MakerJs.paths.Chord.prototype.end;

/**
 * @constructor
 * @struct
 * @param {!MakerJs.IPathLine} toLine
 * @param {number} distance
 * @param {!MakerJs.IPoint} nearPoint
 */
MakerJs.paths.Parallel = function(toLine, distance, nearPoint) {};
 /** @type {string} */
MakerJs.paths.Parallel.prototype.type;
 /** @type {!MakerJs.IPoint} */
MakerJs.paths.Parallel.prototype.origin;
 /** @type {!MakerJs.IPoint} */
MakerJs.paths.Parallel.prototype.end;
/** @const */
MakerJs.model = {};

/**
 * Count the number of child models within a given model.
 * 
 * @param {!MakerJs.IModel} modelContext The model containing other models.
 * @return {number} Number of child models.
 */
MakerJs.model.countChildModels = function(modelContext) {};

/**
 * Get an unused id in the models map with the same prefix.
 * 
 * @param {!MakerJs.IModel} modelContext The model containing the models map.
 * @param {string} modelId The id to use directly (if unused), or as a prefix.
 * @return {string}
 */
MakerJs.model.getSimilarModelId = function(modelContext, modelId) {};

/**
 * Get an unused id in the paths map with the same prefix.
 * 
 * @param {!MakerJs.IModel} modelContext The model containing the paths map.
 * @param {string} pathId The id to use directly (if unused), or as a prefix.
 * @return {string}
 */
MakerJs.model.getSimilarPathId = function(modelContext, pathId) {};

/**
 * Moves all of a model's children (models and paths, recursively) in reference to a single common origin. Useful when points between children need to connect to each other.
 * 
 * @param {!MakerJs.IModel} modelToOriginate The model to originate.
 * @param {!MakerJs.IPoint=} origin Optional offset reference point.
 * @return {!MakerJs.IModel}
 */
MakerJs.model.originate = function(modelToOriginate, origin) {};

/**
 * Center a model at [0, 0].
 * 
 * @param {!MakerJs.IModel} modelToCenter The model to center.
 * @return {!MakerJs.IModel}
 */
MakerJs.model.center = function(modelToCenter) {};

/**
 * Create a clone of a model, mirrored on either or both x and y axes.
 * 
 * @param {!MakerJs.IModel} modelToMirror The model to mirror.
 * @param {boolean} mirrorX Boolean to mirror on the x axis.
 * @param {boolean} mirrorY Boolean to mirror on the y axis.
 * @return {!MakerJs.IModel} Mirrored model.
 */
MakerJs.model.mirror = function(modelToMirror, mirrorX, mirrorY) {};

/**
 * Move a model to an absolute point. Note that this is also accomplished by directly setting the origin property. This function exists for cascading.
 * 
 * @param {!MakerJs.IModel} modelToMove The model to move.
 * @param {!MakerJs.IPoint} origin The new position of the model.
 * @return {!MakerJs.IModel} The original model (for cascading).
 */
MakerJs.model.move = function(modelToMove, origin) {};

/**
 * Move a model's origin by a relative amount.
 * 
 * @param {!MakerJs.IModel} modelToMove The model to move.
 * @param {!MakerJs.IPoint} delta The x & y adjustments as a point object.
 * @return {!MakerJs.IModel} The original model (for cascading).
 */
MakerJs.model.moveRelative = function(modelToMove, delta) {};

/**
 * Prefix the ids of paths in a model.
 * 
 * @param {!MakerJs.IModel} modelToPrefix The model to prefix.
 * @param {string} prefix The prefix to prepend on paths ids.
 * @return {!MakerJs.IModel} The original model (for cascading).
 */
MakerJs.model.prefixPathIds = function(modelToPrefix, prefix) {};

/**
 * Rotate a model.
 * 
 * @param {!MakerJs.IModel} modelToRotate The model to rotate.
 * @param {number} angleInDegrees The amount of rotation, in degrees.
 * @param {!MakerJs.IPoint=} rotationOrigin The center point of rotation.
 * @return {!MakerJs.IModel} The original model (for cascading).
 */
MakerJs.model.rotate = function(modelToRotate, angleInDegrees, rotationOrigin) {};

/**
 * Scale a model.
 * 
 * @param {!MakerJs.IModel} modelToScale The model to scale.
 * @param {number} scaleValue The amount of scaling.
 * @param {boolean=} scaleOrigin Optional boolean to scale the origin point. Typically false for the root model.
 * @return {!MakerJs.IModel} The original model (for cascading).
 */
MakerJs.model.scale = function(modelToScale, scaleValue, scaleOrigin) {};

/**
 * Convert a model to match a different unit system.
 * 
 * @param {!MakerJs.IModel} modeltoConvert The model to convert.
 * @param {string} destUnitType The unit system.
 * @return {!MakerJs.IModel} The scaled model (for cascading).
 */
MakerJs.model.convertUnits = function(modeltoConvert, destUnitType) {};

/**
 * Recursively walk through all paths for a given model.
 * 
 * @param {!MakerJs.IModel} modelContext The model to walk.
 * @param {!MakerJs.IModelPathCallback} callback Callback for each path.
 * @return {void}
 */
MakerJs.model.walkPaths = function(modelContext, callback) {};

/**
 * Recursively walk through all paths for a given model.
 * 
 * @param {!MakerJs.IModel} modelContext The model to walk.
 * @param {!MakerJs.IWalkOptions} options
 * @return {void}
 */
MakerJs.model.walk = function(modelContext, options) {};

/**
 * Move a model so its bounding box begins at [0, 0].
 * 
 * @param {!MakerJs.IModel} modelToZero The model to zero.
 * @return {!MakerJs.IModel}
 */
MakerJs.model.zero = function(modelToZero) {};

/**
 * Check to see if a path is inside of a model.
 * 
 * @param {!MakerJs.IPath} pathContext The path to check.
 * @param {!MakerJs.IModel} modelContext The model to check against.
 * @param {!MakerJs.IPoint=} pathOffset
 * @param {!MakerJs.IPoint=} farPoint Optional point of reference which is outside the bounds of the modelContext.
 * @param {!MakerJs.measure.Atlas=} measureAtlas
 * @return {boolean} Boolean true if the path is inside of the modelContext.
 */
MakerJs.model.isPathInsideModel = function(pathContext, modelContext, pathOffset, farPoint, measureAtlas) {};

/**
 * Break a model's paths everywhere they intersect with another path.
 * 
 * @param {!MakerJs.IModel} modelToBreak The model containing paths to be broken.
 * @param {!MakerJs.IModel=} modelToIntersect Optional model containing paths to look for intersection, or else the modelToBreak will be used.
 * @return {void}
 */
MakerJs.model.breakPathsAtIntersections = function(modelToBreak, modelToIntersect) {};

/**
 * Combine 2 models.
 * 
 * @param {!MakerJs.IModel} modelA First model to combine.
 * @param {!MakerJs.IModel} modelB Second model to combine.
 * @param {boolean=} includeAInsideB Flag to include paths from modelA which are inside of modelB.
 * @param {boolean=} includeAOutsideB Flag to include paths from modelA which are outside of modelB.
 * @param {boolean=} includeBInsideA Flag to include paths from modelB which are inside of modelA.
 * @param {boolean=} includeBOutsideA Flag to include paths from modelB which are outside of modelA.
 * @param {!MakerJs.ICombineOptions=} options
 * @return {void}
 */
MakerJs.model.combine = function(modelA, modelB, includeAInsideB, includeAOutsideB, includeBInsideA, includeBOutsideA, options) {};

/**
 * Combine 2 models, resulting in a intersection.
 * 
 * @param {!MakerJs.IModel} modelA First model to combine.
 * @param {!MakerJs.IModel} modelB Second model to combine.
 * @return {void}
 */
MakerJs.model.combineIntersection = function(modelA, modelB) {};

/**
 * Combine 2 models, resulting in a subtraction of B from A.
 * 
 * @param {!MakerJs.IModel} modelA First model to combine.
 * @param {!MakerJs.IModel} modelB Second model to combine.
 * @return {void}
 */
MakerJs.model.combineSubtraction = function(modelA, modelB) {};

/**
 * Combine 2 models, resulting in a union.
 * 
 * @param {!MakerJs.IModel} modelA First model to combine.
 * @param {!MakerJs.IModel} modelB Second model to combine.
 * @return {void}
 */
MakerJs.model.combineUnion = function(modelA, modelB) {};
/**
 * @record
 * @struct
 */
MakerJs.ICollectionKeyComparer = function() {};

/* TODO: CallSignature: MakerJs */
/**
 * @record
 * @struct
 */
MakerJs.ICollection = function() {};
 /** @type {K} */
MakerJs.ICollection.prototype.key;
 /** @type {!Array<T>} */
MakerJs.ICollection.prototype.items;

/**
 * @constructor
 * @struct
 * @param {!MakerJs.ICollectionKeyComparer<K>=} comparer
 */
MakerJs.Collector = function(comparer) {};
 /** @type {?} */
MakerJs.Collector.prototype.comparer;
 /** @type {!Array<!MakerJs.ICollection<K, T>>} */
MakerJs.Collector.prototype.collections;

/**
 * @param {K} key
 * @param {T} item
 * @return {void}
 */
MakerJs.Collector.prototype.addItemToCollection = function(key, item) {};

/**
 * @param {K} key
 * @param {function(number): void=} action
 * @return {!Array<T>}
 */
MakerJs.Collector.prototype.findCollection = function(key, action) {};

/**
 * @param {K} key
 * @return {boolean}
 */
MakerJs.Collector.prototype.removeCollection = function(key) {};

/**
 * @param {K} key
 * @param {T} item
 * @return {boolean}
 */
MakerJs.Collector.prototype.removeItemFromCollection = function(key, item) {};

/**
 * @param {function(K, !Array<T>): void} cb
 * @return {void}
 */
MakerJs.Collector.prototype.getCollectionsOfMultiple = function(cb) {};

/**
 * Simplify a model's paths by reducing redundancy: combine multiple overlapping paths into a single path. The model must be originated.
 * 
 * @param {!MakerJs.IModel} modelToSimplify
 * @param {!MakerJs.ISimplifyOptions=} options Optional options object.
 * @return {!MakerJs.IModel} The simplified model (for cascading).
 */
MakerJs.model.simplify = function(modelToSimplify, options) {};

/**
 * Expand path by creating a model which surrounds it.
 * 
 * @param {!MakerJs.IPath} pathToExpand Path to expand.
 * @param {number} expansion Distance to expand.
 * @param {boolean=} isolateCaps Optional flag to put the end caps into a separate model named "caps".
 * @return {!MakerJs.IModel} Model which surrounds the path.
 */
MakerJs.path.expand = function(pathToExpand, expansion, isolateCaps) {};

/**
 * Represent an arc using straight lines.
 * 
 * @param {!MakerJs.IPathArc} arc Arc to straighten.
 * @param {boolean=} bevel Optional flag to bevel the angle to prevent it from being too sharp.
 * @param {string=} prefix Optional string prefix to apply to path ids.
 * @param {boolean=} close Optional flag to make a closed geometry by connecting the endpoints.
 * @return {!MakerJs.IModel} Model of straight lines with same endpoints as the arc.
 */
MakerJs.path.straighten = function(arc, bevel, prefix, close) {};

/**
 * Expand all paths in a model, then combine the resulting expansions.
 * 
 * @param {!MakerJs.IModel} modelToExpand Model to expand.
 * @param {number} distance Distance to expand.
 * @param {number=} joints Number of points at a joint between paths. Use 0 for round joints, 1 for pointed joints, 2 for beveled joints.
 * @param {!MakerJs.ICombineOptions=} combineOptions
 * @return {!MakerJs.IModel} Model which surrounds the paths of the original model.
 */
MakerJs.model.expandPaths = function(modelToExpand, distance, joints, combineOptions) {};

/**
 * Outline a model by a specified distance. Useful for accommodating for kerf.
 * 
 * @param {!MakerJs.IModel} modelToOutline Model to outline.
 * @param {number} distance Distance to outline.
 * @param {number=} joints Number of points at a joint between paths. Use 0 for round joints, 1 for pointed joints, 2 for beveled joints.
 * @param {boolean=} inside Optional boolean to draw lines inside the model instead of outside.
 * @return {!MakerJs.IModel} Model which surrounds the paths outside of the original model.
 */
MakerJs.model.outline = function(modelToOutline, distance, joints, inside) {};
/** @const */
MakerJs.units = {};

/**
 * Get a conversion ratio between a source unit and a destination unit.
 * 
 * @param {string} srcUnitType unitType converting from.
 * @param {string} destUnitType unitType converting to.
 * @return {number} Numeric ratio of the conversion.
 */
MakerJs.units.conversionScale = function(srcUnitType, destUnitType) {};
/** @const */
MakerJs.measure = {};

/**
 * Find out if two angles are equal.
 * 
 * @param {number} angleA First angle.
 * @param {number} angleB Second angle.
 * @param {number=} accuracy
 * @return {boolean} true if angles are the same, false if they are not
 */
MakerJs.measure.isAngleEqual = function(angleA, angleB, accuracy) {};

/**
 * Find out if two paths are equal.
 * 
 * @param {!MakerJs.IPath} pathA First path.
 * @param {!MakerJs.IPath} pathB Second path.
 * @param {number=} withinPointDistance
 * @param {!MakerJs.IPoint=} pathAOffset
 * @param {!MakerJs.IPoint=} pathBOffset
 * @return {boolean} true if paths are the same, false if they are not
 */
MakerJs.measure.isPathEqual = function(pathA, pathB, withinPointDistance, pathAOffset, pathBOffset) {};

/**
 * Find out if two points are equal.
 * 
 * @param {!MakerJs.IPoint} a First point.
 * @param {!MakerJs.IPoint} b Second point.
 * @param {number=} withinDistance
 * @return {boolean} true if points are the same, false if they are not
 */
MakerJs.measure.isPointEqual = function(a, b, withinDistance) {};

/**
 * Find out if point is on a slope.
 * 
 * @param {!MakerJs.IPoint} p Point to check.
 * @param {!MakerJs.ISlope} slope
 * @param {number=} withinDistance
 * @return {boolean} true if point is on the slope
 */
MakerJs.measure.isPointOnSlope = function(p, slope, withinDistance) {};

/**
 * Check for slope equality.
 * 
 * @param {!MakerJs.ISlope} slopeA The ISlope to test.
 * @param {!MakerJs.ISlope} slopeB The ISlope to check for equality.
 * @return {boolean} Boolean true if slopes are equal.
 */
MakerJs.measure.isSlopeEqual = function(slopeA, slopeB) {};

/**
 * Increase a measurement by an additional measurement.
 * 
 * @param {!MakerJs.IMeasure} baseMeasure The measurement to increase.
 * @param {!MakerJs.IMeasure} addMeasure The additional measurement.
 * @return {!MakerJs.IMeasure} The increased original measurement (for cascading).
 */
MakerJs.measure.increase = function(baseMeasure, addMeasure) {};

/**
 * Check for arc being concave or convex towards a given point.
 * 
 * @param {!MakerJs.IPathArc} arc The arc to test.
 * @param {!MakerJs.IPoint} towardsPoint The point to test.
 * @return {boolean} Boolean true if arc is concave towards point.
 */
MakerJs.measure.isArcConcaveTowardsPoint = function(arc, towardsPoint) {};

/**
 * Check for arc overlapping another arc.
 * 
 * @param {!MakerJs.IPathArc} arcA The arc to test.
 * @param {!MakerJs.IPathArc} arcB The arc to check for overlap.
 * @param {boolean} excludeTangents Boolean to exclude exact endpoints and only look for deep overlaps.
 * @return {boolean} Boolean true if arcA is overlapped with arcB.
 */
MakerJs.measure.isArcOverlapping = function(arcA, arcB, excludeTangents) {};

/**
 * Check if a given number is between two given limits.
 * 
 * @param {number} valueInQuestion The number to test.
 * @param {number} limitA First limit.
 * @param {number} limitB Second limit.
 * @param {boolean} exclusive Flag to exclude equaling the limits.
 * @return {boolean} Boolean true if value is between (or equal to) the limits.
 */
MakerJs.measure.isBetween = function(valueInQuestion, limitA, limitB, exclusive) {};

/**
 * Check if a given angle is between an arc's start and end angles.
 * 
 * @param {number} angleInQuestion The angle to test.
 * @param {!MakerJs.IPathArc} arc Arc to test against.
 * @param {boolean} exclusive Flag to exclude equaling the start or end angles.
 * @return {boolean} Boolean true if angle is between (or equal to) the arc's start and end angles.
 */
MakerJs.measure.isBetweenArcAngles = function(angleInQuestion, arc, exclusive) {};

/**
 * Check if a given point is between a line's end points.
 * 
 * @param {!MakerJs.IPoint} pointInQuestion The point to test.
 * @param {!MakerJs.IPathLine} line Line to test against.
 * @param {boolean} exclusive Flag to exclude equaling the origin or end points.
 * @return {boolean} Boolean true if point is between (or equal to) the line's origin and end points.
 */
MakerJs.measure.isBetweenPoints = function(pointInQuestion, line, exclusive) {};

/**
 * Check if a given bezier seed is simply a line.
 * 
 * @param {!MakerJs.IPathBezierSeed} seed The bezier seed to test.
 * @return {boolean} Boolean true if bezier seed has control points on the line slope and between the line endpoints.
 */
MakerJs.measure.isBezierSeedLinear = function(seed) {};

/**
 * Check for line overlapping another line.
 * 
 * @param {!MakerJs.IPathLine} lineA The line to test.
 * @param {!MakerJs.IPathLine} lineB The line to check for overlap.
 * @param {boolean} excludeTangents Boolean to exclude exact endpoints and only look for deep overlaps.
 * @return {boolean} Boolean true if lineA is overlapped with lineB.
 */
MakerJs.measure.isLineOverlapping = function(lineA, lineB, excludeTangents) {};

/**
 * Check for measurement overlapping another measurement.
 * 
 * @param {!MakerJs.IMeasure} measureA The measurement to test.
 * @param {!MakerJs.IMeasure} measureB The measurement to check for overlap.
 * @return {boolean} Boolean true if measureA is overlapped with measureB.
 */
MakerJs.measure.isMeasurementOverlapping = function(measureA, measureB) {};

/**
 * Gets the slope of a line.
 * @param {!MakerJs.IPathLine} line
 * @return {!MakerJs.ISlope}
 */
MakerJs.measure.lineSlope = function(line) {};

/**
 * Calculates the distance between two points.
 * 
 * @param {!MakerJs.IPoint} a First point.
 * @param {!MakerJs.IPoint} b Second point.
 * @return {number} Distance between points.
 */
MakerJs.measure.pointDistance = function(a, b) {};

/**
 * Calculates the smallest rectangle which contains a path.
 * 
 * @param {!MakerJs.IPath} pathToMeasure The path to measure.
 * @param {!MakerJs.IPoint=} addOffset
 * @return {!MakerJs.IMeasure} object with low and high points.
 */
MakerJs.measure.pathExtents = function(pathToMeasure, addOffset) {};

/**
 * Measures the length of a path.
 * 
 * @param {!MakerJs.IPath} pathToMeasure The path to measure.
 * @return {number} Length of the path.
 */
MakerJs.measure.pathLength = function(pathToMeasure) {};

/**
 * Measures the smallest rectangle which contains a model.
 * 
 * @param {!MakerJs.IModel} modelToMeasure The model to measure.
 * @param {!MakerJs.measure.Atlas=} atlas Optional atlas to save measurements.
 * @return {!MakerJs.IMeasureWithCenter} object with low and high points.
 */
MakerJs.measure.modelExtents = function(modelToMeasure, atlas) {};

/**
 * @constructor
 * @struct
 * Constructor.
 * @param {!MakerJs.IModel} modelContext The model to measure.
 */
MakerJs.measure.Atlas = function(modelContext) {};
 /** @type {!MakerJs.IModel} */
MakerJs.measure.Atlas.prototype.modelContext;
 /** @type {boolean} */
MakerJs.measure.Atlas.prototype.modelsMeasured;
 /** @type {!MakerJs.IMeasureMap} */
MakerJs.measure.Atlas.prototype.modelMap;
 /** @type {!MakerJs.IMeasureMap} */
MakerJs.measure.Atlas.prototype.pathMap;

/**
 * @return {void}
 */
MakerJs.measure.Atlas.prototype.measureModels = function() {};
/**
 * @extends {MakerJs.IModel}
 * @record
 * @struct
 */
MakerJs.measure.IBoundingHex = function() {};
 /** @type {number} */
MakerJs.measure.IBoundingHex.prototype.radius;

/**
 * Measures the minimum bounding hexagon surrounding a model. The hexagon is oriented such that the right and left sides are vertical, and the top and bottom are pointed.
 * 
 * @param {!MakerJs.IModel} modelToMeasure The model to measure.
 * @return {!MakerJs.measure.IBoundingHex} IBoundingHex object which is a hexagon model, with an additional radius property.
 */
MakerJs.measure.boundingHexagon = function(modelToMeasure) {};
/** @const */
MakerJs.exporter = {};
/**
 * @record
 * @struct
 */
MakerJs.exporter.IExportOptions = function() {};
 /** @type {string} */
MakerJs.exporter.IExportOptions.prototype.units;

/**
 * Try to get the unit system from a model
 * @param {?} itemToExport
 * @return {string}
 */
MakerJs.exporter.tryGetModelUnits = function(itemToExport) {};

/**
 * @constructor
 * @struct
 * @param {!MakerJs.IPathOriginFunctionMap} map Object containing properties: property name is the type of path, e.g. "line", "circle"; property value
 * is a function to render a path. Function parameters are path and point.
 * @param {function(!MakerJs.IPoint): !MakerJs.IPoint=} fixPoint Optional function to modify a point prior to export. Function parameter is a point; function must return a point.
 * @param {function(!MakerJs.IPath, !MakerJs.IPoint): !MakerJs.IPath=} fixPath Optional function to modify a path prior to output. Function parameters are path and offset point; function must return a path.
 * @param {function(string, !MakerJs.IModel): void=} beginModel
 * @param {function(!MakerJs.IModel): void=} endModel
 */
MakerJs.exporter.Exporter = function(map, fixPoint, fixPath, beginModel, endModel) {};
 /** @type {?} */
MakerJs.exporter.Exporter.prototype.map;
 /** @type {?} */
MakerJs.exporter.Exporter.prototype.fixPoint;
 /** @type {?} */
MakerJs.exporter.Exporter.prototype.fixPath;
 /** @type {?} */
MakerJs.exporter.Exporter.prototype.beginModel;
 /** @type {?} */
MakerJs.exporter.Exporter.prototype.endModel;

/**
 * Export a path.
 * 
 * @param {string} id
 * @param {!MakerJs.IPath} pathToExport The path to export.
 * @param {!MakerJs.IPoint} offset The offset position of the path.
 * @param {string} layer
 * @return {void}
 */
MakerJs.exporter.Exporter.prototype.exportPath = function(id, pathToExport, offset, layer) {};

/**
 * Export a model.
 * 
 * @param {string} modelId
 * @param {!MakerJs.IModel} modelToExport The model to export.
 * @param {!MakerJs.IPoint} offset The offset position of the model.
 * @return {void}
 */
MakerJs.exporter.Exporter.prototype.exportModel = function(modelId, modelToExport, offset) {};

/**
 * Export an object.
 * 
 * @param {string} itemId
 * @param {?} itemToExport
 * @param {!MakerJs.IPoint} origin
 * @return {void}
 */
MakerJs.exporter.Exporter.prototype.exportItem = function(itemId, itemToExport, origin) {};
/** @const */
MakerJs.importer = {};

/**
 * Create a numeric array from a string of numbers. The numbers may be delimited by anything non-numeric.
 * 
 * Example:
 * ```
 * var n = makerjs.importer.parseNumericList('5, 10, 15.20 25-30-35 4e1 .5');
 * ```
 * 
 * @param {string} s The string of numbers.
 * @return {!Array<number>} Array of numbers.
 */
MakerJs.importer.parseNumericList = function(s) {};

/**
 * @param {!MakerJs.IModel|!Array<!MakerJs.IPath>|!MakerJs.IPath} modelToExport_or_pathsToExport_or_pathToExport
 * @param {!MakerJs.exporter.IDXFRenderOptions=} options
 * @return {string}
 */
MakerJs.exporter.toDXF = function(modelToExport_or_pathsToExport_or_pathToExport, options) {};
/**
 * @extends {MakerJs.exporter.IExportOptions}
 * @record
 * @struct
 */
MakerJs.exporter.IDXFRenderOptions = function() {};
/** @const */
MakerJs.solvers = {};

/**
 * Solves for the angle of a triangle when you know lengths of 3 sides.
 * 
 * @param {number} lengthA Length of side of triangle, opposite of the angle you are trying to find.
 * @param {number} lengthB Length of any other side of the triangle.
 * @param {number} lengthC Length of the remaining side of the triangle.
 * @return {number} Angle opposite of the side represented by the first parameter.
 */
MakerJs.solvers.solveTriangleSSS = function(lengthA, lengthB, lengthC) {};

/**
 * Solves for the length of a side of a triangle when you know length of one side and 2 angles.
 * 
 * @param {number} oppositeAngleInDegrees Angle which is opposite of the side you are trying to find.
 * @param {number} lengthOfSideBetweenAngles Length of one side of the triangle which is between the provided angles.
 * @param {number} otherAngleInDegrees An other angle of the triangle.
 * @return {number} Length of the side of the triangle which is opposite of the first angle parameter.
 */
MakerJs.solvers.solveTriangleASA = function(oppositeAngleInDegrees, lengthOfSideBetweenAngles, otherAngleInDegrees) {};

/**
 * Find the point(s) where 2 paths intersect.
 * 
 * @param {!MakerJs.IPath} path1 First path to find intersection.
 * @param {!MakerJs.IPath} path2 Second path to find intersection.
 * @param {!MakerJs.IPathIntersectionOptions=} options Optional IPathIntersectionOptions.
 * @return {!MakerJs.IPathIntersection} IPathIntersection object, with points(s) of intersection (and angles, when a path is an arc or circle); or null if the paths did not intersect.
 */
MakerJs.path.intersection = function(path1, path2, options) {};

/**
 * Adds a round corner to the outside angle between 2 lines. The lines must meet at one point.
 * 
 * @param {!MakerJs.IPathLine} lineA First line to fillet, which will be modified to fit the fillet.
 * @param {!MakerJs.IPathLine} lineB Second line to fillet, which will be modified to fit the fillet.
 * @param {number} filletRadius
 * @param {!MakerJs.IPointMatchOptions=} options
 * @return {!MakerJs.IPathArc} Arc path object of the new fillet.
 */
MakerJs.path.dogbone = function(lineA, lineB, filletRadius, options) {};

/**
 * Adds a round corner to the inside angle between 2 paths. The paths must meet at one point.
 * 
 * @param {!MakerJs.IPath} pathA First path to fillet, which will be modified to fit the fillet.
 * @param {!MakerJs.IPath} pathB Second path to fillet, which will be modified to fit the fillet.
 * @param {number} filletRadius Radius of the fillet.
 * @param {!MakerJs.IPointMatchOptions=} options Optional IPointMatchOptions object to specify pointMatchingDistance.
 * @return {!MakerJs.IPathArc} Arc path object of the new fillet.
 */
MakerJs.path.fillet = function(pathA, pathB, filletRadius, options) {};
/** @const */
MakerJs.chain = {};

/**
 * Adds a fillet between each link in a chain. Each path will be cropped to fit a fillet, and all fillets will be returned as paths in a returned model object.
 * 
 * @param {!MakerJs.IChain} chainToFillet The chain to add fillets to.
 * @param {number} filletRadius Radius of the fillet.
 * @return {!MakerJs.IModel} Model object containing paths which fillet the joints in the chain.
 */
MakerJs.chain.fillet = function(chainToFillet, filletRadius) {};
/** @const */
MakerJs.kit = {};

/**
 * Helper function to use the JavaScript "apply" function in conjunction with the "new" keyword.
 * 
 * @param {!MakerJs.IKit} ctor The constructor for the class which is an IKit.
 * @param {?} args The array of parameters passed to the constructor.
 * @return {!MakerJs.IModel} A new instance of the class, which implements the IModel interface.
 */
MakerJs.kit.construct = function(ctor, args) {};

/**
 * Extract just the initial sample values from a kit.
 * 
 * @param {!MakerJs.IKit} ctor The constructor for the class which is an IKit.
 * @return {!Array<?>} Array of the inital sample values provided in the metaParameters array.
 */
MakerJs.kit.getParameterValues = function(ctor) {};

/**
 * Find a single chain within a model, across all layers. Shorthand of findChains; useful when you know there is only one chain to find in your model.
 * 
 * @param {!MakerJs.IModel} modelContext The model to search for a chain.
 * @return {!MakerJs.IChain} A chain object or null if chains were not found.
 */
MakerJs.model.findSingleChain = function(modelContext) {};

/**
 * Find paths that have common endpoints and form chains.
 * 
 * @param {!MakerJs.IModel} modelContext The model to search for chains.
 * @param {!MakerJs.IChainCallback} callback
 * @param {!MakerJs.IFindChainsOptions=} options Optional options object.
 * @return {void}
 */
MakerJs.model.findChains = function(modelContext, callback, options) {};

/**
 * Shift the links of an endless chain.
 * 
 * @param {!MakerJs.IChain} chainContext Chain to cycle through. Must be endless.
 * @param {number=} amount Optional number of links to shift. May be negative to cycle backwards.
 * @return {!MakerJs.IChain} The chainContext for cascading.
 */
MakerJs.chain.cycle = function(chainContext, amount) {};

/**
 * Reverse the links of a chain.
 * 
 * @param {!MakerJs.IChain} chainContext Chain to reverse.
 * @return {!MakerJs.IChain} The chainContext for cascading.
 */
MakerJs.chain.reverse = function(chainContext) {};

/**
 * Set the beginning of an endless chain to a known routeKey of a path.
 * 
 * @param {!MakerJs.IChain} chainContext Chain to cycle through. Must be endless.
 * @param {string} routeKey RouteKey of the desired path to start the chain with.
 * @return {!MakerJs.IChain} The chainContext for cascading.
 */
MakerJs.chain.startAt = function(chainContext, routeKey) {};

/**
 * Get points along a chain of paths.
 * 
 * @param {!MakerJs.IChain} chainContext Chain of paths to get points from.
 * @param {number} distance Distance along the chain between points.
 * @param {number=} maxPoints Maximum number of points to retrieve.
 * @return {!Array<!MakerJs.IPoint>} Array of points which are on the chain spread at a uniform interval.
 */
MakerJs.chain.toPoints = function(chainContext, distance, maxPoints) {};

/**
 * Get key points (a minimal a number of points) along a chain of paths.
 * 
 * @param {!MakerJs.IChain} chainContext Chain of paths to get points from.
 * @param {number=} maxArcFacet The maximum length between points on an arc or circle.
 * @return {!Array<!MakerJs.IPoint>} Array of points which are on the chain.
 */
MakerJs.chain.toKeyPoints = function(chainContext, maxArcFacet) {};

/**
 * Find paths that have common endpoints and form loops.
 * 
 * @param {!MakerJs.IModel} modelContext The model to search for loops.
 * @param {!MakerJs.IFindLoopsOptions=} options Optional options object.
 * @return {!MakerJs.IModel} A new model with child models ranked according to their containment within other found loops. The paths of models will be IPathDirectionalWithPrimeContext.
 */
MakerJs.model.findLoops = function(modelContext, options) {};

/**
 * Remove all paths in a loop model from the model(s) which contained them.
 * 
 * @param {!MakerJs.IModel} loopToDetach The model to search for loops.
 * @return {void}
 */
MakerJs.model.detachLoop = function(loopToDetach) {};

/**
 * Remove paths from a model which have endpoints that do not connect to other paths.
 * 
 * @param {!MakerJs.IModel} modelContext The model to search for dead ends.
 * @param {?=} pointMatchingDistance
 * @param {!MakerJs.IWalkPathBooleanCallback=} keep
 * @return {!MakerJs.IModel} The input model (for cascading).
 */
MakerJs.model.removeDeadEnds = function(modelContext, pointMatchingDistance, keep) {};
/**
 * @record
 * @struct
 */
MakerJs.exporter.IXmlTagAttrs = function() {};

/* TODO: IndexSignature: MakerJs.exporter */

/**
 * @constructor
 * @struct
 * @param {string} name Name of the XML tag.
 * @param {!MakerJs.exporter.IXmlTagAttrs=} attrs Optional attributes for the tag.
 */
MakerJs.exporter.XmlTag = function(name, attrs) {};
 /** @type {string} */
MakerJs.exporter.XmlTag.prototype.name;
 /** @type {!MakerJs.exporter.IXmlTagAttrs} */
MakerJs.exporter.XmlTag.prototype.attrs;
 /** @type {string} */
MakerJs.exporter.XmlTag.prototype.innerText;
 /** @type {boolean} */
MakerJs.exporter.XmlTag.prototype.innerTextEscaped;

/**
 * Escapes certain characters within a string so that it can appear in a tag or its attribute.
 * 
 * @param {string} value
 * @return {string} Escaped string.
 */
MakerJs.exporter.XmlTag.escapeString = function(value) {};

/**
 * Get the opening tag.
 * 
 * @param {boolean} selfClose Flag to determine if opening tag should be self closing.
 * @return {string}
 */
MakerJs.exporter.XmlTag.prototype.getOpeningTag = function(selfClose) {};

/**
 * Get the inner text.
 * @return {string}
 */
MakerJs.exporter.XmlTag.prototype.getInnerText = function() {};

/**
 * Get the closing tag.
 * @return {string}
 */
MakerJs.exporter.XmlTag.prototype.getClosingTag = function() {};

/**
 * Output the entire tag as a string.
 * @return {string}
 */
MakerJs.exporter.XmlTag.prototype.toString = function() {};

/**
 * @param {!MakerJs.IModel|!Array<!MakerJs.IPath>|!MakerJs.IPath} modelToExport_or_pathsToExport_or_pathToExport
 * @param {!MakerJs.exporter.IOpenJsCadOptions=} options
 * @return {string}
 */
MakerJs.exporter.toOpenJsCad = function(modelToExport_or_pathsToExport_or_pathToExport, options) {};

/**
 * Executes a JavaScript string with the OpenJsCad engine - converts 2D to 3D.
 * 
 * @param {!MakerJs.IModel} modelToExport Model object to export.
 * @param {!MakerJs.exporter.IOpenJsCadOptions=} options Export options object.
 * @return {string} String of STL format of 3D object.
 */
MakerJs.exporter.toSTL = function(modelToExport, options) {};
/**
 * @extends {MakerJs.IFindLoopsOptions}
 * @record
 * @struct
 */
MakerJs.exporter.IOpenJsCadOptions = function() {};
 /** @type {number} */
MakerJs.exporter.IOpenJsCadOptions.prototype.extrusion;
 /** @type {number} */
MakerJs.exporter.IOpenJsCadOptions.prototype.facetSize;
 /** @type {string} */
MakerJs.exporter.IOpenJsCadOptions.prototype.functionName;
 /** @type {!MakerJs.exporter.IOpenJsCadOptionsMap} */
MakerJs.exporter.IOpenJsCadOptions.prototype.modelMap;
/**
 * @record
 * @struct
 */
MakerJs.exporter.IOpenJsCadOptionsMap = function() {};

/* TODO: IndexSignature: MakerJs.exporter */

/**
 * Injects drawing into a PDFKit document.
 * 
 * @param {!PDFKit.PDFDocument} doc
 * @param {!MakerJs.IModel} modelToExport Model object to export.
 * @param {!MakerJs.exporter.IPDFRenderOptions=} options Export options object.
 * @return {void} String of PDF file contents.
 */
MakerJs.exporter.toPDF = function(doc, modelToExport, options) {};
/**
 * @extends {MakerJs.exporter.IExportOptions}
 * @record
 * @struct
 */
MakerJs.exporter.IPDFRenderOptions = function() {};
 /** @type {!MakerJs.IPoint} */
MakerJs.exporter.IPDFRenderOptions.prototype.origin;
 /** @type {string} */
MakerJs.exporter.IPDFRenderOptions.prototype.stroke;
/**
 * @record
 * @struct
 */
MakerJs.exporter.IPathDataByLayerMap = function() {};

/* TODO: IndexSignature: MakerJs.exporter */

/**
 * Convert a chain to SVG path data.
 * @param {!MakerJs.IChain} chain
 * @param {!MakerJs.IPoint} offset
 * @return {string}
 */
MakerJs.exporter.chainToSVGPathData = function(chain, offset) {};

/**
 * Convert a path to SVG path data.
 * @param {!MakerJs.IPath} pathToExport
 * @param {!MakerJs.IPoint} offset
 * @param {!MakerJs.IPoint} offset2
 * @return {string}
 */
MakerJs.exporter.pathToSVGPathData = function(pathToExport, offset, offset2) {};

/**
 * Convert a model to SVG path data.
 * 
 * @param {!MakerJs.IModel} modelToExport Model to export.
 * @param {boolean=} byLayers Boolean flag (default true) to return a map of path data by layer.
 * @param {!MakerJs.IPoint=} origin Optional reference origin.
 * @return {(string|!MakerJs.exporter.IPathDataByLayerMap)} String of SVG path data (if byLayers is false) or an object map of path data by layer .
 */
MakerJs.exporter.toSVGPathData = function(modelToExport, byLayers, origin) {};

/**
 * @param {!MakerJs.IModel|!Array<!MakerJs.IPath>|!MakerJs.IPath} modelToExport_or_pathsToExport_or_pathToExport
 * @param {!MakerJs.exporter.ISVGRenderOptions=} options
 * @return {string}
 */
MakerJs.exporter.toSVG = function(modelToExport_or_pathsToExport_or_pathToExport, options) {};
/**
 * @record
 * @struct
 */
MakerJs.exporter.svgUnitConversion = function() {};

/* TODO: IndexSignature: MakerJs.exporter */
 /** @type {!MakerJs.exporter.svgUnitConversion} */
MakerJs.exporter.svgUnit;
/**
 * @extends {MakerJs.exporter.IExportOptions}
 * @record
 * @struct
 */
MakerJs.exporter.ISVGRenderOptions = function() {};
 /** @type {!MakerJs.exporter.IXmlTagAttrs} */
MakerJs.exporter.ISVGRenderOptions.prototype.svgAttrs;
 /** @type {string} */
MakerJs.exporter.ISVGRenderOptions.prototype.fill;
 /** @type {string} */
MakerJs.exporter.ISVGRenderOptions.prototype.fontSize;
 /** @type {string} */
MakerJs.exporter.ISVGRenderOptions.prototype.strokeWidth;
 /** @type {string} */
MakerJs.exporter.ISVGRenderOptions.prototype.stroke;
 /** @type {number} */
MakerJs.exporter.ISVGRenderOptions.prototype.scale;
 /** @type {boolean} */
MakerJs.exporter.ISVGRenderOptions.prototype.annotate;
 /** @type {!MakerJs.IPoint} */
MakerJs.exporter.ISVGRenderOptions.prototype.origin;
 /** @type {boolean} */
MakerJs.exporter.ISVGRenderOptions.prototype.useSvgPathOnly;
 /** @type {boolean} */
MakerJs.exporter.ISVGRenderOptions.prototype.viewBox;

/**
 * @param {string} pathData
 * @return {!MakerJs.IModel}
 */
MakerJs.importer.fromSVGPathData = function(pathData) {};
/** @const */
MakerJs.models = {};

/**
 * @constructor
 * @struct
 * @param {!Array<!MakerJs.IPoint>|!MakerJs.IPathBezierSeed|!MakerJs.IPoint} points_or_seed_or_origin
 * @param {number|boolean|!MakerJs.IPoint|!Array<!MakerJs.IPoint>=} accuracy_or_isChild_or_control_or_controls_or_control1
 * @param {number|!MakerJs.IPoint=} accuracy_or_end_or_control2
 * @param {number|!MakerJs.IPoint=} accuracy_or_end
 * @param {number=} accuracy
 */
MakerJs.models.BezierCurve = function(points_or_seed_or_origin, accuracy_or_isChild_or_control_or_controls_or_control1, accuracy_or_end_or_control2, accuracy_or_end, accuracy) {};
 /** @type {!MakerJs.IModelMap} */
MakerJs.models.BezierCurve.prototype.models;
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.BezierCurve.prototype.paths;
 /** @type {!MakerJs.IPoint} */
MakerJs.models.BezierCurve.prototype.origin;
 /** @type {string} */
MakerJs.models.BezierCurve.prototype.type;
 /** @type {!MakerJs.IPathBezierSeed} */
MakerJs.models.BezierCurve.prototype.seed;
 /** @type {number} */
MakerJs.models.BezierCurve.prototype.accuracy;
 /** @type {string} */
MakerJs.models.BezierCurve.typeName;

/**
 * @param {!MakerJs.models.BezierCurve} curve
 * @param {!MakerJs.IFindChainsOptions=} options
 * @return {!Array<!MakerJs.IPathBezierSeed>}
 */
MakerJs.models.BezierCurve.getBezierSeeds = function(curve, options) {};

/**
 * @param {!MakerJs.IPathBezierSeed} seed
 * @return {number}
 */
MakerJs.models.BezierCurve.computeLength = function(seed) {};

/**
 * @param {!MakerJs.IPathBezierSeed} seed
 * @param {number} t
 * @return {!MakerJs.IPoint}
 */
MakerJs.models.BezierCurve.computePoint = function(seed, t) {};
 /** @type {?} */
var Bezier;

/**
 * @constructor
 * @struct
 * Class for Ellipse created with 2 radii.
 * 
 * Class for Ellipse created at a specific origin and 2 radii.
 * 
 * Class for Ellipse created at a specific x, y and 2 radii.
 * 
 * @param {number|!MakerJs.IPoint} radiusX_or_origin_or_cx The x radius of the ellipse. / The center of the ellipse. / The x coordinate of the center of the ellipse.
 * @param {number} radiusY_or_radiusX_or_cy The y radius of the ellipse. / The x radius of the ellipse. / The y coordinate of the center of the ellipse.
 * @param {number=} accuracy_or_radiusY_or_rx Optional accuracy of the underlying BezierCurve. / The y radius of the ellipse.
 * @param {number=} accuracy_or_ry Optional accuracy of the underlying BezierCurve.
 * @param {number=} accuracy Optional accuracy of the underlying BezierCurve.
 */
MakerJs.models.Ellipse = function(radiusX_or_origin_or_cx, radiusY_or_radiusX_or_cy, accuracy_or_radiusY_or_rx, accuracy_or_ry, accuracy) {};
 /** @type {!MakerJs.IModelMap} */
MakerJs.models.Ellipse.prototype.models;
 /** @type {!MakerJs.IPoint} */
MakerJs.models.Ellipse.prototype.origin;

/**
 * @constructor
 * @struct
 * Class for Elliptic Arc created by distorting a circular arc.
 * 
 * Class for Elliptic Arc created by distorting a circular arc.
 * 
 * @param {number|!MakerJs.IPathArc} startAngle_or_arc The circular arc to use as the basis of the elliptic arc.
 * @param {number} endAngle_or_distortX The x scale of the ellipse.
 * @param {number} radiusX_or_distortY The x radius of the ellipse. / The y scale of the ellipse.
 * @param {number=} radiusY_or_accuracy The y radius of the ellipse. / Optional accuracy of the underlying BezierCurve.
 * @param {number=} accuracy Optional accuracy of the underlying BezierCurve.
 */
MakerJs.models.EllipticArc = function(startAngle_or_arc, endAngle_or_distortX, radiusX_or_distortY, radiusY_or_accuracy, accuracy) {};
 /** @type {!MakerJs.IModelMap} */
MakerJs.models.EllipticArc.prototype.models;

/**
 * @constructor
 * @struct
 * Create a model by connecting points designated in a string. The model will be 'closed' - i.e. the last point will connect to the first point.
 * 
 * Example:
 * ```
 * var c = new makerjs.models.ConnectTheDots('-10 0 10 0 0 20'); // 3 coordinates to form a triangle
 * ```
 * 
 * Create a model by connecting points designated in a string. The model will be 'closed' - i.e. the last point will connect to the first point.
 * 
 * Example:
 * ```
 * var c = new makerjs.models.ConnectTheDots(false, '-10 0 10 0 0 20'); // 3 coordinates to form a polyline
 * ```
 * 
 * Create a model by connecting points designated in a numeric array. The model will be 'closed' - i.e. the last point will connect to the first point.
 * 
 * Example:
 * ```
 * var c = new makerjs.models.ConnectTheDots([-10, 0, 10, 0, 0, 20]); // 3 coordinates to form a triangle
 * ```
 * 
 * Create a model by connecting points designated in a numeric array. The model will be 'closed' - i.e. the last point will connect to the first point.
 * 
 * Example:
 * ```
 * var c = new makerjs.models.ConnectTheDots(false, [-10, 0, 10, 0, 0, 20]); // 3 coordinates to form a polyline
 * ```
 * 
 * Create a model by connecting points designated in an array of points. The model may be closed, or left open.
 * 
 * Example:
 * ```
 * var c = new makerjs.models.ConnectTheDots(false, [[-10, 0], [10, 0], [0, 20]]); // 3 coordinates left open
 * ```
 * 
 * @param {string|boolean|!Array<number>} numericList_or_isClosed_or_coords String containing a list of numbers which can be delimited by spaces, commas, or anything non-numeric (Note: [exponential notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential) is allowed). / Flag to specify if last point should connect to the first point. / Array of coordinates.
 * @param {string|!Array<number>|!Array<!MakerJs.IPoint>=} numericList_or_coords_or_points String containing a list of numbers which can be delimited by spaces, commas, or anything non-numeric (Note: [exponential notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential) is allowed). / Array of coordinates. / Array of IPoints.
 */
MakerJs.models.ConnectTheDots = function(numericList_or_isClosed_or_coords, numericList_or_coords_or_points) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.ConnectTheDots.prototype.paths;

/**
 * @constructor
 * @struct
 * @param {number} numberOfSides
 * @param {number} radius
 * @param {number=} firstCornerAngleInDegrees
 * @param {boolean=} circumscribed
 */
MakerJs.models.Polygon = function(numberOfSides, radius, firstCornerAngleInDegrees, circumscribed) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.Polygon.prototype.paths;

/**
 * @param {number} radius
 * @param {number} angleInRadians
 * @return {number}
 */
MakerJs.models.Polygon.circumscribedRadius = function(radius, angleInRadians) {};

/**
 * @param {number} numberOfSides
 * @param {number} radius
 * @param {number=} firstCornerAngleInDegrees
 * @param {boolean=} circumscribed
 * @return {!Array<!MakerJs.IPoint>}
 */
MakerJs.models.Polygon.getPoints = function(numberOfSides, radius, firstCornerAngleInDegrees, circumscribed) {};

/**
 * @constructor
 * @struct
 * Create an array of circles of the same radius from an array of center points.
 * 
 * Example:
 * ```
 * //Create some holes from an array of points
 * var makerjs = require('makerjs');
 * var model = new makerjs.models.Holes(10, [[0, 0],[50, 0],[25, 40]]);
 * var svg = makerjs.exporter.toSVG(model);
 * document.write(svg);
 * ```
 * 
 * @param {number} holeRadius Hole radius.
 * @param {!Array<!MakerJs.IPoint>} points Array of points for origin of each hole.
 * @param {!Array<string>=} ids Optional array of corresponding path ids for the holes.
 */
MakerJs.models.Holes = function(holeRadius, points, ids) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.Holes.prototype.paths;

/**
 * @constructor
 * @struct
 * @param {number} boltRadius
 * @param {number} holeRadius
 * @param {number} boltCount
 * @param {number=} firstBoltAngleInDegrees
 */
MakerJs.models.BoltCircle = function(boltRadius, holeRadius, boltCount, firstBoltAngleInDegrees) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.BoltCircle.prototype.paths;

/**
 * @constructor
 * @struct
 * @param {number} width
 * @param {number} height
 * @param {number} holeRadius
 */
MakerJs.models.BoltRectangle = function(width, height, holeRadius) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.BoltRectangle.prototype.paths;

/**
 * @constructor
 * @struct
 * Create a dogbone from width, height, corner radius, style, and bottomless flag.
 * 
 * Example:
 * ```
 * var d = new makerjs.models.Dogbone(50, 100, 5);
 * ```
 * 
 * @param {number} width Width of the rectangle.
 * @param {number} height Height of the rectangle.
 * @param {number} radius Corner radius.
 * @param {number=} style Optional corner style: 0 (default) for dogbone, 1 for vertical, -1 for horizontal.
 * @param {boolean=} bottomless Optional flag to omit the bottom line and bottom corners (default false).
 */
MakerJs.models.Dogbone = function(width, height, radius, style, bottomless) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.Dogbone.prototype.paths;

/**
 * @constructor
 * @struct
 * @param {number} width
 * @param {number} height
 * @param {number=} radius
 */
MakerJs.models.Dome = function(width, height, radius) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.Dome.prototype.paths;

/**
 * @constructor
 * @struct
 * Create a round rectangle from width, height, and corner radius.
 * 
 * Example:
 * ```
 * var r = new makerjs.models.RoundRectangle(100, 50, 5);
 * ```
 * 
 * Create a round rectangle which will surround a model.
 * 
 * Example:
 * ```
 * var b = new makerjs.models.BoltRectangle(30, 20, 1); //draw a bolt rectangle so we have something to surround
 * var r = new makerjs.models.RoundRectangle(b, 2.5);   //surround it
 * ```
 * 
 * @param {number|!MakerJs.IModel} width_or_modelToSurround Width of the rectangle. / IModel object.
 * @param {number} height_or_margin Height of the rectangle. / Distance from the model. This will also become the corner radius.
 * @param {number=} radius Corner radius.
 */
MakerJs.models.RoundRectangle = function(width_or_modelToSurround, height_or_margin, radius) {};
 /** @type {!MakerJs.IPoint} */
MakerJs.models.RoundRectangle.prototype.origin;
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.RoundRectangle.prototype.paths;

/**
 * @constructor
 * @struct
 * @param {number} width
 * @param {number} height
 */
MakerJs.models.Oval = function(width, height) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.Oval.prototype.paths;

/**
 * @constructor
 * @struct
 * @param {number} startAngle
 * @param {number} endAngle
 * @param {number} sweepRadius
 * @param {number} slotRadius
 * @param {boolean=} selfIntersect
 * @param {boolean=} isolateCaps
 */
MakerJs.models.OvalArc = function(startAngle, endAngle, sweepRadius, slotRadius, selfIntersect, isolateCaps) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.OvalArc.prototype.paths;
 /** @type {!MakerJs.IModelMap} */
MakerJs.models.OvalArc.prototype.models;

/**
 * @constructor
 * @struct
 * Create a rectangle from width and height.
 * 
 * Example:
 * ```
 * //Create a rectangle from width and height
 * var makerjs = require('makerjs');
 * var model = new makerjs.models.Rectangle(50, 100);
 * var svg = makerjs.exporter.toSVG(model);
 * document.write(svg);
 * ```
 * 
 * Create a rectangle which will surround a model.
 * 
 * Example:
 * ```
 * //Create a rectangle which will surround a model
 * var makerjs = require('makerjs');
 * var e = new makerjs.models.Ellipse(17, 10); // draw an ellipse so we have something to surround.
 * var r = new makerjs.models.Rectangle(e, 3); // draws a rectangle surrounding the ellipse by 3 units.
 * var svg = makerjs.exporter.toSVG({ models: { e: e, r: r }});
 * document.write(svg);
 * ```
 * 
 * Create a rectangle from a measurement.
 * 
 * Example:
 * ```
 * //Create a rectangle from a measurement.
 * var makerjs = require('makerjs');
 * var e = new makerjs.models.Ellipse(17, 10); // draw an ellipse so we have something to measure.
 * var m = makerjs.measure.modelExtents(e);    // measure the ellipse.
 * var r = new makerjs.models.Rectangle(m);    // draws a rectangle surrounding the ellipse.
 * var svg = makerjs.exporter.toSVG({ models: { e: e, r: r }});
 * document.write(svg);
 * ```
 * 
 * @param {number|!MakerJs.IModel|!MakerJs.IMeasure} width_or_modelToSurround_or_measurement Width of the rectangle. / IModel object. / IMeasure object. See http://microsoft.github.io/maker.js/docs/api/modules/makerjs.measure.html#pathextents and http://microsoft.github.io/maker.js/docs/api/modules/makerjs.measure.html#modelextents to get measurements of paths and models.
 * @param {number=} height_or_margin Height of the rectangle. / Optional distance from the model.
 */
MakerJs.models.Rectangle = function(width_or_modelToSurround_or_measurement, height_or_margin) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.Rectangle.prototype.paths;
 /** @type {!MakerJs.IPoint} */
MakerJs.models.Rectangle.prototype.origin;

/**
 * @constructor
 * @struct
 * @param {number} outerRadius
 * @param {number} innerRadius
 */
MakerJs.models.Ring = function(outerRadius, innerRadius) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.Ring.prototype.paths;

/**
 * @constructor
 * @struct
 * @param {number} width
 * @param {number} height
 */
MakerJs.models.SCurve = function(width, height) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.SCurve.prototype.paths;

/**
 * @constructor
 * @struct
 * @param {!MakerJs.IPoint} origin
 * @param {!MakerJs.IPoint} endPoint
 * @param {number} radius
 * @param {boolean=} isolateCaps
 */
MakerJs.models.Slot = function(origin, endPoint, radius, isolateCaps) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.Slot.prototype.paths;
 /** @type {!MakerJs.IPoint} */
MakerJs.models.Slot.prototype.origin;
 /** @type {!MakerJs.IModelMap} */
MakerJs.models.Slot.prototype.models;

/**
 * @constructor
 * @struct
 * @param {number} side
 */
MakerJs.models.Square = function(side) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.Square.prototype.paths;

/**
 * @constructor
 * @struct
 * @param {number} numberOfPoints
 * @param {number} outerRadius
 * @param {number=} innerRadius
 * @param {number=} skipPoints
 */
MakerJs.models.Star = function(numberOfPoints, outerRadius, innerRadius, skipPoints) {};
 /** @type {!MakerJs.IPathMap} */
MakerJs.models.Star.prototype.paths;

/**
 * @param {number} numberOfPoints
 * @param {number} skipPoints
 * @return {number}
 */
MakerJs.models.Star.InnerRadiusRatio = function(numberOfPoints, skipPoints) {};

/**
 * @constructor
 * @struct
 * @param {?} font
 * @param {string} text
 * @param {number} fontSize
 * @param {boolean=} combine
 * @param {boolean=} centerCharacterOrigin
 * @param {number=} bezierAccuracy
 */
MakerJs.models.Text = function(font, text, fontSize, combine, centerCharacterOrigin, bezierAccuracy) {};
 /** @type {!MakerJs.IModelMap} */
MakerJs.models.Text.prototype.models;
