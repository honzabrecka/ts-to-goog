/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/rsvp/index.d.ts:
/** @const */
var RSVP = {};

/** @typedef {function(T): (U|!RSVP.Thenable<U, C>)} */
RSVP.Resolution;

/** @typedef {function(C): (D|!RSVP.Thenable<T, D>)} */
RSVP.Rejection;
/**
 * @record
 * @struct
 */
RSVP.Thenable = function() {};

/**
 * @template U, D
 * @param {string|function(T): (U|!RSVP.Thenable<U, C>)=} label_or_onFulfillment
 * @param {string|function(C): (D|!RSVP.Thenable<T, D>)=} label_or_onRejected
 * @param {string=} label
 * @return {!RSVP.Thenable|!RSVP.Thenable<U, C>|!RSVP.Thenable<U, D>}
 */
RSVP.Thenable.prototype.then = function(label_or_onFulfillment, label_or_onRejected, label) {};
/**
 * @record
 * @struct
 */
RSVP.Catchable = function() {};

/**
 * @template D
 * @param {string|function(C): D=} label_or_onRejection
 * @param {string=} label
 * @return {!RSVP.Catchable|!RSVP.Catchable<D>}
 */
RSVP.Catchable.prototype.catch = function(label_or_onRejection, label) {};
/**
 * @record
 * @struct
 */
RSVP.Deferred = function() {};
 /** @type {!RSVP.Promise<T, C>} */
RSVP.Deferred.prototype.promise;

/**
 * @param {T} value
 * @return {void}
 */
RSVP.Deferred.prototype.resolve = function(value) {};

/**
 * @param {C} reason
 * @return {void}
 */
RSVP.Deferred.prototype.reject = function(reason) {};

/** @typedef {string} */
RSVP.PromiseStates;
/**
 * @record
 * @struct
 */
RSVP.IPromiseState = function() {};
 /** @type {string} */
RSVP.IPromiseState.prototype.state;
 /** @type {T} */
RSVP.IPromiseState.prototype.value;
 /** @type {C} */
RSVP.IPromiseState.prototype.reason;
/**
 * @implements {RSVP.IPromiseState}
 * @constructor
 * @struct
 */
RSVP.Resolved = function() {};
 /** @type {string} */
RSVP.Resolved.prototype.state;
 /** @type {T} */
RSVP.Resolved.prototype.value;
 /** @type {?} */
RSVP.Resolved.prototype.reason;
/**
 * @implements {RSVP.IPromiseState}
 * @constructor
 * @struct
 */
RSVP.Rejected = function() {};
 /** @type {string} */
RSVP.Rejected.prototype.state;
 /** @type {?} */
RSVP.Rejected.prototype.value;
 /** @type {C} */
RSVP.Rejected.prototype.reason;
/**
 * @implements {RSVP.IPromiseState}
 * @constructor
 * @struct
 */
RSVP.Pending = function() {};
 /** @type {string} */
RSVP.Pending.prototype.state;
 /** @type {?} */
RSVP.Pending.prototype.value;
 /** @type {?} */
RSVP.Pending.prototype.reason;

/** @typedef {(!RSVP.Resolved<T, C>|!RSVP.Rejected<C, C>|!RSVP.Pending<T, C>)} */
RSVP.PromiseState;

/** @typedef {?} */
RSVP.PromiseHash;

/** @typedef {?} */
RSVP.SettledHash;
/**
 * @record
 * @struct
 */
RSVP.InstrumentEvent = function() {};
 /** @type {string} */
RSVP.InstrumentEvent.prototype.guid;
 /** @type {string} */
RSVP.InstrumentEvent.prototype.childGuid;
 /** @type {string} */
RSVP.InstrumentEvent.prototype.eventName;
 /** @type {?} */
RSVP.InstrumentEvent.prototype.detail;
 /** @type {string} */
RSVP.InstrumentEvent.prototype.label;
 /** @type {number} */
RSVP.InstrumentEvent.prototype.timeStamp;
/**
 * @record
 * @struct
 */
RSVP.ObjectWithEventMixins = function() {};

/**
 * @param {string} eventName
 * @param {function(!RSVP.InstrumentEvent): void|function(?): void} listener_or_errorHandler_or_callback
 * @return {void}
 */
RSVP.ObjectWithEventMixins.prototype.on = function(eventName, listener_or_errorHandler_or_callback) {};

/**
 * @param {string} eventName
 * @param {function(?): void=} callback
 * @return {void}
 */
RSVP.ObjectWithEventMixins.prototype.off = function(eventName, callback) {};

/**
 * @param {string} eventName
 * @param {?=} options
 * @param {string=} label
 * @return {void}
 */
RSVP.ObjectWithEventMixins.prototype.trigger = function(eventName, options, label) {};

/**
 * @constructor
 * @struct
 * If you call resolve in the body of the callback passed to the constructor,
 * your promise is fulfilled with result object passed to resolve.
 * If you call reject your promise is rejected with the object passed to reject.
 * For consistency and debugging (eg stack traces), obj should be an instanceof Error.
 * Any errors thrown in the constructor callback will be implicitly passed to reject().
 * @param {function(function((T|!RSVP.Thenable<T, ?>)): void, function((C|!RSVP.Thenable<?, C>)): void): void} callback
 * @param {string=} label
 */
RSVP.Promise = function(callback, label) {};

/**
 * onFulfillment is called when/if "promise" resolves. onRejected is called when/if "promise" rejects.
 * Both are optional, if either/both are omitted the next onFulfillment/onRejected in the chain is called.
 * Both callbacks have a single parameter , the fulfillment value or rejection reason.
 * "then" returns a new promise equivalent to the value you return from onFulfillment/onRejected after being passed through Promise.resolve.
 * If an error is thrown in the callback, the returned promise rejects with that error.
 * 
 * @template U, D
 * @param {function(T): (U|!RSVP.Thenable<U, C>)|string=} onFulfillment_or_label called when/if "promise" resolves
 * @param {function(C): (D|!RSVP.Thenable<T, D>)|string=} onRejected_or_label called when/if "promise" rejects
 * @param {string=} label useful for tooling
 * @return {!RSVP.Promise<U, D>|!RSVP.Promise<U, C>|!RSVP.Promise}
 */
RSVP.Promise.prototype.then = function(onFulfillment_or_label, onRejected_or_label, label) {};

/**
 * Sugar for promise.then(undefined, onRejected)
 * @template D
 * @param {string|function(C): (D|!RSVP.Thenable<T, D>)=} label_or_onRejection
 * @param {string=} label
 * @return {!RSVP.Promise|!RSVP.Promise<T, D>}
 */
RSVP.Promise.prototype.catch = function(label_or_onRejection, label) {};

/**
 * @param {!Function} finallyCallback
 * @return {!RSVP.Promise}
 */
RSVP.Promise.prototype.finally = function(finallyCallback) {};

/**
 * `RSVP.Promise.all` accepts an array of promises, and returns a new promise which
 * is fulfilled with an array of fulfillment values for the passed promises, or
 * rejected with the reason of the first passed promise to be rejected. It casts all
 * elements of the passed iterable to promises as it runs this algorithm.
 * @template T, C
 * @param {!Array<!RSVP.Thenable<T, C>>} promises
 * @param {string=} label
 * @return {!RSVP.Promise<!Array<T>, C>}
 */
RSVP.Promise.all = function(promises, label) {};

/**
 * `RSVP.Promise.race` returns a new promise which is settled in the same way as the
 * first passed promise to settle.
 * 
 * `RSVP.Promise.race` is deterministic in that only the state of the first
 * settled promise matters. For example, even if other promises given to the
 * `promises` array argument are resolved, but the first settled promise has
 * become rejected before the other promises became fulfilled, the returned
 * promise will become rejected.
 * @template T, C
 * @param {!Array<!RSVP.Promise<T, C>>} promises
 * @return {!RSVP.Promise<T, C>}
 */
RSVP.Promise.race = function(promises) {};

/**
 * Returns a promise that will become resolved with the passed `value`
 * @template T
 * @param {T} value
 * @param {string=} label
 * @return {!RSVP.Promise<T, ?>}
 */
RSVP.Promise.resolve = function(value, label) {};

/**
 * Deprecated in favor of resolve
 * @template T
 * @param {T} value
 * @param {string=} label
 * @return {!RSVP.Promise<T, ?>}
 */
RSVP.Promise.cast = function(value, label) {};

/**
 * Returns a promise rejected with the passed `reason`.
 * @template C
 * @param {C} reason
 * @return {!RSVP.Promise<?, C>}
 */
RSVP.Promise.reject = function(reason) {};
/** @const */
RSVP.EventTarget = {};

/**
 * `RSVP.EventTarget.mixin` extends an object with EventTarget methods.
 * @param {!Object} object
 * @return {!RSVP.ObjectWithEventMixins}
 */
RSVP.EventTarget.mixin = function(object) {};

/**
 * Registers a callback to be executed when `eventName` is triggered
 * @param {string} eventName
 * @param {function(!RSVP.InstrumentEvent): void|function(?): void} listener_or_errorHandler_or_callback
 * @return {void}
 */
RSVP.EventTarget.on = function(eventName, listener_or_errorHandler_or_callback) {};

/**
 * You can use `off` to stop firing a particular callback for an event.
 * 
 * If you don't pass a `callback` argument to `off`, ALL callbacks for the
 * event will not be executed when the event fires.
 * @param {string} eventName
 * @param {function(?): void=} callback
 * @return {void}
 */
RSVP.EventTarget.off = function(eventName, callback) {};

/**
 * Use `trigger` to fire custom events.
 * 
 * You can also pass a value as a second argument to `trigger` that will be
 * passed as an argument to all event listeners for the event
 * @param {string} eventName
 * @param {?=} options
 * @param {string=} label
 * @return {void}
 */
RSVP.EventTarget.trigger = function(eventName, options, label) {};

/**
 * @param {string} configName
 * @param {boolean|?} shouldInstrument_or_value
 * @return {void}
 */
RSVP.configure = function(configName, shouldInstrument_or_value) {};

/**
 * Make a promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
 * the array passed to all can be a mixture of promise-like objects and other objects.
 * The fulfillment value is an array (in order) of fulfillment values. The rejection value is the first rejection value.
 * @template T, C
 * @param {!Array<!RSVP.Thenable<T, C>>} promises
 * @return {!RSVP.Promise<!Array<T>, C>}
 */
RSVP.all = function(promises) {};

/**
 *  `RSVP.hash` is similar to `RSVP.all`, but takes an object instead of an array
 *  for its `promises` argument.
 * 
 *  Returns a promise that is fulfilled when all the given promises have been
 *  fulfilled, or rejected if any of them become rejected. The returned promise
 *  is fulfilled with a hash that has the same key names as the `promises` object
 *  argument. If any of the values in the object are not promises, they will
 *  simply be copied over to the fulfilled object.
 * 
 *  If any of the `promises` given to `RSVP.hash` are rejected, the first promise
 *  that is rejected will be given as the reason to the rejection handler.
 * @template T, C
 * @param {?} promises
 * @return {!RSVP.Promise<T, C>}
 */
RSVP.hash = function(promises) {};

/**
 * `RSVP.map` is similar to JavaScript's native `map` method. `mapFn` is eagerly called
 * meaning that as soon as any promise resolves its value will be passed to `mapFn`.
 * `RSVP.map` returns a promise that will become fulfilled with the result of running
 * `mapFn` on the values the promises become fulfilled with.
 * 
 * If any of the `promises` given to `RSVP.map` are rejected, the first promise
 * that is rejected will be given as an argument to the returned promise's
 * rejection handler.
 * @template T, U, C
 * @param {!Array<!RSVP.Thenable<T, C>>} promises
 * @param {function(T): U} mapFn
 * @param {string=} label
 * @return {!RSVP.Promise<!Array<U>, C>}
 */
RSVP.map = function(promises, mapFn, label) {};

/**
 * `RSVP.allSettled` is similar to `RSVP.all`, but instead of implementing
 * a fail-fast method, it waits until all the promises have returned and
 * shows you all the results. This is useful if you want to handle multiple
 * promises' failure states together as a set.
 * @template T, C
 * @param {!Array<!RSVP.Thenable<T, C>>} promises
 * @return {!RSVP.Promise<!Array<(!RSVP.Resolved<T, C>|!RSVP.Rejected<C, C>|!RSVP.Pending<T, C>)>, C>}
 */
RSVP.allSettled = function(promises) {};

/**
 * `RSVP.hashSettled` is similar to `RSVP.allSettled`, but takes an object
 * instead of an array for its `promises` argument.
 * 
 * Unlike `RSVP.all` or `RSVP.hash`, which implement a fail-fast method,
 * but like `RSVP.allSettled`, `hashSettled` waits until all the
 * constituent promises have returned and then shows you all the results
 * with their states and values/reasons. This is useful if you want to
 * handle multiple promises' failure states together as a set.
 * @template T, C
 * @param {?} promises
 * @return {!RSVP.Promise<?, C>}
 */
RSVP.hashSettled = function(promises) {};

/**
 * Make a Promise that fulfills when any item fulfills, and rejects if any item rejects.
 * @template T, C
 * @param {!Array<!RSVP.Promise<T, C>>} promises
 * @return {!RSVP.Promise<T, C>}
 */
RSVP.race = function(promises) {};

/**
 * `RSVP.denodeify` takes a "node-style" function and returns a function that
 *  will return an `RSVP.Promise`. You can use `denodeify` in Node.js or the
 *  browser when you'd prefer to use promises over using callbacks. For example,
 * `denodeify` transforms the following:
 * 
 * ```
 * let fs = require('fs');
 * 
 * fs.readFile('myfile.txt', function(err, data){
 *   if (err) return handleError(err);
 *   handleData(data);
 * });
 * ```
 * 
 * into:
 * 
 * ```
 * let fs = require('fs');
 * let readFile = RSVP.denodeify(fs.readFile);
 * 
 * readFile('myfile.txt').then(handleData, handleError);
 * ```
 * 
 * If the node function has multiple success parameters, then denodeify just
 * returns the first one:
 * 
 * ```
 * let request = RSVP.denodeify(require('request'));
 * 
 * request('http://example.com').then(function(res) {
 *   // ...
 * });
 * ```
 * 
 * However, if you need all success parameters, setting denodeify's second
 * parameter to true causes it to return all success parameters as an array:
 * 
 * ```
 * let request = RSVP.denodeify(require('request'), true);
 * 
 * request('http://example.com').then(function(result) {
 *   // result[0] -> res
 *   // result[1] -> body
 * });
 * ```
 * 
 * Or if you pass it an array with names it returns the parameters as a hash:
 * 
 * ```
 * let request = RSVP.denodeify(require('request'), ['res', 'body']);
 * 
 * request('http://example.com').then(function(result) {
 *   // result.res
 *   // result.body
 * });
 * ```
 * @template A, T, C
 * @param {!Function} nodeFunction
 * @param {(boolean|!Array<string>)} options
 * @return {function(!Array<A>): !RSVP.Promise<T, C>}
 */
RSVP.denodeify = function(nodeFunction, options) {};

/**
 * `RSVP.defer` returns an object similar to jQuery's `$.Deferred`.
 * `RSVP.defer` should be used when porting over code reliant on `$.Deferred`'s
 * interface. New code should use the `RSVP.Promise` constructor instead.
 * 
 * The object returned from `RSVP.defer` is a plain object with three properties:
 * * promise - an `RSVP.Promise`.
 * * reject - a function that causes the `promise` property on this object to become rejected
 * * resolve - a function that causes the `promise` property on this object to become fulfilled.
 * @template T, C
 * @param {string=} label
 * @return {!RSVP.Deferred<T, C>}
 */
RSVP.defer = function(label) {};

/**
 * `RSVP.Promise.reject` returns a promise rejected with the passed `reason`.
 * @template C
 * @param {C} reason
 * @return {!RSVP.Promise<?, C>}
 */
RSVP.reject = function(reason) {};

/**
 * `RSVP.Promise.resolve` returns a promise that will become resolved with the
 * passed `value`.
 * @template T
 * @param {T} value
 * @return {!RSVP.Promise<T, ?>}
 */
RSVP.resolve = function(value) {};

/**
 * `RSVP.filter` is similar to JavaScript's native `filter` method, except that it
 * waits for all promises to become fulfilled before running the `filterFn` on
 * each item in given to `promises`. `RSVP.filter` returns a promise that will
 * become fulfilled with the result of running `filterFn` on the values the
 * promises become fulfilled with.
 * @template T, C
 * @param {!Array<!RSVP.Thenable<T, C>>} promises
 * @param {function(T): (boolean|!RSVP.Promise<?, ?>)} filterFn
 * @return {!RSVP.Promise<!Array<T>, C>}
 */
RSVP.filter = function(promises, filterFn) {};

/**
 * `RSVP.rethrow` will rethrow an error on the next turn of the JavaScript event
 * loop in order to aid debugging.
 * 
 * Promises A+ specifies that any exceptions that occur with a promise must be
 * caught by the promises implementation and bubbled to the last handler. For
 * this reason, it is recommended that you always specify a second rejection
 * handler function to `then`. However, `RSVP.rethrow` will throw the exception
 * outside of the promise, so it bubbles up to your console if in the browser,
 * or domain/cause uncaught exception in Node. `rethrow` will also throw the
 * error again so the error can be handled by the promise per the spec.
 * @template C
 * @param {C} reason
 * @return {void}
 */
RSVP.rethrow = function(reason) {};

/* TODO: ExportAssignment in  */
