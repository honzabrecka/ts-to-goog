/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/source-map/index.d.ts:

/* TODO: NamespaceExportDeclaration in  */
/**
 * @record
 * @struct
 */
function StartOfSourceMap() {}
 /** @type {string} */
StartOfSourceMap.prototype.file;
 /** @type {string} */
StartOfSourceMap.prototype.sourceRoot;
 /** @type {boolean} */
StartOfSourceMap.prototype.skipValidation;
/**
 * @record
 * @struct
 */
function RawSourceMap() {}
 /** @type {number} */
RawSourceMap.prototype.version;
 /** @type {!Array<string>} */
RawSourceMap.prototype.sources;
 /** @type {!Array<string>} */
RawSourceMap.prototype.names;
 /** @type {string} */
RawSourceMap.prototype.sourceRoot;
 /** @type {!Array<string>} */
RawSourceMap.prototype.sourcesContent;
 /** @type {string} */
RawSourceMap.prototype.mappings;
 /** @type {string} */
RawSourceMap.prototype.file;
/**
 * @extends {StartOfSourceMap}
 * @record
 * @struct
 */
function RawIndexMap() {}
 /** @type {number} */
RawIndexMap.prototype.version;
 /** @type {!Array<?>} */
RawIndexMap.prototype.sections;
/**
 * @record
 * @struct
 */
function RawSection() {}
 /** @type {?} */
RawSection.prototype.offset;
 /** @type {?} */
RawSection.prototype.map;
/**
 * @record
 * @struct
 */
function Position() {}
 /** @type {number} */
Position.prototype.line;
 /** @type {number} */
Position.prototype.column;
/**
 * @record
 * @struct
 */
function NullablePosition() {}
 /** @type {number} */
NullablePosition.prototype.line;
 /** @type {number} */
NullablePosition.prototype.column;
 /** @type {number} */
NullablePosition.prototype.lastColumn;
/**
 * @record
 * @struct
 */
function MappedPosition() {}
 /** @type {string} */
MappedPosition.prototype.source;
 /** @type {number} */
MappedPosition.prototype.line;
 /** @type {number} */
MappedPosition.prototype.column;
 /** @type {string} */
MappedPosition.prototype.name;
/**
 * @record
 * @struct
 */
function NullableMappedPosition() {}
 /** @type {string} */
NullableMappedPosition.prototype.source;
 /** @type {number} */
NullableMappedPosition.prototype.line;
 /** @type {number} */
NullableMappedPosition.prototype.column;
 /** @type {string} */
NullableMappedPosition.prototype.name;
/**
 * @record
 * @struct
 */
function MappingItem() {}
 /** @type {string} */
MappingItem.prototype.source;
 /** @type {number} */
MappingItem.prototype.generatedLine;
 /** @type {number} */
MappingItem.prototype.generatedColumn;
 /** @type {number} */
MappingItem.prototype.originalLine;
 /** @type {number} */
MappingItem.prototype.originalColumn;
 /** @type {string} */
MappingItem.prototype.name;
/**
 * @record
 * @struct
 */
function Mapping() {}
 /** @type {?} */
Mapping.prototype.generated;
 /** @type {?} */
Mapping.prototype.original;
 /** @type {string} */
Mapping.prototype.source;
 /** @type {string} */
Mapping.prototype.name;
/**
 * @record
 * @struct
 */
function CodeWithSourceMap() {}
 /** @type {string} */
CodeWithSourceMap.prototype.code;
 /** @type {?} */
CodeWithSourceMap.prototype.map;
/**
 * @record
 * @struct
 */
function SourceMapConsumer() {}

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 * @return {void}
 */
SourceMapConsumer.prototype.computeColumnSpans = function() {};

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 * 
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 * 
 * and an object is returned with the following properties:
 * 
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 * @param {?} generatedPosition
 * @return {?}
 */
SourceMapConsumer.prototype.originalPositionFor = function(generatedPosition) {};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 * 
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 * 
 * and an object is returned with the following properties:
 * 
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 * @param {?} originalPosition
 * @return {?}
 */
SourceMapConsumer.prototype.generatedPositionFor = function(originalPosition) {};

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 * 
 * The only argument is an object with the following properties:
 * 
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 * 
 * and an array of objects is returned, each with the following properties:
 * 
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 * @param {?} originalPosition
 * @return {!Array<?>}
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor = function(originalPosition) {};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 * @return {boolean}
 */
SourceMapConsumer.prototype.hasContentsOfAllSources = function() {};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 * @param {string} source
 * @param {boolean=} returnNullOnMissing
 * @return {string}
 */
SourceMapConsumer.prototype.sourceContentFor = function(source, returnNullOnMissing) {};

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 * 
 * @param {?} callback 
 *        The function that is called with each mapping.
 * @param {?=} context 
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param {number=} order 
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 * @return {void}
 */
SourceMapConsumer.prototype.eachMapping = function(callback, context, order) {};
/**
 * @record
 * @struct
 */
function SourceMapConsumerConstructor() {}
 /** @type {?} */
SourceMapConsumerConstructor.prototype.prototype;
 /** @type {number} */
SourceMapConsumerConstructor.prototype.GENERATED_ORDER;
 /** @type {number} */
SourceMapConsumerConstructor.prototype.ORIGINAL_ORDER;
 /** @type {number} */
SourceMapConsumerConstructor.prototype.GREATEST_LOWER_BOUND;
 /** @type {number} */
SourceMapConsumerConstructor.prototype.LEAST_UPPER_BOUND;

/* TODO: ConstructSignature:  */

/* TODO: ConstructSignature:  */

/* TODO: ConstructSignature:  */

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 * 
 * @param {?} sourceMap 
 *        The source map that will be consumed.
 * @return {?}
 */
SourceMapConsumerConstructor.prototype.fromSourceMap = function(sourceMap) {};
 /** @type {?} */
var SourceMapConsumer;
/**
 * @record
 * @struct
 */
function BasicSourceMapConsumer() {}
 /** @type {string} */
BasicSourceMapConsumer.prototype.file;
 /** @type {string} */
BasicSourceMapConsumer.prototype.sourceRoot;
 /** @type {!Array<string>} */
BasicSourceMapConsumer.prototype.sources;
 /** @type {!Array<string>} */
BasicSourceMapConsumer.prototype.sourcesContent;
/**
 * @record
 * @struct
 */
function BasicSourceMapConsumerConstructor() {}
 /** @type {?} */
BasicSourceMapConsumerConstructor.prototype.prototype;

/* TODO: ConstructSignature:  */

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 * 
 * @param {?} sourceMap 
 *        The source map that will be consumed.
 * @return {?}
 */
BasicSourceMapConsumerConstructor.prototype.fromSourceMap = function(sourceMap) {};
 /** @type {?} */
var BasicSourceMapConsumer;
/**
 * @record
 * @struct
 */
function IndexedSourceMapConsumer() {}
 /** @type {!Array<string>} */
IndexedSourceMapConsumer.prototype.sources;
/**
 * @record
 * @struct
 */
function IndexedSourceMapConsumerConstructor() {}
 /** @type {?} */
IndexedSourceMapConsumerConstructor.prototype.prototype;

/* TODO: ConstructSignature:  */
 /** @type {?} */
var IndexedSourceMapConsumer;

/**
 * @constructor
 * @struct
 * @param {?=} startOfSourceMap
 */
function SourceMapGenerator(startOfSourceMap) {}

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 * 
 * @param {?} sourceMapConsumer The SourceMap.
 * @return {?}
 */
SourceMapGenerator.fromSourceMap = function(sourceMapConsumer) {};

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 * 
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 * @param {?} mapping
 * @return {void}
 */
SourceMapGenerator.prototype.addMapping = function(mapping) {};

/**
 * Set the source content for a source file.
 * @param {string} sourceFile
 * @param {string} sourceContent
 * @return {void}
 */
SourceMapGenerator.prototype.setSourceContent = function(sourceFile, sourceContent) {};

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 * 
 * @param {?} sourceMapConsumer The source map to be applied.
 * @param {string=} sourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param {string=} sourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 * @return {void}
 */
SourceMapGenerator.prototype.applySourceMap = function(sourceMapConsumer, sourceFile, sourceMapPath) {};

/**
 * @return {string}
 */
SourceMapGenerator.prototype.toString = function() {};

/**
 * @return {?}
 */
SourceMapGenerator.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {number=} line
 * @param {number=} column
 * @param {string=} source
 * @param {(string|?|!Array<(string|?)>)=} chunks
 * @param {string=} name
 */
function SourceNode(line, column, source, chunks, name) {}
 /** @type {!Array<?>} */
SourceNode.prototype.children;
 /** @type {?} */
SourceNode.prototype.sourceContents;
 /** @type {number} */
SourceNode.prototype.line;
 /** @type {number} */
SourceNode.prototype.column;
 /** @type {string} */
SourceNode.prototype.source;
 /** @type {string} */
SourceNode.prototype.name;

/**
 * @param {string} code
 * @param {?} sourceMapConsumer
 * @param {string=} relativePath
 * @return {?}
 */
SourceNode.fromStringWithSourceMap = function(code, sourceMapConsumer, relativePath) {};

/**
 * @param {(string|?|!Array<(string|?)>)} chunk
 * @return {?}
 */
SourceNode.prototype.add = function(chunk) {};

/**
 * @param {(string|?|!Array<(string|?)>)} chunk
 * @return {?}
 */
SourceNode.prototype.prepend = function(chunk) {};

/**
 * @param {string} sourceFile
 * @param {string} sourceContent
 * @return {void}
 */
SourceNode.prototype.setSourceContent = function(sourceFile, sourceContent) {};

/**
 * @param {?} fn
 * @return {void}
 */
SourceNode.prototype.walk = function(fn) {};

/**
 * @param {?} fn
 * @return {void}
 */
SourceNode.prototype.walkSourceContents = function(fn) {};

/**
 * @param {string} sep
 * @return {?}
 */
SourceNode.prototype.join = function(sep) {};

/**
 * @param {string} pattern
 * @param {string} replacement
 * @return {?}
 */
SourceNode.prototype.replaceRight = function(pattern, replacement) {};

/**
 * @return {string}
 */
SourceNode.prototype.toString = function() {};

/**
 * @param {?=} startOfSourceMap
 * @return {?}
 */
SourceNode.prototype.toStringWithSourceMap = function(startOfSourceMap) {};
