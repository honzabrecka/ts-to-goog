/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/rx-lite-experimental/index.d.ts:

/**
 *  Returns an observable sequence that is the result of invoking the selector on the source sequence, without sharing subscriptions.
 *  This operator allows for a fluent style of writing queries that use the same sequence multiple times.
 * 
 * @template TResult
 * @param {function(?): ?<TResult>} selector Selector function which can use the source sequence as many times as needed, without sharing subscriptions to the source sequence.
 * @return {?<TResult>} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
 */
Rx.Observable.prototype.let = function(selector) {};

/**
 *  Returns an observable sequence that is the result of invoking the selector on the source sequence, without sharing subscriptions.
 *  This operator allows for a fluent style of writing queries that use the same sequence multiple times.
 * 
 * @template TResult
 * @param {function(?): ?<TResult>} selector Selector function which can use the source sequence as many times as needed, without sharing subscriptions to the source sequence.
 * @return {?<TResult>} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
 */
Rx.Observable.prototype.letBind = function(selector) {};

/**
 *  Repeats source as long as condition holds emulating a do while loop.
 * @param {function(): boolean} condition The condition which determines if the source will be repeated.
 * @return {?} An observable sequence which is repeated as long as the condition holds.
 */
Rx.Observable.prototype.doWhile = function(condition) {};

/**
 *  Expands an observable sequence by recursively invoking selector.
 * 
 * @param {function(T): ?} selector Selector function to invoke for each produced element, resulting in another sequence to which the selector will be invoked recursively again.
 * @param {!Rx.IScheduler=} scheduler
 * @return {?} An observable sequence containing all the elements produced by the recursive expansion.
 */
Rx.Observable.prototype.expand = function(selector, scheduler) {};

/**
 *  Runs two observable sequences in parallel and combines their last elemenets.
 * 
 * @template TSecond, TResult
 * @param {?<TSecond>|!Rx.IPromise<TSecond>} second Second observable sequence or promise.
 * @param {function(T, TSecond): TResult} resultSelector Result selector function to invoke with the last elements of both sequences.
 * @return {?<TResult>} An observable sequence with the result of calling the selector function with the last elements of both input sequences.
 */
Rx.Observable.prototype.forkJoin = function(second, resultSelector) {};

/**
 * Comonadic bind operator.
 * @template TResult
 * @param {function(?, number, ?): TResult} selector A transform function to apply to each element.
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<TResult>} An observable sequence which results from the comonadic bind operation.
 */
Rx.Observable.prototype.manySelect = function(selector, scheduler) {};

/**
 *  Determines whether an observable collection contains values. There is an alias for this method called 'ifThen' for browsers <IE9
 * 
 * \@example 
 * res = Rx.Observable.if(condition, obs1, obs2);
 *  Determines whether an observable collection contains values. There is an alias for this method called 'ifThen' for browsers <IE9
 * 
 * \@example 
 * res = Rx.Observable.if(condition, obs1, scheduler);
 * @template T
 * @param {function(): boolean} condition The condition which determines if the thenSource or elseSource will be run. / The condition which determines if the thenSource or empty sequence will be run.
 * @param {?<T>|!Rx.IPromise<T>} thenSource The observable sequence or promise that will be run if the condition function returns true.
 * @param {?<T>|!Rx.IPromise<T>|!Rx.IScheduler=} elseSource_or_scheduler The observable sequence or promise that will be run if the condition function returns false. / Scheduler used to create Rx.Observabe.Empty.
 * @return {?<T>} An observable sequence which is either the thenSource or elseSource. / An observable sequence which is either the thenSource or empty sequence.
 */
Rx.ObservableStatic.prototype.if = function(condition, thenSource, elseSource_or_scheduler) {};

/**
 *  Determines whether an observable collection contains values. There is an alias for this method called 'ifThen' for browsers <IE9
 * 
 * \@example 
 * res = Rx.Observable.if(condition, obs1, obs2);
 *  Determines whether an observable collection contains values. There is an alias for this method called 'ifThen' for browsers <IE9
 * 
 * \@example 
 * res = Rx.Observable.if(condition, obs1, scheduler);
 * @template T
 * @param {function(): boolean} condition The condition which determines if the thenSource or elseSource will be run. / The condition which determines if the thenSource or empty sequence will be run.
 * @param {?<T>|!Rx.IPromise<T>} thenSource The observable sequence or promise that will be run if the condition function returns true.
 * @param {?<T>|!Rx.IPromise<T>|!Rx.IScheduler=} elseSource_or_scheduler The observable sequence or promise that will be run if the condition function returns false. / Scheduler used to create Rx.Observabe.Empty.
 * @return {?<T>} An observable sequence which is either the thenSource or elseSource. / An observable sequence which is either the thenSource or empty sequence.
 */
Rx.ObservableStatic.prototype.ifThen = function(condition, thenSource, elseSource_or_scheduler) {};

/**
 *  Concatenates the observable sequences obtained by running the specified result selector for each element in source.
 * There is an alias for this method called 'forIn' for browsers <IE9
 * @template T, TResult
 * @param {!Array<T>} sources An array of values to turn into an observable sequence.
 * @param {function(T): ?<TResult>} resultSelector A function to apply to each item in the sources array to turn it into an observable sequence.
 * @return {?<TResult>} An observable sequence from the concatenated observable sequences.
 */
Rx.ObservableStatic.prototype.for = function(sources, resultSelector) {};

/**
 *  Concatenates the observable sequences obtained by running the specified result selector for each element in source.
 * There is an alias for this method called 'forIn' for browsers <IE9
 * @template T, TResult
 * @param {!Array<T>} sources An array of values to turn into an observable sequence.
 * @param {function(T): ?<TResult>} resultSelector A function to apply to each item in the sources array to turn it into an observable sequence.
 * @return {?<TResult>} An observable sequence from the concatenated observable sequences.
 */
Rx.ObservableStatic.prototype.forIn = function(sources, resultSelector) {};

/**
 *  Repeats source as long as condition holds emulating a while loop.
 * There is an alias for this method called 'whileDo' for browsers <IE9
 * @template T
 * @param {function(): boolean} condition The condition which determines if the source will be repeated.
 * @param {?<T>|!Rx.IPromise<T>} source The observable sequence or promise that will be run if the condition function returns true.
 * @return {?<T>} An observable sequence which is repeated as long as the condition holds.
 */
Rx.ObservableStatic.prototype.while = function(condition, source) {};

/**
 *  Repeats source as long as condition holds emulating a while loop.
 * There is an alias for this method called 'whileDo' for browsers <IE9
 * @template T
 * @param {function(): boolean} condition The condition which determines if the source will be repeated.
 * @param {?<T>|!Rx.IPromise<T>} source The observable sequence or promise that will be run if the condition function returns true.
 * @return {?<T>} An observable sequence which is repeated as long as the condition holds.
 */
Rx.ObservableStatic.prototype.whileDo = function(condition, source) {};

/**
 *  Uses selector to determine which source in sources to use.
 *  There is an alias 'switchCase' for browsers <IE9.
 * 
 * \@example 
 *  res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 }, obs0);
 *  Uses selector to determine which source in sources to use.
 *  There is an alias 'switchCase' for browsers <IE9.
 * 
 * \@example 
 *  res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 });
 *  res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 }, scheduler);
 * 
 *  Uses selector to determine which source in sources to use.
 *  There is an alias 'switchCase' for browsers <IE9.
 * 
 * \@example 
 *  res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 }, obs0);
 *  Uses selector to determine which source in sources to use.
 *  There is an alias 'switchCase' for browsers <IE9.
 * 
 * \@example 
 *  res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 });
 *  res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 }, scheduler);
 * 
 * @template T
 * @param {function(): string|function(): number} selector The function which extracts the value for to test in a case statement.
 * @param {!Object<string,?<T>>|!Object<string,!Rx.IPromise<T>>|!Object<number,?<T>>|!Object<number,!Rx.IPromise<T>>} sources A object which has keys which correspond to the case statement labels.
 * @param {?<T>|!Rx.IPromise<T>|!Rx.IScheduler=} elseSource_or_scheduler The observable sequence or promise that will be run if the sources are not matched.
 *  / Scheduler used to create Rx.Observabe.Empty.
 * 
 * @return {?<T>} An observable sequence which is determined by a case statement.
 */
Rx.ObservableStatic.prototype.case = function(selector, sources, elseSource_or_scheduler) {};

/**
 *  Uses selector to determine which source in sources to use.
 *  There is an alias 'switchCase' for browsers <IE9.
 * 
 * \@example 
 *  res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 }, obs0);
 *  Uses selector to determine which source in sources to use.
 *  There is an alias 'switchCase' for browsers <IE9.
 * 
 * \@example 
 *  res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 });
 *  res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 }, scheduler);
 * 
 *  Uses selector to determine which source in sources to use.
 *  There is an alias 'switchCase' for browsers <IE9.
 * 
 * \@example 
 *  res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 }, obs0);
 *  Uses selector to determine which source in sources to use.
 *  There is an alias 'switchCase' for browsers <IE9.
 * 
 * \@example 
 *  res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 });
 *  res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 }, scheduler);
 * 
 * @template T
 * @param {function(): string|function(): number} selector The function which extracts the value for to test in a case statement.
 * @param {!Object<string,?<T>>|!Object<string,!Rx.IPromise<T>>|!Object<number,?<T>>|!Object<number,!Rx.IPromise<T>>} sources A object which has keys which correspond to the case statement labels.
 * @param {?<T>|!Rx.IPromise<T>|!Rx.IScheduler=} elseSource_or_scheduler The observable sequence or promise that will be run if the sources are not matched.
 *  / Scheduler used to create Rx.Observabe.Empty.
 * 
 * @return {?<T>} An observable sequence which is determined by a case statement.
 */
Rx.ObservableStatic.prototype.switchCase = function(selector, sources, elseSource_or_scheduler) {};

/**
 *  Runs all observable sequences in parallel and collect their last elements.
 * 
 * \@example 
 * res = Rx.Observable.forkJoin([obs1, obs2]);
 *  Runs all observable sequences in parallel and collect their last elements.
 * 
 * \@example 
 * res = Rx.Observable.forkJoin(obs1, obs2, ...);
 * @template T
 * @param {...!Array<?<T>>|!Array<!Rx.IPromise<T>>|?<T>|!Rx.IPromise<T>} sources_or_args Array of source sequences or promises. / Source sequences or promises.
 * @return {?<!Array<T>>} An observable sequence with an array collecting the last elements of all the input sequences.
 */
Rx.ObservableStatic.prototype.forkJoin = function(sources_or_args) {};
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "rx-lite-experimental"
/** @const */
tsickle_declare_module.rx_lite_experimental = {};

/* TODO: ExportAssignment in tsickle_declare_module.rx_lite_experimental */
