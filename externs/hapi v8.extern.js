/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/hapi v8/index.d.ts:

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */
/**
 * @record
 * @struct
 */
function IDictionary() {}

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function IBoom() {}
 /** @type {boolean} */
IBoom.prototype.isBoom;
 /** @type {boolean} */
IBoom.prototype.isServer;
 /** @type {string} */
IBoom.prototype.message;
 /** @type {?} */
IBoom.prototype.output;

/**
 * reformat()rebuilds error.output using the other object properties.
 * @return {void}
 */
IBoom.prototype.reformat = function() {};
/**
 * @record
 * @struct
 */
function ICatBoxCacheOptions() {}
 /** @type {?} */
ICatBoxCacheOptions.prototype.engine;
 /** @type {string} */
ICatBoxCacheOptions.prototype.name;
 /** @type {boolean} */
ICatBoxCacheOptions.prototype.shared;
/**
 * @extends {IConnectionConfigurationServerDefaults}
 * @record
 * @struct
 */
function ISeverConnectionOptions() {}
 /** @type {string} */
ISeverConnectionOptions.prototype.host;
 /** @type {string} */
ISeverConnectionOptions.prototype.address;
 /** @type {(string|number)} */
ISeverConnectionOptions.prototype.port;
 /** @type {string} */
ISeverConnectionOptions.prototype.uri;
 /** @type {?} */
ISeverConnectionOptions.prototype.listener;
 /** @type {boolean} */
ISeverConnectionOptions.prototype.autoListen;
 /** @type {?} */
ISeverConnectionOptions.prototype.cache;
 /** @type {(string|!Array<string>)} */
ISeverConnectionOptions.prototype.labels;
 /** @type {boolean} */
ISeverConnectionOptions.prototype.tls;
/**
 * @record
 * @struct
 */
function IConnectionConfigurationServerDefaults() {}
 /** @type {?} */
IConnectionConfigurationServerDefaults.prototype.app;
 /** @type {?} */
IConnectionConfigurationServerDefaults.prototype.load;
 /** @type {?} */
IConnectionConfigurationServerDefaults.prototype.plugins;
 /** @type {?} */
IConnectionConfigurationServerDefaults.prototype.router;
 /** @type {?} */
IConnectionConfigurationServerDefaults.prototype.routes;
 /** @type {?} */
IConnectionConfigurationServerDefaults.prototype.state;
/**
 * @record
 * @struct
 */
function IServerOptions() {}
 /** @type {?} */
IServerOptions.prototype.app;
 /** @type {?} */
IServerOptions.prototype.cache;
 /** @type {?} */
IServerOptions.prototype.connections;
 /** @type {(boolean|?)} */
IServerOptions.prototype.debug;
 /** @type {?} */
IServerOptions.prototype.files;
 /** @type {?} */
IServerOptions.prototype.load;
 /** @type {?} */
IServerOptions.prototype.mime;
 /** @type {boolean} */
IServerOptions.prototype.minimal;
 /** @type {?} */
IServerOptions.prototype.plugins;
/**
 * @record
 * @struct
 */
function IServerViewCompile() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function IServerViewsAdditionalOptions() {}
 /** @type {string} */
IServerViewsAdditionalOptions.prototype.path;
 /** @type {string} */
IServerViewsAdditionalOptions.prototype.partialsPath;
 /** @type {string} */
IServerViewsAdditionalOptions.prototype.helpersPath;
 /** @type {string} */
IServerViewsAdditionalOptions.prototype.relativeTo;
 /** @type {boolean} */
IServerViewsAdditionalOptions.prototype.layout;
 /** @type {string} */
IServerViewsAdditionalOptions.prototype.layoutPath;
 /** @type {string} */
IServerViewsAdditionalOptions.prototype.layoutKeywork;
 /** @type {string} */
IServerViewsAdditionalOptions.prototype.encoding;
 /** @type {boolean} */
IServerViewsAdditionalOptions.prototype.isCached;
 /** @type {boolean} */
IServerViewsAdditionalOptions.prototype.allowAbsolutePaths;
 /** @type {boolean} */
IServerViewsAdditionalOptions.prototype.allowInsecureAccess;
 /** @type {?} */
IServerViewsAdditionalOptions.prototype.compileOptions;
 /** @type {?} */
IServerViewsAdditionalOptions.prototype.runtimeOptions;
 /** @type {string} */
IServerViewsAdditionalOptions.prototype.contentType;
 /** @type {string} */
IServerViewsAdditionalOptions.prototype.compileMode;
 /** @type {?} */
IServerViewsAdditionalOptions.prototype.context;
/**
 * @extends {IServerViewsAdditionalOptions}
 * @record
 * @struct
 */
function IServerViewsEnginesOptions() {}
 /** @type {?} */
IServerViewsEnginesOptions.prototype.module;
/**
 * @extends {IServerViewsAdditionalOptions}
 * @record
 * @struct
 */
function IServerViewsConfiguration() {}
 /** @type {?} */
IServerViewsConfiguration.prototype.engines;
 /** @type {string} */
IServerViewsConfiguration.prototype.defaultExtension;
/**
 * @record
 * @struct
 */
function IReplyMethods() {}

/**
 * Returns control back to the framework without setting a response. If called in the handler, the response defaults to an empty payload with status code 200.
 * The data argument is only used for passing back authentication data and is ignored elsewhere.
 * @param {?=} credentialData
 * @return {void}
 */
IReplyMethods.prototype.continue = function(credentialData) {};

/**
 * Transmits a file from the file system. The 'Content-Type' header defaults to the matching mime type based on filename extension.  The response flow control rules do not apply.
 * @param {string} path
 * @param {?=} options
 * @return {void}
 */
IReplyMethods.prototype.file = function(path, options) {};

/**
 * Concludes the handler activity by returning control over to the router with a templatized view response.
 * the response flow control rules apply.
 * @param {string} template
 * @param {!Object=} context
 * @param {?=} options
 * @return {!Response}
 */
IReplyMethods.prototype.view = function(template, context, options) {};

/**
 * Concludes the handler activity by returning control over to the router and informing the router that a response has already been sent back directly via request.raw.res and that no further response action is needed
 * The response flow control rules do not apply.
 * @param {?=} options
 * @return {void}
 */
IReplyMethods.prototype.close = function(options) {};

/**
 * Proxies the request to an upstream endpoint.
 * the response flow control rules do not apply.
 * @param {?} options
 * @return {void}
 */
IReplyMethods.prototype.proxy = function(options) {};

/**
 * Redirects the client to the specified uri. Same as calling reply().redirect(uri).
 * he response flow control rules apply.
 * @param {string} uri
 * @return {!Response}
 */
IReplyMethods.prototype.redirect = function(uri) {};
/**
 * @extends {IReplyMethods}
 * @record
 * @struct
 */
function IReply() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
/**
 * @extends {IReplyMethods}
 * @record
 * @struct
 */
function IStrictReply() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ISessionHandler() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function IStrictSessionHandler() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function IRequestHandler() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function IFailAction() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function IProxyHandlerConfig() {}
 /** @type {string} */
IProxyHandlerConfig.prototype.host;
 /** @type {number} */
IProxyHandlerConfig.prototype.port;
 /** @type {string} */
IProxyHandlerConfig.prototype.protocol;
 /** @type {string} */
IProxyHandlerConfig.prototype.uri;
 /** @type {boolean} */
IProxyHandlerConfig.prototype.passThrough;
 /** @type {boolean} */
IProxyHandlerConfig.prototype.localStatePassThrough;
 /** @type {boolean} */
IProxyHandlerConfig.prototype.acceptEncoding;
 /** @type {boolean} */
IProxyHandlerConfig.prototype.rejectUnauthorized;
 /** @type {boolean} */
IProxyHandlerConfig.prototype.xforward;
 /** @type {(number|boolean)} */
IProxyHandlerConfig.prototype.redirects;
 /** @type {number} */
IProxyHandlerConfig.prototype.timeout;
 /** @type {?} */
IProxyHandlerConfig.prototype.mapUri;
 /** @type {?} */
IProxyHandlerConfig.prototype.onResponse;
 /** @type {number} */
IProxyHandlerConfig.prototype.ttl;
 /** @type {!Agent} */
IProxyHandlerConfig.prototype.agent;
 /** @type {(number|boolean)} */
IProxyHandlerConfig.prototype.maxSockets;
/**
 * @record
 * @struct
 */
function IJoi() {}
/**
 * @record
 * @struct
 */
function IValidationFunction() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function IRouteFailFunction() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function IRouteAdditionalConfigurationOptions() {}
 /** @type {?} */
IRouteAdditionalConfigurationOptions.prototype.app;
 /** @type {(string|boolean|?)} */
IRouteAdditionalConfigurationOptions.prototype.auth;
 /** @type {?} */
IRouteAdditionalConfigurationOptions.prototype.bind;
 /** @type {?} */
IRouteAdditionalConfigurationOptions.prototype.cache;
 /** @type {?} */
IRouteAdditionalConfigurationOptions.prototype.cors;
 /** @type {?} */
IRouteAdditionalConfigurationOptions.prototype.files;
 /** @type {(string|?)} */
IRouteAdditionalConfigurationOptions.prototype.handler;
 /** @type {number} */
IRouteAdditionalConfigurationOptions.prototype.id;
 /** @type {?} */
IRouteAdditionalConfigurationOptions.prototype.json;
 /** @type {string} */
IRouteAdditionalConfigurationOptions.prototype.jsonp;
 /** @type {?} */
IRouteAdditionalConfigurationOptions.prototype.payload;
 /** @type {?} */
IRouteAdditionalConfigurationOptions.prototype.plugins;
 /** @type {!Array<?>} */
IRouteAdditionalConfigurationOptions.prototype.pre;
 /** @type {?} */
IRouteAdditionalConfigurationOptions.prototype.response;
 /** @type {(boolean|?)} */
IRouteAdditionalConfigurationOptions.prototype.security;
 /** @type {?} */
IRouteAdditionalConfigurationOptions.prototype.state;
 /** @type {?} */
IRouteAdditionalConfigurationOptions.prototype.validate;
 /** @type {?} */
IRouteAdditionalConfigurationOptions.prototype.timeout;
 /** @type {string} */
IRouteAdditionalConfigurationOptions.prototype.description;
 /** @type {(string|!Array<string>)} */
IRouteAdditionalConfigurationOptions.prototype.notes;
 /** @type {!Array<string>} */
IRouteAdditionalConfigurationOptions.prototype.tags;
/**
 * @record
 * @struct
 */
function IServerRealm() {}
 /** @type {?} */
IServerRealm.prototype.modifiers;
 /** @type {string} */
IServerRealm.prototype.plugin;
 /** @type {?} */
IServerRealm.prototype.plugins;
 /** @type {?} */
IServerRealm.prototype.settings;
/**
 * @record
 * @struct
 */
function IServerState() {}
 /** @type {string} */
IServerState.prototype.name;
 /** @type {?} */
IServerState.prototype.options;
/**
 * @record
 * @struct
 */
function IFileHandlerConfig() {}
 /** @type {string} */
IFileHandlerConfig.prototype.path;
 /** @type {string} */
IFileHandlerConfig.prototype.filename;
 /** @type {(string|boolean)} */
IFileHandlerConfig.prototype.mode;
 /** @type {boolean} */
IFileHandlerConfig.prototype.lookupCompressed;
/**
 * @record
 * @struct
 */
function IRouteHandlerConfig() {}
 /** @type {(string|?)} */
IRouteHandlerConfig.prototype.file;
 /** @type {?} */
IRouteHandlerConfig.prototype.directory;
 /** @type {?} */
IRouteHandlerConfig.prototype.proxy;
 /** @type {(string|?)} */
IRouteHandlerConfig.prototype.view;
 /** @type {?} */
IRouteHandlerConfig.prototype.config;
/**
 * @record
 * @struct
 */
function IRouteConfiguration() {}
 /** @type {string} */
IRouteConfiguration.prototype.path;
 /** @type {(string|!Array<string>)} */
IRouteConfiguration.prototype.method;
 /** @type {string} */
IRouteConfiguration.prototype.vhost;
 /** @type {(string|?)} */
IRouteConfiguration.prototype.handler;
 /** @type {?} */
IRouteConfiguration.prototype.config;
/**
 * @record
 * @struct
 */
function IRoute() {}
 /** @type {string} */
IRoute.prototype.method;
 /** @type {string} */
IRoute.prototype.path;
 /** @type {(string|!Array<string>)} */
IRoute.prototype.vhost;
 /** @type {?} */
IRoute.prototype.realm;
 /** @type {?} */
IRoute.prototype.settings;
/**
 * @record
 * @struct
 */
function IServerAuthScheme() {}
 /** @type {?} */
IServerAuthScheme.prototype.options;

/**
 * authenticate(request, reply) - required function called on each incoming request configured with the authentication scheme where:
 * request - the request object.
 * reply - the reply interface the authentication method must call when done authenticating the request where:
 * reply(err, response, result) - is called if authentication failed where:
 * err - any authentication error.
 * response - any authentication response action such as redirection. Ignored if err is present, otherwise required.
 * result - an object containing:
 * credentials - the authenticated credentials.
 * artifacts - optional authentication artifacts.
 * reply.continue(result) - is called if authentication succeeded where:
 * result - same object as result above.
 * When the scheme authenticate() method implementation calls reply() with an error condition, the specifics of the error affect whether additional authentication strategies will be attempted if configured for the route.
 * .If the err returned by the reply() method includes a message, no additional strategies will be attempted.
 * If the err does not include a message but does include a scheme name (e.g. Boom.unauthorized(null, 'Custom')), additional strategies will be attempted in order of preference.
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * var scheme = function (server, options) {
 * return {
 * authenticate: function (request, reply) {
 * var req = request.raw.req;
 * var authorization = req.headers.authorization;
 * if (!authorization) {
 * return reply(Boom.unauthorized(null, 'Custom'));
 * }
 * return reply(null, { credentials: { user: 'john' } });
 * }
 * };
 * };
 * server.auth.scheme('custom', scheme);
 * @template T
 * @param {!Request} request
 * @param {?} reply
 * @return {void}
 */
IServerAuthScheme.prototype.authenticate = function(request, reply) {};

/**
 * payload(request, reply) - optional function called to authenticate the request payload where:
 * request - the request object.
 * reply(err, response) - is called if authentication failed where:
 * err - any authentication error.
 * response - any authentication response action such as redirection. Ignored if err is present, otherwise required.
 * reply.continue() - is called if payload authentication succeeded.
 * When the scheme payload() method returns an error with a message, it means payload validation failed due to bad payload. If the error has no message but includes a scheme name (e.g. Boom.unauthorized(null, 'Custom')), authentication may still be successful if the route auth.payload configuration is set to 'optional'.
 * @template T
 * @param {!Request} request
 * @param {?} reply
 * @return {void}
 */
IServerAuthScheme.prototype.payload = function(request, reply) {};

/**
 * response(request, reply) - optional function called to decorate the response with authentication headers before the response headers or payload is written where:
 * request - the request object.
 * reply(err, response) - is called if an error occurred where:
 * err - any authentication error.
 * response - any authentication response to send instead of the current response. Ignored if err is present, otherwise required.
 * reply.continue() - is called if the operation succeeded.
 * @template T
 * @param {!Request} request
 * @param {?} reply
 * @return {void}
 */
IServerAuthScheme.prototype.response = function(request, reply) {};
/**
 * @record
 * @struct
 */
function IServerInject() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function IConnectionTable() {}
 /** @type {?} */
IConnectionTable.prototype.info;
 /** @type {?} */
IConnectionTable.prototype.labels;
 /** @type {!Array<?>} */
IConnectionTable.prototype.table;
/**
 * @record
 * @struct
 */
function ICookieSettings() {}
 /** @type {number} */
ICookieSettings.prototype.ttl;
 /** @type {boolean} */
ICookieSettings.prototype.isSecure;
 /** @type {boolean} */
ICookieSettings.prototype.isHttpOnly;
 /** @type {string} */
ICookieSettings.prototype.path;
 /** @type {?} */
ICookieSettings.prototype.domain;
 /** @type {?} */
ICookieSettings.prototype.autoValue;
 /** @type {string} */
ICookieSettings.prototype.encoding;
 /** @type {?} */
ICookieSettings.prototype.sign;
 /** @type {string} */
ICookieSettings.prototype.password;
 /** @type {?} */
ICookieSettings.prototype.iron;
 /** @type {boolean} */
ICookieSettings.prototype.ignoreErrors;
 /** @type {boolean} */
ICookieSettings.prototype.clearInvalid;
 /** @type {boolean} */
ICookieSettings.prototype.strictHeader;
 /** @type {?} */
ICookieSettings.prototype.passThrough;
/**
 * @record
 * @struct
 */
function IServerMethod() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function IServerMethodOptions() {}
 /** @type {?} */
IServerMethodOptions.prototype.bind;
 /** @type {?} */
IServerMethodOptions.prototype.cache;
 /** @type {boolean} */
IServerMethodOptions.prototype.callback;

/**
 * @param {!Array<?>} args
 * @return {string}
 */
IServerMethodOptions.prototype.generateKey = function(args) {};
/**
 * @extends {internal.EventEmitter}
 * @constructor
 * @struct
 */
function Request() {}
 /** @type {?} */
Request.prototype.app;
 /** @type {{isAuthenticated: boolean, credentials: ?, artifacts: ?, mode: ?, error: ?, session: ?}} */
Request.prototype.auth;
 /** @type {?} */
Request.prototype.domain;
 /** @type {?} */
Request.prototype.headers;
 /** @type {number} */
Request.prototype.id;
 /** @type {{received: number, responded: number, remoteAddress: string, remotePort: number, referrer: string, host: string, hostname: string}} */
Request.prototype.info;
 /** @type {string} */
Request.prototype.method;
 /** @type {string} */
Request.prototype.mime;
 /** @type {{params: ?, query: ?, payload: ?}} */
Request.prototype.orig;
 /** @type {?} */
Request.prototype.params;
 /** @type {!Array<string>} */
Request.prototype.paramsArray;
 /** @type {string} */
Request.prototype.path;
 /** @type {?} */
Request.prototype.payload;
 /** @type {?} */
Request.prototype.plugins;
 /** @type {?} */
Request.prototype.pre;
 /** @type {!Response} */
Request.prototype.response;
 /** @type {?} */
Request.prototype.preResponses;
 /** @type {?} */
Request.prototype.query;
 /** @type {{req: !ClientRequest, res: !ServerResponse}} */
Request.prototype.raw;
 /** @type {?} */
Request.prototype.route;
 /** @type {!Server} */
Request.prototype.server;
 /** @type {?} */
Request.prototype.session;
 /** @type {?} */
Request.prototype.state;
 /** @type {{auth: ?, hash: ?, host: ?, hostname: ?, href: string, path: string, pathname: string, port: ?, protocol: ?, query: ?, search: string, slashes: ?}} */
Request.prototype.url;

/**
 * request.setUrl(url)
 * Available only in 'onRequest' extension methods.
 * Changes the request URI before the router begins processing the request where:
 * url - the new request path value.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * server.ext('onRequest', function (request, reply) {
 * // Change all requests to '/test'
 * request.setUrl('/test');
 * return reply.continue();
 * });
 * @param {string} url
 * @return {void}
 */
Request.prototype.setUrl = function(url) {};

/**
 * request.setMethod(method)
 * Available only in 'onRequest' extension methods.
 * Changes the request method before the router begins processing the request where:
 * method - is the request HTTP method (e.g. 'GET').
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * server.ext('onRequest', function (request, reply) {
 * // Change all requests to 'GET'
 * request.setMethod('GET');
 * return reply.continue();
 * });
 * @param {string} method
 * @return {void}
 */
Request.prototype.setMethod = function(method) {};

/**
 * request.log(tags, [data, [timestamp]])
 * Always available.
 * Logs request-specific events. When called, the server emits a 'request' event which can be used by other listeners or plugins. The arguments are:
 * data - an optional message string or object with the application data being logged.
 * timestamp - an optional timestamp expressed in milliseconds. Defaults to Date.now() (now).
 * Any logs generated by the server internally will be emitted only on the 'request-internal' channel and will include the event.internal flag set to true.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * server.on('request', function (request, event, tags) {
 * if (tags.error) {
 * console.log(event);
 * }
 * });
 * var handler = function (request, reply) {
 * request.log(['test', 'error'], 'Test event');
 * return reply();
 * };
 * @param {(string|!Array<string>)} tags
 * @param {?=} data
 * @param {number=} timestamp
 * @return {void}
 */
Request.prototype.log = function(tags, data, timestamp) {};

/**
 * request.getLog([tags], [internal])
 * Always available.
 * Returns an array containing the events matching any of the tags specified (logical OR)
 * request.getLog();
 * request.getLog('error');
 * request.getLog(['error', 'auth']);
 * request.getLog(['error'], true);
 * request.getLog(false);
 * @param {string=} tags
 * @param {boolean=} internal
 * @return {!Array<string>}
 */
Request.prototype.getLog = function(tags, internal) {};

/**
 * request.tail([name])
 * Available until immediately after the 'response' event is emitted.
 * Adds a request tail which has to complete before the request lifecycle is complete where:
 * name - an optional tail name used for logging purposes.
 * Returns a tail function which must be called when the tail activity is completed.
 * Tails are actions performed throughout the request lifecycle, but which may end after a response is sent back to the client. For example, a request may trigger a database update which should not delay sending back a response. However, it is still desirable to associate the activity with the request when logging it (or an error associated with it).
 * When all tails completed, the server emits a 'tail' event.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * var get = function (request, reply) {
 * var dbTail = request.tail('write to database');
 * db.save('key', 'value', function () {
 * dbTail();
 * });
 * return reply('Success!');
 * };
 * server.route({ method: 'GET', path: '/', handler: get });
 * server.on('tail', function (request) {
 * console.log('Request completed including db activity');
 * });
 * @param {string=} name
 * @return {!Function}
 */
Request.prototype.tail = function(name) {};
/**
 * @extends {internal.EventEmitter}
 * @constructor
 * @struct
 */
function Response() {}
 /** @type {number} */
Response.prototype.statusCode;
 /** @type {?} */
Response.prototype.headers;
 /** @type {?} */
Response.prototype.source;
 /** @type {string} */
Response.prototype.variety;
 /** @type {?} */
Response.prototype.app;
 /** @type {?} */
Response.prototype.plugins;
 /** @type {{charset: string, encoding: string, passThrough: boolean, stringify: ?, ttl: number, varyEtag: boolean}} */
Response.prototype.settings;

/**
 * sets the HTTP 'Content-Length' header (to avoid chunked transfer encoding) where:
 * length - the header value. Must match the actual payload size.
 * @param {number} length
 * @return {void}
 */
Response.prototype.bytes = function(length) {};

/**
 * sets the 'Content-Type' HTTP header 'charset' property where: charset - the charset property value.
 * @param {string} charset
 * @return {void}
 */
Response.prototype.charset = function(charset) {};

/**
 * sets the HTTP status code where:
 * statusCode - the HTTP status code.
 * @param {number} statusCode
 * @return {void}
 */
Response.prototype.code = function(statusCode) {};

/**
 * sets the HTTP status code to Created (201) and the HTTP 'Location' header where: uri - an absolute or relative URI used as the 'Location' header value.
 * @param {string} uri
 * @return {void}
 */
Response.prototype.created = function(uri) {};

/**
 * encoding(encoding) - sets the string encoding scheme used to serial data into the HTTP payload where: encoding - the encoding property value (see node Buffer encoding).
 * @param {string} encoding
 * @return {void}
 */
Response.prototype.encoding = function(encoding) {};

/**
 * etag(tag, options) - sets the representation entity tag where:
 * tag - the entity tag string without the double-quote.
 * options - optional settings where:
 * weak - if true, the tag will be prefixed with the 'W/' weak signifier. Weak tags will fail to match identical tags for the purpose of determining 304 response status. Defaults to false.
 * vary - if true and content encoding is set or applied to the response (e.g 'gzip' or 'deflate'), the encoding name will be automatically added to the tag at transmission time (separated by a '-' character). Ignored when weak is true. Defaults to true.
 * @param {string} tag
 * @param {{weak: boolean, vary: boolean}} options
 * @return {void}
 */
Response.prototype.etag = function(tag, options) {};

/**
 * header(name, value, options) - sets an HTTP header where:
 * name - the header name.
 * value - the header value.
 * options - optional settings where:
 * append - if true, the value is appended to any existing header value using separator. Defaults to false.
 * separator - string used as separator when appending to an exiting value. Defaults to ','.
 * override - if false, the header value is not set if an existing value present. Defaults to true.
 * @param {string} name
 * @param {string} value
 * @param {{append: boolean, separator: string, override: boolean}=} options
 * @return {void}
 */
Response.prototype.header = function(name, value, options) {};

/**
 * location(uri) - sets the HTTP 'Location' header where:
 * uri - an absolute or relative URI used as the 'Location' header value.
 * @param {string} uri
 * @return {void}
 */
Response.prototype.location = function(uri) {};

/**
 * redirect(uri) - sets an HTTP redirection response (302) and decorates the response with additional methods listed below, where:
 * uri - an absolute or relative URI used to redirect the client to another resource.
 * @param {string} uri
 * @return {void}
 */
Response.prototype.redirect = function(uri) {};

/**
 * replacer(method) - sets the JSON.stringify() replacer argument where:
 * method - the replacer function or array. Defaults to none.
 * @param {(!Function|!Array<!Function>)} method
 * @return {void}
 */
Response.prototype.replacer = function(method) {};

/**
 * spaces(count) - sets the JSON.stringify() space argument where:
 * count - the number of spaces to indent nested object keys. Defaults to no indentation.
 * @param {number} count
 * @return {void}
 */
Response.prototype.spaces = function(count) {};

/**
 * state(name, value, [options]) - sets an HTTP cookie where:
 * name - the cookie name.
 * value - the cookie value. If no encoding is defined, must be a string.
 * options - optional configuration. If the state was previously registered with the server using server.state(), the specified keys in options override those same keys in the server definition (but not others).
 * @param {string} name
 * @param {string} value
 * @param {?=} options
 * @return {void}
 */
Response.prototype.state = function(name, value, options) {};

/**
 * @constructor
 * @struct
 * @param {?=} options
 */
function Server(options) {}
 /** @type {?} */
Server.prototype.app;
 /** @type {!Array<?>} */
Server.prototype.connections;
 /** @type {{id: string, created: number, started: number, port: number, host: string, address: string, protocol: string, uri: string}} */
Server.prototype.info;
 /** @type {{eventLoopDelay: number, heapUsed: number}} */
Server.prototype.load;
 /** @type {!Server} */
Server.prototype.listener;
 /** @type {?} */
Server.prototype.methods;
 /** @type {?} */
Server.prototype.mime;
 /** @type {?} */
Server.prototype.plugins;
 /** @type {?} */
Server.prototype.realm;
 /** @type {!Server} */
Server.prototype.root;
 /** @type {?} */
Server.prototype.settings;
 /** @type {string} */
Server.prototype.version;
 /** @type {{default: ?, scheme: function(string, function(!Server, ?): ?): void, strategy: function(string, ?, boolean, ?): void, test: function(string, !Request, function(?, ?): void): void}} */
Server.prototype.auth;
 /** @type {?} */
Server.prototype.inject;

/**
 * server.after(method, [dependencies])
 * Adds a method to be called after all the plugin dependencies have been registered and before the server starts (only called if the server is started) where:
 * after - the method with signature function(plugin, next) where:
 * server - server object the after() method was called on.
 * next - the callback function the method must call to return control over to the application and complete the registration process. The function signature is function(err) where:
 * err - internal error which is returned back via the server.start() callback.
 * dependencies - a string or array of string with the plugin names to call this method after their after() methods. There is no requirement for the other plugins to be registered. Setting dependencies only arranges the after methods in the specified order.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * server.after(function () {
 * // Perform some pre-start logic
 * });
 * server.start(function (err) {
 * // After method already executed
 * });
 * server.auth.default(options)
 * @param {function(?, function(?): void): void} method
 * @param {(string|!Array<string>)} dependencies
 * @return {void}
 */
Server.prototype.after = function(method, dependencies) {};

/**
 * server.bind(context)
 * Sets a global context used as the default bind object when adding a route or an extension where:
 * context - the object used to bind this in handler and extension methods.
 * When setting context inside a plugin, the context is applied only to methods set up by the plugin. Note that the context applies only to routes and extensions added after it has been set.
 * var handler = function (request, reply) {
 * return reply(this.message);
 * };
 * exports.register = function (server, options, next) {
 * var bind = {
 * message: 'hello'
 * };
 * server.bind(bind);
 * server.route({ method: 'GET', path: '/', handler: handler });
 * return next();
 * };
 * @param {?} context
 * @return {void}
 */
Server.prototype.bind = function(context) {};

/**
 * server.cache(options)
 * Provisions a cache segment within the server cache facility where:
 * options - catbox policy configuration where:
 * expiresIn - relative expiration expressed in the number of milliseconds since the item was saved in the cache. Cannot be used together with expiresAt.
 * expiresAt - time of day expressed in 24h notation using the 'HH:MM' format, at which point all cache records expire. Uses local time. Cannot be used together with expiresIn.
 * generateFunc - a function used to generate a new cache item if one is not found in the cache when calling get(). The method's signature is function(id, next) where: - id - the id string or object provided to the get() method. - next - the method called when the new item is returned with the signature function(err, value, ttl) where: - err - an error condition. - value - the new value generated. - ttl - the cache ttl value in milliseconds. Set to 0 to skip storing in the cache. Defaults to the cache global policy.
 * staleIn - number of milliseconds to mark an item stored in cache as stale and attempt to regenerate it when generateFunc is provided. Must be less than expiresIn.
 * staleTimeout - number of milliseconds to wait before checking if an item is stale.
 * generateTimeout - number of milliseconds to wait before returning a timeout error when the generateFunc function takes too long to return a value. When the value is eventually returned, it is stored in the cache for future requests.
 * cache - the cache name configured in 'server.cache`. Defaults to the default cache.
 * segment - string segment name, used to isolate cached items within the cache partition. When called within a plugin, defaults to '!name' where 'name' is the plugin name. Required when called outside of a plugin.
 * shared - if true, allows multiple cache provisions to share the same segment. Default to false.
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * var cache = server.cache({ segment: 'countries', expiresIn: 60 * 60 * 1000 });
 * cache.set('norway', { capital: 'oslo' }, null, function (err) {
 * cache.get('norway', function (err, value, cached, log) {
 * // value === { capital: 'oslo' };
 * });
 * });
 * @param {?} options
 * @return {void}
 */
Server.prototype.cache = function(options) {};

/**
 * server.connection([options])
 * Adds an incoming server connection
 * Returns a server object with the new connection selected.
 * Must be called before any other server method that modifies connections is called for it to apply to the new connection (e.g. server.state()).
 * Note that the options object is deeply cloned (with the exception of listener which is shallowly copied) and cannot contain any values that are unsafe to perform deep copy on.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * var web = server.connection({ port: 8000, host: 'example.com', labels: ['web'] });
 * var admin = server.connection({ port: 8001, host: 'example.com', labels: ['admin'] });
 * // server.connections.length === 2
 * // web.connections.length === 1
 * // admin.connections.length === 1
 * @param {?} options
 * @return {!Server}
 */
Server.prototype.connection = function(options) {};

/**
 * server.decorate(type, property, method)
 * Extends various framework interfaces with custom methods where:
 * type - the interface being decorated. Supported types:
 * 'reply' - adds methods to the reply interface.
 * 'server' - adds methods to the Server object.
 * property - the object decoration key name.
 * method - the extension function.
 * Note that decorations apply to the entire server and all its connections regardless of current selection.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * server.decorate('reply', 'success', function () {
 * return this.response({ status: 'ok' });
 * });
 * server.route({
 * method: 'GET',
 * path: '/',
 * handler: function (request, reply) {
 * return reply.success();
 * }
 * });
 * @param {string} type
 * @param {string} property
 * @param {!Function} method
 * @return {void}
 */
Server.prototype.decorate = function(type, property, method) {};

/**
 * server.dependency(dependencies, [after])
 * Used within a plugin to declares a required dependency on other plugins where:
 * dependencies - a single string or array of plugin name strings which must be registered in order for this plugin to operate. Plugins listed must be registered before the server is started. Does not provide version dependency which should be implemented using npm peer dependencies.
 * after - an optional function called after all the specified dependencies have been registered and before the server starts. The function is only called if the server is started. If a circular dependency is detected, an exception is thrown (e.g. two plugins each has an after function to be called after the other). The function signature is function(server, next) where:
 * server - the server the dependency() method was called on.
 * next - the callback function the method must call to return control over to the application and complete the registration process. The function signature is function(err) where:
 * err - internal error condition, which is returned back via the server.start() callback.
 * exports.register = function (server, options, next) {
 * server.dependency('yar', after);
 * return next();
 * };
 * var after = function (server, next) {
 * // Additional plugin registration logic
 * return next();
 * };
 * @param {(string|!Array<string>)} dependencies
 * @param {function(!Server, function(?): void): void=} after
 * @return {void}
 */
Server.prototype.dependency = function(dependencies, after) {};

/**
 * server.expose(key, value)
 * Used within a plugin to expose a property via server.plugins[name] where:
 * key - the key assigned (server.plugins[name][key]).
 * value - the value assigned.
 * exports.register = function (server, options, next) {
 * server.expose('util', function () { console.log('something'); });
 * return next();
 * };
 * server.expose(obj)
 * Merges a deep copy of an object into to the existing content of server.plugins[name] where:
 * obj - the object merged into the exposed properties container.
 * exports.register = function (server, options, next) {
 * server.expose({ util: function () { console.log('something'); } });
 * return next();
 * };
 * @param {string|?} key_or_obj
 * @param {?=} value
 * @return {void}
 */
Server.prototype.expose = function(key_or_obj, value) {};

/**
 * server.ext(event, method, [options])
 * Registers an extension function in one of the available extension points where:
 * event - the event name.
 * method - a function or an array of functions to be executed at a specified point during request processing. The required extension function signature is function(request, reply) where:
 * request - the request object.
 * reply - the reply interface which is used to return control back to the framework. To continue normal execution of the request lifecycle, reply.continue() must be called. To abort processing and return a response to the client, call reply(value) where value is an error or any other valid response.
 * this - the object provided via options.bind or the current active context set with server.bind().
 * options - an optional object with the following:
 * before - a string or array of strings of plugin names this method must execute before (on the same event). Otherwise, extension methods are executed in the order added.
 * after - a string or array of strings of plugin names this method must execute after (on the same event). Otherwise, extension methods are executed in the order added.
 * bind - a context object passed back to the provided method (via this) when called.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * server.ext('onRequest', function (request, reply) {
 * // Change all requests to '/test'
 * request.setUrl('/test');
 * return reply.continue();
 * });
 * var handler = function (request, reply) {
 * return reply({ status: 'ok' });
 * };
 * server.route({ method: 'GET', path: '/test', handler: handler });
 * server.start();
 * // All requests will get routed to '/test'
 * @template T
 * @param {string} event
 * @param {function(!Request, ?, ?): void} method
 * @param {{before: (string|!Array<string>), after: (string|!Array<string>), bind: ?}=} options
 * @return {void}
 */
Server.prototype.ext = function(event, method, options) {};

/**
 * server.handler(name, method)
 * Registers a new handler type to be used in routes where:
 * name - string name for the handler being registered. Cannot override the built-in handler types (directory, file, proxy, and view) or any previously registered type.
 * method - the function used to generate the route handler using the signature function(route, options) where:
 * route - the route public interface object.
 * options - the configuration object provided in the handler config.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ host: 'localhost', port: 8000 });
 * // Defines new handler for routes on this server
 * server.handler('test', function (route, options) {
 * return function (request, reply) {
 * return reply('new handler: ' + options.msg);
 * }
 * });
 * server.route({
 * method: 'GET',
 * path: '/',
 * handler: { test: { msg: 'test' } }
 * });
 * server.start();
 * The method function can have a defaults object or function property. If the property is set to an object, that object is used as the default route config for routes using this handler. If the property is set to a function, the function uses the signature function(method) and returns the route default configuration.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ host: 'localhost', port: 8000 });
 * var handler = function (route, options) {
 * return function (request, reply) {
 * return reply('new handler: ' + options.msg);
 * }
 * };
 * // Change the default payload processing for this handler
 * handler.defaults = {
 * payload: {
 * output: 'stream',
 * parse: false
 * }
 * };
 * server.handler('test', handler);
 * @template THandlerConfig
 * @param {string} name
 * @param {function(?, THandlerConfig): ?} method
 * @return {void}
 */
Server.prototype.handler = function(name, method) {};

/**
 * server.log(tags, [data, [timestamp]])
 * Logs server events that cannot be associated with a specific request. When called the server emits a 'log' event which can be used by other listeners or plugins to record the information or output to the console. The arguments are:
 * tags - a string or an array of strings (e.g. ['error', 'database', 'read']) used to identify the event. Tags are used instead of log levels and provide a much more expressive mechanism for describing and filtering events. Any logs generated by the server internally include the 'hapi' tag along with event-specific information.
 * data - an optional message string or object with the application data being logged.
 * timestamp - an optional timestamp expressed in milliseconds. Defaults to Date.now() (now).
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * server.on('log', function (event, tags) {
 * if (tags.error) {
 * console.log(event);
 * }
 * });
 * server.log(['test', 'error'], 'Test event');
 * @param {(string|!Array<string>)} tags
 * @param {?=} data
 * @param {number=} timestamp
 * @return {void}
 */
Server.prototype.log = function(tags, data, timestamp) {};

/**
 * server.lookup(id)
 * When the server contains exactly one connection, looks up a route configuration where:
 * id - the route identifier as set in the route options.
 * returns the route public interface object if found, otherwise null.
 * var server = new Hapi.Server();
 * server.connection();
 * server.route({
 * method: 'GET',
 * path: '/',
 * config: {
 * handler: function (request, reply) { return reply(); },
 * id: 'root'
 * }
 * });
 * var route = server.lookup('root');
 * When the server contains more than one connection, each server.connections array member provides its own connection.lookup() method.
 * @param {string} id
 * @return {?}
 */
Server.prototype.lookup = function(id) {};

/**
 * server.match(method, path, [host])
 * When the server contains exactly one connection, looks up a route configuration where:
 * method - the HTTP method (e.g. 'GET', 'POST').
 * path - the requested path (must begin with '/').
 * host - optional hostname (to match against routes with vhost).
 * returns the route public interface object if found, otherwise null.
 * var server = new Hapi.Server();
 * server.connection();
 * server.route({
 * method: 'GET',
 * path: '/',
 * config: {
 * handler: function (request, reply) { return reply(); },
 * id: 'root'
 * }
 * });
 * var route = server.match('get', '/');
 * When the server contains more than one connection, each server.connections array member provides its own connection.match() method.
 * @param {string} method
 * @param {string} path
 * @param {string=} host
 * @return {?}
 */
Server.prototype.match = function(method, path, host) {};

/**
 * server.method(name, method, [options])
 * Registers a server method. Server methods are functions registered with the server and used throughout the application as a common utility. Their advantage is in the ability to configure them to use the built-in cache and share across multiple request handlers without having to create a common module.
 * Methods are registered via server.method(name, method, [options])
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * // Simple arguments
 * var add = function (a, b, next) {
 * return next(null, a + b);
 * };
 * server.method('sum', add, { cache: { expiresIn: 2000 } });
 * server.methods.sum(4, 5, function (err, result) {
 * console.log(result);
 * });
 * // Object argument
 * var addArray = function (array, next) {
 * var sum = 0;
 * array.forEach(function (item) {
 * sum += item;
 * });
 * return next(null, sum);
 * };
 * server.method('sumObj', addArray, {
 * cache: { expiresIn: 2000 },
 * generateKey: function (array) {
 * return array.join(',');
 * }
 * });
 * server.methods.sumObj([5, 6], function (err, result) {
 * console.log(result);
 * });
 * // Synchronous method with cache
 * var addSync = function (a, b) {
 * return a + b;
 * };
 * server.method('sumSync', addSync, { cache: { expiresIn: 2000 }, callback: false });
 * server.methods.sumSync(4, 5, function (err, result) {
 * console.log(result);
 * });
 * server.method(methods)
 * Registers a server method function as described in server.method() using a configuration object where:
 * methods - an object or an array of objects where each one contains:
 * name - the method name.
 * method - the method function.
 * options - optional settings.
 * var add = function (a, b, next) {
 * next(null, a + b);
 * };
 * server.method({
 * name: 'sum',
 * method: add,
 * options: {
 * cache: {
 * expiresIn: 2000
 * }
 * }
 * });
 * @param {string|({name: string, method: ?, options: ?}|!Array<{name: string, method: ?, options: ?}>)} name_or_methods
 * @param {?=} method
 * @param {?=} options
 * @return {void}
 */
Server.prototype.method = function(name_or_methods, method, options) {};

/**
 * server.path(relativeTo)
 * Sets the path prefix used to locate static resources (files and view templates) when relative paths are used where:
 * relativeTo - the path prefix added to any relative file path starting with '.'.
 * Note that setting a path within a plugin only applies to resources accessed by plugin methods. If no path is set, the connection files.relativeTo configuration is used. The path only applies to routes added after it has been set.
 * exports.register = function (server, options, next) {
 * server.path(__dirname + '../static');
 * server.route({ path: '/file', method: 'GET', handler: { file: './test.html' } });
 * next();
 * };
 * @param {string} relativeTo
 * @return {void}
 */
Server.prototype.path = function(relativeTo) {};

/**
 * server.register(plugins, [options], callback)
 * Registers a plugin where:
 * plugins - an object or array of objects where each one is either:
 * a plugin registration function.
 * an object with the following:
 * register - the plugin registration function.
 * options - optional options passed to the registration function when called.
 * options - optional registration options (different from the options passed to the registration function):
 * select - a string or array of string labels used to pre-select connections for plugin registration.
 * routes - modifiers applied to each route added by the plugin:
 * prefix - string added as prefix to any route path (must begin with '/'). If a plugin registers a child plugin the prefix is passed on to the child or is added in front of the child-specific prefix.
 * vhost - virtual host string (or array of strings) applied to every route. The outer-most vhost overrides the any nested configuration.
 * callback - the callback function with signature function(err) where:
 * err - an error returned from the registration function. Note that exceptions thrown by the registration function are not handled by the framework.
 * server.register({
 * register: require('plugin_name'),
 * options: {
 * message: 'hello'
 * }
 * }, function (err) {
 * if (err) {
 * console.log('Failed loading plugin');
 * }
 * });
 * @param {?} plugins
 * @param {{select: (string|!Array<string>), routes: {prefix: string, vhost: (string|!Array<string>)}}|function(?): void} options_or_callback
 * @param {function(?): void=} callback
 * @return {void}
 */
Server.prototype.register = function(plugins, options_or_callback, callback) {};

/**
 * server.render(template, context, [options], callback)
 * Utilizes the server views manager to render a template where:
 * template - the template filename and path, relative to the views manager templates path (path or relativeTo).
 * context - optional object used by the template to render context-specific result. Defaults to no context ({}).
 * options - optional object used to override the views manager configuration.
 * callback - the callback function with signature function (err, rendered, config) where:
 * err - the rendering error if any.
 * rendered - the result view string.
 * config - the configuration used to render the template.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * server.views({
 * engines: { html: require('handlebars') },
 * path: __dirname + '/templates'
 * });
 * var context = {
 * title: 'Views Example',
 * message: 'Hello, World'
 * };
 * server.render('hello', context, function (err, rendered, config) {
 * console.log(rendered);
 * });
 * @param {string} template
 * @param {?} context
 * @param {?} options
 * @param {function(?, ?, ?): void} callback
 * @return {void}
 */
Server.prototype.render = function(template, context, options, callback) {};

/**
 * server.route(options)
 * Adds a connection route where:
 * options - a route configuration object or an array of configuration objects.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * server.route({ method: 'GET', path: '/', handler: function (request, reply) { return reply('ok'); } });
 * server.route([
 * { method: 'GET', path: '/1', handler: function (request, reply) { return reply('ok'); } },
 * { method: 'GET', path: '/2', handler: function (request, reply) { return reply('ok'); } }
 * ]);
 * @param {?|!Array<?>} options
 * @return {void}
 */
Server.prototype.route = function(options) {};

/**
 * server.select(labels)
 * Selects a subset of the server's connections where:
 * labels - a single string or array of strings of labels used as a logical OR statement to select all the connections with matching labels in their configuration.
 * Returns a server object with connections set to the requested subset. Selecting again on a selection operates as a logic AND statement between the individual selections.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80, labels: ['a'] });
 * server.connection({ port: 8080, labels: ['b'] });
 * server.connection({ port: 8081, labels: ['c'] });
 * server.connection({ port: 8082, labels: ['c','d'] });
 * var a = server.select('a');          // The server with port 80
 * var ab = server.select(['a','b']);   // A list of servers containing the server with port 80 and the server with port 8080
 * var c = server.select('c');          // A list of servers containing the server with port 8081 and the server with port 8082
 * @param {(string|!Array<string>)} labels
 * @return {(!Server|!Array<!Server>)}
 */
Server.prototype.select = function(labels) {};

/**
 * server.start([callback])
 * Starts the server connections by listening for incoming requests on the configured port of each listener (unless the connection was configured with autoListen set to false), where:
 * callback - optional callback when server startup is completed or failed with the signature function(err) where:
 * err - any startup error condition.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * server.start(function (err) {
 * console.log('Server started at: ' + server.info.uri);
 * });
 * @param {function(?): void=} callback
 * @return {void}
 */
Server.prototype.start = function(callback) {};

/**
 * server.state(name, [options])
 * HTTP state management uses client cookies to persist a state across multiple requests. Registers a cookie definitions
 * State defaults can be modified via the server connections.routes.state configuration option.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * // Set cookie definition
 * server.state('session', {
 * ttl: 24 * 60 * 60 * 1000,     // One day
 * isSecure: true,
 * path: '/',
 * encoding: 'base64json'
 * });
 * // Set state in route handler
 * var handler = function (request, reply) {
 * var session = request.state.session;
 * if (!session) {
 * session = { user: 'joe' };
 * }
 * session.last = Date.now();
 * return reply('Success').state('session', session);
 * };
 * Registered cookies are automatically parsed when received. Parsing rules depends on the route state.parse configuration. If an incoming registered cookie fails parsing, it is not included in request.state, regardless of the state.failAction setting. When state.failAction is set to 'log' and an invalid cookie value is received, the server will emit a 'request-internal' event. To capture these errors subscribe to the 'request-internal' events and filter on 'error' and 'state' tags:
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * server.on('request-internal', function (request, event, tags) {
 * if (tags.error && tags.state) {
 * console.error(event);
 * }
 * });
 * @param {string} name
 * @param {?=} options
 * @return {void}
 */
Server.prototype.state = function(name, options) {};

/**
 * server.stop([options], [callback])
 * Stops the server's connections by refusing to accept any new connections or requests (existing connections will continue until closed or timeout), where:
 * options - optional object with:
 * timeout - overrides the timeout in millisecond before forcefully terminating a connection. Defaults to 5000 (5 seconds).
 * callback - optional callback method with signature function() which is called once all the connections have ended and it is safe to exit the process.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80 });
 * server.stop({ timeout: 60 * 1000 }, function () {
 * console.log('Server stopped');
 * });
 * @param {{timeout: number}=} options
 * @param {function(): void=} callback
 * @return {void}
 */
Server.prototype.stop = function(options, callback) {};

/**
 * server.table([host])
 * Returns a copy of the routing table where:
 * host - optional host to filter routes matching a specific virtual host. Defaults to all virtual hosts.
 * The return value is an array where each item is an object containing:
 * info - the connection.info the connection the table was generated for.
 * labels - the connection labels.
 * table - an array of routes where each route contains:
 * settings - the route config with defaults applied.
 * method - the HTTP method in lower case.
 * path - the route path.
 * Note that if the server has not been started and multiple connections use port 0, the table items will override each other and will produce an incomplete result.
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80, host: 'example.com' });
 * server.route({ method: 'GET', path: '/example', handler: function (request, reply) { return reply(); } });
 * var table = server.table();
 * When calling connection.table() directly on each connection, the return value is the same as the array table item value of an individual connection:
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.connection({ port: 80, host: 'example.com' });
 * server.route({ method: 'GET', path: '/example', handler: function (request, reply) { return reply(); } });
 * var table = server.connections[0].table();
 * //[
 * //    {
 * //        method: 'get',
 * //        path: '/example',
 * //        settings: { ... }
 * //    }
 * //]
 * @param {?=} host
 * @return {?}
 */
Server.prototype.table = function(host) {};

/**
 * server.views(options)
 * Initializes the server views manager
 * var Hapi = require('hapi');
 * var server = new Hapi.Server();
 * server.views({
 * engines: {
 * html: require('handlebars'),
 * jade: require('jade')
 * },
 * path: '/static/templates'
 * });
 * When server.views() is called within a plugin, the views manager is only available to plugins methods.
 * @param {?} options
 * @return {void}
 */
Server.prototype.views = function(options) {};
