/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/sharp/index.d.ts:

/* TODO: ImportDeclaration in  */

/**
 * Creates a sharp instance from an image
 * @throws {Error} Invalid parameters
 * @param {(string|?)=} input
 * @param {!sharp.SharpOptions=} options
 * @return {!sharp.SharpInstance}
 */
function sharp(input, options) {}
 /** @type {!sharp.GravityEnum} */
sharp.gravity;
 /** @type {!sharp.StrategyEnum} */
sharp.strategy;

/**
 * Gets, or when options are provided sets, the limits of libvips' operation cache.
 * Existing entries in the cache will be trimmed after any change in limits.
 * This method always returns cache statistics, useful for determining how much working memory is required for a particular task.
 * @param {(boolean|!sharp.CacheOptions)=} options
 * @return {!sharp.CacheResult}
 */
sharp.cache = function(options) {};

/**
 * Gets, or when a concurrency is provided sets, the number of threads libvips' should create to process each image.
 * @param {number=} threads
 * @return {number}
 */
sharp.concurrency = function(threads) {};

/**
 * Provides access to internal task counters.
 * @return {!sharp.SharpCounters}
 */
sharp.counters = function() {};

/**
 * Get and set use of SIMD vector unit instructions.
 * @param {boolean=} enable
 * @return {boolean}
 */
sharp.simd = function(enable) {};
 /** @type {!sharp.KernelEnum} */
sharp.kernel;
 /** @type {!sharp.InterpolatorEnum} */
sharp.interpolator;
 /** @type {!sharp.FormatEnum} */
sharp.format;
 /** @type {!NodeJS.EventEmitter} */
sharp.queue;
 /** @type {{vips: string, cairo: string, croco: string, exif: string, expat: string, ffi: string, fontconfig: string, freetype: string, gdkpixbuf: string, gif: string, glib: string, gsf: string, harfbuzz: string, jpeg: string, lcms: string, orc: string, pango: string, pixman: string, png: string, svg: string, tiff: string, webp: string, xml: string, zlib: string}} */
sharp.versions;
 /** @type {!sharp.BoolEnum} */
sharp.bool;
/**
 * @record
 * @struct
 */
sharp.SharpInstance = function() {};

/**
 * Fast access to image metadata without decoding any compressed image data.
 * Fast access to image metadata without decoding any compressed image data.
 * @param {function(!Error, !sharp.Metadata): void=} callback
 * @return {!sharp.SharpInstance|!Promise<!sharp.Metadata>}
 */
sharp.SharpInstance.prototype.metadata = function(callback) {};

/**
 * Take a "snapshot" of the Sharp instance, returning a new instance.
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.clone = function() {};

/**
 * An advanced setting that switches the libvips access method to VIPS_ACCESS_SEQUENTIAL.
 * @param {boolean=} sequentialRead
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.sequentialRead = function(sequentialRead) {};

/**
 * Do not process input images where the number of pixels (width _ height) exceeds this limit.
 * @throws {Error} Invalid limit
 * @param {(number|boolean)} pixels
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.limitInputPixels = function(pixels) {};

/**
 * Resize image to width x height. By default, the resized image is centre cropped to the exact size specified.
 * @throws {Error} Invalid parameters
 * @param {number=} width
 * @param {number=} height
 * @param {!sharp.ResizeOptions=} options
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.resize = function(width, height, options) {};

/**
 * Crop the resized image to the exact size specified, the default behaviour.
 * @throws {Error} Invalid parameters
 * @param {(string|number)=} crop
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.crop = function(crop) {};

/**
 * Preserving aspect ratio, resize the image to the maximum width or height specified then embed on a background of the exact width and height specified.
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.embed = function() {};

/**
 * Preserving aspect ratio, resize the image to be as large as possible while ensuring its dimensions are less than or equal to the width and height specified.
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.max = function() {};

/**
 * Preserving aspect ratio, resize the image to be as small as possible while ensuring its dimensions are greater than or equal to the width and height specified.
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.min = function() {};

/**
 * Do not enlarge the output image if the input image width or height are already less than the required dimensions.
 * @param {boolean=} withoutEnlargement
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.withoutEnlargement = function(withoutEnlargement) {};

/**
 * Ignoring the aspect ratio of the input, stretch the image to the exact width and/or height provided via resize.
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.ignoreAspectRatio = function() {};

/**
 * Extract a region of the image.
 * @throws {Error} Invalid parameters
 * @param {!sharp.Region} region
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.extract = function(region) {};

/**
 * Trim "boring" pixels from all edges that contain values within a percentage similarity of the top-left pixel.
 * @throws {Error} Invalid parameters
 * @param {number=} tolerance
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.trim = function(tolerance) {};

/**
 * Set the background for the embed, flatten and extend operations. The default background is {r: 0, g: 0, b: 0, alpha: 1}, black without transparency.
 * @throws {Error} Invalid parameter
 * @param {(string|!sharp.RGBA)=} rgba
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.background = function(rgba) {};

/**
 * Merge alpha transparency channel, if any, with background.
 * @param {boolean=} flatten
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.flatten = function(flatten) {};

/**
 * Extends/pads the edges of the image with the colour provided to the background method.
 * @throws {Error} Invalid parameters
 * @param {(number|!sharp.ExtendOptions)} extend
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.extend = function(extend) {};

/**
 * Produce the "negative" of the image.
 * @param {boolean=} negate
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.negate = function(negate) {};

/**
 * Rotate the output image by either an explicit angle or auto-orient based on the EXIF Orientation tag.
 * @throws {Error} Invalid parameters
 * @param {number=} angle
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.rotate = function(angle) {};

/**
 * Flip the image about the vertical Y axis.
 * @param {boolean=} flip
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.flip = function(flip) {};

/**
 * Flop the image about the horizontal X axis.
 * @param {boolean=} flop
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.flop = function(flop) {};

/**
 * Blur the image.
 * @throws {Error} Invalid parameters
 * @param {number=} sigma
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.blur = function(sigma) {};

/**
 * Convolve the image with the specified kernel.
 * @throws {Error} Invalid parameters
 * @param {!sharp.Kernel} kernel
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.convolve = function(kernel) {};

/**
 * Sharpen the image.
 * @throws {Error} Invalid parameters
 * @param {number=} sigma
 * @param {number=} flat
 * @param {number=} jagged
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.sharpen = function(sigma, flat, jagged) {};

/**
 * Any pixel value greather than or equal to the threshold value will be set to 255, otherwise it will be set to 0.
 * @throws {Error} Invalid parameters
 * @param {number=} threshold
 * @param {!sharp.ThresholdOptions=} options
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.threshold = function(threshold, options) {};

/**
 * Apply a gamma correction by reducing the encoding (darken) pre-resize at a factor of 1/gamma then increasing the encoding (brighten) post-resize at a factor of gamma.
 * @throws {Error} Invalid parameters
 * @param {number=} gamma
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.gamma = function(gamma) {};

/**
 * Alternative spelling of greyscale.
 * Convert to 8-bit greyscale; 256 shades of grey.
 * This is a linear operation.
 * If the input image is in a non-linear colour space such as sRGB, use gamma() with greyscale() for the best results.
 * By default the output image will be web-friendly sRGB and contain three (identical) color channels.
 * This may be overridden by other sharp operations such as toColourspace('b-w'), which will produce an output image containing one color channel.
 * An alpha channel may be present, and will be unchanged by the operation.
 * @param {boolean=} grayscale
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.grayscale = function(grayscale) {};

/**
 * Convert to 8-bit greyscale; 256 shades of grey.
 * This is a linear operation.
 * If the input image is in a non-linear colour space such as sRGB, use gamma() with greyscale() for the best results.
 * By default the output image will be web-friendly sRGB and contain three (identical) color channels.
 * This may be overridden by other sharp operations such as toColourspace('b-w'), which will produce an output image containing one color channel.
 * An alpha channel may be present, and will be unchanged by the operation.
 * @param {boolean=} greyscale
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.greyscale = function(greyscale) {};

/**
 * Enhance output image contrast by stretching its luminance to cover the full dynamic range.
 * @param {boolean=} normalize
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.normalize = function(normalize) {};

/**
 * Alternative spelling of normalise.
 * Enhance output image contrast by stretching its luminance to cover the full dynamic range.
 * @param {boolean=} normalise
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.normalise = function(normalise) {};

/**
 * Overlay (composite) an image over the processed (resized, extracted etc.) image.
 * @param {(string|?)} image
 * @param {!sharp.OverlayOptions=} options
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.overlayWith = function(image, options) {};

/**
 * Set the output colourspace.
 * @throws {Error} Invalid parameters
 * @param {string=} colourspace
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.toColourspace = function(colourspace) {};

/**
 * Alternative spelling of toColourspace.
 * Set the output colorspace.
 * @throws {Error} Invalid parameters
 * @param {string} colorspace
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.toColorspace = function(colorspace) {};

/**
 * Extract a single channel from a multi-channel image.
 * @throws {Error} Invalid channel
 * @param {(string|number)} channel
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.extractChannel = function(channel) {};

/**
 * Join one or more channels to the image. The meaning of the added channels depends on the output colourspace, set with toColourspace().
 * @throws {Error} Invalid parameters
 * @param {(string|?|!Array<string>|!Array<?>)} channels
 * @param {{raw: !sharp.Raw}=} options
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.joinChannel = function(channels, options) {};

/**
 * Perform a bitwise boolean operation on all input image channels (bands) to produce a single channel output image.
 * @param {string} boolOp
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.bandbool = function(boolOp) {};

/**
 * Perform a bitwise boolean operation with operand image.
 * @throws {Error} Invalid parameters
 * @param {(string|?)} operand
 * @param {string} operator
 * @param {{raw: !sharp.Raw}=} options
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.boolean = function(operand, operator, options) {};

/**
 * Write output image data to a file.
 * @throws {Error} Invalid parameters
 * Write output image data to a file.
 * @throws {Error} Invalid parameters
 * @param {string} fileOut
 * @param {function(!Error, !sharp.OutputInfo): void=} callback
 * @return {!sharp.SharpInstance|!Promise<!sharp.OutputInfo>}
 */
sharp.SharpInstance.prototype.toFile = function(fileOut, callback) {};

/**
 * Write output to a Buffer. JPEG, PNG, WebP, and RAW output are supported. By default, the format will match the input image, except GIF and SVG input which become PNG output.
 *                            err is an error message, if any.
 *                            buffer is the output image data.
 *                            info contains the output image format, size (bytes), width, height and channels.
 *                            A Promises/A+ promise is returned when callback is not provided.
 * Write output to a Buffer. JPEG, PNG, WebP, and RAW output are supported. By default, the format will match the input image, except GIF and SVG input which become PNG output.
 * @param {function(!Error, ?, !sharp.OutputInfo): void=} callback
 * @return {!sharp.SharpInstance|!Promise<?>}
 */
sharp.SharpInstance.prototype.toBuffer = function(callback) {};

/**
 * Use these JPEG options for output image.
 * @throws {Error} Invalid options
 * @param {!sharp.JpegOptions=} options
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.jpeg = function(options) {};

/**
 * Use these PNG options for output image.
 * @throws {Error} Invalid options
 * @param {!sharp.PngOptions=} options
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.png = function(options) {};

/**
 * Use these WebP options for output image.
 * @throws {Error} Invalid options
 * @param {!sharp.OutputOptions=} options
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.webp = function(options) {};

/**
 * Use these TIFF options for output image.
 * @throws {Error} Invalid options
 * @param {!sharp.OutputOptions=} options
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.tiff = function(options) {};

/**
 * Force output to be raw, uncompressed uint8 pixel data.
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.raw = function() {};

/**
 * Force output to a given format.
 * @throws {Error} Unsupported format or options
 * @param {(string|!sharp.AvailableFormatInfo)} format
 * @param {(!sharp.JpegOptions|!sharp.OutputOptions|!sharp.PngOptions)=} options
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.toFormat = function(format, options) {};

/**
 * Include all metadata (EXIF, XMP, IPTC) from the input image in the output image.
 * The default behaviour, when withMetadata is not used, is to strip all metadata and convert to the device-independent sRGB colour space.
 * This will also convert to and add a web-friendly sRGB ICC profile.
 * @throws {Error} Invalid parameters.
 * @param {!sharp.Metadata=} metadata
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.withMetadata = function(metadata) {};

/**
 * Use tile-based deep zoom (image pyramid) output. Set the format and options for tile images via the  toFormat, jpeg, png or webp functions.
 * Use a .zip or .szi file extension with toFile to write to a compressed archive file format.
 * @param {!sharp.TileOptions} options
 * @return {!sharp.SharpInstance}
 */
sharp.SharpInstance.prototype.tile = function(options) {};
/**
 * @record
 * @struct
 */
sharp.SharpOptions = function() {};
 /** @type {number} */
sharp.SharpOptions.prototype.density;
 /** @type {!sharp.Raw} */
sharp.SharpOptions.prototype.raw;
/**
 * @record
 * @struct
 */
sharp.CacheOptions = function() {};
 /** @type {number} */
sharp.CacheOptions.prototype.memory;
 /** @type {number} */
sharp.CacheOptions.prototype.files;
 /** @type {number} */
sharp.CacheOptions.prototype.items;
/**
 * @record
 * @struct
 */
sharp.SharpCounters = function() {};
 /** @type {number} */
sharp.SharpCounters.prototype.queue;
 /** @type {number} */
sharp.SharpCounters.prototype.process;
/**
 * @record
 * @struct
 */
sharp.Raw = function() {};
 /** @type {number} */
sharp.Raw.prototype.width;
 /** @type {number} */
sharp.Raw.prototype.height;
 /** @type {number} */
sharp.Raw.prototype.channels;
/**
 * @record
 * @struct
 */
sharp.Metadata = function() {};
 /** @type {string} */
sharp.Metadata.prototype.format;
 /** @type {number} */
sharp.Metadata.prototype.width;
 /** @type {number} */
sharp.Metadata.prototype.height;
 /** @type {string} */
sharp.Metadata.prototype.space;
 /** @type {number} */
sharp.Metadata.prototype.channels;
 /** @type {number} */
sharp.Metadata.prototype.density;
 /** @type {boolean} */
sharp.Metadata.prototype.hasProfile;
 /** @type {boolean} */
sharp.Metadata.prototype.hasAlpha;
 /** @type {number} */
sharp.Metadata.prototype.orientation;
 /** @type {?} */
sharp.Metadata.prototype.exif;
 /** @type {?} */
sharp.Metadata.prototype.icc;
/**
 * @extends {sharp.OutputOptions}
 * @record
 * @struct
 */
sharp.JpegOptions = function() {};
 /** @type {boolean} */
sharp.JpegOptions.prototype.progressive;
 /** @type {string} */
sharp.JpegOptions.prototype.chromaSubsampling;
 /** @type {boolean} */
sharp.JpegOptions.prototype.trellisQuantisation;
 /** @type {boolean} */
sharp.JpegOptions.prototype.overshootDeringing;
 /** @type {boolean} */
sharp.JpegOptions.prototype.optimiseScans;
 /** @type {boolean} */
sharp.JpegOptions.prototype.optimizeScans;
/**
 * @record
 * @struct
 */
sharp.PngOptions = function() {};
 /** @type {boolean} */
sharp.PngOptions.prototype.progressive;
 /** @type {number} */
sharp.PngOptions.prototype.compressionLevel;
 /** @type {boolean} */
sharp.PngOptions.prototype.adaptiveFiltering;
 /** @type {boolean} */
sharp.PngOptions.prototype.force;
/**
 * @record
 * @struct
 */
sharp.OutputOptions = function() {};
 /** @type {number} */
sharp.OutputOptions.prototype.quality;
 /** @type {boolean} */
sharp.OutputOptions.prototype.force;
/**
 * @record
 * @struct
 */
sharp.ResizeOptions = function() {};
 /** @type {string} */
sharp.ResizeOptions.prototype.kernel;
 /** @type {string} */
sharp.ResizeOptions.prototype.interpolator;
 /** @type {boolean} */
sharp.ResizeOptions.prototype.centreSampling;
 /** @type {boolean} */
sharp.ResizeOptions.prototype.centerSampling;
/**
 * @record
 * @struct
 */
sharp.Region = function() {};
 /** @type {number} */
sharp.Region.prototype.left;
 /** @type {number} */
sharp.Region.prototype.top;
 /** @type {number} */
sharp.Region.prototype.width;
 /** @type {number} */
sharp.Region.prototype.height;
/**
 * @record
 * @struct
 */
sharp.ExtendOptions = function() {};
 /** @type {number} */
sharp.ExtendOptions.prototype.top;
 /** @type {number} */
sharp.ExtendOptions.prototype.left;
 /** @type {number} */
sharp.ExtendOptions.prototype.bottom;
 /** @type {number} */
sharp.ExtendOptions.prototype.right;
/**
 * @record
 * @struct
 */
sharp.RGBA = function() {};
 /** @type {number} */
sharp.RGBA.prototype.r;
 /** @type {number} */
sharp.RGBA.prototype.g;
 /** @type {number} */
sharp.RGBA.prototype.b;
 /** @type {number} */
sharp.RGBA.prototype.alpha;
/**
 * @record
 * @struct
 */
sharp.Kernel = function() {};
 /** @type {number} */
sharp.Kernel.prototype.width;
 /** @type {number} */
sharp.Kernel.prototype.height;
 /** @type {!Array<number>} */
sharp.Kernel.prototype.kernel;
 /** @type {number} */
sharp.Kernel.prototype.scale;
 /** @type {number} */
sharp.Kernel.prototype.offset;
/**
 * @record
 * @struct
 */
sharp.ThresholdOptions = function() {};
 /** @type {boolean} */
sharp.ThresholdOptions.prototype.greyscale;
 /** @type {boolean} */
sharp.ThresholdOptions.prototype.grayscale;
/**
 * @record
 * @struct
 */
sharp.OverlayOptions = function() {};
 /** @type {number} */
sharp.OverlayOptions.prototype.gravity;
 /** @type {number} */
sharp.OverlayOptions.prototype.top;
 /** @type {number} */
sharp.OverlayOptions.prototype.left;
 /** @type {boolean} */
sharp.OverlayOptions.prototype.tile;
 /** @type {boolean} */
sharp.OverlayOptions.prototype.cutout;
 /** @type {!sharp.Raw} */
sharp.OverlayOptions.prototype.raw;
/**
 * @record
 * @struct
 */
sharp.TileOptions = function() {};
 /** @type {number} */
sharp.TileOptions.prototype.size;
 /** @type {number} */
sharp.TileOptions.prototype.overlap;
 /** @type {string} */
sharp.TileOptions.prototype.container;
 /** @type {string} */
sharp.TileOptions.prototype.layout;
/**
 * @record
 * @struct
 */
sharp.OutputInfo = function() {};
 /** @type {string} */
sharp.OutputInfo.prototype.format;
 /** @type {number} */
sharp.OutputInfo.prototype.size;
 /** @type {number} */
sharp.OutputInfo.prototype.width;
 /** @type {number} */
sharp.OutputInfo.prototype.height;
 /** @type {number} */
sharp.OutputInfo.prototype.channels;
/**
 * @record
 * @struct
 */
sharp.AvailableFormatInfo = function() {};
 /** @type {string} */
sharp.AvailableFormatInfo.prototype.id;
 /** @type {{file: boolean, buffer: boolean, stream: boolean}} */
sharp.AvailableFormatInfo.prototype.input;
 /** @type {{file: boolean, buffer: boolean, stream: boolean}} */
sharp.AvailableFormatInfo.prototype.output;
/**
 * @record
 * @struct
 */
sharp.KernelEnum = function() {};
 /** @type {string} */
sharp.KernelEnum.prototype.cubic;
 /** @type {string} */
sharp.KernelEnum.prototype.lanczos2;
 /** @type {string} */
sharp.KernelEnum.prototype.lanczos3;
/**
 * @record
 * @struct
 */
sharp.InterpolatorEnum = function() {};
 /** @type {string} */
sharp.InterpolatorEnum.prototype.nearest;
 /** @type {string} */
sharp.InterpolatorEnum.prototype.bilinear;
 /** @type {string} */
sharp.InterpolatorEnum.prototype.bicubic;
 /** @type {string} */
sharp.InterpolatorEnum.prototype.nohalo;
 /** @type {string} */
sharp.InterpolatorEnum.prototype.lbb;
 /** @type {string} */
sharp.InterpolatorEnum.prototype.locallyBoundedBicubic;
 /** @type {string} */
sharp.InterpolatorEnum.prototype.vsqbs;
 /** @type {string} */
sharp.InterpolatorEnum.prototype.vertexSplitQuadraticBasisSpline;
/**
 * @record
 * @struct
 */
sharp.BoolEnum = function() {};
 /** @type {string} */
sharp.BoolEnum.prototype.and;
 /** @type {string} */
sharp.BoolEnum.prototype.or;
 /** @type {string} */
sharp.BoolEnum.prototype.eor;
/**
 * @record
 * @struct
 */
sharp.ColourspaceEnum = function() {};
 /** @type {string} */
sharp.ColourspaceEnum.prototype.multiband;

/* TODO: PropertySignature: sharp."b-w" */
 /** @type {string} */
sharp.ColourspaceEnum.prototype.bw;
 /** @type {string} */
sharp.ColourspaceEnum.prototype.cmyk;
 /** @type {string} */
sharp.ColourspaceEnum.prototype.srgb;
/**
 * @record
 * @struct
 */
sharp.GravityEnum = function() {};
 /** @type {number} */
sharp.GravityEnum.prototype.north;
 /** @type {number} */
sharp.GravityEnum.prototype.northeast;
 /** @type {number} */
sharp.GravityEnum.prototype.southeast;
 /** @type {number} */
sharp.GravityEnum.prototype.south;
 /** @type {number} */
sharp.GravityEnum.prototype.southwest;
 /** @type {number} */
sharp.GravityEnum.prototype.west;
 /** @type {number} */
sharp.GravityEnum.prototype.northwest;
 /** @type {number} */
sharp.GravityEnum.prototype.east;
 /** @type {number} */
sharp.GravityEnum.prototype.center;
 /** @type {number} */
sharp.GravityEnum.prototype.centre;
/**
 * @record
 * @struct
 */
sharp.StrategyEnum = function() {};
 /** @type {number} */
sharp.StrategyEnum.prototype.entropy;
 /** @type {number} */
sharp.StrategyEnum.prototype.attention;
/**
 * @record
 * @struct
 */
sharp.FormatEnum = function() {};
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.jpeg;
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.png;
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.webp;
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.raw;
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.tiff;
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.dz;
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.input;
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.magick;
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.openslide;
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.ppm;
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.fits;
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.gif;
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.svg;
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.pdf;
 /** @type {!sharp.AvailableFormatInfo} */
sharp.FormatEnum.prototype.v;
/**
 * @record
 * @struct
 */
sharp.CacheResult = function() {};
 /** @type {{current: number, high: number, max: number}} */
sharp.CacheResult.prototype.memory;
 /** @type {{current: number, max: number}} */
sharp.CacheResult.prototype.files;
 /** @type {{current: number, max: number}} */
sharp.CacheResult.prototype.items;

/* TODO: ExportAssignment in  */
