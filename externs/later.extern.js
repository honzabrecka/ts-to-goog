/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/later/index.d.ts:
/** @const */
var later = {};
/**
 * @record
 * @struct
 */
later.ScheduleData = function() {};
 /** @type {!Array<!later.Recurrence>} */
later.ScheduleData.prototype.schedules;
 /** @type {!Array<!later.Recurrence>} */
later.ScheduleData.prototype.exceptions;
 /** @type {number} */
later.ScheduleData.prototype.error;
/**
 * @record
 * @struct
 */
later.Recurrence = function() {};
 /** @type {!Array<number>} */
later.Recurrence.prototype.t;
 /** @type {!Array<number>} */
later.Recurrence.prototype.s;
 /** @type {!Array<number>} */
later.Recurrence.prototype.m;
 /** @type {!Array<number>} */
later.Recurrence.prototype.h;
 /** @type {!Array<number>} */
later.Recurrence.prototype.D;
 /** @type {!Array<number>} */
later.Recurrence.prototype.dw;
 /** @type {!Array<number>} */
later.Recurrence.prototype.dc;
 /** @type {!Array<number>} */
later.Recurrence.prototype.dy;
 /** @type {!Array<number>} */
later.Recurrence.prototype.wm;
 /** @type {!Array<number>} */
later.Recurrence.prototype.wy;
 /** @type {!Array<number>} */
later.Recurrence.prototype.M;
 /** @type {!Array<number>} */
later.Recurrence.prototype.Y;
 /** @type {!Array<number>} */
later.Recurrence.prototype.t_a;
 /** @type {!Array<number>} */
later.Recurrence.prototype.s_a;
 /** @type {!Array<number>} */
later.Recurrence.prototype.m_a;
 /** @type {!Array<number>} */
later.Recurrence.prototype.h_a;
 /** @type {!Array<number>} */
later.Recurrence.prototype.D_a;
 /** @type {!Array<number>} */
later.Recurrence.prototype.dw_a;
 /** @type {!Array<number>} */
later.Recurrence.prototype.dc_a;
 /** @type {!Array<number>} */
later.Recurrence.prototype.dy_a;
 /** @type {!Array<number>} */
later.Recurrence.prototype.wm_a;
 /** @type {!Array<number>} */
later.Recurrence.prototype.wy_a;
 /** @type {!Array<number>} */
later.Recurrence.prototype.M_a;
 /** @type {!Array<number>} */
later.Recurrence.prototype.Y_a;
 /** @type {!Array<number>} */
later.Recurrence.prototype.t_b;
 /** @type {!Array<number>} */
later.Recurrence.prototype.s_b;
 /** @type {!Array<number>} */
later.Recurrence.prototype.m_b;
 /** @type {!Array<number>} */
later.Recurrence.prototype.h_b;
 /** @type {!Array<number>} */
later.Recurrence.prototype.D_b;
 /** @type {!Array<number>} */
later.Recurrence.prototype.dw_b;
 /** @type {!Array<number>} */
later.Recurrence.prototype.dc_b;
 /** @type {!Array<number>} */
later.Recurrence.prototype.dy_b;
 /** @type {!Array<number>} */
later.Recurrence.prototype.wm_b;
 /** @type {!Array<number>} */
later.Recurrence.prototype.wy_b;
 /** @type {!Array<number>} */
later.Recurrence.prototype.M_b;
 /** @type {!Array<number>} */
later.Recurrence.prototype.Y_b;

/* TODO: IndexSignature: later */
/**
 * @record
 * @struct
 */
later.ParseStatic = function() {};

/**
 * Create a recurrence builder for building schedule data.
 * @return {!later.RecurrenceBuilder}
 */
later.ParseStatic.prototype.recur = function() {};

/**
 * Create schedule data by parsing a cron string
 * 
 * @param {string=} input
 * @param {boolean=} hasSeconds
 * @return {!later.ScheduleData}
 */
later.ParseStatic.prototype.cron = function(input, hasSeconds) {};

/**
 * Create schedule data by paring a human readable string.
 * 
 * @param {string=} input
 * @return {!later.ScheduleData}
 */
later.ParseStatic.prototype.text = function(input) {};
/**
 * @record
 * @struct
 */
later.Timer = function() {};

/**
 * Clear the timer and end execution.
 * @return {void}
 */
later.Timer.prototype.clear = function() {};
/**
 * @record
 * @struct
 */
later.Schedule = function() {};

/**
 * Finds the next valid instance or instances of the current schedule,
 * optionally between a specified start and end date. Start date is
 * Date.now() by default, end date is unspecified. Start date must be
 * smaller than end date.
 * 
 * @param {number} numberOfInst
 * @param {!Date=} dateFrom
 * @param {!Date=} dateTo
 * @return {!Array<!Date>}
 */
later.Schedule.prototype.next = function(numberOfInst, dateFrom, dateTo) {};

/**
 * Finds the next valid range or ranges of the current schedule,
 * optionally between a specified start and end date. Start date is
 * Date.now() by default, end date is unspecified. Start date must be
 * greater than end date.
 * 
 * @param {number} numberOfInst
 * @param {!Date=} dateFrom
 * @param {!Date=} dateTo
 * @return {!Array<!Date>}
 */
later.Schedule.prototype.nextRange = function(numberOfInst, dateFrom, dateTo) {};

/**
 * Finds the previous valid instance or instances of the current schedule,
 * optionally between a specified start and end date. Start date is
 * Date.now() by default, end date is unspecified. Start date must be
 * greater than end date.
 * 
 * @param {number} numberOfInst
 * @param {!Date=} dateFrom
 * @param {!Date=} dateTo
 * @return {!Array<!Date>}
 */
later.Schedule.prototype.prev = function(numberOfInst, dateFrom, dateTo) {};

/**
 * Finds the previous valid range or ranges of the current schedule,
 * optionally between a specified start and end date. Start date is
 * Date.now() by default, end date is unspecified. Start date must be
 * greater than end date.
 * 
 * @param {number} numberOfInst
 * @param {!Date=} dateFrom
 * @param {!Date=} dateTo
 * @return {!Array<!Date>}
 */
later.Schedule.prototype.prevRange = function(numberOfInst, dateFrom, dateTo) {};
/**
 * @extends {later.ScheduleData}
 * @record
 * @struct
 */
later.RecurrenceBuilder = function() {};

/**
 * a time period
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.second = function() {};

/**
 * a time period
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.minute = function() {};

/**
 * a time period
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.hour = function() {};

/**
 * a time period
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.time = function() {};

/**
 * a time period
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.dayOfWeek = function() {};

/**
 * a time period
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.dayOfWeekCount = function() {};

/**
 * a time period
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.dayOfMonth = function() {};

/**
 * a time period
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.dayOfYear = function() {};

/**
 * a time period
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.weekOfMonth = function() {};

/**
 * a time period
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.weekOfYear = function() {};

/**
 * a time period
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.month = function() {};

/**
 * a time period
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.year = function() {};

/**
 * a time period
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.fullDate = function() {};

/**
 * Specifies one or more specific vals of a time period information provider.
 * When used to specify a time, a string indicating the 24-hour time may be used.
 * 
 * Specifies one or more specific vals of a time period information provider.
 * When used to specify a time, a string indicating the 24-hour time may be used.
 * 
 * @param {...number|(string|!Date)} values_or_value - A Date or string representing your value.
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.on = function(values_or_value) {};

/**
 * Preceed a time period.
 * 
 * @param {(string|number)=} value
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.every = function(value) {};

/**
 * Preceed a time period.
 * 
 * Preceed a time period.
 * 
 * @param {number|string} start
 * @param {number|string} end
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.between = function(start, end) {};

/**
 * After a time period.
 * 
 * @param {(string|number)} value - A number or string representing your value.
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.after = function(value) {};

/**
 * Before a time period.
 * 
 * @param {(string|number)} value - A number or string representing your value.
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.before = function(value) {};

/**
 * After a time period.
 * 
 * @param {(string|number)} value - A number or string representing your value.
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.startingOn = function(value) {};

/**
 * Equivalent to .on(min)
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.first = function() {};

/**
 * Equivalent to .on(max)
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.last = function() {};

/**
 * Equivalent to .on(1,7).dayOfWeek()
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.onWeekend = function() {};

/**
 * Equivalent to .on(2,3,4,5,6).dayOfWeek()
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.onWeekday = function() {};

/**
 * Add a new schedule value to schedules, composite schedule.
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.and = function() {};

/**
 * Add exceptions.
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.except = function() {};

/**
 * Custom Timeperiod Recurrences.
 * Using a key as defined by the custom period in any extension to Later.IStatic.
 * @param {string} key
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.customPeriod = function(key) {};

/**
 * Customise Recurrences.
 * Using a key as defined by the custom modifier in any extension to Later.IModifierStatic.
 * @param {string} key
 * @param {number} values
 * @return {!later.RecurrenceBuilder}
 */
later.RecurrenceBuilder.prototype.customModifier = function(key, values) {};
/**
 * @record
 * @struct
 */
later.DateProvider = function() {};

/**
 * Set later to use UTC time.
 * @return {void}
 */
later.DateProvider.prototype.UTC = function() {};

/**
 * Set later to use local time.
 * @return {void}
 */
later.DateProvider.prototype.localTime = function() {};

/**
 * Builds and returns a new Date using the specified values.  Date
 * returned is either using Local time or UTC based on isLocal.
 * 
 * @param {number=} Y
 * @param {number=} M
 * @param {number=} D
 * @param {number=} h
 * @param {number=} m
 * @param {number=} s
 * @return {!Date}
 */
later.DateProvider.prototype.next = function(Y, M, D, h, m, s) {};

/**
 * Builds and returns a new Date using the specified values.  Date
 * returned is either using Local time or UTC based on isLocal.
 * 
 * @param {number=} Y
 * @param {number=} M
 * @param {number=} D
 * @param {number=} h
 * @param {number=} m
 * @param {number=} s
 * @return {!Date}
 */
later.DateProvider.prototype.prev = function(Y, M, D, h, m, s) {};

/**
 * Determines if a value will cause a particular constraint to rollover to the
 * next largest time period. Used primarily when a constraint has a
 * variable extent.
 * 
 * @param {!Date} d
 * @param {number} val
 * @param {!later.Modifier} constraint
 * @param {!later.TimePeriod} period
 * @return {!Date}
 */
later.DateProvider.prototype.nextRollover = function(d, val, constraint, period) {};

/**
 * Determines if a value will cause a particular constraint to rollover to the
 * previous largest time period. Used primarily when a constraint has a
 * variable extent.
 * 
 * @param {!Date} d
 * @param {number} val
 * @param {!later.Modifier} constraint
 * @param {!later.TimePeriod} period
 * @return {!Date}
 */
later.DateProvider.prototype.prevRollover = function(d, val, constraint, period) {};
/**
 * @record
 * @struct
 */
later.TimePeriod = function() {};
 /** @type {string} */
later.TimePeriod.prototype.name;
 /** @type {number} */
later.TimePeriod.prototype.range;

/**
 * The value of this time period for the date specified.
 * 
 * @param {!Date} date
 * @return {number}
 */
later.TimePeriod.prototype.val = function(date) {};

/**
 * True if the specified value is valid for the specified date, false otherwise.
 * 
 * @param {!Date} date
 * @param {?} value
 * @return {boolean}
 */
later.TimePeriod.prototype.isValid = function(date, value) {};

/**
 * The minimum and maximum valid values for the time period for the specified date.
 * If the minimum value is not 0, 0 can be specified in schedules to indicate the maximum value.
 * This makes working with non - constant extents(like days in a month) easier.
 * 
 * @param {!Date=} date
 * @return {!Array<number>}
 */
later.TimePeriod.prototype.extent = function(date) {};

/**
 * The first second in which the value is the same as the value of the specified date.
 *  For example, the start of an hour would be the hour with 0 minutes and 0 seconds.
 * 
 * @param {!Date} date
 * @return {!Date}
 */
later.TimePeriod.prototype.start = function(date) {};

/**
 * The last second in which the value is the same as the value of the specified date.
 * For example, the end of an hour would be the hour with 59 minutes and 59 seconds.
 * 
 * @param {!Date} date
 * @return {!Date}
 */
later.TimePeriod.prototype.end = function(date) {};

/**
 * Returns the next date where the value is the value specified.
 * Sets the value to 1 if value specified is greater than the max allowed value.
 * 
 * @param {!Date} date
 * @param {?} value
 * @return {!Date}
 */
later.TimePeriod.prototype.next = function(date, value) {};

/**
 * Returns the previous date where the value is the value specified.
 * Sets the value to the max allowed value if the value specified is greater than the max allowed value.
 * 
 * @param {!Date} date
 * @param {?} value
 * @return {!Date}
 */
later.TimePeriod.prototype.prev = function(date, value) {};
/**
 * @extends {later.TimePeriod}
 * @record
 * @struct
 */
later.Modifier = function() {};

/* TODO: CallSignature: later */
/**
 * @record
 * @struct
 */
later.ModifierStatic = function() {};
 /** @type {!later.Modifier} */
later.ModifierStatic.prototype.after;
 /** @type {!later.Modifier} */
later.ModifierStatic.prototype.before;
/**
 * @record
 * @struct
 */
later.Static = function() {};
 /** @type {!later.ParseStatic} */
later.Static.prototype.parse;
 /** @type {!later.DateProvider} */
later.Static.prototype.date;
 /** @type {!later.TimePeriod} */
later.Static.prototype.time;
 /** @type {!later.TimePeriod} */
later.Static.prototype.second;
 /** @type {!later.TimePeriod} */
later.Static.prototype.minute;
 /** @type {!later.TimePeriod} */
later.Static.prototype.hour;
 /** @type {!later.TimePeriod} */
later.Static.prototype.day;
 /** @type {!later.TimePeriod} */
later.Static.prototype.dayOfWeek;
 /** @type {!later.TimePeriod} */
later.Static.prototype.dayOfWeekCount;
 /** @type {!later.TimePeriod} */
later.Static.prototype.dayOfYear;
 /** @type {!later.TimePeriod} */
later.Static.prototype.weekOfMonth;
 /** @type {!later.TimePeriod} */
later.Static.prototype.weekOfYear;
 /** @type {!later.TimePeriod} */
later.Static.prototype.month;
 /** @type {!later.TimePeriod} */
later.Static.prototype.year;
 /** @type {!later.ModifierStatic} */
later.Static.prototype.modifier;

/**
 * Schedule
 * Generates instances from schedule data.
 * @param {?} input
 * @return {!later.Schedule}
 */
later.Static.prototype.schedule = function(input) {};

/**
 * Set timeout on window using given recurrence next.
 * 
 * @param {function(): void} callback
 * @param {!later.ScheduleData} time
 * @return {!later.Timer}
 */
later.Static.prototype.setTimeout = function(callback, time) {};

/**
 * Set interval on window using given recurrence
 * 
 * @param {function(): void} callback
 * @param {!later.ScheduleData} time
 * @return {!later.Timer}
 */
later.Static.prototype.setInterval = function(callback, time) {};
 /** @type {!later.Static} */
var later;

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
