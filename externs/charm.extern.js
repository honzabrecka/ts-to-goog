/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/charm/index.d.ts:
/** @const */
var charm = {};

/** @typedef {string} */
charm.CharmColorName;

/** @typedef {number} */
charm.CharmColorHex;

/** @typedef {(number|string)} */
charm.CharmColor;

/** @typedef {(!NodeJS.WritableStream|!NodeJS.ReadableStream|!NodeJS.Process)} */
charm.CharmAnyStream;
/**
 * @extends {NodeJS.WritableStream}
 * @record
 * @struct
 */
charm.CharmInstance = function() {};

/**
 * Reset the entire screen, like the /usr/bin/reset command.
 * @return {void}
 */
charm.CharmInstance.prototype.reset = function() {};

/**
 * Emit an "end" event downstream.
 * @return {void}
 */
charm.CharmInstance.prototype.destroy = function() {};

/**
 * Emit an "end" event downstream.
 * @return {void}
 */
charm.CharmInstance.prototype.end = function() {};

/**
 * Pass along `msg` to the output stream.
 * @param {(string|?)} msg_or_msgs
 * @param {!Function|string=} cb_or_encoding Unused by charm, only there to comply to the WritableStream interface
 * @param {!Function=} cb
 * @return {boolean}
 */
charm.CharmInstance.prototype.write = function(msg_or_msgs, cb_or_encoding, cb) {};

/**
 * Set the cursor position to the absolute coordinates `x`, `y`.
 * Query the absolute cursor position from the input stream through the output stream
 * (the shell does this automatically) and get the response back as `cb(x, y)`.
 * @param {number|function(number, number): void} x_or_callback
 * @param {number=} y
 * @return {void}
 */
charm.CharmInstance.prototype.position = function(x_or_callback, y) {};

/**
 * Move the cursor position by the relative coordinates `x`, `y`.
 * @param {number} x
 * @param {number} y
 * @return {CharmInstance}
 */
charm.CharmInstance.prototype.move = function(x, y) {};

/**
 * Move the cursor up by `y` rows.
 * @param {number} y
 * @return {CharmInstance}
 */
charm.CharmInstance.prototype.up = function(y) {};

/**
 * Move the cursor down by `y` rows.
 * @param {number} y
 * @return {CharmInstance}
 */
charm.CharmInstance.prototype.down = function(y) {};

/**
 * Move the cursor left by `x` columns.
 * @param {number} x
 * @return {CharmInstance}
 */
charm.CharmInstance.prototype.left = function(x) {};

/**
 * Move the cursor right by `x` columns.
 * @param {number} x
 * @return {CharmInstance}
 */
charm.CharmInstance.prototype.right = function(x) {};

/**
 * Push the cursor state and optionally the attribute state.
 * @param {boolean=} withAttributes
 * @return {CharmInstance}
 */
charm.CharmInstance.prototype.push = function(withAttributes) {};

/**
 * Pop the cursor state and optionally the attribute state.
 * @param {boolean=} withAttributes
 * @return {CharmInstance}
 */
charm.CharmInstance.prototype.pop = function(withAttributes) {};

/**
 * Erase a region defined by the string `s`.
 * 
 * `s` can be:
 * 
 *  - end - erase from the cursor to the end of the line
 *  - start - erase from the cursor to the start of the line
 *  - line - erase the current line
 *  - down - erase everything below the current line
 *  - up - erase everything above the current line
 *  - screen - erase the entire screen
 * @param {string} s
 * @return {CharmInstance}
 */
charm.CharmInstance.prototype.erase = function(s) {};

/**
 * Delete `'line'` or `'char'`s. delete differs from erase because it does not write over
 * the deleted characters with whitesapce, but instead removes the deleted space.
 * 
 * mode can be `'line'` or `'char'`. `n` is the number of items to be deleted.
 * `n` must be a positive integer.
 * 
 * The cursor position is not updated.
 * @param {string} mode
 * @param {number=} n
 * @return {CharmInstance}
 */
charm.CharmInstance.prototype.delete = function(mode, n) {};

/**
 * Insert space into the terminal. `insert` is the opposite of `delete`,
 * 
 * mode can be `'line'` or `'char'`. `n` is the number of items to be deleted.
 * `n` must be a positive integer.
 * @param {string} mode
 * @param {number} n
 * @return {CharmInstance}
 */
charm.CharmInstance.prototype.insert = function(mode, n) {};

/**
 * Set the display mode with the string `attr.`
 * 
 * `attr` can be:
 * 
 *  - reset
 *  - bright
 *  - dim
 *  - underscore
 *  - blink
 *  - reverse
 *  - hidden
 * @param {string} attr
 * @return {CharmInstance}
 */
charm.CharmInstance.prototype.display = function(attr) {};

/**
 * Set the foreground color with the string `color`, which can be:
 * 
 *  - red
 *  - yellow
 *  - green
 *  - blue
 *  - cyan
 *  - magenta
 *  - black
 *  - white
 *  - or `color` can be an integer from 0 to 255, inclusive.
 * @param {(number|string)} color
 * @return {CharmInstance}
 */
charm.CharmInstance.prototype.foreground = function(color) {};

/**
 * Set the background color with the string `color`, which can be:
 * 
 *  - red
 *  - yellow
 *  - green
 *  - blue
 *  - cyan
 *  - magenta
 *  - black
 *  - white
 *  - or `color` can be an integer from 0 to 255, inclusive.
 * @param {(number|string)} color
 * @return {CharmInstance}
 */
charm.CharmInstance.prototype.background = function(color) {};

/**
 * Set the cursor visibility with a boolean `visible`.
 * @param {boolean} visible
 * @return {?}
 */
charm.CharmInstance.prototype.cursor = function(visible) {};

/**
 * Pipes the output of Charm to a writeable stream `stream`
 * @param {!NodeJS.WritableStream} stream
 * @return {void}
 */
charm.CharmInstance.prototype.pipe = function(stream) {};

/**
 * Create a new readable/writable charm stream.
 * 
 * You can pass in readable or writable streams as parameters
 * and they will be piped to or from accordingly.
 * You can also pass `process` in which case
 * `process.stdin` and `process.stdout` will be used.
 * @param {(!NodeJS.WritableStream|!NodeJS.ReadableStream|!NodeJS.Process)=} param
 * @return {!charm.CharmInstance}
 */
function charm(param) {}

/* TODO: ExportAssignment in  */
