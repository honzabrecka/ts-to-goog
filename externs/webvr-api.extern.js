/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/webvr-api/index.d.ts:
/**
 * @constructor
 * @struct
 */
function VRDisplay() {}
 /** @type {boolean} */
VRDisplay.prototype.isConnected;
 /** @type {boolean} */
VRDisplay.prototype.isPresenting;
 /** @type {!VRDisplayCapabilities} */
VRDisplay.prototype.capabilities;
 /** @type {!VRStageParameters} */
VRDisplay.prototype.stageParameters;
 /** @type {number} */
VRDisplay.prototype.displayId;
 /** @type {string} */
VRDisplay.prototype.displayName;
 /** @type {number} */
VRDisplay.prototype.depthNear;
 /** @type {number} */
VRDisplay.prototype.depthFar;

/**
 * @param {string} whichEye
 * @return {!VREyeParameters}
 */
VRDisplay.prototype.getEyeParameters = function(whichEye) {};

/**
 * Populates the passed VRFrameData with the information required to render
 * the current frame.
 * @param {!VRFrameData} frameData
 * @return {boolean}
 */
VRDisplay.prototype.getFrameData = function(frameData) {};

/**
 * Return a VRPose containing the future predicted pose of the VRDisplay
 * when the current frame will be presented. The value returned will not
 * change until JavaScript has returned control to the browser.
 * 
 * The VRPose will contain the position, orientation, velocity,
 * and acceleration of each of these properties.
 * @return {!VRPose}
 */
VRDisplay.prototype.getPose = function() {};

/**
 * Return the current instantaneous pose of the VRDisplay, with no
 * prediction applied.
 * @return {!VRPose}
 */
VRDisplay.prototype.getImmediatePose = function() {};

/**
 * Reset the pose for this display, treating its current position and
 * orientation as the "origin/zero" values. VRPose.position,
 * VRPose.orientation, and VRStageParameters.sittingToStandingTransform may be
 * updated when calling resetPose(). This should be called in only
 * sitting-space experiences.
 * @return {void}
 */
VRDisplay.prototype.resetPose = function() {};

/**
 * The callback passed to `requestAnimationFrame` will be called
 * any time a new frame should be rendered. When the VRDisplay is
 * presenting the callback will be called at the native refresh
 * rate of the HMD. When not presenting this function acts
 * identically to how window.requestAnimationFrame acts. Content should
 * make no assumptions of frame rate or vsync behavior as the HMD runs
 * asynchronously from other displays and at differing refresh rates.
 * @param {!FrameRequestCallback} callback
 * @return {number}
 */
VRDisplay.prototype.requestAnimationFrame = function(callback) {};

/**
 * Passing the value returned by `requestAnimationFrame` to
 * `cancelAnimationFrame` will unregister the callback.
 * @param {number} handle
 * @return {void}
 */
VRDisplay.prototype.cancelAnimationFrame = function(handle) {};

/**
 * Begin presenting to the VRDisplay. Must be called in response to a user gesture.
 * Repeat calls while already presenting will update the VRLayers being displayed.
 * @param {!Array<{source: !HTMLCanvasElement, leftBounds: !Array<number>, rightBounds: !Array<number>}>} layers
 * @return {!Promise<void>}
 */
VRDisplay.prototype.requestPresent = function(layers) {};

/**
 * Stops presenting to the VRDisplay.
 * @return {!Promise<void>}
 */
VRDisplay.prototype.exitPresent = function() {};

/**
 * Get the layers currently being presented.
 * @return {!Array<{source: !HTMLCanvasElement, leftBounds: !Array<number>, rightBounds: !Array<number>}>}
 */
VRDisplay.prototype.getLayers = function() {};

/**
 * The VRLayer provided to the VRDisplay will be captured and presented
 * in the HMD. Calling this function has the same effect on the source
 * canvas as any other operation that uses its source image, and canvases
 * created without preserveDrawingBuffer set to true will be cleared.
 * @param {!VRPose=} pose
 * @return {void}
 */
VRDisplay.prototype.submitFrame = function(pose) {};

/** @typedef {!HTMLCanvasElement} */
var VRSource;

/** @typedef {{source: !HTMLCanvasElement, leftBounds: !Array<number>, rightBounds: !Array<number>}} */
var VRLayer;
/**
 * @record
 * @struct
 */
function VRDisplayCapabilities() {}
 /** @type {boolean} */
VRDisplayCapabilities.prototype.hasPosition;
 /** @type {boolean} */
VRDisplayCapabilities.prototype.hasOrientation;
 /** @type {boolean} */
VRDisplayCapabilities.prototype.hasExternalDisplay;
 /** @type {boolean} */
VRDisplayCapabilities.prototype.canPresent;
 /** @type {number} */
VRDisplayCapabilities.prototype.maxLayers;

/** @typedef {string} */
var VREye;
/**
 * @record
 * @struct
 */
function VRFieldOfView() {}
 /** @type {number} */
VRFieldOfView.prototype.upDegrees;
 /** @type {number} */
VRFieldOfView.prototype.rightDegrees;
 /** @type {number} */
VRFieldOfView.prototype.downDegrees;
 /** @type {number} */
VRFieldOfView.prototype.leftDegrees;
/**
 * @record
 * @struct
 */
function VRPose() {}
 /** @type {number} */
VRPose.prototype.timestamp;
 /** @type {!Float32Array} */
VRPose.prototype.position;
 /** @type {!Float32Array} */
VRPose.prototype.linearVelocity;
 /** @type {!Float32Array} */
VRPose.prototype.linearAcceleration;
 /** @type {!Float32Array} */
VRPose.prototype.orientation;
 /** @type {!Float32Array} */
VRPose.prototype.angularVelocity;
 /** @type {!Float32Array} */
VRPose.prototype.angularAcceleration;
/**
 * @constructor
 * @struct
 */
function VRFrameData() {}
 /** @type {number} */
VRFrameData.prototype.timestamp;
 /** @type {!Float32Array} */
VRFrameData.prototype.leftProjectionMatrix;
 /** @type {!Float32Array} */
VRFrameData.prototype.leftViewMatrix;
 /** @type {!Float32Array} */
VRFrameData.prototype.rightProjectionMatrix;
 /** @type {!Float32Array} */
VRFrameData.prototype.rightViewMatrix;
 /** @type {!VRPose} */
VRFrameData.prototype.pose;
/**
 * @record
 * @struct
 */
function VREyeParameters() {}
 /** @type {!Float32Array} */
VREyeParameters.prototype.offset;
 /** @type {!VRFieldOfView} */
VREyeParameters.prototype.fieldOfView;
 /** @type {number} */
VREyeParameters.prototype.renderWidth;
 /** @type {number} */
VREyeParameters.prototype.renderHeight;
/**
 * @record
 * @struct
 */
function VRStageParameters() {}
 /** @type {!Float32Array} */
VRStageParameters.prototype.sittingToStandingTransform;
 /** @type {number} */
VRStageParameters.prototype.sizeX;
 /** @type {number} */
VRStageParameters.prototype.sizeZ;
 /** @type {!Array<!VRDisplay>} */
Navigator.prototype.activeVRDisplays;

/**
 * @return {!Promise<!Array<!VRDisplay>>}
 */
Navigator.prototype.getVRDisplays = function() {};
 /** @type {function(!Event): ?} */
Window.prototype.onvrdisplayconnected;
 /** @type {function(!Event): ?} */
Window.prototype.onvrdisplaydisconnected;
 /** @type {function(!Event): ?} */
Window.prototype.onvrdisplaypresentchange;

/**
 * @param {string} type
 * @param {function(!Event): ?} listener
 * @param {boolean=} useCapture
 * @return {void}
 */
Window.prototype.addEventListener = function(type, listener, useCapture) {};
 /** @type {number} */
Gamepad.prototype.displayId;
