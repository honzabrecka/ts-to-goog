/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/jest/index.d.ts:
 /** @type {function(function(!jest.DoneCallback): ?, number): ?} */
var beforeAll;
 /** @type {function(function(!jest.DoneCallback): ?, number): ?} */
var beforeEach;
 /** @type {function(function(!jest.DoneCallback): ?, number): ?} */
var afterAll;
 /** @type {function(function(!jest.DoneCallback): ?, number): ?} */
var afterEach;
 /** @type {!jest.Describe} */
var describe;
 /** @type {!jest.Describe} */
var fdescribe;
 /** @type {!jest.Describe} */
var xdescribe;
 /** @type {!jest.It} */
var it;
 /** @type {!jest.It} */
var fit;
 /** @type {!jest.It} */
var xit;
 /** @type {!jest.It} */
var test;
 /** @type {!jest.It} */
var xtest;
 /** @type {!jest.Expect} */
var expect;
/**
 * @record
 * @struct
 */
function NodeRequire() {}

/**
 * Returns the actual module instead of a mock, bypassing all checks on
 * whether the module should receive a mock implementation or not.
 * @param {string} moduleName
 * @return {?}
 */
NodeRequire.prototype.requireActual = function(moduleName) {};

/**
 * Returns a mock module instead of the actual module, bypassing all checks
 * on whether the module should be required normally or not.
 * @param {string} moduleName
 * @return {?}
 */
NodeRequire.prototype.requireMock = function(moduleName) {};
/** @const */
var jest = {};

/**
 * Provides a way to add Jasmine-compatible matchers into your Jest context.
 * @param {!jasmine.CustomMatcherFactories} matchers
 * @return {?}
 */
jest.addMatchers = function(matchers) {};

/**
 * Disables automatic mocking in the module loader.
 * @return {?}
 */
jest.autoMockOff = function() {};

/**
 * Enables automatic mocking in the module loader.
 * @return {?}
 */
jest.autoMockOn = function() {};

/**
 * @deprecated use resetAllMocks instead
 * @return {?}
 */
jest.clearAllMocks = function() {};

/**
 * Clears the mock.calls and mock.instances properties of all mocks.
 * Equivalent to calling .mockClear() on every mocked function.
 * @return {?}
 */
jest.resetAllMocks = function() {};

/**
 * Removes any pending timers from the timer system. If any timers have
 * been scheduled, they will be cleared and will never have the opportunity
 * to execute in the future.
 * @return {?}
 */
jest.clearAllTimers = function() {};

/**
 * Indicates that the module system should never return a mocked version
 * of the specified module, including all of the specificied module's dependencies.
 * @param {string} moduleName
 * @return {?}
 */
jest.deepUnmock = function(moduleName) {};

/**
 * Disables automatic mocking in the module loader.
 * @return {?}
 */
jest.disableAutomock = function() {};

/**
 * Mocks a module with an auto-mocked version when it is being required.
 * @param {string} moduleName
 * @param {?=} factory
 * @param {!jest.MockOptions=} options
 * @return {?}
 */
jest.doMock = function(moduleName, factory, options) {};

/**
 * Indicates that the module system should never return a mocked version
 * of the specified module from require() (e.g. that it should always return the real module).
 * @param {string} moduleName
 * @return {?}
 */
jest.dontMock = function(moduleName) {};

/**
 * Enables automatic mocking in the module loader.
 * @return {?}
 */
jest.enableAutomock = function() {};

/**
 * Creates a mock function. Optionally takes a mock implementation.
 * @template T
 * @param {function(!Array<?>): T|function(!Array<?>): ?=} implementation
 * @return {!jest.Mock<T>}
 */
jest.fn = function(implementation) {};

/**
 * Use the automatic mocking system to generate a mocked version of the given module.
 * @template T
 * @param {string} moduleName
 * @return {T}
 */
jest.genMockFromModule = function(moduleName) {};

/**
 * Returns whether the given function is a mock function.
 * @param {?} fn
 * @return {boolean}
 */
jest.isMockFunction = function(fn) {};

/**
 * Mocks a module with an auto-mocked version when it is being required.
 * @param {string} moduleName
 * @param {?=} factory
 * @param {!jest.MockOptions=} options
 * @return {?}
 */
jest.mock = function(moduleName, factory, options) {};

/**
 * Resets the module registry - the cache of all required modules. This is
 * useful to isolate modules where local state might conflict between tests.
 * @return {?}
 */
jest.resetModuleRegistry = function() {};

/**
 * Resets the module registry - the cache of all required modules. This is
 * useful to isolate modules where local state might conflict between tests.
 * @return {?}
 */
jest.resetModules = function() {};

/**
 * Exhausts tasks queued by setImmediate().
 * @return {?}
 */
jest.runAllImmediates = function() {};

/**
 * Exhausts the micro-task queue (usually interfaced in node via process.nextTick).
 * @return {?}
 */
jest.runAllTicks = function() {};

/**
 * Exhausts the macro-task queue (i.e., all tasks queued by setTimeout() and setInterval()).
 * @return {?}
 */
jest.runAllTimers = function() {};

/**
 * Executes only the macro-tasks that are currently pending (i.e., only the
 * tasks that have been queued by setTimeout() or setInterval() up to this point).
 * If any of the currently pending macro-tasks schedule new macro-tasks,
 * those new tasks will not be executed by this call.
 * @return {?}
 */
jest.runOnlyPendingTimers = function() {};

/**
 * Executes only the macro task queue (i.e. all tasks queued by setTimeout()
 * or setInterval() and setImmediate()).
 * @param {number} msToRun
 * @return {?}
 */
jest.runTimersToTime = function(msToRun) {};

/**
 * Explicitly supplies the mock object that the module system should return
 * for the specified module.
 * @template T
 * @param {string} moduleName
 * @param {T} moduleExports
 * @return {?}
 */
jest.setMock = function(moduleName, moduleExports) {};

/**
 * Creates a mock function similar to jest.fn but also tracks calls to object[methodName]
 * @template T, M
 * @param {T} object
 * @param {M} method
 * @return {!jest.SpyInstance<?>}
 */
jest.spyOn = function(object, method) {};

/**
 * Indicates that the module system should never return a mocked version of
 * the specified module from require() (e.g. that it should always return the real module).
 * @param {string} moduleName
 * @return {?}
 */
jest.unmock = function(moduleName) {};

/**
 * Instructs Jest to use fake versions of the standard timer functions.
 * @return {?}
 */
jest.useFakeTimers = function() {};

/**
 * Instructs Jest to use the real versions of the standard timer functions.
 * @return {?}
 */
jest.useRealTimers = function() {};
/**
 * @record
 * @struct
 */
jest.MockOptions = function() {};
 /** @type {boolean} */
jest.MockOptions.prototype.virtual;

/** @typedef {function(): void} */
jest.EmptyFunction;
/**
 * @record
 * @struct
 */
jest.DoneCallback = function() {};

/* TODO: CallSignature: jest */

/**
 * @param {(string|{message: string})=} error
 * @return {?}
 */
jest.DoneCallback.prototype.fail = function(error) {};

/** @typedef {function(!jest.DoneCallback): ?} */
jest.ProvidesCallback;

/** @typedef {function(function(!jest.DoneCallback): ?, number): ?} */
jest.Lifecycle;
/**
 * @record
 * @struct
 */
jest.It = function() {};

/* TODO: CallSignature: jest */
 /** @type {!jest.It} */
jest.It.prototype.only;
 /** @type {!jest.It} */
jest.It.prototype.skip;
 /** @type {!jest.It} */
jest.It.prototype.concurrent;
/**
 * @record
 * @struct
 */
jest.Describe = function() {};

/* TODO: CallSignature: jest */
 /** @type {!jest.Describe} */
jest.Describe.prototype.only;
 /** @type {!jest.Describe} */
jest.Describe.prototype.skip;
/**
 * @record
 * @struct
 */
jest.MatcherUtils = function() {};
 /** @type {boolean} */
jest.MatcherUtils.prototype.isNot;
 /** @type {{EXPECTED_COLOR: string, RECEIVED_COLOR: string, ensureActualIsNumber: function(?, string): void, ensureExpectedIsNumber: function(?, string): void, ensureNoExpected: function(?, string): void, ensureNumbers: function(?, ?, string): void, getType: function(?): string, matcherHint: function(string, string, string, {secondArgument: string, isDirectExpectCall: boolean}): string, pluralize: function(string, number): string, printExpected: function(?): string, printReceived: function(?): string, printWithType: function(string, ?, function(?): string): string, stringify: function(!Object, number): string}} */
jest.MatcherUtils.prototype.utils;
/**
 * @record
 * @struct
 */
jest.ExpectExtendMap = function() {};

/* TODO: IndexSignature: jest */
/**
 * @record
 * @struct
 */
jest.SnapshotSerializerOptions = function() {};
 /** @type {boolean} */
jest.SnapshotSerializerOptions.prototype.callToJSON;
 /** @type {string} */
jest.SnapshotSerializerOptions.prototype.edgeSpacing;
 /** @type {string} */
jest.SnapshotSerializerOptions.prototype.spacing;
 /** @type {boolean} */
jest.SnapshotSerializerOptions.prototype.escapeRegex;
 /** @type {boolean} */
jest.SnapshotSerializerOptions.prototype.highlight;
 /** @type {number} */
jest.SnapshotSerializerOptions.prototype.indent;
 /** @type {number} */
jest.SnapshotSerializerOptions.prototype.maxDepth;
 /** @type {boolean} */
jest.SnapshotSerializerOptions.prototype.min;
 /** @type {!Array<!jest.SnapshotSerializerPlugin>} */
jest.SnapshotSerializerOptions.prototype.plugins;
 /** @type {boolean} */
jest.SnapshotSerializerOptions.prototype.printFunctionName;
 /** @type {!jest.SnapshotSerializerOptionsTheme} */
jest.SnapshotSerializerOptions.prototype.theme;
/**
 * @record
 * @struct
 */
jest.SnapshotSerializerOptionsTheme = function() {};
 /** @type {string} */
jest.SnapshotSerializerOptionsTheme.prototype.comment;
 /** @type {string} */
jest.SnapshotSerializerOptionsTheme.prototype.content;
 /** @type {string} */
jest.SnapshotSerializerOptionsTheme.prototype.prop;
 /** @type {string} */
jest.SnapshotSerializerOptionsTheme.prototype.tag;
 /** @type {string} */
jest.SnapshotSerializerOptionsTheme.prototype.value;
/**
 * @record
 * @struct
 */
jest.SnapshotSerializerColor = function() {};
 /** @type {string} */
jest.SnapshotSerializerColor.prototype.close;
 /** @type {string} */
jest.SnapshotSerializerColor.prototype.open;
/**
 * @record
 * @struct
 */
jest.SnapshotSerializerColors = function() {};
 /** @type {!jest.SnapshotSerializerColor} */
jest.SnapshotSerializerColors.prototype.comment;
 /** @type {!jest.SnapshotSerializerColor} */
jest.SnapshotSerializerColors.prototype.content;
 /** @type {!jest.SnapshotSerializerColor} */
jest.SnapshotSerializerColors.prototype.prop;
 /** @type {!jest.SnapshotSerializerColor} */
jest.SnapshotSerializerColors.prototype.tag;
 /** @type {!jest.SnapshotSerializerColor} */
jest.SnapshotSerializerColors.prototype.value;
/**
 * @record
 * @struct
 */
jest.SnapshotSerializerPlugin = function() {};

/**
 * @param {?} val
 * @param {function(?): string} serialize
 * @param {function(string): string} indent
 * @param {!jest.SnapshotSerializerOptions} opts
 * @param {!jest.SnapshotSerializerColors} colors
 * @return {string}
 */
jest.SnapshotSerializerPlugin.prototype.print = function(val, serialize, indent, opts, colors) {};

/**
 * @param {?} val
 * @return {boolean}
 */
jest.SnapshotSerializerPlugin.prototype.test = function(val) {};
/**
 * @record
 * @struct
 */
jest.Expect = function() {};

/* TODO: CallSignature: jest */

/**
 * @return {?}
 */
jest.Expect.prototype.anything = function() {};

/**
 * Matches anything that was created with the given constructor.
 * You can use it inside `toEqual` or `toBeCalledWith` instead of a literal value.
 * @param {?} classType
 * @return {?}
 */
jest.Expect.prototype.any = function(classType) {};

/**
 * Matches any array made up entirely of elements in the provided array.
 * You can use it inside `toEqual` or `toBeCalledWith` instead of a literal value.
 * @param {!Array<?>} arr
 * @return {?}
 */
jest.Expect.prototype.arrayContaining = function(arr) {};

/**
 * Verifies that a certain number of assertions are called during a test.
 * This is often useful when testing asynchronous code, in order to
 * make sure that assertions in a callback actually got called.
 * @param {number} num
 * @return {void}
 */
jest.Expect.prototype.assertions = function(num) {};

/**
 * Verifies that at least one assertion is called during a test.
 * This is often useful when testing asynchronous code, in order to
 * make sure that assertions in a callback actually got called.
 * @return {void}
 */
jest.Expect.prototype.hasAssertions = function() {};

/**
 * You can use `expect.extend` to add your own matchers to Jest.
 * @param {!jest.ExpectExtendMap} obj
 * @return {void}
 */
jest.Expect.prototype.extend = function(obj) {};

/**
 * Adds a module to format application-specific data structures for serialization.
 * @param {!jest.SnapshotSerializerPlugin} serializer
 * @return {void}
 */
jest.Expect.prototype.addSnapshotSerializer = function(serializer) {};

/**
 * Matches any object that recursively matches the provided keys.
 * This is often handy in conjunction with other asymmetric matchers.
 * @param {!Object} obj
 * @return {?}
 */
jest.Expect.prototype.objectContaining = function(obj) {};

/**
 * Matches any string that contains the exact provided string
 * @param {(string|!RegExp)} str
 * @return {?}
 */
jest.Expect.prototype.stringMatching = function(str) {};
/**
 * @record
 * @struct
 */
jest.Matchers = function() {};
 /** @type {!jest.Matchers} */
jest.Matchers.prototype.not;
 /** @type {!jest.Matchers<!Promise<R>>} */
jest.Matchers.prototype.resolves;
 /** @type {!jest.Matchers<!Promise<R>>} */
jest.Matchers.prototype.rejects;

/**
 * @param {...?} args
 * @return {R}
 */
jest.Matchers.prototype.lastCalledWith = function(args) {};

/**
 * Checks that a value is what you expect. It uses `===` to check strict equality.
 * Don't use `toBe` with floating-point numbers.
 * @param {?} expected
 * @return {R}
 */
jest.Matchers.prototype.toBe = function(expected) {};

/**
 * Ensures that a mock function is called.
 * @return {R}
 */
jest.Matchers.prototype.toBeCalled = function() {};

/**
 * Ensure that a mock function is called with specific arguments.
 * @param {...?} args
 * @return {R}
 */
jest.Matchers.prototype.toBeCalledWith = function(args) {};

/**
 * Using exact equality with floating point numbers is a bad idea.
 * Rounding means that intuitive things fail.
 * @param {number} expected
 * @param {number=} delta
 * @return {R}
 */
jest.Matchers.prototype.toBeCloseTo = function(expected, delta) {};

/**
 * Ensure that a variable is not undefined.
 * @return {R}
 */
jest.Matchers.prototype.toBeDefined = function() {};

/**
 * When you don't care what a value is, you just want to
 * ensure a value is false in a boolean context.
 * @return {R}
 */
jest.Matchers.prototype.toBeFalsy = function() {};

/**
 * For comparing floating point numbers.
 * @param {number} expected
 * @return {R}
 */
jest.Matchers.prototype.toBeGreaterThan = function(expected) {};

/**
 * For comparing floating point numbers.
 * @param {number} expected
 * @return {R}
 */
jest.Matchers.prototype.toBeGreaterThanOrEqual = function(expected) {};

/**
 * Ensure that an object is an instance of a class.
 * This matcher uses `instanceof` underneath.
 * @param {?} expected
 * @return {R}
 */
jest.Matchers.prototype.toBeInstanceOf = function(expected) {};

/**
 * For comparing floating point numbers.
 * @param {number} expected
 * @return {R}
 */
jest.Matchers.prototype.toBeLessThan = function(expected) {};

/**
 * For comparing floating point numbers.
 * @param {number} expected
 * @return {R}
 */
jest.Matchers.prototype.toBeLessThanOrEqual = function(expected) {};

/**
 * This is the same as `.toBe(null)` but the error messages are a bit nicer.
 * So use `.toBeNull()` when you want to check that something is null.
 * @return {R}
 */
jest.Matchers.prototype.toBeNull = function() {};

/**
 * Use when you don't care what a value is, you just want to ensure a value
 * is true in a boolean context. In JavaScript, there are six falsy values:
 * `false`, `0`, `''`, `null`, `undefined`, and `NaN`. Everything else is truthy.
 * @return {R}
 */
jest.Matchers.prototype.toBeTruthy = function() {};

/**
 * Used to check that a variable is undefined.
 * @return {R}
 */
jest.Matchers.prototype.toBeUndefined = function() {};

/**
 * Used to check that a variable is NaN.
 * @return {R}
 */
jest.Matchers.prototype.toBeNaN = function() {};

/**
 * Used when you want to check that an item is in a list.
 * For testing the items in the list, this uses `===`, a strict equality check.
 * @param {?} expected
 * @return {R}
 */
jest.Matchers.prototype.toContain = function(expected) {};

/**
 * Used when you want to check that an item is in a list.
 * For testing the items in the list, this  matcher recursively checks the
 * equality of all fields, rather than checking for object identity.
 * @param {?} expected
 * @return {R}
 */
jest.Matchers.prototype.toContainEqual = function(expected) {};

/**
 * Used when you want to check that two objects have the same value.
 * This matcher recursively checks the equality of all fields, rather than checking for object identity.
 * @param {?} expected
 * @return {R}
 */
jest.Matchers.prototype.toEqual = function(expected) {};

/**
 * Ensures that a mock function is called.
 * @return {R}
 */
jest.Matchers.prototype.toHaveBeenCalled = function() {};

/**
 * Ensures that a mock function is called an exact number of times.
 * @param {number} expected
 * @return {R}
 */
jest.Matchers.prototype.toHaveBeenCalledTimes = function(expected) {};

/**
 * Ensure that a mock function is called with specific arguments.
 * @param {...?} params
 * @return {R}
 */
jest.Matchers.prototype.toHaveBeenCalledWith = function(params) {};

/**
 * If you have a mock function, you can use `.toHaveBeenLastCalledWith`
 * to test what arguments it was last called with.
 * @param {...?} params
 * @return {R}
 */
jest.Matchers.prototype.toHaveBeenLastCalledWith = function(params) {};

/**
 * Used to check that an object has a `.length` property
 * and it is set to a certain numeric value.
 * @param {number} expected
 * @return {R}
 */
jest.Matchers.prototype.toHaveLength = function(expected) {};

/**
 * @param {string} propertyPath
 * @param {?=} value
 * @return {R}
 */
jest.Matchers.prototype.toHaveProperty = function(propertyPath, value) {};

/**
 * Check that a string matches a regular expression.
 * @param {(string|!RegExp)} expected
 * @return {R}
 */
jest.Matchers.prototype.toMatch = function(expected) {};

/**
 * Used to check that a JavaScript object matches a subset of the properties of an object
 * @param {(!Object|!Array<?>)} expected
 * @return {R}
 */
jest.Matchers.prototype.toMatchObject = function(expected) {};

/**
 * This ensures that a value matches the most recent snapshot.
 * Check out [the Snapshot Testing guide](http://facebook.github.io/jest/docs/snapshot-testing.html) for more information.
 * @param {string=} snapshotName
 * @return {R}
 */
jest.Matchers.prototype.toMatchSnapshot = function(snapshotName) {};

/**
 * Used to test that a function throws when it is called.
 * @param {(string|!RegExp|!jest.Constructable)=} error
 * @return {R}
 */
jest.Matchers.prototype.toThrow = function(error) {};

/**
 * If you want to test that a specific error is thrown inside a function.
 * @param {(string|!RegExp|!jest.Constructable)=} error
 * @return {R}
 */
jest.Matchers.prototype.toThrowError = function(error) {};

/**
 * Used to test that a function throws a error matching the most recent snapshot when it is called.
 * @return {R}
 */
jest.Matchers.prototype.toThrowErrorMatchingSnapshot = function() {};
/**
 * @record
 * @struct
 */
jest.Constructable = function() {};

/* TODO: ConstructSignature: jest */
/**
 * @extends {jest.MockInstance}
 * @record
 * @struct
 */
jest.Mock = function() {};

/* TODO: ConstructSignature: jest */

/* TODO: CallSignature: jest */
/**
 * @extends {jest.MockInstance}
 * @record
 * @struct
 */
jest.SpyInstance = function() {};

/**
 * @return {void}
 */
jest.SpyInstance.prototype.mockRestore = function() {};

/** @typedef {?} */
jest.Mocked;
/**
 * @record
 * @struct
 */
jest.MockInstance = function() {};
 /** @type {!jest.MockContext<T>} */
jest.MockInstance.prototype.mock;

/**
 * @return {void}
 */
jest.MockInstance.prototype.mockClear = function() {};

/**
 * @return {void}
 */
jest.MockInstance.prototype.mockReset = function() {};

/**
 * @param {function(!Array<?>): ?} fn
 * @return {!jest.Mock<T>}
 */
jest.MockInstance.prototype.mockImplementation = function(fn) {};

/**
 * @param {function(!Array<?>): ?} fn
 * @return {!jest.Mock<T>}
 */
jest.MockInstance.prototype.mockImplementationOnce = function(fn) {};

/**
 * @return {!jest.Mock<T>}
 */
jest.MockInstance.prototype.mockReturnThis = function() {};

/**
 * @param {?} value
 * @return {!jest.Mock<T>}
 */
jest.MockInstance.prototype.mockReturnValue = function(value) {};

/**
 * @param {?} value
 * @return {!jest.Mock<T>}
 */
jest.MockInstance.prototype.mockReturnValueOnce = function(value) {};
/**
 * @record
 * @struct
 */
jest.MockContext = function() {};
 /** @type {!Array<!Array<?>>} */
jest.MockContext.prototype.calls;
 /** @type {!Array<T>} */
jest.MockContext.prototype.instances;

/**
 * @param {?} object
 * @param {string} method
 * @return {!jasmine.Spy}
 */
function spyOn(object, method) {}

/**
 * If you call the function pending anywhere in the spec body,
 * no matter the expectations, the spec will be marked pending.
 * @param {string=} reason
 * @return {void}
 */
function pending(reason) {}

/**
 * Fails a test when called within one.
 * @param {?=} error
 * @return {void}
 */
function fail(error) {}
/** @const */
var jasmine = {};
 /** @type {number} */
jasmine.DEFAULT_TIMEOUT_INTERVAL;

/**
 * @return {!jasmine.Clock}
 */
jasmine.clock = function() {};

/**
 * @param {?} aclass
 * @return {!jasmine.Any}
 */
jasmine.any = function(aclass) {};

/**
 * @return {!jasmine.Any}
 */
jasmine.anything = function() {};

/**
 * @param {!Array<?>} sample
 * @return {!jasmine.ArrayContaining}
 */
jasmine.arrayContaining = function(sample) {};

/**
 * @param {?} sample
 * @return {!jasmine.ObjectContaining}
 */
jasmine.objectContaining = function(sample) {};

/**
 * @param {string} name
 * @param {function(!Array<?>): ?=} originalFn
 * @return {!jasmine.Spy}
 */
jasmine.createSpy = function(name, originalFn) {};

/**
 * @template T
 * @param {string} baseName
 * @param {!Array<?>} methodNames
 * @return {?|T}
 */
jasmine.createSpyObj = function(baseName, methodNames) {};

/**
 * @param {?} value
 * @return {string}
 */
jasmine.pp = function(value) {};

/**
 * @param {function(?, ?): boolean} equalityTester
 * @return {void}
 */
jasmine.addCustomEqualityTester = function(equalityTester) {};

/**
 * @param {!jasmine.CustomMatcherFactories} matchers
 * @return {void}
 */
jasmine.addMatchers = function(matchers) {};

/**
 * @param {(string|!RegExp)} value
 * @return {!jasmine.Any}
 */
jasmine.stringMatching = function(value) {};
/**
 * @record
 * @struct
 */
jasmine.Clock = function() {};

/**
 * @return {void}
 */
jasmine.Clock.prototype.install = function() {};

/**
 * @return {void}
 */
jasmine.Clock.prototype.uninstall = function() {};

/**
 * Calls to any registered callback are triggered when the clock isticked forward
 * via the jasmine.clock().tick function, which takes a number of milliseconds.
 * @param {number} ms
 * @return {void}
 */
jasmine.Clock.prototype.tick = function(ms) {};

/**
 * @param {!Date=} date
 * @return {void}
 */
jasmine.Clock.prototype.mockDate = function(date) {};
/**
 * @record
 * @struct
 */
jasmine.Any = function() {};

/* TODO: ConstructSignature: jasmine */

/**
 * @param {?} other
 * @return {boolean}
 */
jasmine.Any.prototype.jasmineMatches = function(other) {};

/**
 * @return {string}
 */
jasmine.Any.prototype.jasmineToString = function() {};
/**
 * @record
 * @struct
 */
jasmine.ArrayContaining = function() {};

/* TODO: ConstructSignature: jasmine */

/**
 * @param {?} other
 * @return {boolean}
 */
jasmine.ArrayContaining.prototype.asymmetricMatch = function(other) {};

/**
 * @return {string}
 */
jasmine.ArrayContaining.prototype.jasmineToString = function() {};
/**
 * @record
 * @struct
 */
jasmine.ObjectContaining = function() {};

/* TODO: ConstructSignature: jasmine */

/**
 * @param {?} other
 * @param {!Array<?>} mismatchKeys
 * @param {!Array<?>} mismatchValues
 * @return {boolean}
 */
jasmine.ObjectContaining.prototype.jasmineMatches = function(other, mismatchKeys, mismatchValues) {};

/**
 * @return {string}
 */
jasmine.ObjectContaining.prototype.jasmineToString = function() {};
/**
 * @record
 * @struct
 */
jasmine.Spy = function() {};

/* TODO: CallSignature: jasmine */
 /** @type {string} */
jasmine.Spy.prototype.identity;
 /** @type {!jasmine.SpyAnd} */
jasmine.Spy.prototype.and;
 /** @type {!jasmine.Calls} */
jasmine.Spy.prototype.calls;
 /** @type {{args: !Array<?>}} */
jasmine.Spy.prototype.mostRecentCall;
 /** @type {!Array<?>} */
jasmine.Spy.prototype.argsForCall;
 /** @type {boolean} */
jasmine.Spy.prototype.wasCalled;
/**
 * @record
 * @struct
 */
jasmine.SpyAnd = function() {};

/**
 * By chaining the spy with and.callThrough, the spy will still track all
 * calls to it but in addition it will delegate to the actual implementation.
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.callThrough = function() {};

/**
 * By chaining the spy with and.returnValue, all calls to the function
 * will return a specific value.
 * @param {?} val
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.returnValue = function(val) {};

/**
 * By chaining the spy with and.returnValues, all calls to the function
 * will return specific values in order until it reaches the end of the return values list.
 * @param {...?} values
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.returnValues = function(values) {};

/**
 * By chaining the spy with and.callFake, all calls to the spy
 * will delegate to the supplied function.
 * @param {function(!Array<?>): ?} fn
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.callFake = function(fn) {};

/**
 * By chaining the spy with and.throwError, all calls to the spy
 * will throw the specified value.
 * @param {string} msg
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.throwError = function(msg) {};

/**
 * When a calling strategy is used for a spy, the original stubbing
 * behavior can be returned at any time with and.stub.
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.stub = function() {};
/**
 * @record
 * @struct
 */
jasmine.Calls = function() {};

/**
 * By chaining the spy with calls.any(),
 * will return false if the spy has not been called at all,
 * and then true once at least one call happens.
 * @return {boolean}
 */
jasmine.Calls.prototype.any = function() {};

/**
 * By chaining the spy with calls.count(),
 * will return the number of times the spy was called
 * @return {number}
 */
jasmine.Calls.prototype.count = function() {};

/**
 * By chaining the spy with calls.argsFor(),
 * will return the arguments passed to call number index
 * @param {number} index
 * @return {!Array<?>}
 */
jasmine.Calls.prototype.argsFor = function(index) {};

/**
 * By chaining the spy with calls.allArgs(),
 * will return the arguments to all calls
 * @return {!Array<?>}
 */
jasmine.Calls.prototype.allArgs = function() {};

/**
 * By chaining the spy with calls.all(), will return the
 * context (the this) and arguments passed all calls
 * @return {!Array<!jasmine.CallInfo>}
 */
jasmine.Calls.prototype.all = function() {};

/**
 * By chaining the spy with calls.mostRecent(), will return the
 * context (the this) and arguments for the most recent call
 * @return {!jasmine.CallInfo}
 */
jasmine.Calls.prototype.mostRecent = function() {};

/**
 * By chaining the spy with calls.first(), will return the
 * context (the this) and arguments for the first call
 * @return {!jasmine.CallInfo}
 */
jasmine.Calls.prototype.first = function() {};

/**
 * By chaining the spy with calls.reset(), will clears all tracking for a spy
 * @return {void}
 */
jasmine.Calls.prototype.reset = function() {};
/**
 * @record
 * @struct
 */
jasmine.CallInfo = function() {};
 /** @type {?} */
jasmine.CallInfo.prototype.object;
 /** @type {!Array<?>} */
jasmine.CallInfo.prototype.args;
 /** @type {?} */
jasmine.CallInfo.prototype.returnValue;
/**
 * @record
 * @struct
 */
jasmine.CustomMatcherFactories = function() {};

/* TODO: IndexSignature: jasmine */

/** @typedef {function(!jasmine.MatchersUtil, !Array<function(?, ?): boolean>): !jasmine.CustomMatcher} */
jasmine.CustomMatcherFactory;
/**
 * @record
 * @struct
 */
jasmine.MatchersUtil = function() {};

/**
 * @param {?} a
 * @param {?} b
 * @param {!Array<function(?, ?): boolean>=} customTesters
 * @return {boolean}
 */
jasmine.MatchersUtil.prototype.equals = function(a, b, customTesters) {};

/**
 * @template T
 * @param {(string|!jasmine.ArrayLike<T>)} haystack
 * @param {?} needle
 * @param {!Array<function(?, ?): boolean>=} customTesters
 * @return {boolean}
 */
jasmine.MatchersUtil.prototype.contains = function(haystack, needle, customTesters) {};

/**
 * @param {string} matcherName
 * @param {boolean} isNot
 * @param {?} actual
 * @param {...?} expected
 * @return {string}
 */
jasmine.MatchersUtil.prototype.buildFailureMessage = function(matcherName, isNot, actual, expected) {};

/** @typedef {function(?, ?): boolean} */
jasmine.CustomEqualityTester;
/**
 * @record
 * @struct
 */
jasmine.CustomMatcher = function() {};

/**
 * @template T
 * @param {T|?} actual
 * @param {T|?} expected
 * @return {!jasmine.CustomMatcherResult}
 */
jasmine.CustomMatcher.prototype.compare = function(actual, expected) {};
/**
 * @record
 * @struct
 */
jasmine.CustomMatcherResult = function() {};
 /** @type {boolean} */
jasmine.CustomMatcherResult.prototype.pass;
 /** @type {(string|function(): string)} */
jasmine.CustomMatcherResult.prototype.message;
/**
 * @record
 * @struct
 */
jasmine.ArrayLike = function() {};
 /** @type {number} */
jasmine.ArrayLike.prototype.length;

/* TODO: IndexSignature: jasmine */

/** @typedef {(void|T)} */
jest.Maybe;

/** @typedef {function(!jest.AggregatedResult): !jest.AggregatedResult} */
jest.TestResultsProcessor;

/** @typedef {?} */
jest.HasteResolver;

/** @typedef {?} */
jest.ModuleMocker;

/** @typedef {?} */
jest.ModuleMap;

/** @typedef {?} */
jest.HasteFS;

/** @typedef {?} */
jest.Runtime;

/** @typedef {?} */
jest.Script;

/** @typedef {string} */
jest.Path;

/** @typedef {string} */
jest.Glob;
/**
 * @record
 * @struct
 */
jest.HasteConfig = function() {};
 /** @type {(string|void)} */
jest.HasteConfig.prototype.defaultPlatform;
 /** @type {string} */
jest.HasteConfig.prototype.hasteImplModulePath;
 /** @type {!Array<string>} */
jest.HasteConfig.prototype.platforms;
 /** @type {!Array<string>} */
jest.HasteConfig.prototype.providesModuleNodeModules;

/** @typedef {!Array<?>} */
jest.ReporterConfig;

/** @typedef {!Object} */
jest.ConfigGlobals;

/** @typedef {string} */
jest.SnapshotUpdateState;
/**
 * @record
 * @struct
 */
jest.GlobalConfig = function() {};
 /** @type {boolean} */
jest.GlobalConfig.prototype.bail;
 /** @type {boolean} */
jest.GlobalConfig.prototype.collectCoverage;
 /** @type {!Array<string>} */
jest.GlobalConfig.prototype.collectCoverageFrom;
 /** @type {(void|!Object<string,boolean>)} */
jest.GlobalConfig.prototype.collectCoverageOnlyFrom;
 /** @type {string} */
jest.GlobalConfig.prototype.coverageDirectory;
 /** @type {!Array<string>} */
jest.GlobalConfig.prototype.coverageReporters;
 /** @type {{global: !Object<string,number>}} */
jest.GlobalConfig.prototype.coverageThreshold;
 /** @type {boolean} */
jest.GlobalConfig.prototype.expand;
 /** @type {boolean} */
jest.GlobalConfig.prototype.forceExit;
 /** @type {boolean} */
jest.GlobalConfig.prototype.logHeapUsage;
 /** @type {boolean} */
jest.GlobalConfig.prototype.mapCoverage;
 /** @type {boolean} */
jest.GlobalConfig.prototype.noStackTrace;
 /** @type {boolean} */
jest.GlobalConfig.prototype.notify;
 /** @type {!Array<string>} */
jest.GlobalConfig.prototype.projects;
 /** @type {(string|void)} */
jest.GlobalConfig.prototype.replname;
 /** @type {!Array<!Array<?>>} */
jest.GlobalConfig.prototype.reporters;
 /** @type {string} */
jest.GlobalConfig.prototype.rootDir;
 /** @type {boolean} */
jest.GlobalConfig.prototype.silent;
 /** @type {string} */
jest.GlobalConfig.prototype.testNamePattern;
 /** @type {string} */
jest.GlobalConfig.prototype.testPathPattern;
 /** @type {(string|void)} */
jest.GlobalConfig.prototype.testResultsProcessor;
 /** @type {string} */
jest.GlobalConfig.prototype.updateSnapshot;
 /** @type {boolean} */
jest.GlobalConfig.prototype.useStderr;
 /** @type {(boolean|void)} */
jest.GlobalConfig.prototype.verbose;
 /** @type {boolean} */
jest.GlobalConfig.prototype.watch;
 /** @type {boolean} */
jest.GlobalConfig.prototype.watchman;
/**
 * @record
 * @struct
 */
jest.ProjectConfig = function() {};
 /** @type {boolean} */
jest.ProjectConfig.prototype.automock;
 /** @type {boolean} */
jest.ProjectConfig.prototype.browser;
 /** @type {boolean} */
jest.ProjectConfig.prototype.cache;
 /** @type {string} */
jest.ProjectConfig.prototype.cacheDirectory;
 /** @type {boolean} */
jest.ProjectConfig.prototype.clearMocks;
 /** @type {!Array<string>} */
jest.ProjectConfig.prototype.coveragePathIgnorePatterns;
 /** @type {!Object} */
jest.ProjectConfig.prototype.globals;
 /** @type {!jest.HasteConfig} */
jest.ProjectConfig.prototype.haste;
 /** @type {!Array<string>} */
jest.ProjectConfig.prototype.moduleDirectories;
 /** @type {!Array<string>} */
jest.ProjectConfig.prototype.moduleFileExtensions;
 /** @type {string} */
jest.ProjectConfig.prototype.moduleLoader;
 /** @type {!Array<!Array<?>>} */
jest.ProjectConfig.prototype.moduleNameMapper;
 /** @type {!Array<string>} */
jest.ProjectConfig.prototype.modulePathIgnorePatterns;
 /** @type {!Array<string>} */
jest.ProjectConfig.prototype.modulePaths;
 /** @type {string} */
jest.ProjectConfig.prototype.name;
 /** @type {boolean} */
jest.ProjectConfig.prototype.resetMocks;
 /** @type {boolean} */
jest.ProjectConfig.prototype.resetModules;
 /** @type {(string|void)} */
jest.ProjectConfig.prototype.resolver;
 /** @type {string} */
jest.ProjectConfig.prototype.rootDir;
 /** @type {!Array<string>} */
jest.ProjectConfig.prototype.roots;
 /** @type {!Array<string>} */
jest.ProjectConfig.prototype.setupFiles;
 /** @type {string} */
jest.ProjectConfig.prototype.setupTestFrameworkScriptFile;
 /** @type {boolean} */
jest.ProjectConfig.prototype.skipNodeResolution;
 /** @type {!Array<string>} */
jest.ProjectConfig.prototype.snapshotSerializers;
 /** @type {string} */
jest.ProjectConfig.prototype.testEnvironment;
 /** @type {!Array<string>} */
jest.ProjectConfig.prototype.testMatch;
 /** @type {!Array<string>} */
jest.ProjectConfig.prototype.testPathIgnorePatterns;
 /** @type {string} */
jest.ProjectConfig.prototype.testRegex;
 /** @type {string} */
jest.ProjectConfig.prototype.testRunner;
 /** @type {string} */
jest.ProjectConfig.prototype.testURL;
 /** @type {string} */
jest.ProjectConfig.prototype.timers;
 /** @type {!Array<!Array<?>>} */
jest.ProjectConfig.prototype.transform;
 /** @type {!Array<string>} */
jest.ProjectConfig.prototype.transformIgnorePatterns;
 /** @type {(void|!Array<string>)} */
jest.ProjectConfig.prototype.unmockedModulePathPatterns;

/** @typedef {string} */
jest.LogMessage;
/**
 * @record
 * @struct
 */
jest.LogEntry = function() {};
 /** @type {string} */
jest.LogEntry.prototype.message;
 /** @type {string} */
jest.LogEntry.prototype.origin;
 /** @type {string} */
jest.LogEntry.prototype.type;

/** @typedef {string} */
jest.LogType;

/** @typedef {!Array<!jest.LogEntry>} */
jest.ConsoleBuffer;
/**
 * @record
 * @struct
 */
jest.Context = function() {};
 /** @type {!jest.ProjectConfig} */
jest.Context.prototype.config;
 /** @type {?} */
jest.Context.prototype.hasteFS;
 /** @type {?} */
jest.Context.prototype.moduleMap;
 /** @type {?} */
jest.Context.prototype.resolver;
/**
 * @record
 * @struct
 */
jest.FakeTimers = function() {};

/**
 * @return {void}
 */
jest.FakeTimers.prototype.clearAllTimers = function() {};

/**
 * @return {void}
 */
jest.FakeTimers.prototype.runAllImmediates = function() {};

/**
 * @return {void}
 */
jest.FakeTimers.prototype.runAllTicks = function() {};

/**
 * @return {void}
 */
jest.FakeTimers.prototype.runAllTimers = function() {};

/**
 * @param {number} msToRun
 * @return {void}
 */
jest.FakeTimers.prototype.runTimersToTime = function(msToRun) {};

/**
 * @return {void}
 */
jest.FakeTimers.prototype.runOnlyPendingTimers = function() {};

/**
 * @param {?} callback
 * @return {void}
 */
jest.FakeTimers.prototype.runWithRealTimers = function(callback) {};

/**
 * @return {void}
 */
jest.FakeTimers.prototype.useFakeTimers = function() {};

/**
 * @return {void}
 */
jest.FakeTimers.prototype.useRealTimers = function() {};
/**
 * @record
 * @struct
 */
jest.$JestEnvironment = function() {};
 /** @type {!Object} */
jest.$JestEnvironment.prototype.global;
 /** @type {!jest.FakeTimers} */
jest.$JestEnvironment.prototype.fakeTimers;
 /** @type {string} */
jest.$JestEnvironment.prototype.testFilePath;
 /** @type {?} */
jest.$JestEnvironment.prototype.moduleMocker;

/**
 * @return {void}
 */
jest.$JestEnvironment.prototype.dispose = function() {};

/**
 * @param {?} script
 * @return {?}
 */
jest.$JestEnvironment.prototype.runScript = function(script) {};

/** @typedef {!jest.$JestEnvironment} */
jest.Environment;

/** @typedef {!Object} */
jest.Global;
/**
 * @record
 * @struct
 */
jest.ReporterOnStartOptions = function() {};
 /** @type {number} */
jest.ReporterOnStartOptions.prototype.estimatedTime;
 /** @type {boolean} */
jest.ReporterOnStartOptions.prototype.showStatus;
/**
 * @record
 * @struct
 */
jest.RawFileCoverage = function() {};
 /** @type {string} */
jest.RawFileCoverage.prototype.path;
 /** @type {!Object<number,number>} */
jest.RawFileCoverage.prototype.s;
 /** @type {!Object<number,number>} */
jest.RawFileCoverage.prototype.b;
 /** @type {!Object<number,number>} */
jest.RawFileCoverage.prototype.f;
 /** @type {!Object<number,number>} */
jest.RawFileCoverage.prototype.l;
 /** @type {!Object<number,?>} */
jest.RawFileCoverage.prototype.fnMap;
 /** @type {!Object<number,?>} */
jest.RawFileCoverage.prototype.statementMap;
 /** @type {!Object<number,?>} */
jest.RawFileCoverage.prototype.branchMap;
 /** @type {!Object} */
jest.RawFileCoverage.prototype.inputSourceMap;
/**
 * @record
 * @struct
 */
jest.RawCoverage = function() {};

/* TODO: IndexSignature: jest */
/**
 * @record
 * @struct
 */
jest.FileCoverageTotal = function() {};
 /** @type {number} */
jest.FileCoverageTotal.prototype.total;
 /** @type {number} */
jest.FileCoverageTotal.prototype.covered;
 /** @type {number} */
jest.FileCoverageTotal.prototype.skipped;
 /** @type {number} */
jest.FileCoverageTotal.prototype.pct;
/**
 * @record
 * @struct
 */
jest.CoverageSummary = function() {};
 /** @type {!jest.FileCoverageTotal} */
jest.CoverageSummary.prototype.lines;
 /** @type {!jest.FileCoverageTotal} */
jest.CoverageSummary.prototype.statements;
 /** @type {!jest.FileCoverageTotal} */
jest.CoverageSummary.prototype.branches;
 /** @type {!jest.FileCoverageTotal} */
jest.CoverageSummary.prototype.functions;
/**
 * @record
 * @struct
 */
jest.FileCoverage = function() {};

/**
 * @return {!Object}
 */
jest.FileCoverage.prototype.getLineCoverage = function() {};

/**
 * @return {!Array<number>}
 */
jest.FileCoverage.prototype.getUncoveredLines = function() {};

/**
 * @return {!Object}
 */
jest.FileCoverage.prototype.getBranchCoverageByLine = function() {};

/**
 * @return {!Object}
 */
jest.FileCoverage.prototype.toJSON = function() {};

/**
 * @param {!Object} other
 * @return {void}
 */
jest.FileCoverage.prototype.merge = function(other) {};

/**
 * @param {string} property
 * @return {!jest.FileCoverageTotal}
 */
jest.FileCoverage.prototype.computeSimpleTotals = function(property) {};

/**
 * @return {!jest.FileCoverageTotal}
 */
jest.FileCoverage.prototype.computeBranchTotals = function() {};

/**
 * @return {void}
 */
jest.FileCoverage.prototype.resetHits = function() {};

/**
 * @return {!jest.CoverageSummary}
 */
jest.FileCoverage.prototype.toSummary = function() {};
/**
 * @record
 * @struct
 */
jest.CoverageMap = function() {};
 /** @type {!jest.RawCoverage} */
jest.CoverageMap.prototype.data;

/**
 * @param {!Object} data
 * @return {void}
 */
jest.CoverageMap.prototype.merge = function(data) {};

/**
 * @return {!jest.FileCoverage}
 */
jest.CoverageMap.prototype.getCoverageSummary = function() {};

/**
 * @param {!jest.RawFileCoverage} fileCoverage
 * @return {void}
 */
jest.CoverageMap.prototype.addFileCoverage = function(fileCoverage) {};

/**
 * @return {!Array<string>}
 */
jest.CoverageMap.prototype.files = function() {};

/**
 * @param {string} file
 * @return {!jest.FileCoverage}
 */
jest.CoverageMap.prototype.fileCoverageFor = function(file) {};
/**
 * @record
 * @struct
 */
jest.SerializableError = function() {};
 /** @type {?} */
jest.SerializableError.prototype.code;
 /** @type {string} */
jest.SerializableError.prototype.message;
 /** @type {(string|void)} */
jest.SerializableError.prototype.stack;
 /** @type {string} */
jest.SerializableError.prototype.type;

/** @typedef {string} */
jest.Status;

/** @typedef {number} */
jest.Bytes;

/** @typedef {number} */
jest.Milliseconds;
/**
 * @record
 * @struct
 */
jest.AssertionResult = function() {};
 /** @type {!Array<string>} */
jest.AssertionResult.prototype.ancestorTitles;
 /** @type {(number|void)} */
jest.AssertionResult.prototype.duration;
 /** @type {!Array<string>} */
jest.AssertionResult.prototype.failureMessages;
 /** @type {string} */
jest.AssertionResult.prototype.fullName;
 /** @type {number} */
jest.AssertionResult.prototype.numPassingAsserts;
 /** @type {string} */
jest.AssertionResult.prototype.status;
 /** @type {string} */
jest.AssertionResult.prototype.title;
/**
 * @record
 * @struct
 */
jest.AggregatedResult = function() {};
 /** @type {(void|!jest.CoverageMap)} */
jest.AggregatedResult.prototype.coverageMap;
 /** @type {number} */
jest.AggregatedResult.prototype.numFailedTests;
 /** @type {number} */
jest.AggregatedResult.prototype.numFailedTestSuites;
 /** @type {number} */
jest.AggregatedResult.prototype.numPassedTests;
 /** @type {number} */
jest.AggregatedResult.prototype.numPassedTestSuites;
 /** @type {number} */
jest.AggregatedResult.prototype.numPendingTests;
 /** @type {number} */
jest.AggregatedResult.prototype.numPendingTestSuites;
 /** @type {number} */
jest.AggregatedResult.prototype.numRuntimeErrorTestSuites;
 /** @type {number} */
jest.AggregatedResult.prototype.numTotalTests;
 /** @type {number} */
jest.AggregatedResult.prototype.numTotalTestSuites;
 /** @type {!jest.SnapshotSummary} */
jest.AggregatedResult.prototype.snapshot;
 /** @type {number} */
jest.AggregatedResult.prototype.startTime;
 /** @type {boolean} */
jest.AggregatedResult.prototype.success;
 /** @type {!Array<!jest.TestResult>} */
jest.AggregatedResult.prototype.testResults;
 /** @type {boolean} */
jest.AggregatedResult.prototype.wasInterrupted;
/**
 * @record
 * @struct
 */
jest.TestResult = function() {};
 /** @type {(void|!Array<!jest.LogEntry>)} */
jest.TestResult.prototype.console;
 /** @type {!jest.RawCoverage} */
jest.TestResult.prototype.coverage;
 /** @type {number} */
jest.TestResult.prototype.memoryUsage;
 /** @type {(string|void)} */
jest.TestResult.prototype.failureMessage;
 /** @type {number} */
jest.TestResult.prototype.numFailingTests;
 /** @type {number} */
jest.TestResult.prototype.numPassingTests;
 /** @type {number} */
jest.TestResult.prototype.numPendingTests;
 /** @type {{end: number, start: number}} */
jest.TestResult.prototype.perfStats;
 /** @type {boolean} */
jest.TestResult.prototype.skipped;
 /** @type {{added: number, fileDeleted: boolean, matched: number, unchecked: number, unmatched: number, updated: number}} */
jest.TestResult.prototype.snapshot;
 /** @type {!Object<string,string>} */
jest.TestResult.prototype.sourceMaps;
 /** @type {!jest.SerializableError} */
jest.TestResult.prototype.testExecError;
 /** @type {string} */
jest.TestResult.prototype.testFilePath;
 /** @type {!Array<!jest.AssertionResult>} */
jest.TestResult.prototype.testResults;
/**
 * @record
 * @struct
 */
jest.SnapshotSummary = function() {};
 /** @type {number} */
jest.SnapshotSummary.prototype.added;
 /** @type {boolean} */
jest.SnapshotSummary.prototype.didUpdate;
 /** @type {boolean} */
jest.SnapshotSummary.prototype.failure;
 /** @type {number} */
jest.SnapshotSummary.prototype.filesAdded;
 /** @type {number} */
jest.SnapshotSummary.prototype.filesRemoved;
 /** @type {number} */
jest.SnapshotSummary.prototype.filesUnmatched;
 /** @type {number} */
jest.SnapshotSummary.prototype.filesUpdated;
 /** @type {number} */
jest.SnapshotSummary.prototype.matched;
 /** @type {number} */
jest.SnapshotSummary.prototype.total;
 /** @type {number} */
jest.SnapshotSummary.prototype.unchecked;
 /** @type {number} */
jest.SnapshotSummary.prototype.unmatched;
 /** @type {number} */
jest.SnapshotSummary.prototype.updated;
/**
 * @record
 * @struct
 */
jest.Test = function() {};
 /** @type {!jest.Context} */
jest.Test.prototype.context;
 /** @type {number} */
jest.Test.prototype.duration;
 /** @type {string} */
jest.Test.prototype.path;
/**
 * @record
 * @struct
 */
jest.Reporter = function() {};

/**
 * @param {!jest.Test} test
 * @param {!jest.TestResult} testResult
 * @param {!jest.AggregatedResult} aggregatedResult
 * @return {void}
 */
jest.Reporter.prototype.onTestResult = function(test, testResult, aggregatedResult) {};

/**
 * @param {!jest.AggregatedResult} results
 * @param {!jest.ReporterOnStartOptions} options
 * @return {void}
 */
jest.Reporter.prototype.onRunStart = function(results, options) {};

/**
 * @param {!jest.Test} test
 * @return {void}
 */
jest.Reporter.prototype.onTestStart = function(test) {};

/**
 * @param {!Set<!jest.Context>} contexts
 * @param {!jest.AggregatedResult} results
 * @return {(void|!Promise<void>)}
 */
jest.Reporter.prototype.onRunComplete = function(contexts, results) {};

/**
 * @return {(void|!Error)}
 */
jest.Reporter.prototype.getLastError = function() {};

/** @typedef {function(!jest.GlobalConfig, !jest.ProjectConfig, !jest.$JestEnvironment, ?, string): !Promise<!jest.TestResult>} */
jest.TestFramework;
/**
 * @record
 * @struct
 */
jest.TransformedSource = function() {};
 /** @type {string} */
jest.TransformedSource.prototype.code;
 /** @type {(string|void|!Object)} */
jest.TransformedSource.prototype.map;
/**
 * @record
 * @struct
 */
jest.TransformOptions = function() {};
 /** @type {boolean} */
jest.TransformOptions.prototype.instrument;
/**
 * @record
 * @struct
 */
jest.Transformer = function() {};
 /** @type {boolean} */
jest.Transformer.prototype.canInstrument;

/**
 * @param {?} options
 * @return {!jest.Transformer}
 */
jest.Transformer.prototype.createTransformer = function(options) {};

/**
 * @param {string} fileData
 * @param {string} filePath
 * @param {string} configStr
 * @param {!jest.TransformOptions} options
 * @return {string}
 */
jest.Transformer.prototype.getCacheKey = function(fileData, filePath, configStr, options) {};

/**
 * @param {string} sourceText
 * @param {string} sourcePath
 * @param {!jest.ProjectConfig} config
 * @param {!jest.TransformOptions=} options
 * @return {(string|!jest.TransformedSource)}
 */
jest.Transformer.prototype.process = function(sourceText, sourcePath, config, options) {};
