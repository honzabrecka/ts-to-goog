/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/bingmaps/index.d.ts:
/** @const */
var Microsoft = {};
/** @const */
Microsoft.Maps = {};
/**
 * @record
 * @struct
 */
Microsoft.Maps.IMapElementStyle = function() {};
 /** @type {string} */
Microsoft.Maps.IMapElementStyle.prototype.fillColor;
 /** @type {string} */
Microsoft.Maps.IMapElementStyle.prototype.labelColor;
 /** @type {string} */
Microsoft.Maps.IMapElementStyle.prototype.labelOutlineColor;
 /** @type {boolean} */
Microsoft.Maps.IMapElementStyle.prototype.labelVisible;
 /** @type {string} */
Microsoft.Maps.IMapElementStyle.prototype.strokeColor;
 /** @type {boolean} */
Microsoft.Maps.IMapElementStyle.prototype.visible;
/**
 * @extends {Microsoft.Maps.IMapElementStyle}
 * @record
 * @struct
 */
Microsoft.Maps.IBorderedMapElementStyle = function() {};
 /** @type {string} */
Microsoft.Maps.IBorderedMapElementStyle.prototype.borderOutlineColor;
 /** @type {string} */
Microsoft.Maps.IBorderedMapElementStyle.prototype.borderStrokeColor;
 /** @type {boolean} */
Microsoft.Maps.IBorderedMapElementStyle.prototype.borderVisible;
/**
 * @record
 * @struct
 */
Microsoft.Maps.ISettingsStyle = function() {};
 /** @type {string} */
Microsoft.Maps.ISettingsStyle.prototype.landColor;
 /** @type {boolean} */
Microsoft.Maps.ISettingsStyle.prototype.shadedReliefVisible;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IMapElements = function() {};
 /** @type {!Microsoft.Maps.IBorderedMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.adminDistrict;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.adminDistrictCapital;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.airport;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.area;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.arterialRoad;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.building;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.business;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.capital;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.cemetery;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.continent;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.controlledAccessHighway;
 /** @type {!Microsoft.Maps.IBorderedMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.countryRegion;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.countryRegionCapital;
 /** @type {!Microsoft.Maps.IBorderedMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.district;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.education;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.educationBuilding;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.foodPoint;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.forest;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.golfCourse;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.highSpeedRamp;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.highway;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.indigenousPeoplesReserve;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.island;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.majorRoad;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.mapElement;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.medical;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.medicalBuilding;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.military;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.naturalPoint;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.nautical;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.neighborhood;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.park;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.peak;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.point;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.pointOfInterest;
 /** @type {!Microsoft.Maps.IBorderedMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.political;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.populatedPlace;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.railway;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.ramp;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.reserve;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.river;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.road;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.roadExit;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.runway;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.sand;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.shoppingCenter;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.stadium;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.street;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.structure;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.tollRoad;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.trail;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.transit;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.transitBuilding;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.transportation;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.unpavedStreet;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.vegetation;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.volcanicPeak;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.water;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.waterPoint;
 /** @type {!Microsoft.Maps.IMapElementStyle} */
Microsoft.Maps.IMapElements.prototype.waterRoute;
/**
 * @record
 * @struct
 */
Microsoft.Maps.ICustomMapStyle = function() {};
 /** @type {!Microsoft.Maps.IMapElements} */
Microsoft.Maps.ICustomMapStyle.prototype.elements;
 /** @type {!Microsoft.Maps.ISettingsStyle} */
Microsoft.Maps.ICustomMapStyle.prototype.settings;
 /** @type {string} */
Microsoft.Maps.ICustomMapStyle.prototype.version;

/** @const */
Microsoft.Maps.LabelOverlay = {};
/** @const {number} */
Microsoft.Maps.LabelOverlay.hidden;
/** @const {number} */
Microsoft.Maps.LabelOverlay.visible;

/** @const */
Microsoft.Maps.MapTypeId = {};
/** @const {number} */
Microsoft.Maps.MapTypeId.aerial;
/** @const {number} */
Microsoft.Maps.MapTypeId.birdseye;
/** @const {number} */
Microsoft.Maps.MapTypeId.canvasDark;
/** @const {number} */
Microsoft.Maps.MapTypeId.canvasLight;
/** @const {number} */
Microsoft.Maps.MapTypeId.grayscale;
/** @const {number} */
Microsoft.Maps.MapTypeId.mercator;
/** @const {number} */
Microsoft.Maps.MapTypeId.ordnanceSurvey;
/** @const {number} */
Microsoft.Maps.MapTypeId.road;
/** @const {number} */
Microsoft.Maps.MapTypeId.streetside;

/** @const */
Microsoft.Maps.NavigationBarMode = {};
/** @const {number} */
Microsoft.Maps.NavigationBarMode.compact;
/** @const {number} */
Microsoft.Maps.NavigationBarMode.default;
/** @const {number} */
Microsoft.Maps.NavigationBarMode.minified;

/** @const */
Microsoft.Maps.NavigationBarOrientation = {};
/** @const {number} */
Microsoft.Maps.NavigationBarOrientation.horizontal;
/** @const {number} */
Microsoft.Maps.NavigationBarOrientation.vertical;

/** @const */
Microsoft.Maps.OverviewMapMode = {};
/** @const {number} */
Microsoft.Maps.OverviewMapMode.expanded;
/** @const {number} */
Microsoft.Maps.OverviewMapMode.hidden;
/** @const {number} */
Microsoft.Maps.OverviewMapMode.minimized;

/** @const */
Microsoft.Maps.PixelReference = {};
/** @const {number} */
Microsoft.Maps.PixelReference.control;
/** @const {number} */
Microsoft.Maps.PixelReference.page;
/** @const {number} */
Microsoft.Maps.PixelReference.viewport;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IAddress = function() {};
 /** @type {string} */
Microsoft.Maps.IAddress.prototype.addressLine;
 /** @type {string} */
Microsoft.Maps.IAddress.prototype.adminDistrict;
 /** @type {string} */
Microsoft.Maps.IAddress.prototype.countryRegion;
 /** @type {string} */
Microsoft.Maps.IAddress.prototype.countryRegionISO2;
 /** @type {string} */
Microsoft.Maps.IAddress.prototype.district;
 /** @type {string} */
Microsoft.Maps.IAddress.prototype.formattedAddress;
 /** @type {string} */
Microsoft.Maps.IAddress.prototype.locality;
 /** @type {string} */
Microsoft.Maps.IAddress.prototype.postalCode;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IAnimatedFrameEventArgs = function() {};
 /** @type {!Microsoft.Maps.AnimatedTileLayer} */
Microsoft.Maps.IAnimatedFrameEventArgs.prototype.animatedTileLayer;
 /** @type {number} */
Microsoft.Maps.IAnimatedFrameEventArgs.prototype.index;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IAnimatedTileLayerOptions = function() {};
 /** @type {boolean} */
Microsoft.Maps.IAnimatedTileLayerOptions.prototype.autoPlay;
 /** @type {number} */
Microsoft.Maps.IAnimatedTileLayerOptions.prototype.frameRate;
 /** @type {!Microsoft.Maps.CustomOverlay} */
Microsoft.Maps.IAnimatedTileLayerOptions.prototype.loadingScreen;
 /** @type {number} */
Microsoft.Maps.IAnimatedTileLayerOptions.prototype.maxTotalLoadTime;
 /** @type {!Array<!Microsoft.Maps.TileSource>} */
Microsoft.Maps.IAnimatedTileLayerOptions.prototype.mercator;
 /** @type {boolean} */
Microsoft.Maps.IAnimatedTileLayerOptions.prototype.visible;
/**
 * @record
 * @struct
 */
Microsoft.Maps.ICustomOverlayOptions = function() {};
 /** @type {boolean} */
Microsoft.Maps.ICustomOverlayOptions.prototype.beneathLabels;
/**
 * @extends {Microsoft.Maps.ILayer}
 * @record
 * @struct
 */
Microsoft.Maps.IDataLayer = function() {};

/**
 * Clears all data in the layer.
 * @return {void}
 */
Microsoft.Maps.IDataLayer.prototype.clear = function() {};
/**
 * @record
 * @struct
 */
Microsoft.Maps.IEntityCollectionChangedEventArgs = function() {};
 /** @type {!Microsoft.Maps.EntityCollection} */
Microsoft.Maps.IEntityCollectionChangedEventArgs.prototype.collection;
 /** @type {!Microsoft.Maps.IPrimitive} */
Microsoft.Maps.IEntityCollectionChangedEventArgs.prototype.data;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IHandlerId = function() {};
/**
 * @record
 * @struct
 */
Microsoft.Maps.ILayer = function() {};
/**
 * @record
 * @struct
 */
Microsoft.Maps.ILayerMouseEventArgs = function() {};
 /** @type {!Microsoft.Maps.IPrimitive} */
Microsoft.Maps.ILayerMouseEventArgs.prototype.primitive;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IInfoboxOptions = function() {};
 /** @type {!Array<!Microsoft.Maps.IInfoboxActions>} */
Microsoft.Maps.IInfoboxOptions.prototype.actions;
 /** @type {string} */
Microsoft.Maps.IInfoboxOptions.prototype.description;
 /** @type {string} */
Microsoft.Maps.IInfoboxOptions.prototype.htmlContent;
 /** @type {!Microsoft.Maps.Location} */
Microsoft.Maps.IInfoboxOptions.prototype.location;
 /** @type {number} */
Microsoft.Maps.IInfoboxOptions.prototype.maxHeight;
 /** @type {number} */
Microsoft.Maps.IInfoboxOptions.prototype.maxWidth;
 /** @type {!Microsoft.Maps.Point} */
Microsoft.Maps.IInfoboxOptions.prototype.offset;
 /** @type {boolean} */
Microsoft.Maps.IInfoboxOptions.prototype.showCloseButton;
 /** @type {boolean} */
Microsoft.Maps.IInfoboxOptions.prototype.showPointer;
 /** @type {string} */
Microsoft.Maps.IInfoboxOptions.prototype.title;
 /** @type {boolean} */
Microsoft.Maps.IInfoboxOptions.prototype.visible;
 /** @type {number} */
Microsoft.Maps.IInfoboxOptions.prototype.zIndex;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IInfoboxActions = function() {};
 /** @type {string} */
Microsoft.Maps.IInfoboxActions.prototype.label;
 /** @type {function(!MouseEvent): void} */
Microsoft.Maps.IInfoboxActions.prototype.eventHandler;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IInfoboxEventArgs = function() {};
 /** @type {string} */
Microsoft.Maps.IInfoboxEventArgs.prototype.eventName;
 /** @type {number} */
Microsoft.Maps.IInfoboxEventArgs.prototype.pageX;
 /** @type {number} */
Microsoft.Maps.IInfoboxEventArgs.prototype.pageY;
 /** @type {!Microsoft.Maps.Infobox} */
Microsoft.Maps.IInfoboxEventArgs.prototype.target;
 /** @type {string} */
Microsoft.Maps.IInfoboxEventArgs.prototype.targetType;
 /** @type {!MouseEvent} */
Microsoft.Maps.IInfoboxEventArgs.prototype.originalEvent;
/**
 * @extends {Microsoft.Maps.IMapOptions}
 * @extends {Microsoft.Maps.IViewOptions}
 * @record
 * @struct
 */
Microsoft.Maps.IMapLoadOptions = function() {};
 /** @type {string} */
Microsoft.Maps.IMapLoadOptions.prototype.credentials;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IMapOptions = function() {};
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.allowHidingLabelsOfRoad;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.allowInfoboxOverflow;
 /** @type {(string|!Microsoft.Maps.Color)} */
Microsoft.Maps.IMapOptions.prototype.backgroundColor;
 /** @type {!Microsoft.Maps.ICustomMapStyle} */
Microsoft.Maps.IMapOptions.prototype.customMapStyle;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.disableKeyboardInput;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.disableMapTypeSelectorMouseOver;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.disablePanning;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.disableScrollWheelZoom;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.disableStreetside;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.disableStreetsideAutoCoverage;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.disableZooming;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.enableClickableLogo;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.enableInertia;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.liteMode;
 /** @type {!Microsoft.Maps.LocationRect} */
Microsoft.Maps.IMapOptions.prototype.maxBounds;
 /** @type {number} */
Microsoft.Maps.IMapOptions.prototype.maxZoom;
 /** @type {number} */
Microsoft.Maps.IMapOptions.prototype.minZoom;
 /** @type {Microsoft.Maps.NavigationBarMode} */
Microsoft.Maps.IMapOptions.prototype.navigationBarMode;
 /** @type {Microsoft.Maps.NavigationBarOrientation} */
Microsoft.Maps.IMapOptions.prototype.navigationBarOrientation;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.showBreadcrumb;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.showDashboard;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.showLocateMeButton;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.showLogo;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.showMapTypeSelector;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.showScalebar;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.showTrafficButton;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.showTermsLink;
 /** @type {boolean} */
Microsoft.Maps.IMapOptions.prototype.showZoomButtons;
 /** @type {!Microsoft.Maps.IStreetsideOptions} */
Microsoft.Maps.IMapOptions.prototype.streetsideOptions;
 /** @type {!Array<Microsoft.Maps.MapTypeId>} */
Microsoft.Maps.IMapOptions.prototype.supportedMapTypes;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IMapTypeChangeEventArgs = function() {};
 /** @type {Microsoft.Maps.MapTypeId} */
Microsoft.Maps.IMapTypeChangeEventArgs.prototype.newMapTypeId;
 /** @type {Microsoft.Maps.MapTypeId} */
Microsoft.Maps.IMapTypeChangeEventArgs.prototype.oldMapTypeId;
 /** @type {!Microsoft.Maps.Map} */
Microsoft.Maps.IMapTypeChangeEventArgs.prototype.target;
 /** @type {string} */
Microsoft.Maps.IMapTypeChangeEventArgs.prototype.targetType;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IModuleOptions = function() {};
 /** @type {function(): void} */
Microsoft.Maps.IModuleOptions.prototype.callback;
 /** @type {function(): void} */
Microsoft.Maps.IModuleOptions.prototype.errorCallback;
 /** @type {string} */
Microsoft.Maps.IModuleOptions.prototype.credentials;
/**
 * @extends {Microsoft.Maps.ILayerMouseEventArgs}
 * @record
 * @struct
 */
Microsoft.Maps.IMouseEventArgs = function() {};
 /** @type {string} */
Microsoft.Maps.IMouseEventArgs.prototype.eventName;
 /** @type {boolean} */
Microsoft.Maps.IMouseEventArgs.prototype.isPrimary;
 /** @type {boolean} */
Microsoft.Maps.IMouseEventArgs.prototype.isSecondary;
 /** @type {!Microsoft.Maps.Layer} */
Microsoft.Maps.IMouseEventArgs.prototype.layer;
 /** @type {!Microsoft.Maps.Location} */
Microsoft.Maps.IMouseEventArgs.prototype.location;
 /** @type {number} */
Microsoft.Maps.IMouseEventArgs.prototype.pageX;
 /** @type {number} */
Microsoft.Maps.IMouseEventArgs.prototype.pageY;
 /** @type {!Microsoft.Maps.Point} */
Microsoft.Maps.IMouseEventArgs.prototype.point;
 /** @type {(!Microsoft.Maps.IPrimitive|!Microsoft.Maps.Map)} */
Microsoft.Maps.IMouseEventArgs.prototype.target;
 /** @type {string} */
Microsoft.Maps.IMouseEventArgs.prototype.targetType;

/**
 * Returns the x-value of the pixel coordinate, relative to the map, of the mouse.
 * @return {number} The x-value of the pixel coordinate, relative to the map, of the mouse.
 */
Microsoft.Maps.IMouseEventArgs.prototype.getX = function() {};

/**
 * Returns the y-value of the pixel coordinate, relative to the map, of the mouse.
 * @return {number} The y-value of the pixel coordinate, relative to the map, of the mouse.
 */
Microsoft.Maps.IMouseEventArgs.prototype.getY = function() {};
/**
 * @record
 * @struct
 */
Microsoft.Maps.IPanoramaInfo = function() {};
 /** @type {string} */
Microsoft.Maps.IPanoramaInfo.prototype.cd;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IPrimitive = function() {};
 /** @type {?} */
Microsoft.Maps.IPrimitive.prototype.metadata;

/**
 * Gets the css cursor value when the primitive has events on it.
 * @return {string} css cursor string when primitive has events on it.
 */
Microsoft.Maps.IPrimitive.prototype.getCursor = function() {};

/**
 * Gets whether the primitive is visible.
 * @return {boolean} A boolean indicating whether the primitive is visible or not.
 */
Microsoft.Maps.IPrimitive.prototype.getVisible = function() {};

/**
 * Sets the options for customizing the IPrimitive.
 * @param {!Microsoft.Maps.IPrimitiveOptions} options The options for customizing the IPrimitive.
 * @return {void}
 */
Microsoft.Maps.IPrimitive.prototype.setOptions = function(options) {};
/**
 * @record
 * @struct
 */
Microsoft.Maps.IPrimitiveChangedEventArgs = function() {};
 /** @type {!Microsoft.Maps.IPrimitive} */
Microsoft.Maps.IPrimitiveChangedEventArgs.prototype.sender;
 /** @type {string} */
Microsoft.Maps.IPrimitiveChangedEventArgs.prototype.name;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IPrimitiveOptions = function() {};
 /** @type {string} */
Microsoft.Maps.IPrimitiveOptions.prototype.cursor;
 /** @type {boolean} */
Microsoft.Maps.IPrimitiveOptions.prototype.visible;
/**
 * @extends {Microsoft.Maps.IPrimitiveOptions}
 * @record
 * @struct
 */
Microsoft.Maps.IPolylineOptions = function() {};
 /** @type {boolean} */
Microsoft.Maps.IPolylineOptions.prototype.generalizable;
 /** @type {(string|!Microsoft.Maps.Color)} */
Microsoft.Maps.IPolylineOptions.prototype.strokeColor;
 /** @type {(string|!Array<number>)} */
Microsoft.Maps.IPolylineOptions.prototype.strokeDashArray;
 /** @type {number} */
Microsoft.Maps.IPolylineOptions.prototype.strokeThickness;
/**
 * @extends {Microsoft.Maps.IPolylineOptions}
 * @record
 * @struct
 */
Microsoft.Maps.IPolygonOptions = function() {};
 /** @type {(string|!Microsoft.Maps.Color)} */
Microsoft.Maps.IPolygonOptions.prototype.fillColor;
/**
 * @extends {Microsoft.Maps.IPrimitiveOptions}
 * @record
 * @struct
 */
Microsoft.Maps.IPushpinOptions = function() {};
 /** @type {!Microsoft.Maps.Point} */
Microsoft.Maps.IPushpinOptions.prototype.anchor;
 /** @type {(string|!Microsoft.Maps.Color)} */
Microsoft.Maps.IPushpinOptions.prototype.color;
 /** @type {boolean} */
Microsoft.Maps.IPushpinOptions.prototype.draggable;
 /** @type {boolean} */
Microsoft.Maps.IPushpinOptions.prototype.enableClickedStyle;
 /** @type {boolean} */
Microsoft.Maps.IPushpinOptions.prototype.enableHoverStyle;
 /** @type {string} */
Microsoft.Maps.IPushpinOptions.prototype.icon;
 /** @type {boolean} */
Microsoft.Maps.IPushpinOptions.prototype.roundClickableArea;
 /** @type {string} */
Microsoft.Maps.IPushpinOptions.prototype.subTitle;
 /** @type {string} */
Microsoft.Maps.IPushpinOptions.prototype.title;
 /** @type {string} */
Microsoft.Maps.IPushpinOptions.prototype.text;
 /** @type {!Microsoft.Maps.Point} */
Microsoft.Maps.IPushpinOptions.prototype.textOffset;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IRange = function() {};
 /** @type {number} */
Microsoft.Maps.IRange.prototype.min;
 /** @type {number} */
Microsoft.Maps.IRange.prototype.max;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IStreetsideOptions = function() {};
 /** @type {boolean} */
Microsoft.Maps.IStreetsideOptions.prototype.disablePanoramaNavigation;
 /** @type {!Microsoft.Maps.Location} */
Microsoft.Maps.IStreetsideOptions.prototype.locationToLookAt;
 /** @type {function(): void} */
Microsoft.Maps.IStreetsideOptions.prototype.onErrorLoading;
 /** @type {function(): void} */
Microsoft.Maps.IStreetsideOptions.prototype.onSuccessLoading;
 /** @type {Microsoft.Maps.OverviewMapMode} */
Microsoft.Maps.IStreetsideOptions.prototype.overviewMapMode;
 /** @type {!Microsoft.Maps.IPanoramaInfo} */
Microsoft.Maps.IStreetsideOptions.prototype.panoramaInfo;
 /** @type {number} */
Microsoft.Maps.IStreetsideOptions.prototype.panoramaLookupRadius;
 /** @type {boolean} */
Microsoft.Maps.IStreetsideOptions.prototype.showCurrentAddress;
 /** @type {boolean} */
Microsoft.Maps.IStreetsideOptions.prototype.showExitButton;
 /** @type {boolean} */
Microsoft.Maps.IStreetsideOptions.prototype.showHeadingCompass;
 /** @type {boolean} */
Microsoft.Maps.IStreetsideOptions.prototype.showProblemReporting;
 /** @type {boolean} */
Microsoft.Maps.IStreetsideOptions.prototype.showZoomButtons;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IStylesOptions = function() {};
 /** @type {!Microsoft.Maps.IPushpinOptions} */
Microsoft.Maps.IStylesOptions.prototype.pushpinOptions;
 /** @type {!Microsoft.Maps.IPolylineOptions} */
Microsoft.Maps.IStylesOptions.prototype.polylineOptions;
 /** @type {!Microsoft.Maps.IPolygonOptions} */
Microsoft.Maps.IStylesOptions.prototype.polygonOptions;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IStyleUrl = function() {};
 /** @type {!Array<string>} */
Microsoft.Maps.IStyleUrl.prototype.styleURLs;
/**
 * @record
 * @struct
 */
Microsoft.Maps.ITileLayerOptions = function() {};
 /** @type {number} */
Microsoft.Maps.ITileLayerOptions.prototype.downloadTimeout;
 /** @type {!Microsoft.Maps.TileSource} */
Microsoft.Maps.ITileLayerOptions.prototype.mercator;
 /** @type {number} */
Microsoft.Maps.ITileLayerOptions.prototype.opacity;
 /** @type {boolean} */
Microsoft.Maps.ITileLayerOptions.prototype.visible;
 /** @type {number} */
Microsoft.Maps.ITileLayerOptions.prototype.zIndex;
/**
 * @record
 * @struct
 */
Microsoft.Maps.ITileSourceOptions = function() {};
 /** @type {!Microsoft.Maps.LocationRect} */
Microsoft.Maps.ITileSourceOptions.prototype.bounds;
 /** @type {number} */
Microsoft.Maps.ITileSourceOptions.prototype.maxZoom;
 /** @type {number} */
Microsoft.Maps.ITileSourceOptions.prototype.minZoom;
 /** @type {(string|function(!Microsoft.Maps.PyramidTileId): string)} */
Microsoft.Maps.ITileSourceOptions.prototype.uriConstructor;
/**
 * @record
 * @struct
 */
Microsoft.Maps.IViewOptions = function() {};
 /** @type {!Microsoft.Maps.LocationRect} */
Microsoft.Maps.IViewOptions.prototype.bounds;
 /** @type {!Microsoft.Maps.Location} */
Microsoft.Maps.IViewOptions.prototype.center;
 /** @type {number} */
Microsoft.Maps.IViewOptions.prototype.heading;
 /** @type {Microsoft.Maps.LabelOverlay} */
Microsoft.Maps.IViewOptions.prototype.labelOverlay;
 /** @type {Microsoft.Maps.MapTypeId} */
Microsoft.Maps.IViewOptions.prototype.mapTypeId;
 /** @type {number} */
Microsoft.Maps.IViewOptions.prototype.padding;
 /** @type {number} */
Microsoft.Maps.IViewOptions.prototype.pitch;
 /** @type {number} */
Microsoft.Maps.IViewOptions.prototype.zoom;

/**
 * Loads the specified registered module, making its functionality available. You can provide the name of a single module or an array of names in.
 * Options or a callback function that is called when the module is loaded can be specified.
 * @param {(string|!Array<string>)} moduleName Name of the module to load. Can be the name of a custom module or a built in module name. Built in modules:
 * Microsoft.Maps.Autosuggest, Microsoft.Maps.Clustering, Microsoft.Maps.Directions, Microsoft.Maps.DrawingTools, Microsoft.Maps.GeoJSON,
 * Microsoft.Maps.HeatMap, Microsoft.Maps.Search, Microsoft.Maps.SpatialDataService, Microsoft.Maps.SpatialMath, Microsoft.Maps.Traffic,
 * Microsoft.Maps.WellKnownText
 * @param {(function(): void|!Microsoft.Maps.IModuleOptions)=} options A callback function or options containing additional information and a callback to call once a module is loaded
 * @return {void}
 */
Microsoft.Maps.loadModule = function(moduleName, options) {};

/**
 * Registers a module with the map control. The name of the module is specified in moduleKey, the module script is defined in scriptURL, and the
 * options provides the location of a *.css file to load with the module.
 * @param {string} moduleName Name of the module to load.
 * @param {string} url Url to where the module code is located.
 * @param {!Microsoft.Maps.IStyleUrl=} styles List of css files to download.
 * @return {void}
 */
Microsoft.Maps.registerModule = function(moduleName, url, styles) {};

/**
 * Signals that the specified module has been loaded and if specified, calls the callback function in loadModule. Call this method at the end of your custom module script.
 * @param {string} moduleName Name of the module that is loaded.
 * @return {void}
 */
Microsoft.Maps.moduleLoaded = function(moduleName) {};

/**
 * @constructor
 * @struct
 * \@contstructor
 * @param {!Microsoft.Maps.IAnimatedTileLayerOptions=} options Options that define how to animate between the specified tile layers.
 */
Microsoft.Maps.AnimatedTileLayer = function(options) {};

/**
 * Gets the frame rate of this animated tile layer.
 * @return {number} The frame rate of this animated tile layer.
 * 
 */
Microsoft.Maps.AnimatedTileLayer.prototype.getFrameRate = function() {};

/**
 * Gets the loading screen overlay when tiles are being fetched.
 * @return {!Microsoft.Maps.CustomOverlay} The loading screen overlay when tiles are being fetched.
 * 
 */
Microsoft.Maps.AnimatedTileLayer.prototype.getLoadingScreen = function() {};

/**
 * Gets the maximum total tile fetching time of this animated tile layer.
 * @return {number} The maximum total tile fetching time of this animated tile layer
 * 
 */
Microsoft.Maps.AnimatedTileLayer.prototype.getMaxTotalLoadTime = function() {};

/**
 * Gets the tile sources associated with this layer.
 * @return {!Array<!Microsoft.Maps.TileSource>} The tile sources associated with this layer.
 * 
 */
Microsoft.Maps.AnimatedTileLayer.prototype.getTileSources = function() {};

/**
 * Gets the visibility of this animated tile layer.
 * @return {boolean} The visibility of this animated tile layer.
 * 
 */
Microsoft.Maps.AnimatedTileLayer.prototype.getVisible = function() {};

/**
 * Pause the tile layer animation. *
 * @return {void}
 */
Microsoft.Maps.AnimatedTileLayer.prototype.pause = function() {};

/**
 * Play the animation either from start or where it was paused. *
 * @return {void}
 */
Microsoft.Maps.AnimatedTileLayer.prototype.play = function() {};

/**
 * Sets the options for the animated tile layer.
 * \@params Options that define how to animate between the specified tile layers.
 * 
 * @param {!Microsoft.Maps.IAnimatedTileLayerOptions} options
 * @return {void}
 */
Microsoft.Maps.AnimatedTileLayer.prototype.setOptions = function(options) {};

/**
 * Stop the layer animation, hide layer, and reset frame to the beginning. *
 * @return {void}
 */
Microsoft.Maps.AnimatedTileLayer.prototype.stop = function() {};

/**
 * @constructor
 * @struct
 * @param {number} a The alpha value in argb format
 * @param {number} r The r value in argb format
 * @param {number} g The g value in argb format
 * @param {number} b The b value in argb format
 */
Microsoft.Maps.Color = function(a, r, g, b) {};
 /** @type {number} */
Microsoft.Maps.Color.prototype.a;
 /** @type {number} */
Microsoft.Maps.Color.prototype.r;
 /** @type {number} */
Microsoft.Maps.Color.prototype.g;
 /** @type {number} */
Microsoft.Maps.Color.prototype.b;

/**
 * Clones the color.
 * @param {!Microsoft.Maps.Color} color The color class that needs to be clones.
 * @return {!Microsoft.Maps.Color} The colne of the color.
 */
Microsoft.Maps.Color.clone = function(color) {};

/**
 * Creates the color from a hex string.
 * @param {string} hex The color represented as '#rrggbb' format.
 * @return {!Microsoft.Maps.Color} The color object.
 */
Microsoft.Maps.Color.fromHex = function(hex) {};

/**
 * Clones the color.
 * @return {!Microsoft.Maps.Color} The clone of the color.
 */
Microsoft.Maps.Color.prototype.clone = function() {};

/**
 * Gets the opacity of this color.
 * @return {number} The opacity between 0 and 1 of this color.
 */
Microsoft.Maps.Color.prototype.getOpacity = function() {};

/**
 * Converts the color to hex notation.
 * @return {string} The hex notation as '#rrggbb' (ignores a).
 */
Microsoft.Maps.Color.prototype.toHex = function() {};

/**
 * Converts the color to rgba notation.
 * @return {string} The rgba notation as rgba(rr, gg, bb, aa)
 */
Microsoft.Maps.Color.prototype.toRgba = function() {};

/**
 * @constructor
 * @struct
 * @param {!Microsoft.Maps.ICustomOverlayOptions=} options The options to use when initializing the custom overlay.
 */
Microsoft.Maps.CustomOverlay = function(options) {};
 /** @type {!Microsoft.Maps.Map} */
Microsoft.Maps.CustomOverlay.prototype._map;

/**
 * Gets the html element of this custom overlay.
 * @return {!HTMLElement} The htmlElement of this overlay.
 */
Microsoft.Maps.CustomOverlay.prototype.getHtmlElement = function() {};

/**
 * Gets the map that this overlay is attached to.
 * @return {!Microsoft.Maps.Map} The map that this overlay is attached to.
 */
Microsoft.Maps.CustomOverlay.prototype.getMap = function() {};

/**
 * Updates the html element of this custom overlay.
 * @param {!HTMLElement} htmlElement The new htmlElement to set for the overlay.
 * @return {void}
 */
Microsoft.Maps.CustomOverlay.prototype.setHtmlElement = function(htmlElement) {};

/**
 * Implement this method to perform any task that should be done when the overlay is added to the map.
 * @return {void}
 */
Microsoft.Maps.CustomOverlay.prototype.onAdd = function() {};

/**
 * Implement this methof to perform any task that should be done after the overlay has been added to the map.
 * @return {void}
 */
Microsoft.Maps.CustomOverlay.prototype.onRemove = function() {};

/**
 * Implement this method to perform any tasks that should be done when the overlay is removed from the map.
 * @return {void}
 */
Microsoft.Maps.CustomOverlay.prototype.onLoad = function() {};

/**
 * @constructor
 * @struct
 * @deprecated in V8
 */
Microsoft.Maps.EntityCollection = function() {};

/**
 * Removes all shapes from the collection.
 * @return {void}
 */
Microsoft.Maps.EntityCollection.prototype.clear = function() {};

/**
 * Gets the item at a specified index.
 * @param {number} index Index of the item to get.
 * @return {!Microsoft.Maps.IPrimitive} The item at a specified index.
 */
Microsoft.Maps.EntityCollection.prototype.get = function(index) {};

/**
 * Gets the number of items in this collection.
 * @return {number} The count of the items.
 */
Microsoft.Maps.EntityCollection.prototype.getLength = function() {};

/**
 * Gets the index of the item in the list.
 * @param {!Microsoft.Maps.IPrimitive} primitive The item to get the index of.
 * @return {number} The index of the item in the list.
 */
Microsoft.Maps.EntityCollection.prototype.indexOf = function(primitive) {};

/**
 * Inserts the item into the list at a specific index.
 * @param {!Microsoft.Maps.IPrimitive} primitive The item to insert.
 * @param {number} index Index of the item to be inserted.
 * @return {void}
 */
Microsoft.Maps.EntityCollection.prototype.insert = function(primitive, index) {};

/**
 * Returns the last element in the list after removing it.
 * @return {!Microsoft.Maps.IPrimitive} The last element in the list after removing it.
 */
Microsoft.Maps.EntityCollection.prototype.pop = function() {};

/**
 * Adds the item to the end of the list.
 * @param {(!Microsoft.Maps.IPrimitive|!Array<!Microsoft.Maps.IPrimitive>)} primitive Item to be added.
 * @return {void}
 */
Microsoft.Maps.EntityCollection.prototype.push = function(primitive) {};

/**
 * Removes the item from the list.
 * @param {!Microsoft.Maps.IPrimitive} primitive Item to be removed.
 * @return {!Microsoft.Maps.IPrimitive} The item to be removed.
 */
Microsoft.Maps.EntityCollection.prototype.remove = function(primitive) {};

/**
 * Removes the item from the list at a specified index.
 * @param {number} index Index of the item that needs to be removed.
 * @return {!Microsoft.Maps.IPrimitive} The item to be removed at a specified index.
 */
Microsoft.Maps.EntityCollection.prototype.removeAt = function(index) {};
/** @const */
Microsoft.Maps.Events = {};

/**
 * Attaches the handler for the event that is thrown by the target. Use the return object to remove the handler using the removeHandler method.
 * Attaches the handler for the event that is thrown by the target. Use the return object to remove the handler using the removeHandler method.
 * Attaches the handler for the event that is thrown by the target. Use the return object to remove the handler using the removeHandler method.
 * Attaches the handler for the event that is thrown by the target. Use the return object to remove the handler using the removeHandler method.
 * Attaches the handler for the event that is thrown by the target. Use the return object to remove the handler using the removeHandler method.
 * Attaches the handler for the event that is thrown by the target. Use the return object to remove the handler using the removeHandler method.
 * Attaches the handler for the event that is thrown by the target. Use the return object to remove the handler using the removeHandler method.
 * @param {!Microsoft.Maps.Map|!Microsoft.Maps.Pushpin|(!Microsoft.Maps.Polyline|!Microsoft.Maps.Polygon)|!Microsoft.Maps.Infobox|!Microsoft.Maps.Layer|!Microsoft.Maps.EntityCollection|?} target The object to attach the event to; Map, IPrimitive, Infobox, Layer, DrawingTools, DrawingManager, DirectionsManager, etc.
 * @param {string} eventName The type of event to attach. Supported events:
 * click, dblclick, maptypechanged, mousedown, mousemove, mouseout, mouseover, mouseup, mousewheel, rightclick, viewchange, viewchangeend, viewchangestart / The type of event to attach. Supported Events:
 * changed, click, dblclick, drag, dragend, dragstart, mousedown, mouseout, mouseover, mouseup / The type of event to attach. Supported Events:
 * changed, click, dblclick, mousedown, mouseout, mouseover, mouseup / The type of event to attach. Supported Events:
 * click, infoboxChanged, mouseenter, mouseleave / The type of event to attach. Supported Events:
 * click, dblclick, mousedown, mouseout, mouseover, mouseup, rightclick / The type of event to attach. Supported Events:
 * � entityadded
 * � entityremoved / The type of event to attach.
 * @param {function((!Microsoft.Maps.IMouseEventArgs|!Microsoft.Maps.IMapTypeChangeEventArgs)): void|function((!Microsoft.Maps.IMouseEventArgs|!Microsoft.Maps.IPrimitiveChangedEventArgs)): void|function(!Microsoft.Maps.IInfoboxEventArgs): void|function(!Microsoft.Maps.IMouseEventArgs): void|function(!Microsoft.Maps.IEntityCollectionChangedEventArgs): void|function(?): void} handler The callback function to handle the event when triggered. 
 * @return {!Microsoft.Maps.IHandlerId} The handler id.
 */
Microsoft.Maps.Events.addHandler = function(target, eventName, handler) {};

/**
 * Attaches the handler for the event that is thrown by the target, but only triggers the handler the first once after being attached.
 * Attaches the handler for the event that is thrown by the target, but only triggers the handler the first once after being attached.
 * Attaches the handler for the event that is thrown by the target, but only triggers the handler the first once after being attached.
 * Attaches the handler for the event that is thrown by the target, but only triggers the handler the first once after being attached.
 * Attaches the handler for the event that is thrown by the target, but only triggers the handler the first once after being attached.
 * Attaches the handler for the event that is thrown by the target, but only triggers the handler the first once after being attached.
 * Attaches the handler for the event that is thrown by the target, but only triggers the handler the first once after being attached.
 * @param {!Microsoft.Maps.Map|!Microsoft.Maps.Pushpin|(!Microsoft.Maps.Polyline|!Microsoft.Maps.Polygon)|!Microsoft.Maps.Infobox|!Microsoft.Maps.Layer|!Microsoft.Maps.EntityCollection|?} target The object to attach the event to; Map, IPrimitive, Infobox, Layer, DrawingTools, DrawingManager, DirectionsManager, etc.
 * @param {string} eventName The type of event to attach. Supported events:
 * click, dblclick, maptypechanged, mousedown, mousemove, mouseout, mouseover, mouseup, mousewheel, rightclick, viewchange, viewchangeend, viewchangestart / The type of event to attach. Supported Events:
 * changed, click, dblclick, drag, dragend, dragstart, mousedown, mouseout, mouseover, mouseup / The type of event to attach. Supported Events:
 * changed, click, dblclick, mousedown, mouseout, mouseover, mouseup / The type of event to attach. Supported Events:
 * click, infoboxChanged, mouseenter, mouseleave / The type of event to attach. Supported Events:
 * click, dblclick, mousedown, mouseout, mouseover, mouseup, rightclick / The type of event to attach. Supported Events:
 * � entityadded
 * � entityremoved / The type of event to attach.
 * @param {function((!Microsoft.Maps.IMouseEventArgs|!Microsoft.Maps.IMapTypeChangeEventArgs)): void|function((!Microsoft.Maps.IMouseEventArgs|!Microsoft.Maps.IPrimitiveChangedEventArgs)): void|function(!Microsoft.Maps.IInfoboxEventArgs): void|function(!Microsoft.Maps.IMouseEventArgs): void|function(!Microsoft.Maps.IEntityCollectionChangedEventArgs): void|function(?): void} handler The callback function to handle the event when triggered.
 * @return {void}
 */
Microsoft.Maps.Events.addOne = function(target, eventName, handler) {};

/**
 * Attaches the handler for the event that is thrown by the target, where the minimum interval between events (in milliseconds) is specified as a parameter.
 * Attaches the handler for the event that is thrown by the target, where the minimum interval between events (in milliseconds) is specified as a parameter.
 * Attaches the handler for the event that is thrown by the target, where the minimum interval between events (in milliseconds) is specified as a parameter.
 * Attaches the handler for the event that is thrown by the target, where the minimum interval between events (in milliseconds) is specified as a parameter.
 * Attaches the handler for the event that is thrown by the target, where the minimum interval between events (in milliseconds) is specified as a parameter.
 * Attaches the handler for the event that is thrown by the target, where the minimum interval between events (in milliseconds) is specified as a parameter.
 * Attaches the handler for the event that is thrown by the target, where the minimum interval between events (in milliseconds) is specified as a parameter.
 * @param {!Microsoft.Maps.Map|!Microsoft.Maps.Pushpin|(!Microsoft.Maps.Polyline|!Microsoft.Maps.Polygon)|!Microsoft.Maps.Infobox|!Microsoft.Maps.Layer|!Microsoft.Maps.EntityCollection|?} target The object to attach the event to; Map, IPrimitive, Infobox, Layer, DrawingTools, DrawingManager, DirectionsManager, etc.
 * @param {string} eventName The type of event to attach. Supported events:
 * click, dblclick, maptypechanged, mousedown, mousemove, mouseout, mouseover, mouseup, mousewheel, rightclick, viewchange, viewchangeend, viewchangestart / The type of event to attach. Supported Events:
 * changed, click, dblclick, drag, dragend, dragstart, mousedown, mouseout, mouseover, mouseup / The type of event to attach. Supported Events:
 * changed, click, dblclick, mousedown, mouseout, mouseover, mouseup / The type of event to attach. Supported Events:
 * click, infoboxChanged, mouseenter, mouseleave / The type of event to attach. Supported Events:
 * click, dblclick, mousedown, mouseout, mouseover, mouseup, rightclick / The type of event to attach. Supported Events:
 * � entityadded
 * � entityremoved / The type of event to attach.
 * @param {function((!Microsoft.Maps.IMouseEventArgs|!Microsoft.Maps.IMapTypeChangeEventArgs)): void|function((!Microsoft.Maps.IMouseEventArgs|!Microsoft.Maps.IPrimitiveChangedEventArgs)): void|function(!Microsoft.Maps.IInfoboxEventArgs): void|function(!Microsoft.Maps.IMouseEventArgs): void|function(!Microsoft.Maps.IEntityCollectionChangedEventArgs): void|function(?): void} handler The callback function to handle the event when triggered. / The callback function to handle the event when triggered. 
 * @param {number=} throttleInterval throttle interval (in ms)
 * @return {!Microsoft.Maps.IHandlerId} The handler id.
 */
Microsoft.Maps.Events.addThrottledHandler = function(target, eventName, handler, throttleInterval) {};

/**
 * Checks if the target has any attached event handler.
 * @param {?} target The object to check if an event is attached to it. 
 * @param {string} eventName The name of the event to check to see is attached.
 * @return {boolean} A boolean indicating if the specified event type is attached to the object.
 */
Microsoft.Maps.Events.hasHandler = function(target, eventName) {};

/**
 * Invokes an event on the target. This causes all handlers for the specified event name to be called.
 * @param {?} target The object to invoke the event on.
 * @param {string} evenName
 * @param {?} args Arguments for the event handler.
 * @return {void}
 */
Microsoft.Maps.Events.invoke = function(target, evenName, args) {};

/**
 * Detaches the specified handler from the event. The handlerId is returned by the addHandler and addThrottledHandler methods.
 * @param {!Microsoft.Maps.IHandlerId} handlerId The handler id of the event to remove.
 * @return {void}
 */
Microsoft.Maps.Events.removeHandler = function(handlerId) {};
/**
 * @constructor
 * @struct
 */
Microsoft.Maps.Heading = function() {};
 /** @type {number} */
Microsoft.Maps.Heading.North;
 /** @type {number} */
Microsoft.Maps.Heading.South;
 /** @type {number} */
Microsoft.Maps.Heading.East;
 /** @type {number} */
Microsoft.Maps.Heading.West;

/**
 * @constructor
 * @struct
 * @param {!Microsoft.Maps.Location} location The location to display the infobox at.
 * @param {!Microsoft.Maps.IInfoboxOptions=} options Options for rendering the infobox.
 */
Microsoft.Maps.Infobox = function(location, options) {};

/**
 * @deprecated Use HTML buttons and links in description instead.
 * @return {!Array<!Microsoft.Maps.IInfoboxActions>}
 */
Microsoft.Maps.Infobox.prototype.getActions = function() {};

/**
 * Gets the point on the infobox which is anchored to the map. An anchor of (0,0) is the top left corner of the infobox.
 * @return {!Microsoft.Maps.Point} The anchor point of the infobox.
 */
Microsoft.Maps.Infobox.prototype.getAnchor = function() {};

/**
 * Gets the string that is printed inside the infobox.
 * @return {string} The description value of the infobox options.
 */
Microsoft.Maps.Infobox.prototype.getDescription = function() {};

/**
 * Gets the height of the infobox.
 * @return {number} The height of the infobox.
 */
Microsoft.Maps.Infobox.prototype.getHeight = function() {};

/**
 * Gets the infobox as HTML.
 * @return {string} The HTML string used to create a custom infobox.
 */
Microsoft.Maps.Infobox.prototype.getHtmlContent = function() {};

/**
 * Gets the location on the map where the infobox�s anchor is attached.
 * @return {!Microsoft.Maps.Location} The location of the infobox.
 */
Microsoft.Maps.Infobox.prototype.getLocation = function() {};

/**
 * Gets the maximium height setting for the infobox.
 * @return {number} the maximium height setting for the infobox.
 */
Microsoft.Maps.Infobox.prototype.getMaxHeight = function() {};

/**
 * Gets the maximium width setting for the infobox.
 * @return {number} the maximium width setting for the infobox.
 */
Microsoft.Maps.Infobox.prototype.getMaxWidth = function() {};

/**
 * Gets the amount the infobox pointer is shifted from the location of the infobox, or if showPointer is false, then it is the amount the infobox
 * bottom left edge is shifted from the location of the infobox. The default value is (0,0), which means there is no offset.
 * @return {!Microsoft.Maps.Point} The offset of the infobox.
 */
Microsoft.Maps.Infobox.prototype.getOffset = function() {};

/**
 * Gets the infobox options.
 * @return {!Microsoft.Maps.IInfoboxOptions} The infobox options currently used by the infobox.
 */
Microsoft.Maps.Infobox.prototype.getOptions = function() {};

/**
 * Gets a boolean indicating whether the infobox close button is shown.
 * @return {boolean} A boolean indicating if the close button is shown or not.
 */
Microsoft.Maps.Infobox.prototype.getShowCloseButton = function() {};

/**
 * Gets a boolean indicating whether the infobox is drawn with a pointer.
 * @return {boolean} A boolean indicating if the pointer of the infobox is shown or not.
 */
Microsoft.Maps.Infobox.prototype.getShowPointer = function() {};

/**
 * Gets a string that is the title of the infobox.
 * @return {string} The title property of the infobox.
 */
Microsoft.Maps.Infobox.prototype.getTitle = function() {};

/**
 * Gets whether the infobox is visible. A value of false indicates that the infobox is hidden, although it is still an entity on the map.
 * @return {boolean} A boolean indicating if the infobox is visible or not.
 */
Microsoft.Maps.Infobox.prototype.getVisible = function() {};

/**
 * Gets the width of the infobox.
 * @return {number} The width of the infobox.
 */
Microsoft.Maps.Infobox.prototype.getWidth = function() {};

/**
 * Gets the z-index of the infobox.
 * @return {number} The z-index of the infobox.
 */
Microsoft.Maps.Infobox.prototype.getZIndex = function() {};

/**
 * Sets the HTML content of the infobox. You can use this method to change the look of the infobox. Note that infobox options are ignored if
 * custom HTML is set. Also, when custom HTML is used to represent the infobox, the infobox is anchored at the bottom-left corner.
 * @param {string} content The HTML string to use to generate the infobox.
 * @return {void}
 */
Microsoft.Maps.Infobox.prototype.setHtmlContent = function(content) {};

/**
 * Sets the location on the map where the anchor of the infobox is attached.
 * @param {!Microsoft.Maps.Location} loc The location to display the infobox at.
 * @return {void}
 */
Microsoft.Maps.Infobox.prototype.setLocation = function(loc) {};

/**
 * Adds the infobox to the map. To remove an Infobox from the map, simply pass null into this function.
 * @param {!Microsoft.Maps.Map} map A map instance to display the infoboox on, or null if removing infobox from map.
 * @return {void}
 */
Microsoft.Maps.Infobox.prototype.setMap = function(map) {};

/**
 * Sets options for the infobox.
 * @param {!Microsoft.Maps.IInfoboxOptions} options The options to assign to the infobox.
 * @return {void}
 */
Microsoft.Maps.Infobox.prototype.setOptions = function(options) {};

/**
 * @constructor
 * @struct
 * @param {string=} id Unique string identifier for the layer.
 */
Microsoft.Maps.Layer = function(id) {};
 /** @type {?} */
Microsoft.Maps.Layer.prototype.metadata;

/**
 * Adds a shapes to the layer, at the specified index if specified.
 * @param {(!Microsoft.Maps.IPrimitive|!Array<!Microsoft.Maps.IPrimitive>)} primitive The shape(s) to be added to the layer.
 * @param {number=} index The index at which to insert the shape into the layer.
 * @return {void}
 */
Microsoft.Maps.Layer.prototype.add = function(primitive, index) {};

/**
 * Clears all the data
 * @return {void}
 */
Microsoft.Maps.Layer.prototype.clear = function() {};

/**
 * Cleans up any resources this object is consuming
 * @return {void}
 */
Microsoft.Maps.Layer.prototype.dispose = function() {};

/**
 * Gets the id of the layer.
 * @return {string} The id assigned to the layer.
 */
Microsoft.Maps.Layer.prototype.getId = function() {};

/**
 * Gets an array of shapes that are in the layer. This can be used to iterate over the individual shapes.
 * @return {!Array<!Microsoft.Maps.IPrimitive>} An array of shapes that are in the layer.
 */
Microsoft.Maps.Layer.prototype.getPrimitives = function() {};

/**
 * Gets a value indicating whether the layer is visible or not.
 * @return {boolean} A boolean indicating if the layer is visible or not.
 */
Microsoft.Maps.Layer.prototype.getVisible = function() {};

/**
 * Gets the zIndex of the layer.
 * @return {number} The zIndex of the layer.
 */
Microsoft.Maps.Layer.prototype.getZIndex = function() {};

/**
 * Removes a primitive
 * @param {!Microsoft.Maps.IPrimitive} primitive primitive that needs to be removed
 * @return {!Microsoft.Maps.IPrimitive} The primitive that needs to be removed
 */
Microsoft.Maps.Layer.prototype.remove = function(primitive) {};

/**
 * Removes a primitive at a specified index
 * @param {number} index index of the primitive that needs to be removed
 * @return {!Microsoft.Maps.IPrimitive} The primitive that needs to be removed at this index
 */
Microsoft.Maps.Layer.prototype.removeAt = function(index) {};

/**
 * Replaces all shapes in the layer with the new array of shapes that have been provided.
 * @param {!Array<!Microsoft.Maps.IPrimitive>} primitives The array of shapes to add to the layer.
 * @return {void}
 */
Microsoft.Maps.Layer.prototype.setPrimitives = function(primitives) {};

/**
 * Sets whether the layer is visible or not.
 * @param {boolean} value A value indicating if the layer should be displayed or not.
 * @return {void}
 */
Microsoft.Maps.Layer.prototype.setVisible = function(value) {};

/**
 * Sets the zIndex of the layer.
 * @param {number} zIndex The zIndex value to assign to the layer.
 * @return {void}
 */
Microsoft.Maps.Layer.prototype.setZIndex = function(zIndex) {};
/**
 * @constructor
 * @struct
 */
Microsoft.Maps.LayerCollection = function() {};
 /** @type {number} */
Microsoft.Maps.LayerCollection.prototype.length;

/**
 * Removes all layers from the map.
 * @return {void}
 */
Microsoft.Maps.LayerCollection.prototype.clear = function() {};

/**
 * Gets the index of a layer in the collection.
 * @param {!Microsoft.Maps.ILayer} layer The layer to get the index of.
 * @return {number} The index of the specified layer.
 */
Microsoft.Maps.LayerCollection.prototype.indexOf = function(layer) {};

/**
 * Adds a layer to the map.
 * @param {!Microsoft.Maps.ILayer} layer The layer to insert into the collection.
 * @return {void}
 */
Microsoft.Maps.LayerCollection.prototype.insert = function(layer) {};

/**
 * Adds an array of layers to the map.
 * @param {!Array<!Microsoft.Maps.ILayer>} layers The layers to insert into the collection.
 * @return {void}
 */
Microsoft.Maps.LayerCollection.prototype.insertAll = function(layers) {};

/**
 * Removes a layer from the map.
 * @param {!Microsoft.Maps.ILayer} layer The layer to remove from the collection.
 * @return {void}
 */
Microsoft.Maps.LayerCollection.prototype.remove = function(layer) {};

/**
 * Removes a layer from the map at the specified index in the collection.        
 * @param {number} idx The index of the layer to remove.
 * @return {void}
 */
Microsoft.Maps.LayerCollection.prototype.removeAt = function(idx) {};

/**
 * @constructor
 * @struct
 * @param {?} latitude The location north or south of the equator from +90 to -90
 * @param {?} longitude The location east or west of the prime meridian +180 to -180
 */
Microsoft.Maps.Location = function(latitude, longitude) {};
 /** @type {number} */
Microsoft.Maps.Location.prototype.latitude;
 /** @type {number} */
Microsoft.Maps.Location.prototype.longitude;

/**
 * Determines if two locations are equal.
 * @param {!Microsoft.Maps.Location} location1 The first location to test.
 * @param {!Microsoft.Maps.Location} location2 The second location to test.
 * @return {boolean} True if both locations are equivalent.
 */
Microsoft.Maps.Location.areEqual = function(location1, location2) {};

/**
 * Creates a deep copy of the map location.
 * @return {!Microsoft.Maps.Location} A deep copy of the map location.
 */
Microsoft.Maps.Location.prototype.clone = function() {};

/**
 * Creates a proper Location from an object that has the same signature.
 * @param {!Microsoft.Maps.Location} source A Location or Location-like object that contains the same properties.
 * @return {!Microsoft.Maps.Location} A copy of the map location.
 */
Microsoft.Maps.Location.cloneFrom = function(source) {};

/**
 * Normalizes the longitude by wrapping it around the earth.
 * @param {number} longitude The input longitude.
 * @return {number} The longitude normalized to within -180 and +180.
 */
Microsoft.Maps.Location.normalizeLongitude = function(longitude) {};

/**
 * Parses a location string of the form "lat,long".
 * @param {string} str The location string.
 * @return {!Microsoft.Maps.Location} The parsed location or null otherwise.
 */
Microsoft.Maps.Location.parseLatLong = function(str) {};

/**
 * Converts the Location to a string representation.
 * @return {string} A string representation of the location.
 */
Microsoft.Maps.Location.prototype.toString = function() {};

/**
 * @constructor
 * @struct
 * @param {!Microsoft.Maps.Location} center The center of the LocationRect.
 * @param {number} width The width of the LocationRect in degrees.
 * @param {number} height The height of the LocationRect in degrees.
 */
Microsoft.Maps.LocationRect = function(center, width, height) {};
 /** @type {!Microsoft.Maps.Location} */
Microsoft.Maps.LocationRect.prototype.center;
 /** @type {number} */
Microsoft.Maps.LocationRect.prototype.height;
 /** @type {number} */
Microsoft.Maps.LocationRect.prototype.width;

/**
 * Gets a LocationRect using the specified locations for the northwest and southeast corners.
 * @param {!Microsoft.Maps.Location} northwest The north west corner of the LocationRect.
 * @param {!Microsoft.Maps.Location} southeast The south east corner of the LocationRect.
 * @return {!Microsoft.Maps.LocationRect} A LocationRect using the specified locations for the northwest and southeast corners.
 */
Microsoft.Maps.LocationRect.fromCorners = function(northwest, southeast) {};

/**
 * Gets a LocationRect using the specified northern and southern latitudes and western and eastern longitudes for the rectangle boundaries.
 * @param {number} north The northern latitude of the LocationRect.
 * @param {number} west The western longitude of the LocationRect.
 * @param {number} south The southern latitude of the LocationRect.
 * @param {number} east The eastern longitude of the LocationRect.
 * @return {!Microsoft.Maps.LocationRect} A LocationRect defined by the specified northern and southern latitudes and western and eastern longitudes for the rectangle boundaries.
 */
Microsoft.Maps.LocationRect.fromEdges = function(north, west, south, east) {};

/**
 * Gets a LocationRect using a list of locations.
 * Gets a LocationRect using an array of locations.
 * @param {...!Microsoft.Maps.Location|!Array<!Microsoft.Maps.Location>} locations A list of locations. / An array of locations.
 * @return {!Microsoft.Maps.LocationRect} A LocationRect that encloses all the specified locations.
 */
Microsoft.Maps.LocationRect.fromLocations = function(locations) {};

/**
 * Creates a LocationRect from a string with the following format: "north,west,south,east". North, west, south and east specify the coordinate number values.
 * @param {string} str A string that repsents a LocationRect with the format "north,west,south,east".
 * @return {!Microsoft.Maps.LocationRect} A LocationRect defined by the specified northern and southern latitudes and western and eastern longitudes for the rectangle boundaries that have been parsed by the string.
 */
Microsoft.Maps.LocationRect.fromString = function(str) {};

/**
 * Gets a copy of the LocationRect object.
 * \@retruns A copy of the LocationRect object.
 * @return {!Microsoft.Maps.LocationRect}
 */
Microsoft.Maps.LocationRect.prototype.clone = function() {};

/**
 * Gets whether the specified Location is within the LocationRect.
 * @param {!Microsoft.Maps.Location} location
 * @return {boolean} A boolean indicating if a location is within a LocationRect.
 */
Microsoft.Maps.LocationRect.prototype.contains = function(location) {};

/**
 * Determines if the LocationRect crosses the 180th meridian.
 * @return {boolean} A boolean indicating if the LocationRect crosses the international date line (-180/180 degrees longitude).
 */
Microsoft.Maps.LocationRect.prototype.crossesInternationalDateLine = function() {};

/**
 * Gets the longitude that defines the eastern edge of the LocationRect.
 * @return {number} The eastern longitude value of the LocationRect.
 */
Microsoft.Maps.LocationRect.prototype.getEast = function() {};

/**
 * Gets the latitude that defines the northern edge of the LocationRect.
 * @return {number} The northern latitude value of the LocationRect.
 */
Microsoft.Maps.LocationRect.prototype.getNorth = function() {};

/**
 * Gets the Location that defines the northwest corner of the LocationRect.
 * @return {!Microsoft.Maps.Location} The northwest corner location of the LocationRect.
 */
Microsoft.Maps.LocationRect.prototype.getNorthwest = function() {};

/**
 * Gets the latitude that defines the southern edge of the LocationRect.
 * @return {number} The southern latitude value of the LocationRect.
 */
Microsoft.Maps.LocationRect.prototype.getSouth = function() {};

/**
 * Gets the Location that defines the southeast corner of the LocationRect.
 * @return {!Microsoft.Maps.Location} The southeast corner location of the LocationRect.
 */
Microsoft.Maps.LocationRect.prototype.getSoutheast = function() {};

/**
 * Gets the latitude that defines the western edge of the LocationRect.
 * @return {number} The western longitude value of the LocationRect.
 */
Microsoft.Maps.LocationRect.prototype.getWest = function() {};

/**
 * Gets whether the specified LocationRect intersects with this LocationRect.
 * @param {!Microsoft.Maps.LocationRect} rect A second LocationRect to test for intersection with.
 * @return {boolean} A boolean indicating if a second LocationRect interests with this LocationRect.
 */
Microsoft.Maps.LocationRect.prototype.intersects = function(rect) {};

/**
 * Scales the size of a LocationRect by multiplying the width and height properties by a percentage.
 * @param {number} percentage A percentage value to increase the size of the LocationRect by.
 * @return {void}
 */
Microsoft.Maps.LocationRect.prototype.inflate = function(percentage) {};

/**
 * If a LocationRect crosses the international date line, this method splits it into two LocationRect objects and returns them as an array.
 * @return {!Array<!Microsoft.Maps.LocationRect>} An array of LocationRects, that are split by the international date line (-180/180 degrees longitude)
 */
Microsoft.Maps.LocationRect.prototype.splitByInternationalDateLine = function() {};

/**
 * Converts the LocationRect object to a string.
 * @return {string} A string version of the LocationRect.
 */
Microsoft.Maps.LocationRect.prototype.toString = function() {};

/**
 * @constructor
 * @struct
 * @param {(string|!HTMLElement)} parentElement The parent element of the map as a CSS selector string or HTMLElement.
 * @param {!Microsoft.Maps.IMapLoadOptions} options Options used when creating the map.
 */
Microsoft.Maps.Map = function(parentElement, options) {};
 /** @type {!Microsoft.Maps.EntityCollection} */
Microsoft.Maps.Map.prototype.entities;
 /** @type {!Microsoft.Maps.LayerCollection} */
Microsoft.Maps.Map.prototype.layers;

/**
 * Gets the streetside panorama information closest to the specified bounding box and returns using a success callback function. 
 * This information can then be used to set the map view to that streetside panorama.
 * @param {!Microsoft.Maps.LocationRect} bounds
 * @param {function(!Microsoft.Maps.IPanoramaInfo): void} success
 * @param {function(): void} missingCoverage
 * @return {void}
 */
Microsoft.Maps.Map.getClosestPanorama = function(bounds, success, missingCoverage) {};

/**
 * Returns the branch name; release, experimental, frozen.
 * @return {string}
 */
Microsoft.Maps.Map.getVersion = function() {};

/**
 * Deletes the Map object and releases any associated resources.
 * @return {void}
 */
Microsoft.Maps.Map.prototype.dispose = function() {};

/**
 * Gets the location rectangle that defines the boundaries of the current map view.
 * @return {!Microsoft.Maps.LocationRect} The location rectangle that defines the boundaries of the current map view.
 */
Microsoft.Maps.Map.prototype.getBounds = function() {};

/**
 * Gets the location of the center of the current map view.
 * @return {!Microsoft.Maps.Location} The location of the center of the current map view.
 */
Microsoft.Maps.Map.prototype.getCenter = function() {};

/**
 * Gets to the specified callback an array of strings representing the attributions of the imagery currently displayed on the map.
 * @param {function(!Array<string>): void} callback The callback function that needs to be called after retrieving the copyright information.
 * @return {void}
 */
Microsoft.Maps.Map.prototype.getCopyrights = function(callback) {};

/**
 * Gets the session ID. This method calls the callback function with the session ID as the first parameter
 * @param {function(string): void} callback The callback function that needs to be called with the session id.
 * @return {void}
 */
Microsoft.Maps.Map.prototype.getCredentials = function(callback) {};

/**
 * Gets the current culture.
 * @return {string} The current culture.
 */
Microsoft.Maps.Map.prototype.getCulture = function() {};

/**
 * Gets the height of the map control.
 * @return {number} The height of the map control.
 */
Microsoft.Maps.Map.prototype.getHeight = function() {};

/**
 * Returns the heading of the current map view.
 * @return {number} Returns the heading of the current map view.
 */
Microsoft.Maps.Map.prototype.getHeading = function() {};

/**
 * Gets the string that represents the imagery currently displayed on the map.
 * @return {string} The string that represents the imagery currently displayed on the map.
 */
Microsoft.Maps.Map.prototype.getImageryId = function() {};

/**
 * Gets a string that represents the current map type displayed on the map.
 * @return {Microsoft.Maps.MapTypeId} A string that represents the current map type displayed on the map.
 */
Microsoft.Maps.Map.prototype.getMapTypeId = function() {};

/**
 * Gets the current scale in meters per pixel of the center of the map.
 * @return {number} The current scale in meters per pixel of the center of the map.
 */
Microsoft.Maps.Map.prototype.getMetersPerPixel = function() {};

/**
 * Gets the map options that have been set.
 * @return {!Microsoft.Maps.IMapOptions} the map options that have been set.
 */
Microsoft.Maps.Map.prototype.getOptions = function() {};

/**
 * Gets the x coordinate of the top left corner of the map control, relative to the page.
 * @return {number} The x coordinate of the top left corner of the map control, relative to the page.
 */
Microsoft.Maps.Map.prototype.getPageX = function() {};

/**
 * Gets the y coordinate of the top left corner of the map control, relative to the page.
 * @return {number} The y coordinate of the top left corner of the map control, relative to the page.
 */
Microsoft.Maps.Map.prototype.getPageY = function() {};

/**
 * Returns the pitch of the current streetside map view.
 * @return {number} Returns the pitch of the current streetside map view.
 */
Microsoft.Maps.Map.prototype.getPitch = function() {};

/**
 * Gets the map root node.
 * @return {!HTMLElement} the map root node.
 */
Microsoft.Maps.Map.prototype.getRootElement = function() {};

/**
 * Gets the user region.
 * @return {string} The user region.
 */
Microsoft.Maps.Map.prototype.getUserRegion = function() {};

/**
 * Gets the width of the map control.
 * @return {number} the width of the map control.
 */
Microsoft.Maps.Map.prototype.getWidth = function() {};

/**
 * Gets the zoom level of the current map view.
 * @return {number} Returns the zoom level of the current map view.
 */
Microsoft.Maps.Map.prototype.getZoom = function() {};

/**
 * Gets the range of valid zoom levels for the current map view.
 * @return {!Microsoft.Maps.IRange} The range of valid zoom levels for the current map view.
 */
Microsoft.Maps.Map.prototype.getZoomRange = function() {};

/**
 * Gets a boolean indicating whether the map is in a regular Mercator nadir mode.
 * @return {boolean} A boolean indicating whether the map is in a regular Mercator nadir mode.
 */
Microsoft.Maps.Map.prototype.isMercator = function() {};

/**
 * Gets a boolean indicating if the current map type allows the heading to change; false if the display heading is fixed.
 * @return {boolean} true if the current map type allows the heading to change; false if the display heading is fixed.
 */
Microsoft.Maps.Map.prototype.isRotationEnabled = function() {};

/**
 * Sets the current map type.
 * @param {Microsoft.Maps.MapTypeId} mapTypeId The map imagery type of the map to set.
 * @return {void}
 */
Microsoft.Maps.Map.prototype.setMapType = function(mapTypeId) {};

/**
 * Sets the map options.
 * @param {!Microsoft.Maps.IMapOptions} options The map options to be set.
 * @return {void}
 */
Microsoft.Maps.Map.prototype.setOptions = function(options) {};

/**
 * Sets the view of the map.
 * @param {!Microsoft.Maps.IViewOptions} viewOptions The view options to be set.
 * @return {void}
 */
Microsoft.Maps.Map.prototype.setView = function(viewOptions) {};

/**
 * Converts a specified Location or a Location array to a Point or Point array on the map
 * relative to the specified PixelReference. If no reference is specified, PixelReference.viewport
 * is taken.
 * @param {(!Microsoft.Maps.Location|!Array<!Microsoft.Maps.Location>)} location The given Location or Location[] to convert.
 * @param {?=} reference The PixelReference to specify the reference point.
 * @return {(!Microsoft.Maps.Point|!Array<!Microsoft.Maps.Point>)} The converted Point or Point[], or null if the conversion fails.
 */
Microsoft.Maps.Map.prototype.tryLocationToPixel = function(location, reference) {};

/**
 * Converts a specified Point or a Point array to a Location or Location array on the map
 * relative to the specified PixelReference. If no reference is specified, PixelReference.viewport
 * is taken.
 * @param {(!Microsoft.Maps.Point|!Array<!Microsoft.Maps.Point>)} point The given Point or Point[] to convert.
 * @param {?=} reference The PixelReference to specify the reference point.
 * @return {(!Microsoft.Maps.Location|!Array<!Microsoft.Maps.Location>)} The converted Location or Location[], or null if the conversion fails.
 */
Microsoft.Maps.Map.prototype.tryPixelToLocation = function(point, reference) {};

/**
 * @constructor
 * @struct
 * @param {number} x The x coordinate.
 * @param {number} y The y coordinate.
 */
Microsoft.Maps.Point = function(x, y) {};
 /** @type {number} */
Microsoft.Maps.Point.prototype.x;
 /** @type {number} */
Microsoft.Maps.Point.prototype.y;

/**
 * Adds the x and y values of two points and returns a new Point.
 * @param {!Microsoft.Maps.Point} point The point to add.
 * @return {!Microsoft.Maps.Point} A new point created by the sum of two points.
 */
Microsoft.Maps.Point.prototype.add = function(point) {};

/**
 * Creates a copy of the current point.
 * @return {!Microsoft.Maps.Point} A new instance of the current point.
 */
Microsoft.Maps.Point.prototype.clone = function() {};

/**
 * Compares the x and y values of two points to see if they are equal. If a tolerance value is specified, it checks to see if the linear distance between the points is less than or equal to the tolerance value.
 * @param {!Microsoft.Maps.Point} point The point to compare to.
 * @param {number=} tolerance Optional, tolerance (>= 0) to avoid false result because of floating point errors.
 * @return {boolean} true if this point equals point, false otherwise
 */
Microsoft.Maps.Point.prototype.equals = function(point, tolerance) {};

/**
 * Subtracts the x and y values of a points and returns a new Point.
 * @param {!Microsoft.Maps.Point} point The point to subtract.
 * @return {!Microsoft.Maps.Point} A new point created by the subtraction of two points.
 */
Microsoft.Maps.Point.prototype.subtract = function(point) {};

/**
 * Converts the Point to a string representation.
 * @return {string} A string representation of the point.
 */
Microsoft.Maps.Point.prototype.toString = function() {};
/**
 * @constructor
 * @struct
 */
Microsoft.Maps.PointCompression = function() {};

/**
 * Decodes a collection of locations from a compressed string.
 * @param {string} value Compressed string to decode.
 * @return {!Array<!Microsoft.Maps.Location>} An array of locations that have been decoded from the compressed string.
 */
Microsoft.Maps.PointCompression.decode = function(value) {};

/**
 * Compresses an array of locations into a string.
 * @param {!Array<!Microsoft.Maps.Location>} locations Collection of coordinates to compress.
 * @return {string} A compressed string representing an array of locations.
 */
Microsoft.Maps.PointCompression.encode = function(locations) {};

/**
 * @constructor
 * @struct
 * @param {(!Array<!Microsoft.Maps.Location>|!Array<!Array<!Microsoft.Maps.Location>>)} rings A Location array for basic polygon with single outer perimeter,
 * or an array of Location arrays for advanced polygon (multi-polygon, polygon with holes, or combination of polygons).
 * @param {!Microsoft.Maps.IPolygonOptions=} options Options used to customize polygon.
 */
Microsoft.Maps.Polygon = function(rings, options) {};
 /** @type {?} */
Microsoft.Maps.Polygon.prototype.metadata;

/**
 * Gets the css cursor value when polygon has events on it.
 * @return {string} CSS cursor string when polygon has events on it.
 */
Microsoft.Maps.Polygon.prototype.getCursor = function() {};

/**
 * Gets the fill color of the inside of the polygon. Will be string or Color object depending on the the what method was used in the pushpin options.
 * @return {(string|!Microsoft.Maps.Color)} The fill color of the inside of the polygon.
 */
Microsoft.Maps.Polygon.prototype.getFillColor = function() {};

/**
 * Returns whether the polygon is generalizable based on zoom level or not.
 * @return {boolean} whether the polygon is generalizable based on zoom level or not.
 */
Microsoft.Maps.Polygon.prototype.getGeneralizable = function() {};

/**
 * Gets the first ring of the polygon (for V7 compatability).
 * @return {!Array<!Microsoft.Maps.Location>} An array of Locations that is the first ring of the polygon; or an empty array if the polygon has no ring at all.
 */
Microsoft.Maps.Polygon.prototype.getLocations = function() {};

/**
 * Gets an array of location arrays, where each location array defines a ring of the polygon.
 * @return {!Array<!Array<!Microsoft.Maps.Location>>} An array of location arrays, where each location array defines a ring of the polygon.
 */
Microsoft.Maps.Polygon.prototype.getRings = function() {};

/**
 * Gets the color of the border stroke of the polygon. Will be string or Color object depending on the the what method was used in the pushpin options.
 * @return {(string|!Microsoft.Maps.Color)} The color of the border stroke of the polygon.
 */
Microsoft.Maps.Polygon.prototype.getStrokeColor = function() {};

/**
 * Gets the stroke dash array of the polygon, in format of either array or string, whichever user provides.
 * @return {(string|!Array<number>)} The stroke dash array of the polygon.
 */
Microsoft.Maps.Polygon.prototype.getStrokeDashArray = function() {};

/**
 * Gets the thickness of the border stroke of the polygon.
 * @return {number} The thickness of the border stroke of the polygon as a number.
 */
Microsoft.Maps.Polygon.prototype.getStrokeThickness = function() {};

/**
 * Gets whether the polygon is visible.
 * @return {boolean} A boolean indicating whether the polygon is visible or not.
 */
Microsoft.Maps.Polygon.prototype.getVisible = function() {};

/**
 * Sets locations (single ring) of the polygon. (for V7 compatability)
 * @param {!Array<!Microsoft.Maps.Location>} locations A Location[] that defines the only ring of the polygon
 * @return {void}
 */
Microsoft.Maps.Polygon.prototype.setLocations = function(locations) {};

/**
 * Sets the properties for the polygon.
 * @param {!Microsoft.Maps.IPolygonOptions} options The IPolygonOptions object containing the options to customize the polygon.
 * @return {void}
 */
Microsoft.Maps.Polygon.prototype.setOptions = function(options) {};

/**
 * Sets rings of the polygon.
 * @param {(!Array<!Microsoft.Maps.Location>|!Array<!Array<!Microsoft.Maps.Location>>)} rings A Location[][] where each Location[] defines a ring of the polygon.
 * @return {void}
 */
Microsoft.Maps.Polygon.prototype.setRings = function(rings) {};

/**
 * @constructor
 * @struct
 * @param {!Array<!Microsoft.Maps.Location>} locations An array of locations that make up the path of the polyine.
 * @param {!Microsoft.Maps.IPolylineOptions=} options Options used to customize polyline.
 */
Microsoft.Maps.Polyline = function(locations, options) {};
 /** @type {?} */
Microsoft.Maps.Polyline.prototype.metadata;

/**
 * Gets the css cursor value when polyline has events on it.
 * @return {string} CSS cursor string when polyline has events on it.
 */
Microsoft.Maps.Polyline.prototype.getCursor = function() {};

/**
 * Returns whether the polyline is generalizable based on zoom level or not.
 * @return {boolean} whether the polyline is generalizable based on zoom level or not.
 */
Microsoft.Maps.Polyline.prototype.getGeneralizable = function() {};

/**
 * Gets the locations that make up the polyline.
 * @return {!Array<!Microsoft.Maps.Location>} An array that defines the path of the polyline.
 */
Microsoft.Maps.Polyline.prototype.getLocations = function() {};

/**
 * Gets the color of the border stroke of the polyline. Will be string or Color object depending on the the what method was used in the polyline options.
 * @return {(string|!Microsoft.Maps.Color)} The stroke color of the polyline.
 */
Microsoft.Maps.Polyline.prototype.getStrokeColor = function() {};

/**
 * Gets the stroke dash array of the polyline, in format of either array or string, whichever user provides.
 * @return {(string|!Array<number>)} The stroke dash array of the polyline.
 */
Microsoft.Maps.Polyline.prototype.getStrokeDashArray = function() {};

/**
 * Gets the thickness of the border stroke of the polyline.
 * @return {number} The thickness of the border stroke of the polyline as a number.
 */
Microsoft.Maps.Polyline.prototype.getStrokeThickness = function() {};

/**
 * Gets whether the polyline is visible.
 * @return {boolean} A boolean indicating whether the polyline is visible or not.
 */
Microsoft.Maps.Polyline.prototype.getVisible = function() {};

/**
 * Sets locations of the polyline.
 * @param {!Array<!Microsoft.Maps.Location>} locations A Location[] that defines path of the polyline
 * @return {void}
 */
Microsoft.Maps.Polyline.prototype.setLocations = function(locations) {};

/**
 * Sets the properties for the polyline.
 * @param {!Microsoft.Maps.IPolylineOptions} options The IPolylineOptions object containing the options to customize the polyline.
 * @return {void}
 */
Microsoft.Maps.Polyline.prototype.setOptions = function(options) {};

/**
 * @constructor
 * @struct
 * @param {!Microsoft.Maps.Location} location A Location object that specifies where to display the pushpin.
 * @param {!Microsoft.Maps.IPushpinOptions=} options Options used when creating the Pushpin.
 */
Microsoft.Maps.Pushpin = function(location, options) {};
 /** @type {?} */
Microsoft.Maps.Pushpin.prototype.metadata;

/**
 * Gets the point on the Pushpin icon which is anchored to the pushpin location.
 * An anchor of (0,0) is the top left corner of the icon.
 * @return {!Microsoft.Maps.Point} The point on the Pushpin icon which is anchored to the pushpin location.
 */
Microsoft.Maps.Pushpin.prototype.getAnchor = function() {};

/**
 * Gets whether the pushpin clicked style is enabled
 * @return {boolean} Whether the pushpin clicked style is enabled.
 */
Microsoft.Maps.Pushpin.prototype.getClickedStyleEnabled = function() {};

/**
 * Gets the color option of the pushpin.
 * @return {(string|!Microsoft.Maps.Color)} The color option of the pushpin.
 */
Microsoft.Maps.Pushpin.prototype.getColor = function() {};

/**
 * Gets the css cursor value when pushpin has events on it.
 * @return {string} CSS cursor string when pushpin has events on it.
 */
Microsoft.Maps.Pushpin.prototype.getCursor = function() {};

/**
 * Gets a boolean indicating if the pushpin is draggable or not.
 * @return {boolean} A boolean indicating if the pushpin is draggable or not.
 */
Microsoft.Maps.Pushpin.prototype.getDraggable = function() {};

/**
 * Gets whether the pushpin hover style is enabled
 * @return {boolean} Whether the pushpin hover style is enabled.
 */
Microsoft.Maps.Pushpin.prototype.getHoverStyleEnabled = function() {};

/**
 * Gets the custom Pushpin source icon string which can be a url to an image or SVG, inline SVG string, or data URI.
 * @return {string} the custom Pushpin icon source string, which can be a url to an image or SVG, inline SVG string, or data URI.
 */
Microsoft.Maps.Pushpin.prototype.getIcon = function() {};

/**
 * Returns the location of the pushpin.
 * @return {!Microsoft.Maps.Location} The location of the pushpin.
 */
Microsoft.Maps.Pushpin.prototype.getLocation = function() {};

/**
 * Returns whether the clickable area of the pushpin is an ellipse.
 * @return {boolean} A boolean indicating whether the clickable area of the pushpin is an ellipse.
 */
Microsoft.Maps.Pushpin.prototype.getRoundClickableArea = function() {};

/**
 * Gets the subtitle label of the Pushpin.
 * @return {string} The subtitle label of the Pushpin.
 */
Microsoft.Maps.Pushpin.prototype.getSubTitle = function() {};

/**
 * Gets the text within the Pushpin icon.
 * @return {string} The text within the Pushpin icon.
 */
Microsoft.Maps.Pushpin.prototype.getText = function() {};

/**
 * Gets the amount the text is shifted from the Pushpin icon.
 * @return {!Microsoft.Maps.Point} the amount the text is shifted from the Pushpin icon.
 */
Microsoft.Maps.Pushpin.prototype.getTextOffset = function() {};

/**
 * Gets the title label of the Pushpin.
 * @return {string} the title label of the Pushpin.
 */
Microsoft.Maps.Pushpin.prototype.getTitle = function() {};

/**
 * Gets whether the pushpin is visible.
 * @return {boolean} A boolean indicating whether the pushpin is visible or not.
 */
Microsoft.Maps.Pushpin.prototype.getVisible = function() {};

/**
 * Sets the location of the Pushpin.
 * @param {!Microsoft.Maps.Location} location The location of the Pushpin.
 * @return {void}
 */
Microsoft.Maps.Pushpin.prototype.setLocation = function(location) {};

/**
 * Sets the properties for the pushpin.
 * @param {!Microsoft.Maps.IPushpinOptions} options The IPushpinOptions object containing the options to customize the pushpin.
 * @return {void}
 */
Microsoft.Maps.Pushpin.prototype.setOptions = function(options) {};

/**
 * @constructor
 * @struct
 * @param {number} x The integer x position of the tile within the tile layer at the specified zoom level.
 * @param {number} y The integer y position of the tile within the tile layer at the specified zoom level.
 * @param {number} zoom The zoom level of the tile.
 * @param {number=} width The tile's width in pixels. Default value: 256
 * @param {number=} height The tile's height in pixels. Default value: 256
 */
Microsoft.Maps.PyramidTileId = function(x, y, zoom, width, height) {};
 /** @type {number} */
Microsoft.Maps.PyramidTileId.prototype.pixelHeight;
 /** @type {number} */
Microsoft.Maps.PyramidTileId.prototype.pixelWidth;
 /** @type {string} */
Microsoft.Maps.PyramidTileId.prototype.quadKey;
 /** @type {number} */
Microsoft.Maps.PyramidTileId.prototype.x;
 /** @type {number} */
Microsoft.Maps.PyramidTileId.prototype.y;
 /** @type {number} */
Microsoft.Maps.PyramidTileId.prototype.zoom;

/**
 * Compares two PyramidTileId objects and returns a boolean indicating if the two PyramidTileId are equal.
 * @param {!Microsoft.Maps.PyramidTileId} tileId1 The first PyramidTileId to compare to the second.
 * @param {!Microsoft.Maps.PyramidTileId} tileId2 The second PyramidTileId to compare to the first.
 * @return {boolean} A boolean indicating if the two PyramidTileId are equal.
 */
Microsoft.Maps.PyramidTileId.areEqual = function(tileId1, tileId2) {};

/**
 * Generates a PyramidTileId from a quadkey tile id string. 
 * @param {string} quadkey The quadkey tile id string to convert into a PyramidTileId object.
 * @param {number=} width The tile's width in pixels. Default value: 256
 * @param {number=} height The tile's height in pixels. Default value: 256
 * @return {!Microsoft.Maps.PyramidTileId}
 */
Microsoft.Maps.PyramidTileId.fromQuadKey = function(quadkey, width, height) {};
/**
 * @constructor
 * @struct
 */
Microsoft.Maps.TestDataGenerator = function() {};

/**
 * Generates a random hex or rgba color string. 
 * @param {boolean=} withAlpha A boolean indicating if the color should have an alpha value or not. if set to true, a rgba value will be returned with an alpha value of 0.5.
 * @return {string} A css color string, hex or rgba.
 */
Microsoft.Maps.TestDataGenerator.getColor = function(withAlpha) {};

/**
 * Generates random Location objects.
 * @param {number=} num The number of locations to generate. If set to one a single Location will be returned. If greater than one and array will be returned.
 * @param {!Microsoft.Maps.LocationRect=} bounds The bounding box in which all the locations should fall within.
 * @return {(!Microsoft.Maps.Location|!Array<!Microsoft.Maps.Location>)} One or more random Locations.
 */
Microsoft.Maps.TestDataGenerator.getLocations = function(num, bounds) {};

/**
 * Generates random pushpins.
 * @param {number=} num The number of pushpins to generate. If set to one a single Pushpin will be returned. If greater than one and array will be returned.
 * @param {!Microsoft.Maps.LocationRect=} bounds The bounding box in which all the pushpins should fall within.
 * @param {!Microsoft.Maps.IPushpinOptions=} options The options to use for rendering the pushpins. Default is random.
 * @return {(!Microsoft.Maps.Pushpin|!Array<!Microsoft.Maps.Pushpin>)} One or more random Pushpins.
 */
Microsoft.Maps.TestDataGenerator.getPushpins = function(num, bounds, options) {};

/**
 * Generates random polylines.
 * @param {number=} num The number of polylines to generate. If set to one a single Polyline will be returned. If greater than one and array will be returned.
 * @param {!Microsoft.Maps.LocationRect=} bounds The bounding box in which all the locations of the polylines should fall within.
 * @param {number=} size The number of locations each polylines should have. Default: random between 3 and 10.
 * @param {number=} scaleFactor A number that scales the size of the polylines based on size of the bounding box. A value of 0.1 would generate polylines that are no larger than 10% of the width/height of the map. Default: 0.1
 * @param {!Microsoft.Maps.IPolylineOptions=} options The options to use for rendering the polylines. Default is random.
 * @return {(!Microsoft.Maps.Polyline|!Array<!Microsoft.Maps.Polyline>)} One or more random Polylines.
 */
Microsoft.Maps.TestDataGenerator.getPolylines = function(num, bounds, size, scaleFactor, options) {};

/**
 * Generates random polygons.
 * @param {number=} num The number of polygons to generate. If set to one a single Polygon will be returned. If greater than one and array will be returned.
 * @param {!Microsoft.Maps.LocationRect=} bounds The bounding box in which all the locations of the polygon should fall within.
 * @param {number=} size The number of locations each polygon should have. Default: random between 3 and 10.
 * @param {number=} scaleFactor A number that scales the size of the polygons based on the size of the bounding box. A value of 0.1 would generate polygons that are no larger than 10% of the width/height of the map. Default: 0.1
 * @param {!Microsoft.Maps.IPolygonOptions=} options The options to use for rendering the polygons. Default is random.
 * @param {boolean=} addHole A boolean indicating if the generated polygon should have a hole or not. Note that this will double the number of Location objects that are in the Polygon. Default: false
 * @return {(!Microsoft.Maps.Polygon|!Array<!Microsoft.Maps.Polygon>)} One or more random polygons.
 */
Microsoft.Maps.TestDataGenerator.getPolygons = function(num, bounds, size, scaleFactor, options, addHole) {};

/**
 * @constructor
 * @struct
 * @param {!Microsoft.Maps.ITileLayerOptions} options The options to use to define the tile layer.
 */
Microsoft.Maps.TileLayer = function(options) {};

/**
 * Gets the opacity of the tile layer, defined as a double between 0 (not visible) and 1.
 * @return {number} The opacity of the tile layer, defined as a double between 0 (not visible) and 1.
 */
Microsoft.Maps.TileLayer.prototype.getOpacity = function() {};

/**
 * Gets the tile source of the tile layer.
 * @return {!Microsoft.Maps.TileSource} The tile source of the tile layer.
 */
Microsoft.Maps.TileLayer.prototype.getTileSource = function() {};

/**
 * Gets a boolean that indicates if the tile layer is visible or not.
 * @return {boolean} A boolean that indicates if the tile layer is visible or not.
 */
Microsoft.Maps.TileLayer.prototype.getVisible = function() {};

/**
 * Gets the zIndex of the tile layer.
 * @return {number} The zIndex of the tile layer.
 */
Microsoft.Maps.TileLayer.prototype.getZIndex = function() {};

/**
 * Sets the opacity of the tile layer. Value must be a number between 0 and 1.
 * @param {number} opacity The opacity of the tile layer. Value must be a number between 0 and 1.
 * @return {void}
 */
Microsoft.Maps.TileLayer.prototype.setOpacity = function(opacity) {};

/**
 * Sets options for the tile layer.
 * @param {!Microsoft.Maps.ITileLayerOptions} options The options for the tile layer.
 * @return {void}
 */
Microsoft.Maps.TileLayer.prototype.setOptions = function(options) {};

/**
 * Sets the visibility of the tile layer.
 * @param {boolean} show A boolean indicating if the tile layer should be visible or not.
 * @return {void}
 */
Microsoft.Maps.TileLayer.prototype.setVisible = function(show) {};

/**
 * Sets the zIndex of the tile layer.
 * @param {number} idx The zIndex of the tile layer.
 * @return {void}
 */
Microsoft.Maps.TileLayer.prototype.setZIndex = function(idx) {};

/**
 * @constructor
 * @struct
 * @param {!Microsoft.Maps.ITileSourceOptions} options The options to use to define the tile source.
 */
Microsoft.Maps.TileSource = function(options) {};

/**
 * Gets the specified bounding box of the of the tile source.
 * @return {!Microsoft.Maps.LocationRect} The specified bounding box of the of the tile source.
 */
Microsoft.Maps.TileSource.prototype.getBounds = function() {};

/**
 * Gets the pixel height of each tile in the tile source.
 * @return {number} The pixel height of each tile in the tile source.
 */
Microsoft.Maps.TileSource.prototype.getHeight = function() {};

/**
 * Gets the maximum zoom level specified for the tile source.
 * @return {number} The maximum zoom level specified for the tile source.
 */
Microsoft.Maps.TileSource.prototype.getMaxZoom = function() {};

/**
 * Gets the minimum zoom level specified for the tile source.
 * @return {number} The minimum zoom level specified for the tile source.
 */
Microsoft.Maps.TileSource.prototype.getMinZoom = function() {};

/**
 * Gets a string that constructs tile URLs used to retrieve tiles for the tile layer.
 * @return {(string|function(!Microsoft.Maps.PyramidTileId): string)} A string that constructs tile URLs used to retrieve tiles for the tile layer.
 */
Microsoft.Maps.TileSource.prototype.getUriConstructor = function() {};

/**
 * Gets the pixel width of each tile in the tile source.
 * @return {number} The pixel width of each tile in the tile source.
 */
Microsoft.Maps.TileSource.prototype.getWidth = function() {};
