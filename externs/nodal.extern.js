/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/nodal/index.d.ts:

/* TODO: ImportDeclaration in  */
/**
 * @constructor
 * @struct
 */
function APIConstructor() {}

/**
 * @param {?} obj
 * @param {!Array<string>=} arrInterface
 * @return {?}
 */
APIConstructor.prototype.format = function(obj, arrInterface) {};

/**
 * @param {number} total
 * @param {number} count
 * @param {number} offset
 * @param {?} error
 * @param {string=} summary
 * @param {?=} resource
 * @return {?}
 */
APIConstructor.prototype.meta = function(total, count, offset, error, summary, resource) {};

/**
 * @param {string} message
 * @param {string} details
 * @return {?}
 */
APIConstructor.prototype.error = function(message, details) {};

/**
 * @param {?} obj
 * @param {boolean=} useResource
 * @return {?}
 */
APIConstructor.prototype.spoof = function(obj, useResource) {};

/**
 * @param {?} itemArray
 * @param {?} arrInterface
 * @param {boolean=} useResource
 * @return {?}
 */
APIConstructor.prototype.response = function(itemArray, arrInterface, useResource) {};

/**
 * @param {!Array<?>} arr
 * @return {?}
 */
APIConstructor.prototype.resourceFromArray = function(arr) {};

/**
 * @param {?} modelArray
 * @param {?} arrInterface
 * @return {?}
 */
APIConstructor.prototype.resourceFromModelArray = function(modelArray, arrInterface) {};
 /** @type {?} */
var API;
 /** @type {?} */
var APIResource;

/**
 * @constructor
 * @struct
 */
function Application() {}

/**
 * HTTP Error
 * @param {?} req
 * @param {?} res
 * @param {?} start
 * @param {number} status
 * @param {string} message
 * @param {?} err
 * @return {void}
 */
Application.prototype.error = function(req, res, start, status, message, err) {};
/**
 * @constructor
 * @struct
 */
function Controller() {}

/**
 * Set HTTP status code for this response. If OPTIONS mode, default to 200.
 * @param {number} value
 * @return {boolean}
 */
Controller.prototype.status = function(value) {};

/**
 * Using API formatting, send an http.ServerResponse indicating there was a Bad Request (400)
 * @param {string} msg
 * @param {?} details
 * @return {boolean}
 */
Controller.prototype.badRequest = function(msg, details) {};

/**
 * Using API formatting, send an http.ServerResponse indicating there was an Unauthorized request (401)
 * @param {string} msg
 * @param {?} details
 * @return {boolean}
 */
Controller.prototype.unauthorized = function(msg, details) {};

/**
 * Using API formatting, send an http.ServerResponse indicating the requested resource was Not Found (404)
 * @param {string} msg
 * @param {?} details
 * @return {boolean}
 */
Controller.prototype.notFound = function(msg, details) {};

/**
 * Endpoint not implemented
 * @param {string} msg
 * @param {?} details
 * @return {boolean}
 */
Controller.prototype.notImplemented = function(msg, details) {};

/**
 * Using API formatting, send an http.ServerResponse indicating there were Too Many Requests (429) (i.e. the client is being rate limited)
 * @param {string} msg
 * @param {?} details
 * @return {boolean}
 */
Controller.prototype.tooManyRequests = function(msg, details) {};

/**
 * Using API formatting, send an http.ServerResponse indicating there was an Internal Server Error (500)
 * @param {string} msg
 * @param {?} details
 * @return {boolean}
 */
Controller.prototype.error = function(msg, details) {};

/**
 * Using API formatting, generate an error or respond with model / object data.
 * @param {(!Object|!Array<?>|!Error|?)} data
 * @param {!Array<string>=} arrInterface
 * @return {boolean}
 */
Controller.prototype.respond = function(data, arrInterface) {};
/**
 * @record
 * @struct
 */
function IComparison() {}

/* TODO: IndexSignature:  */
 /** @type {string} */
IComparison.prototype.__order;
 /** @type {number} */
IComparison.prototype.__offset;
 /** @type {number} */
IComparison.prototype.__count;

/**
 * @constructor
 * @struct
 * Created by Model#query, used for composing SQL queries based on Models
 * @param {?} modelConstructor
 * @param {?=} parent
 */
function Composer(modelConstructor, parent) {}
 /** @type {?} */
Composer.prototype.db;
 /** @type {?} */
Composer.prototype.Model;
 /** @type {?} */
Composer.prototype._parent;
 /** @type {?} */
Composer.prototype._command;

/**
 * Given rows with repeated data (due to joining in multiple children),
 * return only parent models (but include references to their children)
 * @param {?} rows
 * @param {?=} grouped
 * @return {?}
 */
Composer.prototype.__parseModelsFromRows__ = function(rows, grouped) {};

/**
 * Collapses linked list of queries into an array (for .reduce, .map etc)
 * @return {?}
 */
Composer.prototype.__collapse__ = function() {};

/**
 * Removes last limit command from a collapsed array of composer commands
 * @param {?} composerArray
 * @return {?}
 */
Composer.prototype.__removeLastLimitCommand__ = function(composerArray) {};

/**
 * Gets last limit command from a collapsed array of composer commands
 * @param {?} composerArray
 * @return {?}
 */
Composer.prototype.__getLastLimitCommand__ = function(composerArray) {};

/**
 * Determines whether this composer query represents a grouped query or not
 * @return {?}
 */
Composer.prototype.__isGrouped__ = function() {};

/**
 * Reduces an array of composer queries to a single query information object
 * @param {?} composerArray
 * @return {?}
 */
Composer.prototype.__reduceToQueryInformation__ = function(composerArray) {};

/**
 * Reduces an array of commands from query informtion to a SQL query
 * @param {?} commandArray
 * @param {?=} includeColumns
 * @return {?}
 */
Composer.prototype.__reduceCommandsToQuery__ = function(commandArray, includeColumns) {};

/**
 * Retrieve all joined column data for a given join
 * @param {?} joinName
 * @return {?}
 */
Composer.prototype.__joinedColumns__ = function(joinName) {};

/**
 * Generate a SQL query and its associated parameters from the current composer instance
 * @param {?=} includeColumns
 * @param {?=} disableJoins
 * @return {?}
 */
Composer.prototype.__generateQuery__ = function(includeColumns, disableJoins) {};

/**
 * Generate a SQL count query
 * @param {?=} useLimit
 * @return {?}
 */
Composer.prototype.__generateCountQuery__ = function(useLimit) {};

/**
 * Add Joins to a query from queryInfo
 * @param {?} query
 * @param {?} queryInfo
 * @param {?=} includeColumns
 * @return {?}
 */
Composer.prototype.__addJoinsToQuery__ = function(query, queryInfo, includeColumns) {};

/**
 * When using Composer#where, format all provided comparisons
 * @param {?} comparisons
 * @param {?=} model
 * @return {?}
 */
Composer.prototype.__parseComparisons__ = function(comparisons, model) {};

/**
 * @param {?} modelConstructor
 * @param {?} comparisonsArray
 * @return {?}
 */
Composer.prototype.__filterHidden__ = function(modelConstructor, comparisonsArray) {};

/**
 * Add comparisons to SQL WHERE clause. Does not allow filtering if Model.hides() has been called.
 * @param {...?} comparisonsArray
 * @return {?}
 */
Composer.prototype.safeWhere = function(comparisonsArray) {};

/**
 * Join in a relationship. Filters out hidden fields from comparisons.
 * @param {string} joinName
 * @param {...?} comparisonsArray
 * @return {?}
 */
Composer.prototype.safeJoin = function(joinName, comparisonsArray) {};

/**
 * Add comparisons to SQL WHERE clause.
 * @param {...?} comparisonsArray
 * @return {?}
 */
Composer.prototype.where = function(comparisonsArray) {};

/**
 * Order by field belonging to the current Composer instance's model.
 * @param {string} field
 * @param {?=} direction
 * @return {?}
 */
Composer.prototype.orderBy = function(field, direction) {};

/**
 * Limit to an offset and count
 * @param {(string|number)} offset
 * @param {(string|number)=} count
 * @return {?}
 */
Composer.prototype.limit = function(offset, count) {};

/**
 * Join in a relationship.
 * @param {string} joinName
 * @param {(?|!Array<?>)=} comparisonsArray
 * @param {string=} orderBy
 * @param {number=} count
 * @param {number=} offset
 * @return {?}
 */
Composer.prototype.join = function(joinName, comparisonsArray, orderBy, count, offset) {};

/**
 * Groups by a specific field, or a transformation on a field
 * @param {string} column
 * @return {?}
 */
Composer.prototype.groupBy = function(column) {};

/**
 * Aggregates a field
 * @param {string} alias
 * @param {!Function=} transformation
 * @return {?}
 */
Composer.prototype.aggregate = function(alias, transformation) {};

/**
 * Counts the results in the query
 * @param {?} callback
 * @return {void}
 */
Composer.prototype.count = function(callback) {};

/**
 * Execute the query you've been composing.
 * @param {?} callback
 * @return {void}
 */
Composer.prototype.end = function(callback) {};

/**
 * Shortcut for .limit(1).end(callback) that only returns a model object or error if not found
 * @param {?} callback
 * @return {void}
 */
Composer.prototype.first = function(callback) {};

/**
 * Execute query as an update query, changed all fields specified.
 * @param {?} fields
 * @param {?} callback
 * @return {void}
 */
Composer.prototype.update = function(fields, callback) {};
 /** @type {?} */
var CLI;

/**
 * @constructor
 * @struct
 */
function Daemon() {}

/**
 * @param {?} req
 * @param {?} res
 * @param {?} err
 * @return {void}
 */
Daemon.prototype.error = function(req, res, err) {};

/**
 * @constructor
 * @struct
 */
function Database() {}
 /** @type {?} */
Database.prototype.adapter;
 /** @type {!Array<!Function>} */
Database.prototype.__logColorFuncs;
 /** @type {?} */
Database.prototype._useLogColor;

/**
 * @param {?} cfg
 * @return {boolean}
 */
Database.prototype.connect = function(cfg) {};

/**
 * @param {!Function} callback
 * @return {boolean}
 */
Database.prototype.close = function(callback) {};

/**
 * @param {string} sql
 * @param {?=} params
 * @param {number=} time
 * @return {boolean}
 */
Database.prototype.log = function(sql, params, time) {};

/**
 * @param {string} message
 * @return {void}
 */
Database.prototype.info = function(message) {};

/**
 * @param {string} message
 * @return {boolean}
 */
Database.prototype.error = function(message) {};

/**
 * @param {...?} args
 * @return {void}
 */
Database.prototype.query = function(args) {};

/**
 * @param {...?} args
 * @return {void}
 */
Database.prototype.transaction = function(args) {};

/**
 * @return {void}
 */
Database.prototype.drop = function() {};

/**
 * @return {void}
 */
Database.prototype.create = function() {};

/**
 * @constructor
 * @struct
 * Create a GraphQuery object
 * @param {string} str
 * @param {number} maxDepth
 * @param {?=} mModel
 */
function GraphQuery(str, maxDepth, mModel) {}

/* TODO: PropertyDeclaration: 'constructor' */
 /** @type {string} */
GraphQuery.prototype.identifier;
 /** @type {string} */
GraphQuery.prototype.name;
 /** @type {?} */
GraphQuery.prototype.Model;
 /** @type {?} */
GraphQuery.prototype.structure;
 /** @type {?} */
GraphQuery.prototype.joins;

/**
 * Create and execute a GraphQuery object
 * @param {string} str
 * @param {number} maxDepth
 * @param {!Function} callback
 * @return {boolean}
 */
GraphQuery.query = function(str, maxDepth, callback) {};

/**
 * Parse syntax tree of a GraphQL query
 * @param {string} str
 * @param {string=} state
 * @param {!Array<?>=} arr
 * @return {?}
 */
GraphQuery.parseSyntaxTree = function(str, state, arr) {};

/**
 * Fully parse a GraphQL query, get necessary joins to make in SQL
 * @param {string} str
 * @param {number} max
 * @return {?}
 */
GraphQuery.parse = function(str, max) {};

/**
 * Format a parsed syntax tree in a way that the Composer expects
 * @param {!Array<?>} tree
 * @param {number} max
 * @param {?} joins
 * @param {?=} parents
 * @return {!Array<?>}
 */
GraphQuery.formatTree = function(tree, max, joins, parents) {};

/**
 * Query the GraphQuery object from the database
 * @param {!Function} callback
 * @return {?}
 */
GraphQuery.prototype.query = function(callback) {};
/**
 * @record
 * @struct
 */
function IArrayMetadata() {}
 /** @type {number} */
IArrayMetadata.prototype.total;
 /** @type {number} */
IArrayMetadata.prototype.offset;

/* TODO: IndexSignature:  */

/**
 * @constructor
 * @struct
 */
function ItemArray() {}
 /** @type {?} */
ItemArray.prototype._meta;

/**
 * @param {!Array<!Object>} arr
 * @return {?}
 */
ItemArray.from = function(arr) {};

/**
 * @param {?} data
 * @return {?}
 */
ItemArray.prototype.setMeta = function(data) {};

/**
 * @param {!Array<string>} arrInterface
 * @return {!Object}
 */
ItemArray.prototype.toObject = function(arrInterface) {};

/**
 * @constructor
 * @struct
 * @param {?} db
 */
function Migration(db) {}
 /** @type {?} */
Migration.prototype.db;
 /** @type {?} */
Migration.prototype.id;
 /** @type {?} */
Migration.prototype.schema;

/**
 * @return {!Array<string>}
 */
Migration.prototype.up = function() {};

/**
 * @return {!Array<string>}
 */
Migration.prototype.down = function() {};

/**
 * @param {?} callback
 * @return {void}
 */
Migration.prototype.executeUp = function(callback) {};

/**
 * @param {?} callback
 * @param {string=} prevId
 * @return {void}
 */
Migration.prototype.executeDown = function(callback, prevId) {};

/**
 * @param {string} table
 * @param {!Array<!Object>} arrFieldData
 * @param {string} modelName
 * @return {?}
 */
Migration.prototype.createTable = function(table, arrFieldData, modelName) {};

/**
 * @param {string} table
 * @return {?}
 */
Migration.prototype.dropTable = function(table) {};

/**
 * @param {string} table
 * @param {string} newTableName
 * @param {string} renameModel
 * @param {string} newModelName
 * @return {?}
 */
Migration.prototype.renameTable = function(table, newTableName, renameModel, newModelName) {};

/**
 * @param {string} table
 * @param {string} column
 * @param {string} type
 * @param {?} properties
 * @return {?}
 */
Migration.prototype.alterColumn = function(table, column, type, properties) {};

/**
 * @param {string} table
 * @param {string} column
 * @param {string} type
 * @param {?} properties
 * @return {?}
 */
Migration.prototype.addColumn = function(table, column, type, properties) {};

/**
 * @param {string} table
 * @param {string} column
 * @return {?}
 */
Migration.prototype.dropColumn = function(table, column) {};

/**
 * @param {string} table
 * @param {string} column
 * @param {string} newColumn
 * @return {?}
 */
Migration.prototype.renameColumn = function(table, column, newColumn) {};

/**
 * @param {string} table
 * @param {string} column
 * @param {string} type
 * @return {?}
 */
Migration.prototype.createIndex = function(table, column, type) {};

/**
 * @param {string} table
 * @param {string} column
 * @return {?}
 */
Migration.prototype.dropIndex = function(table, column) {};

/**
 * @param {string} table
 * @param {string} referenceTable
 * @return {?}
 */
Migration.prototype.addForeignKey = function(table, referenceTable) {};

/**
 * @param {string} table
 * @param {string} referenceTable
 * @return {?}
 */
Migration.prototype.dropForeignKey = function(table, referenceTable) {};
 /** @type {?} */
var mime;
/**
 * @record
 * @struct
 */
function IErrorsObject() {}
 /** @type {?} */
IErrorsObject.prototype._query;

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function ICalculation() {}
 /** @type {!Array<string>} */
ICalculation.prototype.fields;
 /** @type {!Function} */
ICalculation.prototype.calculate;
/**
 * @record
 * @struct
 */
function ICalculations() {}

/* TODO: IndexSignature:  */

/**
 * @constructor
 * @struct
 * @param {!Object} modelData
 * @param {boolean=} fromStorage
 * @param {boolean=} fromSeed
 */
function Model(modelData, fromStorage, fromSeed) {}

/* TODO: PropertyDeclaration: 'constructor' */
 /** @type {?} */
Model.prototype.db;
 /** @type {?} */
Model.prototype.schema;
 /** @type {?} */
Model.prototype.data;
 /** @type {!Array<string>} */
Model.prototype.externalInterface;
 /** @type {?} */
Model.prototype.aggregateBy;
 /** @type {?} */
Model.prototype.formatters;
 /** @type {boolean} */
Model.prototype._inStorage;
 /** @type {?} */
Model.prototype._isSeeding;
 /** @type {?} */
Model.prototype._changed;
 /** @type {?} */
Model.prototype._errors;
 /** @type {?} */
Model.prototype._joinsList;
 /** @type {?} */
Model.prototype._joinsCache;
 /** @type {?} */
Model.prototype._data;
 /** @type {?} */
Model.prototype._calculations;
 /** @type {?} */
Model._relationshipCache;
 /** @type {?} */
Model.prototype._validations;
 /** @type {!Array<?>} */
Model.prototype._validationsList;
 /** @type {!Array<string>} */
Model.prototype._calculationsList;
 /** @type {?} */
Model.prototype._verificationsList;
 /** @type {?} */
Model.prototype._hides;
 /** @type {string} */
Model.prototype._table;
 /** @type {?} */
Model.prototype._columnLookup;
 /** @type {!Array<string>} */
Model.prototype._columnNames;
 /** @type {!Array<?>} */
Model.prototype._columns;
 /** @type {?} */
Model.prototype._relationshipCache;

/**
 * Indicates whethere or not the model is currently represented in hard storage (db).
 * @return {boolean}
 */
Model.prototype.inStorage = function() {};

/**
 * Indicates whethere or not the model is being generated from a seed.
 * @return {boolean}
 */
Model.prototype.isSeeding = function() {};

/**
 * Tells us whether a model field has changed since we created it or loaded it from storage.
 * @param {string} field
 * @return {boolean}
 */
Model.prototype.hasChanged = function(field) {};

/**
 * Provides an array of all changed fields since model was created / loaded from storage
 * @return {!Array<string>}
 */
Model.prototype.changedFields = function() {};

/**
 * Creates an error object for the model if any validations have failed, returns null otherwise
 * @return {?}
 */
Model.prototype.errorObject = function() {};

/**
 * Tells us whether or not the model has errors (failed validations)
 * @return {boolean}
 */
Model.prototype.hasErrors = function() {};

/**
 * Gives us an error object with each errored field as a key, and each value
 * being an array of failure messages from the validators
 * @return {?}
 */
Model.prototype.getErrors = function() {};

/**
 * Reads new data into the model.
 * @param {?} data
 * @return {?}
 */
Model.prototype.read = function(data) {};

/**
 * Converts a value to its intended format based on its field. Returns null if field not found.
 * @param {string} field
 * @param {?} value
 * @return {?}
 */
Model.prototype.convert = function(field, value) {};

/**
 * Grabs the path of the given relationship from the RelationshipGraph
 * @param {string} name
 * @return {?}
 */
Model.prototype.relationship = function(name) {};

/**
 * Sets specified field data for the model. Logs and validates the change.
 * @param {string} field
 * @param {?} value
 * @return {?}
 */
Model.prototype.set = function(field, value) {};

/**
 * Set a joined object (Model or ModelArray)
 * @param {string} field
 * @param {?} value
 * @return {?}
 */
Model.prototype.setJoined = function(field, value) {};

/**
 * Calculate field from calculations (assumes it exists)
 *  \@param {string} field Name of the calculated field
 * @param {string} field
 * @return {void}
 */
Model.prototype.calculate = function(field) {};

/**
 * Retrieve field data for the model.
 * @param {string} field
 * @param {boolean=} ignoreFormat
 * @return {?}
 */
Model.prototype.get = function(field, ignoreFormat) {};

/**
 * Retrieves joined Model or ModelArray
 * @param {string} joinName
 * @return {?}
 */
Model.prototype.joined = function(joinName) {};

/**
 * Retrieve associated models joined this model from the database.
 *   Pass in a function with named parameters corresponding the relationships you'd like to retrieve.
 *   The first parameter is always an error callback.
 * @param {?} callback
 * @return {void}
 */
Model.prototype.include = function(callback) {};

/**
 * Creates a plain object from the Model, with properties matching an optional interface
 * @param {!Array<?>=} arrInterface
 * @return {?}
 */
Model.prototype.toObject = function(arrInterface) {};

/**
 * Get the table name for the model.
 * @return {string}
 */
Model.prototype.tableName = function() {};

/**
 * Determine if the model has a specified field.
 * @param {string} field
 * @return {boolean}
 */
Model.prototype.hasField = function(field) {};

/**
 * Retrieve the schema field data for the specified field
 * @param {string} field
 * @return {?}
 */
Model.prototype.getFieldData = function(field) {};

/**
 * Retrieve the schema data type for the specified field
 * @param {string} field
 * @return {?}
 */
Model.prototype.getDataTypeOf = function(field) {};

/**
 * Determine whether or not this field is an Array (PostgreSQL supports this)
 * @param {string} field
 * @return {boolean}
 */
Model.prototype.isFieldArray = function(field) {};

/**
 * Determine whether or not this field is a primary key in our schema
 * @param {string} field
 * @return {boolean}
 */
Model.prototype.isFieldPrimaryKey = function(field) {};

/**
 * Retrieve the defaultValue for this field from our schema
 * @param {string} field
 * @return {?}
 */
Model.prototype.fieldDefaultValue = function(field) {};

/**
 * Retrieve an array of fields for our model
 * @return {!Array<string>}
 */
Model.prototype.fieldList = function() {};

/**
 * Retrieve our field schema definitions
 * @return {!Array<?>}
 */
Model.prototype.fieldDefinitions = function() {};

/**
 * Set an error for a specified field (supports multiple errors)
 * @param {string} key
 * @param {string} message
 * @return {boolean}
 */
Model.prototype.setError = function(key, message) {};

/**
 * Clears all errors for a specified field
 * @param {string} key
 * @return {boolean}
 */
Model.prototype.clearError = function(key) {};

/**
 * @return {?}
 */
Model.prototype.__generateSaveQuery__ = function() {};

/**
 * Runs all verifications before saving
 * @param {!Function} callback
 * @return {?}
 */
Model.prototype.__verify__ = function(callback) {};

/**
 * Saves model to database
 * @param {?} callback
 * @return {?}
 */
Model.prototype.__save__ = function(callback) {};

/**
 * Destroys model and cascades all deletes.
 * @param {!Function} callback
 * @return {void}
 */
Model.prototype.destroyCascade = function(callback) {};

/**
 * Logic to execute before a model gets destroyed. Intended to be overwritten when inherited.
 * @param {!Function} callback
 * @return {void}
 */
Model.prototype.beforeDestroy = function(callback) {};

/**
 * Logic to execute after a model is destroyed. Intended to be overwritten when inherited.
 * @param {!Function} callback
 * @return {void}
 */
Model.prototype.afterDestroy = function(callback) {};

/**
 * Destroys model reference in database.
 *   Method to execute upon completion, returns error if failed
 * @param {!Function} callback
 * @return {void}
 */
Model.prototype.destroy = function(callback) {};

/**
 * Logic to execute before a model saves. Intended to be overwritten when inherited.
 * @param {!Function} callback
 * @return {void}
 */
Model.prototype.beforeSave = function(callback) {};

/**
 * Logic to execute after a model saves. Intended to be overwritten when inherited.
 * @param {!Function} callback
 * @return {void}
 */
Model.prototype.afterSave = function(callback) {};

/**
 * Save a model (execute beforeSave and afterSave)
 * @param {!Function} callback
 * @return {void}
 */
Model.prototype.save = function(callback) {};

/**
 * Runs an update query for this specific model instance
 * @param {?} fields
 * @param {!Function} callback
 * @return {void}
 */
Model.prototype.update = function(fields, callback) {};

/**
 * @param {number} id
 * @param {?} callback
 * @return {void}
 */
Model.find = function(id, callback) {};

/**
 * @param {string} field
 * @param {?} value
 * @param {?} callback
 * @return {void}
 */
Model.findBy = function(field, value, callback) {};

/**
 * Creates a new model instance using the provided data.
 * @param {?} data
 * @param {?} callback
 * @return {void}
 */
Model.create = function(data, callback) {};

/**
 * Finds a model with a provided field, value pair. Returns the first found.
 * @param {string} field
 * @param {?} data
 * @param {?} callback
 * @return {void}
 */
Model.findOrCreateBy = function(field, data, callback) {};

/**
 * Finds and updates a model with a specified id. Return a notFound error if model does not exist.
 * @param {number} id
 * @param {?} data
 * @param {?} callback
 * @return {void}
 */
Model.update = function(id, data, callback) {};

/**
 * Finds and destroys a model with a specified id. Return a notFound error if model does not exist.
 * @param {number} id
 * @param {?} callback
 * @return {void}
 */
Model.destroy = function(id, callback) {};

/**
 * Creates a new Composer (ORM) instance to begin a new query.
 * @template T
 * @param {?=} db
 * @return {?}
 */
Model.query = function(db) {};

/**
 * Get the model's table name
 * @return {string}
 */
Model.table = function() {};

/**
 * Get the model's column data
 * @return {!Array<?>}
 */
Model.columns = function() {};

/**
 * Get the model's column names (fields)
 * @return {!Array<string>}
 */
Model.columnNames = function() {};

/**
 * Get the model's column lookup data
 * @return {?}
 */
Model.columnLookup = function() {};

/**
 * Check if the model has a column name in its schema
 * @param {string} columnName
 * @return {boolean}
 */
Model.hasColumn = function(columnName) {};

/**
 * Return the column schema data for a given name
 * @param {string} columnName
 * @return {?}
 */
Model.column = function(columnName) {};

/**
 * Set the database to be used for this model
 * @param {?} db
 * @return {void}
 */
Model.setDatabase = function(db) {};

/**
 * Set the schema to be used for this model
 * @param {?} schema
 * @return {void}
 */
Model.setSchema = function(schema) {};

/**
 * FIXME
 * @return {?}
 */
Model.relationships = function() {};

/**
 * `
 * FIXME
 * @param {string} name
 * @return {?}
 */
Model.relationship = function(name) {};

/**
 * Sets a joins relationship for the Model. Sets joinedBy relationship for parent.
 *   "name": The string name of the parent in the relationship (default to camelCase of Model name)
 *   "via": Which field in current model represents this relationship, defaults to `${name}_id`
 *   "as": What to display the name of the child as when joined to the parent (default to camelCase of child name)
 *   "multiple": Whether the child exists in multiples for the parent (defaults to false)
 * @param {?} modelClass
 * @param {?} options
 * @return {?}
 */
Model.joinsTo = function(modelClass, options) {};

/**
 * Create a validator. These run synchronously and check every time a field is set / cleared.
 * @param {string} field
 * @param {string} message
 * @param {?} fnAction
 * @return {void}
 */
Model.validates = function(field, message, fnAction) {};

/**
 * Creates a verifier. These run asynchronously, support multiple fields, and check every time you try to save a Model.
 * and field names are determined by the  argument names.
 * @param {string} message
 * @param {!Function} fnAction
 * @return {void}
 */
Model.verifies = function(message, fnAction) {};

/**
 * Create a calculated field (in JavaScript). Must be synchronous.
 *   Pass the names of the (non-computed) fields you'd like to use as parameters.
 * @param {string} calcField
 * @param {!Function} fnCompute
 * @return {void}
 */
Model.calculates = function(calcField, fnCompute) {};

/**
 * Hides fields from being output in .toObject() (i.e. API responses), even if asked for
 * @param {string} field
 * @return {boolean}
 */
Model.hides = function(field) {};

/**
 * Tells us if a field is hidden (i.e. from API queries)
 * @param {string} field
 * @return {?}
 */
Model.isHidden = function(field) {};

/**
 * Prepare model for use
 * @return {?}
 */
Model.prototype.__initialize__ = function() {};

/**
 * @param {?} data
 * @param {boolean=} fromStorage
 * @param {boolean=} fromSeed
 * @return {?}
 */
Model.prototype.__load__ = function(data, fromStorage, fromSeed) {};

/**
 * Validates provided fieldList (or all fields if not provided)
 * @param {?=} field
 * @return {?}
 */
Model.prototype.__validate__ = function(field) {};

/**
 * Sets specified field data for the model, assuming data is safe and does not log changes
 * @param {string} field
 * @param {?} value
 * @return {void}
 */
Model.prototype.__safeSet__ = function(field, value) {};

/**
 * Destroys model reference in database
 * @param {?} callback
 * @return {?}
 */
Model.prototype.__destroy__ = function(callback) {};

/**
 * @constructor
 * @struct
 * @param {?} modelConstructor
 */
function ModelArray(modelConstructor) {}
 /** @type {?} */
ModelArray.prototype.Model;

/**
 * @template T
 * @param {!Array<?>} arr
 * @return {?}
 */
ModelArray.from = function(arr) {};

/**
 * @param {!Array<string>=} arrInterface
 * @return {?}
 */
ModelArray.prototype.toObject = function(arrInterface) {};

/**
 * @param {?} model
 * @return {boolean}
 */
ModelArray.prototype.has = function(model) {};

/**
 * @param {!Object} data
 * @return {boolean}
 */
ModelArray.prototype.readAll = function(data) {};

/**
 * @param {string} field
 * @param {string} value
 * @return {boolean}
 */
ModelArray.prototype.setAll = function(field, value) {};

/**
 * @param {!Function} callback
 * @return {void}
 */
ModelArray.prototype.destroyAll = function(callback) {};

/**
 * @param {!Function} callback
 * @return {void}
 */
ModelArray.prototype.destroyCascade = function(callback) {};

/**
 * @param {!Function} callback
 * @return {!Function}
 */
ModelArray.prototype.saveAll = function(callback) {};

/**
 * @param {?} callback
 * @return {?}
 */
ModelArray.prototype.__saveAll__ = function(callback) {};
/**
 * @record
 * @struct
 */
function IModelData() {}

/* TODO: IndexSignature:  */

/**
 * @constructor
 * @struct
 * Create the ModelFactory with a provided Model to use as a reference.
 * @param {?} modelConstructor
 */
function ModelFactory(modelConstructor) {}
 /** @type {?} */
ModelFactory.prototype.Model;

/**
 * Loads all model constructors in your ./app/models directory into an array
 * @return {!Array<?>}
 */
ModelFactory.loadModels = function() {};

/**
 * Creates new factories from a supplied array of Models, loading in data keyed by Model name
 * @param {!Array<?>} Models
 * @param {?} objModelData
 * @param {!Function} callback
 * @return {void}
 */
ModelFactory.createFromModels = function(Models, objModelData, callback) {};

/**
 * Populates a large amount of model data from an Object.
 * @param {?} objModelData
 * @param {!Function} callback
 * @return {void}
 */
ModelFactory.populate = function(objModelData, callback) {};

/**
 * Creates models from an array of Objects containing the model data
 * @param {!Array<?>} arrModelData
 * @param {!Function} callback
 * @return {void}
 */
ModelFactory.prototype.create = function(arrModelData, callback) {};
/**
 * @record
 * @struct
 */
function IOptions() {}
 /** @type {string} */
IOptions.prototype.name;
 /** @type {boolean} */
IOptions.prototype.multiple;
 /** @type {string} */
IOptions.prototype.as;
 /** @type {string} */
IOptions.prototype.via;

/**
 * @constructor
 * @struct
 * @param {!Array<?>} path
 */
function RelationshipPath(path) {}

/* TODO: PropertyDeclaration: 'constructor' */
 /** @type {!Array<?>} */
RelationshipPath.prototype.path;

/**
 * @return {string}
 */
RelationshipPath.prototype.toString = function() {};

/**
 * @param {boolean=} reverse
 * @return {string}
 */
RelationshipPath.prototype.joinName = function(reverse) {};

/**
 * @param {?} node
 * @param {?} edge
 * @return {?}
 */
RelationshipPath.prototype.add = function(node, edge) {};

/**
 * @return {?}
 */
RelationshipPath.prototype.getModel = function() {};

/**
 * @return {boolean}
 */
RelationshipPath.prototype.multiple = function() {};

/**
 * @return {boolean}
 */
RelationshipPath.prototype.immediateMultiple = function() {};

/**
 * @param {string=} alias
 * @param {string=} firstTable
 * @return {!Array<?>}
 */
RelationshipPath.prototype.joins = function(alias, firstTable) {};

/**
 * @constructor
 * @struct
 * @param {?} Graph
 * @param {?} mModel
 */
function RelationshipNode(Graph, mModel) {}
 /** @type {?} */
RelationshipNode.prototype.Graph;
 /** @type {?} */
RelationshipNode.prototype.Model;
 /** @type {!Array<?>} */
RelationshipNode.prototype.edges;

/**
 * @return {string}
 */
RelationshipNode.prototype.toString = function() {};

/**
 * @param {?} mModel
 * @param {?} options
 * @return {?}
 */
RelationshipNode.prototype.joinsTo = function(mModel, options) {};

/**
 * @return {!Array<?>}
 */
RelationshipNode.prototype.childEdges = function() {};

/**
 * @return {!Array<?>}
 */
RelationshipNode.prototype.cascade = function() {};

/**
 * @param {string} pathname
 * @return {?}
 */
RelationshipNode.prototype.findExplicit = function(pathname) {};

/**
 * @param {string} name
 * @return {?}
 */
RelationshipNode.prototype.find = function(name) {};

/**
 * @constructor
 * @struct
 * @param {?} parent
 * @param {?} child
 * @param {?} options
 */
function RelationshipEdge(parent, child, options) {}
 /** @type {number} */
RelationshipEdge.prototype.id;
 /** @type {?} */
RelationshipEdge.prototype.parent;
 /** @type {?} */
RelationshipEdge.prototype.child;
 /** @type {?} */
RelationshipEdge.prototype.options;

/**
 * @return {string}
 */
RelationshipEdge.prototype.toString = function() {};

/**
 * @param {?} child
 * @return {boolean}
 */
RelationshipEdge.prototype.hasChild = function(child) {};

/**
 * @param {?} parent
 * @return {boolean}
 */
RelationshipEdge.prototype.hasParent = function(parent) {};

/**
 * @param {?} node
 * @return {?}
 */
RelationshipEdge.prototype.opposite = function(node) {};

/**
 * @constructor
 * @struct
 */
function RelationshipGraph() {}
 /** @type {!Array<?>} */
RelationshipGraph.prototype.nodes;
 /** @type {!Array<?>} */
RelationshipGraph.prototype.edges;

/**
 * @param {?} mModel
 * @return {?}
 */
RelationshipGraph.prototype.of = function(mModel) {};
/**
 * @constructor
 * @struct
 */
function Router() {}
/**
 * @constructor
 * @struct
 */
function Scheduler() {}
/**
 * @record
 * @struct
 */
function IAnyObject() {}

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function IExtendedError() {}
 /** @type {boolean} */
IExtendedError.prototype.notFound;
 /** @type {!Object} */
IExtendedError.prototype.details;
/**
 * @record
 * @struct
 */
function IColumn() {}
 /** @type {string} */
IColumn.prototype.name;
 /** @type {string} */
IColumn.prototype.type;
 /** @type {?} */
IColumn.prototype.properties;
/**
 * @record
 * @struct
 */
function ISchema() {}
 /** @type {string} */
ISchema.prototype.table;
 /** @type {!Array<?>} */
ISchema.prototype.columns;
/**
 * @record
 * @struct
 */
function IJoin() {}
 /** @type {string} */
IJoin.prototype.prevColumn;
 /** @type {string} */
IJoin.prototype.joinColumn;
 /** @type {string} */
IJoin.prototype.joinTable;
 /** @type {string} */
IJoin.prototype.prevTable;
 /** @type {string} */
IJoin.prototype.name;
 /** @type {string} */
IJoin.prototype.key;
 /** @type {boolean} */
IJoin.prototype.multiple;
 /** @type {!Array<string>} */
IJoin.prototype.columns;
 /** @type {!Object} */
IJoin.prototype.columnsObject;
 /** @type {?} */
IJoin.prototype.cachedModel;
 /** @type {string} */
IJoin.prototype.joinAlias;
 /** @type {?} */
IJoin.prototype.multiFilter;
 /** @type {string} */
IJoin.prototype.prevAlias;
 /** @type {?} */
IJoin.prototype.orderBy;
 /** @type {number} */
IJoin.prototype.offset;
 /** @type {number} */
IJoin.prototype.count;

/** @typedef {?} */
var Query;
/**
 * @record
 * @struct
 */
function IColumnProperties() {}
 /** @type {number} */
IColumnProperties.prototype.length;
 /** @type {boolean} */
IColumnProperties.prototype.nullable;
 /** @type {(boolean|number)} */
IColumnProperties.prototype.primary_key;
 /** @type {boolean} */
IColumnProperties.prototype.auto_increment;
 /** @type {(boolean|number)} */
IColumnProperties.prototype.unique;
 /** @type {boolean} */
IColumnProperties.prototype.array;
 /** @type {?} */
IColumnProperties.prototype.defaultValue;
/**
 * @record
 * @struct
 */
function IArrInterface() {}

/* TODO: IndexSignature:  */

/** @typedef {(string|?)} */
var InterfaceType;

/** @typedef {string} */
var DataType;
 /** @type {?} */
var my;
 /** @type {!NodeRequire} */
var require;
