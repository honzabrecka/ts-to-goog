/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/lolex/index.d.ts:
/**
 * @record
 * @struct
 */
function NodeTimer() {}

/**
 * Stub method call. Does nothing.
 * @return {void}
 */
NodeTimer.prototype.ref = function() {};

/**
 * Stub method call. Does nothing.
 * @return {void}
 */
NodeTimer.prototype.unref = function() {};

/** @typedef {(number|?)} */
var TimerId;

/** @typedef {?} */
var BrowserClock;

/** @typedef {?} */
var NodeClock;

/** @typedef {?} */
var Clock;

/** @typedef {string} */
var FakeMethod;
/**
 * @record
 * @struct
 */
function LolexClock() {}
 /** @type {number} */
LolexClock.prototype.now;
 /** @type {!DateConstructor} */
LolexClock.prototype.Date;

/**
 * Schedules a callback to be fired once timeout milliseconds have ticked by.
 * 
 * @param {?} callback   Callback to be fired.
 * @param {number} timeout   How many ticks to wait to run the callback.
 * @return {?} Time identifier for cancellation.
 */
LolexClock.prototype.setTimeout = function(callback, timeout) {};

/**
 * Clears a timer, as long as it was created using setTimeout.
 * 
 * @param {?} id   Timer ID or object.
 * @return {void}
 */
LolexClock.prototype.clearTimeout = function(id) {};

/**
 * Schedules a callback to be fired every time timeout milliseconds have ticked by.
 * 
 * @param {?} callback   Callback to be fired.
 * @param {number} timeout   How many ticks to wait between callbacks.
 * @return {?} Time identifier for cancellation.
 */
LolexClock.prototype.setInterval = function(callback, timeout) {};

/**
 * Clears a timer, as long as it was created using setInterval.
 * 
 * @param {?} id   Timer ID or object.
 * @return {void}
 */
LolexClock.prototype.clearInterval = function(id) {};

/**
 * Schedules the callback to be fired once 0 milliseconds have ticked by.
 * 
 * \@remarks You'll still have to call clock.tick() for the callback to fire.
 * \@remarks If called during a tick the callback won't fire until 1 millisecond has ticked by.
 * @param {?} callback   Callback to be fired.
 * @return {?}
 */
LolexClock.prototype.setImmediate = function(callback) {};

/**
 * Clears a timer, as long as it was created using setImmediate.
 * 
 * @param {?} id   Timer ID or object.
 * @return {void}
 */
LolexClock.prototype.clearImmediate = function(id) {};

/**
 * Advances the clock to the the moment of the first scheduled timer, firing it.
 * @return {void}
 */
LolexClock.prototype.next = function() {};

/**
 * Advance the clock, firing callbacks if necessary.
 * 
 * @param {(string|number)} time   How many ticks to advance by.
 * @return {void}
 */
LolexClock.prototype.tick = function(time) {};

/**
 * Runs all pending timers until there are none remaining.
 * 
 * \@remarks If new timers are added while it is executing they will be run as well.
 * @return {void}
 */
LolexClock.prototype.runAll = function() {};

/**
 * Takes note of the last scheduled timer when it is run, and advances the clock to
 * that time firing callbacks as necessary.
 * @return {void}
 */
LolexClock.prototype.runToLast = function() {};

/**
 * Simulates a user changing the system clock.
 * 
 * \@remarks This affects the current time but it does not in itself cause timers to fire.
 * @param {(number|!Date)=} now   New system time.
 * @return {void}
 */
LolexClock.prototype.setSystemTime = function(now) {};

/**
 * Restores the original methods on the context that was passed to lolex.install,
 * or the native timers if no context was given.
 * @return {void}
 */
LolexClock.prototype.uninstall = function() {};

/**
 * Creates a clock.
 * 
 * \@remarks The default epoch is 0.
 * @template TClock
 * @param {(number|!Date)=} now   Current time for the clock.
 * @param {number=} loopLimit    Maximum number of timers that will be run when calling runAll()
 *                     before assuming that we have an infinite loop and throwing an error
 *                     (by default, 1000).
 * @return {TClock}
 */
function createClock(now, loopLimit) {}

/**
 * Creates a clock and installs it globally.
 * 
 * \@usage lolex.install(["setTimeout", "clearTimeout"]);
 * Creates a clock and installs it onto the context object.
 * 
 * \@usage lolex.install(context, ["setTimeout", "clearTimeout"]);
 * @template TClock
 * @param {(number|!Date)|?=} now_or_context   Current time for the clock, as with lolex.createClock(). /   Context to install the clock onto.
 * @param {!Array<string>|(number|!Date)=} toFake_or_now   Names of methods that should be faked. /   Current time for the clock, as with lolex.createClock().
 * @param {!Array<string>=} toFake   Names of methods that should be faked.
 * @return {TClock}
 */
function install(now_or_context, toFake_or_now, toFake) {}
