/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/lodash/index.d.ts:

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
 /** @type {!_.LoDashStatic} */
var _;

/** @typedef {?} */
var PartialObject;

/** @typedef {(T|!Array<T>)} */
_.Many;
/**
 * @record
 * @struct
 */
_.LoDashStatic = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
 /** @type {string} */
_.LoDashStatic.prototype.VERSION;
 /** @type {!_.TemplateSettings} */
_.LoDashStatic.prototype.templateSettings;
/**
 * @record
 * @struct
 */
_.TemplateSettings = function() {};
 /** @type {!RegExp} */
_.TemplateSettings.prototype.escape;
 /** @type {!RegExp} */
_.TemplateSettings.prototype.evaluate;
 /** @type {!_.Dictionary<?>} */
_.TemplateSettings.prototype.imports;
 /** @type {!RegExp} */
_.TemplateSettings.prototype.interpolate;
 /** @type {string} */
_.TemplateSettings.prototype.variable;
/**
 * @record
 * @struct
 */
_.MapCache = function() {};

/**
 * Removes `key` and its value from the cache.
 * @param {string} key The key of the value to remove.
 * @return {boolean} Returns `true` if the entry was removed successfully, else `false`.
 */
_.MapCache.prototype.delete = function(key) {};

/**
 * Gets the cached value for `key`.
 * @param {string} key The key of the value to get.
 * @return {?} Returns the cached value.
 */
_.MapCache.prototype.get = function(key) {};

/**
 * Checks if a cached value for `key` exists.
 * @param {string} key The key of the entry to check.
 * @return {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
_.MapCache.prototype.has = function(key) {};

/**
 * Sets `value` to `key` of the cache.
 * @param {string} key The key of the value to cache.
 * @param {?} value The value to cache.
 * @return {!_.Dictionary<?>} Returns the cache object.
 */
_.MapCache.prototype.set = function(key, value) {};

/**
 * Removes all key-value entries from the map.
 * @return {void}
 */
_.MapCache.prototype.clear = function() {};
/**
 * @record
 * @struct
 */
_.MapCacheConstructor = function() {};

/* TODO: ConstructSignature: _ */
/**
 * @record
 * @struct
 */
_.LoDashWrapperBase = function() {};
/**
 * @extends {_.LoDashWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitWrapperBase = function() {};
/**
 * @extends {_.LoDashWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitWrapperBase = function() {};
/**
 * @extends {_.LoDashImplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitWrapper = function() {};
/**
 * @extends {_.LoDashExplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitWrapper = function() {};
/**
 * @extends {_.LoDashImplicitWrapper}
 * @record
 * @struct
 */
_.LoDashImplicitStringWrapper = function() {};
/**
 * @extends {_.LoDashExplicitWrapper}
 * @record
 * @struct
 */
_.LoDashExplicitStringWrapper = function() {};
/**
 * @extends {_.LoDashImplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitObjectWrapperBase = function() {};
/**
 * @extends {_.LoDashImplicitObjectWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitObjectWrapper = function() {};
/**
 * @extends {_.LoDashImplicitObjectWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitNillableObjectWrapper = function() {};
/**
 * @extends {_.LoDashExplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitObjectWrapperBase = function() {};
/**
 * @extends {_.LoDashExplicitObjectWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitObjectWrapper = function() {};
/**
 * @extends {_.LoDashExplicitObjectWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitNillableObjectWrapper = function() {};
/**
 * @extends {_.LoDashImplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitArrayWrapperBase = function() {};

/**
 * @return {T}
 */
_.LoDashImplicitArrayWrapperBase.prototype.pop = function() {};

/**
 * @param {...T} items
 * @return {TWrapper}
 */
_.LoDashImplicitArrayWrapperBase.prototype.push = function(items) {};

/**
 * @return {T}
 */
_.LoDashImplicitArrayWrapperBase.prototype.shift = function() {};

/**
 * @param {function(T, T): number=} compareFn
 * @return {TWrapper}
 */
_.LoDashImplicitArrayWrapperBase.prototype.sort = function(compareFn) {};

/**
 * @param {number} start
 * @param {number=} deleteCount
 * @param {...T} items
 * @return {TWrapper}
 */
_.LoDashImplicitArrayWrapperBase.prototype.splice = function(start, deleteCount, items) {};

/**
 * @param {...T} items
 * @return {TWrapper}
 */
_.LoDashImplicitArrayWrapperBase.prototype.unshift = function(items) {};
/**
 * @extends {_.LoDashImplicitArrayWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitArrayWrapper = function() {};
/**
 * @extends {_.LoDashImplicitArrayWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitNillableArrayWrapper = function() {};
/**
 * @extends {_.LoDashImplicitArrayWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitNumberArrayWrapperBase = function() {};
/**
 * @extends {_.LoDashImplicitArrayWrapper}
 * @record
 * @struct
 */
_.LoDashImplicitNumberArrayWrapper = function() {};
/**
 * @extends {_.LoDashExplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitArrayWrapperBase = function() {};

/**
 * @return {!_.LoDashExplicitObjectWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.pop = function() {};

/**
 * @param {...T} items
 * @return {TWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.push = function(items) {};

/**
 * @return {!_.LoDashExplicitObjectWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.shift = function() {};

/**
 * @param {function(T, T): number=} compareFn
 * @return {TWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.sort = function(compareFn) {};

/**
 * @param {number} start
 * @param {number=} deleteCount
 * @param {...T} items
 * @return {TWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.splice = function(start, deleteCount, items) {};

/**
 * @param {...T} items
 * @return {TWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.unshift = function(items) {};
/**
 * @extends {_.LoDashExplicitArrayWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitArrayWrapper = function() {};
/**
 * @extends {_.LoDashExplicitArrayWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitNillableArrayWrapper = function() {};
/**
 * @extends {_.LoDashExplicitArrayWrapper}
 * @record
 * @struct
 */
_.LoDashExplicitNumberArrayWrapper = function() {};

/**
 * Creates an array of elements split into groups the length of size. If collection can’t be split evenly, the
 * final chunk will be the remaining elements.
 * 
 * @template T
 * @param {!ArrayLike<T>} array The array to process.
 * @param {number=} size The length of each chunk.
 * @return {!Array<!Array<T>>} Returns the new array containing chunks.
 */
_.LoDashStatic.prototype.chunk = function(array, size) {};

/**
 * @see _.chunk
 * @param {number=} size
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.chunk = function(size) {};

/**
 * @see _.chunk
 * @template TResult
 * @param {number=} size
 * @return {!_.LoDashImplicitArrayWrapper<!Array<TResult>>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.chunk = function(size) {};

/**
 * @see _.chunk
 * @param {number=} size
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.chunk = function(size) {};

/**
 * @see _.chunk
 * @template TResult
 * @param {number=} size
 * @return {!_.LoDashExplicitArrayWrapper<!Array<TResult>>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.chunk = function(size) {};

/**
 * Creates an array with all falsey values removed. The values false, null, 0, "", undefined, and NaN are
 * falsey.
 * 
 * @template T
 * @param {!ArrayLike<(boolean|string|number|T)>=} array The array to compact.
 * @return {!Array<T>} (Array) Returns the new array of filtered values.
 */
_.LoDashStatic.prototype.compact = function(array) {};

/**
 * @see _.compact
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.compact = function() {};

/**
 * @see _.compact
 * @template TResult
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.compact = function() {};

/**
 * @see _.compact
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.compact = function() {};

/**
 * @see _.compact
 * @template TResult
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.compact = function() {};

/**
 * Creates a new array concatenating `array` with any additional arrays
 * and/or values.
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * var array = [1];
 * var other = _.concat(array, 2, [3], [[4]]);
 * 
 * console.log(other);
 * // => [1, 2, 3, [4]]
 * 
 * console.log(array);
 * // => [1]
 * @template T
 * @param {!ArrayLike<T>} array
 * @param {...(T|!ArrayLike<T>)} values
 * @return {!Array<T>}
 */
_.LoDashStatic.prototype.concat = function(array, values) {};

/**
 * Creates an array of unique array values not included in the other provided arrays using SameValueZero for
 * equality comparisons.
 * 
 * @template T
 * @param {!ArrayLike<T>} array The array to inspect.
 * @param {...!ArrayLike<T>} values The arrays of values to exclude.
 * @return {!Array<T>} Returns the new array of filtered values.
 */
_.LoDashStatic.prototype.difference = function(array, values) {};

/**
 * @see _.difference
 * @param {...!ArrayLike<T>} values
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.difference = function(values) {};

/**
 * @see _.difference
 * @template TValue
 * @param {...!ArrayLike<TValue>} values
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.difference = function(values) {};

/**
 * @see _.difference
 * @param {...!ArrayLike<T>} values
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.difference = function(values) {};

/**
 * @see _.difference
 * @template TValue
 * @param {...!ArrayLike<TValue>} values
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.difference = function(values) {};

/**
 * This method is like _.difference except that it accepts iteratee which is invoked for each element of array
 * and values to generate the criterion by which uniqueness is computed. The iteratee is invoked with one
 * argument: (value).
 * 
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @template T, W
 * @param {!ArrayLike<T>} array The array to inspect.
 * @param {...!ArrayLike<T>|?=} values_or_values1 The values to exclude.
 * @return {!Array<T>} Returns the new array of filtered values.
 */
_.LoDashStatic.prototype.differenceBy = function(array, values_or_values1) {};

/**
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @template T, W
 * @param {...!ArrayLike<T>|?=} values_or_values1
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.differenceBy = function(values_or_values1) {};

/**
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @template T, W
 * @param {...!ArrayLike<T>|?=} values_or_values1
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.differenceBy = function(values_or_values1) {};

/**
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @template T, W
 * @param {...!ArrayLike<T>|?=} values_or_values1
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.differenceBy = function(values_or_values1) {};

/**
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @see _.differenceBy
 * @template T, W
 * @param {...!ArrayLike<T>|?=} values_or_values1
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.differenceBy = function(values_or_values1) {};

/**
 * Creates an array of unique `array` values not included in the other
 * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * _.difference([3, 2, 1], [4, 2]);
 * // => [3, 1]
 * @param {!ArrayLike<?>} array
 * @param {...?} values
 * @return {!Array<?>}
 */
_.LoDashStatic.prototype.differenceWith = function(array, values) {};

/**
 * Creates a slice of array with n elements dropped from the beginning.
 * 
 * @template T
 * @param {!ArrayLike<T>} array The array to query.
 * @param {number=} n The number of elements to drop.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.drop = function(array, n) {};

/**
 * @see _.drop
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.drop = function(n) {};

/**
 * @see _.drop
 * @template T
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.drop = function(n) {};

/**
 * @see _.drop
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.drop = function(n) {};

/**
 * @see _.drop
 * @template T
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.drop = function(n) {};

/**
 * Creates a slice of array with n elements dropped from the end.
 * 
 * @template T
 * @param {!ArrayLike<T>} array The array to query.
 * @param {number=} n The number of elements to drop.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.dropRight = function(array, n) {};

/**
 * @see _.dropRight
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.dropRight = function(n) {};

/**
 * @see _.dropRight
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.dropRight = function(n) {};

/**
 * @see _.dropRight
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.dropRight = function(n) {};

/**
 * @see _.dropRight
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.dropRight = function(n) {};

/**
 * Creates a slice of array excluding elements dropped from the end. Elements are dropped until predicate
 * returns falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * match the properties of the given object, else false.
 * 
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TValue, TWhere
 * @param {!ArrayLike<TValue>} array The array to query.
 * @param {function(TValue, number, !ArrayLike<TValue>): boolean|string|TWhere=} predicate The function invoked per iteration.
 * @return {!Array<TValue>} Returns the slice of array.
 */
_.LoDashStatic.prototype.dropRightWhile = function(array, predicate) {};

/**
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TWhere
 * @param {function(T, number, !ArrayLike<T>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.dropRightWhile = function(predicate) {};

/**
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TValue, TWhere
 * @param {function(TValue, number, !ArrayLike<TValue>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.dropRightWhile = function(predicate) {};

/**
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TWhere
 * @param {function(T, number, !ArrayLike<T>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.dropRightWhile = function(predicate) {};

/**
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TValue, TWhere
 * @param {function(TValue, number, !ArrayLike<TValue>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.dropRightWhile = function(predicate) {};

/**
 * Creates a slice of array excluding elements dropped from the beginning. Elements are dropped until predicate
 * returns falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TValue, TWhere
 * @param {!ArrayLike<TValue>} array The array to query.
 * @param {function(TValue, number, !ArrayLike<TValue>): boolean|string|TWhere=} predicate The function invoked per iteration.
 * @return {!Array<TValue>} Returns the slice of array.
 */
_.LoDashStatic.prototype.dropWhile = function(array, predicate) {};

/**
 * @see _.dropWhile
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TWhere
 * @param {function(T, number, !ArrayLike<T>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.dropWhile = function(predicate) {};

/**
 * @see _.dropWhile
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TValue, TWhere
 * @param {function(TValue, number, !ArrayLike<TValue>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.dropWhile = function(predicate) {};

/**
 * @see _.dropWhile
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TWhere
 * @param {function(T, number, !ArrayLike<T>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.dropWhile = function(predicate) {};

/**
 * @see _.dropWhile
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TValue, TWhere
 * @param {function(TValue, number, !ArrayLike<TValue>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.dropWhile = function(predicate) {};

/**
 * Fills elements of array with value from start up to, but not including, end.
 * 
 * Note: This method mutates array.
 * 
 * @see _.fill
 * @template T
 * @param {!Array<?>|!ArrayLike<?>} array The array to fill.
 * @param {T} value The value to fill array with.
 * @param {number=} start The start position.
 * @param {number=} end The end position.
 * @return {!Array<T>|!ArrayLike<T>} Returns array.
 */
_.LoDashStatic.prototype.fill = function(array, value, start, end) {};

/**
 * @see _.fill
 * @template T
 * @param {T} value
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.fill = function(value, start, end) {};

/**
 * @see _.fill
 * @template T
 * @param {T} value
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashImplicitObjectWrapper<!ArrayLike<T>>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.fill = function(value, start, end) {};

/**
 * @see _.fill
 * @template T
 * @param {T} value
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.fill = function(value, start, end) {};

/**
 * @see _.fill
 * @template T
 * @param {T} value
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashExplicitObjectWrapper<!ArrayLike<T>>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.fill = function(value, start, end) {};

/**
 * This method is like _.find except that it returns the index of the first element predicate returns truthy
 * for instead of the element itself.
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.findIndex
 * @see _.findIndex
 * @template T, W
 * @param {!ArrayLike<T>} array The array to search.
 * @param {function(T, number, !ArrayLike<T>): boolean|string|W=} predicate The function invoked per iteration.
 * @param {number=} fromIndex The index to search from.
 * @return {number} Returns the index of the found element, else -1.
 */
_.LoDashStatic.prototype.findIndex = function(array, predicate, fromIndex) {};

/**
 * @see _.findIndex
 * @see _.findIndex
 * @see _.findIndex
 * @template W
 * @param {function(T, number, !ArrayLike<T>): boolean|string|W=} predicate
 * @param {number=} fromIndex
 * @return {number}
 */
_.LoDashImplicitArrayWrapperBase.prototype.findIndex = function(predicate, fromIndex) {};

/**
 * @see _.findIndex
 * @see _.findIndex
 * @see _.findIndex
 * @template TResult, W
 * @param {function(TResult, number, !ArrayLike<TResult>): boolean|string|W=} predicate
 * @param {number=} fromIndex
 * @return {number}
 */
_.LoDashImplicitObjectWrapperBase.prototype.findIndex = function(predicate, fromIndex) {};

/**
 * @see _.findIndex
 * @see _.findIndex
 * @see _.findIndex
 * @template W
 * @param {function(T, number, !ArrayLike<T>): boolean|string|W=} predicate
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.findIndex = function(predicate, fromIndex) {};

/**
 * @see _.findIndex
 * @see _.findIndex
 * @see _.findIndex
 * @template TResult, W
 * @param {function(TResult, number, !ArrayLike<TResult>): boolean|string|W=} predicate
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.findIndex = function(predicate, fromIndex) {};

/**
 * This method is like _.findIndex except that it iterates over elements of collection from right to left.
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template T, W
 * @param {!ArrayLike<T>} array The array to search.
 * @param {function(T, number, !ArrayLike<T>): boolean|string|W=} predicate The function invoked per iteration.
 * @param {number=} fromIndex The index to search from.
 * @return {number} Returns the index of the found element, else -1.
 */
_.LoDashStatic.prototype.findLastIndex = function(array, predicate, fromIndex) {};

/**
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template W
 * @param {function(T, number, !ArrayLike<T>): boolean|string|W=} predicate
 * @param {number=} fromIndex
 * @return {number}
 */
_.LoDashImplicitArrayWrapperBase.prototype.findLastIndex = function(predicate, fromIndex) {};

/**
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template TResult, W
 * @param {function(TResult, number, !ArrayLike<TResult>): boolean|string|W=} predicate
 * @param {number=} fromIndex
 * @return {number}
 */
_.LoDashImplicitObjectWrapperBase.prototype.findLastIndex = function(predicate, fromIndex) {};

/**
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template W
 * @param {function(T, number, !ArrayLike<T>): boolean|string|W=} predicate
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.findLastIndex = function(predicate, fromIndex) {};

/**
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template TResult, W
 * @param {function(TResult, number, !ArrayLike<TResult>): boolean|string|W=} predicate
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.findLastIndex = function(predicate, fromIndex) {};

/**
 * @see _.head
 * @template T
 * @param {!ArrayLike<T>} array
 * @return {T}
 */
_.LoDashStatic.prototype.first = function(array) {};

/**
 * @see _.head
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.first = function() {};

/**
 * @see _.head
 * @return {T}
 */
_.LoDashImplicitArrayWrapperBase.prototype.first = function() {};

/**
 * @see _.head
 * @template T
 * @return {T}
 */
_.LoDashImplicitObjectWrapperBase.prototype.first = function() {};

/**
 * @see _.head
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.first = function() {};

/**
 * @see _.head
 * @template T
 * @return {T}
 */
_.LoDashExplicitArrayWrapperBase.prototype.first = function() {};

/**
 * @see _.head
 * @template T
 * @return {T}
 */
_.LoDashExplicitObjectWrapperBase.prototype.first = function() {};
/**
 * @record
 * @struct
 */
_.RecursiveArray = function() {};
/**
 * @extends {_.List}
 * @record
 * @struct
 */
_.ListOfRecursiveArraysOrValues = function() {};

/**
 * Flattens a nested array. If isDeep is true the array is recursively flattened, otherwise it’s only
 * flattened a single level.
 * 
 * @see _.flatten
 * @see _.flatten
 * @template T
 * @param {!_.ListOfRecursiveArraysOrValues<T>|!ArrayLike<(T|!Array<T>)>} array The array to flatten.
 * @param {boolean=} isDeep Specify a deep flatten.
 * @return {!Array<T>|!_.RecursiveArray<T>} Returns the new flattened array.
 */
_.LoDashStatic.prototype.flatten = function(array, isDeep) {};

/**
 * @see _.flatten
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.flatten = function() {};

/**
 * @see _.flatten
 * @template TResult
 * @param {boolean=} isDeep
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.flatten = function(isDeep) {};

/**
 * @see _.flatten
 * @template TResult
 * @param {boolean=} isDeep
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.flatten = function(isDeep) {};

/**
 * @see _.flatten
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.flatten = function() {};

/**
 * @see _.flatten
 * @template TResult
 * @param {boolean=} isDeep
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.flatten = function(isDeep) {};

/**
 * @see _.flatten
 * @template TResult
 * @param {boolean=} isDeep
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.flatten = function(isDeep) {};

/**
 * Recursively flattens a nested array.
 * 
 * @template T
 * @param {!_.ListOfRecursiveArraysOrValues<T>} array The array to recursively flatten.
 * @return {!Array<T>} Returns the new flattened array.
 */
_.LoDashStatic.prototype.flattenDeep = function(array) {};

/**
 * @see _.flattenDeep
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.flattenDeep = function() {};

/**
 * Recursively flatten array up to depth times.
 * 
 * @template T
 * @param {!_.ListOfRecursiveArraysOrValues<T>} array The array to recursively flatten.
 * @param {number=} depth
 * @return {!Array<T>} Returns the new flattened array.
 */
_.LoDashStatic.prototype.flattenDepth = function(array, depth) {};

/**
 * The inverse of `_.toPairs`; this method returns an object composed
 * from key-value `pairs`.
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * _.fromPairs([['fred', 30], ['barney', 40]]);
 * // => { 'fred': 30, 'barney': 40 }
 * @see _.fromPairs
 * @template T
 * @param {!ArrayLike<!Array<?>>} array
 * @return {!_.Dictionary<T>|!_.Dictionary<?>}
 */
_.LoDashStatic.prototype.fromPairs = function(array) {};

/**
 * @see _.fromPairs
 * @return {!_.LoDashImplicitObjectWrapper<?>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.fromPairs = function() {};

/**
 * @see _.fromPairs
 * @return {!_.LoDashExplicitObjectWrapper<?>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.fromPairs = function() {};

/**
 * Gets the first element of array.
 * 
 * \@alias _.first
 * 
 * @template T
 * @param {!ArrayLike<T>} array The array to query.
 * @return {T} Returns the first element of array.
 */
_.LoDashStatic.prototype.head = function(array) {};

/**
 * @see _.head
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.head = function() {};

/**
 * @see _.head
 * @return {T}
 */
_.LoDashImplicitArrayWrapperBase.prototype.head = function() {};

/**
 * @see _.head
 * @template T
 * @return {T}
 */
_.LoDashImplicitObjectWrapperBase.prototype.head = function() {};

/**
 * @see _.head
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.head = function() {};

/**
 * @see _.head
 * @template T
 * @return {T}
 */
_.LoDashExplicitArrayWrapperBase.prototype.head = function() {};

/**
 * @see _.head
 * @template T
 * @return {T}
 */
_.LoDashExplicitObjectWrapperBase.prototype.head = function() {};

/**
 * Gets the index at which the first occurrence of `value` is found in `array`
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the offset
 * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
 * performs a faster binary search.
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * _.indexOf([1, 2, 1, 2], 2);
 * // => 1
 * 
 * // using `fromIndex`
 * _.indexOf([1, 2, 1, 2], 2, 2);
 * // => 3
 * @template T
 * @param {!ArrayLike<T>} array
 * @param {T} value
 * @param {(number|boolean)=} fromIndex
 * @return {number}
 */
_.LoDashStatic.prototype.indexOf = function(array, value, fromIndex) {};

/**
 * @see _.indexOf
 * @param {T} value
 * @param {(number|boolean)=} fromIndex
 * @return {number}
 */
_.LoDashImplicitArrayWrapperBase.prototype.indexOf = function(value, fromIndex) {};

/**
 * @see _.indexOf
 * @template TValue
 * @param {TValue} value
 * @param {(number|boolean)=} fromIndex
 * @return {number}
 */
_.LoDashImplicitObjectWrapperBase.prototype.indexOf = function(value, fromIndex) {};

/**
 * @see _.indexOf
 * @param {T} value
 * @param {(number|boolean)=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.indexOf = function(value, fromIndex) {};

/**
 * @see _.indexOf
 * @template TValue
 * @param {TValue} value
 * @param {(number|boolean)=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.indexOf = function(value, fromIndex) {};

/**
 * This method is like `_.intersection` except that it accepts `iteratee`
 * which is invoked for each element of each `arrays` to generate the criterion
 * by which uniqueness is computed. The iteratee is invoked with one argument: (value).
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
 * // => [2.1]
 * 
 * // using the `_.property` iteratee shorthand
 * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }]
 * @param {!ArrayLike<?>} array
 * @param {...?} values
 * @return {!Array<?>}
 */
_.LoDashStatic.prototype.intersectionBy = function(array, values) {};

/**
 * This method is like `_.intersection` except that it accepts `comparator`
 * which is invoked to compare elements of `arrays`. The comparator is invoked
 * with two arguments: (arrVal, othVal).
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 * 
 * _.intersectionWith(objects, others, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }]
 * @param {!ArrayLike<?>} array
 * @param {...?} values
 * @return {!Array<?>}
 */
_.LoDashStatic.prototype.intersectionWith = function(array, values) {};

/**
 * Converts all elements in `array` into a string separated by `separator`.
 * 
 * @param {!ArrayLike<?>} array The array to convert.
 * @param {string=} separator The element separator.
 * @return {string} Returns the joined string.
 */
_.LoDashStatic.prototype.join = function(array, separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {string}
 */
_.LoDashImplicitArrayWrapperBase.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {string}
 */
_.LoDashImplicitObjectWrapperBase.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.join = function(separator) {};

/**
 * This method is like `_.pull` except that it accepts an array of values to remove.
 * 
 * **Note:** Unlike `_.difference`, this method mutates `array`.
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * var array = [1, 2, 3, 1, 2, 3];
 * 
 * _.pull(array, [2, 3]);
 * console.log(array);
 * // => [1, 1]
 * @param {!ArrayLike<?>} array
 * @param {...?} values
 * @return {!Array<?>}
 */
_.LoDashStatic.prototype.pullAll = function(array, values) {};

/**
 * This method is like `_.pullAll` except that it accepts `iteratee` which is
 * invoked for each element of `array` and `values` to to generate the criterion
 * by which uniqueness is computed. The iteratee is invoked with one argument: (value).
 * 
 * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
 * 
 * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
 * console.log(array);
 * // => [{ 'x': 2 }]
 * @param {!ArrayLike<?>} array
 * @param {...?} values
 * @return {!Array<?>}
 */
_.LoDashStatic.prototype.pullAllBy = function(array, values) {};

/**
 * Reverses `array` so that the first element becomes the last, the second
 * element becomes the second to last, and so on.
 * 
 * **Note:** This method mutates `array` and is based on
 * [`Array#reverse`](https://mdn.io/Array/reverse).
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * var array = [1, 2, 3];
 * 
 * _.reverse(array);
 * // => [3, 2, 1]
 * 
 * console.log(array);
 * // => [3, 2, 1]
 * @param {!ArrayLike<?>} array
 * @param {...?} values
 * @return {!Array<?>}
 */
_.LoDashStatic.prototype.reverse = function(array, values) {};

/**
 * This method is like `_.indexOf` except that it performs a binary
 * search on a sorted `array`.
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * _.sortedIndexOf([1, 1, 2, 2], 2);
 * // => 2
 * @template T
 * @param {!ArrayLike<T>} array
 * @param {T} value
 * @return {number}
 */
_.LoDashStatic.prototype.sortedIndexOf = function(array, value) {};

/**
 * @see _.sortedIndexOf
 * @param {T} value
 * @return {number}
 */
_.LoDashImplicitArrayWrapperBase.prototype.sortedIndexOf = function(value) {};

/**
 * @see _.sortedIndexOf
 * @template TValue
 * @param {TValue} value
 * @return {number}
 */
_.LoDashImplicitObjectWrapperBase.prototype.sortedIndexOf = function(value) {};

/**
 * @see _.sortedIndexOf
 * @param {T} value
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.sortedIndexOf = function(value) {};

/**
 * @see _.sortedIndexOf
 * @template TValue
 * @param {TValue} value
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.sortedIndexOf = function(value) {};

/**
 * Gets all but the last element of array.
 * 
 * @template T
 * @param {!ArrayLike<T>} array The array to query.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.initial = function(array) {};

/**
 * @see _.initial
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.initial = function() {};

/**
 * @see _.initial
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.initial = function() {};

/**
 * @see _.initial
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.initial = function() {};

/**
 * @see _.initial
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.initial = function() {};

/**
 * Creates an array of unique values that are included in all of the provided arrays using SameValueZero for
 * equality comparisons.
 * 
 * @template T
 * @param {...!ArrayLike<T>} arrays The arrays to inspect.
 * @return {!Array<T>} Returns the new array of shared values.
 */
_.LoDashStatic.prototype.intersection = function(arrays) {};

/**
 * @see _.intersection
 * @template TResult
 * @param {...!ArrayLike<TResult>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.intersection = function(arrays) {};

/**
 * @see _.intersection
 * @template TResult
 * @param {...!ArrayLike<TResult>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.intersection = function(arrays) {};

/**
 * @see _.intersection
 * @template TResult
 * @param {...!ArrayLike<TResult>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.intersection = function(arrays) {};

/**
 * @see _.intersection
 * @template TResult
 * @param {...!ArrayLike<TResult>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.intersection = function(arrays) {};

/**
 * Gets the last element of array.
 * 
 * @template T
 * @param {!ArrayLike<T>} array The array to query.
 * @return {T} Returns the last element of array.
 */
_.LoDashStatic.prototype.last = function(array) {};

/**
 * @see _.last
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.last = function() {};

/**
 * @see _.last
 * @return {T}
 */
_.LoDashImplicitArrayWrapperBase.prototype.last = function() {};

/**
 * @see _.last
 * @template T
 * @return {T}
 */
_.LoDashImplicitObjectWrapperBase.prototype.last = function() {};

/**
 * @see _.last
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.last = function() {};

/**
 * @see _.last
 * @template T
 * @return {T}
 */
_.LoDashExplicitArrayWrapperBase.prototype.last = function() {};

/**
 * @see _.last
 * @template T
 * @return {T}
 */
_.LoDashExplicitObjectWrapperBase.prototype.last = function() {};

/**
 * This method is like _.indexOf except that it iterates over elements of array from right to left.
 * 
 * @template T
 * @param {!ArrayLike<T>} array The array to search.
 * @param {T} value The value to search for.
 * @param {(number|boolean)=} fromIndex The index to search from or true to perform a binary search on a sorted array.
 * @return {number} Returns the index of the matched value, else -1.
 */
_.LoDashStatic.prototype.lastIndexOf = function(array, value, fromIndex) {};

/**
 * @see _.lastIndexOf
 * @param {T} value
 * @param {(number|boolean)=} fromIndex
 * @return {number}
 */
_.LoDashImplicitArrayWrapperBase.prototype.lastIndexOf = function(value, fromIndex) {};

/**
 * @see _.lastIndexOf
 * @template TResult
 * @param {TResult} value
 * @param {(number|boolean)=} fromIndex
 * @return {number}
 */
_.LoDashImplicitObjectWrapperBase.prototype.lastIndexOf = function(value, fromIndex) {};

/**
 * @see _.lastIndexOf
 * @param {T} value
 * @param {(number|boolean)=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.lastIndexOf = function(value, fromIndex) {};

/**
 * @see _.lastIndexOf
 * @template TResult
 * @param {TResult} value
 * @param {(number|boolean)=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.lastIndexOf = function(value, fromIndex) {};

/**
 * Gets the element at index `n` of `array`. If `n` is negative, the nth element from the end is returned.
 * 
 * @template T
 * @param {!ArrayLike<T>} array array The array to query.
 * @param {number=} n
 * @return {T} Returns the nth element of `array`.
 */
_.LoDashStatic.prototype.nth = function(array, n) {};

/**
 * @see _.nth
 * @param {number=} n
 * @return {T}
 */
_.LoDashImplicitArrayWrapperBase.prototype.nth = function(n) {};

/**
 * @see _.nth
 * @template TResult
 * @param {number=} n
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapperBase.prototype.nth = function(n) {};

/**
 * @see _.nth
 * @param {number=} n
 * @return {!_.LoDashExplicitWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.nth = function(n) {};

/**
 * @see _.nth
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashExplicitWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.nth = function(n) {};

/**
 * Removes all provided values from array using SameValueZero for equality comparisons.
 * 
 * Note: Unlike _.without, this method mutates array.
 * 
 * @see _.pull
 * @template T
 * @param {!Array<T>|!ArrayLike<T>} array The array to modify.
 * @param {...T} values The values to remove.
 * @return {!Array<T>|!ArrayLike<T>} Returns array.
 */
_.LoDashStatic.prototype.pull = function(array, values) {};

/**
 * @see _.pull
 * @param {...T} values
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.pull = function(values) {};

/**
 * @see _.pull
 * @template TValue
 * @param {...TValue} values
 * @return {!_.LoDashImplicitObjectWrapper<!ArrayLike<TValue>>}
 */
_.LoDashImplicitObjectWrapper.prototype.pull = function(values) {};

/**
 * @see _.pull
 * @param {...T} values
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.pull = function(values) {};

/**
 * @see _.pull
 * @template TValue
 * @param {...TValue} values
 * @return {!_.LoDashExplicitObjectWrapper<!ArrayLike<TValue>>}
 */
_.LoDashExplicitObjectWrapper.prototype.pull = function(values) {};

/**
 * Removes elements from array corresponding to the given indexes and returns an array of the removed elements.
 * Indexes may be specified as an array of indexes or as individual arguments.
 * 
 * Note: Unlike _.at, this method mutates array.
 * 
 * @template T
 * @param {!ArrayLike<T>} array The array to modify.
 * @param {...(number|!Array<number>)} indexes The indexes of elements to remove, specified as individual indexes or arrays of indexes.
 * @return {!Array<T>} Returns the new array of removed elements.
 */
_.LoDashStatic.prototype.pullAt = function(array, indexes) {};

/**
 * @see _.pullAt
 * @param {...(number|!Array<number>)} indexes
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.pullAt = function(indexes) {};

/**
 * @see _.pullAt
 * @template T
 * @param {...(number|!Array<number>)} indexes
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.pullAt = function(indexes) {};

/**
 * @see _.pullAt
 * @param {...(number|!Array<number>)} indexes
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.pullAt = function(indexes) {};

/**
 * @see _.pullAt
 * @template T
 * @param {...(number|!Array<number>)} indexes
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.pullAt = function(indexes) {};

/**
 * Removes all elements from array that predicate returns truthy for and returns an array of the removed
 * elements. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * Note: Unlike _.filter, this method mutates array.
 * 
 * @see _.remove
 * @see _.remove
 * @template T, W
 * @param {!ArrayLike<T>} array The array to modify.
 * @param {function(T, number, !ArrayLike<T>): boolean|string|W=} predicate The function invoked per iteration.
 * @return {!Array<T>} Returns the new array of removed elements.
 */
_.LoDashStatic.prototype.remove = function(array, predicate) {};

/**
 * @see _.remove
 * @see _.remove
 * @see _.remove
 * @template W
 * @param {function(T, number, !ArrayLike<T>): boolean|string|W=} predicate
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.remove = function(predicate) {};

/**
 * @see _.remove
 * @see _.remove
 * @see _.remove
 * @template TResult, W
 * @param {function(TResult, number, !ArrayLike<TResult>): boolean|string|W=} predicate
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.remove = function(predicate) {};

/**
 * @see _.remove
 * @see _.remove
 * @see _.remove
 * @template W
 * @param {function(T, number, !ArrayLike<T>): boolean|string|W=} predicate
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.remove = function(predicate) {};

/**
 * @see _.remove
 * @see _.remove
 * @see _.remove
 * @template TResult, W
 * @param {function(TResult, number, !ArrayLike<TResult>): boolean|string|W=} predicate
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.remove = function(predicate) {};

/**
 * Gets all but the first element of array.
 * 
 * \@alias _.tail
 * 
 * @template T
 * @param {!ArrayLike<T>} array The array to query.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.tail = function(array) {};

/**
 * @see _.tail
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.tail = function() {};

/**
 * @see _.tail
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.tail = function() {};

/**
 * @see _.tail
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.tail = function() {};

/**
 * @see _.tail
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.tail = function() {};

/**
 * Creates a slice of array from start up to, but not including, end.
 * 
 * @template T
 * @param {!Array<T>} array The array to slice.
 * @param {number=} start The start position.
 * @param {number=} end The end position.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.slice = function(array, start, end) {};

/**
 * @see _.slice
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.slice = function(start, end) {};

/**
 * @see _.slice
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.slice = function(start, end) {};

/**
 * Uses a binary search to determine the lowest index at which `value` should
 * be inserted into `array` in order to maintain its sort order.
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * _.sortedIndex([30, 50], 40);
 * // => 1
 * 
 * _.sortedIndex([4, 5], 4);
 * // => 0
 * @template T
 * @param {!ArrayLike<T>} array
 * @param {T} value
 * @return {number}
 */
_.LoDashStatic.prototype.sortedIndex = function(array, value) {};

/**
 * @see _.sortedIndex
 * @template TSort
 * @param {string} value
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.sortedIndex = function(value) {};

/**
 * @see _.sortedIndex
 * @param {T} value
 * @return {number}
 */
_.LoDashImplicitArrayWrapperBase.prototype.sortedIndex = function(value) {};

/**
 * @see _.sortedIndex
 * @template T
 * @param {T} value
 * @return {number}
 */
_.LoDashImplicitObjectWrapperBase.prototype.sortedIndex = function(value) {};

/**
 * @see _.sortedIndex
 * @template TSort
 * @param {string} value
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.sortedIndex = function(value) {};

/**
 * @see _.sortedIndex
 * @param {T} value
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.sortedIndex = function(value) {};

/**
 * @see _.sortedIndex
 * @template T
 * @param {T} value
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.sortedIndex = function(value) {};

/**
 * This method is like `_.sortedIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };
 * 
 * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));
 * // => 1
 * 
 * // using the `_.property` iteratee shorthand
 * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
 * // => 0
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @template T, TSort, W
 * @param {!ArrayLike<T>} array
 * @param {T} value
 * @param {function(T): TSort|function(T): ?|string|W|!Object} iteratee
 * @return {number}
 */
_.LoDashStatic.prototype.sortedIndexBy = function(array, value, iteratee) {};

/**
 * @see _.sortedIndexBy
 * @template TSort
 * @param {string} value
 * @param {function(string): TSort} iteratee
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.sortedIndexBy = function(value, iteratee) {};

/**
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @template TSort, W
 * @param {T} value
 * @param {function(T): TSort|string|W} iteratee
 * @return {number}
 */
_.LoDashImplicitArrayWrapperBase.prototype.sortedIndexBy = function(value, iteratee) {};

/**
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @template T, TSort, W
 * @param {T} value
 * @param {function(T): TSort|function(T): ?|string|W|!Object} iteratee
 * @return {number}
 */
_.LoDashImplicitObjectWrapperBase.prototype.sortedIndexBy = function(value, iteratee) {};

/**
 * @see _.sortedIndexBy
 * @template TSort
 * @param {string} value
 * @param {function(string): TSort} iteratee
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.sortedIndexBy = function(value, iteratee) {};

/**
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @template TSort, W
 * @param {T} value
 * @param {function(T): TSort|string|W} iteratee
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.sortedIndexBy = function(value, iteratee) {};

/**
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @see _.sortedIndexBy
 * @template T, TSort, W
 * @param {T} value
 * @param {function(T): TSort|function(T): ?|string|W|!Object} iteratee
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.sortedIndexBy = function(value, iteratee) {};

/**
 * This method is like `_.sortedIndex` except that it returns the highest
 * index at which `value` should be inserted into `array` in order to
 * maintain its sort order.
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * _.sortedLastIndex([4, 5], 4);
 * // => 1
 * @template T
 * @param {!ArrayLike<T>} array
 * @param {T} value
 * @return {number}
 */
_.LoDashStatic.prototype.sortedLastIndex = function(array, value) {};

/**
 * @see _.sortedLastIndex
 * @param {string} value
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.sortedLastIndex = function(value) {};

/**
 * @see _.sortedLastIndex
 * @param {T} value
 * @return {number}
 */
_.LoDashImplicitArrayWrapperBase.prototype.sortedLastIndex = function(value) {};

/**
 * @see _.sortedLastIndex
 * @template T
 * @param {T} value
 * @return {number}
 */
_.LoDashImplicitObjectWrapperBase.prototype.sortedLastIndex = function(value) {};

/**
 * @see _.sortedLastIndex
 * @param {string} value
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.sortedLastIndex = function(value) {};

/**
 * @see _.sortedLastIndex
 * @param {T} value
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.sortedLastIndex = function(value) {};

/**
 * @see _.sortedLastIndex
 * @template T
 * @param {T} value
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.sortedLastIndex = function(value) {};

/**
 * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * // using the `_.property` iteratee shorthand
 * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
 * // => 1
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @template T, TSort, W
 * @param {!ArrayLike<T>} array
 * @param {T} value
 * @param {function(T): TSort|function(T): ?|string|W|!Object} iteratee
 * @return {number}
 */
_.LoDashStatic.prototype.sortedLastIndexBy = function(array, value, iteratee) {};

/**
 * @see _.sortedLastIndexBy
 * @template TSort
 * @param {string} value
 * @param {function(string): TSort} iteratee
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.sortedLastIndexBy = function(value, iteratee) {};

/**
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @template TSort, W
 * @param {T} value
 * @param {function(T): TSort|string|W} iteratee
 * @return {number}
 */
_.LoDashImplicitArrayWrapperBase.prototype.sortedLastIndexBy = function(value, iteratee) {};

/**
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @template T, TSort, W
 * @param {T} value
 * @param {function(T): TSort|function(T): ?|string|W|!Object} iteratee
 * @return {number}
 */
_.LoDashImplicitObjectWrapperBase.prototype.sortedLastIndexBy = function(value, iteratee) {};

/**
 * @see _.sortedLastIndexBy
 * @template TSort
 * @param {string} value
 * @param {function(string): TSort} iteratee
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.sortedLastIndexBy = function(value, iteratee) {};

/**
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @template TSort, W
 * @param {T} value
 * @param {function(T): TSort|string|W} iteratee
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.sortedLastIndexBy = function(value, iteratee) {};

/**
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @see _.sortedLastIndexBy
 * @template T, TSort, W
 * @param {T} value
 * @param {function(T): TSort|function(T): ?|string|W|!Object} iteratee
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.sortedLastIndexBy = function(value, iteratee) {};

/**
 * This method is like `_.lastIndexOf` except that it performs a binary
 * search on a sorted `array`.
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * _.sortedLastIndexOf([1, 1, 2, 2], 2);
 * // => 3
 * @template T
 * @param {!ArrayLike<T>} array
 * @param {T} value
 * @return {number}
 */
_.LoDashStatic.prototype.sortedLastIndexOf = function(array, value) {};

/**
 * @see _.rest
 * @template T
 * @param {!ArrayLike<T>} array
 * @return {!Array<T>}
 */
_.LoDashStatic.prototype.tail = function(array) {};

/**
 * @see _.rest
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.tail = function() {};

/**
 * @see _.rest
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.tail = function() {};

/**
 * @see _.rest
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.tail = function() {};

/**
 * @see _.rest
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.tail = function() {};

/**
 * Creates a slice of array with n elements taken from the beginning.
 * 
 * @template T
 * @param {!ArrayLike<T>} array The array to query.
 * @param {number=} n The number of elements to take.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.take = function(array, n) {};

/**
 * @see _.take
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.take = function(n) {};

/**
 * @see _.take
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.take = function(n) {};

/**
 * @see _.take
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.take = function(n) {};

/**
 * @see _.take
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.take = function(n) {};

/**
 * Creates a slice of array with n elements taken from the end.
 * 
 * @template T
 * @param {!ArrayLike<T>} array The array to query.
 * @param {number=} n The number of elements to take.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.takeRight = function(array, n) {};

/**
 * @see _.takeRight
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.takeRight = function(n) {};

/**
 * @see _.takeRight
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.takeRight = function(n) {};

/**
 * @see _.takeRight
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.takeRight = function(n) {};

/**
 * @see _.takeRight
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.takeRight = function(n) {};

/**
 * Creates a slice of array with elements taken from the end. Elements are taken until predicate returns
 * falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TValue, TWhere
 * @param {!ArrayLike<TValue>} array The array to query.
 * @param {function(TValue, number, !ArrayLike<TValue>): boolean|string|TWhere=} predicate The function invoked per iteration.
 * @return {!Array<TValue>} Returns the slice of array.
 */
_.LoDashStatic.prototype.takeRightWhile = function(array, predicate) {};

/**
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TWhere
 * @param {function(T, number, !ArrayLike<T>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.takeRightWhile = function(predicate) {};

/**
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TValue, TWhere
 * @param {function(TValue, number, !ArrayLike<TValue>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.takeRightWhile = function(predicate) {};

/**
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TWhere
 * @param {function(T, number, !ArrayLike<T>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.takeRightWhile = function(predicate) {};

/**
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TValue, TWhere
 * @param {function(TValue, number, !ArrayLike<TValue>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.takeRightWhile = function(predicate) {};

/**
 * Creates a slice of array with elements taken from the beginning. Elements are taken until predicate returns
 * falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TValue, TWhere
 * @param {!ArrayLike<TValue>} array The array to query.
 * @param {function(TValue, number, !ArrayLike<TValue>): boolean|string|TWhere=} predicate The function invoked per iteration.
 * @return {!Array<TValue>} Returns the slice of array.
 */
_.LoDashStatic.prototype.takeWhile = function(array, predicate) {};

/**
 * @see _.takeWhile
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TWhere
 * @param {function(T, number, !ArrayLike<T>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.takeWhile = function(predicate) {};

/**
 * @see _.takeWhile
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TValue, TWhere
 * @param {function(TValue, number, !ArrayLike<TValue>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.takeWhile = function(predicate) {};

/**
 * @see _.takeWhile
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TWhere
 * @param {function(T, number, !ArrayLike<T>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.takeWhile = function(predicate) {};

/**
 * @see _.takeWhile
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TValue, TWhere
 * @param {function(TValue, number, !ArrayLike<TValue>): boolean|string|TWhere=} predicate
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.takeWhile = function(predicate) {};

/**
 * Creates an array of unique values, in order, from all of the provided arrays using SameValueZero for
 * equality comparisons.
 * 
 * @template T
 * @param {...!ArrayLike<T>} arrays The arrays to inspect.
 * @return {!Array<T>} Returns the new array of combined values.
 */
_.LoDashStatic.prototype.union = function(arrays) {};

/**
 * @see _.union
 * @see _.union
 * @template T
 * @param {...!ArrayLike<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.union = function(arrays) {};

/**
 * @see _.union
 * @template T
 * @param {...!ArrayLike<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.union = function(arrays) {};

/**
 * @see _.union
 * @see _.union
 * @template T
 * @param {...!ArrayLike<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.union = function(arrays) {};

/**
 * @see _.union
 * @template T
 * @param {...!ArrayLike<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.union = function(arrays) {};

/**
 * This method is like `_.union` except that it accepts `iteratee` which is
 * invoked for each element of each `arrays` to generate the criterion by which
 * uniqueness is computed. The iteratee is invoked with one argument: (value).
 * 
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @template T, W
 * @param {!ArrayLike<T>} arrays_or_arrays1 The arrays to inspect.
 * @param {...function(T): ?|W|!ArrayLike<T>|?=} iteratee_or_arrays2 The iteratee invoked per element.
 * @return {!Array<T>} Returns the new array of combined values.
 */
_.LoDashStatic.prototype.unionBy = function(arrays_or_arrays1, iteratee_or_arrays2) {};

/**
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @template T, W
 * @param {...function(T): ?|W|!ArrayLike<T>|?=} iteratee_or_arrays2
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.unionBy = function(iteratee_or_arrays2) {};

/**
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @template T, W
 * @param {...function(T): ?|W|!ArrayLike<T>|?=} iteratee_or_arrays2
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.unionBy = function(iteratee_or_arrays2) {};

/**
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @template T, W
 * @param {...function(T): ?|W|!ArrayLike<T>|?=} iteratee_or_arrays2
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.unionBy = function(iteratee_or_arrays2) {};

/**
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @see _.unionBy
 * @template T, W
 * @param {...function(T): ?|W|!ArrayLike<T>|?=} iteratee_or_arrays2
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.unionBy = function(iteratee_or_arrays2) {};

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept.
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 * @see _.uniq
 * @template T, TSort
 * @param {!ArrayLike<T>} array
 * @return {!Array<T>}
 */
_.LoDashStatic.prototype.uniq = function(array) {};

/**
 * @see _.uniq
 * @template TSort
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.uniq = function() {};

/**
 * @see _.uniq
 * @see _.uniq
 * @template TSort
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.uniq = function() {};

/**
 * @see _.uniq
 * @template T, TSort
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.uniq = function() {};

/**
 * @see _.uniq
 * @template TSort
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapper.prototype.uniq = function() {};

/**
 * @see _.uniq
 * @see _.uniq
 * @template TSort
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.uniq = function() {};

/**
 * @see _.uniq
 * @see _.uniq
 * @template T, TSort
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.uniq = function() {};

/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The iteratee is invoked with one argument: (value).
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 * 
 * // using the `_.property` iteratee shorthand
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 * @see _.uniqBy
 * @see _.uniqBy
 * @see _.uniqBy
 * @see _.uniqBy
 * @template T, TSort, TWhere
 * @param {!ArrayLike<T>} array
 * @param {function(T, number, !ArrayLike<T>): ?|function(T, number, !ArrayLike<T>): TSort|string|!Object|TWhere} iteratee
 * @return {!Array<T>}
 */
_.LoDashStatic.prototype.uniqBy = function(array, iteratee) {};

/**
 * @see _.uniqBy
 * @template TSort
 * @param {function(T, number, !ArrayLike<T>): TSort} iteratee
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.uniqBy = function(iteratee) {};

/**
 * @see _.uniqBy
 * @see _.uniqBy
 * @see _.uniqBy
 * @template TSort, TWhere
 * @param {function(T, number, !ArrayLike<T>): TSort|string|TWhere} iteratee
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.uniqBy = function(iteratee) {};

/**
 * @see _.uniqBy
 * @see _.uniqBy
 * @see _.uniqBy
 * @see _.uniqBy
 * @see _.uniqBy
 * @template T, TSort, TWhere
 * @param {function(T, number, !ArrayLike<T>): ?|function(T, number, !ArrayLike<T>): TSort|string|!Object|TWhere} iteratee
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.uniqBy = function(iteratee) {};

/**
 * @see _.uniqBy
 * @template TSort
 * @param {function(T, number, !ArrayLike<T>): TSort} iteratee
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapper.prototype.uniqBy = function(iteratee) {};

/**
 * @see _.uniqBy
 * @see _.uniqBy
 * @see _.uniqBy
 * @template TSort, TWhere
 * @param {function(T, number, !ArrayLike<T>): TSort|string|TWhere} iteratee
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.uniqBy = function(iteratee) {};

/**
 * @see _.uniqBy
 * @see _.uniqBy
 * @see _.uniqBy
 * @see _.uniqBy
 * @see _.uniqBy
 * @template T, TSort, TWhere
 * @param {function(T, number, !ArrayLike<T>): ?|function(T, number, !ArrayLike<T>): TSort|string|!Object|TWhere} iteratee
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.uniqBy = function(iteratee) {};

/**
 * This method is like `_.uniq` except that it's designed and optimized
 * for sorted arrays.
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * _.sortedUniq([1, 1, 2]);
 * // => [1, 2]
 * @see _.sortedUniq
 * @template T, TSort
 * @param {!ArrayLike<T>} array
 * @return {!Array<T>}
 */
_.LoDashStatic.prototype.sortedUniq = function(array) {};

/**
 * @see _.sortedUniq
 * @template TSort
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.sortedUniq = function() {};

/**
 * @see _.sortedUniq
 * @see _.sortedUniq
 * @template TSort
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.sortedUniq = function() {};

/**
 * @see _.sortedUniq
 * @template T, TSort
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.sortedUniq = function() {};

/**
 * @see _.sortedUniq
 * @template TSort
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapper.prototype.sortedUniq = function() {};

/**
 * @see _.sortedUniq
 * @see _.sortedUniq
 * @template TSort
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.sortedUniq = function() {};

/**
 * @see _.sortedUniq
 * @see _.sortedUniq
 * @template T, TSort
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.sortedUniq = function() {};

/**
 * This method is like `_.uniqBy` except that it's designed and optimized
 * for sorted arrays.
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
 * // => [1.1, 2.2]
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @template T, TSort, TWhere
 * @param {!ArrayLike<T>} array
 * @param {function(T, number, !ArrayLike<T>): ?|function(T, number, !ArrayLike<T>): TSort|string|!Object|TWhere} iteratee
 * @return {!Array<T>}
 */
_.LoDashStatic.prototype.sortedUniqBy = function(array, iteratee) {};

/**
 * @see _.sortedUniqBy
 * @template TSort
 * @param {function(T, number, !ArrayLike<T>): TSort} iteratee
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.sortedUniqBy = function(iteratee) {};

/**
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @template TSort, TWhere
 * @param {function(T, number, !ArrayLike<T>): TSort|string|TWhere} iteratee
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.sortedUniqBy = function(iteratee) {};

/**
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @template T, TSort, TWhere
 * @param {function(T, number, !ArrayLike<T>): ?|function(T, number, !ArrayLike<T>): TSort|string|!Object|TWhere} iteratee
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.sortedUniqBy = function(iteratee) {};

/**
 * @see _.sortedUniqBy
 * @template TSort
 * @param {function(T, number, !ArrayLike<T>): TSort} iteratee
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapper.prototype.sortedUniqBy = function(iteratee) {};

/**
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @template TSort, TWhere
 * @param {function(T, number, !ArrayLike<T>): TSort|string|TWhere} iteratee
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.sortedUniqBy = function(iteratee) {};

/**
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @see _.sortedUniqBy
 * @template T, TSort, TWhere
 * @param {function(T, number, !ArrayLike<T>): ?|function(T, number, !ArrayLike<T>): TSort|string|!Object|TWhere} iteratee
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.sortedUniqBy = function(iteratee) {};

/**
 * This method is like `_.union` except that it accepts `comparator` which
 * is invoked to compare elements of `arrays`. The comparator is invoked
 * with two arguments: (arrVal, othVal).
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 * 
 * _.unionWith(objects, others, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
 * @param {!ArrayLike<?>} array
 * @param {...?} values
 * @return {!Array<?>}
 */
_.LoDashStatic.prototype.unionWith = function(array, values) {};

/**
 * This method is like `_.uniq` except that it accepts `comparator` which
 * is invoked to compare elements of `array`. The comparator is invoked with
 * two arguments: (arrVal, othVal).
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];
 * 
 * _.uniqWith(objects, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 * @param {!ArrayLike<?>} array
 * @param {...?} values
 * @return {!Array<?>}
 */
_.LoDashStatic.prototype.uniqWith = function(array, values) {};

/**
 * This method is like _.zip except that it accepts an array of grouped elements and creates an array
 * regrouping the elements to their pre-zip configuration.
 * 
 * @template T
 * @param {!ArrayLike<!ArrayLike<T>>} array The array of grouped elements to process.
 * @return {!Array<!Array<T>>} Returns the new array of regrouped elements.
 */
_.LoDashStatic.prototype.unzip = function(array) {};

/**
 * @see _.unzip
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.unzip = function() {};

/**
 * @see _.unzip
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.unzip = function() {};

/**
 * @see _.unzip
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.unzip = function() {};

/**
 * @see _.unzip
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.unzip = function() {};

/**
 * This method is like _.unzip except that it accepts an iteratee to specify how regrouped values should be
 * combined. The iteratee is bound to thisArg and invoked with four arguments: (accumulator, value, index,
 * group).
 * 
 * @template TArray, TResult
 * @param {!ArrayLike<!ArrayLike<TArray>>} array The array of grouped elements to process.
 * @param {function(TResult, TArray, ?, !Array<TArray>): TResult=} iteratee The function to combine regrouped values.
 * @return {!Array<TResult>} Returns the new array of regrouped elements.
 */
_.LoDashStatic.prototype.unzipWith = function(array, iteratee) {};

/**
 * @see _.unzipWith
 * @template TArr, TResult
 * @param {function(TResult, TArr, ?, !Array<TArr>): TResult=} iteratee
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.unzipWith = function(iteratee) {};

/**
 * @see _.unzipWith
 * @template TArr, TResult
 * @param {function(TResult, TArr, ?, !Array<TArr>): TResult=} iteratee
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.unzipWith = function(iteratee) {};

/**
 * Creates an array excluding all provided values using SameValueZero for equality comparisons.
 * 
 * @template T
 * @param {!ArrayLike<T>} array The array to filter.
 * @param {...T} values The values to exclude.
 * @return {!Array<T>} Returns the new array of filtered values.
 */
_.LoDashStatic.prototype.without = function(array, values) {};

/**
 * @see _.without
 * @param {...T} values
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.without = function(values) {};

/**
 * @see _.without
 * @template T
 * @param {...T} values
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.without = function(values) {};

/**
 * @see _.without
 * @param {...T} values
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.without = function(values) {};

/**
 * @see _.without
 * @template T
 * @param {...T} values
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.without = function(values) {};

/**
 * Creates an array of unique values that is the symmetric difference of the provided arrays.
 * 
 * @template T
 * @param {...!ArrayLike<T>} arrays The arrays to inspect.
 * @return {!Array<T>} Returns the new array of values.
 */
_.LoDashStatic.prototype.xor = function(arrays) {};

/**
 * @see _.xor
 * @param {...!ArrayLike<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.xor = function(arrays) {};

/**
 * @see _.xor
 * @template T
 * @param {...!ArrayLike<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.xor = function(arrays) {};

/**
 * @see _.xor
 * @param {...!ArrayLike<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.xor = function(arrays) {};

/**
 * @see _.xor
 * @template T
 * @param {...!ArrayLike<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.xor = function(arrays) {};

/**
 * This method is like `_.xor` except that it accepts `iteratee` which is
 * invoked for each element of each `arrays` to generate the criterion by which
 * uniqueness is computed. The iteratee is invoked with one argument: (value).
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);
 * // => [1.2, 4.3]
 * 
 * // using the `_.property` iteratee shorthand
 * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 2 }]
 * @param {!ArrayLike<?>} array
 * @param {...?} values
 * @return {!Array<?>}
 */
_.LoDashStatic.prototype.xorBy = function(array, values) {};

/**
 * This method is like `_.xor` except that it accepts `comparator` which is
 * invoked to compare elements of `arrays`. The comparator is invoked with
 * two arguments: (arrVal, othVal).
 * 
 * \@memberOf _
 * \@category Array
 * \@example 
 * 
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 * 
 * _.xorWith(objects, others, _.isEqual);
 * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
 * @param {!ArrayLike<?>} array
 * @param {...?} values
 * @return {!Array<?>}
 */
_.LoDashStatic.prototype.xorWith = function(array, values) {};

/**
 * Creates an array of grouped elements, the first of which contains the first elements of the given arrays,
 * the second of which contains the second elements of the given arrays, and so on.
 * 
 * @template T
 * @param {...!ArrayLike<T>} arrays The arrays to process.
 * @return {!Array<!Array<T>>} Returns the new array of grouped elements.
 */
_.LoDashStatic.prototype.zip = function(arrays) {};

/**
 * @see _.zip
 * @template T
 * @param {...!ArrayLike<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.zip = function(arrays) {};

/**
 * @see _.zip
 * @template T
 * @param {...!ArrayLike<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.zip = function(arrays) {};

/**
 * @see _.zip
 * @template T
 * @param {...!ArrayLike<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.zip = function(arrays) {};

/**
 * @see _.zip
 * @template T
 * @param {...!ArrayLike<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.zip = function(arrays) {};

/**
 * This method is like _.fromPairs except that it accepts two arrays, one of property
 * identifiers and one of corresponding values.
 * 
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {(!ArrayLike<!_.StringRepresentable>|!ArrayLike<!ArrayLike<?>>)} props The property names.
 * @param {!ArrayLike<TValues>|!ArrayLike<?>=} values The property values.
 * @return {TResult|!_.Dictionary<?>} Returns the new object.
 */
_.LoDashStatic.prototype.zipObject = function(props, values) {};

/**
 * This method is like _.zipObject except that it supports property paths.
 * 
 * @see _.zipObjectDeep
 * @see _.zipObjectDeep
 * @template TValues, TResult
 * @param {(!ArrayLike<!_.StringRepresentable>|!ArrayLike<!ArrayLike<?>>)} props The property names.
 * @param {!ArrayLike<TValues>|!ArrayLike<?>=} values The property values.
 * @return {TResult|!_.Dictionary<?>} Returns the new object.
 */
_.LoDashStatic.prototype.zipObjectDeep = function(props, values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!ArrayLike<TValues>|!ArrayLike<?>=} values
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashImplicitArrayWrapper.prototype.zipObject = function(values) {};

/**
 * @see _.zipObjectDeep
 * @see _.zipObjectDeep
 * @see _.zipObjectDeep
 * @template TValues, TResult
 * @param {!ArrayLike<TValues>|!ArrayLike<?>=} values
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashImplicitArrayWrapper.prototype.zipObjectDeep = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!ArrayLike<TValues>|!ArrayLike<?>=} values
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashImplicitObjectWrapper.prototype.zipObject = function(values) {};

/**
 * @see _.zipObjectDeep
 * @see _.zipObjectDeep
 * @see _.zipObjectDeep
 * @template TValues, TResult
 * @param {!ArrayLike<TValues>|!ArrayLike<?>=} values
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashImplicitObjectWrapper.prototype.zipObjectDeep = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!ArrayLike<TValues>|!ArrayLike<?>=} values
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashExplicitArrayWrapper.prototype.zipObject = function(values) {};

/**
 * @see _.zipObjectDeep
 * @see _.zipObjectDeep
 * @see _.zipObjectDeep
 * @template TValues, TResult
 * @param {!ArrayLike<TValues>|!ArrayLike<?>=} values
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashExplicitArrayWrapper.prototype.zipObjectDeep = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!ArrayLike<TValues>|!ArrayLike<?>=} values
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashExplicitObjectWrapper.prototype.zipObject = function(values) {};

/**
 * @see _.zipObjectDeep
 * @see _.zipObjectDeep
 * @see _.zipObjectDeep
 * @template TValues, TResult
 * @param {!ArrayLike<TValues>|!ArrayLike<?>=} values
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashExplicitObjectWrapper.prototype.zipObjectDeep = function(values) {};

/**
 * This method is like _.zip except that it accepts an iteratee to specify how grouped values should be
 * combined. The iteratee is bound to thisArg and invoked with four arguments: (accumulator, value, index,
 * group).
 * @template TResult
 * @param {...?} args
 * @return {!Array<TResult>} Returns the new array of grouped elements.
 */
_.LoDashStatic.prototype.zipWith = function(args) {};

/**
 * @see _.zipWith
 * @template TResult
 * @param {...?} args
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.zipWith = function(args) {};

/**
 * Creates a lodash object that wraps value with explicit method chaining enabled.
 * 
 * @template T
 * @param {number|string|boolean|null|!Array<T>|!ReadonlyArray<T>|T|?} value The value to wrap.
 * @return {!_.LoDashExplicitWrapper<number>|!_.LoDashExplicitWrapper<string>|!_.LoDashExplicitWrapper<boolean>|!_.LoDashExplicitWrapper<null>|!_.LoDashExplicitArrayWrapper<T>|!_.LoDashExplicitNillableArrayWrapper<T>|!_.LoDashExplicitObjectWrapper<T>|!_.LoDashExplicitWrapper<?>} Returns the new lodash wrapper instance.
 */
_.LoDashStatic.prototype.chain = function(value) {};

/**
 * @see _.chain
 * @return {!_.LoDashExplicitWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.chain = function() {};

/**
 * @see _.chain
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.chain = function() {};

/**
 * @see _.chain
 * @return {!_.LoDashExplicitNillableArrayWrapper<T>}
 */
_.LoDashImplicitNillableArrayWrapper.prototype.chain = function() {};

/**
 * @see _.chain
 * @return {!_.LoDashExplicitObjectWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.chain = function() {};

/**
 * @see _.chain
 * @return {!_.LoDashExplicitNillableObjectWrapper<T>}
 */
_.LoDashImplicitNillableObjectWrapper.prototype.chain = function() {};

/**
 * @see _.chain
 * @return {TWrapper}
 */
_.LoDashExplicitWrapperBase.prototype.chain = function() {};

/**
 * This method invokes interceptor and returns value. The interceptor is bound to thisArg and invoked with one
 * argument; (value). The purpose of this method is to "tap into" a method chain in order to perform operations
 * on intermediate results within the chain.
 * 
 * \@parem thisArg The this binding of interceptor.
 * @template T
 * @param {T} value The value to provide to interceptor.
 * @param {function(T): void} interceptor The function to invoke.
 * @return {T} Returns value.
 * 
 */
_.LoDashStatic.prototype.tap = function(value, interceptor) {};

/**
 * @see _.tap
 * @param {function(T): void} interceptor
 * @return {TWrapper}
 */
_.LoDashImplicitWrapperBase.prototype.tap = function(interceptor) {};

/**
 * @see _.tap
 * @param {function(T): void} interceptor
 * @return {TWrapper}
 */
_.LoDashExplicitWrapperBase.prototype.tap = function(interceptor) {};

/**
 * This method is like _.tap except that it returns the result of interceptor.
 * 
 * @template T, TResult
 * @param {T} value The value to provide to interceptor.
 * @param {function(T): TResult} interceptor The function to invoke.
 * @return {TResult} Returns the result of interceptor.
 */
_.LoDashStatic.prototype.thru = function(value, interceptor) {};

/**
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @template TResult
 * @param {function(T): TResult|function(T): !Array<TResult>} interceptor
 * @return {!_.LoDashImplicitWrapper<TResult>|!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitWrapperBase.prototype.thru = function(interceptor) {};

/**
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @template TResult
 * @param {function(T): TResult|function(T): !Array<TResult>} interceptor
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitWrapperBase.prototype.thru = function(interceptor) {};

/**
 * Executes the chained sequence and returns the wrapped result.
 * 
 * @return {TWrapper} Returns the new lodash wrapper instance.
 */
_.LoDashImplicitWrapperBase.prototype.commit = function() {};

/**
 * @see _.commit
 * @return {TWrapper}
 */
_.LoDashExplicitWrapperBase.prototype.commit = function() {};

/**
 * Creates a new array joining a wrapped array with any additional arrays and/or values.
 * 
 * @see _.concat
 * @template TItem
 * @param {...(TItem|!Array<TItem>)|(T|!Array<T>)} items
 * @return {!_.LoDashImplicitArrayWrapper<TItem>|!_.LoDashImplicitArrayWrapper<T>} Returns the new concatenated array.
 */
_.LoDashImplicitWrapperBase.prototype.concat = function(items) {};

/**
 * @see _.concat
 * @see _.concat
 * @template TItem
 * @param {...(TItem|!Array<TItem>)|(T|!Array<T>)} items
 * @return {!_.LoDashExplicitArrayWrapper<TItem>|!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapperBase.prototype.concat = function(items) {};

/**
 * Creates a clone of the chained sequence planting value as the wrapped value.
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @template T
 * @param {number|string|boolean|!Array<number>|!Array<T>|!ReadonlyArray<T>|T|?} value The value to plant as the wrapped value.
 * @return {!_.LoDashImplicitWrapper<number>|!_.LoDashImplicitStringWrapper|!_.LoDashImplicitWrapper<boolean>|!_.LoDashImplicitNumberArrayWrapper|!_.LoDashImplicitArrayWrapper<T>|!_.LoDashImplicitObjectWrapper<T>|!_.LoDashImplicitWrapper<?>} Returns the new lodash wrapper instance.
 */
_.LoDashImplicitWrapperBase.prototype.plant = function(value) {};

/**
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @template T
 * @param {number|string|boolean|!Array<number>|!Array<T>|!ReadonlyArray<T>|T|?} value
 * @return {!_.LoDashExplicitWrapper<number>|!_.LoDashExplicitStringWrapper|!_.LoDashExplicitWrapper<boolean>|!_.LoDashExplicitNumberArrayWrapper|!_.LoDashExplicitArrayWrapper<T>|!_.LoDashExplicitObjectWrapper<T>|!_.LoDashExplicitWrapper<?>}
 */
_.LoDashExplicitWrapperBase.prototype.plant = function(value) {};

/**
 * Reverses the wrapped array so the first element becomes the last, the second element becomes the second to
 * last, and so on.
 * 
 * Note: This method mutates the wrapped array.
 * 
 * @return {!_.LoDashImplicitArrayWrapper} Returns the new reversed lodash wrapper instance.
 */
_.LoDashImplicitArrayWrapper.prototype.reverse = function() {};

/**
 * @see _.reverse
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.reverse = function() {};

/**
 * @see _.value
 * @return {T}
 */
_.LoDashWrapperBase.prototype.toJSON = function() {};

/**
 * Produces the result of coercing the unwrapped value to a string.
 * 
 * @return {string} Returns the coerced string value.
 */
_.LoDashWrapperBase.prototype.toString = function() {};

/**
 * Executes the chained sequence to extract the unwrapped value.
 * 
 * \@alias _.toJSON, _.valueOf
 * 
 * @return {T} Returns the resolved unwrapped value.
 */
_.LoDashWrapperBase.prototype.value = function() {};

/**
 * @see _.value
 * @return {T}
 */
_.LoDashWrapperBase.prototype.valueOf = function() {};

/**
 * Creates an array of elements corresponding to the given keys, or indexes, of collection. Keys may be
 * specified as individual arguments or as arrays of keys.
 * 
 * @template T
 * @param {(!ArrayLike<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {...(string|number|!Array<(string|number)>)} props The property names or indexes of elements to pick, specified individually or in arrays.
 * @return {!Array<T>} Returns the new array of picked elements.
 */
_.LoDashStatic.prototype.at = function(collection, props) {};

/**
 * @see _.at
 * @param {...(string|number|!Array<(string|number)>)} props
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.at = function(props) {};

/**
 * @see _.at
 * @template T
 * @param {...(string|number|!Array<(string|number)>)} props
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.at = function(props) {};

/**
 * @see _.at
 * @param {...(string|number|!Array<(string|number)>)} props
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.at = function(props) {};

/**
 * @see _.at
 * @template T
 * @param {...(string|number|!Array<(string|number)>)} props
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.at = function(props) {};

/**
 * Creates an object composed of keys generated from the results of running each element of collection through
 * iteratee. The corresponding value of each key is the number of times the key was returned by iteratee. The
 * iteratee is bound to thisArg and invoked with three arguments:
 * (value, index|key, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template T, W
 * @param {!ArrayLike<T>|!_.Dictionary<T>|!_.NumericDictionary<T>|(!ArrayLike<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)} collection The collection to iterate over.
 * @param {function(T, number, !ArrayLike<T>): ?|function(T, string, !_.Dictionary<T>): ?|function(T, number, !_.Dictionary<T>): ?|string|W|!Object=} iteratee The function invoked per iteration.
 * @return {!_.Dictionary<number>} Returns the composed aggregate object.
 */
_.LoDashStatic.prototype.countBy = function(collection, iteratee) {};

/**
 * @see _.countBy
 * @param {function(T, number, !ArrayLike<T>): ?=} iteratee
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashImplicitWrapper.prototype.countBy = function(iteratee) {};

/**
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template W
 * @param {function(T, number, !ArrayLike<T>): ?|string|W=} iteratee
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.countBy = function(iteratee) {};

/**
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template T, W
 * @param {(function(T, number, !ArrayLike<T>): ?|function(T, string, !_.Dictionary<T>): ?|function(T, number, !_.Dictionary<T>): ?)|string|W=} iteratee
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.countBy = function(iteratee) {};

/**
 * @see _.countBy
 * @param {function(T, number, !ArrayLike<T>): ?=} iteratee
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashExplicitWrapper.prototype.countBy = function(iteratee) {};

/**
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template W
 * @param {function(T, number, !ArrayLike<T>): ?|string|W=} iteratee
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.countBy = function(iteratee) {};

/**
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template T, W
 * @param {(function(T, number, !ArrayLike<T>): ?|function(T, string, !_.Dictionary<T>): ?|function(T, number, !_.Dictionary<T>): ?)|string|W=} iteratee
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.countBy = function(iteratee) {};

/**
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @template T, TValue
 * @param {!Array<T>|string|!ArrayLike<T>|!_.Dictionary<T>|T} collection
 * @param {function(T, number, !ArrayLike<T>): ?|function(string, number, !ArrayLike<string>): ?|function(T, string, !_.Dictionary<T>): ?|function(?, string, ?): ?|function(TValue, string, ?): ?=} iteratee
 * @return {!Array<T>|string|!ArrayLike<T>|!_.Dictionary<T>|T}
 */
_.LoDashStatic.prototype.each = function(collection, iteratee) {};

/**
 * @see _.forEach
 * @param {function(string, number, !ArrayLike<string>): ?} iteratee
 * @return {!_.LoDashImplicitWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.each = function(iteratee) {};

/**
 * @see _.forEach
 * @param {function(T, number, !ArrayLike<T>): ?} iteratee
 * @return {TWrapper}
 */
_.LoDashImplicitArrayWrapperBase.prototype.each = function(iteratee) {};

/**
 * @see _.forEach
 * @template TValue
 * @param {(function(TValue, number, !ArrayLike<TValue>): ?|function(TValue, string, !_.Dictionary<TValue>): ?)=} iteratee
 * @return {TWrapper}
 */
_.LoDashImplicitObjectWrapperBase.prototype.each = function(iteratee) {};

/**
 * @see _.forEach
 * @param {function(string, number, !ArrayLike<string>): ?} iteratee
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.each = function(iteratee) {};

/**
 * @see _.forEach
 * @param {function(T, number, !ArrayLike<T>): ?} iteratee
 * @return {TWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.each = function(iteratee) {};

/**
 * @see _.forEach
 * @template TValue
 * @param {(function(TValue, number, !ArrayLike<TValue>): ?|function(TValue, string, !_.Dictionary<TValue>): ?)=} iteratee
 * @return {TWrapper}
 */
_.LoDashExplicitObjectWrapperBase.prototype.each = function(iteratee) {};

/**
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @template T, TValue
 * @param {string|!Array<T>|!ArrayLike<T>|!_.Dictionary<T>|T} collection
 * @param {function(string, number, !ArrayLike<string>): ?|function(T, number, !ArrayLike<T>): ?|function(T, string, !_.Dictionary<T>): ?|function(?, string, ?): ?|function(TValue, string, ?): ?=} iteratee
 * @return {string|!Array<T>|!ArrayLike<T>|!_.Dictionary<T>|T}
 */
_.LoDashStatic.prototype.eachRight = function(collection, iteratee) {};

/**
 * @see _.forEachRight
 * @param {function(string, number, !ArrayLike<string>): ?} iteratee
 * @return {!_.LoDashImplicitWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.eachRight = function(iteratee) {};

/**
 * @see _.forEachRight
 * @param {function(T, number, !ArrayLike<T>): ?} iteratee
 * @return {TWrapper}
 */
_.LoDashImplicitArrayWrapperBase.prototype.eachRight = function(iteratee) {};

/**
 * @see _.forEachRight
 * @template TValue
 * @param {(function(TValue, number, !ArrayLike<TValue>): ?|function(TValue, string, !_.Dictionary<TValue>): ?)=} iteratee
 * @return {TWrapper}
 */
_.LoDashImplicitObjectWrapperBase.prototype.eachRight = function(iteratee) {};

/**
 * @see _.forEachRight
 * @param {function(string, number, !ArrayLike<string>): ?} iteratee
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.eachRight = function(iteratee) {};

/**
 * @see _.forEachRight
 * @param {function(T, number, !ArrayLike<T>): ?} iteratee
 * @return {TWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.eachRight = function(iteratee) {};

/**
 * @see _.forEachRight
 * @template TValue
 * @param {(function(TValue, number, !ArrayLike<TValue>): ?|function(TValue, string, !_.Dictionary<TValue>): ?)=} iteratee
 * @return {TWrapper}
 */
_.LoDashExplicitObjectWrapperBase.prototype.eachRight = function(iteratee) {};

/**
 * Checks if predicate returns truthy for all elements of collection. Iteration is stopped once predicate
 * returns falsey. The predicate is invoked with three arguments: (value, index|key, collection).
 * 
 * @see _.every
 * @see _.every
 * @see _.every
 * @see _.every
 * @template T
 * @param {!ArrayLike<T>|!_.Dictionary<T>|!_.NumericDictionary<T>|(!ArrayLike<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)} collection The collection to iterate over.
 * @param {function(T, number, !ArrayLike<T>): boolean|function(T, string, !_.Dictionary<T>): boolean|function(T, number, !_.Dictionary<T>): boolean|(string|!Array<?>)|?=} predicate The function invoked per iteration.
 * @return {boolean} Returns true if all elements pass the predicate check, else false.
 */
_.LoDashStatic.prototype.every = function(collection, predicate) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @param {(function(T, number, !ArrayLike<T>): boolean|function(T, number, !_.Dictionary<T>): boolean)|(string|!Array<?>)|?=} predicate
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapperBase.prototype.every = function(predicate) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TResult
 * @param {(function(TResult, number, !ArrayLike<TResult>): boolean|function(TResult, string, !_.Dictionary<TResult>): boolean|function(T, number, !_.Dictionary<T>): boolean)|(string|!Array<?>)|?=} predicate
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapperBase.prototype.every = function(predicate) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @param {(function(T, number, !ArrayLike<T>): boolean|function(T, number, !_.Dictionary<T>): boolean)|(string|!Array<?>)|?=} predicate
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.every = function(predicate) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TResult
 * @param {(function(TResult, number, !ArrayLike<TResult>): boolean|function(TResult, string, !_.Dictionary<TResult>): boolean|function(T, number, !_.Dictionary<T>): boolean)|(string|!Array<?>)|?=} predicate
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.every = function(predicate) {};

/**
 * Iterates over elements of collection, returning an array of all elements predicate returns truthy for. The
 * predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T
 * @param {!ArrayLike<T>|!_.Dictionary<T>|string|(!ArrayLike<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {function(T, number, !ArrayLike<T>): boolean|function(T, string, !_.Dictionary<T>): boolean|function(string, number, string): boolean|(string|!RegExp)|?=} predicate The function invoked per iteration.
 * @return {!Array<T>|!Array<string>} Returns the new filtered array.
 */
_.LoDashStatic.prototype.filter = function(collection, predicate) {};

/**
 * @see _.filter
 * @param {function(string, number, string): boolean=} predicate
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.filter = function(predicate) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @param {function(T, number, !ArrayLike<T>): boolean|(string|!RegExp)|?} predicate
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.filter = function(predicate) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T
 * @param {(function(T, number, !ArrayLike<T>): boolean|function(T, string, !_.Dictionary<T>): boolean)|(string|!RegExp)|?} predicate
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.filter = function(predicate) {};

/**
 * @see _.filter
 * @param {function(string, number, string): boolean=} predicate
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.filter = function(predicate) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @param {function(T, number, !ArrayLike<T>): boolean|(string|!RegExp)|?} predicate
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.filter = function(predicate) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T
 * @param {(function(T, number, !ArrayLike<T>): boolean|function(T, string, !_.Dictionary<T>): boolean)|(string|!RegExp)|?} predicate
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.filter = function(predicate) {};

/**
 * Iterates over elements of collection, returning the first element predicate returns truthy for.
 * The predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.find
 * @see _.find
 * @see _.find
 * @template T
 * @param {!ArrayLike<T>|!_.Dictionary<T>|(!ArrayLike<T>|!_.Dictionary<T>)} collection The collection to search.
 * @param {function(T, number, !ArrayLike<T>): boolean|function(T, string, !_.Dictionary<T>): boolean|string|?=} predicate The function invoked per iteration.
 * @param {number=} fromIndex The index to search from.
 * @return {T} Returns the matched element, else undefined.
 */
_.LoDashStatic.prototype.find = function(collection, predicate, fromIndex) {};

/**
 * @see _.find
 * @see _.find
 * @see _.find
 * @param {function(T, number, !ArrayLike<T>): boolean|string|?=} predicate
 * @param {number=} fromIndex
 * @return {T}
 */
_.LoDashImplicitArrayWrapperBase.prototype.find = function(predicate, fromIndex) {};

/**
 * @see _.find
 * @see _.find
 * @see _.find
 * @template TResult
 * @param {(function(TResult, number, !ArrayLike<TResult>): boolean|function(TResult, string, !_.Dictionary<TResult>): boolean)|string|?=} predicate
 * @param {number=} fromIndex
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapperBase.prototype.find = function(predicate, fromIndex) {};

/**
 * @see _.find
 * @see _.find
 * @see _.find
 * @param {function(T, number, !ArrayLike<T>): boolean|string|?=} predicate
 * @param {number=} fromIndex
 * @return {?}
 */
_.LoDashExplicitWrapperBase.prototype.find = function(predicate, fromIndex) {};

/**
 * This method is like _.find except that it iterates over elements of a collection from
 * right to left.
 * @see _.find
 * 
 * @see _.find
 * 
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @template T, W
 * @param {!Array<T>|!ArrayLike<T>|!_.Dictionary<T>} collection Searches for a value in this list.
 * @param {function(T, number, !ArrayLike<T>): boolean|function(T, string, !_.Dictionary<T>): boolean|W|string} callback_or_whereValue_or_pluckValue The function called per iteration.
 * @param {number=} fromIndex The index to search from.
 * @return {T} The found element, else undefined.
 * 
 */
_.LoDashStatic.prototype.findLast = function(collection, callback_or_whereValue_or_pluckValue, fromIndex) {};

/**
 * @see _.findLast
 * @see _.findLast
 * @see _.findLast
 * @template W
 * @param {function(T, number, !ArrayLike<T>): boolean|W|string} callback_or_whereValue_or_pluckValue
 * @param {number=} fromIndex
 * @return {T}
 */
_.LoDashImplicitArrayWrapperBase.prototype.findLast = function(callback_or_whereValue_or_pluckValue, fromIndex) {};

/**
 * @see _.findLast
 * @see _.findLast
 * @see _.findLast
 * @param {function(T, number, !ArrayLike<T>): boolean|string|?=} predicate
 * @param {number=} fromIndex
 * @return {?}
 */
_.LoDashExplicitWrapperBase.prototype.findLast = function(predicate, fromIndex) {};

/**
 * Creates an array of flattened values by running each element in collection through iteratee
 * and concating its result to the other mapped values. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 * 
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @template T, TResult, TObject, TWhere
 * @param {!ArrayLike<T>|!ArrayLike<?>|!_.Dictionary<T>|!_.Dictionary<?>|!_.NumericDictionary<T>|!_.NumericDictionary<?>|TObject|!Object|string} collection The collection to iterate over.
 * @param {function(T, number, !ArrayLike<T>): (TResult|!Array<TResult>)|function(?, number, !ArrayLike<?>): (TResult|!Array<TResult>)|function(T, string, !_.Dictionary<T>): (TResult|!Array<TResult>)|function(?, string, !_.Dictionary<?>): (TResult|!Array<TResult>)|function(T, number, !_.Dictionary<T>): (TResult|!Array<TResult>)|function(?, number, !_.Dictionary<?>): (TResult|!Array<TResult>)|function(?, string, ?): (TResult|!Array<TResult>)|TWhere|(string|!Object)|!Array<?>=} iteratee The function invoked per iteration.
 * @return {!Array<TResult>|!Array<boolean>|!Array<string>} Returns the new flattened array.
 */
_.LoDashStatic.prototype.flatMap = function(collection, iteratee) {};

/**
 * @see _.flatMap
 * @see _.flatMap
 * @template TResult
 * @param {function(string, number, !ArrayLike<string>): (TResult|!Array<TResult>)=} iteratee
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.flatMap = function(iteratee) {};

/**
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @template TResult, TWhere
 * @param {(string|function(T, number, !ArrayLike<T>): (TResult|!Array<TResult>))|TWhere|!Array<?>=} iteratee
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.flatMap = function(iteratee) {};

/**
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @template T, TResult, TWhere
 * @param {(function(T, number, !ArrayLike<T>): (TResult|!Array<TResult>)|function(T, string, !_.Dictionary<T>): (TResult|!Array<TResult>)|function(T, number, !_.Dictionary<T>): (TResult|!Array<TResult>))|(string|function(?, string, ?): (TResult|!Array<TResult>))|TWhere|!Array<?>=} iteratee
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.flatMap = function(iteratee) {};

/**
 * @see _.flatMap
 * @see _.flatMap
 * @template TResult
 * @param {function(string, number, !ArrayLike<string>): (TResult|!Array<TResult>)=} iteratee
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.flatMap = function(iteratee) {};

/**
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @template TResult, TWhere
 * @param {(string|function(T, number, !ArrayLike<T>): (TResult|!Array<TResult>))|TWhere|!Array<?>=} iteratee
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.flatMap = function(iteratee) {};

/**
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @see _.flatMap
 * @template T, TResult, TWhere
 * @param {(function(T, number, !ArrayLike<T>): (TResult|!Array<TResult>)|function(T, string, !_.Dictionary<T>): (TResult|!Array<TResult>)|function(T, number, !_.Dictionary<T>): (TResult|!Array<TResult>))|(string|function(?, string, ?): (TResult|!Array<TResult>))|TWhere|!Array<?>=} iteratee
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.flatMap = function(iteratee) {};

/**
 * Iterates over elements of collection invoking iteratee for each element. The iteratee is bound to thisArg
 * and invoked with three arguments:
 * (value, index|key, collection). Iteratee functions may exit iteration early by explicitly returning false.
 * 
 * Note: As with other "Collections" methods, objects with a "length" property are iterated like arrays. To
 * avoid this behavior _.forIn or _.forOwn may be used for object iteration.
 * 
 * \@alias _.each
 * 
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @template T, TValue
 * @param {!Array<T>|string|!ArrayLike<T>|!_.Dictionary<T>|T} collection The collection to iterate over.
 * @param {function(T, number, !ArrayLike<T>): ?|function(string, number, !ArrayLike<string>): ?|function(T, string, !_.Dictionary<T>): ?|function(?, string, ?): ?|function(TValue, string, ?): ?=} iteratee The function invoked per iteration.
 * @return {!Array<T>|string|!ArrayLike<T>|!_.Dictionary<T>|T}
 */
_.LoDashStatic.prototype.forEach = function(collection, iteratee) {};

/**
 * @see _.forEach
 * @param {function(string, number, !ArrayLike<string>): ?} iteratee
 * @return {!_.LoDashImplicitWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.forEach = function(iteratee) {};

/**
 * @see _.forEach
 * @param {function(T, number, !ArrayLike<T>): ?} iteratee
 * @return {TWrapper}
 */
_.LoDashImplicitArrayWrapperBase.prototype.forEach = function(iteratee) {};

/**
 * @see _.forEach
 * @template TValue
 * @param {(function(TValue, number, !ArrayLike<TValue>): ?|function(TValue, string, !_.Dictionary<TValue>): ?)=} iteratee
 * @return {TWrapper}
 */
_.LoDashImplicitObjectWrapperBase.prototype.forEach = function(iteratee) {};

/**
 * @see _.forEach
 * @param {function(string, number, !ArrayLike<string>): ?} iteratee
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.forEach = function(iteratee) {};

/**
 * @see _.forEach
 * @param {function(T, number, !ArrayLike<T>): ?} iteratee
 * @return {TWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.forEach = function(iteratee) {};

/**
 * @see _.forEach
 * @template TValue
 * @param {(function(TValue, number, !ArrayLike<TValue>): ?|function(TValue, string, !_.Dictionary<TValue>): ?)=} iteratee
 * @return {TWrapper}
 */
_.LoDashExplicitObjectWrapperBase.prototype.forEach = function(iteratee) {};

/**
 * This method is like _.forEach except that it iterates over elements of collection from right to left.
 * 
 * \@alias _.eachRight
 * 
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @template T, TValue
 * @param {!Array<T>|string|!ArrayLike<T>|!_.Dictionary<T>|T} collection The collection to iterate over.
 * @param {function(T, number, !ArrayLike<T>): ?|function(string, number, !ArrayLike<string>): ?|function(T, string, !_.Dictionary<T>): ?|function(?, string, ?): ?|function(TValue, string, ?): ?=} iteratee The function called per iteration.
 * @return {!Array<T>|string|!ArrayLike<T>|!_.Dictionary<T>|T}
 */
_.LoDashStatic.prototype.forEachRight = function(collection, iteratee) {};

/**
 * @see _.forEachRight
 * @param {function(string, number, !ArrayLike<string>): ?} iteratee
 * @return {!_.LoDashImplicitWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.forEachRight = function(iteratee) {};

/**
 * @see _.forEachRight
 * @param {function(T, number, !ArrayLike<T>): ?} iteratee
 * @return {TWrapper}
 */
_.LoDashImplicitArrayWrapperBase.prototype.forEachRight = function(iteratee) {};

/**
 * @see _.forEachRight
 * @template TValue
 * @param {(function(TValue, number, !ArrayLike<TValue>): ?|function(TValue, string, !_.Dictionary<TValue>): ?)=} iteratee
 * @return {TWrapper}
 */
_.LoDashImplicitObjectWrapperBase.prototype.forEachRight = function(iteratee) {};

/**
 * @see _.forEachRight
 * @param {function(string, number, !ArrayLike<string>): ?} iteratee
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.forEachRight = function(iteratee) {};

/**
 * @see _.forEachRight
 * @param {function(T, number, !ArrayLike<T>): ?} iteratee
 * @return {TWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.forEachRight = function(iteratee) {};

/**
 * @see _.forEachRight
 * @template TValue
 * @param {(function(TValue, number, !ArrayLike<TValue>): ?|function(TValue, string, !_.Dictionary<TValue>): ?)=} iteratee
 * @return {TWrapper}
 */
_.LoDashExplicitObjectWrapperBase.prototype.forEachRight = function(iteratee) {};

/**
 * Creates an object composed of keys generated from the results of running each element of collection through
 * iteratee. The corresponding value of each key is an array of the elements responsible for generating the
 * key. The iteratee is bound to thisArg and invoked with three arguments:
 * (value, index|key, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template T, TKey, TValue, TWhere
 * @param {!ArrayLike<T>|!ArrayLike<?>|!_.Dictionary<T>|!_.Dictionary<?>|(!ArrayLike<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {function(T, number, !ArrayLike<T>): TKey|function(T, number, !ArrayLike<T>): ?|function(T, string, !_.Dictionary<T>): TKey|function(T, string, !_.Dictionary<T>): ?|string|TWhere|!Object=} iteratee The function invoked per iteration.
 * @return {!_.Dictionary<!Array<T>>} Returns the composed aggregate object.
 */
_.LoDashStatic.prototype.groupBy = function(collection, iteratee) {};

/**
 * @see _.groupBy
 * @template TKey
 * @param {function(T, number, !ArrayLike<T>): TKey=} iteratee
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashImplicitWrapper.prototype.groupBy = function(iteratee) {};

/**
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template TKey, TValue, TWhere
 * @param {function(T, number, !ArrayLike<T>): TKey|string|TWhere=} iteratee
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.groupBy = function(iteratee) {};

/**
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template T, TKey, TValue, TWhere
 * @param {(function(T, number, !ArrayLike<T>): TKey|function(T, string, !_.Dictionary<T>): TKey)|(function(T, number, !ArrayLike<T>): ?|function(T, string, !_.Dictionary<T>): ?)|string|TWhere|!Object=} iteratee
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.groupBy = function(iteratee) {};

/**
 * @see _.groupBy
 * @template TKey
 * @param {function(T, number, !ArrayLike<T>): TKey=} iteratee
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashExplicitWrapper.prototype.groupBy = function(iteratee) {};

/**
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template TKey, TValue, TWhere
 * @param {function(T, number, !ArrayLike<T>): TKey|string|TWhere=} iteratee
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.groupBy = function(iteratee) {};

/**
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template T, TKey, TValue, TWhere
 * @param {(function(T, number, !ArrayLike<T>): TKey|function(T, string, !_.Dictionary<T>): TKey)|(function(T, number, !ArrayLike<T>): ?|function(T, string, !_.Dictionary<T>): ?)|string|TWhere|!Object=} iteratee
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.groupBy = function(iteratee) {};

/**
 * Checks if target is in collection using SameValueZero for equality comparisons. If fromIndex is negative,
 * it’s used as the offset from the end of collection.
 * 
 * @see _.includes
 * @template T
 * @param {(!ArrayLike<T>|!_.Dictionary<T>)|string} collection The collection to search.
 * @param {T|string} target The value to search for.
 * @param {number=} fromIndex The index to search from.
 * @return {boolean} True if the target element is found, else false.
 */
_.LoDashStatic.prototype.includes = function(collection, target, fromIndex) {};

/**
 * @see _.includes
 * @param {T} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapperBase.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @template TValue
 * @param {TValue} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapperBase.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {string} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {T} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @template TValue
 * @param {TValue} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {string} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.includes = function(target, fromIndex) {};

/**
 * Creates an object composed of keys generated from the results of running each element of collection through
 * iteratee. The corresponding value of each key is the last element responsible for generating the key. The
 * iteratee function is bound to thisArg and invoked with three arguments:
 * (value, index|key, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.keyBy
 * @see _.keyBy
 * @see _.keyBy
 * @see _.keyBy
 * @see _.keyBy
 * @template T, W
 * @param {!ArrayLike<T>|!_.NumericDictionary<T>|!_.Dictionary<T>|(!_.Dictionary<T>|!ArrayLike<T>|!_.NumericDictionary<T>)} collection The collection to iterate over.
 * @param {function(T, number, !ArrayLike<T>): ?|function(T, number, !_.Dictionary<T>): ?|function(T, string, !_.Dictionary<T>): ?|string|W|!Object=} iteratee The function invoked per iteration.
 * @return {!_.Dictionary<T>} Returns the composed aggregate object.
 */
_.LoDashStatic.prototype.keyBy = function(collection, iteratee) {};

/**
 * @see _.keyBy
 * @param {function(T, number, !ArrayLike<T>): ?=} iteratee
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashImplicitWrapper.prototype.keyBy = function(iteratee) {};

/**
 * @see _.keyBy
 * @see _.keyBy
 * @see _.keyBy
 * @template W
 * @param {function(T, number, !ArrayLike<T>): ?|string|W=} iteratee
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.keyBy = function(iteratee) {};

/**
 * @see _.keyBy
 * @see _.keyBy
 * @see _.keyBy
 * @see _.keyBy
 * @template T, W
 * @param {(function(T, number, !ArrayLike<T>): ?|function(T, number, !_.Dictionary<T>): ?|function(T, string, !_.Dictionary<T>): ?)|string|W|!Object=} iteratee
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.keyBy = function(iteratee) {};

/**
 * @see _.keyBy
 * @param {function(T, number, !ArrayLike<T>): ?=} iteratee
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashExplicitWrapper.prototype.keyBy = function(iteratee) {};

/**
 * @see _.keyBy
 * @see _.keyBy
 * @see _.keyBy
 * @template W
 * @param {function(T, number, !ArrayLike<T>): ?|string|W=} iteratee
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.keyBy = function(iteratee) {};

/**
 * @see _.keyBy
 * @see _.keyBy
 * @see _.keyBy
 * @see _.keyBy
 * @template T, W
 * @param {(function(T, number, !ArrayLike<T>): ?|function(T, number, !_.Dictionary<T>): ?|function(T, string, !_.Dictionary<T>): ?)|string|W|!Object=} iteratee
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.keyBy = function(iteratee) {};

/**
 * Invokes the method at path of object.
 * @see _.invoke
 * 
 * @see _.invoke
 * 
 * @template TObject, TResult, TValue
 * @param {TObject|(!_.Dictionary<TValue>|!Array<TValue>)|?} object The object to query.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the method to invoke.
 * @param {...?} args The arguments to invoke the method with.
 * 
 * @return {TResult}
 */
_.LoDashStatic.prototype.invoke = function(object, path, args) {};

/**
 * @see _.invoke
 * 
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {...?} args
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapper.prototype.invoke = function(path, args) {};

/**
 * @see _.invoke
 * 
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {...?} args
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.invoke = function(path, args) {};

/**
 * @see _.invoke
 * 
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {...?} args
 * @return {TResult}
 */
_.LoDashExplicitArrayWrapper.prototype.invoke = function(path, args) {};

/**
 * @see _.invoke
 * 
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {...?} args
 * @return {TResult}
 */
_.LoDashExplicitObjectWrapper.prototype.invoke = function(path, args) {};

/**
 * Invokes the method named by methodName on each element in the collection returning
 * an array of the results of each invoked method. Additional arguments will be provided
 * to each invoked method. If methodName is a function it will be invoked for, and this
 * bound to, each element in the collection.
 * @see _.invokeMap
 * 
 * @see _.invokeMap
 * 
 * @see _.invokeMap
 * 
 * @see _.invokeMap
 * 
 * @see _.invokeMap
 * 
 * @see _.invokeMap
 * 
 * @see _.invokeMap
 * 
 * @template TValue, TResult
 * @param {!Array<TValue>|!_.Dictionary<TValue>|!Array<!Object>|!_.Dictionary<!Object>} collection The collection to iterate over.
 * @param {string|function(!Array<?>): TResult} methodName_or_method The name of the method to invoke.
 * @param {...?} args Arguments to invoke the method with.
 * 
 * @return {!Array<TResult>}
 */
_.LoDashStatic.prototype.invokeMap = function(collection, methodName_or_method, args) {};

/**
 * @see _.invokeMap
 * 
 * @see _.invokeMap
 * 
 * @template TResult
 * @param {string|function(!Array<?>): TResult} methodName_or_method
 * @param {...?} args
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.invokeMap = function(methodName_or_method, args) {};

/**
 * @see _.invokeMap
 * 
 * @see _.invokeMap
 * 
 * @template TResult
 * @param {string|function(!Array<?>): TResult} methodName_or_method
 * @param {...?} args
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.invokeMap = function(methodName_or_method, args) {};

/**
 * @see _.invokeMap
 * 
 * @see _.invokeMap
 * 
 * @template TResult
 * @param {string|function(!Array<?>): TResult} methodName_or_method
 * @param {...?} args
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.invokeMap = function(methodName_or_method, args) {};

/**
 * @see _.invokeMap
 * 
 * @see _.invokeMap
 * 
 * @template TResult
 * @param {string|function(!Array<?>): TResult} methodName_or_method
 * @param {...?} args
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.invokeMap = function(methodName_or_method, args) {};

/**
 * Creates an array of values by running each element in collection through iteratee. The iteratee is bound to
 * thisArg and invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property value
 * of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * Many lodash methods are guarded to work as iteratees for methods like _.every, _.filter, _.map, _.mapValues,
 * _.reject, and _.some.
 * 
 * The guarded methods are:
 * ary, callback, chunk, clone, create, curry, curryRight, drop, dropRight, every, fill, flatten, invert, max,
 * min, parseInt, slice, sortBy, take, takeRight, template, trim, trimLeft, trimRight, trunc, random, range,
 * sample, some, sum, uniq, and words
 * 
 * @see _.map
 * @see _.map
 * @see _.map
 * @see _.map
 * @see _.map
 * @see _.map
 * @see _.map
 * @template T, TResult, K, TObject
 * @param {!ArrayLike<T>|!_.Dictionary<T>|!_.NumericDictionary<T>|(!ArrayLike<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)} collection The collection to iterate over.
 * @param {function(T, number, !ArrayLike<T>): TResult|function(T, string, !_.Dictionary<T>): TResult|K|function(T, number, !_.Dictionary<T>): TResult|string|TObject=} iteratee The function invoked per iteration.
 * @return {!Array<TResult>|!Array<T>|!Array<?>|!Array<boolean>} Returns the new mapped array.
 */
_.LoDashStatic.prototype.map = function(collection, iteratee) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TResult, K, TObject
 * @param {function(T, number, !ArrayLike<T>): TResult|K|string|TObject=} iteratee
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<T>|!_.LoDashImplicitArrayWrapper<?>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.map = function(iteratee) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TValue, TResult, K, TObject
 * @param {(function(TValue, number, !ArrayLike<TValue>): TResult|function(TValue, string, !_.Dictionary<TValue>): TResult)|K|string|TObject=} iteratee
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<?>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.map = function(iteratee) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TResult, K, TObject
 * @param {function(T, number, !ArrayLike<T>): TResult|K|string|TObject=} iteratee
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<T>|!_.LoDashExplicitArrayWrapper<?>|!_.LoDashExplicitArrayWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.map = function(iteratee) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TValue, TResult, TObject
 * @param {(function(TValue, number, !ArrayLike<TValue>): TResult|function(TValue, string, !_.Dictionary<TValue>): TResult)|string|TObject=} iteratee
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<?>|!_.LoDashExplicitArrayWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.map = function(iteratee) {};

/**
 * Creates an array of elements split into two groups, the first of which contains elements predicate returns truthy for,
 * while the second of which contains elements predicate returns falsey for.
 * The predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for predicate the created _.property style callback
 * returns the property value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback
 * returns true for elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns
 * true for elements that have the properties of the given object, else false.
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @template T, W
 * @param {!ArrayLike<T>|!_.Dictionary<T>} collection The collection to iterate over.
 * @param {function(T, number, !ArrayLike<T>): boolean|function(T, string, !_.Dictionary<T>): boolean|W|string} callback_or_whereValue_or_path_or_pluckValue The function called per iteration.
 * @param {?=} srcValue
 * @return {!Array<!Array<T>>} Returns the array of grouped elements.
 * 
 */
_.LoDashStatic.prototype.partition = function(collection, callback_or_whereValue_or_path_or_pluckValue, srcValue) {};

/**
 * @see _.partition
 * @param {function(string, number, !ArrayLike<string>): boolean} callback
 * @return {!_.LoDashImplicitArrayWrapper<!Array<string>>}
 */
_.LoDashImplicitStringWrapper.prototype.partition = function(callback) {};

/**
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @template W
 * @param {function(T, number, !ArrayLike<T>): boolean|W|string} callback_or_whereValue_or_path_or_pluckValue
 * @param {?=} srcValue
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.partition = function(callback_or_whereValue_or_path_or_pluckValue, srcValue) {};

/**
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @template TResult, W
 * @param {function(TResult, number, !ArrayLike<TResult>): boolean|function(TResult, string, !_.Dictionary<TResult>): boolean|W|string} callback_or_whereValue_or_path_or_pluckValue
 * @param {?=} srcValue
 * @return {!_.LoDashImplicitArrayWrapper<!Array<TResult>>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.partition = function(callback_or_whereValue_or_path_or_pluckValue, srcValue) {};

/**
 * Reduces a collection to a value which is the accumulated result of running each
 * element in the collection through the callback, where each successive callback execution
 * consumes the return value of the previous execution. If accumulator is not provided the
 * first element of the collection will be used as the initial accumulator value. The callback
 * is bound to thisArg and invoked with four arguments; (accumulator, value, index|key, collection).
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template T, TResult
 * @param {!Array<T>|!ArrayLike<T>|!_.Dictionary<T>|!_.NumericDictionary<T>} collection The collection to iterate over.
 * @param {function(TResult, T, ?, !Array<T>): TResult} callback The function called per iteration.
 * @param {TResult=} accumulator Initial value of the accumulator.
 * @return {TResult} Returns the accumulated value.
 * 
 */
_.LoDashStatic.prototype.reduce = function(collection, callback, accumulator) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TResult
 * @param {function(TResult, T, ?, !Array<T>): TResult} callback
 * @param {TResult=} accumulator
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapperBase.prototype.reduce = function(callback, accumulator) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TValue, TResult
 * @param {function(TResult, TValue, ?, !Array<TValue>): TResult} callback
 * @param {TResult=} accumulator
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapperBase.prototype.reduce = function(callback, accumulator) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TValue, TResult
 * @param {function(TResult, TValue, ?, !Array<TValue>): TResult} callback
 * @param {TResult=} accumulator
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.reduce = function(callback, accumulator) {};

/**
 * LoDashExplicitWrapper
 * @see _.reduce
 * @see _.reduce
 * @template TResult
 * @param {function(TResult, T, ?, !Array<T>): TResult} callback
 * @param {TResult=} accumulator
 * @return {!_.LoDashExplicitWrapper<TResult>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.reduce = function(callback, accumulator) {};

/**
 * This method is like _.reduce except that it iterates over elements of a collection from
 * right to left.
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @template T, TResult
 * @param {!Array<T>|!ArrayLike<T>|!_.Dictionary<T>} collection The collection to iterate over.
 * @param {function(TResult, T, ?, !Array<T>): TResult} callback The function called per iteration.
 * @param {TResult=} accumulator Initial value of the accumulator.
 * @return {TResult} The accumulated value.
 * 
 */
_.LoDashStatic.prototype.reduceRight = function(collection, callback, accumulator) {};

/**
 * The opposite of _.filter; this method returns the elements of collection that predicate does not return
 * truthy for.
 * 
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template T, W
 * @param {!ArrayLike<T>|!_.Dictionary<T>|string|(!ArrayLike<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {function(T, number, !ArrayLike<T>): boolean|function(T, string, !_.Dictionary<T>): boolean|function(string, number, string): boolean|string|W=} predicate The function invoked per iteration.
 * @return {!Array<T>|!Array<string>} Returns the new filtered array.
 */
_.LoDashStatic.prototype.reject = function(collection, predicate) {};

/**
 * @see _.reject
 * @param {function(string, number, string): boolean=} predicate
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.reject = function(predicate) {};

/**
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template W
 * @param {function(T, number, !ArrayLike<T>): boolean|string|W} predicate
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.reject = function(predicate) {};

/**
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template T, W
 * @param {(function(T, number, !ArrayLike<T>): boolean|function(T, string, !_.Dictionary<T>): boolean)|string|W} predicate
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.reject = function(predicate) {};

/**
 * @see _.reject
 * @param {function(string, number, string): boolean=} predicate
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.reject = function(predicate) {};

/**
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template W
 * @param {function(T, number, !ArrayLike<T>): boolean|string|W} predicate
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.reject = function(predicate) {};

/**
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template T, W
 * @param {(function(T, number, !ArrayLike<T>): boolean|function(T, string, !_.Dictionary<T>): boolean)|string|W} predicate
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.reject = function(predicate) {};

/**
 * Gets a random element from collection.
 * 
 * @template T
 * @param {(!Object|!ArrayLike<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)} collection The collection to sample.
 * @return {T} Returns the random element.
 */
_.LoDashStatic.prototype.sample = function(collection) {};

/**
 * @see _.sample
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.sample = function() {};

/**
 * @see _.sample
 * @return {T}
 */
_.LoDashImplicitArrayWrapperBase.prototype.sample = function() {};

/**
 * @see _.sample
 * @template T
 * @return {T}
 */
_.LoDashImplicitObjectWrapperBase.prototype.sample = function() {};

/**
 * @see _.sample
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.sample = function() {};

/**
 * @see _.sample
 * @template TWrapper
 * @return {TWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.sample = function() {};

/**
 * @see _.sample
 * @template TWrapper
 * @return {TWrapper}
 */
_.LoDashExplicitObjectWrapperBase.prototype.sample = function() {};

/**
 * Gets n random elements at unique keys from collection up to the size of collection.
 * 
 * @see _.sampleSize
 * @see _.sampleSize
 * @template T, O
 * @param {(!ArrayLike<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)|O|!Object} collection The collection to sample.
 * @param {number=} n The number of elements to sample.
 * @return {!Array<T>} Returns the random elements.
 */
_.LoDashStatic.prototype.sampleSize = function(collection, n) {};

/**
 * @see _.sampleSize
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.sampleSize = function(n) {};

/**
 * @see _.sampleSize
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.sampleSize = function(n) {};

/**
 * @see _.sampleSize
 * @template T
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.sampleSize = function(n) {};

/**
 * @see _.sampleSize
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.sampleSize = function(n) {};

/**
 * @see _.sampleSize
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.sampleSize = function(n) {};

/**
 * @see _.sampleSize
 * @template T
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.sampleSize = function(n) {};

/**
 * Creates an array of shuffled values, using a version of the Fisher-Yates shuffle.
 * 
 * @see _.shuffle
 * @template T
 * @param {(!ArrayLike<T>|!_.Dictionary<T>)|string} collection The collection to shuffle.
 * @return {!Array<T>|!Array<string>} Returns the new shuffled array.
 */
_.LoDashStatic.prototype.shuffle = function(collection) {};

/**
 * @see _.shuffle
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.shuffle = function() {};

/**
 * Gets the size of collection by returning its length for array-like values or the number of own enumerable
 * properties for objects.
 * 
 * @see _.size
 * @template T
 * @param {(!ArrayLike<T>|!_.Dictionary<T>)|string} collection The collection to inspect.
 * @return {number} Returns the size of collection.
 */
_.LoDashStatic.prototype.size = function(collection) {};

/**
 * @see _.size
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.size = function() {};

/**
 * @see _.size
 * @return {number}
 */
_.LoDashImplicitArrayWrapperBase.prototype.size = function() {};

/**
 * @see _.size
 * @return {number}
 */
_.LoDashImplicitObjectWrapperBase.prototype.size = function() {};

/**
 * @see _.size
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.size = function() {};

/**
 * @see _.size
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.size = function() {};

/**
 * @see _.size
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.size = function() {};

/**
 * Checks if predicate returns truthy for any element of collection. Iteration is stopped once predicate
 * returns truthy. The predicate is invoked with three arguments: (value, index|key, collection).
 * 
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @template T
 * @param {!ArrayLike<T>|!_.Dictionary<T>|!_.NumericDictionary<T>|!Object|(!ArrayLike<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)} collection The collection to iterate over.
 * @param {function(T, number, !ArrayLike<T>): boolean|function(T, string, !_.Dictionary<T>): boolean|function(T, number, !_.Dictionary<T>): boolean|function(?, string, ?): boolean|(string|!Array<?>)|?=} predicate The function invoked per iteration.
 * @return {boolean} Returns true if any element passes the predicate check, else false.
 */
_.LoDashStatic.prototype.some = function(collection, predicate) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @param {(function(T, number, !ArrayLike<T>): boolean|function(T, number, !_.Dictionary<T>): boolean)|(string|!Array<?>)|?=} predicate
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapperBase.prototype.some = function(predicate) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TResult
 * @param {(function(T, number, !_.Dictionary<T>): boolean|function(?, string, ?): boolean|function(TResult, number, !ArrayLike<TResult>): boolean|function(TResult, string, !_.Dictionary<TResult>): boolean)|(string|!Array<?>)|?=} predicate
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapperBase.prototype.some = function(predicate) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @param {(function(T, number, !ArrayLike<T>): boolean|function(T, number, !_.Dictionary<T>): boolean)|(string|!Array<?>)|?=} predicate
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.some = function(predicate) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TResult
 * @param {(function(T, number, !_.Dictionary<T>): boolean|function(?, string, ?): boolean|function(TResult, number, !ArrayLike<TResult>): boolean|function(TResult, string, !_.Dictionary<TResult>): boolean)|(string|!Array<?>)|?=} predicate
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.some = function(predicate) {};

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection through each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 * 
 * \@memberOf _
 * \@category Collection
 *  The iteratees to sort by, specified individually or in arrays.
 * \@example 
 * 
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 42 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 * 
 * _.sortBy(users, function(o) { return o.user; });
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
 * 
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
 * 
 * _.sortBy(users, 'user', function(o) {
 *   return Math.floor(o.age / 10);
 * });
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @template T, TSort, W
 * @param {!ArrayLike<T>|!_.Dictionary<T>|(!ArrayLike<T>|!_.Dictionary<T>)} collection
 * @param {...function(T, number, !ArrayLike<T>): TSort|function(T, string, !_.Dictionary<T>): TSort|string|W|!Array<(string|!Object|function(T, number, !ArrayLike<T>): ?)>|(string|!Object|function(T, number, !ArrayLike<T>): boolean)=} iteratee_or_whereValue_or_iteratees
 * @return {!Array<T>}
 */
_.LoDashStatic.prototype.sortBy = function(collection, iteratee_or_whereValue_or_iteratees) {};

/**
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * 
 * @template TSort, W
 * @param {...function(T, number, !ArrayLike<T>): TSort|string|W|(string|!Object|function(T, number, !ArrayLike<T>): boolean)|!Array<(string|!Object|function(T, number, !ArrayLike<T>): ?)>=} iteratee_or_whereValue_or_iteratees
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.sortBy = function(iteratee_or_whereValue_or_iteratees) {};

/**
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @template T, TSort, W
 * @param {(function(T, number, !ArrayLike<T>): TSort|function(T, string, !_.Dictionary<T>): TSort)|string|W=} iteratee_or_whereValue
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.sortBy = function(iteratee_or_whereValue) {};

/**
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @template TSort, W
 * @param {function(T, number, !ArrayLike<T>): TSort|string|W=} iteratee_or_whereValue
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.sortBy = function(iteratee_or_whereValue) {};

/**
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @template T, TSort, W
 * @param {(function(T, number, !ArrayLike<T>): TSort|function(T, string, !_.Dictionary<T>): TSort)|string|W=} iteratee_or_whereValue
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.sortBy = function(iteratee_or_whereValue) {};

/**
 * This method is like `_.sortBy` except that it allows specifying the sort
 * orders of the iteratees to sort by. If `orders` is unspecified, all values
 * are sorted in ascending order. Otherwise, specify an order of "desc" for
 * descending or "asc" for ascending sort order of corresponding values.
 * 
 * \@memberOf _
 * \@category Collection
 * \@param- {Object} [guard] Enables use as an iteratee for functions like `_.reduce`.
 * \@example 
 * 
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 34 },
 *   { 'user': 'fred',   'age': 42 },
 *   { 'user': 'barney', 'age': 36 }
 * ];
 * 
 * // sort by `user` in ascending order and by `age` in descending order
 * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
 * @see _.orderBy
 * @see _.orderBy
 * @see _.orderBy
 * @see _.orderBy
 * @see _.orderBy
 * @template W, T
 * @param {!ArrayLike<T>|!_.NumericDictionary<T>|!_.Dictionary<T>} collection
 * @param {(string|W|function(T, number, !ArrayLike<T>): ?|!Array<(string|W|?)>)|(string|!Object|function(T, number, !ArrayLike<T>): ?|!Array<(string|!Object|?)>)|(string|W|function(T, number, !_.Dictionary<T>): ?|!Array<(string|W|?)>)|(string|!Object|function(T, number, !_.Dictionary<T>): ?|!Array<(string|!Object|?)>)|(string|W|function(T, string, !_.Dictionary<T>): ?|!Array<(string|W|?)>)|(string|!Object|function(T, string, !_.Dictionary<T>): ?|!Array<(string|!Object|?)>)=} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!Array<T>}
 */
_.LoDashStatic.prototype.orderBy = function(collection, iteratees, orders) {};

/**
 * @see _.orderBy
 * @param {(string|function(T, number, !ArrayLike<T>): ?|!Array<(string|?)>)=} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.orderBy = function(iteratees, orders) {};

/**
 * @see _.orderBy
 * @template W
 * @param {(string|function(T, number, !ArrayLike<T>): ?|W|!Array<(string|?|W)>)=} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.orderBy = function(iteratees, orders) {};

/**
 * @see _.orderBy
 * @see _.orderBy
 * @see _.orderBy
 * @see _.orderBy
 * @see _.orderBy
 * @see _.orderBy
 * @template W, T
 * @param {(string|W|function(T, number, !ArrayLike<T>): ?|!Array<(string|W|?)>)|(string|!Object|function(T, number, !ArrayLike<T>): ?|!Array<(string|!Object|?)>)|(string|W|function(T, number, !_.Dictionary<T>): ?|!Array<(string|W|?)>)|(string|!Object|function(T, number, !_.Dictionary<T>): ?|!Array<(string|!Object|?)>)|(string|W|function(T, string, !_.Dictionary<T>): ?|!Array<(string|W|?)>)|(string|!Object|function(T, string, !_.Dictionary<T>): ?|!Array<(string|!Object|?)>)=} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.orderBy = function(iteratees, orders) {};

/**
 * @see _.orderBy
 * @param {(string|function(T, number, !ArrayLike<T>): ?|!Array<(string|?)>)=} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapper.prototype.orderBy = function(iteratees, orders) {};

/**
 * @see _.orderBy
 * @template W
 * @param {(string|function(T, number, !ArrayLike<T>): ?|W|!Array<(string|?|W)>)=} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.orderBy = function(iteratees, orders) {};

/**
 * @see _.orderBy
 * @see _.orderBy
 * @see _.orderBy
 * @see _.orderBy
 * @see _.orderBy
 * @see _.orderBy
 * @template W, T
 * @param {(string|W|function(T, number, !ArrayLike<T>): ?|!Array<(string|W|?)>)|(string|!Object|function(T, number, !ArrayLike<T>): ?|!Array<(string|!Object|?)>)|(string|W|function(T, number, !_.Dictionary<T>): ?|!Array<(string|W|?)>)|(string|!Object|function(T, number, !_.Dictionary<T>): ?|!Array<(string|!Object|?)>)|(string|W|function(T, string, !_.Dictionary<T>): ?|!Array<(string|W|?)>)|(string|!Object|function(T, string, !_.Dictionary<T>): ?|!Array<(string|!Object|?)>)=} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.orderBy = function(iteratees, orders) {};

/**
 * Gets the number of milliseconds that have elapsed since the Unix epoch (1 January 1970 00:00:00 UTC).
 * 
 * @return {number} The number of milliseconds.
 */
_.LoDashStatic.prototype.now = function() {};

/**
 * @see _.now
 * @return {number}
 */
_.LoDashImplicitWrapperBase.prototype.now = function() {};

/**
 * @see _.now
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapperBase.prototype.now = function() {};

/**
 * The opposite of _.before; this method creates a function that invokes func once it’s called n or more times.
 * 
 * @template TFunc
 * @param {number} n The number of calls before func is invoked.
 * @param {TFunc} func The function to restrict.
 * @return {TFunc} Returns the new restricted function.
 */
_.LoDashStatic.prototype.after = function(n, func) {};

/**
 * @see _.after
 * 
 * @template TFunc
 * @param {TFunc} func
 * @return {!_.LoDashImplicitObjectWrapper<TFunc>}
 */
_.LoDashImplicitWrapper.prototype.after = function(func) {};

/**
 * @see _.after
 * 
 * @template TFunc
 * @param {TFunc} func
 * @return {!_.LoDashExplicitObjectWrapper<TFunc>}
 */
_.LoDashExplicitWrapper.prototype.after = function(func) {};

/**
 * Creates a function that accepts up to n arguments ignoring any additional arguments.
 * 
 * @template TResult, T
 * @param {!Function|T} func The function to cap arguments for.
 * @param {number=} n The arity cap.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.ary = function(func, n) {};

/**
 * @see _.ary
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.ary = function(n) {};

/**
 * @see _.ary
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.ary = function(n) {};

/**
 * Creates a function that invokes func, with the this binding and arguments of the created function, while
 * it’s called less than n times. Subsequent calls to the created function return the result of the last func
 * invocation.
 * 
 * @template TFunc
 * @param {number} n The number of calls at which func is no longer invoked.
 * @param {TFunc} func The function to restrict.
 * @return {TFunc} Returns the new restricted function.
 */
_.LoDashStatic.prototype.before = function(n, func) {};

/**
 * @see _.before
 * 
 * @template TFunc
 * @param {TFunc} func
 * @return {!_.LoDashImplicitObjectWrapper<TFunc>}
 */
_.LoDashImplicitWrapper.prototype.before = function(func) {};

/**
 * @see _.before
 * 
 * @template TFunc
 * @param {TFunc} func
 * @return {!_.LoDashExplicitObjectWrapper<TFunc>}
 */
_.LoDashExplicitWrapper.prototype.before = function(func) {};
/**
 * @record
 * @struct
 */
_.FunctionBind = function() {};
 /** @type {?} */
_.FunctionBind.prototype.placeholder;

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
 /** @type {!_.FunctionBind} */
_.LoDashStatic.prototype.bind;

/**
 * @see _.bind
 * @template TResult
 * @param {?} thisArg
 * @param {...?} partials
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.bind = function(thisArg, partials) {};

/**
 * @see _.bind
 * @template TResult
 * @param {?} thisArg
 * @param {...?} partials
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.bind = function(thisArg, partials) {};

/**
 * Binds methods of an object to the object itself, overwriting the existing method. Method names may be
 * specified as individual arguments or as arrays of method names. If no method names are provided all
 * enumerable function properties, own and inherited, of object are bound.
 * 
 * Note: This method does not set the "length" property of bound functions.
 * 
 * @template T
 * @param {T} object The object to bind and assign the bound methods to.
 * @param {...(string|!Array<string>)} methodNames The object method names to bind, specified as individual method names or arrays of
 * method names.
 * @return {T} Returns object.
 */
_.LoDashStatic.prototype.bindAll = function(object, methodNames) {};

/**
 * @see _.bindAll
 * @param {...(string|!Array<string>)} methodNames
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.bindAll = function(methodNames) {};

/**
 * @see _.bindAll
 * @param {...(string|!Array<string>)} methodNames
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.bindAll = function(methodNames) {};
/**
 * @record
 * @struct
 */
_.FunctionBindKey = function() {};
 /** @type {?} */
_.FunctionBindKey.prototype.placeholder;

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
 /** @type {!_.FunctionBindKey} */
_.LoDashStatic.prototype.bindKey;

/**
 * @see _.bindKey
 * @template TResult
 * @param {?} key
 * @param {...?} partials
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.bindKey = function(key, partials) {};

/**
 * @see _.bindKey
 * @template TResult
 * @param {?} key
 * @param {...?} partials
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.bindKey = function(key, partials) {};

/**
 * Produces a callback bound to an optional thisArg. If func is a property name the created
 * callback will return the property value for a given element. If func is an object the created
 * callback will return true for elements that contain the equivalent object properties,
 * otherwise it will return false.
 * @see _.createCallback
 * 
 * @param {string|!_.Dictionary<?>} func The value to convert to a callback.
 * @param {number=} argCount The number of arguments the callback accepts.
 * @return {function(): ?|function(): boolean} A callback function.
 * 
 */
_.LoDashStatic.prototype.createCallback = function(func, argCount) {};

/**
 * @see _.createCallback
 * 
 * @param {number=} argCount
 * @return {!_.LoDashImplicitObjectWrapper<function(): ?>}
 */
_.LoDashImplicitWrapper.prototype.createCallback = function(argCount) {};

/**
 * @see _.createCallback
 * 
 * @param {number=} argCount
 * @return {!_.LoDashImplicitObjectWrapper<function(): ?>}
 */
_.LoDashImplicitObjectWrapper.prototype.createCallback = function(argCount) {};

/**
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * @template T1, R, T2, T3, T4, T5, TResult
 * @param {function(T1): R|function(T1, T2): R|function(T1, T2, T3): R|function(T1, T2, T3, T4): R|function(T1, T2, T3, T4, T5): R|!Function} func The function to curry.
 * @param {number=} arity The arity of func.
 * @return {!_.CurriedFunction1<T1, R>|!_.CurriedFunction2<T1, T2, R>|!_.CurriedFunction3<T1, T2, T3, R>|!_.CurriedFunction4<T1, T2, T3, T4, R>|!_.CurriedFunction5<T1, T2, T3, T4, T5, R>|TResult} Returns the new curried function.
 */
_.LoDashStatic.prototype.curry = function(func, arity) {};
/**
 * @record
 * @struct
 */
_.CurriedFunction1 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.CurriedFunction2 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.CurriedFunction3 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.CurriedFunction4 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.CurriedFunction5 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.RightCurriedFunction1 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.RightCurriedFunction2 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.RightCurriedFunction3 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.RightCurriedFunction4 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.RightCurriedFunction5 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/**
 * @see _.curry
 * 
 * @template TResult
 * @param {number=} arity
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.curry = function(arity) {};

/**
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * @template T1, R, T2, T3, T4, T5, TResult
 * @param {function(T1): R|function(T1, T2): R|function(T1, T2, T3): R|function(T1, T2, T3, T4): R|function(T1, T2, T3, T4, T5): R|!Function} func The function to curry.
 * @param {number=} arity The arity of func.
 * @return {!_.RightCurriedFunction1<T1, R>|!_.RightCurriedFunction2<T1, T2, R>|!_.RightCurriedFunction3<T1, T2, T3, R>|!_.RightCurriedFunction4<T1, T2, T3, T4, R>|!_.RightCurriedFunction5<T1, T2, T3, T4, T5, R>|TResult} Returns the new curried function.
 */
_.LoDashStatic.prototype.curryRight = function(func, arity) {};

/**
 * @see _.curryRight
 * 
 * @template TResult
 * @param {number=} arity
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.curryRight = function(arity) {};
/**
 * @record
 * @struct
 */
_.DebounceSettings = function() {};
 /** @type {boolean} */
_.DebounceSettings.prototype.leading;
 /** @type {number} */
_.DebounceSettings.prototype.maxWait;
 /** @type {boolean} */
_.DebounceSettings.prototype.trailing;

/**
 * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since
 * the last time the debounced function was invoked. The debounced function comes with a cancel method to
 * cancel delayed invocations and a flush method to immediately invoke them. Provide an options object to
 * indicate that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent
 * calls to the debounced function return the result of the last func invocation.
 * 
 * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only
 * if the the debounced function is invoked more than once during the wait timeout.
 * 
 * See David Corbacho’s article for details over the differences between _.debounce and _.throttle.
 * 
 * @template T
 * @param {T} func The function to debounce.
 * @param {number=} wait The number of milliseconds to delay.
 * @param {!_.DebounceSettings=} options The options object.
 * @return {?} Returns the new debounced function.
 */
_.LoDashStatic.prototype.debounce = function(func, wait, options) {};

/**
 * @see _.debounce
 * @param {number=} wait
 * @param {!_.DebounceSettings=} options
 * @return {!_.LoDashImplicitObjectWrapper<?>}
 */
_.LoDashImplicitObjectWrapper.prototype.debounce = function(wait, options) {};

/**
 * @see _.debounce
 * @param {number=} wait
 * @param {!_.DebounceSettings=} options
 * @return {!_.LoDashExplicitObjectWrapper<?>}
 */
_.LoDashExplicitObjectWrapper.prototype.debounce = function(wait, options) {};

/**
 * Defers invoking the func until the current call stack has cleared. Any additional arguments are provided to
 * func when it’s invoked.
 * 
 * @template T
 * @param {T} func The function to defer.
 * @param {...?} args The arguments to invoke the function with.
 * @return {number} Returns the timer id.
 */
_.LoDashStatic.prototype.defer = function(func, args) {};

/**
 * @see _.defer
 * @param {...?} args
 * @return {!_.LoDashImplicitWrapper<number>}
 */
_.LoDashImplicitObjectWrapper.prototype.defer = function(args) {};

/**
 * @see _.defer
 * @param {...?} args
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.defer = function(args) {};

/**
 * Invokes func after wait milliseconds. Any additional arguments are provided to func when it’s invoked.
 * 
 * @template T
 * @param {T} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {...?} args The arguments to invoke the function with.
 * @return {number} Returns the timer id.
 */
_.LoDashStatic.prototype.delay = function(func, wait, args) {};

/**
 * @see _.delay
 * @param {number} wait
 * @param {...?} args
 * @return {!_.LoDashImplicitWrapper<number>}
 */
_.LoDashImplicitObjectWrapper.prototype.delay = function(wait, args) {};

/**
 * @see _.delay
 * @param {number} wait
 * @param {...?} args
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.delay = function(wait, args) {};

/**
 * Creates a function that invokes `func` with arguments reversed.
 * 
 * \@memberOf _
 * \@category Function
 * \@example 
 * 
 * var flipped = _.flip(function() {
 *   return _.toArray(arguments);
 * });
 * 
 * flipped('a', 'b', 'c', 'd');
 * // => ['d', 'c', 'b', 'a']
 * @template T
 * @param {T} func
 * @return {T}
 */
_.LoDashStatic.prototype.flip = function(func) {};

/**
 * @see _.flip
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.flip = function() {};

/**
 * @see _.flip
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.flip = function() {};

/**
 * @template R1, R2, R3, R4, R5, R6, R7, A1, A2, A3, A4, TResult
 * @param {...function(): R1|function(A1): R1|function(A1, A2): R1|function(A1, A2, A3): R1|function(A1, A2, A3, A4): R1|!Function|!Array<!Function>} f1_or_funcs
 * @return {function(): R2|function(): R3|function(): R4|function(): R5|function(): R6|function(): R7|function(A1): R2|function(A1): R3|function(A1): R4|function(A1): R5|function(A1): R6|function(A1): R7|function(A1, A2): R2|function(A1, A2): R3|function(A1, A2): R4|function(A1, A2): R5|function(A1, A2): R6|function(A1, A2): R7|function(A1, A2, A3): R2|function(A1, A2, A3): R3|function(A1, A2, A3): R4|function(A1, A2, A3): R5|function(A1, A2, A3): R6|function(A1, A2, A3): R7|function(A1, A2, A3, A4): R2|function(A1, A2, A3, A4): R3|function(A1, A2, A3, A4): R4|function(A1, A2, A3, A4): R5|function(A1, A2, A3, A4): R6|function(A1, A2, A3, A4): R7|TResult}
 */
_.LoDashStatic.prototype.flow = function(f1_or_funcs) {};

/**
 * @see _.flow
 * @see _.flow
 * @template TResult
 * @param {...!Function|!Array<!Function>} funcs
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.flow = function(funcs) {};

/**
 * @see _.flow
 * @see _.flow
 * @template TResult
 * @param {...!Function|!Array<!Function>} funcs
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.flow = function(funcs) {};

/**
 * This method is like _.flow except that it creates a function that invokes the provided functions from right
 * to left.
 * 
 * @see _.flowRight
 * @template TResult
 * @param {...!Function|!Array<!Function>} funcs Functions to invoke.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.flowRight = function(funcs) {};

/**
 * @see _.flowRight
 * @see _.flowRight
 * @template TResult
 * @param {...!Function|!Array<!Function>} funcs
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.flowRight = function(funcs) {};

/**
 * @see _.flowRight
 * @see _.flowRight
 * @template TResult
 * @param {...!Function|!Array<!Function>} funcs
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.flowRight = function(funcs) {};
/**
 * @record
 * @struct
 */
_.MemoizedFunction = function() {};
 /** @type {!_.MapCache} */
_.MemoizedFunction.prototype.cache;
 /** @type {?} */
_.LoDashStatic.prototype.memoize;

/**
 * @see _.memoize
 * @param {!Function=} resolver
 * @return {!_.LoDashImplicitObjectWrapper<?>}
 */
_.LoDashImplicitObjectWrapper.prototype.memoize = function(resolver) {};

/**
 * @see _.memoize
 * @param {!Function=} resolver
 * @return {!_.LoDashExplicitObjectWrapper<?>}
 */
_.LoDashExplicitObjectWrapper.prototype.memoize = function(resolver) {};

/**
 * Creates a function that runs each argument through a corresponding transform function.
 * 
 * @see _.overArgs
 * @template T, TResult
 * @param {T} func The function to wrap.
 * @param {...!Function|!Array<!Function>} transforms The functions to transform arguments, specified as individual functions or arrays
 * of functions.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.overArgs = function(func, transforms) {};

/**
 * @see _.overArgs
 * @see _.overArgs
 * @template TResult
 * @param {...!Function|!Array<!Function>} transforms
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.overArgs = function(transforms) {};

/**
 * @see _.overArgs
 * @see _.overArgs
 * @template TResult
 * @param {...!Function|!Array<!Function>} transforms
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.overArgs = function(transforms) {};

/**
 * Creates a function that negates the result of the predicate func. The func predicate is invoked with
 * the this binding and arguments of the created function.
 * 
 * @see _.negate
 * @template T, TResult
 * @param {T} predicate The predicate to negate.
 * @return {function(!Array<?>): boolean|TResult} Returns the new function.
 */
_.LoDashStatic.prototype.negate = function(predicate) {};

/**
 * @see _.negate
 * @see _.negate
 * @template TResult
 * @return {!_.LoDashImplicitObjectWrapper<function(!Array<?>): boolean>|!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.negate = function() {};

/**
 * @see _.negate
 * @see _.negate
 * @template TResult
 * @return {!_.LoDashExplicitObjectWrapper<function(!Array<?>): boolean>|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.negate = function() {};

/**
 * Creates a function that is restricted to invoking func once. Repeat calls to the function return the value
 * of the first call. The func is invoked with the this binding and arguments of the created function.
 * 
 * @template T
 * @param {T} func The function to restrict.
 * @return {T} Returns the new restricted function.
 */
_.LoDashStatic.prototype.once = function(func) {};

/**
 * @see _.once
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.once = function() {};

/**
 * @see _.once
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.once = function() {};
 /** @type {!_.Partial} */
_.LoDashStatic.prototype.partial;

/** @typedef {!_.LoDashStatic} */
_.PH;

/** @typedef {function(): R} */
_.Function0;

/** @typedef {function(T1): R} */
_.Function1;

/** @typedef {function(T1, T2): R} */
_.Function2;

/** @typedef {function(T1, T2, T3): R} */
_.Function3;

/** @typedef {function(T1, T2, T3, T4): R} */
_.Function4;
/**
 * @record
 * @struct
 */
_.Partial = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
 /** @type {!_.PartialRight} */
_.LoDashStatic.prototype.partialRight;
/**
 * @record
 * @struct
 */
_.PartialRight = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/**
 * Creates a function that invokes func with arguments arranged according to the specified indexes where the
 * argument value at the first index is provided as the first argument, the argument value at the second index
 * is provided as the second argument, and so on.
 * @see _.rearg
 * @template TResult
 * @param {!Function} func The function to rearrange arguments for.
 * @param {...!Array<number>|number} indexes The arranged argument indexes, specified as individual indexes or arrays of indexes.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.rearg = function(func, indexes) {};

/**
 * @see _.rearg
 * @see _.rearg
 * @template TResult
 * @param {...!Array<number>|number} indexes
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.rearg = function(indexes) {};

/**
 * Creates a function that invokes func with the this binding of the created function and arguments from start
 * and beyond provided as an array.
 * 
 * Note: This method is based on the rest parameter.
 * 
 * @see _.rest
 * @template TResult, TFunc
 * @param {!Function|TFunc} func The function to apply a rest parameter to.
 * @param {number=} start The start position of the rest parameter.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.rest = function(func, start) {};

/**
 * @see _.rest
 * @template TResult
 * @param {number=} start
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.rest = function(start) {};

/**
 * @see _.rest
 * @template TResult
 * @param {number=} start
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.rest = function(start) {};

/**
 * Creates a function that invokes func with the this binding of the created function and an array of arguments
 * much like Function#apply.
 * 
 * Note: This method is based on the spread operator.
 * 
 * @see _.spread
 * @template F, T
 * @param {F|!Function} func The function to spread arguments over.
 * @return {T} Returns the new function.
 */
_.LoDashStatic.prototype.spread = function(func) {};

/**
 * @see _.spread
 * @template T
 * @return {!_.LoDashImplicitObjectWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.spread = function() {};

/**
 * @see _.spread
 * @template T
 * @return {!_.LoDashExplicitObjectWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.spread = function() {};
/**
 * @record
 * @struct
 */
_.ThrottleSettings = function() {};
 /** @type {boolean} */
_.ThrottleSettings.prototype.leading;
 /** @type {boolean} */
_.ThrottleSettings.prototype.trailing;

/**
 * Creates a throttled function that only invokes func at most once per every wait milliseconds. The throttled
 * function comes with a cancel method to cancel delayed invocations and a flush method to immediately invoke
 * them. Provide an options object to indicate that func should be invoked on the leading and/or trailing edge
 * of the wait timeout. Subsequent calls to the throttled function return the result of the last func call.
 * 
 * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only if
 * the the throttled function is invoked more than once during the wait timeout.
 * 
 * @template T
 * @param {T} func The function to throttle.
 * @param {number=} wait The number of milliseconds to throttle invocations to.
 * @param {!_.ThrottleSettings=} options The options object.
 * @return {?} Returns the new throttled function.
 */
_.LoDashStatic.prototype.throttle = function(func, wait, options) {};

/**
 * @see _.throttle
 * @param {number=} wait
 * @param {!_.ThrottleSettings=} options
 * @return {!_.LoDashImplicitObjectWrapper<?>}
 */
_.LoDashImplicitObjectWrapper.prototype.throttle = function(wait, options) {};

/**
 * @see _.throttle
 * @param {number=} wait
 * @param {!_.ThrottleSettings=} options
 * @return {!_.LoDashExplicitObjectWrapper<?>}
 */
_.LoDashExplicitObjectWrapper.prototype.throttle = function(wait, options) {};

/**
 * Creates a function that accepts up to one argument, ignoring any
 * additional arguments.
 * 
 * \@memberOf _
 * \@category Function
 * \@example 
 * 
 * _.map(['6', '8', '10'], _.unary(parseInt));
 * // => [6, 8, 10]
 * @template T
 * @param {T} func
 * @return {T}
 */
_.LoDashStatic.prototype.unary = function(func) {};

/**
 * @see _.unary
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.unary = function() {};

/**
 * @see _.unary
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.unary = function() {};

/**
 * Creates a function that provides value to the wrapper function as its first argument. Any additional
 * arguments provided to the function are appended to those provided to the wrapper function. The wrapper is
 * invoked with the this binding of the created function.
 * 
 * @see _.wrap
 * @see _.wrap
 * @template V, W, R
 * @param {V|?} value The value to wrap.
 * @param {W|!Function} wrapper The wrapper function.
 * @return {R} Returns the new function.
 */
_.LoDashStatic.prototype.wrap = function(value, wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashImplicitObjectWrapper<R>}
 */
_.LoDashImplicitWrapper.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashImplicitObjectWrapper<R>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashImplicitObjectWrapper<R>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashExplicitObjectWrapper<R>}
 */
_.LoDashExplicitWrapper.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashExplicitObjectWrapper<R>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashExplicitObjectWrapper<R>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.wrap = function(wrapper) {};

/**
 * Casts value as an array if it’s not one.
 * 
 * @template T
 * @param {(T|!Array<T>)=} value The value to inspect.
 * @return {!Array<T>} Returns the cast array.
 */
_.LoDashStatic.prototype.castArray = function(value) {};

/**
 * @see _.castArray
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.castArray = function() {};

/**
 * @see _.castArray
 * @return {TWrapper}
 */
_.LoDashImplicitArrayWrapperBase.prototype.castArray = function() {};

/**
 * @see _.castArray
 * @return {!_.LoDashImplicitArrayWrapper<TObject>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.castArray = function() {};

/**
 * @see _.castArray
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapper.prototype.castArray = function() {};

/**
 * @see _.castArray
 * @return {TWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.castArray = function() {};

/**
 * @see _.castArray
 * @return {!_.LoDashExplicitArrayWrapper<TObject>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.castArray = function() {};

/**
 * Creates a shallow clone of value.
 * 
 * Note: This method is loosely based on the structured clone algorithm and supports cloning arrays,
 * array buffers, booleans, date objects, maps, numbers, Object objects, regexes, sets, strings, symbols,
 * and typed arrays. The own enumerable properties of arguments objects are cloned as plain objects. An empty
 * object is returned for uncloneable values such as error objects, functions, DOM nodes, and WeakMaps.
 * 
 * @template T
 * @param {T} value The value to clone.
 * @return {T} Returns the cloned value.
 */
_.LoDashStatic.prototype.clone = function(value) {};

/**
 * @see _.clone
 * @return {T}
 */
_.LoDashImplicitWrapper.prototype.clone = function() {};

/**
 * @see _.clone
 * @return {TArray}
 */
_.LoDashImplicitArrayWrapperBase.prototype.clone = function() {};

/**
 * @see _.clone
 * @return {TObject}
 */
_.LoDashImplicitObjectWrapperBase.prototype.clone = function() {};

/**
 * @see _.clone
 * @return {!_.LoDashExplicitWrapper}
 */
_.LoDashExplicitWrapper.prototype.clone = function() {};

/**
 * @see _.clone
 * @return {TWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.clone = function() {};

/**
 * @see _.clone
 * @return {TWrapper}
 */
_.LoDashExplicitObjectWrapperBase.prototype.clone = function() {};

/**
 * This method is like _.clone except that it recursively clones value.
 * 
 * @template T
 * @param {T} value The value to recursively clone.
 * @return {T} Returns the deep cloned value.
 */
_.LoDashStatic.prototype.cloneDeep = function(value) {};

/**
 * @see _.cloneDeep
 * @return {T}
 */
_.LoDashImplicitWrapper.prototype.cloneDeep = function() {};

/**
 * @see _.cloneDeep
 * @return {TArray}
 */
_.LoDashImplicitArrayWrapperBase.prototype.cloneDeep = function() {};

/**
 * @see _.cloneDeep
 * @return {TObject}
 */
_.LoDashImplicitObjectWrapperBase.prototype.cloneDeep = function() {};

/**
 * @see _.cloneDeep
 * @return {!_.LoDashExplicitWrapper}
 */
_.LoDashExplicitWrapper.prototype.cloneDeep = function() {};

/**
 * @see _.cloneDeep
 * @return {TWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.cloneDeep = function() {};

/**
 * @see _.cloneDeep
 * @return {TWrapper}
 */
_.LoDashExplicitObjectWrapperBase.prototype.cloneDeep = function() {};

/** @typedef {function(TValue, (string|number), ?, ?): TResult} */
_.CloneDeepWithCustomizer;

/**
 * This method is like _.cloneWith except that it recursively clones value.
 * 
 * @see _.clonDeepeWith
 * @template TResult, T
 * @param {?|T} value The value to recursively clone.
 * @param {function(?, (string|number), ?, ?): TResult|function(T, (string|number), ?, ?): TResult=} customizer The function to customize cloning.
 * @return {TResult} Returns the deep cloned value.
 */
_.LoDashStatic.prototype.cloneDeepWith = function(value, customizer) {};

/**
 * @see _.cloneDeepWith
 * @template TResult
 * @param {function(T, (string|number), ?, ?): TResult=} customizer
 * @return {TResult}
 */
_.LoDashImplicitWrapper.prototype.cloneDeepWith = function(customizer) {};

/**
 * @see _.cloneDeepWith
 * @template TResult
 * @param {function(TArray, (string|number), ?, ?): TResult=} customizer
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapperBase.prototype.cloneDeepWith = function(customizer) {};

/**
 * @see _.cloneDeepWith
 * @template TResult
 * @param {function(TObject, (string|number), ?, ?): TResult=} customizer
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapperBase.prototype.cloneDeepWith = function(customizer) {};

/**
 * @see _.cloneDeepWith
 * @see _.cloneDeepWith
 * @see _.cloneDeepWith
 * @template TResult
 * @param {function(T, (string|number), ?, ?): TResult|function(T, (string|number), ?, ?): !Array<TResult>=} customizer
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitWrapper.prototype.cloneDeepWith = function(customizer) {};

/**
 * @see _.cloneDeepWith
 * @see _.cloneDeepWith
 * @see _.cloneDeepWith
 * @template TResult
 * @param {function(TArray, (string|number), ?, ?): TResult|function(!Array<T>, (string|number), ?, ?): !Array<TResult>|function(!Array<T>, (string|number), ?, ?): TResult=} customizer
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.cloneDeepWith = function(customizer) {};

/**
 * @see _.cloneDeepWith
 * @see _.cloneDeepWith
 * @see _.cloneDeepWith
 * @template TResult
 * @param {function(T, (string|number), ?, ?): TResult|function(T, (string|number), ?, ?): !Array<TResult>=} customizer
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.cloneDeepWith = function(customizer) {};

/** @typedef {function(TValue, (string|number), ?, ?): TResult} */
_.CloneWithCustomizer;

/**
 * This method is like _.clone except that it accepts customizer which is invoked to produce the cloned value.
 * If customizer returns undefined cloning is handled by the method instead.
 * 
 * @see _.cloneWith
 * @template TResult, T
 * @param {?|T} value The value to clone.
 * @param {function(?, (string|number), ?, ?): TResult|function(T, (string|number), ?, ?): TResult=} customizer The function to customize cloning.
 * @return {TResult} Returns the cloned value.
 */
_.LoDashStatic.prototype.cloneWith = function(value, customizer) {};

/**
 * @see _.cloneWith
 * @template TResult
 * @param {function(T, (string|number), ?, ?): TResult=} customizer
 * @return {TResult}
 */
_.LoDashImplicitWrapper.prototype.cloneWith = function(customizer) {};

/**
 * @see _.cloneWith
 * @template TResult
 * @param {function(TArray, (string|number), ?, ?): TResult=} customizer
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapperBase.prototype.cloneWith = function(customizer) {};

/**
 * @see _.cloneWith
 * @template TResult
 * @param {function(TObject, (string|number), ?, ?): TResult=} customizer
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapperBase.prototype.cloneWith = function(customizer) {};

/**
 * @see _.cloneWith
 * @see _.cloneWith
 * @see _.cloneWith
 * @template TResult
 * @param {function(T, (string|number), ?, ?): TResult|function(T, (string|number), ?, ?): !Array<TResult>=} customizer
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitWrapper.prototype.cloneWith = function(customizer) {};

/**
 * @see _.cloneWith
 * @see _.cloneWith
 * @see _.cloneWith
 * @template TResult
 * @param {function(TArray, (string|number), ?, ?): TResult|function(!Array<T>, (string|number), ?, ?): !Array<TResult>|function(!Array<T>, (string|number), ?, ?): TResult=} customizer
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.cloneWith = function(customizer) {};

/**
 * @see _.cloneWith
 * @see _.cloneWith
 * @see _.cloneWith
 * @template TResult
 * @param {function(T, (string|number), ?, ?): TResult|function(T, (string|number), ?, ?): !Array<TResult>=} customizer
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.cloneWith = function(customizer) {};

/** @typedef {?} */
_.ConformsPredicateObject;

/**
 * Creates a function that invokes the predicate properties of `source` with the corresponding
 * property values of a given object, returning true if all predicates return truthy, else false.
 * @template T
 * @param {?} source
 * @return {function(T): boolean}
 */
_.LoDashStatic.prototype.conforms = function(source) {};

/**
 * Checks if object conforms to source by invoking the predicate properties of source with the
 * corresponding property values of object.
 * 
 * Note: This method is equivalent to _.conforms when source is partially applied.
 * @template T
 * @param {T} object
 * @param {?} source
 * @return {boolean}
 */
_.LoDashStatic.prototype.conformsTo = function(object, source) {};

/**
 * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 * 
 * _.eq(object, object);
 * // => true
 * 
 * _.eq(object, other);
 * // => false
 * 
 * _.eq('a', 'a');
 * // => true
 * 
 * _.eq('a', Object('a'));
 * // => false
 * 
 * _.eq(NaN, NaN);
 * // => true
 * @param {?} value
 * @param {?} other
 * @return {boolean}
 */
_.LoDashStatic.prototype.eq = function(value, other) {};

/**
 * @see _.isEqual
 * @param {?} other
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.eq = function(other) {};

/**
 * @see _.isEqual
 * @param {?} other
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.eq = function(other) {};

/**
 * Checks if value is greater than other.
 * 
 * @param {?} value The value to compare.
 * @param {?} other The other value to compare.
 * @return {boolean} Returns true if value is greater than other, else false.
 */
_.LoDashStatic.prototype.gt = function(value, other) {};

/**
 * @see _.gt
 * @param {?} other
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.gt = function(other) {};

/**
 * @see _.gt
 * @param {?} other
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.gt = function(other) {};

/**
 * Checks if value is greater than or equal to other.
 * 
 * @param {?} value The value to compare.
 * @param {?} other The other value to compare.
 * @return {boolean} Returns true if value is greater than or equal to other, else false.
 */
_.LoDashStatic.prototype.gte = function(value, other) {};

/**
 * @see _.gte
 * @param {?} other
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.gte = function(other) {};

/**
 * @see _.gte
 * @param {?} other
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.gte = function(other) {};

/**
 * Checks if value is classified as an arguments object.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isArguments = function(value) {};

/**
 * @see _.isArguments
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isArguments = function() {};

/**
 * @see _.isArguments
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isArguments = function() {};

/**
 * Checks if value is classified as an Array object.
 * DEPRECATED
 * @template T
 * @param {?=} value The value to check.
 * 
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isArray = function(value) {};

/**
 * @see _.isArray
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isArray = function() {};

/**
 * @see _.isArray
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isArray = function() {};

/**
 * Checks if value is classified as an ArrayBuffer object.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isArrayBuffer = function(value) {};

/**
 * @see _.isArrayBuffer
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isArrayBuffer = function() {};

/**
 * @see _.isArrayBuffer
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isArrayBuffer = function() {};

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * _.isArrayLike([1, 2, 3]);
 * // => true
 * 
 * _.isArrayLike(document.body.children);
 * // => true
 * 
 * _.isArrayLike('abc');
 * // => true
 * 
 * _.isArrayLike(_.noop);
 * // => false
 * @see _.isArrayLike
 * @see _.isArrayLike
 * DEPRECATED
 * @template T
 * @param {?|!Function|(!Function|T)=} value
 * @return {boolean}
 */
_.LoDashStatic.prototype.isArrayLike = function(value) {};

/**
 * @see _.isArrayLike
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isArrayLike = function() {};

/**
 * @see _.isArrayLike
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isArrayLike = function() {};

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 * 
 * _.isArrayLikeObject(document.body.children);
 * // => true
 * 
 * _.isArrayLikeObject('abc');
 * // => false
 * 
 * _.isArrayLikeObject(_.noop);
 * // => false
 * @see _.isArrayLike
 * @see _.isArrayLike
 * DEPRECATED
 * @template T
 * @param {?|(string|number|boolean|!Function)|(string|number|boolean|!Function|T)=} value
 * @return {boolean}
 */
_.LoDashStatic.prototype.isArrayLikeObject = function(value) {};

/**
 * @see _.isArrayLikeObject
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isArrayLikeObject = function() {};

/**
 * @see _.isArrayLikeObject
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isArrayLikeObject = function() {};

/**
 * Checks if value is classified as a boolean primitive or object.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isBoolean = function(value) {};

/**
 * @see _.isBoolean
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isBoolean = function() {};

/**
 * @see _.isBoolean
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isBoolean = function() {};

/**
 * Checks if value is a buffer.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is a buffer, else false.
 */
_.LoDashStatic.prototype.isBuffer = function(value) {};

/**
 * @see _.isBuffer
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isBuffer = function() {};

/**
 * @see _.isBuffer
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isBuffer = function() {};

/**
 * Checks if value is classified as a Date object.
 * @param {?=} value The value to check.
 * 
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isDate = function(value) {};

/**
 * @see _.isDate
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isDate = function() {};

/**
 * @see _.isDate
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isDate = function() {};

/**
 * Checks if value is a DOM element.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is a DOM element, else false.
 */
_.LoDashStatic.prototype.isElement = function(value) {};

/**
 * @see _.isElement
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isElement = function() {};

/**
 * @see _.isElement
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isElement = function() {};

/**
 * Checks if value is empty. A value is considered empty unless it’s an arguments object, array, string, or
 * jQuery-like collection with a length greater than 0 or an object with own enumerable properties.
 * 
 * @param {?=} value The value to inspect.
 * @return {boolean} Returns true if value is empty, else false.
 */
_.LoDashStatic.prototype.isEmpty = function(value) {};

/**
 * @see _.isEmpty
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isEmpty = function() {};

/**
 * @see _.isEmpty
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isEmpty = function() {};

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 * 
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are **not** supported.
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 * 
 * _.isEqual(object, other);
 * // => true
 * 
 * object === other;
 * // => false
 * @param {?} value
 * @param {?} other
 * @return {boolean}
 */
_.LoDashStatic.prototype.isEqual = function(value, other) {};

/**
 * @see _.isEqual
 * @param {?} other
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isEqual = function(other) {};

/**
 * @see _.isEqual
 * @param {?} other
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isEqual = function(other) {};

/** @typedef {function(?, ?, (string|number), ?, ?, ?): boolean} */
_.IsEqualCustomizer;

/**
 * This method is like `_.isEqual` except that it accepts `customizer` which is
 * invoked to compare values. If `customizer` returns `undefined` comparisons are
 * handled by the method instead. The `customizer` is invoked with up to seven arguments:
 * (objValue, othValue [, index|key, object, other, stack]).
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 * 
 * function customizer(objValue, othValue) {
 *   if (isGreeting(objValue) && isGreeting(othValue)) {
 *     return true;
 *   }
 * }
 * 
 * var array = ['hello', 'goodbye'];
 * var other = ['hi', 'goodbye'];
 * 
 * _.isEqualWith(array, other, customizer);
 * // => true
 * @param {?} value
 * @param {?} other
 * @param {function(?, ?, (string|number), ?, ?, ?): boolean=} customizer
 * @return {boolean}
 */
_.LoDashStatic.prototype.isEqualWith = function(value, other, customizer) {};

/**
 * @see _.isEqualWith
 * @param {?} other
 * @param {function(?, ?, (string|number), ?, ?, ?): boolean=} customizer
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isEqualWith = function(other, customizer) {};

/**
 * @see _.isEqualWith
 * @param {?} other
 * @param {function(?, ?, (string|number), ?, ?, ?): boolean=} customizer
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isEqualWith = function(other, customizer) {};

/**
 * Checks if value is an Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, or URIError
 * object.
 * 
 * @param {?} value The value to check.
 * @return {boolean} Returns true if value is an error object, else false.
 */
_.LoDashStatic.prototype.isError = function(value) {};

/**
 * @see _.isError
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isError = function() {};

/**
 * @see _.isError
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isError = function() {};

/**
 * Checks if value is a finite primitive number.
 * 
 * Note: This method is based on Number.isFinite.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is a finite number, else false.
 */
_.LoDashStatic.prototype.isFinite = function(value) {};

/**
 * @see _.isFinite
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isFinite = function() {};

/**
 * @see _.isFinite
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isFinite = function() {};

/**
 * Checks if value is classified as a Function object.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isFunction = function(value) {};

/**
 * @see _.isFunction
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isFunction = function() {};

/**
 * @see _.isFunction
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isFunction = function() {};

/**
 * Checks if `value` is an integer.
 * 
 * **Note:** This method is based on [`Number.isInteger`](https://mdn.io/Number/isInteger).
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * _.isInteger(3);
 * // => true
 * 
 * _.isInteger(Number.MIN_VALUE);
 * // => false
 * 
 * _.isInteger(Infinity);
 * // => false
 * 
 * _.isInteger('3');
 * // => false
 * @param {?=} value
 * @return {boolean}
 */
_.LoDashStatic.prototype.isInteger = function(value) {};

/**
 * @see _.isInteger
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isInteger = function() {};

/**
 * @see _.isInteger
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isInteger = function() {};

/**
 * Checks if `value` is a valid array-like length.
 * 
 * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * _.isLength(3);
 * // => true
 * 
 * _.isLength(Number.MIN_VALUE);
 * // => false
 * 
 * _.isLength(Infinity);
 * // => false
 * 
 * _.isLength('3');
 * // => false
 * @param {?=} value
 * @return {boolean}
 */
_.LoDashStatic.prototype.isLength = function(value) {};

/**
 * @see _.isLength
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isLength = function() {};

/**
 * @see _.isLength
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isLength = function() {};

/**
 * Checks if value is classified as a Map object.
 * 
 * @template K, V
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isMap = function(value) {};

/**
 * @see _.isMap
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isMap = function() {};

/**
 * @see _.isMap
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isMap = function() {};

/** @typedef {function(?, ?, (string|number)): boolean} */
_.isMatchCustomizer;

/**
 * Performs a deep comparison between `object` and `source` to determine if
 * `object` contains equivalent property values.
 * 
 * **Note:** This method supports comparing the same values as `_.isEqual`.
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * var object = { 'user': 'fred', 'age': 40 };
 * 
 * _.isMatch(object, { 'age': 40 });
 * // => true
 * 
 * _.isMatch(object, { 'age': 36 });
 * // => false
 * @param {!Object} object
 * @param {!Object} source
 * @return {boolean}
 */
_.LoDashStatic.prototype.isMatch = function(object, source) {};

/**
 * @see _.isMatch
 * @param {!Object} source
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.isMatch = function(source) {};

/** @typedef {function(?, ?, (string|number)): boolean} */
_.isMatchWithCustomizer;

/**
 * This method is like `_.isMatch` except that it accepts `customizer` which
 * is invoked to compare values. If `customizer` returns `undefined` comparisons
 * are handled by the method instead. The `customizer` is invoked with three
 * arguments: (objValue, srcValue, index|key, object, source).
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 * 
 * function customizer(objValue, srcValue) {
 *   if (isGreeting(objValue) && isGreeting(srcValue)) {
 *     return true;
 *   }
 * }
 * 
 * var object = { 'greeting': 'hello' };
 * var source = { 'greeting': 'hi' };
 * 
 * _.isMatchWith(object, source, customizer);
 * // => true
 * @param {!Object} object
 * @param {!Object} source
 * @param {function(?, ?, (string|number)): boolean} customizer
 * @return {boolean}
 */
_.LoDashStatic.prototype.isMatchWith = function(object, source, customizer) {};

/**
 * @see _.isMatchWith
 * @param {!Object} source
 * @param {function(?, ?, (string|number)): boolean} customizer
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.isMatchWith = function(source, customizer) {};

/**
 * Checks if value is NaN.
 * 
 * Note: This method is not the same as isNaN which returns true for undefined and other non-numeric values.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is NaN, else false.
 */
_.LoDashStatic.prototype.isNaN = function(value) {};

/**
 * @see _.isNaN
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isNaN = function() {};

/**
 * @see _.isNaN
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isNaN = function() {};

/**
 * Checks if value is a native function.
 * \@retrun Returns true if value is a native function, else false.
 * @param {?} value The value to check.
 * 
 * @return {boolean}
 */
_.LoDashStatic.prototype.isNative = function(value) {};

/**
 * see _.isNative
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isNative = function() {};

/**
 * see _.isNative
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isNative = function() {};

/**
 * Checks if `value` is `null` or `undefined`.
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * _.isNil(null);
 * // => true
 * 
 * _.isNil(void 0);
 * // => true
 * 
 * _.isNil(NaN);
 * // => false
 * @param {?} value
 * @return {boolean}
 */
_.LoDashStatic.prototype.isNil = function(value) {};

/**
 * see _.isNil
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isNil = function() {};

/**
 * see _.isNil
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isNil = function() {};

/**
 * Checks if value is null.
 * 
 * @param {?} value The value to check.
 * @return {boolean} Returns true if value is null, else false.
 */
_.LoDashStatic.prototype.isNull = function(value) {};

/**
 * see _.isNull
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isNull = function() {};

/**
 * see _.isNull
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isNull = function() {};

/**
 * Checks if value is classified as a Number primitive or object.
 * 
 * Note: To exclude Infinity, -Infinity, and NaN, which are classified as numbers, use the _.isFinite method.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isNumber = function(value) {};

/**
 * see _.isNumber
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isNumber = function() {};

/**
 * see _.isNumber
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isNumber = function() {};

/**
 * Checks if value is the language type of Object. (e.g. arrays, functions, objects, regexes, new Number(0),
 * and new String(''))
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is an object, else false.
 */
_.LoDashStatic.prototype.isObject = function(value) {};

/**
 * see _.isObject
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isObject = function() {};

/**
 * see _.isObject
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isObject = function() {};

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * _.isObjectLike({});
 * // => true
 * 
 * _.isObjectLike([1, 2, 3]);
 * // => true
 * 
 * _.isObjectLike(_.noop);
 * // => false
 * 
 * _.isObjectLike(null);
 * // => false
 * @param {?=} value
 * @return {boolean}
 */
_.LoDashStatic.prototype.isObjectLike = function(value) {};

/**
 * see _.isObjectLike
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isObjectLike = function() {};

/**
 * see _.isObjectLike
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isObjectLike = function() {};

/**
 * Checks if value is a plain object, that is, an object created by the Object constructor or one with a
 * [[Prototype]] of null.
 * 
 * Note: This method assumes objects created by the Object constructor have no inherited enumerable properties.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is a plain object, else false.
 */
_.LoDashStatic.prototype.isPlainObject = function(value) {};

/**
 * see _.isPlainObject
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isPlainObject = function() {};

/**
 * see _.isPlainObject
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isPlainObject = function() {};

/**
 * Checks if value is classified as a RegExp object.
 * @param {?=} value The value to check.
 * 
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isRegExp = function(value) {};

/**
 * see _.isRegExp
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isRegExp = function() {};

/**
 * see _.isRegExp
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isRegExp = function() {};

/**
 * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
 * double precision number which isn't the result of a rounded unsafe integer.
 * 
 * **Note:** This method is based on [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * _.isSafeInteger(3);
 * // => true
 * 
 * _.isSafeInteger(Number.MIN_VALUE);
 * // => false
 * 
 * _.isSafeInteger(Infinity);
 * // => false
 * 
 * _.isSafeInteger('3');
 * // => false
 * @param {?} value
 * @return {boolean}
 */
_.LoDashStatic.prototype.isSafeInteger = function(value) {};

/**
 * see _.isSafeInteger
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isSafeInteger = function() {};

/**
 * see _.isSafeInteger
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isSafeInteger = function() {};

/**
 * Checks if value is classified as a Set object.
 * 
 * @template T
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isSet = function(value) {};

/**
 * @see _.isSet
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isSet = function() {};

/**
 * @see _.isSet
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isSet = function() {};

/**
 * Checks if value is classified as a String primitive or object.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isString = function(value) {};

/**
 * see _.isString
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isString = function() {};

/**
 * see _.isString
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isString = function() {};

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * _.isSymbol(Symbol.iterator);
 * // => true
 * 
 * _.isSymbol('abc');
 * // => false
 * @param {?} value
 * @return {boolean}
 */
_.LoDashStatic.prototype.isSymbol = function(value) {};

/**
 * see _.isSymbol
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isSymbol = function() {};

/**
 * see _.isSymbol
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isSymbol = function() {};

/**
 * Checks if value is classified as a typed array.
 * 
 * @param {?} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isTypedArray = function(value) {};

/**
 * see _.isTypedArray
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isTypedArray = function() {};

/**
 * see _.isTypedArray
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isTypedArray = function() {};

/**
 * Checks if value is undefined.
 * 
 * @param {?} value The value to check.
 * @return {boolean} Returns true if value is undefined, else false.
 */
_.LoDashStatic.prototype.isUndefined = function(value) {};

/**
 * see _.isUndefined
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isUndefined = function() {};

/**
 * see _.isUndefined
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isUndefined = function() {};

/**
 * Checks if value is classified as a WeakMap object.
 * 
 * @template K, V
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isWeakMap = function(value) {};

/**
 * @see _.isSet
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isWeakMap = function() {};

/**
 * @see _.isSet
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isWeakMap = function() {};

/**
 * Checks if value is classified as a WeakSet object.
 * 
 * @template T
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isWeakSet = function(value) {};

/**
 * @see _.isWeakSet
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isWeakSet = function() {};

/**
 * @see _.isWeakSet
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isWeakSet = function() {};

/**
 * Checks if value is less than other.
 * 
 * @param {?} value The value to compare.
 * @param {?} other The other value to compare.
 * @return {boolean} Returns true if value is less than other, else false.
 */
_.LoDashStatic.prototype.lt = function(value, other) {};

/**
 * @see _.lt
 * @param {?} other
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.lt = function(other) {};

/**
 * @see _.lt
 * @param {?} other
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.lt = function(other) {};

/**
 * Checks if value is less than or equal to other.
 * 
 * @param {?} value The value to compare.
 * @param {?} other The other value to compare.
 * @return {boolean} Returns true if value is less than or equal to other, else false.
 */
_.LoDashStatic.prototype.lte = function(value, other) {};

/**
 * @see _.lte
 * @param {?} other
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.lte = function(other) {};

/**
 * @see _.lte
 * @param {?} other
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.lte = function(other) {};

/**
 * Converts value to an array.
 * 
 * @see _.toArray
 * @see _.toArray
 * @template T, TValue, TResult
 * @param {(!ArrayLike<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)|TValue|?=} value The value to convert.
 * @return {!Array<T>|!Array<TResult>} Returns the converted array.
 */
_.LoDashStatic.prototype.toArray = function(value) {};

/**
 * @see _.toArray
 * @template TResult
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitWrapper.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @template TResult
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @template TResult
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitWrapper.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @template TResult
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.toArray = function() {};

/**
 * Converts value to a plain object flattening inherited enumerable properties of value to own properties
 * of the plain object.
 * 
 * @template TResult
 * @param {?=} value The value to convert.
 * @return {TResult} Returns the converted plain object.
 */
_.LoDashStatic.prototype.toPlainObject = function(value) {};

/**
 * @see _.toPlainObject
 * @template TResult
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitWrapperBase.prototype.toPlainObject = function() {};

/**
 * Converts `value` to a finite number.
 * 
 * \@memberOf _
 * \@since 4.12.0
 * \@category Lang
 * \@example 
 * 
 * _.toFinite(3.2);
 * // => 3.2
 * 
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 * 
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 * 
 * _.toFinite('3.2');
 * // => 3.2
 * @param {?} value
 * @return {number}
 */
_.LoDashStatic.prototype.toFinite = function(value) {};

/**
 * @see _.toFinite
 * @return {!_.LoDashImplicitWrapper<number>}
 */
_.LoDashImplicitWrapperBase.prototype.toFinite = function() {};

/**
 * @see _.toFinite
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapperBase.prototype.toFinite = function() {};

/**
 * Converts `value` to an integer.
 * 
 * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * _.toInteger(3);
 * // => 3
 * 
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 * 
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 * 
 * _.toInteger('3');
 * // => 3
 * @param {?} value
 * @return {number}
 */
_.LoDashStatic.prototype.toInteger = function(value) {};

/**
 * @see _.toInteger
 * @return {!_.LoDashImplicitWrapper<number>}
 */
_.LoDashImplicitWrapperBase.prototype.toInteger = function() {};

/**
 * @see _.toInteger
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapperBase.prototype.toInteger = function() {};

/**
 * Converts `value` to an integer suitable for use as the length of an
 * array-like object.
 * 
 * **Note:** This method is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * _.toLength(3);
 * // => 3
 * 
 * _.toLength(Number.MIN_VALUE);
 * // => 0
 * 
 * _.toLength(Infinity);
 * // => 4294967295
 * 
 * _.toLength('3');
 * // => 3
 * @param {?} value
 * @return {number}
 */
_.LoDashStatic.prototype.toLength = function(value) {};

/**
 * @see _.toLength
 * @return {!_.LoDashImplicitWrapper<number>}
 */
_.LoDashImplicitWrapperBase.prototype.toLength = function() {};

/**
 * @see _.toLength
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapperBase.prototype.toLength = function() {};

/**
 * Converts `value` to a number.
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * _.toNumber(3);
 * // => 3
 * 
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 * 
 * _.toNumber(Infinity);
 * // => Infinity
 * 
 * _.toNumber('3');
 * // => 3
 * @param {?} value
 * @return {number}
 */
_.LoDashStatic.prototype.toNumber = function(value) {};

/**
 * @see _.toNumber
 * @return {!_.LoDashImplicitWrapper<number>}
 */
_.LoDashImplicitWrapperBase.prototype.toNumber = function() {};

/**
 * @see _.toNumber
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapperBase.prototype.toNumber = function() {};

/**
 * Converts `value` to a safe integer. A safe integer can be compared and
 * represented correctly.
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * _.toSafeInteger(3);
 * // => 3
 * 
 * _.toSafeInteger(Number.MIN_VALUE);
 * // => 0
 * 
 * _.toSafeInteger(Infinity);
 * // => 9007199254740991
 * 
 * _.toSafeInteger('3');
 * // => 3
 * @param {?} value
 * @return {number}
 */
_.LoDashStatic.prototype.toSafeInteger = function(value) {};

/**
 * @see _.toSafeInteger
 * @return {!_.LoDashImplicitWrapper<number>}
 */
_.LoDashImplicitWrapperBase.prototype.toSafeInteger = function() {};

/**
 * @see _.toSafeInteger
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapperBase.prototype.toSafeInteger = function() {};

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` and `undefined` values. The sign of `-0` is preserved.
 * 
 * \@memberOf _
 * \@category Lang
 * \@example 
 * 
 * _.toString(null);
 * // => ''
 * 
 * _.toString(-0);
 * // => '-0'
 * 
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 * @param {?} value
 * @return {string}
 */
_.LoDashStatic.prototype.toString = function(value) {};

/**
 * Adds two numbers.
 * 
 * @param {number} augend The first number to add.
 * @param {number} addend The second number to add.
 * @return {number} Returns the sum.
 */
_.LoDashStatic.prototype.add = function(augend, addend) {};

/**
 * @see _.add
 * @param {number} addend
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.add = function(addend) {};

/**
 * @see _.add
 * @param {number} addend
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.add = function(addend) {};

/**
 * Calculates n rounded up to precision.
 * 
 * @param {number} n The number to round up.
 * @param {number=} precision The precision to round up to.
 * @return {number} Returns the rounded up number.
 */
_.LoDashStatic.prototype.ceil = function(n, precision) {};

/**
 * @see _.ceil
 * @param {number=} precision
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.ceil = function(precision) {};

/**
 * @see _.ceil
 * @param {number=} precision
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.ceil = function(precision) {};

/**
 * Divide two numbers.
 * 
 * @param {number} dividend The first number in a division.
 * @param {number} divisor The second number in a division.
 * @return {number} Returns the quotient.
 */
_.LoDashStatic.prototype.divide = function(dividend, divisor) {};

/**
 * @see _.divide
 * @param {number} divisor
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.divide = function(divisor) {};

/**
 * @see _.divide
 * @param {number} divisor
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.divide = function(divisor) {};

/**
 * Calculates n rounded down to precision.
 * 
 * @param {number} n The number to round down.
 * @param {number=} precision The precision to round down to.
 * @return {number} Returns the rounded down number.
 */
_.LoDashStatic.prototype.floor = function(n, precision) {};

/**
 * @see _.floor
 * @param {number=} precision
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.floor = function(precision) {};

/**
 * @see _.floor
 * @param {number=} precision
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.floor = function(precision) {};

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey
 * `undefined` is returned.
 * 
 * \@memberOf _
 * \@category Math
 * @template T
 * @param {!ArrayLike<T>} collection
 * @return {T}
 */
_.LoDashStatic.prototype.max = function(collection) {};

/**
 * @see _.max
 * @return {T}
 */
_.LoDashImplicitArrayWrapperBase.prototype.max = function() {};

/**
 * @see _.max
 * @template T
 * @return {T}
 */
_.LoDashImplicitObjectWrapperBase.prototype.max = function() {};

/**
 * This method is like `_.max` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 * 
 * \@memberOf _
 * \@category Math
 * \@example 
 * 
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 * 
 * _.maxBy(objects, function(o) { return o.a; });
 * // => { 'n': 2 }
 * 
 * // using the `_.property` iteratee shorthand
 * _.maxBy(objects, 'n');
 * // => { 'n': 2 }
 * @see _.maxBy
 * @see _.maxBy
 * @see _.maxBy
 * @template T, TObject
 * @param {!ArrayLike<T>|!_.Dictionary<T>|(!ArrayLike<T>|!_.Dictionary<T>)} collection
 * @param {function(T, number, !ArrayLike<T>): ?|function(T, string, !_.Dictionary<T>): ?|string|TObject=} iteratee_or_whereValue
 * @return {T}
 */
_.LoDashStatic.prototype.maxBy = function(collection, iteratee_or_whereValue) {};

/**
 * @see _.maxBy
 * @see _.maxBy
 * @see _.maxBy
 * @template TObject
 * @param {function(T, number, !ArrayLike<T>): ?|string|TObject=} iteratee_or_whereValue
 * @return {T}
 */
_.LoDashImplicitArrayWrapperBase.prototype.maxBy = function(iteratee_or_whereValue) {};

/**
 * @see _.maxBy
 * @see _.maxBy
 * @see _.maxBy
 * @template T, TObject
 * @param {(function(T, number, !ArrayLike<T>): ?|function(T, string, !_.Dictionary<T>): ?)|string|TObject=} iteratee_or_whereValue
 * @return {T}
 */
_.LoDashImplicitObjectWrapperBase.prototype.maxBy = function(iteratee_or_whereValue) {};

/**
 * Computes the mean of the values in `array`.
 * 
 * \@memberOf _
 * \@category Math
 * \@example 
 * 
 * _.mean([4, 2, 8, 6]);
 * // => 5
 * @template T
 * @param {!ArrayLike<T>} collection
 * @return {number}
 */
_.LoDashStatic.prototype.mean = function(collection) {};

/**
 * Computes the mean of the provided propties of the objects in the `array`
 * 
 * \@memberOf _
 * \@category Math
 * \@example 
 * 
 * _.mean([{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }], 'n');
 * // => 5
 * @template T
 * @param {!ArrayLike<T>} collection
 * @param {function(T, string, !_.Dictionary<T>): ?=} iteratee
 * @return {number}
 */
_.LoDashStatic.prototype.meanBy = function(collection, iteratee) {};

/**
 * @see _.mean
 * @see _.mean
 * @template T
 * @return {number}
 */
_.LoDashImplicitArrayWrapperBase.prototype.mean = function() {};

/**
 * Computes the minimum value of `array`. If `array` is empty or falsey
 * `undefined` is returned.
 * 
 * \@memberOf _
 * \@category Math
 * @template T
 * @param {!ArrayLike<T>} collection
 * @return {T}
 */
_.LoDashStatic.prototype.min = function(collection) {};

/**
 * @see _.min
 * @return {T}
 */
_.LoDashImplicitArrayWrapperBase.prototype.min = function() {};

/**
 * @see _.min
 * @template T
 * @return {T}
 */
_.LoDashImplicitObjectWrapperBase.prototype.min = function() {};

/**
 * This method is like `_.min` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 * 
 * \@memberOf _
 * \@category Math
 * \@example 
 * 
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 * 
 * _.minBy(objects, function(o) { return o.a; });
 * // => { 'n': 1 }
 * 
 * // using the `_.property` iteratee shorthand
 * _.minBy(objects, 'n');
 * // => { 'n': 1 }
 * @see _.minBy
 * @see _.minBy
 * @see _.minBy
 * @template T, TObject
 * @param {!ArrayLike<T>|!_.Dictionary<T>|(!ArrayLike<T>|!_.Dictionary<T>)} collection
 * @param {function(T, number, !ArrayLike<T>): ?|function(T, string, !_.Dictionary<T>): ?|string|TObject=} iteratee_or_whereValue
 * @return {T}
 */
_.LoDashStatic.prototype.minBy = function(collection, iteratee_or_whereValue) {};

/**
 * @see _.minBy
 * @see _.minBy
 * @see _.minBy
 * @template TObject
 * @param {function(T, number, !ArrayLike<T>): ?|string|TObject=} iteratee_or_whereValue
 * @return {T}
 */
_.LoDashImplicitArrayWrapperBase.prototype.minBy = function(iteratee_or_whereValue) {};

/**
 * @see _.minBy
 * @see _.minBy
 * @see _.minBy
 * @template T, TObject
 * @param {(function(T, number, !ArrayLike<T>): ?|function(T, string, !_.Dictionary<T>): ?)|string|TObject=} iteratee_or_whereValue
 * @return {T}
 */
_.LoDashImplicitObjectWrapperBase.prototype.minBy = function(iteratee_or_whereValue) {};

/**
 * Multiply two numbers.
 * @param {number} multiplier The first number in a multiplication.
 * @param {number} multiplicand The second number in a multiplication.
 * @return {number} Returns the product.
 */
_.LoDashStatic.prototype.multiply = function(multiplier, multiplicand) {};

/**
 * @see _.multiply
 * @param {number} multiplicand
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.multiply = function(multiplicand) {};

/**
 * @see _.multiply
 * @param {number} multiplicand
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.multiply = function(multiplicand) {};

/**
 * Calculates n rounded to precision.
 * 
 * @param {number} n The number to round.
 * @param {number=} precision The precision to round to.
 * @return {number} Returns the rounded number.
 */
_.LoDashStatic.prototype.round = function(n, precision) {};

/**
 * @see _.round
 * @param {number=} precision
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.round = function(precision) {};

/**
 * @see _.round
 * @param {number=} precision
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.round = function(precision) {};

/**
 * Computes the sum of the values in `array`.
 * 
 * \@memberOf _
 * \@category Math
 * \@example 
 * 
 * _.sum([4, 2, 8, 6]);
 * // => 20
 * @see _.sum
 * @template T
 * @param {!ArrayLike<T>|(!_.Dictionary<number>|!ArrayLike<number>)} collection
 * @return {number}
 */
_.LoDashStatic.prototype.sum = function(collection) {};

/**
 * @see _.sum
 * @return {number}
 */
_.LoDashImplicitArrayWrapperBase.prototype.sum = function() {};

/**
 * @see _.sum
 * 
 * @see _.sum
 * @template TValue
 * @return {number}
 */
_.LoDashImplicitObjectWrapperBase.prototype.sum = function() {};

/**
 * @see _.sum
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.sum = function() {};

/**
 * @see _.sum
 * @see _.sum
 * @template TValue
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.sum = function() {};

/**
 * This method is like `_.sum` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the value to be summed.
 * The iteratee is invoked with one argument: (value).
 * 
 * \@memberOf _
 * \@category Math
 * \@example 
 * 
 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
 * 
 * _.sumBy(objects, function(o) { return o.n; });
 * // => 20
 * 
 * // using the `_.property` iteratee shorthand
 * _.sumBy(objects, 'n');
 * // => 20
 * @see _.sumBy
 * @see _.sumBy
 * @see _.sumBy
 * @template T
 * @param {!ArrayLike<T>|!ArrayLike<!Object>|!ArrayLike<number>} collection
 * @param {function(T, number, !ArrayLike<T>): number|string|!_.Dictionary<!Object>=} iteratee
 * @return {number}
 */
_.LoDashStatic.prototype.sumBy = function(collection, iteratee) {};

/**
 * @see _.sumBy
 * @see _.sumBy
 * @see _.sumBy
 * @param {function(T, number, !ArrayLike<T>): number|string|!_.Dictionary<!Object>} iteratee
 * @return {number}
 */
_.LoDashImplicitArrayWrapperBase.prototype.sumBy = function(iteratee) {};

/**
 * @see _.sumBy
 * @see _.sumBy
 * @see _.sumBy
 * @param {function(!Object, number, !ArrayLike<?>): number|string|!_.Dictionary<!Object>} iteratee
 * @return {number}
 */
_.LoDashImplicitObjectWrapperBase.prototype.sumBy = function(iteratee) {};

/**
 * @see _.sumBy
 * @see _.sumBy
 * @see _.sumBy
 * @see _.sumBy
 * @param {function(T, number, !ArrayLike<T>): number|string|!_.Dictionary<!Object>=} iteratee
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.sumBy = function(iteratee) {};

/**
 * @see _.sumBy
 * @see _.sumBy
 * @see _.sumBy
 * @param {function(!Object, number, !ArrayLike<?>): number|string|!_.Dictionary<!Object>} iteratee
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.sumBy = function(iteratee) {};

/**
 * Subtract two numbers.
 * 
 * \@memberOf _
 * \@category Math
 * \@example 
 * 
 * _.subtract(6, 4);
 * // => 2
 * @param {number} minuend
 * @param {number} subtrahend
 * @return {number}
 */
_.LoDashStatic.prototype.subtract = function(minuend, subtrahend) {};

/**
 * @see _.subtract
 * @param {number} subtrahend
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.subtract = function(subtrahend) {};

/**
 * @see _.subtract
 * @param {number} subtrahend
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.subtract = function(subtrahend) {};

/**
 * Clamps `number` within the inclusive `lower` and `upper` bounds.
 * 
 * \@memberOf _
 * \@category Number
 * \@example 
 * 
 * _.clamp(-10, -5, 5);
 * // => -5
 * 
 * _.clamp(10, -5, 5);
 * // => 5
 * @param {number} number
 * @param {number} lower
 * @param {number} upper
 * @return {number}
 */
_.LoDashStatic.prototype.clamp = function(number, lower, upper) {};

/**
 * @see _.clamp
 * @param {number} lower
 * @param {number} upper
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.clamp = function(lower, upper) {};

/**
 * @see _.clamp
 * @param {number} lower
 * @param {number} upper
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.clamp = function(lower, upper) {};

/**
 * Checks if n is between start and up to but not including, end. If end is not specified it’s set to start
 * with start then set to 0.
 * 
 * @see _.inRange
 * @param {number} n The number to check.
 * @param {number} start_or_end The start of the range.
 * @param {number=} end The end of the range.
 * @return {boolean} Returns true if n is in the range, else false.
 */
_.LoDashStatic.prototype.inRange = function(n, start_or_end, end) {};

/**
 * @see _.inRange
 * @see _.inRange
 * @param {number} start_or_end
 * @param {number=} end
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.inRange = function(start_or_end, end) {};

/**
 * @see _.inRange
 * @see _.inRange
 * @param {number} start_or_end
 * @param {number=} end
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.inRange = function(start_or_end, end) {};

/**
 * Produces a random number between min and max (inclusive). If only one argument is provided a number between
 * 0 and the given number is returned. If floating is true, or either min or max are floats, a floating-point
 * number is returned instead of an integer.
 * 
 * @see _.random
 * @see _.random
 * @param {number|boolean=} min_or_floating The minimum possible value.
 * @param {number|boolean=} max_or_floating The maximum possible value.
 * @param {boolean=} floating Specify returning a floating-point number.
 * @return {number} Returns the random number.
 */
_.LoDashStatic.prototype.random = function(min_or_floating, max_or_floating, floating) {};

/**
 * @see _.random
 * @see _.random
 * @param {number|boolean=} max_or_floating
 * @param {boolean=} floating
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.random = function(max_or_floating, floating) {};

/**
 * @see _.random
 * @see _.random
 * @param {number|boolean=} max_or_floating
 * @param {boolean=} floating
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.random = function(max_or_floating, floating) {};

/**
 * Assigns own enumerable properties of source objects to the destination
 * object. Source objects are applied from left to right. Subsequent sources
 * overwrite property assignments of previous sources.
 * 
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 * 
 * \@memberOf _
 * \@category Object
 * \@example 
 * 
 * function Foo() {
 *   this.c = 3;
 * }
 * 
 * function Bar() {
 *   this.e = 5;
 * }
 * 
 * Foo.prototype.d = 4;
 * Bar.prototype.f = 6;
 * 
 * _.assign({ 'a': 1 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3, 'e': 5 }
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TObject, TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {TObject|?} object
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {?|TObject|TResult}
 */
_.LoDashStatic.prototype.assign = function(object, source_or_source1_or_otherArgs) {};

/**
 * @see _.assign
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashImplicitObjectWrapper<?>|!_.LoDashImplicitObjectWrapper|!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.assign = function(source_or_source1_or_otherArgs) {};

/**
 * @see _.assign
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashExplicitObjectWrapper<?>|!_.LoDashExplicitObjectWrapper|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.assign = function(source_or_source1_or_otherArgs) {};

/**
 * This method is like `_.assign` except that it accepts `customizer` which
 * is invoked to produce the assigned values. If `customizer` returns `undefined`
 * assignment is handled by the method instead. The `customizer` is invoked
 * with five arguments: (objValue, srcValue, key, object, source).
 * 
 * **Note:** This method mutates `object`.
 * 
 * \@memberOf _
 * \@category Object
 * \@example 
 * 
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 * 
 * var defaults = _.partialRight(_.assignWith, customizer);
 * 
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 * @see assignWith
 * @see assignWith
 * @see assignWith
 * @see _.assignWith
 * @see _.assignWith
 * @template TObject, TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {TObject|?} object
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {?|TObject|TResult}
 */
_.LoDashStatic.prototype.assignWith = function(object, source_or_source1_or_otherArgs) {};

/**
 * @see _.assignWith
 * @see assignWith
 * @see assignWith
 * @see assignWith
 * @see _.assignWith
 * @see _.assignWith
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashImplicitObjectWrapper<?>|!_.LoDashImplicitObjectWrapper|!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.assignWith = function(source_or_source1_or_otherArgs) {};

/**
 * @see _.assignWith
 * @see assignWith
 * @see assignWith
 * @see assignWith
 * @see _.assignWith
 * @see _.assignWith
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashExplicitObjectWrapper<?>|!_.LoDashExplicitObjectWrapper|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.assignWith = function(source_or_source1_or_otherArgs) {};

/**
 * This method is like `_.assign` except that it iterates over own and
 * inherited source properties.
 * 
 * **Note:** This method mutates `object`.
 * 
 * \@memberOf _
 * \@alias extend
 * \@category Object
 * \@example 
 * 
 * function Foo() {
 *   this.b = 2;
 * }
 * 
 * function Bar() {
 *   this.d = 4;
 * }
 * 
 * Foo.prototype.c = 3;
 * Bar.prototype.e = 5;
 * 
 * _.assignIn({ 'a': 1 }, new Foo, new Bar);
 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }
 * @see assignIn
 * @see assignIn
 * @see assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @template TObject, TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {TObject|?} object
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {?|TObject|TResult}
 */
_.LoDashStatic.prototype.assignIn = function(object, source_or_source1_or_otherArgs) {};

/**
 * @see _.assignIn
 * @see assignIn
 * @see assignIn
 * @see assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashImplicitObjectWrapper<?>|!_.LoDashImplicitObjectWrapper|!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.assignIn = function(source_or_source1_or_otherArgs) {};

/**
 * @see _.assignIn
 * @see assignIn
 * @see assignIn
 * @see assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashExplicitObjectWrapper<?>|!_.LoDashExplicitObjectWrapper|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.assignIn = function(source_or_source1_or_otherArgs) {};

/** @typedef {function(?, ?, string, !Object, ?): ?} */
_.AssignCustomizer;

/**
 * This method is like `_.assignIn` except that it accepts `customizer` which
 * is invoked to produce the assigned values. If `customizer` returns `undefined`
 * assignment is handled by the method instead. The `customizer` is invoked
 * with five arguments: (objValue, srcValue, key, object, source).
 * 
 * **Note:** This method mutates `object`.
 * 
 * \@memberOf _
 * \@alias extendWith
 * \@category Object
 * \@example 
 * 
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 * 
 * var defaults = _.partialRight(_.assignInWith, customizer);
 * 
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 * @see assignInWith
 * @see assignInWith
 * @see assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @template TObject, TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {TObject|?} object
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {?|TObject|TResult}
 */
_.LoDashStatic.prototype.assignInWith = function(object, source_or_source1_or_otherArgs) {};

/**
 * @see _.assignInWith
 * @see assignInWith
 * @see assignInWith
 * @see assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashImplicitObjectWrapper<?>|!_.LoDashImplicitObjectWrapper|!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.assignInWith = function(source_or_source1_or_otherArgs) {};

/**
 * @see _.assignInWith
 * @see assignInWith
 * @see assignInWith
 * @see assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashExplicitObjectWrapper<?>|!_.LoDashExplicitObjectWrapper|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.assignInWith = function(source_or_source1_or_otherArgs) {};

/**
 * Creates an object that inherits from the given prototype object. If a properties object is provided its own
 * enumerable properties are assigned to the created object.
 * 
 * @template T, U
 * @param {T} prototype The object to inherit from.
 * @param {U=} properties The properties to assign to the object.
 * @return {?} Returns the new object.
 */
_.LoDashStatic.prototype.create = function(prototype, properties) {};

/**
 * @see _.create
 * @template U
 * @param {U=} properties
 * @return {!_.LoDashImplicitObjectWrapper<?>}
 */
_.LoDashImplicitObjectWrapper.prototype.create = function(properties) {};

/**
 * @see _.create
 * @template U
 * @param {U=} properties
 * @return {!_.LoDashExplicitObjectWrapper<?>}
 */
_.LoDashExplicitObjectWrapper.prototype.create = function(properties) {};

/**
 * Assigns own enumerable properties of source object(s) to the destination object for all destination
 * properties that resolve to undefined. Once a property is set, additional values of the same property are
 * ignored.
 * 
 * Note: This method mutates object.
 * 
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @template TObject, TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {TObject|?} object The destination object.
 * @param {...TSource|TSource1|?} source_or_source1_or_sources
 * @return {?|TObject|TResult} The destination object.
 */
_.LoDashStatic.prototype.defaults = function(object, source_or_source1_or_sources) {};

/**
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_sources
 * @return {!_.LoDashImplicitObjectWrapper<?>|!_.LoDashImplicitObjectWrapper|!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.defaults = function(source_or_source1_or_sources) {};

/**
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_sources
 * @return {!_.LoDashExplicitObjectWrapper<?>|!_.LoDashExplicitObjectWrapper|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.defaults = function(source_or_source1_or_sources) {};

/**
 * This method is like _.defaults except that it recursively assigns default properties.
 * @template T, TResult
 * @param {T} object The destination object.
 * @param {...?} sources The source objects.
 * @return {TResult} Returns object.
 * 
 */
_.LoDashStatic.prototype.defaultsDeep = function(object, sources) {};

/**
 * @see _.defaultsDeep
 * 
 * @template TResult
 * @param {...?} sources
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.defaultsDeep = function(sources) {};

/**
 * @see _.assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @template TObject, TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {TObject|?} object
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {?|TObject|TResult}
 */
_.LoDashStatic.prototype.extend = function(object, source_or_source1_or_otherArgs) {};

/**
 * @see _.assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashImplicitObjectWrapper<?>|!_.LoDashImplicitObjectWrapper|!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.extend = function(source_or_source1_or_otherArgs) {};

/**
 * @see _.assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @see _.assignIn
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashExplicitObjectWrapper<?>|!_.LoDashExplicitObjectWrapper|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.extend = function(source_or_source1_or_otherArgs) {};

/**
 * @see _.assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @template TObject, TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {TObject|?} object
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {?|TObject|TResult}
 */
_.LoDashStatic.prototype.extendWith = function(object, source_or_source1_or_otherArgs) {};

/**
 * @see _.assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashImplicitObjectWrapper<?>|!_.LoDashImplicitObjectWrapper|!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.extendWith = function(source_or_source1_or_otherArgs) {};

/**
 * @see _.assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @see _.assignInWith
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashExplicitObjectWrapper<?>|!_.LoDashExplicitObjectWrapper|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.extendWith = function(source_or_source1_or_otherArgs) {};

/**
 * This method is like _.find except that it returns the key of the first element predicate returns truthy for
 * instead of the element itself.
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @template TValues, TObject, TWhere
 * @param {TObject} object The object to search.
 * @param {function(TValues, string, !_.Dictionary<TValues>): boolean|function(?, string, ?): boolean|string|TWhere=} predicate The function invoked per iteration.
 * @return {string} Returns the key of the matched element, else undefined.
 */
_.LoDashStatic.prototype.findKey = function(object, predicate) {};

/**
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @template TValues, TWhere
 * @param {function(TValues, string, !_.Dictionary<TValues>): boolean|function(?, string, ?): boolean|string|TWhere=} predicate
 * @return {string}
 */
_.LoDashImplicitObjectWrapperBase.prototype.findKey = function(predicate) {};

/**
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @template TValues, TWhere
 * @param {function(TValues, string, !_.Dictionary<TValues>): boolean|function(?, string, ?): boolean|string|TWhere=} predicate
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.findKey = function(predicate) {};

/**
 * This method is like _.findKey except that it iterates over elements of a collection in the opposite order.
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @template TValues, TObject, TWhere
 * @param {TObject} object The object to search.
 * @param {function(TValues, string, !_.Dictionary<TValues>): boolean|function(?, string, ?): boolean|string|TWhere=} predicate The function invoked per iteration.
 * @return {string} Returns the key of the matched element, else undefined.
 */
_.LoDashStatic.prototype.findLastKey = function(object, predicate) {};

/**
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @template TValues, TWhere
 * @param {function(TValues, string, !_.Dictionary<TValues>): boolean|function(?, string, ?): boolean|string|TWhere=} predicate
 * @return {string}
 */
_.LoDashImplicitObjectWrapperBase.prototype.findLastKey = function(predicate) {};

/**
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @template TValues, TWhere
 * @param {function(TValues, string, !_.Dictionary<TValues>): boolean|function(?, string, ?): boolean|string|TWhere=} predicate
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.findLastKey = function(predicate) {};

/**
 * Iterates over own and inherited enumerable properties of an object invoking iteratee for each property. The
 * iteratee is bound to thisArg and invoked with three arguments: (value, key, object). Iteratee functions may
 * exit iteration early by explicitly returning false.
 * 
 * @see _.forIn
 * @see _.forIn
 * @template T
 * @param {!_.Dictionary<T>|T} object The object to iterate over.
 * @param {function(T, string, !_.Dictionary<T>): ?|function(?, string, ?): ?=} iteratee The function invoked per iteration.
 * @return {!_.Dictionary<T>|T} Returns object.
 */
_.LoDashStatic.prototype.forIn = function(object, iteratee) {};

/**
 * @see _.forIn
 * @template TValue
 * @param {function(TValue, string, !_.Dictionary<TValue>): ?=} iteratee
 * @return {TWrapper}
 */
_.LoDashImplicitObjectWrapperBase.prototype.forIn = function(iteratee) {};

/**
 * @see _.forIn
 * @template TValue
 * @param {function(TValue, string, !_.Dictionary<TValue>): ?=} iteratee
 * @return {TWrapper}
 */
_.LoDashExplicitObjectWrapperBase.prototype.forIn = function(iteratee) {};

/**
 * This method is like _.forIn except that it iterates over properties of object in the opposite order.
 * 
 * @see _.forInRight
 * @see _.forInRight
 * @template T
 * @param {!_.Dictionary<T>|T} object The object to iterate over.
 * @param {function(T, string, !_.Dictionary<T>): ?|function(?, string, ?): ?=} iteratee The function invoked per iteration.
 * @return {!_.Dictionary<T>|T} Returns object.
 */
_.LoDashStatic.prototype.forInRight = function(object, iteratee) {};

/**
 * @see _.forInRight
 * @template TValue
 * @param {function(TValue, string, !_.Dictionary<TValue>): ?=} iteratee
 * @return {TWrapper}
 */
_.LoDashImplicitObjectWrapperBase.prototype.forInRight = function(iteratee) {};

/**
 * @see _.forInRight
 * @template TValue
 * @param {function(TValue, string, !_.Dictionary<TValue>): ?=} iteratee
 * @return {TWrapper}
 */
_.LoDashExplicitObjectWrapperBase.prototype.forInRight = function(iteratee) {};

/**
 * Iterates over own enumerable properties of an object invoking iteratee for each property. The iteratee is
 * bound to thisArg and invoked with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning false.
 * 
 * @see _.forOwn
 * @see _.forOwn
 * @template T
 * @param {!_.Dictionary<T>|T} object The object to iterate over.
 * @param {function(T, string, !_.Dictionary<T>): ?|function(?, string, ?): ?=} iteratee The function invoked per iteration.
 * @return {!_.Dictionary<T>|T} Returns object.
 */
_.LoDashStatic.prototype.forOwn = function(object, iteratee) {};

/**
 * @see _.forOwn
 * @template TValue
 * @param {function(TValue, string, !_.Dictionary<TValue>): ?=} iteratee
 * @return {TWrapper}
 */
_.LoDashImplicitObjectWrapperBase.prototype.forOwn = function(iteratee) {};

/**
 * @see _.forOwn
 * @template TValue
 * @param {function(TValue, string, !_.Dictionary<TValue>): ?=} iteratee
 * @return {TWrapper}
 */
_.LoDashExplicitObjectWrapperBase.prototype.forOwn = function(iteratee) {};

/**
 * This method is like _.forOwn except that it iterates over properties of object in the opposite order.
 * 
 * @see _.forOwnRight
 * @see _.forOwnRight
 * @template T
 * @param {!_.Dictionary<T>|T} object The object to iterate over.
 * @param {function(T, string, !_.Dictionary<T>): ?|function(?, string, ?): ?=} iteratee The function invoked per iteration.
 * @return {!_.Dictionary<T>|T} Returns object.
 */
_.LoDashStatic.prototype.forOwnRight = function(object, iteratee) {};

/**
 * @see _.forOwnRight
 * @template TValue
 * @param {function(TValue, string, !_.Dictionary<TValue>): ?=} iteratee
 * @return {TWrapper}
 */
_.LoDashImplicitObjectWrapperBase.prototype.forOwnRight = function(iteratee) {};

/**
 * @see _.forOwnRight
 * @template TValue
 * @param {function(TValue, string, !_.Dictionary<TValue>): ?=} iteratee
 * @return {TWrapper}
 */
_.LoDashExplicitObjectWrapperBase.prototype.forOwnRight = function(iteratee) {};

/**
 * Creates an array of function property names from own enumerable properties
 * of `object`.
 * 
 * \@memberOf _
 * \@category Object
 * \@example 
 * 
 * function Foo() {
 *   this.a = _.constant('a');
 *   this.b = _.constant('b');
 * }
 * 
 * Foo.prototype.c = _.constant('c');
 * 
 * _.functions(new Foo);
 * // => ['a', 'b']
 * @template T
 * @param {?} object
 * @return {!Array<string>}
 */
_.LoDashStatic.prototype.functions = function(object) {};

/**
 * @see _.functions
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitObjectWrapper.prototype.functions = function() {};

/**
 * @see _.functions
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.functions = function() {};

/**
 * Creates an array of function property names from own and inherited
 * enumerable properties of `object`.
 * 
 * \@memberOf _
 * \@category Object
 * \@example 
 * 
 * function Foo() {
 *   this.a = _.constant('a');
 *   this.b = _.constant('b');
 * }
 * 
 * Foo.prototype.c = _.constant('c');
 * 
 * _.functionsIn(new Foo);
 * // => ['a', 'b', 'c']
 * @template T
 * @param {?} object
 * @return {!Array<string>}
 */
_.LoDashStatic.prototype.functionsIn = function(object) {};

/**
 * @see _.functionsIn
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitObjectWrapper.prototype.functionsIn = function() {};

/**
 * @see _.functionsIn
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.functionsIn = function() {};

/**
 * Gets the property value at path of object. If the resolved value is undefined the defaultValue is used
 * in its place.
 * 
 * @see _.get
 * @template TObject, TResult
 * @param {TObject|?} object The object to query.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to get.
 * @param {TResult=} defaultValue The value returned if the resolved value is undefined.
 * @return {TResult} Returns the resolved value.
 */
_.LoDashStatic.prototype.get = function(object, path, defaultValue) {};

/**
 * @see _.get
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {TResult=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitWrapper.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {TResult=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapperBase.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {TResult=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapperBase.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitWrapper.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitObjectWrapperBase.prototype.get = function(path, defaultValue) {};

/**
 * Checks if `path` is a direct property of `object`.
 * 
 * \@memberOf _
 * \@category Object
 * \@example 
 * 
 * var object = { 'a': { 'b': { 'c': 3 } } };
 * var other = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });
 * 
 * _.has(object, 'a');
 * // => true
 * 
 * _.has(object, 'a.b.c');
 * // => true
 * 
 * _.has(object, ['a', 'b', 'c']);
 * // => true
 * 
 * _.has(other, 'a');
 * // => false
 * @template T
 * @param {T} object
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {boolean}
 */
_.LoDashStatic.prototype.has = function(object, path) {};

/**
 * @see _.has
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapperBase.prototype.has = function(path) {};

/**
 * @see _.has
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.has = function(path) {};

/**
 * Checks if `path` is a direct or inherited property of `object`.
 * 
 * \@memberOf _
 * \@category Object
 * \@example 
 * 
 * var object = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });
 * 
 * _.hasIn(object, 'a');
 * // => true
 * 
 * _.hasIn(object, 'a.b.c');
 * // => true
 * 
 * _.hasIn(object, ['a', 'b', 'c']);
 * // => true
 * 
 * _.hasIn(object, 'b');
 * // => false
 * @template T
 * @param {T} object
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {boolean}
 */
_.LoDashStatic.prototype.hasIn = function(object, path) {};

/**
 * @see _.hasIn
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapperBase.prototype.hasIn = function(path) {};

/**
 * @see _.hasIn
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.hasIn = function(path) {};

/**
 * Creates an object composed of the inverted keys and values of object. If object contains duplicate values,
 * subsequent values overwrite property assignments of previous values unless multiValue is true.
 * 
 * @see _.invert
 * @template T, TResult
 * @param {T|!Object} object The object to invert.
 * @param {boolean=} multiValue Allow multiple values per key.
 * @return {TResult} Returns the new inverted object.
 */
_.LoDashStatic.prototype.invert = function(object, multiValue) {};

/**
 * @see _.invert
 * @template TResult
 * @param {boolean=} multiValue
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.invert = function(multiValue) {};

/**
 * @see _.invert
 * @template TResult
 * @param {boolean=} multiValue
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.invert = function(multiValue) {};

/** @typedef {function(T): ?} */
_.InvertByIterator;

/**
 * This method is like _.invert except that the inverted object is generated from the results of running each
 * element of object through iteratee. The corresponding inverted value of each inverted key is an array of
 * keys responsible for generating the inverted value. The iteratee is invoked with one argument: (value).
 * 
 * @see _.invertBy
 * @see _.invertBy
 * @see _.invertBy
 * @template T, W
 * @param {!Object|(!_.Dictionary<T>|!_.NumericDictionary<T>)|!_.Dictionary<T>} object The object to invert.
 * @param {(string|function(?): ?)|(string|function(T): ?)|W=} interatee The iteratee invoked per element.
 * @return {!_.Dictionary<!Array<string>>} Returns the new inverted object.
 */
_.LoDashStatic.prototype.invertBy = function(object, interatee) {};

/**
 * @see _.invertBy
 * @param {function(?): ?=} interatee
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<!Array<string>>>}
 */
_.LoDashImplicitWrapper.prototype.invertBy = function(interatee) {};

/**
 * @see _.invertBy
 * @see _.invertBy
 * @template W
 * @param {(string|function(T): ?)|W=} interatee
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<!Array<string>>>}
 */
_.LoDashImplicitArrayWrapper.prototype.invertBy = function(interatee) {};

/**
 * @see _.invertBy
 * @see _.invertBy
 * @template W
 * @param {(string|function(?): ?)|W=} interatee
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<!Array<string>>>}
 */
_.LoDashImplicitObjectWrapper.prototype.invertBy = function(interatee) {};

/**
 * @see _.invertBy
 * @param {function(?): ?=} interatee
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<!Array<string>>>}
 */
_.LoDashExplicitWrapper.prototype.invertBy = function(interatee) {};

/**
 * @see _.invertBy
 * @see _.invertBy
 * @template W
 * @param {(string|function(T): ?)|W=} interatee
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<!Array<string>>>}
 */
_.LoDashExplicitArrayWrapper.prototype.invertBy = function(interatee) {};

/**
 * @see _.invertBy
 * @see _.invertBy
 * @template W
 * @param {(string|function(?): ?)|W=} interatee
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<!Array<string>>>}
 */
_.LoDashExplicitObjectWrapper.prototype.invertBy = function(interatee) {};

/**
 * Creates an array of the own enumerable property names of object.
 * 
 * Note: Non-object values are coerced to objects. See the ES spec for more details.
 * 
 * @param {?=} object The object to query.
 * @return {!Array<string>} Returns the array of property names.
 */
_.LoDashStatic.prototype.keys = function(object) {};

/**
 * @see _.keys
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.keys = function() {};

/**
 * @see _.keys
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.keys = function() {};

/**
 * Creates an array of the own and inherited enumerable property names of object.
 * 
 * Note: Non-object values are coerced to objects.
 * 
 * @param {?=} object The object to query.
 * @return {!Array<string>} An array of property names.
 */
_.LoDashStatic.prototype.keysIn = function(object) {};

/**
 * @see _.keysIn
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.keysIn = function() {};

/**
 * @see _.keysIn
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.keysIn = function() {};

/**
 * The opposite of _.mapValues; this method creates an object with the same values as object and keys generated
 * by running each own enumerable property of object through iteratee.
 * 
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template T, TKey, TObject
 * @param {!ArrayLike<T>|!_.Dictionary<T>|(!_.Dictionary<T>|!ArrayLike<T>)} object The object to iterate over.
 * @param {function(T, number, !ArrayLike<T>): TKey|function(T, string, !_.Dictionary<T>): TKey|TObject|string=} iteratee The function invoked per iteration.
 * @return {!_.Dictionary<T>} Returns the new mapped object.
 */
_.LoDashStatic.prototype.mapKeys = function(object, iteratee) {};

/**
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template TKey, TObject
 * @param {function(T, number, !ArrayLike<T>): TKey|TObject|string=} iteratee
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.mapKeys = function(iteratee) {};

/**
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template TResult, TKey, TObject
 * @param {(function(TResult, number, !ArrayLike<TResult>): TKey|function(TResult, string, !_.Dictionary<TResult>): TKey)|TObject|string=} iteratee
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<TResult>>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.mapKeys = function(iteratee) {};

/**
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template TKey, TObject
 * @param {function(T, number, !ArrayLike<T>): TKey|TObject|string=} iteratee
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.mapKeys = function(iteratee) {};

/**
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template TResult, TKey, TObject
 * @param {(function(TResult, number, !ArrayLike<TResult>): TKey|function(TResult, string, !_.Dictionary<TResult>): TKey)|TObject|string=} iteratee
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<TResult>>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.mapKeys = function(iteratee) {};

/**
 * Creates an object with the same keys as object and values generated by running each own
 * enumerable property of object through iteratee. The iteratee function is bound to thisArg
 * and invoked with three arguments: (value, key, object).
 * 
 * If a property name is provided iteratee the created "_.property" style callback returns
 * the property value of the given element.
 * 
 * If a value is also provided for thisArg the creted "_.matchesProperty" style callback returns
 * true for elements that have a matching property value, else false;.
 * 
 * If an object is provided for iteratee the created "_.matches" style callback returns true
 * for elements that have the properties of the given object, else false.
 * 
 * @template T, TResult, TMapped
 * @param {!_.Dictionary<T>|T} obj
 * @param {function(T, string, ?): TResult|!_.Dictionary<T>|string|function(?, string, ?): ?} callback_or_where_or_pluck
 * @return {!_.Dictionary<TResult>|!_.Dictionary<boolean>|TMapped|T}
 */
_.LoDashStatic.prototype.mapValues = function(obj, callback_or_where_or_pluck) {};

/**
 * @see _.mapValues
 * TValue is the type of the property values of T.
 * TResult is the type output by the ObjectIterator function
 * @see _.mapValues
 * TResult is the type of the property specified by pluck.
 * T should be a Dictionary<Dictionary<TResult>>
 * @see _.mapValues
 * TResult is the type of the properties of each object in the values of T
 * T should be a Dictionary<Dictionary<TResult>>
 * @template TValue, TResult
 * @param {function(TValue, string, ?): TResult|string|!_.Dictionary<TResult>} callback_or_pluck_or_where
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<TResult>>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.mapValues = function(callback_or_pluck_or_where) {};

/**
 * @see _.mapValues
 * TValue is the type of the property values of T.
 * TResult is the type output by the ObjectIterator function
 * @see _.mapValues
 * TResult is the type of the property specified by pluck.
 * T should be a Dictionary<Dictionary<TResult>>
 * @see _.mapValues
 * TResult is the type of the properties of each object in the values of T
 * T should be a Dictionary<Dictionary<TResult>>
 * @template TValue, TResult
 * @param {function(TValue, string, ?): TResult|string|!_.Dictionary<TResult>} callback_or_pluck_or_where
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<TResult>>|!_.LoDashExplicitObjectWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.mapValues = function(callback_or_pluck_or_where) {};

/**
 * Recursively merges own and inherited enumerable properties of source
 * objects into the destination object, skipping source properties that resolve
 * to `undefined`. Array and plain object properties are merged recursively.
 * Other objects and value types are overridden by assignment. Source objects
 * are applied from left to right. Subsequent sources overwrite property
 * assignments of previous sources.
 * 
 * **Note:** This method mutates `object`.
 * 
 * \@memberOf _
 * \@category Object
 * \@example 
 * 
 * var users = {
 *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
 * };
 * 
 * var ages = {
 *   'data': [{ 'age': 36 }, { 'age': 40 }]
 * };
 * 
 * _.merge(users, ages);
 * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @template TObject, TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {TObject|?} object
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {?|TResult}
 */
_.LoDashStatic.prototype.merge = function(object, source_or_source1_or_otherArgs) {};

/**
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashImplicitObjectWrapper<?>|!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.merge = function(source_or_source1_or_otherArgs) {};

/**
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashExplicitObjectWrapper<?>|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.merge = function(source_or_source1_or_otherArgs) {};

/** @typedef {function(?, ?, string, !Object, !Object): ?} */
_.MergeWithCustomizer;

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined` merging is handled by the
 * method instead. The `customizer` is invoked with seven arguments:
 * (objValue, srcValue, key, object, source, stack).
 * 
 * \@memberOf _
 * \@category Object
 * \@example 
 * 
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 * 
 * var object = {
 *   'fruits': ['apple'],
 *   'vegetables': ['beet']
 * };
 * 
 * var other = {
 *   'fruits': ['banana'],
 *   'vegetables': ['carrot']
 * };
 * 
 * _.merge(object, other, customizer);
 * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
 * @see _.mergeWith
 * @see _.mergeWith
 * @see _.mergeWith
 * @see _.mergeWith
 * @template TObject, TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {TObject|?} object
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {?|TResult}
 */
_.LoDashStatic.prototype.mergeWith = function(object, source_or_source1_or_otherArgs) {};

/**
 * @see _.mergeWith
 * @see _.mergeWith
 * @see _.mergeWith
 * @see _.mergeWith
 * @see _.mergeWith
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashImplicitObjectWrapper<?>|!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.mergeWith = function(source_or_source1_or_otherArgs) {};

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable properties of `object` that are not omitted.
 * 
 * \@memberOf _
 * \@category Object
 *  individually or in arrays..
 * \@example 
 * 
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 * 
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 * @template TResult, T
 * @param {T} object
 * @param {...(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate
 * @return {TResult}
 */
_.LoDashStatic.prototype.omit = function(object, predicate) {};

/**
 * @see _.omit
 * @template TResult
 * @param {...(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.omit = function(predicate) {};

/**
 * @see _.omit
 * @template TResult
 * @param {...(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.omit = function(predicate) {};

/**
 * The opposite of `_.pickBy`; this method creates an object composed of the
 * own and inherited enumerable properties of `object` that `predicate`
 * doesn't return truthy for.
 * 
 * \@memberOf _
 * \@category Object
 * \@example 
 * 
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 * 
 * _.omitBy(object, _.isNumber);
 * // => { 'b': '2' }
 * @template TResult, T
 * @param {T} object
 * @param {function(?, string, ?): boolean} predicate
 * @return {TResult}
 */
_.LoDashStatic.prototype.omitBy = function(object, predicate) {};

/**
 * @see _.omitBy
 * @template TResult
 * @param {function(?, string, ?): boolean} predicate
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.omitBy = function(predicate) {};

/**
 * @see _.omitBy
 * @template TResult
 * @param {function(?, string, ?): boolean} predicate
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.omitBy = function(predicate) {};

/**
 * Creates an object composed of the picked `object` properties.
 * 
 * \@memberOf _
 * \@category Object
 *  individually or in arrays.
 * \@example 
 * 
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 * 
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 * @template TResult, T
 * @param {T} object
 * @param {...(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate
 * @return {TResult}
 */
_.LoDashStatic.prototype.pick = function(object, predicate) {};

/**
 * @see _.pick
 * @template TResult
 * @param {...(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.pick = function(predicate) {};

/**
 * @see _.pick
 * @template TResult
 * @param {...(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.pick = function(predicate) {};

/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with one argument: (value).
 * 
 * \@memberOf _
 * \@category Object
 * \@example 
 * 
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 * 
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 * @template TResult, T
 * @param {T} object
 * @param {function(?, string, ?): boolean=} predicate
 * @return {TResult}
 */
_.LoDashStatic.prototype.pickBy = function(object, predicate) {};

/**
 * @see _.pickBy
 * @template TResult
 * @param {function(?, string, ?): boolean=} predicate
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.pickBy = function(predicate) {};

/**
 * @see _.pickBy
 * @template TResult
 * @param {function(?, string, ?): boolean=} predicate
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.pickBy = function(predicate) {};

/**
 * This method is like _.get except that if the resolved value is a function it’s invoked with the this binding
 * of its parent object and its result is returned.
 * 
 * @see _.result
 * @template TObject, TResult
 * @param {TObject|?} object The object to query.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to resolve.
 * @param {(TResult|function(!Array<?>): TResult)=} defaultValue The value returned if the resolved value is undefined.
 * @return {TResult} Returns the resolved value.
 */
_.LoDashStatic.prototype.result = function(object, path, defaultValue) {};

/**
 * @see _.result
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {(TResult|function(!Array<?>): TResult)=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitWrapper.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {(TResult|function(!Array<?>): TResult)=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapperBase.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {(TResult|function(!Array<?>): TResult)=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapperBase.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitWrapper.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.result = function(path, defaultValue) {};

/**
 * Sets the value at path of object. If a portion of path doesn’t exist it’s created. Arrays are created for
 * missing index properties while objects are created for all other missing properties. Use _.setWith to
 * customize path creation.
 * 
 * @see _.set
 * @see _.set
 * @template TResult, V, O
 * @param {!Object|O} object The object to modify.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to set.
 * @param {?|V} value The value to set.
 * @return {TResult} Returns object.
 */
_.LoDashStatic.prototype.set = function(object, path, value) {};

/**
 * @see _.set
 * @see _.set
 * @template TResult, V
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?|V} value
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.set = function(path, value) {};

/**
 * @see _.set
 * @see _.set
 * @template TResult, V
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?|V} value
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.set = function(path, value) {};

/** @typedef {function(?, string, T): ?} */
_.SetWithCustomizer;

/**
 * This method is like _.set except that it accepts customizer which is invoked to produce the objects of
 * path. If customizer returns undefined path creation is handled by the method instead. The customizer is
 * invoked with three arguments: (nsValue, key, nsObject).
 * 
 * \@parem customizer The function to customize assigned values.
 * @see _.setWith
 * @see _.setWith
 * @template TResult, V, O
 * @param {!Object|O} object The object to modify.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to set.
 * @param {?|V} value The value to set.
 * @param {function(?, string, !Object): ?|function(?, string, O): ?=} customizer
 * @return {TResult} Returns object.
 */
_.LoDashStatic.prototype.setWith = function(object, path, value, customizer) {};

/**
 * @see _.setWith
 * @see _.setWith
 * @template TResult, V
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?|V} value
 * @param {function(?, string, T): ?=} customizer
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.setWith = function(path, value, customizer) {};

/**
 * @see _.setWith
 * @see _.setWith
 * @template TResult, V
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?|V} value
 * @param {function(?, string, T): ?=} customizer
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.setWith = function(path, value, customizer) {};

/**
 * Creates an array of own enumerable key-value pairs for object.
 * 
 * @template T, TResult
 * @param {T=} object The object to query.
 * @return {!Array<!Array<?>>} Returns the new array of key-value pairs.
 */
_.LoDashStatic.prototype.toPairs = function(object) {};

/**
 * @see _.toPairs
 * @template TResult
 * @return {!_.LoDashImplicitArrayWrapper<!Array<?>>}
 */
_.LoDashImplicitObjectWrapper.prototype.toPairs = function() {};

/**
 * @see _.toPairs
 * @template TResult
 * @return {!_.LoDashExplicitArrayWrapper<!Array<?>>}
 */
_.LoDashExplicitObjectWrapper.prototype.toPairs = function() {};

/**
 * Creates an array of own and inherited enumerable key-value pairs for object.
 * 
 * @template T, TResult
 * @param {T=} object The object to query.
 * @return {!Array<!Array<?>>} Returns the new array of key-value pairs.
 */
_.LoDashStatic.prototype.toPairsIn = function(object) {};

/**
 * @see _.toPairsIn
 * @template TResult
 * @return {!_.LoDashImplicitArrayWrapper<!Array<?>>}
 */
_.LoDashImplicitObjectWrapper.prototype.toPairsIn = function() {};

/**
 * @see _.toPairsIn
 * @template TResult
 * @return {!_.LoDashExplicitArrayWrapper<!Array<?>>}
 */
_.LoDashExplicitObjectWrapper.prototype.toPairsIn = function() {};

/**
 * An alternative to _.reduce; this method transforms object to a new accumulator object which is the result of
 * running each of its own enumerable properties through iteratee, with each invocation potentially mutating
 * the accumulator object. The iteratee is bound to thisArg and invoked with four arguments: (accumulator,
 * value, key, object). Iteratee functions may exit iteration early by explicitly returning false.
 * 
 * @see _.transform
 * @see _.transform
 * @see _.transform
 * @template T, TResult
 * @param {!Array<T>|!_.Dictionary<T>} object The object to iterate over.
 * @param {function(!Array<TResult>, T, number, !Array<T>): void|function(!_.Dictionary<TResult>, T, number, !Array<T>): void|function(!_.Dictionary<TResult>, T, string, !_.Dictionary<T>): void|function(!Array<TResult>, T, string, !_.Dictionary<T>): void=} iteratee The function invoked per iteration.
 * @param {!Array<TResult>|!_.Dictionary<TResult>=} accumulator The custom accumulator value.
 * @return {!Array<TResult>|!_.Dictionary<TResult>} Returns the accumulated value.
 */
_.LoDashStatic.prototype.transform = function(object, iteratee, accumulator) {};

/**
 * @see _.transform
 * @see _.transform
 * @template TResult
 * @param {function(!Array<TResult>, T, number, !Array<T>): void|function(!_.Dictionary<TResult>, T, number, !Array<T>): void=} iteratee
 * @param {!Array<TResult>|!_.Dictionary<TResult>=} accumulator
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<TResult>>}
 */
_.LoDashImplicitArrayWrapper.prototype.transform = function(iteratee, accumulator) {};

/**
 * @see _.transform
 * @see _.transform
 * @template T, TResult
 * @param {function(!_.Dictionary<TResult>, T, string, !_.Dictionary<T>): void|function(!Array<TResult>, T, string, !_.Dictionary<T>): void=} iteratee
 * @param {!_.Dictionary<TResult>|!Array<TResult>=} accumulator
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<TResult>>|!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.transform = function(iteratee, accumulator) {};

/**
 * Removes the property at path of object.
 * 
 * Note: This method mutates object.
 * 
 * @template T
 * @param {T} object The object to modify.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to unset.
 * @return {boolean} Returns true if the property is deleted, else false.
 */
_.LoDashStatic.prototype.unset = function(object, path) {};

/**
 * @see _.unset
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {!_.LoDashImplicitWrapper<boolean>}
 */
_.LoDashImplicitObjectWrapper.prototype.unset = function(path) {};

/**
 * @see _.unset
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.unset = function(path) {};

/**
 * This method is like _.set except that accepts updater to produce the value to set. Use _.updateWith to
 * customize path creation. The updater is invoked with one argument: (value).
 * 
 * @see _.update
 * @see _.update
 * @see _.update
 * @template TResult, U, O
 * @param {!Object|O} object The object to modify.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to set.
 * @param {!Function|U} updater The function to produce the updated value.
 * @return {TResult} Returns object.
 */
_.LoDashStatic.prototype.update = function(object, path, updater) {};

/**
 * @see _.update
 * @see _.update
 * @template TResult, U
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?|U} updater
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.update = function(path, updater) {};

/**
 * @see _.update
 * @see _.update
 * @template TResult, U
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?|U} updater
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.update = function(path, updater) {};

/**
 * Creates an array of the own enumerable property values of object.
 * 
 * @see _.values
 * @template T
 * @param {(!_.Dictionary<T>|!_.NumericDictionary<T>|!ArrayLike<T>)|?=} object The object to query.
 * @return {!Array<T>} Returns an array of property values.
 */
_.LoDashStatic.prototype.values = function(object) {};

/**
 * @see _.values
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitStringWrapper.prototype.values = function() {};

/**
 * @see _.values
 * @return {!_.LoDashImplicitArrayWrapper<?>}
 */
_.LoDashImplicitWrapper.prototype.values = function() {};

/**
 * @see _.values
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapperBase.prototype.values = function() {};

/**
 * @see _.values
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.values = function() {};

/**
 * @see _.values
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapper.prototype.values = function() {};

/**
 * @see _.values
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapperBase.prototype.values = function() {};

/**
 * @see _.values
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.values = function() {};

/**
 * Creates an array of the own and inherited enumerable property values of object.
 * 
 * @see _.valuesIn
 * @template T
 * @param {!_.Dictionary<T>|?=} object The object to query.
 * @return {!Array<T>} Returns the array of property values.
 */
_.LoDashStatic.prototype.valuesIn = function(object) {};

/**
 * @see _.valuesIn
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapperBase.prototype.valuesIn = function() {};

/**
 * @see _.valuesIn
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapperBase.prototype.valuesIn = function() {};

/**
 * Converts string to camel case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the camel cased string.
 */
_.LoDashStatic.prototype.camelCase = function(string) {};

/**
 * @see _.camelCase
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.camelCase = function() {};

/**
 * @see _.camelCase
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.camelCase = function() {};

/**
 * Converts the first character of string to upper case and the remaining to lower case.
 * 
 * @param {string=} string The string to capitalize.
 * @return {string} Returns the capitalized string.
 */
_.LoDashStatic.prototype.capitalize = function(string) {};

/**
 * @see _.capitalize
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.capitalize = function() {};

/**
 * @see _.capitalize
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.capitalize = function() {};

/**
 * Deburrs string by converting latin-1 supplementary letters to basic latin letters and removing combining
 * diacritical marks.
 * 
 * @param {string=} string The string to deburr.
 * @return {string} Returns the deburred string.
 */
_.LoDashStatic.prototype.deburr = function(string) {};

/**
 * @see _.deburr
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.deburr = function() {};

/**
 * @see _.deburr
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.deburr = function() {};

/**
 * Checks if string ends with the given target string.
 * 
 * @param {string=} string The string to search.
 * @param {string=} target The string to search for.
 * @param {number=} position The position to search from.
 * @return {boolean} Returns true if string ends with target, else false.
 */
_.LoDashStatic.prototype.endsWith = function(string, target, position) {};

/**
 * @see _.endsWith
 * @param {string=} target
 * @param {number=} position
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.endsWith = function(target, position) {};

/**
 * @see _.endsWith
 * @param {string=} target
 * @param {number=} position
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.endsWith = function(target, position) {};

/**
 * Converts the characters "&", "<", ">", '"', "'", and "`" in string to their corresponding HTML entities.
 * 
 * Note: No other characters are escaped. To escape additional characters use a third-party library like he.
 * 
 * hough the ">" character is escaped for symmetry, characters like ">" and "/" don’t need escaping in HTML
 * and have no special meaning unless they're part of a tag or unquoted attribute value. See Mathias Bynens’s
 * article (under "semi-related fun fact") for more details.
 * 
 * Backticks are escaped because in IE < 9, they can break out of attribute values or HTML comments. See #59,
 * #102, #108, and #133 of the HTML5 Security Cheatsheet for more details.
 * 
 * When working with HTML you should always quote attribute values to reduce XSS vectors.
 * 
 * @param {string=} string The string to escape.
 * @return {string} Returns the escaped string.
 */
_.LoDashStatic.prototype.escape = function(string) {};

/**
 * @see _.escape
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.escape = function() {};

/**
 * @see _.escape
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.escape = function() {};

/**
 * Escapes the RegExp special characters "^", "$", "\", ".", "*", "+", "?", "(", ")", "[", "]",
 * "{", "}", and "|" in string.
 * 
 * @param {string=} string The string to escape.
 * @return {string} Returns the escaped string.
 */
_.LoDashStatic.prototype.escapeRegExp = function(string) {};

/**
 * @see _.escapeRegExp
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.escapeRegExp = function() {};

/**
 * @see _.escapeRegExp
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.escapeRegExp = function() {};

/**
 * Converts string to kebab case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the kebab cased string.
 */
_.LoDashStatic.prototype.kebabCase = function(string) {};

/**
 * @see _.kebabCase
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.kebabCase = function() {};

/**
 * @see _.kebabCase
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.kebabCase = function() {};

/**
 * Converts `string`, as space separated words, to lower case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the lower cased string.
 */
_.LoDashStatic.prototype.lowerCase = function(string) {};

/**
 * @see _.lowerCase
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.lowerCase = function() {};

/**
 * @see _.lowerCase
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.lowerCase = function() {};

/**
 * Converts the first character of `string` to lower case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the converted string.
 */
_.LoDashStatic.prototype.lowerFirst = function(string) {};

/**
 * @see _.lowerFirst
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.lowerFirst = function() {};

/**
 * @see _.lowerFirst
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.lowerFirst = function() {};

/**
 * Pads string on the left and right sides if it’s shorter than length. Padding characters are truncated if
 * they can’t be evenly divided by length.
 * 
 * @param {string=} string The string to pad.
 * @param {number=} length The padding length.
 * @param {string=} chars The string used as padding.
 * @return {string} Returns the padded string.
 */
_.LoDashStatic.prototype.pad = function(string, length, chars) {};

/**
 * @see _.pad
 * @param {number=} length
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.pad = function(length, chars) {};

/**
 * @see _.pad
 * @param {number=} length
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.pad = function(length, chars) {};

/**
 * Pads string on the right side if it’s shorter than length. Padding characters are truncated if they exceed
 * length.
 * 
 * @param {string=} string The string to pad.
 * @param {number=} length The padding length.
 * @param {string=} chars The string used as padding.
 * @return {string} Returns the padded string.
 */
_.LoDashStatic.prototype.padEnd = function(string, length, chars) {};

/**
 * @see _.padEnd
 * @param {number=} length
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.padEnd = function(length, chars) {};

/**
 * @see _.padEnd
 * @param {number=} length
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.padEnd = function(length, chars) {};

/**
 * Pads string on the left side if it’s shorter than length. Padding characters are truncated if they exceed
 * length.
 * 
 * @param {string=} string The string to pad.
 * @param {number=} length The padding length.
 * @param {string=} chars The string used as padding.
 * @return {string} Returns the padded string.
 */
_.LoDashStatic.prototype.padStart = function(string, length, chars) {};

/**
 * @see _.padStart
 * @param {number=} length
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.padStart = function(length, chars) {};

/**
 * @see _.padStart
 * @param {number=} length
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.padStart = function(length, chars) {};

/**
 * Converts string to an integer of the specified radix. If radix is undefined or 0, a radix of 10 is used
 * unless value is a hexadecimal, in which case a radix of 16 is used.
 * 
 * Note: This method aligns with the ES5 implementation of parseInt.
 * 
 * @param {string} string The string to convert.
 * @param {number=} radix The radix to interpret value by.
 * @return {number} Returns the converted integer.
 */
_.LoDashStatic.prototype.parseInt = function(string, radix) {};

/**
 * @see _.parseInt
 * @param {number=} radix
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.parseInt = function(radix) {};

/**
 * @see _.parseInt
 * @param {number=} radix
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.parseInt = function(radix) {};

/**
 * Repeats the given string n times.
 * 
 * @param {string=} string The string to repeat.
 * @param {number=} n The number of times to repeat the string.
 * @return {string} Returns the repeated string.
 */
_.LoDashStatic.prototype.repeat = function(string, n) {};

/**
 * @see _.repeat
 * @param {number=} n
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.repeat = function(n) {};

/**
 * @see _.repeat
 * @param {number=} n
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.repeat = function(n) {};

/**
 * Replaces matches for pattern in string with replacement.
 * 
 * Note: This method is based on String#replace.
 * 
 * @see _.replace
 * @param {string|(string|!RegExp)=} string_or_pattern
 * @param {(string|!RegExp)|(string|!Function)=} pattern_or_replacement
 * @param {(string|!Function)=} replacement
 * @return {string} Returns the modified string.
 */
_.LoDashStatic.prototype.replace = function(string_or_pattern, pattern_or_replacement, replacement) {};

/**
 * @see _.replace
 * @see _.replace
 * @param {(string|!RegExp)|(string|!Function)=} pattern_or_replacement
 * @param {(string|!Function)=} replacement
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.replace = function(pattern_or_replacement, replacement) {};

/**
 * @see _.replace
 * @see _.replace
 * @param {(string|!RegExp)|(string|!Function)=} pattern_or_replacement
 * @param {(string|!Function)=} replacement
 * @return {string}
 */
_.LoDashImplicitObjectWrapper.prototype.replace = function(pattern_or_replacement, replacement) {};

/**
 * @see _.replace
 * @see _.replace
 * @param {(string|!RegExp)|(string|!Function)=} pattern_or_replacement
 * @param {(string|!Function)=} replacement
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.replace = function(pattern_or_replacement, replacement) {};

/**
 * @see _.replace
 * @see _.replace
 * @param {(string|!RegExp)|(string|!Function)=} pattern_or_replacement
 * @param {(string|!Function)=} replacement
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.replace = function(pattern_or_replacement, replacement) {};

/**
 * Converts string to snake case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the snake cased string.
 */
_.LoDashStatic.prototype.snakeCase = function(string) {};

/**
 * @see _.snakeCase
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.snakeCase = function() {};

/**
 * @see _.snakeCase
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.snakeCase = function() {};

/**
 * Splits string by separator.
 * 
 * Note: This method is based on String#split.
 * 
 * @param {string} string
 * @param {(string|!RegExp)=} separator
 * @param {number=} limit
 * @return {!Array<string>} Returns the new array of string segments.
 */
_.LoDashStatic.prototype.split = function(string, separator, limit) {};

/**
 * @see _.split
 * @param {(string|!RegExp)=} separator
 * @param {number=} limit
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.split = function(separator, limit) {};

/**
 * @see _.split
 * @param {(string|!RegExp)=} separator
 * @param {number=} limit
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.split = function(separator, limit) {};

/**
 * Converts string to start case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the start cased string.
 */
_.LoDashStatic.prototype.startCase = function(string) {};

/**
 * @see _.startCase
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.startCase = function() {};

/**
 * @see _.startCase
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.startCase = function() {};

/**
 * Checks if string starts with the given target string.
 * 
 * @param {string=} string The string to search.
 * @param {string=} target The string to search for.
 * @param {number=} position The position to search from.
 * @return {boolean} Returns true if string starts with target, else false.
 */
_.LoDashStatic.prototype.startsWith = function(string, target, position) {};

/**
 * @see _.startsWith
 * @param {string=} target
 * @param {number=} position
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.startsWith = function(target, position) {};

/**
 * @see _.startsWith
 * @param {string=} target
 * @param {number=} position
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.startsWith = function(target, position) {};
/**
 * @extends {_.TemplateSettings}
 * @record
 * @struct
 */
_.TemplateOptions = function() {};
 /** @type {string} */
_.TemplateOptions.prototype.sourceURL;
/**
 * @record
 * @struct
 */
_.TemplateExecutor = function() {};

/* TODO: CallSignature: _ */
 /** @type {string} */
_.TemplateExecutor.prototype.source;

/**
 * Creates a compiled template function that can interpolate data properties in "interpolate" delimiters,
 * HTML-escape interpolated data properties in "escape" delimiters, and execute JavaScript in "evaluate"
 * delimiters. Data properties may be accessed as free variables in the template. If a setting object is
 * provided it takes precedence over _.templateSettings values.
 * 
 * Note: In the development build _.template utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) for easier
 * debugging.
 * 
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 * 
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 * 
 * @param {string} string The template string.
 * @param {!_.TemplateOptions=} options The options object.
 * @return {!_.TemplateExecutor} Returns the compiled template function.
 */
_.LoDashStatic.prototype.template = function(string, options) {};

/**
 * @see _.template
 * @param {!_.TemplateOptions=} options
 * @return {!_.TemplateExecutor}
 */
_.LoDashImplicitWrapper.prototype.template = function(options) {};

/**
 * @see _.template
 * @param {!_.TemplateOptions=} options
 * @return {!_.LoDashExplicitObjectWrapper<!_.TemplateExecutor>}
 */
_.LoDashExplicitWrapper.prototype.template = function(options) {};

/**
 * Converts `string`, as a whole, to lower case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the lower cased string.
 */
_.LoDashStatic.prototype.toLower = function(string) {};

/**
 * @see _.toLower
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.toLower = function() {};

/**
 * @see _.toLower
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.toLower = function() {};

/**
 * Converts `string`, as a whole, to upper case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the upper cased string.
 */
_.LoDashStatic.prototype.toUpper = function(string) {};

/**
 * @see _.toUpper
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.toUpper = function() {};

/**
 * @see _.toUpper
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.toUpper = function() {};

/**
 * Removes leading and trailing whitespace or specified characters from string.
 * 
 * @param {string=} string The string to trim.
 * @param {string=} chars The characters to trim.
 * @return {string} Returns the trimmed string.
 */
_.LoDashStatic.prototype.trim = function(string, chars) {};

/**
 * @see _.trim
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.trim = function(chars) {};

/**
 * @see _.trim
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.trim = function(chars) {};

/**
 * Removes trailing whitespace or specified characters from string.
 * 
 * @param {string=} string The string to trim.
 * @param {string=} chars The characters to trim.
 * @return {string} Returns the trimmed string.
 */
_.LoDashStatic.prototype.trimEnd = function(string, chars) {};

/**
 * @see _.trimEnd
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.trimEnd = function(chars) {};

/**
 * @see _.trimEnd
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.trimEnd = function(chars) {};

/**
 * Removes leading whitespace or specified characters from string.
 * 
 * @param {string=} string The string to trim.
 * @param {string=} chars The characters to trim.
 * @return {string} Returns the trimmed string.
 */
_.LoDashStatic.prototype.trimStart = function(string, chars) {};

/**
 * @see _.trimStart
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.trimStart = function(chars) {};

/**
 * @see _.trimStart
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.trimStart = function(chars) {};
/**
 * @record
 * @struct
 */
_.TruncateOptions = function() {};
 /** @type {number} */
_.TruncateOptions.prototype.length;
 /** @type {string} */
_.TruncateOptions.prototype.omission;
 /** @type {(string|!RegExp)} */
_.TruncateOptions.prototype.separator;

/**
 * Truncates string if it’s longer than the given maximum string length. The last characters of the truncated
 * string are replaced with the omission string which defaults to "…".
 * 
 * @param {string=} string The string to truncate.
 * @param {!_.TruncateOptions=} options The options object or maximum string length.
 * @return {string} Returns the truncated string.
 */
_.LoDashStatic.prototype.truncate = function(string, options) {};

/**
 * @see _.truncate
 * @param {!_.TruncateOptions=} options
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.truncate = function(options) {};

/**
 * @see _.truncate
 * @param {!_.TruncateOptions=} options
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.truncate = function(options) {};

/**
 * The inverse of _.escape; this method converts the HTML entities &amp;, &lt;, &gt;, &quot;, &#39;, and &#96;
 * in string to their corresponding characters.
 * 
 * Note: No other HTML entities are unescaped. To unescape additional HTML entities use a third-party library
 * like he.
 * 
 * @param {string=} string The string to unescape.
 * @return {string} Returns the unescaped string.
 */
_.LoDashStatic.prototype.unescape = function(string) {};

/**
 * @see _.unescape
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.unescape = function() {};

/**
 * @see _.unescape
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.unescape = function() {};

/**
 * Converts `string`, as space separated words, to upper case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the upper cased string.
 */
_.LoDashStatic.prototype.upperCase = function(string) {};

/**
 * @see _.upperCase
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.upperCase = function() {};

/**
 * @see _.upperCase
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.upperCase = function() {};

/**
 * Converts the first character of `string` to upper case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the converted string.
 */
_.LoDashStatic.prototype.upperFirst = function(string) {};

/**
 * @see _.upperFirst
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.upperFirst = function() {};

/**
 * @see _.upperFirst
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.upperFirst = function() {};

/**
 * Splits `string` into an array of its words.
 * 
 * @param {string=} string The string to inspect.
 * @param {(string|!RegExp)=} pattern The pattern to match words.
 * @return {!Array<string>} Returns the words of `string`.
 */
_.LoDashStatic.prototype.words = function(string, pattern) {};

/**
 * @see _.words
 * @param {(string|!RegExp)=} pattern
 * @return {!Array<string>}
 */
_.LoDashImplicitWrapper.prototype.words = function(pattern) {};

/**
 * @see _.words
 * @param {(string|!RegExp)=} pattern
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.words = function(pattern) {};

/**
 * Attempts to invoke func, returning either the result or the caught error object. Any additional arguments
 * are provided to func when it’s invoked.
 * 
 * @template TResult
 * @param {function(!Array<?>): TResult} func The function to attempt.
 * @param {...?} args
 * @return {(!Error|TResult)} Returns the func result or error object.
 */
_.LoDashStatic.prototype.attempt = function(func, args) {};

/**
 * @see _.attempt
 * @template TResult
 * @param {...?} args
 * @return {(!Error|TResult)}
 */
_.LoDashImplicitObjectWrapper.prototype.attempt = function(args) {};

/**
 * @see _.attempt
 * @template TResult
 * @param {...?} args
 * @return {!_.LoDashExplicitObjectWrapper<(!Error|TResult)>}
 */
_.LoDashExplicitObjectWrapper.prototype.attempt = function(args) {};

/**
 * Creates a function that returns value.
 * 
 * @template T
 * @param {T} value The value to return from the new function.
 * @return {function(): T} Returns the new function.
 */
_.LoDashStatic.prototype.constant = function(value) {};

/**
 * @see _.constant
 * @template TResult
 * @return {!_.LoDashImplicitObjectWrapper<function(): TResult>}
 */
_.LoDashImplicitWrapperBase.prototype.constant = function() {};

/**
 * @see _.constant
 * @template TResult
 * @return {!_.LoDashExplicitObjectWrapper<function(): TResult>}
 */
_.LoDashExplicitWrapperBase.prototype.constant = function() {};

/**
 * Checks `value` to determine whether a default value should be returned in
 * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
 * or `undefined`.
 * 
 * @template T
 * @param {T} value The value to check.
 * @param {T} defaultValue The default value.
 * @return {T} Returns the resolved value.
 */
_.LoDashStatic.prototype.defaultTo = function(value, defaultValue) {};

/**
 * @see _.defaultTo
 * @template TResult
 * @param {TResult} value
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitWrapperBase.prototype.defaultTo = function(value) {};

/**
 * @see _.defaultTo
 * @template TResult
 * @param {TResult} value
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitWrapperBase.prototype.defaultTo = function(value) {};

/**
 * This method returns the first argument provided to it.
 * 
 * @see _.identity
 * @template T
 * @param {T=} value Any value.
 * @return {T|undefined} Returns value.
 */
_.LoDashStatic.prototype.identity = function(value) {};

/**
 * @see _.identity
 * @return {T}
 */
_.LoDashImplicitWrapper.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {TArray}
 */
_.LoDashImplicitArrayWrapperBase.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {TObject}
 */
_.LoDashImplicitObjectWrapperBase.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {!_.LoDashExplicitWrapper}
 */
_.LoDashExplicitWrapper.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {TWrapper}
 */
_.LoDashExplicitArrayWrapperBase.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {TWrapper}
 */
_.LoDashExplicitObjectWrapperBase.prototype.identity = function() {};

/**
 * Creates a function that invokes `func` with the arguments of the created
 * function. If `func` is a property name the created callback returns the
 * property value for a given element. If `func` is an object the created
 * callback returns `true` for elements that contain the equivalent object properties, otherwise it returns `false`.
 * 
 * \@memberOf _
 * \@category Util
 * \@example 
 * 
 * var users = [
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 }
 * ];
 * 
 * // create custom iteratee shorthands
 * _.iteratee = _.wrap(_.iteratee, function(callback, func) {
 *   var p = /^(\S+)\s*([<>])\s*(\S+)$/.exec(func);
 *   return !p ? callback(func) : function(object) {
 *     return (p[2] == '>' ? object[p[1]] > p[3] : object[p[1]] < p[3]);
 *   };
 * });
 * 
 * _.filter(users, 'age > 36');
 * // => [{ 'user': 'fred', 'age': 40 }]
 * @see _.iteratee
 * @see _.iteratee
 * @see _.iteratee
 * @template TResult
 * @param {!Function|string|!Object=} func
 * @return {function(!Array<?>): TResult|function(?): TResult|function(?): boolean|function(TResult): TResult}
 */
_.LoDashStatic.prototype.iteratee = function(func) {};

/**
 * @see _.iteratee
 * @template TResult
 * @return {!_.LoDashImplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashImplicitWrapper.prototype.iteratee = function() {};

/**
 * @see _.iteratee
 * @see _.iteratee
 * @template TResult
 * @return {!_.LoDashImplicitObjectWrapper<function(?): boolean>|!_.LoDashImplicitObjectWrapper<function(!Array<?>): TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.iteratee = function() {};

/**
 * @see _.iteratee
 * @template TResult
 * @return {!_.LoDashExplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashExplicitWrapper.prototype.iteratee = function() {};

/**
 * @see _.iteratee
 * @see _.iteratee
 * @template TResult
 * @return {!_.LoDashExplicitObjectWrapper<function(?): boolean>|!_.LoDashExplicitObjectWrapper<function(!Array<?>): TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.iteratee = function() {};

/**
 * Creates a function that performs a deep comparison between a given object and source, returning true if the
 * given object has equivalent property values, else false.
 * 
 * Note: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and
 * strings. Objects are compared by their own, not inherited, enumerable properties. For comparing a single own
 * or inherited property value see _.matchesProperty.
 * 
 * @see _.matches
 * @template T, V
 * @param {T} source The object of property values to match.
 * @return {function(?): boolean|function(V): boolean} Returns the new function.
 */
_.LoDashStatic.prototype.matches = function(source) {};

/**
 * @see _.matches
 * @template V
 * @return {!_.LoDashImplicitObjectWrapper<function(V): boolean>}
 */
_.LoDashImplicitWrapperBase.prototype.matches = function() {};

/**
 * @see _.matches
 * @template V
 * @return {!_.LoDashExplicitObjectWrapper<function(V): boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.matches = function() {};

/**
 * Creates a function that compares the property value of path on a given object to value.
 * 
 * Note: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and
 * strings. Objects are compared by their own, not inherited, enumerable properties.
 * 
 * @see _.matchesProperty
 * @template T, V
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to get.
 * @param {T} srcValue The value to match.
 * @return {function(?): boolean|function(V): boolean} Returns the new function.
 */
_.LoDashStatic.prototype.matchesProperty = function(path, srcValue) {};

/**
 * @see _.matchesProperty
 * @see _.matchesProperty
 * @template SrcValue, Value
 * @param {SrcValue} srcValue
 * @return {!_.LoDashImplicitObjectWrapper<function(?): boolean>|!_.LoDashImplicitObjectWrapper<function(Value): boolean>}
 */
_.LoDashImplicitWrapperBase.prototype.matchesProperty = function(srcValue) {};

/**
 * @see _.matchesProperty
 * @see _.matchesProperty
 * @template SrcValue, Value
 * @param {SrcValue} srcValue
 * @return {!_.LoDashExplicitObjectWrapper<function(?): boolean>|!_.LoDashExplicitObjectWrapper<function(Value): boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.matchesProperty = function(srcValue) {};

/**
 * Creates a function that invokes the method at path on a given object. Any additional arguments are provided
 * to the invoked method.
 * 
 * @see _.method
 * @template TObject, TResult
 * @param {(string|!Array<!_.StringRepresentable>)} path The path of the method to invoke.
 * @param {...?} args The arguments to invoke the method with.
 * @return {function(TObject): TResult|function(?): TResult} Returns the new function.
 */
_.LoDashStatic.prototype.method = function(path, args) {};

/**
 * @see _.method
 * @see _.method
 * @template TObject, TResult
 * @param {...?} args
 * @return {!_.LoDashImplicitObjectWrapper<function(TObject): TResult>|!_.LoDashImplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashImplicitWrapper.prototype.method = function(args) {};

/**
 * @see _.method
 * @see _.method
 * @template TObject, TResult
 * @param {...?} args
 * @return {!_.LoDashImplicitObjectWrapper<function(TObject): TResult>|!_.LoDashImplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.method = function(args) {};

/**
 * @see _.method
 * @see _.method
 * @template TObject, TResult
 * @param {...?} args
 * @return {!_.LoDashExplicitObjectWrapper<function(TObject): TResult>|!_.LoDashExplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashExplicitWrapper.prototype.method = function(args) {};

/**
 * @see _.method
 * @see _.method
 * @template TObject, TResult
 * @param {...?} args
 * @return {!_.LoDashExplicitObjectWrapper<function(TObject): TResult>|!_.LoDashExplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashExplicitArrayWrapper.prototype.method = function(args) {};

/**
 * The opposite of _.method; this method creates a function that invokes the method at a given path on object.
 * Any additional arguments are provided to the invoked method.
 * 
 * @see _.methodOf
 * @template TObject, TResult
 * @param {TObject|!Object} object The object to query.
 * @param {...?} args The arguments to invoke the method with.
 * @return {function((!_.StringRepresentable|!Array<!_.StringRepresentable>)): TResult} Returns the new function.
 */
_.LoDashStatic.prototype.methodOf = function(object, args) {};

/**
 * @see _.methodOf
 * @template TResult
 * @param {...?} args
 * @return {!_.LoDashImplicitObjectWrapper<function((!_.StringRepresentable|!Array<!_.StringRepresentable>)): TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.methodOf = function(args) {};

/**
 * @see _.methodOf
 * @template TResult
 * @param {...?} args
 * @return {!_.LoDashExplicitObjectWrapper<function((!_.StringRepresentable|!Array<!_.StringRepresentable>)): TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.methodOf = function(args) {};
/**
 * @record
 * @struct
 */
_.MixinOptions = function() {};
 /** @type {boolean} */
_.MixinOptions.prototype.chain;

/**
 * Adds all own enumerable function properties of a source object to the destination object. If object is a
 * function then methods are added to its prototype as well.
 * 
 * Note: Use _.runInContext to create a pristine lodash function to avoid conflicts caused by modifying
 * the original.
 * 
 * @see _.mixin
 * @template TResult, TObject
 * @param {TObject|!_.Dictionary<!Function>} object_or_source The destination object.
 * @param {!_.Dictionary<!Function>|!_.MixinOptions=} source_or_options The object of functions to add.
 * @param {!_.MixinOptions=} options The options object.
 * @return {TResult} Returns object.
 */
_.LoDashStatic.prototype.mixin = function(object_or_source, source_or_options, options) {};

/**
 * @see _.mixin
 * @see _.mixin
 * @template TResult
 * @param {!_.Dictionary<!Function>|!_.MixinOptions=} source_or_options
 * @param {!_.MixinOptions=} options
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.mixin = function(source_or_options, options) {};

/**
 * @see _.mixin
 * @see _.mixin
 * @template TResult
 * @param {!_.Dictionary<!Function>|!_.MixinOptions=} source_or_options
 * @param {!_.MixinOptions=} options
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.mixin = function(source_or_options, options) {};

/**
 * Reverts the _ variable to its previous value and returns a reference to the lodash function.
 * 
 * @return {!_.LoDashStatic} Returns the lodash function.
 */
_.LoDashStatic.prototype.noConflict = function() {};

/**
 * @see _.noConflict
 * @return {!_.LoDashStatic}
 */
_.LoDashImplicitWrapperBase.prototype.noConflict = function() {};

/**
 * @see _.noConflict
 * @return {!_.LoDashExplicitObjectWrapper<!_.LoDashStatic>}
 */
_.LoDashExplicitWrapperBase.prototype.noConflict = function() {};

/**
 * A no-operation function that returns undefined regardless of the arguments it receives.
 * 
 * @param {...?} args
 * @return {void} undefined
 */
_.LoDashStatic.prototype.noop = function(args) {};

/**
 * @see _.noop
 * @param {...?} args
 * @return {void}
 */
_.LoDashImplicitWrapperBase.prototype.noop = function(args) {};

/**
 * @see _.noop
 * @param {...?} args
 * @return {!_.LoDashExplicitWrapper<void>}
 */
_.LoDashExplicitWrapperBase.prototype.noop = function(args) {};

/**
 * Creates a function that returns its nth argument.
 * 
 * @template TResult
 * @param {number=} n The index of the argument to return.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.nthArg = function(n) {};

/**
 * @see _.nthArg
 * @template TResult
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitWrapper.prototype.nthArg = function() {};

/**
 * @see _.nthArg
 * @template TResult
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitWrapper.prototype.nthArg = function() {};

/**
 * Creates a function that invokes iteratees with the arguments provided to the created function and returns
 * their results.
 * 
 * @template TResult
 * @param {...(!Function|!Array<!Function>)} iteratees The iteratees to invoke.
 * @return {function(!Array<?>): !Array<TResult>} Returns the new function.
 */
_.LoDashStatic.prototype.over = function(iteratees) {};

/**
 * @see _.over
 * @template TResult
 * @param {...(!Function|!Array<!Function>)} iteratees
 * @return {!_.LoDashImplicitObjectWrapper<function(!Array<?>): !Array<TResult>>}
 */
_.LoDashImplicitArrayWrapper.prototype.over = function(iteratees) {};

/**
 * @see _.over
 * @template TResult
 * @param {...(!Function|!Array<!Function>)} iteratees
 * @return {!_.LoDashImplicitObjectWrapper<function(!Array<?>): !Array<TResult>>}
 */
_.LoDashImplicitObjectWrapper.prototype.over = function(iteratees) {};

/**
 * @see _.over
 * @template TResult
 * @param {...(!Function|!Array<!Function>)} iteratees
 * @return {!_.LoDashExplicitObjectWrapper<function(!Array<?>): !Array<TResult>>}
 */
_.LoDashExplicitArrayWrapper.prototype.over = function(iteratees) {};

/**
 * @see _.over
 * @template TResult
 * @param {...(!Function|!Array<!Function>)} iteratees
 * @return {!_.LoDashExplicitObjectWrapper<function(!Array<?>): !Array<TResult>>}
 */
_.LoDashExplicitObjectWrapper.prototype.over = function(iteratees) {};

/**
 * Creates a function that checks if all of the predicates return truthy when invoked with the arguments
 * provided to the created function.
 * 
 * @param {...(!Function|!Array<!Function>)} predicates The predicates to check.
 * @return {function(!Array<?>): boolean} Returns the new function.
 */
_.LoDashStatic.prototype.overEvery = function(predicates) {};

/**
 * @see _.overEvery
 * @param {...(!Function|!Array<!Function>)} predicates
 * @return {!_.LoDashImplicitObjectWrapper<function(!Array<?>): boolean>}
 */
_.LoDashImplicitArrayWrapper.prototype.overEvery = function(predicates) {};

/**
 * @see _.overEvery
 * @param {...(!Function|!Array<!Function>)} predicates
 * @return {!_.LoDashImplicitObjectWrapper<function(!Array<?>): boolean>}
 */
_.LoDashImplicitObjectWrapper.prototype.overEvery = function(predicates) {};

/**
 * @see _.overEvery
 * @param {...(!Function|!Array<!Function>)} predicates
 * @return {!_.LoDashExplicitObjectWrapper<function(!Array<?>): boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.overEvery = function(predicates) {};

/**
 * @see _.overEvery
 * @param {...(!Function|!Array<!Function>)} predicates
 * @return {!_.LoDashExplicitObjectWrapper<function(!Array<?>): boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.overEvery = function(predicates) {};

/**
 * Creates a function that checks if any of the predicates return truthy when invoked with the arguments
 * provided to the created function.
 * 
 * @param {...(!Function|!Array<!Function>)} predicates The predicates to check.
 * @return {function(!Array<?>): boolean} Returns the new function.
 */
_.LoDashStatic.prototype.overSome = function(predicates) {};

/**
 * @see _.overSome
 * @param {...(!Function|!Array<!Function>)} predicates
 * @return {!_.LoDashImplicitObjectWrapper<function(!Array<?>): boolean>}
 */
_.LoDashImplicitArrayWrapper.prototype.overSome = function(predicates) {};

/**
 * @see _.overSome
 * @param {...(!Function|!Array<!Function>)} predicates
 * @return {!_.LoDashImplicitObjectWrapper<function(!Array<?>): boolean>}
 */
_.LoDashImplicitObjectWrapper.prototype.overSome = function(predicates) {};

/**
 * @see _.overSome
 * @param {...(!Function|!Array<!Function>)} predicates
 * @return {!_.LoDashExplicitObjectWrapper<function(!Array<?>): boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.overSome = function(predicates) {};

/**
 * @see _.overSome
 * @param {...(!Function|!Array<!Function>)} predicates
 * @return {!_.LoDashExplicitObjectWrapper<function(!Array<?>): boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.overSome = function(predicates) {};

/**
 * Creates a function that returns the property value at path on a given object.
 * 
 * @template TObj, TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to get.
 * @return {function(TObj): TResult} Returns the new function.
 */
_.LoDashStatic.prototype.property = function(path) {};

/**
 * @see _.property
 * @template TObj, TResult
 * @return {!_.LoDashImplicitObjectWrapper<function(TObj): TResult>}
 */
_.LoDashImplicitWrapper.prototype.property = function() {};

/**
 * @see _.property
 * @template TObj, TResult
 * @return {!_.LoDashImplicitObjectWrapper<function(TObj): TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.property = function() {};

/**
 * @see _.property
 * @template TObj, TResult
 * @return {!_.LoDashExplicitObjectWrapper<function(TObj): TResult>}
 */
_.LoDashExplicitWrapper.prototype.property = function() {};

/**
 * @see _.property
 * @template TObj, TResult
 * @return {!_.LoDashExplicitObjectWrapper<function(TObj): TResult>}
 */
_.LoDashExplicitArrayWrapper.prototype.property = function() {};

/**
 * The opposite of _.property; this method creates a function that returns the property value at a given path
 * on object.
 * 
 * @template T
 * @param {T} object The object to query.
 * @return {function((string|!Array<string>)): ?} Returns the new function.
 */
_.LoDashStatic.prototype.propertyOf = function(object) {};

/**
 * @see _.propertyOf
 * @return {!_.LoDashImplicitObjectWrapper<function((string|!Array<string>)): ?>}
 */
_.LoDashImplicitObjectWrapper.prototype.propertyOf = function() {};

/**
 * @see _.propertyOf
 * @return {!_.LoDashExplicitObjectWrapper<function((string|!Array<string>)): ?>}
 */
_.LoDashExplicitObjectWrapper.prototype.propertyOf = function() {};

/**
 * Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end.
 * If end is not specified it’s set to start with start then set to 0. If end is less than start a zero-length
 * range is created unless a negative step is specified.
 * 
 * @see _.range
 * @param {number} start_or_end The start of the range.
 * @param {number=} end_or_step The end of the range.
 * @param {number=} step The value to increment or decrement by.
 * @return {!Array<number>} Returns a new range array.
 */
_.LoDashStatic.prototype.range = function(start_or_end, end_or_step, step) {};

/**
 * @see _.range
 * @param {number=} end
 * @param {number=} step
 * @return {!_.LoDashImplicitArrayWrapper<number>}
 */
_.LoDashImplicitWrapper.prototype.range = function(end, step) {};

/**
 * @see _.range
 * @param {number=} end
 * @param {number=} step
 * @return {!_.LoDashExplicitArrayWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.range = function(end, step) {};

/**
 * This method is like `_.range` except that it populates values in
 * descending order.
 * 
 * \@memberOf _
 * \@category Util
 * \@example 
 * 
 * _.rangeRight(4);
 * // => [3, 2, 1, 0]
 * 
 * _.rangeRight(-4);
 * // => [-3, -2, -1, 0]
 * 
 * _.rangeRight(1, 5);
 * // => [4, 3, 2, 1]
 * 
 * _.rangeRight(0, 20, 5);
 * // => [15, 10, 5, 0]
 * 
 * _.rangeRight(0, -4, -1);
 * // => [-3, -2, -1, 0]
 * 
 * _.rangeRight(1, 4, 0);
 * // => [1, 1, 1]
 * 
 * _.rangeRight(0);
 * // => []
 * @see _.rangeRight
 * @param {number} start_or_end
 * @param {number=} end_or_step
 * @param {number=} step
 * @return {!Array<number>}
 */
_.LoDashStatic.prototype.rangeRight = function(start_or_end, end_or_step, step) {};

/**
 * @see _.rangeRight
 * @param {number=} end
 * @param {number=} step
 * @return {!_.LoDashImplicitArrayWrapper<number>}
 */
_.LoDashImplicitWrapper.prototype.rangeRight = function(end, step) {};

/**
 * @see _.rangeRight
 * @param {number=} end
 * @param {number=} step
 * @return {!_.LoDashExplicitArrayWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.rangeRight = function(end, step) {};

/**
 * Create a new pristine lodash function using the given context object.
 * 
 * @param {!Object=} context The context object.
 * @return {!_.LoDashStatic} Returns a new lodash function.
 */
_.LoDashStatic.prototype.runInContext = function(context) {};

/**
 * @see _.runInContext
 * @return {!_.LoDashStatic}
 */
_.LoDashImplicitObjectWrapper.prototype.runInContext = function() {};

/**
 * This method returns a new empty array.
 * 
 * @return {!Array<?>} Returns the new empty array.
 */
_.LoDashStatic.prototype.stubArray = function() {};

/**
 * @see _.stubArray
 * @return {!Array<?>}
 */
_.LoDashImplicitWrapperBase.prototype.stubArray = function() {};

/**
 * @see _.stubArray
 * @return {!_.LoDashExplicitArrayWrapper<?>}
 */
_.LoDashExplicitWrapperBase.prototype.stubArray = function() {};

/**
 * This method returns `false`.
 * 
 * @return {boolean} Returns `false`.
 */
_.LoDashStatic.prototype.stubFalse = function() {};

/**
 * @see _.stubFalse
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.stubFalse = function() {};

/**
 * @see _.stubFalse
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.stubFalse = function() {};

/**
 * This method returns a new empty object.
 * 
 * @return {!Object} Returns the new empty object.
 */
_.LoDashStatic.prototype.stubObject = function() {};

/**
 * @see _.stubObject
 * @return {!Object}
 */
_.LoDashImplicitWrapperBase.prototype.stubObject = function() {};

/**
 * @see _.stubObject
 * @return {!_.LoDashExplicitObjectWrapper<!Object>}
 */
_.LoDashExplicitWrapperBase.prototype.stubObject = function() {};

/**
 * This method returns an empty string.
 * 
 * @return {string} Returns the empty string.
 */
_.LoDashStatic.prototype.stubString = function() {};

/**
 * @see _.stubString
 * @return {string}
 */
_.LoDashImplicitWrapperBase.prototype.stubString = function() {};

/**
 * @see _.stubString
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapperBase.prototype.stubString = function() {};

/**
 * This method returns `true`.
 * 
 * @return {boolean} Returns `true`.
 */
_.LoDashStatic.prototype.stubTrue = function() {};

/**
 * @see _.stubTrue
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.stubTrue = function() {};

/**
 * @see _.stubTrue
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.stubTrue = function() {};

/**
 * Invokes the iteratee function n times, returning an array of the results of each invocation. The iteratee
 * is invoked with one argument; (index).
 * 
 * @see _.times
 * @template TResult
 * @param {number} n The number of times to invoke iteratee.
 * @param {function(number): TResult=} iteratee The function invoked per iteration.
 * @return {!Array<TResult>|!Array<number>} Returns the array of results.
 */
_.LoDashStatic.prototype.times = function(n, iteratee) {};

/**
 * @see _.times
 * @see _.times
 * @template TResult
 * @param {function(number): TResult=} iteratee
 * @return {!Array<TResult>|!Array<number>}
 */
_.LoDashImplicitWrapper.prototype.times = function(iteratee) {};

/**
 * @see _.times
 * @see _.times
 * @template TResult
 * @param {function(number): TResult=} iteratee
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.times = function(iteratee) {};

/**
 * Converts `value` to a property path array.
 * 
 * \@memberOf _
 * \@category Util
 * \@example 
 * 
 * _.toPath('a.b.c');
 * // => ['a', 'b', 'c']
 * 
 * _.toPath('a[0].b.c');
 * // => ['a', '0', 'b', 'c']
 * 
 * var path = ['a', 'b', 'c'],
 *     newPath = _.toPath(path);
 * 
 * console.log(newPath);
 * // => ['a', 'b', 'c']
 * 
 * console.log(path === newPath);
 * // => false
 * @param {?} value
 * @return {!Array<string>}
 */
_.LoDashStatic.prototype.toPath = function(value) {};

/**
 * @see _.toPath
 * @return {!_.LoDashImplicitWrapper<!Array<string>>}
 */
_.LoDashImplicitWrapperBase.prototype.toPath = function() {};

/**
 * @see _.toPath
 * @return {!_.LoDashExplicitWrapper<!Array<string>>}
 */
_.LoDashExplicitWrapperBase.prototype.toPath = function() {};

/**
 * Generates a unique ID. If prefix is provided the ID is appended to it.
 * 
 * @param {string=} prefix The value to prefix the ID with.
 * @return {string} Returns the unique ID.
 */
_.LoDashStatic.prototype.uniqueId = function(prefix) {};

/**
 * @see _.uniqueId
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.uniqueId = function() {};

/**
 * @see _.uniqueId
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.uniqueId = function() {};

/** @typedef {function(T, number, !ArrayLike<T>): TResult} */
_.ListIterator;

/** @typedef {function(T, string, !_.Dictionary<T>): TResult} */
_.DictionaryIterator;

/** @typedef {function(T, number, !_.Dictionary<T>): TResult} */
_.NumericDictionaryIterator;

/** @typedef {function(T, string, ?): TResult} */
_.ObjectIterator;

/** @typedef {function(string, number, string): TResult} */
_.StringIterator;

/** @typedef {function(TResult, T, ?, !Array<T>): void} */
_.MemoVoidIterator;

/** @typedef {function(TResult, T, ?, !Array<T>): TResult} */
_.MemoIterator;

/** @typedef {function(TResult, T, number, !Array<T>): void} */
_.MemoVoidArrayIterator;

/** @typedef {function(TResult, T, string, !_.Dictionary<T>): void} */
_.MemoVoidDictionaryIterator;

/** @typedef {!ArrayLike<T>} */
_.List;
/**
 * @record
 * @struct
 */
_.Dictionary = function() {};

/* TODO: IndexSignature: _ */
/**
 * @record
 * @struct
 */
_.NumericDictionary = function() {};

/* TODO: IndexSignature: _ */
/**
 * @record
 * @struct
 */
_.StringRepresentable = function() {};

/**
 * @return {string}
 */
_.StringRepresentable.prototype.toString = function() {};
/**
 * @record
 * @struct
 */
_.Cancelable = function() {};

/**
 * @return {void}
 */
_.Cancelable.prototype.cancel = function() {};

/**
 * @return {void}
 */
_.Cancelable.prototype.flush = function() {};
