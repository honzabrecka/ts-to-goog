/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/heremaps/index.d.ts:
/** @const */
var H = {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!Element} element {Element} - html element into which the map will be rendered
 * @param {!H.map.layer.Layer} baseLayer {H.map.layer.Layer} - The layer to be used as the base (bottom most) layer.
 * @param {!H.Map.Options=} opt_options {H.Map.Options=} - additional map options
 */
H.Map = function(element, baseLayer, opt_options) {};

/**
 * This method returns the map root html element
 * @return {!Element}
 */
H.Map.prototype.getElement = function() {};

/**
 * This method sets the new center on a map.
 * @param {!H.geo.IPoint} center {H.geo.IPoint} - requested center to be set
 * @param {boolean=} opt_animate {boolean=} - parameter indicates if animated transition should be applied, default is false
 * @return {!H.Map}
 */
H.Map.prototype.setCenter = function(center, opt_animate) {};

/**
 * This method returns currently rendered center of the map.
 * @return {!H.geo.Point}
 */
H.Map.prototype.getCenter = function() {};

/**
 * This method sets the zoom level on the map. Every zoom level represents different scale i.e map at zoom level 2 is twice as large as the map at zoom level 1.
 * @param {number} zoom {number} - requested zoom level
 * @param {boolean=} opt_animate {boolean=} - parameter indicates if animated transition should be applied, default is false
 * @return {!H.Map}
 */
H.Map.prototype.setZoom = function(zoom, opt_animate) {};

/**
 * This method returns currently rendered zoom level.
 * @return {number}
 */
H.Map.prototype.getZoom = function() {};

/**
 * This method changes the map zoom while keeping target screen coordinates specified as x,y at the same place where they were before.
 * @param {number} zoom {number} - new zoom level
 * @param {number} x {number} - map viewport x-axis pixel coordinate
 * @param {number} y {number} - map viewport y-axis pixel coordinate
 * @return {void}
 */
H.Map.prototype.zoomAt = function(zoom, x, y) {};

/**
 * This method sets the bounding rect to be displayed by the map. Maps display the bounding rect in a way that it fits entirely in the current viewport.
 * @param {!H.geo.Rect} boundingRect {H.geo.Rect} - view bound which should be shown on map
 * @param {boolean=} opt_animate {boolean=} - parameter indicates if animated transition should be applied, default is false
 * @return {!H.Map}
 */
H.Map.prototype.setViewBounds = function(boundingRect, opt_animate) {};

/**
 * This method returns bounding rect for the current map view. Returned bounding rect defines entire currently viewable area on the screen.
 * @return {!H.geo.Rect}
 */
H.Map.prototype.getViewBounds = function() {};

/**
 * Calculates the best CameraModel to show the provided bounding rectangle
 * @param {!H.geo.Rect} rect {H.geo.Rect} - The geographical bounding rectangle to use
 * @return {!H.map.ViewModel.CameraData}
 */
H.Map.prototype.getCameraDataForBounds = function(rect) {};

/**
 * This method returns current map viewport.
 * Viewport can be used to modify padding and margin which will reflect the position of the viewport center and the amount of extra data loaded (for margin)
 * @return {!H.map.ViewPort}
 */
H.Map.prototype.getViewPort = function() {};

/**
 * This method returns current view model. View model can be used to modify the current view or camera. H.map.ViewModel
 * @return {!H.map.ViewModel}
 */
H.Map.prototype.getViewModel = function() {};

/**
 * This method returns the map's current layer collection.
 * @return {!H.map.DataModel}
 */
H.Map.prototype.getLayers = function() {};

/**
 * This method returns the imprint object for this map.
 * @return {!H.map.Imprint}
 */
H.Map.prototype.getImprint = function() {};

/**
 * This method captures desired region of the map and objects on it. Result is returned as an HTML5 Canvas element.
 * Origin of coordinate system for capturing is in the top left corner of the viewport.
 * @param {function(!HTMLCanvasElement): void=} callback {function(HTMLCanvasElement=)} - Callback function to call once result of the capturing is ready
 * @param {!Array<!H.util.ICapturable>=} opt_capturables {Array<H.util.ICapturable>=} - Collection of "capturable" element(s) to draw into the resulting canvas
 * @param {number=} opt_x1 {number=} - The X coordinate of the left edge of the capturing rectangle defaults to 0
 * @param {number=} opt_y1 {number=} - The Y coordinate of the top edge of the capturing rectangle defaults to 0
 * @param {number=} opt_x2 {number=} - The X coordinate of the right edge of the capturing rectangle defaults to viewport width
 * @param {number=} opt_y2 {number=} - The Y coordinate of the bottom edge of the capturing rectangle defaults to viewport height
 * @return {void}
 */
H.Map.prototype.capture = function(callback, opt_capturables, opt_x1, opt_y1, opt_x2, opt_y2) {};

/**
 * This method sets the rendering engine type for the map. Rendering engine is responsible for displaying i.e tiles and data on the map.
 * @param {H.Map.EngineType} type {H.Map.EngineType}
 * @return {!H.Map}
 */
H.Map.prototype.setEngineType = function(type) {};

/**
 * To persistently store the content of a map layer for a given area and range of zoom levels.
 * It can be used to enable map rendering when no internet connection is established and also to reduce the download traffic for frequently visited map areas.
 * @param {function(!H.util.Request): void=} opt_onprogress {function(H.util.Request)=} - A callback which is invoked every time when the progress state of the returned store request changes.
 * @param {!H.geo.Rect=} opt_bounds {H.geo.Rect=} - The area to store, default is the current view bounds
 * @param {number=} opt_min {number=} - The minimum zoom level to store, default is the current zoom level
 * @param {number=} opt_max {number=} - The maximum zoom level to store, default is the current zoom level
 * @param {!H.map.layer.BaseTileLayer=} opt_layer {H.map.layer.BaseTileLayer=} - The layer to store, default is the current base layer
 * @return {!H.util.Request}
 */
H.Map.prototype.storeContent = function(opt_onprogress, opt_bounds, opt_min, opt_max, opt_layer) {};

/**
 * To clear the entire stored content
 * @param {function(!H.util.Request): void=} opt_onprogress {function(H.util.Request)=} - A callback which is invoked every time when the progress state of the returned clear request changes
 * @return {!H.util.Request}
 */
H.Map.prototype.clearContent = function(opt_onprogress) {};

/**
 * This method adds a layer to the map.
 * @param {!H.map.layer.Layer} layer {H.map.layer.Layer} - The map layer to be added
 * @param {number=} opt_idx {number=} - index at which the new layer should be inserted
 * @return {!H.Map}
 */
H.Map.prototype.addLayer = function(layer, opt_idx) {};

/**
 * This method removes layer from the map.
 * @param {!H.map.layer.Layer} layer {H.map.layer.Layer} - The map layer to be removed
 * @return {!H.Map}
 */
H.Map.prototype.removeLayer = function(layer) {};

/**
 * This method will set provided layer as base map. The layer will be inserted as the bottom most layer in the map.
 * @param {!H.map.layer.Layer} layer {H.map.layer.Layer} - The layer to use as base map
 * @return {!H.Map}
 */
H.Map.prototype.setBaseLayer = function(layer) {};

/**
 * To get the current base map layer.
 * @return {!H.map.layer.Layer}
 */
H.Map.prototype.getBaseLayer = function() {};

/**
 * Returns the screen coordinates according to the given geographical coordinates. This method returns a screen pixel coordinates for the provided geo point.
 * @param {!H.geo.IPoint} geoPoint {H.geo.IPoint} - point on the map
 * @return {!H.math.Point}
 */
H.Map.prototype.geoToScreen = function(geoPoint) {};

/**
 * Returns the geographical coordinates according to the given screen coordinates.
 * @param {number} x {number} - map viewport x-axis pixel coordinate
 * @param {number} y {number} - map viewport y-axis pixel coordinate
 * @return {!H.geo.Point}
 */
H.Map.prototype.screenToGeo = function(x, y) {};

/**
 * Returns the camera data according to the given screen coordinates. Method converts screen pixel coordinates to correct camera data object
 * @param {number} x {number} - map viewport x-axis pixel coordinate
 * @param {number} y {number} - map viewport y-axis pixel coordinate
 * @return {!H.map.ViewModel.CameraData}
 */
H.Map.prototype.screenToCameraData = function(x, y) {};

/**
 * This method adds an map object to the map. Map object can be a marker or a spatial object like polygon or polyline.
 * @param {!H.map.Object} mapObject {!H.map.Object} - The map object to add
 * @return {!H.map.Object}
 */
H.Map.prototype.addObject = function(mapObject) {};

/**
 * This method removes previously added map object from the map.
 * @param {!H.map.Object} mapObject {!H.map.Object} - The map object to remove
 * @return {!H.map.Object}
 */
H.Map.prototype.removeObject = function(mapObject) {};

/**
 * This method retrieves the list of all objects which have been added to the map.
 * @return {!Array<!H.map.Object>}
 */
H.Map.prototype.getObjects = function() {};

/**
 * This method adds an array of objects or an object group to the map.
 * @param {!Array<!H.map.Object>} mapObjects {Array<!H.map.Object>}
 * @return {!H.Map}
 */
H.Map.prototype.addObjects = function(mapObjects) {};

/**
 * This method removes an array of object or an object group from the map.
 * @param {(!Array<!H.map.Object>|!H.map.Group)} mapObjects {(Array<H.map.Object> | H.map.Group)}
 * @return {!H.Map}
 */
H.Map.prototype.removeObjects = function(mapObjects) {};

/**
 * Returns the top most z-ordered map object found under the specific screen coordinates. Coordinates are viewport pixel coordinates starting from top left corner as (0, 0) point.
 * @param {number} x {number} - map viewport x-axis pixel coordinate
 * @param {number} y {number} - map viewport y-axis pixel coordinate
 * @return {!H.map.Object}
 */
H.Map.prototype.getObjectAt = function(x, y) {};

/**
 * Returns a list of map objects in descending z-order found under the specific screen coordinates. Coordinates are viewport pixel coordinates starting from top left corner as (0, 0) point.
 * @param {number} x {number} - map viewport x-axis pixel coordinate
 * @param {number} y {number} - map viewport y-axis pixel coordinate
 * @return {!Array<!H.map.Object>}
 */
H.Map.prototype.getObjectsAt = function(x, y) {};

/**
 * This method will dispatch event on the event target object
 * @param {(string|!H.util.Event)} evt {(H.util.Event | string)} - event object or event name
 * @return {void}
 */
H.Map.prototype.dispatchEvent = function(evt) {};

/**
 * Removes listeners from this object. Classes that extend EventTarget may need to override this method in order to remove references to DOM Elements and additional listeners.
 * @return {void}
 */
H.Map.prototype.dispose = function() {};

/**
 * This method adds callback which is triggered when the object is being disposed
 * @param {function(): void} callback {Function} - The callback function.
 * @param {!Object=} opt_scope {Object=} - An optional scope to call the callback in.
 * @return {void}
 */
H.Map.prototype.addOnDisposeCallback = function(callback, opt_scope) {};
/**
 * @record
 * @struct
 */
H.Map.BackgroundRange = function() {};
 /** @type {number} */
H.Map.BackgroundRange.prototype.lower;
 /** @type {number} */
H.Map.BackgroundRange.prototype.higher;

/** @const */
H.Map.EngineType = {};
/** @const {number} */
H.Map.EngineType.P2D;
/** @const {number} */
H.Map.EngineType.PANORAMA;
/**
 * @record
 * @struct
 */
H.Map.Options = function() {};
 /** @type {!H.geo.IPoint} */
H.Map.Options.prototype.center;
 /** @type {number} */
H.Map.Options.prototype.zoom;
 /** @type {!H.geo.Rect} */
H.Map.Options.prototype.bounds;
 /** @type {!Array<!H.map.layer.Layer>} */
H.Map.Options.prototype.layers;
 /** @type {H.Map.EngineType} */
H.Map.Options.prototype.engineType;
 /** @type {number} */
H.Map.Options.prototype.pixelRatio;
 /** @type {!H.map.Imprint.Options} */
H.Map.Options.prototype.imprint;
 /** @type {!H.Map.BackgroundRange} */
H.Map.Options.prototype.renderBaseBackground;
 /** @type {boolean} */
H.Map.Options.prototype.autoColor;
 /** @type {number} */
H.Map.Options.prototype.margin;
 /** @type {!H.map.ViewPort.Padding} */
H.Map.Options.prototype.padding;
 /** @type {boolean} */
H.Map.Options.prototype.fixedCenter;
/** @const */
H.clustering = {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {number} lat {H.geo.Latitude} - The latitude coordinate of the data point's position
 * @param {number} lng {H.geo.Longitude} - The longitude coordinate of the data point's position
 * @param {number=} opt_weight {number=} - The weight of the data point as a positive number > 0. If not specified it , default is 1.
 * @param {?=} opt_data {*=} - Optional data, which will be associated with this DataPoint
 */
H.clustering.DataPoint = function(lat, lng, opt_weight, opt_data) {};
 /** @type {number} */
H.clustering.DataPoint.prototype.lat;
 /** @type {number} */
H.clustering.DataPoint.prototype.lng;
 /** @type {number} */
H.clustering.DataPoint.prototype.alt;
 /** @type {H.geo.AltitudeContext} */
H.clustering.DataPoint.prototype.ctx;
 /** @type {number} */
H.clustering.DataPoint.prototype.wt;
 /** @type {?} */
H.clustering.DataPoint.prototype.data;
/**
 * @record
 * @struct
 */
H.clustering.ICluster = function() {};

/**
 * Returns the maximum zoom level where this cluster doesn't fall apart into sub clusters and/or noise poinst
 * @return {number}
 */
H.clustering.ICluster.prototype.getMaxZoom = function() {};

/**
 * Returns the bounding rectangle of this cluster.
 * @return {!H.geo.Rect}
 */
H.clustering.ICluster.prototype.getBounds = function() {};

/**
 * Invokes the specified callback for each "entry" of the cluster.
 * That "entry" can be either a cluster which implements H.clustering.ICluster interface or a noise point which implements H.clustering.INoisePoint interface.
 * @param {function(!H.clustering.IResult): void} callback {function(H.clustering.IResult)} - The callback gets the currently traversed entry as an argument, which is cluster or noise point.
 * @return {void}
 */
H.clustering.ICluster.prototype.forEachEntry = function(callback) {};

/**
 * Invokes the specified callback for each data point which is part of this cluster, even indirectly.
 * @param {function(!H.clustering.INoisePoint): void} callback {function(H.clustering.INoisePoint)} - The callback gets the currently traversed noise point as argument.
 * @return {void}
 */
H.clustering.ICluster.prototype.forEachDataPoint = function(callback) {};

/**
 * Returns the geographical position of this cluster result.
 * @return {!H.geo.Point}
 */
H.clustering.ICluster.prototype.getPosition = function() {};

/**
 * Returns the weight of this cluster result.
 * @return {number}
 */
H.clustering.ICluster.prototype.getWeight = function() {};

/**
 * To indicate whether this cluster result is a cluster or noise point
 * @return {boolean}
 */
H.clustering.ICluster.prototype.isCluster = function() {};

/**
 * Returns the minimum zoom level where this item is not part of another cluster
 * @return {number}
 */
H.clustering.ICluster.prototype.getMinZoom = function() {};
/**
 * @record
 * @struct
 */
H.clustering.INoisePoint = function() {};

/**
 * This method returns data which coresponds to this noise point.
 * @return {?}
 */
H.clustering.INoisePoint.prototype.getData = function() {};

/**
 * Returns the geographical position of this cluster result.
 * @return {!H.geo.Point}
 */
H.clustering.INoisePoint.prototype.getPosition = function() {};

/**
 * Returns the weight of this cluster result.
 * @return {number}
 */
H.clustering.INoisePoint.prototype.getWeight = function() {};

/**
 * To indicate whether this cluster result is a cluster or noise point
 * @return {boolean}
 */
H.clustering.INoisePoint.prototype.isCluster = function() {};

/**
 * Returns the minimum zoom level where this item is not part of another cluster
 * @return {number}
 */
H.clustering.INoisePoint.prototype.getMinZoom = function() {};
/**
 * @record
 * @struct
 */
H.clustering.IResult = function() {};

/**
 * Returns the geographical position of this cluster result.
 * @return {!H.geo.Point}
 */
H.clustering.IResult.prototype.getPosition = function() {};

/**
 * Returns the weight of this cluster result.
 * @return {number}
 */
H.clustering.IResult.prototype.getWeight = function() {};

/**
 * To indicate whether this cluster result is a cluster or noise point
 * @return {boolean}
 */
H.clustering.IResult.prototype.isCluster = function() {};

/**
 * Returns the minimum zoom level where this item is not part of another cluster
 * @return {number}
 */
H.clustering.IResult.prototype.getMinZoom = function() {};
/**
 * @record
 * @struct
 */
H.clustering.ITheme = function() {};

/**
 * Function returns a cluster presentation as a map object.
 * @param {!H.clustering.ICluster} cluster {H.clustering.ICluster}
 * @return {!H.map.Object}
 */
H.clustering.ITheme.prototype.getClusterPresentation = function(cluster) {};

/**
 * Function returns noise point presentation as a map object
 * @param {!H.clustering.INoisePoint} noisePoint {H.clustering.INoisePoint}
 * @return {!H.map.Object}
 */
H.clustering.ITheme.prototype.getNoisePresentation = function(noisePoint) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!Array<!H.clustering.DataPoint>} dataPoints {Array<H.clustering.DataPoint>}
 * @param {!H.clustering.Provider.Options=} opt_options {H.clustering.Provider.Options=}
 */
H.clustering.Provider = function(dataPoints, opt_options) {};
 /** @type {number} */
H.clustering.Provider.prototype.min;
 /** @type {number} */
H.clustering.Provider.prototype.max;

/**
 * This method will dispatch event on the event target object
 * @param {(string|!H.util.Event)} evt {(H.util.Event | string)} - event object or event name
 * @return {void}
 */
H.clustering.Provider.prototype.dispatchEvent = function(evt) {};

/**
 * Removes listeners from this object. Classes that extend EventTarget may need to override this method in order to remove references to DOM Elements and additional listeners.
 * @return {void}
 */
H.clustering.Provider.prototype.dispose = function() {};

/**
 * This method adds callback which is triggered when the object is being disposed
 * @param {function(): void} callback {Function}
 * @param {!Object=} opt_scope {Object=}
 * @return {void}
 */
H.clustering.Provider.prototype.addOnDisposeCallback = function(callback, opt_scope) {};

/**
 * This method sets new data to the provider
 * @param {!Array<!H.clustering.DataPoint>} dataPoints {Array<H.clustering.DataPoint>}
 * @return {void}
 */
H.clustering.Provider.prototype.setDataPoints = function(dataPoints) {};

/**
 * This method adds a data point to the provider. Beware that this method provokes reclustering of the whole data set.
 * @param {!H.clustering.DataPoint} dataPoint {H.clustering.DataPoint}
 * @return {void}
 */
H.clustering.Provider.prototype.addDataPoint = function(dataPoint) {};

/**
 * This method adds a list of data points to the provider. Beware that this method provokes reclustering of the whole data set.
 * @param {!Array<!H.clustering.DataPoint>} dataPoints {Array<H.clustering.DataPoint>}
 * @return {void}
 */
H.clustering.Provider.prototype.addDataPoints = function(dataPoints) {};

/**
 * This method removes a data point from the provider. Beware that this method provokes reclustering of the whole data set.
 * @param {!H.clustering.DataPoint} dataPoint {H.clustering.DataPoint}
 * @return {void}
 */
H.clustering.Provider.prototype.removeDataPoint = function(dataPoint) {};

/**
 * This method returns current theme used for creating cluster visualization
 * @return {!H.clustering.ITheme}
 */
H.clustering.Provider.prototype.getTheme = function() {};

/**
 * This method sets new theme on the provider. Calling this method will change visuals for displayed clusters and noise points.
 * @param {!H.clustering.ITheme} theme {H.clustering.ITheme}
 * @return {void}
 */
H.clustering.Provider.prototype.setTheme = function(theme) {};

/**
 * This method always returns true as we don't have information about visual representation until we have the clustering result and apply the theme.
 * @return {boolean}
 */
H.clustering.Provider.prototype.providesDomMarkers = function() {};

/**
 * Returns all DomMarker cluster and noise point representations which intersect with the provided rectangular area.
 * @param {!H.geo.Rect} bounds {H.geo.Rect} - A rectangular area in geo space to intersect with
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} visiblesOnly {boolean} - Indicates whether only invisible objects are to be considered
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @return {!Array<!H.map.DomMarker>}
 */
H.clustering.Provider.prototype.requestDomMarkers = function(bounds, zoomLevel, visiblesOnly, cacheOnly) {};

/**
 * This method always returns true as we don't have information about visual representation until we have the clustering result and apply the theme.
 * @return {boolean}
 */
H.clustering.Provider.prototype.providesMarkers = function() {};

/**
 * Returns all cluster and noise point markers which intersect with the provided rectangular area.
 * @param {!H.geo.Rect} bounds {H.geo.Rect} - A rectangular area in geo space to intersect with
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} visiblesOnly {boolean} - Indicates whether only invisible objects are to be considered
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @return {!Array<!H.map.Marker>}
 */
H.clustering.Provider.prototype.requestMarkers = function(bounds, zoomLevel, visiblesOnly, cacheOnly) {};

/**
 * This method always returns true as we don't have information about visual representation until we have the clustering result and apply the theme.
 * @return {boolean}
 */
H.clustering.Provider.prototype.providesSpatials = function() {};

/**
 * Returns all polyline, polygon, circle and rect objects which represent cluster and noise points and intersect with the provided area.
 * @param {!H.geo.Rect} bounds {H.geo.Rect} - A rectangular area in geo space to intersect with
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} visiblesOnly {boolean} - Indicates whether only invisible objects are to be considered
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @return {!Array<!H.map.Spatial>}
 */
H.clustering.Provider.prototype.requestSpatials = function(bounds, zoomLevel, visiblesOnly, cacheOnly) {};

/**
 * Returns the spatial objects which intersect the given tile
 * @param {!H.map.provider.Tile} tile {H.map.provider.SpatialTile} - The tile for which the objects are requested
 * @param {boolean} visiblesOnly {boolean} - Indicates whether only invisible objects are to be considered
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @return {!Array<!H.map.Spatial>}
 */
H.clustering.Provider.prototype.requestSpatialsByTile = function(tile, visiblesOnly, cacheOnly) {};

/**
 * Returns the accumulate invalidations of this provider's objects that have occurred.
 * @return {!H.map.provider.Invalidations}
 */
H.clustering.Provider.prototype.getInvalidations = function() {};

/**
 * To signal to this provider that a map object has been changed. The method updates the Invalidations of this provider and the given map object and triggers dispatchUpdate()
 * @param {!H.map.Object} mapObject {!H.map.Object} - The map object to be invalidated
 * @param {number} changes {H.math.BitMask} - The flags indicating the types of occurred changes
 * @return {void}
 */
H.clustering.Provider.prototype.invalidateObject = function(mapObject, changes) {};
/**
 * @record
 * @struct
 */
H.clustering.Provider.ClusteringOptions = function() {};
 /** @type {number} */
H.clustering.Provider.ClusteringOptions.prototype.eps;
 /** @type {number} */
H.clustering.Provider.ClusteringOptions.prototype.minWeight;
 /** @type {!H.geo.IProjection} */
H.clustering.Provider.ClusteringOptions.prototype.projection;
 /** @type {H.clustering.Provider.Strategy} */
H.clustering.Provider.ClusteringOptions.prototype.strategy;
/**
 * @record
 * @struct
 */
H.clustering.Provider.Options = function() {};
 /** @type {number} */
H.clustering.Provider.Options.prototype.min;
 /** @type {number} */
H.clustering.Provider.Options.prototype.max;
 /** @type {!H.clustering.Provider.ClusteringOptions} */
H.clustering.Provider.Options.prototype.clusteringOptions;
 /** @type {!H.clustering.ITheme} */
H.clustering.Provider.Options.prototype.theme;

/** @const */
H.clustering.Provider.Strategy = {};
/** @const {number} */
H.clustering.Provider.Strategy.FASTGRID;
/** @const {number} */
H.clustering.Provider.Strategy.GRID;
/** @const {number} */
H.clustering.Provider.Strategy.DYNAMICGRID;
/** @const */
H.data = {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {string=} opt_url {string=}
 */
H.data.AbstractReader = function(opt_url) {};

/**
 * Method returns H.map.layer.ObjectLayer that contains parsed data, and can be added directly to the map. It returns new instance of the class with every invocation.
 * If data hasn't been parsed it will return H.map.layer.ObjectLayer that contains partial information, and reader will add new parsed objects to the layer's provider later on.
 * @return {!H.map.layer.ObjectLayer}
 */
H.data.AbstractReader.prototype.getLayer = function() {};

/**
 * Method returns collection of currently parsed, and converted to H.map.Object data objects. Method returns only currently parsed objects if parsing is ongoing.
 * @return {!Array<!H.map.Object>}
 */
H.data.AbstractReader.prototype.getParsedObjects = function() {};

/**
 * Returns URL of the current file, which is either in process of fetching/parsing or file that has been already parsed.
 * @return {(string|void)}
 */
H.data.AbstractReader.prototype.getUrl = function() {};

/**
 * Method sets reader's URL. Method resets current Reader's state to its initial values (clears data about last parsed objects, etc.), and throws
 * InvalidState exception if Reader's state is not READY or ERROR.
 * @param {string} url {string} - The new URL
 * @return {!H.data.AbstractReader}
 */
H.data.AbstractReader.prototype.setUrl = function(url) {};

/**
 * Returns the reader's processing state for possible states see H.data.AbstractReader.State
 * @return {H.data.AbstractReader.State}
 */
H.data.AbstractReader.prototype.getState = function() {};

/**
 * Method launches parsing of the data file at the current url (see H.data.AbstractReader#setUrl or H.data.AbstractReader).
 * Method uses XHR as a transport therefore same origin policy applies, or server should respond with proper CORS headers.
 * @return {void}
 */
H.data.AbstractReader.prototype.parse = function() {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {(!H.map.Object|!H.data.AbstractReader)} target {(H.data.AbstractReader | H.map.Object)} - The target that's passed to event listeners
 * @param {string} type {string} - The type of the event
 * @param {H.data.AbstractReader.State} state {H.data.AbstractReader.State} - The state of the target firing an event
 * @param {string} message {string} - The message associated with an event
 */
H.data.AbstractReader.Event = function(target, type, state, message) {};

/** @const */
H.data.AbstractReader.State = {};
/** @const {number} */
H.data.AbstractReader.State.ERROR;
/** @const {number} */
H.data.AbstractReader.State.LOADING;
/** @const {number} */
H.data.AbstractReader.State.VISIT;
/** @const {number} */
H.data.AbstractReader.State.READY;
/** @const */
H.geo = {};

/** @typedef {number} */
H.geo.Altitude;

/** @const */
H.geo.AltitudeContext = {};
/** @const {number} */
H.geo.AltitudeContext.undefined;
/** @const {number} */
H.geo.AltitudeContext.GL;
/** @const {number} */
H.geo.AltitudeContext.OL;
/** @const {number} */
H.geo.AltitudeContext.SL;
/** @const {number} */
H.geo.AltitudeContext.SB;
/** @const {number} */
H.geo.AltitudeContext.WE;
/** @const {number} */
H.geo.AltitudeContext.WG;
/**
 * @record
 * @struct
 */
H.geo.IPoint = function() {};
 /** @type {number} */
H.geo.IPoint.prototype.lat;
 /** @type {number} */
H.geo.IPoint.prototype.lng;
 /** @type {number} */
H.geo.IPoint.prototype.alt;
 /** @type {H.geo.AltitudeContext} */
H.geo.IPoint.prototype.ctx;
/**
 * @record
 * @struct
 */
H.geo.IProjection = function() {};

/**
 * @param {number} lat
 * @param {number} lng
 * @param {!H.math.Point=} opt_out
 * @return {!H.math.Point}
 */
H.geo.IProjection.prototype.latLngToPoint = function(lat, lng, opt_out) {};

/**
 * @param {number} x
 * @param {number} y
 * @param {!H.geo.Point=} opt_out
 * @return {!H.geo.Point}
 */
H.geo.IProjection.prototype.xyToGeo = function(x, y, opt_out) {};

/**
 * @param {!H.math.IPoint} point
 * @param {!H.geo.Point=} opt_out
 * @return {!H.geo.Point}
 */
H.geo.IProjection.prototype.pointToGeo = function(point, opt_out) {};

/**
 * @param {!H.geo.IPoint} geoPoint
 * @param {!H.math.Point=} opt_out
 * @return {!H.math.Point}
 */
H.geo.IProjection.prototype.geoToPoint = function(geoPoint, opt_out) {};

/** @typedef {number} */
H.geo.Latitude;

/** @typedef {number} */
H.geo.Longitude;

/**
 * @constructor
 * @struct
 * Constructor
 * \@property lat {H.geo.Latitude} - The latitude coordinate.
 * \@property lng {H.geo.Longitude} - The longitude coordinate.
 * \@property opt_alt {H.geo.Altitude=} - The altitude coordinate.
 * \@property opt_ctx {H.geo.AltitudeContext=} - The altitude context.
 * @param {number} lat
 * @param {number} lng
 * @param {number=} opt_alt
 * @param {H.geo.AltitudeContext=} opt_ctx
 */
H.geo.Point = function(lat, lng, opt_alt, opt_ctx) {};
 /** @type {number} */
H.geo.Point.prototype.lat;
 /** @type {number} */
H.geo.Point.prototype.lng;
 /** @type {number} */
H.geo.Point.prototype.alt;
 /** @type {H.geo.AltitudeContext} */
H.geo.Point.prototype.ctx;

/**
 * To compare this point with a supplied other point for equality. Two points are considered equal if they have the same lat and lng as well as equivalent values for alt and ctx.
 * @param {!H.geo.IPoint} other {H.geo.IPoint}
 * @return {boolean}
 */
H.geo.Point.prototype.equals = function(other) {};

/**
 * To calculate the distance between this point and the supplied other point. The method uses the Haversine formula. The altitude is not considered.
 * @param {!H.geo.IPoint} other {H.geo.IPoint}
 * @return {number}
 */
H.geo.Point.prototype.distance = function(other) {};

/**
 * This method calculates the geographic point of a destination point using the distance and bearing specified by the caller.
 * The altitude is ignored, instead the WGS84 Mean Radius is taken.
 * @param {number} bearing {number} - The bearing to use in the calculation in degrees.
 * @param {number} distance {number} - The distance to the destination in meters.
 * @param {boolean=} opt_overGreatCircle {boolean=} - If true the computation uses the 'Great Circle' otherwise 'Rhumb Line'.
 * @return {!H.geo.Point}
 */
H.geo.Point.prototype.walk = function(bearing, distance, opt_overGreatCircle) {};

/**
 * This method validates the given IPoint. It checks, if lat, lng, alt and ctx have valid types. Additionally the value of the lat property is clamped into a range of -90 ... +90
 * and the value of the lng property is modulo into a range of -180 ... +180 plus validates the values of the alt and ctx properties
 * @param {!H.geo.IPoint} point {H.geo.IPoint} - The point to validate
 * @param {function(): void=} opt_caller {Function=} - The caller to use for InvalidArgumentError. If omitted no error is thrown
 * @param {number=} opt_argNr {number=} - The argument number to use for InvalidArgumentError.
 * @return {boolean}
 */
H.geo.Point.validate = function(point, opt_caller, opt_argNr) {};

/**
 * This method creates a Point instance from a given IPoint object.
 * @param {!H.geo.IPoint} iPoint {H.geo.IPoint} - The IPoint object to use
 * @return {!H.geo.Point}
 */
H.geo.Point.fromIPoint = function(iPoint) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {number} top {H.geo.Latitude} - the northern-most latitude
 * @param {number} left {H.geo.Longitude} - the left-most longitude
 * @param {number} bottom {H.geo.Latitude} - the southern-most latitude
 * @param {number} right {H.geo.Longitude} - the right-most latitude
 */
H.geo.Rect = function(top, left, bottom, right) {};

/**
 * To compare this rectangle with a supplied other rectangle for equality.
 * @param {!H.geo.Rect} other {H.geo.Rect}
 * @return {boolean}
 */
H.geo.Rect.prototype.equals = function(other) {};

/**
 * Toclone this rectangle.
 * @return {!H.geo.Rect}
 */
H.geo.Rect.prototype.clone = function() {};

/**
 * This method returns the top-left corner of the rectangular area.
 * @return {!H.geo.Point}
 */
H.geo.Rect.prototype.getTopLeft = function() {};

/**
 * This method returns the bottom-right corner of the rectangular area.
 * @return {!H.geo.Point}
 */
H.geo.Rect.prototype.getBottomRight = function() {};

/**
 * This method returns the north-most latitude of this rectangular area
 * @return {number}
 */
H.geo.Rect.prototype.getTop = function() {};

/**
 * This method returns the south-most latitude of this rectangular area
 * @return {number}
 */
H.geo.Rect.prototype.getBottom = function() {};

/**
 * This method returns the left-most longitude of this rectangular area
 * @return {number}
 */
H.geo.Rect.prototype.getLeft = function() {};

/**
 * This method returns the right-most longitude of this rectangular area
 * @return {number}
 */
H.geo.Rect.prototype.getRight = function() {};

/**
 * This method returns the center point of this rectangular area
 * @return {!H.geo.Point}
 */
H.geo.Rect.prototype.getCenter = function() {};

/**
 * Returns this width of this rectangular area in decimal degrees.
 * @return {number}
 */
H.geo.Rect.prototype.getWidth = function() {};

/**
 * Returns this height of this rectangular area in decimal degrees.
 * @return {number}
 */
H.geo.Rect.prototype.getHeight = function() {};

/**
 * Returns a boolean value indicating whether this rectangular area spans across the date border.
 * @return {boolean}
 */
H.geo.Rect.prototype.isCDB = function() {};

/**
 * The method checks if the area enclosed by the given bounding box is 0.
 * @return {boolean}
 */
H.geo.Rect.prototype.isEmpty = function() {};

/**
 * This method checks if the latitude and longitude supplied by the caller lie within the area of this rectangular area.
 * @param {number} lat {H.geo.Latitude} - the latitude
 * @param {number} lng {H.geo.Longitude} - the longitude
 * @param {boolean=} opt_skipValidation {boolean=} - a boolean flag indicating whether to check validity of the arguments
 * @return {boolean}
 */
H.geo.Rect.prototype.containsLatLng = function(lat, lng, opt_skipValidation) {};

/**
 * This method checks if the point supplied by the caller lies within the area of this rectangular area.
 * @param {!H.geo.IPoint} geoPoint {H.geo.IPoint} - the point
 * @param {boolean=} opt_skipValidation {boolean=} - a boolean flag indicating whether to check validity of the arguments
 * @return {boolean}
 */
H.geo.Rect.prototype.containsPoint = function(geoPoint, opt_skipValidation) {};

/**
 * This method checks if the rectangular area supplied by the caller is completely contained within the area of this rectangular area.
 * @param {!H.geo.Rect} geoRect {H.geo.Rect} - the rectangular area
 * @param {boolean=} opt_skipValidation {boolean=} - a boolean flag indicating whether to check validity of the arguments
 * @return {boolean}
 */
H.geo.Rect.prototype.containsRect = function(geoRect, opt_skipValidation) {};

/**
 * This method returns the smallest bounding box that covers this rectangular area and the latitude and longitude supplied by the caller.
 * @param {number} lat {H.geo.Latitude} - the latitude
 * @param {number} lng {H.geo.Longitude} - the longitude
 * @param {boolean=} opt_skipValidation {boolean=} - a boolean flag indicating whether to check validity of the arguments
 * @param {!H.geo.Rect=} opt_out {H.geo.Rect=} - an optional rectangular area to store the result
 * @return {!H.geo.Rect}
 */
H.geo.Rect.prototype.mergeLatLng = function(lat, lng, opt_skipValidation, opt_out) {};

/**
 * This method returns the smallest bounding box that covers this rectangular area and the point supplied by the caller.
 * @param {!H.geo.IPoint} geoPoint {H.geo.IPoint} - the point to merge
 * @param {boolean=} opt_skipValidation {boolean=} - a boolean flag indicating whether to check validity of the arguments
 * @param {!H.geo.Rect=} opt_out {H.geo.Rect=} - an optional rectangular area to store the result
 * @return {!H.geo.Rect}
 */
H.geo.Rect.prototype.mergePoint = function(geoPoint, opt_skipValidation, opt_out) {};

/**
 * This method returns the smallest bounding box that covers this rectangular area and the rectangular area supplied by the caller.
 * @param {!H.geo.Rect} geoRect {H.geo.Rect} - the point to merge
 * @param {boolean=} opt_skipValidation {boolean=} - a boolean flag indicating whether to check validity of the arguments
 * @param {!H.geo.Rect=} opt_out {H.geo.Rect=} - an optional rectangular area to store the result
 * @return {!H.geo.Rect}
 */
H.geo.Rect.prototype.mergeRect = function(geoRect, opt_skipValidation, opt_out) {};

/**
 * This method returns the smallest bounding box that covers this rectangular area and the rectangular area supplied by the caller.
 * @param {number} top {H.geo.Latitude} - The top latitude of the rectangle to merge
 * @param {number} left {H.geo.Longitude} - The left longitude of the rectangle to merge
 * @param {number} bottom {H.geo.Latitude} - The bottom latitude of the rectangle to merge
 * @param {number} right {H.geo.Longitude} - The right longitude of the rectangle to merge
 * @param {boolean=} opt_skipValidation {boolean=} - a boolean flag indicating whether to check validity of the arguments
 * @param {!H.geo.Rect=} opt_out {H.geo.Rect=} - an optional rectangular area to store the result
 * @return {!H.geo.Rect}
 */
H.geo.Rect.prototype.mergeTopLeftBottomRight = function(top, left, bottom, right, opt_skipValidation, opt_out) {};

/**
 * This method checks if the intersection of two bounding boxes is non-empty.
 * @param {!H.geo.Rect} geoRect {H.geo.Rect} - a rectangular area to be tested for intersection with this rectangular area
 * @param {boolean=} opt_skipValidation {boolean=} - a boolean flag indicating whether to check validity of the arguments
 * @return {boolean}
 */
H.geo.Rect.prototype.intersects = function(geoRect, opt_skipValidation) {};

/**
 * This method merges two rects by their values. The result of the merge is a bounding rect which covers all provided rect bounds.
 * @param {number} topA {H.geo.Latitude} - the northern-most latitude
 * @param {number} leftA {H.geo.Longitude} - the left-most longitude of operand A
 * @param {number} bottomA {H.geo.Latitude} - the southern-most latitude of operand A
 * @param {number} rightA {H.geo.Longitude} - the right-most latitude of operand A
 * @param {number} topB {H.geo.Latitude} - the northern-most latitude of operand B
 * @param {number} leftB {H.geo.Longitude} - the left-most longitude of operand B
 * @param {number} bottomB {H.geo.Latitude} - the southern-most latitude of operand B
 * @param {number} rightB {H.geo.Longitude} - the right-most latitude of operand B
 * @param {!H.geo.Rect=} opt_out {H.geo.Rect=} - an optional rect to store the results
 * @return {!H.geo.Rect}
 */
H.geo.Rect.merge = function(topA, leftA, bottomA, rightA, topB, leftB, bottomB, rightB, opt_out) {};

/**
 * This method creates a rectangular area from a top-left and bottom-right point pair.
 * @param {!H.geo.IPoint} topLeft {H.geo.IPoint} - the top-left corner of the area
 * @param {!H.geo.IPoint} bottomRight {H.geo.IPoint} - the bottom-right corner of the area
 * @param {boolean=} opt_skipValidation {boolean=} - a boolean flag indicating whether to check validity of the arguments
 * @return {!H.geo.Rect}
 */
H.geo.Rect.fromPoints = function(topLeft, bottomRight, opt_skipValidation) {};

/**
 * This method creates the minimum rectangular area covering all of the points in the argument array.
 * @param {!Array<!H.geo.IPoint>} pointArray {Array<H.geo.IPoint>} - the array of points to cover
 * @param {boolean=} opt_skipValidation {boolean=} - a boolean flag indicating whether to check validity of the arguments
 * @return {!H.geo.Rect}
 */
H.geo.Rect.coverPoints = function(pointArray, opt_skipValidation) {};

/**
 * This method creates the minimum rectangular area covering all of the coordinates in the argument array.
 * @param {!Array<number>} latLngAltArray {Array<number>} - the array of coordinates to cover
 * @param {boolean=} opt_skipValidation {boolean=} - a boolean flag indicating whether to check validity of the arguments
 * @return {(void|!H.geo.Rect)}
 */
H.geo.Rect.coverLatLngAlts = function(latLngAltArray, opt_skipValidation) {};

/**
 * This method creates the minimum rectangular area covering all of the rectangular areas in the argument array.
 * @param {!Array<!H.geo.Rect>} rectArray {Array<H.geo.Rect>} - the array of points to cover
 * @param {boolean=} opt_skipValidation {boolean=} - a boolean flag indicating whether to check validity of the arguments
 * @return {(void|!H.geo.Rect)}
 */
H.geo.Rect.coverRects = function(rectArray, opt_skipValidation) {};

/**
 * This method clones the given bounding rect and resizes the clone if necessary until the location supplied by the caller is at its center.
 * @param {!H.geo.IPoint} center {H.geo.IPoint} - a point which is to be the center of the resized rectangular area
 * @param {!H.geo.Rect=} opt_out {H.geo.Rect=} - an optional rectangular area to store the result
 * @return {!H.geo.Rect}
 */
H.geo.Rect.prototype.resizeToCenter = function(center, opt_out) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!Array<number>=} opt_latLngAlts {Array<number>=} - An optional array of latitude, longitude and altitude triples to initialize the strip with.
 * @param {H.geo.AltitudeContext=} opt_ctx {H.geo.AltitudeContext=} - An optional altitude context for all altitudes contained in this strip.
 */
H.geo.Strip = function(opt_latLngAlts, opt_ctx) {};

/**
 * This method pushes a lat, lng, alt to the end of this strip.
 * @param {number} lat {H.geo.Latitude}
 * @param {number} lng {H.geo.Longitude}
 * @param {number} alt {H.geo.Altitude}
 * @return {void}
 */
H.geo.Strip.prototype.pushLatLngAlt = function(lat, lng, alt) {};

/**
 * This method splices the strip at the provided index, removing the specified number of items at that index and inserting the lat, lng, alt array.
 * @param {number} index {number} - The index at which to splice
 * @param {number=} opt_nRemove {number=} - The number of lat, lng, alt values to remove
 * @param {!Array<number>=} opt_latLngAlts {Array<number>=} - The lat, lng, alt values to add
 * @return {!Array<number>}
 */
H.geo.Strip.prototype.spliceLatLngAlts = function(index, opt_nRemove, opt_latLngAlts) {};

/**
 * This method inserts one set of lat, lng, alt values into the strip at the specified index.
 * @param {number} index {number} - the index at which to add the element
 * @param {number} lat {H.geo.Latitude} - the latitude to insert
 * @param {number} lng {H.geo.Longitude} - the longitude to insert
 * @param {number} alt {H.geo.Altitude} - the altitude to insert
 * @return {void}
 */
H.geo.Strip.prototype.insertLatLngAlt = function(index, lat, lng, alt) {};

/**
 * This method removes one set of lat, lng, alt values from the strip at the specified index.
 * @param {number} index {number}
 * @return {void}
 */
H.geo.Strip.prototype.removeLatLngAlt = function(index) {};

/**
 * This method pushes the lat, lng, alt values of a H.geo.Point to the end of this strip.
 * @param {!H.geo.IPoint} geoPoint {H.geo.IPoint}
 * @return {void}
 */
H.geo.Strip.prototype.pushPoint = function(geoPoint) {};

/**
 * This method inserts the lat, lng, alt values of a H.geo.Point into the list at the specified index.
 * @param {number} pointIndex {number}
 * @param {!H.geo.IPoint} geoPoint {H.geo.IPoint}
 * @return {void}
 */
H.geo.Strip.prototype.insertPoint = function(pointIndex, geoPoint) {};

/**
 * This method removes one set of lat, lng, alt values from this strip at the virtual point index specified.
 * @param {number} pointIndex {number} - the virtual point index
 * @return {void}
 */
H.geo.Strip.prototype.removePoint = function(pointIndex) {};

/**
 * This method extracts a H.geo.Point from this strip at the virtual point index. If the extracted point has an alt value, the strip's altitude context will be supplied to the point.
 * @param {number} pointIndex {number} - the virtual point index in the strip
 * @param {!H.geo.Point=} opt_out {H.geo.Point=} - an optional point object to store the lat, lng, alt values
 * @return {!H.geo.Point}
 */
H.geo.Strip.prototype.extractPoint = function(pointIndex, opt_out) {};

/**
 * This method is a utility method that iterates over the lat, lng, alt array and calls the provided function for each 3 elements passing lat, lng and alt and the virtual point
 * index as arguments.
 * @param {function(number, number, number, number): void} eachFn {function(H.geo.Latitude, H.geo.Longitude, H.geo.Altitude, number)} - the function to be called for each 3 elements
 * @param {number=} opt_start {number=} - an optional start index to iterate from
 * @param {number=} opt_end {number=} - an optional end index to iterate to
 * @return {void}
 */
H.geo.Strip.prototype.eachLatLngAlt = function(eachFn, opt_start, opt_end) {};

/**
 * This method returns the number of times that legs in this strip cross the date border.
 * @param {boolean=} opt_closed {boolean=} - indicates whether the strip is closed (i.e. whether the strip's last and first coordinates form the closing leg of a polygon)
 * @return {number}
 */
H.geo.Strip.prototype.getDBCs = function(opt_closed) {};

/**
 * This method return the number of points stored in this strip.
 * @return {number}
 */
H.geo.Strip.prototype.getPointCount = function() {};

/**
 * This method returns the internal array keeping the lat, lng, alt values. Modifying this array directly can destroy the integrity of this strip. Use it only for read access.
 * @return {!Array<number>}
 */
H.geo.Strip.prototype.getLatLngAltArray = function() {};

/**
 * This method returns the bounding box of this strip.
 * @return {!H.geo.Rect}
 */
H.geo.Strip.prototype.getBounds = function() {};

/**
 * This method checks whether two longitudes form a leg which crosses the date border.
 * @param {number} lng1 {H.geo.Longitude} - the start longitude of the leg
 * @param {number} lng2 {H.geo.Longitude} - the end longitude of the leg
 * @return {boolean}
 */
H.geo.Strip.isDBC = function(lng1, lng2) {};

/**
 * This method initializes a new strip with an array of lat, lng values. Arrays are expected to have an even length with the format [lat, lng, lat, lng, ...].
 * @param {!Array<number>} latLngs {Array<number>} - the array of lat, lng value.
 * @return {!H.geo.Strip}
 */
H.geo.Strip.fromLatLngArray = function(latLngs) {};
/** @const */
H.map = {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.geo.IPoint} position {H.geo.IPoint} - The location of this marker
 * @param {!H.map.AbstractMarker.Options=} opt_options {H.map.AbstractMarker.Options=} - The values to initialize this marker
 */
H.map.AbstractMarker = function(position, opt_options) {};

/**
 * This method returns this marker's current position.
 * @return {!H.geo.Point}
 */
H.map.AbstractMarker.prototype.getPosition = function() {};

/**
 * This method sets the marker's current position.
 * @param {!H.geo.IPoint} position {H.geo.IPoint}
 * @return {!H.map.AbstractMarker}
 */
H.map.AbstractMarker.prototype.setPosition = function(position) {};

/**
 * Returns this marker's current icon.
 * @return {(!H.map.Icon|!H.map.DomIcon)}
 */
H.map.AbstractMarker.prototype.getIcon = function() {};

/**
 * Sets the marker's current icon.
 * @param {(!H.map.Icon|!H.map.DomIcon)} icon {!(H.map.Icon | H.map.DomIcon)} - The new marker icon
 * @return {!H.map.AbstractMarker}
 */
H.map.AbstractMarker.prototype.setIcon = function(icon) {};
/**
 * @record
 * @struct
 */
H.map.AbstractMarker.Options = function() {};
 /** @type {number} */
H.map.AbstractMarker.Options.prototype.min;
 /** @type {number} */
H.map.AbstractMarker.Options.prototype.max;
 /** @type {boolean} */
H.map.AbstractMarker.Options.prototype.visibility;
 /** @type {number} */
H.map.AbstractMarker.Options.prototype.zIndex;
 /** @type {!H.map.provider.Provider} */
H.map.AbstractMarker.Options.prototype.provider;
 /** @type {(!H.map.Icon|!H.map.DomIcon)} */
H.map.AbstractMarker.Options.prototype.icon;
 /** @type {?} */
H.map.AbstractMarker.Options.prototype.data;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {(!H.map.ArrowStyle|!H.map.ArrowStyle.Options)=} opt_options {(H.map.ArrowStyle | H.map.ArrowStyle.Options)=}
 */
H.map.ArrowStyle = function(opt_options) {};

/**
 * This method checks value-equality with another arrow style.
 * @param {(!H.map.ArrowStyle|!H.map.ArrowStyle.Options)} other {(H.map.ArrowStyle | H.map.ArrowStyle.Options)} - the arrow style to compare with
 * @return {boolean}
 */
H.map.ArrowStyle.prototype.equals = function(other) {};
/**
 * @record
 * @struct
 */
H.map.ArrowStyle.Options = function() {};
 /** @type {string} */
H.map.ArrowStyle.Options.prototype.fillColor;
 /** @type {number} */
H.map.ArrowStyle.Options.prototype.width;
 /** @type {number} */
H.map.ArrowStyle.Options.prototype.length;
 /** @type {number} */
H.map.ArrowStyle.Options.prototype.frequency;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.geo.IPoint} center {H.geo.IPoint} - The geographical coordinates of the circle's center
 * @param {number} radius {number} - The radius of the circle in meters
 * @param {!H.map.Circle.Options=} opt_options {H.map.Circle.Options=} - An object that specifies circle options and their initial values (among these, precision has a significant impact on the shape of the circle
 */
H.map.Circle = function(center, radius, opt_options) {};

/**
 * To set the geographical center point of this circle. If the specified center is an instance of H.geo.Point you must not modify this Point instance without calling setCenter
 * immediately afterwards.
 * @param {!H.geo.IPoint} center {H.geo.IPoint}
 * @return {void}
 */
H.map.Circle.prototype.setCenter = function(center) {};

/**
 * To get the center point of this circle You must not modify the returned Point instance without calling setCenter immediately afterwards.
 * @return {!H.geo.Point}
 */
H.map.Circle.prototype.getCenter = function() {};

/**
 * To set the length of the radius of the circle in meters. The value is clamped to the of {\@code[0 ... 20015089.27787877]} (half WGS84 mean circumference)
 * @param {number} radius {number}
 * @return {void}
 */
H.map.Circle.prototype.setRadius = function(radius) {};

/**
 * To get the length of the radius of the circle in meters.
 * @return {number}
 */
H.map.Circle.prototype.getRadius = function() {};

/**
 * To set the precision of this circle {\@see H.map.Circle.Options#precision}
 * @param {number} precision {number}
 * @return {void}
 */
H.map.Circle.prototype.setPrecision = function(precision) {};

/**
 * To get the precision value of this circle
 * @return {number}
 */
H.map.Circle.prototype.getPrecision = function() {};
/**
 * @record
 * @struct
 */
H.map.Circle.Options = function() {};
 /** @type {(!H.map.SpatialStyle|!H.map.SpatialStyle.Options)} */
H.map.Circle.Options.prototype.style;
 /** @type {boolean} */
H.map.Circle.Options.prototype.visibility;
 /** @type {number} */
H.map.Circle.Options.prototype.precision;
 /** @type {number} */
H.map.Circle.Options.prototype.zIndex;
 /** @type {number} */
H.map.Circle.Options.prototype.min;
 /** @type {number} */
H.map.Circle.Options.prototype.max;
 /** @type {!H.map.provider.Provider} */
H.map.Circle.Options.prototype.provider;
 /** @type {?} */
H.map.Circle.Options.prototype.data;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!Array<!H.map.layer.Layer>=} opt_layers {Array=} - array of layers to be added to the data model
 */
H.map.DataModel = function(opt_layers) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {(string|!Element)} element {!(Element | string)} - The element or markup to use for this icon
 * @param {!H.map.DomIcon.Options=} opt_options {H.map.DomIcon.Options=}
 */
H.map.DomIcon = function(element, opt_options) {};
/**
 * @record
 * @struct
 */
H.map.DomIcon.Options = function() {};

/**
 * @param {!Element} el
 * @param {!H.map.DomIcon} icon
 * @param {!H.map.DomMarker} marker
 * @return {void}
 */
H.map.DomIcon.Options.prototype.onAttach = function(el, icon, marker) {};

/**
 * @param {!Element} el
 * @param {!H.map.DomIcon} icon
 * @param {!H.map.DomMarker} marker
 * @return {void}
 */
H.map.DomIcon.Options.prototype.onDetach = function(el, icon, marker) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.geo.IPoint} position {H.geo.IPoint}
 * @param {!H.map.DomMarker.Options=} opt_options {H.map.DomMarker.Options=}
 */
H.map.DomMarker = function(position, opt_options) {};
/**
 * @record
 * @struct
 */
H.map.DomMarker.Options = function() {};
 /** @type {number} */
H.map.DomMarker.Options.prototype.min;
 /** @type {number} */
H.map.DomMarker.Options.prototype.max;
 /** @type {boolean} */
H.map.DomMarker.Options.prototype.visibility;
 /** @type {number} */
H.map.DomMarker.Options.prototype.zIndex;
 /** @type {!H.map.provider.Provider} */
H.map.DomMarker.Options.prototype.provider;
 /** @type {!H.map.DomIcon} */
H.map.DomMarker.Options.prototype.icon;
 /** @type {?} */
H.map.DomMarker.Options.prototype.data;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {boolean} isClosed {boolean} - Indicates whether this geographical shape is closed (a polygon)
 * @param {!H.geo.Strip} strip {H.geo.Strip} - The strip describing the shape of the spatial object
 * @param {!H.map.Spatial.Options} options {H.map.Spatial.Options} - The options to apply
 */
H.map.GeoShape = function(isClosed, strip, options) {};

/**
 * This method returns the strip which represents the shape of the spatial object.
 * @return {!H.geo.Strip}
 */
H.map.GeoShape.prototype.getStrip = function() {};

/**
 * This method sets the geo-information for the spatial object
 * @param {!H.geo.Strip} strip {?H.geo.Strip} - The strip which represents the shape of the spatial object.
 * @return {!H.map.GeoShape}
 */
H.map.GeoShape.prototype.setStrip = function(strip) {};

/**
 * This method returns the bounding rectangle for this object. The rectangle is the smallest rectangle which encloses all points of the spatial object.
 * @return {!H.geo.Rect}
 */
H.map.GeoShape.prototype.getBounds = function() {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.Group.Options=} opt_options {H.map.Group.Options=} - an optional object containing initialization values
 */
H.map.Group = function(opt_options) {};

/**
 *
 * @param {function(!H.map.Object, number, !H.map.Group): void} callback {function(!H.map.Object, number, !H.map.Group)}
 * @param {boolean=} opt_recursive {boolean=} - Indicates whether sub groups should be traversed recursively
 * @param {?=} opt_context {*=} - The context to use as "this" within the callback
 * @return {void}
 */
H.map.Group.prototype.forEach = function(callback, opt_recursive, opt_context) {};

/**
 * To get a list of all objects of this group. On groups with many chilren this method can cause a higher memory and CPU consumption. Alternatively you case use H.map.Group#forEach
 * @param {boolean=} opt_recursive {boolean=} - Indicates whether objects in sub-groups are also collected .
 * @return {!Array<!H.map.Object>}
 */
H.map.Group.prototype.getObjects = function(opt_recursive) {};

/**
 * Method returns the bounding rectangle for the group. The rectangle is the smallest rectangle that covers all objects. If group doesn't contains objects method returns null.
 * @return {!H.geo.Rect}
 */
H.map.Group.prototype.getBounds = function() {};

/**
 * To add an object to this group.
 * @param {!H.map.Object} object {!H.map.Object}
 * @return {!H.map.Object}
 */
H.map.Group.prototype.addObject = function(object) {};

/**
 * Appends a list of objects to this group
 * @param {!Array<!H.map.Object>} objects {Array<!H.map.Object>}
 * @return {void}
 */
H.map.Group.prototype.addObjects = function(objects) {};

/**
 * Removes an object from this group.
 * @param {!H.map.Object} object {!H.map.Object} - The object to remove
 * @return {!H.map.Object}
 */
H.map.Group.prototype.removeObject = function(object) {};

/**
 * Removes objects from this group.
 * @param {!Array<!H.map.Object>} objects {!Array<!H.map.Object>} - The list of objects to remove
 * @return {void}
 */
H.map.Group.prototype.removeObjects = function(objects) {};

/**
 * Method removes all objects from the group.
 * @return {void}
 */
H.map.Group.prototype.removeAll = function() {};
/**
 * @record
 * @struct
 */
H.map.Group.Options = function() {};
 /** @type {number} */
H.map.Group.Options.prototype.min;
 /** @type {number} */
H.map.Group.Options.prototype.max;
 /** @type {boolean} */
H.map.Group.Options.prototype.visibility;
 /** @type {number} */
H.map.Group.Options.prototype.zIndex;
 /** @type {!H.map.provider.Provider} */
H.map.Group.Options.prototype.provider;
 /** @type {?} */
H.map.Group.Options.prototype.data;
 /** @type {!Array<!H.map.Object>} */
H.map.Group.Options.prototype.objects;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {H.map.HitArea.ShapeType} shapeType {H.map.HitArea.ShapeType} - The shape type of the HitArea
 * @param {!Array<number>=} opt_values {Array<number>=} - The type-dependent values to define the shape of the hit area. The format for the different types are:
 */
H.map.HitArea = function(shapeType, opt_values) {};

/** @const */
H.map.HitArea.ShapeType = {};
/** @const {number} */
H.map.HitArea.ShapeType.NONE;
/** @const {number} */
H.map.HitArea.ShapeType.RECT;
/** @const {number} */
H.map.HitArea.ShapeType.CIRCLE;
/** @const {number} */
H.map.HitArea.ShapeType.POLYGON;
/**
 * @record
 * @struct
 */
H.map.IControl = function() {};

/**
 * This method starts control action for camera. This action allows to control camera animation and movement according to provided values in the H.map.IControl#control function
 * @param {!H.util.kinetics.IKinetics=} opt_kinetics {H.util.kinetics.IKinetics=} - kinetics settings
 * @param {number=} opt_atX {number=} - control starts at x screen coordinate
 * @param {number=} opt_atY {number=} - control starts at y screen coordinate
 * @return {void}
 */
H.map.IControl.prototype.startControl = function(opt_kinetics, opt_atX, opt_atY) {};

/**
 * This method triggers single control action on engine. This will trigger an animation which will start modification of the view's or camera's properties according to values begin set.
 * Modification will occur at every frame. The speed values are measure by 'levels per frame' were 1 level cooresponds to a distance to next zoom level.
 * @param {number} moveX {number} - moves the view/cam in right/left direction
 * @param {number} moveY {number} - moves the view/cam in bottom/top direction
 * @param {number} moveZ {number} - moves the view/cam in depth direction (changes zoom level)
 * @param {number} angleX {number} - rotates cam over x-axis
 * @param {number} angleY {number} - rotates cam over y-axis
 * @param {number} angleZ {number} - rotates cam over z-axis
 * @param {number} zoom {number} - changes current zoom level (for view works as moveZ)
 * @param {number=} opt_timestamp {number=}
 * @return {void}
 */
H.map.IControl.prototype.control = function(moveX, moveY, moveZ, angleX, angleY, angleZ, zoom, opt_timestamp) {};

/**
 * This method ends current control, which will stop ongoing animation triggered by the startControl method. This method can prevent kinetics as well as it can adjust the final view if
 * the adjust function is being passed.
 * @param {boolean=} opt_preventKinetics {boolean=} - if set to true will prevent kinetics animation
 * @param {function(!H.map.ViewModel.CameraData): void=} opt_adjustView {function(H.map.ViewModel.CameraData)=} - user defined function which can adjust the final view this function takes last requestedData from the view model and
 * should return a modified H.map.ViewModel.CameraData which will be set as the final view
 * @return {void}
 */
H.map.IControl.prototype.endControl = function(opt_preventKinetics, opt_adjustView) {};
/**
 * @record
 * @struct
 */
H.map.ICopyright = function() {};
 /** @type {string} */
H.map.ICopyright.prototype.label;
 /** @type {string} */
H.map.ICopyright.prototype.alt;
/**
 * @record
 * @struct
 */
H.map.IInteraction = function() {};

/**
 * This method starts the interaction with the view port. Should be called every time when new interaction is started i.e mouse grab, or touch start.
 * @param {number} modifiers {number} - a bitmask which specifies what operations should performed during every interaction
 * @param {!H.util.kinetics.IKinetics=} opt_kinetics {H.util.kinetics.IKinetics=} - specifies kinetic move at the end of interaction
 * @return {void}
 */
H.map.IInteraction.prototype.startInteraction = function(modifiers, opt_kinetics) {};

/**
 * This method resolves direct screen (view port) interaction. This function will modify the current view according to values passed in.
 * @param {number} x {number} - viewport x coordinate
 * @param {number} y {number} - viewport y coordinate
 * @param {number=} opt_bx {number=} - x coordinate for second pointer/touch if present
 * @param {number=} opt_by {number=} - y coordinate for secong pointer/touch if present
 * @param {number=} opt_timestamp {number=} - known timestamp which should be passed
 * @return {void}
 */
H.map.IInteraction.prototype.interaction = function(x, y, opt_bx, opt_by, opt_timestamp) {};

/**
 * This method ends interaction and applies kinetic movement if defined by using startInteraction method
 * @param {boolean=} opt_preventKinetics {boolean=} - if set to true will prevent kinetics behaviour at the end of interaction
 * @return {void}
 */
H.map.IInteraction.prototype.endInteraction = function(opt_preventKinetics) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {(string|!HTMLCanvasElement|!HTMLImageElement)} bitmap {!(string | HTMLImageElement | HTMLCanvasElement)} - Either an image URL, a SVG markup, an image or a canvas.
 * @param {!H.map.Icon.Options=} opt_options {H.map.Icon.Options=}
 */
H.map.Icon = function(bitmap, opt_options) {};

/**
 * Returns the icon's bitmap loading state
 * @return {H.map.Icon.State}
 */
H.map.Icon.prototype.getState = function() {};

/**
 * Returns the bitmap of this icon or null if the bitmap is not ready yet (see H.map.Icon#getState)
 * @return {(!HTMLCanvasElement|!HTMLImageElement)}
 */
H.map.Icon.prototype.getBitmap = function() {};

/**
 * Returns the size of this icon or null if a size wasn't specified in the constructor's options and the state of this icon is not H.map.Icon.prototype.State.READY
 * @return {!H.math.Size}
 */
H.map.Icon.prototype.getSize = function() {};

/**
 * Returns the anchor point of this icon or null if an anchor wasn't specified in the constructor's options and the state of this icon is not H.map.Icon.prototype.State.READY.
 * @return {!H.math.Point}
 */
H.map.Icon.prototype.getAnchor = function() {};

/**
 * Returns the hit area of the icon.
 * @return {!H.map.HitArea}
 */
H.map.Icon.prototype.getHitArea = function() {};

/**
 * This method allows to listen for specific event triggered by the object. Keep in mind, that you must removeEventListener manually or dispose an object when you no longer need it.
 * Otherwise memory leak is possible.
 * @param {string} type {string} - name of event
 * @param {function(): void} handler {Function} - event handler function
 * @param {boolean=} opt_capture {boolean=} - if set to true will listen in the capture phase (bubble otherwise)
 * @param {!Object=} opt_scope {Object=} - scope for the handler function
 * @return {void}
 */
H.map.Icon.prototype.addEventListener = function(type, handler, opt_capture, opt_scope) {};

/**
 * This method will removed previously added listener from the event target
 * @param {string} type {string} - name of event
 * @param {function(): void} handler {Function} - previously added event handler
 * @param {boolean=} opt_capture {boolean=} - if set to true will listen in the capture phase (bubble otherwise)
 * @param {!Object=} opt_scope {Object=} - scope for the handler function
 * @return {void}
 */
H.map.Icon.prototype.removeEventListener = function(type, handler, opt_capture, opt_scope) {};

/**
 * This method will dispatch event on the event target object
 * @param {(string|!H.util.Event)} evt {(H.util.Event | string)} - event object or event name
 * @return {void}
 */
H.map.Icon.prototype.dispatchEvent = function(evt) {};

/**
 * Removes listeners from this object. Classes that extend EventTarget may need to override this method in order to remove references to DOM Elements and additional listeners.
 * @return {void}
 */
H.map.Icon.prototype.dispose = function() {};

/**
 * This method adds callback which is triggered when the object is being disposed
 * @param {function(): void} callback {Function} - The callback function.
 * @param {!Object=} opt_scope {Object=} - An optional scope to call the callback in.
 * @return {void}
 */
H.map.Icon.prototype.addOnDisposeCallback = function(callback, opt_scope) {};

/** @const */
H.map.Icon.State = {};
/** @const {number} */
H.map.Icon.State.ERROR;
/** @const {number} */
H.map.Icon.State.LOADING;
/** @const {number} */
H.map.Icon.State.READY;
/**
 * @record
 * @struct
 */
H.map.Icon.Options = function() {};
 /** @type {(number|!H.math.ISize)} */
H.map.Icon.Options.prototype.size;
 /** @type {!H.math.IPoint} */
H.map.Icon.Options.prototype.anchor;
 /** @type {!H.map.HitArea} */
H.map.Icon.Options.prototype.hitArea;
 /** @type {!H.map.HitArea} */
H.map.Icon.Options.prototype.asCanvas;
 /** @type {boolean} */
H.map.Icon.Options.prototype.crossOrigin;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.Map} map {H.Map} - The map where the imprint is attached to
 * @param {!H.map.Imprint.Options=} opt_options {H.map.Imprint.Options=} - The options to style the imprint
 */
H.map.Imprint = function(map, opt_options) {};

/**
 * To set the imprint options. If no opt_options argument is defined then all values are reset to their defaults.
 * @param {!H.map.Imprint.Options=} opt_options {H.map.Imprint.Options=} - The options to style the imprint
 * @return {void}
 */
H.map.Imprint.prototype.setOptions = function(opt_options) {};

/**
 * This method retrieves the copyright string for the current view of the map.
 * @return {string}
 */
H.map.Imprint.prototype.getCopyrights = function() {};

/**
 * To get the CSS style declaration of the imprint DOM element
 * @return {!CSSStyleDeclaration}
 */
H.map.Imprint.prototype.getStyle = function() {};

/**
 * Method adds a callback which will be triggered when the object is disposed
 * @param {function(): void} callback {Function}
 * @param {!Object=} opt_scope {Object=}
 * @return {void}
 */
H.map.Imprint.prototype.addOnDisposeCallback = function(callback, opt_scope) {};

/**
 * This method is used to capture the element view
 * @param {!HTMLCanvasElement} canvas {HTMLCanvasElement} - HTML Canvas element to draw the view of the capturable element
 * @param {number} pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
 * @param {function(!HTMLCanvasElement): void=} callback {function(HTMLCanvasElement=)} - Callback function to call once result of the capturing is ready
 * @param {function(string): void=} opt_errback {function(string)=} - Callback function to call if error occurred during capturing
 * @return {void}
 */
H.map.Imprint.prototype.capture = function(canvas, pixelRatio, callback, opt_errback) {};
/**
 * @record
 * @struct
 */
H.map.Imprint.Options = function() {};
 /** @type {boolean} */
H.map.Imprint.Options.prototype.invert;
 /** @type {string} */
H.map.Imprint.Options.prototype.font;
 /** @type {string} */
H.map.Imprint.Options.prototype.href;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.geo.IPoint} position {H.geo.IPoint} - The location of this marker
 * @param {!H.map.Marker.Options=} opt_options {H.map.Marker.Options=} - The values to initialize this marker
 */
H.map.Marker = function(position, opt_options) {};
/**
 * @record
 * @struct
 */
H.map.Marker.Options = function() {};
 /** @type {number} */
H.map.Marker.Options.prototype.min;
 /** @type {number} */
H.map.Marker.Options.prototype.max;
 /** @type {boolean} */
H.map.Marker.Options.prototype.visibility;
 /** @type {number} */
H.map.Marker.Options.prototype.zIndex;
 /** @type {!H.map.provider.Provider} */
H.map.Marker.Options.prototype.provider;
 /** @type {!H.map.Icon} */
H.map.Marker.Options.prototype.icon;
 /** @type {?} */
H.map.Marker.Options.prototype.data;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.Object.Options=} opt_options {H.map.Object.Options=} - The values to initialize this object
 */
H.map.Object = function(opt_options) {};

/**
 * Returns the ID of this object.
 * @return {?}
 */
H.map.Object.prototype.getId = function() {};

/**
 * Sets the visibility of this object.
 * @param {boolean=} opt_visibility {boolean=} - Indicates whether this map object should be visible.
 * @return {!H.map.Object}
 */
H.map.Object.prototype.setVisibility = function(opt_visibility) {};

/**
 * Returns the visibility of this object.
 * @param {boolean=} opt_effective {boolean=} - Indicates that the effective visibility is requested. In this case the visibility of all possible ancestor groups is also taken into account
 * @return {boolean}
 */
H.map.Object.prototype.getVisibility = function(opt_effective) {};

/**
 * Returns the z-index of this object.
 * @return {(number|void)}
 */
H.map.Object.prototype.getZIndex = function() {};

/**
 * To set the-index of this object.
 * @param {number=} zIndex {(number | undefined)}
 * @return {!H.map.Object}
 */
H.map.Object.prototype.setZIndex = function(zIndex) {};

/**
 * Compares two objects regarding their z-order, useful to sort a list of objects via Array's sort() method
 * @param {!H.map.Object} first {H.map.Object} - The first object to compare
 * @param {!H.map.Object} second {H.map.Object} - The second object to compare
 * @return {number}
 */
H.map.Object.compareZOrder = function(first, second) {};

/**
 * Returns the parent group which contains this object or null if the object is not contained by any group.
 * @return {!H.map.Group}
 */
H.map.Object.prototype.getParentGroup = function() {};

/**
 * The root object in which this object is attached or the object itself.
 * @return {!H.map.Object}
 */
H.map.Object.prototype.getRootGroup = function() {};

/**
 * Checks whether the given object is an inclusive descendant of this object
 * @param {?} object {*} - The object that's being compared against.
 * @return {boolean}
 */
H.map.Object.prototype.contains = function(object) {};

/**
 * The current provider of this object
 * @return {!H.map.provider.ObjectProvider}
 */
H.map.Object.prototype.getProvider = function() {};

/**
 * Returns the invalidations of this object
 * @return {!H.map.provider.Invalidations}
 */
H.map.Object.prototype.getInvalidations = function() {};

/**
 * This method invalidates this map object.
 * @param {number} flags {H.math.BitMask} - The flags indicating the types of occurred changes
 * @return {boolean}
 */
H.map.Object.prototype.invalidate = function(flags) {};

/**
 * This method returns previously stored arbitrary data from this object.
 * @return {?}
 */
H.map.Object.prototype.getData = function() {};

/**
 * This method stores arbitrary data with this map object
 * @param {?} data {*} - the data to be stored
 * @return {!H.map.Object}
 */
H.map.Object.prototype.setData = function(data) {};

/**
 * This method will dispatch event on the event target object
 * @param {(string|!H.util.Event)} evt {(H.util.Event | string)} - event object or event name
 * @return {void}
 */
H.map.Object.prototype.dispatchEvent = function(evt) {};

/**
 * Removes listeners from this object. Classes that extend EventTarget may need to override this method in order to remove references to DOM Elements and additional listeners.
 * @return {void}
 */
H.map.Object.prototype.dispose = function() {};

/**
 * This method adds callback which is triggered when the object is being disposed
 * @param {function(): void} callback {Function} - The callback function.
 * @param {!Object=} opt_scope {Object=} - An optional scope to call the callback in.
 * @return {void}
 */
H.map.Object.prototype.addOnDisposeCallback = function(callback, opt_scope) {};
/**
 * @record
 * @struct
 */
H.map.Object.Options = function() {};
 /** @type {number} */
H.map.Object.Options.prototype.min;
 /** @type {number} */
H.map.Object.Options.prototype.max;
 /** @type {boolean} */
H.map.Object.Options.prototype.visibility;
 /** @type {number} */
H.map.Object.Options.prototype.zIndex;
 /** @type {!H.map.provider.Provider} */
H.map.Object.Options.prototype.provider;
 /** @type {?} */
H.map.Object.Options.prototype.data;

/** @const */
H.map.Object.Type = {};
/** @const {number} */
H.map.Object.Type.ANY;
/** @const {number} */
H.map.Object.Type.OVERLAY;
/** @const {number} */
H.map.Object.Type.SPATIAL;
/** @const {number} */
H.map.Object.Type.MARKER;
/** @const {number} */
H.map.Object.Type.DOM_MARKER;
/** @const {number} */
H.map.Object.Type.GROUP;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.geo.Rect} bounds {H.geo.Rect} - The geographical reactangular area of this overlay
 * @param {(string|!HTMLCanvasElement|!HTMLImageElement)} bitmap {!(string | HTMLImageElement | HTMLCanvasElement)} - Either an image URL, a SVG markup, an image or a canvas.
 * @param {!H.map.Overlay.Options=} opt_options {H.map.Overlay.Options=} - Optional values values to initialize this overlay
 */
H.map.Overlay = function(bounds, bitmap, opt_options) {};

/**
 * This method returns this overlay's current bounds.
 * @return {!H.geo.Rect}
 */
H.map.Overlay.prototype.getBounds = function() {};

/**
 * This method sets the overlay's current bounds.
 * @param {!H.geo.Rect} bounds {H.geo.Rect}
 * @return {!H.map.Overlay}
 */
H.map.Overlay.prototype.setBounds = function(bounds) {};

/**
 * Returns this overlay's current bitmap.
 * @return {(!HTMLCanvasElement|!HTMLImageElement)}
 */
H.map.Overlay.prototype.getBitmap = function() {};

/**
 * Sets the overlay's current bitmap.
 * @param {(string|!HTMLCanvasElement|!HTMLImageElement)} bitmap {!(string | HTMLImageElement | HTMLCanvasElement)} - Either an image URL, a SVG markup, an image or a canvas.
 * @return {!H.map.Overlay}
 */
H.map.Overlay.prototype.setBitmap = function(bitmap) {};

/**
 * Returns this overlay's current opacity.
 * @return {number}
 */
H.map.Overlay.prototype.getOpacity = function() {};

/**
 * Sets the overlay's current opacity.
 * @param {number} opacity {number} - The opacity in range from 0 (transparent) to 1 (opaque).
 * @return {!H.map.Overlay}
 */
H.map.Overlay.prototype.setOpacity = function(opacity) {};
/**
 * @record
 * @struct
 */
H.map.Overlay.Options = function() {};
 /** @type {number} */
H.map.Overlay.Options.prototype.min;
 /** @type {number} */
H.map.Overlay.Options.prototype.max;
 /** @type {number} */
H.map.Overlay.Options.prototype.opacity;
 /** @type {boolean} */
H.map.Overlay.Options.prototype.visibility;
 /** @type {number} */
H.map.Overlay.Options.prototype.zIndex;
 /** @type {!H.map.provider.Provider} */
H.map.Overlay.Options.prototype.provider;
 /** @type {?} */
H.map.Overlay.Options.prototype.data;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.geo.Strip} strip {H.geo.Strip} - the strip describing this polygon's vertices
 * @param {!H.map.Spatial.Options=} opt_options {H.map.Spatial.Options=} - optional initialization parameters
 */
H.map.Polygon = function(strip, opt_options) {};

/**
 * To set the indicator whether this polygon covers the north pole. It's needed for Polygons whose strip is defined as lines arround the world on longitude axis (for example a circle whose
 * center is one of the poles). In this case a additional information is needed to know if the southern or northern part of the world should be covered by the poygon.
 * @param {boolean} flag {boolean} - A value of true means it covers the north pole, false means south pole
 * @return {!H.map.Polygon}
 */
H.map.Polygon.prototype.setNorthPoleCovering = function(flag) {};

/**
 * See H.map.Polygon#setNorthPoleCovering
 * @return {boolean}
 */
H.map.Polygon.prototype.getNorthPoleCovering = function() {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.geo.Strip} strip {H.geo.Strip} - the strip describing this polygon's vertices
 * @param {!H.map.Polyline.Options=} opt_options {H.map.Polyline.Options=} - optional initialization parameters
 */
H.map.Polyline = function(strip, opt_options) {};

/**
 * This method clips this polyline against a rectangular area and returns the intersecting sub-lines.
 * @param {!H.geo.Rect} geoRect {H.geo.Rect}
 * @return {!Array<!Array<number>>}
 */
H.map.Polyline.prototype.clip = function(geoRect) {};
/**
 * @record
 * @struct
 */
H.map.Polyline.Options = function() {};
 /** @type {(!H.map.SpatialStyle|!H.map.SpatialStyle.Options)} */
H.map.Polyline.Options.prototype.style;
 /** @type {(!H.map.ArrowStyle|!H.map.ArrowStyle.Options)} */
H.map.Polyline.Options.prototype.arrows;
 /** @type {boolean} */
H.map.Polyline.Options.prototype.visibility;
 /** @type {number} */
H.map.Polyline.Options.prototype.zIndex;
 /** @type {number} */
H.map.Polyline.Options.prototype.min;
 /** @type {number} */
H.map.Polyline.Options.prototype.max;
 /** @type {!H.map.provider.Provider} */
H.map.Polyline.Options.prototype.provider;
 /** @type {?} */
H.map.Polyline.Options.prototype.data;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.geo.Rect} bounds {H.geo.Rect} - The geographical bounding box for this rectangle
 * @param {!H.map.Spatial.Options=} opt_options {H.map.Spatial.Options=}
 */
H.map.Rect = function(bounds, opt_options) {};

/**
 * To set the bounds of this rectangle.
 * @param {!H.geo.Rect} bounds {H.geo.Rect}
 * @return {void}
 */
H.map.Rect.prototype.setBounds = function(bounds) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {boolean} isClosed {boolean} - Indicates whether this spatial object represents a closed shape
 * @param {!H.map.Spatial.Options=} opt_options {H.map.Spatial.Options=} - The options to apply
 */
H.map.Spatial = function(isClosed, opt_options) {};

/**
 * To get the drawing style of this object. The returned style is treated as immutable and must not be modified afterwards to prevent inconsistancies!
 * @return {!H.map.SpatialStyle}
 */
H.map.Spatial.prototype.getStyle = function() {};

/**
 * To set the drawing style of this object. If the passed opt_style argument is an instance of H.map.SpatialStyle it is treated as immutable and must not be modified afterwards to prevent
 * inconsistancies!
 * @param {(!H.map.SpatialStyle|!H.map.SpatialStyle.Options)=} opt_style {(H.map.SpatialStyle | H.map.SpatialStyle.Options)=} - The style to set. If it evaluates to a falsy the H.map.SpatialStyle.DEFAULT_STYLE is used.
 * @return {!H.map.Spatial}
 */
H.map.Spatial.prototype.setStyle = function(opt_style) {};

/**
 * To get the arrow style of this spatial object or undefined if no style is defined. A returned arrow style is treated as immutable and must not be modified afterwards to prevent
 * inconsistancies!
 * @return {(void|!H.map.ArrowStyle)}
 */
H.map.Spatial.prototype.getArrows = function() {};

/**
 * To set the arrow style of this object.
 * @param {(!H.map.ArrowStyle|!H.map.ArrowStyle.Options)=} opt_arrows {(H.map.ArrowStyle | H.map.ArrowStyle.Options)=} - the arrow style to be applied
 * @return {!H.map.Spatial}
 */
H.map.Spatial.prototype.setArrows = function(opt_arrows) {};

/**
 * Indicates whether this spatial object represents a closed shape
 * @return {boolean}
 */
H.map.Spatial.prototype.isClosed = function() {};
/**
 * @record
 * @struct
 */
H.map.Spatial.Label = function() {};
 /** @type {number} */
H.map.Spatial.Label.prototype.x;
 /** @type {number} */
H.map.Spatial.Label.prototype.y;
 /** @type {number} */
H.map.Spatial.Label.prototype.angle;
 /** @type {string} */
H.map.Spatial.Label.prototype.font;
 /** @type {number} */
H.map.Spatial.Label.prototype.size;
 /** @type {string} */
H.map.Spatial.Label.prototype.color;
 /** @type {string} */
H.map.Spatial.Label.prototype.text;
/**
 * @record
 * @struct
 */
H.map.Spatial.Options = function() {};
 /** @type {(!H.map.SpatialStyle|!H.map.SpatialStyle.Options)} */
H.map.Spatial.Options.prototype.style;
 /** @type {(!H.map.ArrowStyle|!H.map.ArrowStyle.Options)} */
H.map.Spatial.Options.prototype.arrows;
 /** @type {boolean} */
H.map.Spatial.Options.prototype.visibility;
 /** @type {number} */
H.map.Spatial.Options.prototype.zIndex;
 /** @type {number} */
H.map.Spatial.Options.prototype.min;
 /** @type {number} */
H.map.Spatial.Options.prototype.max;
 /** @type {!H.map.provider.Provider} */
H.map.Spatial.Options.prototype.provider;
 /** @type {?} */
H.map.Spatial.Options.prototype.data;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {(!H.map.SpatialStyle|!H.map.SpatialStyle.Options)=} opt_options {(H.map.SpatialStyle | H.map.SpatialStyle.Options)=} - The optional style attributes
 */
H.map.SpatialStyle = function(opt_options) {};
 /** @type {string} */
H.map.SpatialStyle.prototype.strokeColor;
 /** @type {string} */
H.map.SpatialStyle.prototype.fillColor;
 /** @type {number} */
H.map.SpatialStyle.prototype.lineWidth;
 /** @type {string} */
H.map.SpatialStyle.prototype.lineCap;
 /** @type {string} */
H.map.SpatialStyle.prototype.lineJoin;
 /** @type {number} */
H.map.SpatialStyle.prototype.miterLimit;
 /** @type {!Array<number>} */
H.map.SpatialStyle.prototype.lineDash;
 /** @type {number} */
H.map.SpatialStyle.prototype.lineDashOffset;
 /** @type {number} */
H.map.SpatialStyle.MAX_LINE_WIDTH;
 /** @type {!H.map.SpatialStyle} */
H.map.SpatialStyle.DEFAULT_STYLE;

/**
 * This method checks value-equality with another style.
 * @param {(!H.map.SpatialStyle|!H.map.SpatialStyle.Options)} other {(H.map.SpatialStyle | H.map.SpatialStyle.Options)} - the style to compare with
 * @return {boolean}
 */
H.map.SpatialStyle.prototype.equals = function(other) {};

/**
 * Returns a copy of spatial style object and replaces the passed style attributes into it.
 * @param {!H.map.SpatialStyle.Options=} opt_attributes {H.map.SpatialStyle.Options=} - The style attributes to set on the copied style instance
 * @return {!H.map.SpatialStyle}
 */
H.map.SpatialStyle.prototype.getCopy = function(opt_attributes) {};

/** @typedef {string} */
H.map.SpatialStyle.LineCap;

/** @typedef {string} */
H.map.SpatialStyle.LineJoin;
/**
 * @record
 * @struct
 */
H.map.SpatialStyle.Options = function() {};
 /** @type {string} */
H.map.SpatialStyle.Options.prototype.strokeColor;
 /** @type {string} */
H.map.SpatialStyle.Options.prototype.fillColor;
 /** @type {number} */
H.map.SpatialStyle.Options.prototype.lineWidth;
 /** @type {string} */
H.map.SpatialStyle.Options.prototype.lineCap;
 /** @type {string} */
H.map.SpatialStyle.Options.prototype.lineJoin;
 /** @type {number} */
H.map.SpatialStyle.Options.prototype.miterLimit;
 /** @type {!Array<number>} */
H.map.SpatialStyle.Options.prototype.lineDash;
 /** @type {number} */
H.map.SpatialStyle.Options.prototype.lineDashOffset;
/**
 * @extends {H.util.EventTarget}
 * @implements {H.map.IControl}
 * @constructor
 * @struct
 */
H.map.ViewModel = function() {};

/**
 * This method returns the camera data, which is currently rendered.
 * @return {!H.map.ViewModel.CameraData}
 */
H.map.ViewModel.prototype.getCameraData = function() {};

/**
 * This method sets new camera data to be processed by the renderer.
 * @param {!H.map.ViewModel.CameraData} data {H.map.ViewModel.CameraData} - the values to be modified
 * @return {!H.map.ViewModel}
 */
H.map.ViewModel.prototype.setCameraData = function(data) {};

/**
 * This method sets a new zoom level to be processed by the renderer
 * @param {number} zoom {number} - the new zoom level
 * @param {boolean} animate {boolean}
 * @return {void}
 */
H.map.ViewModel.prototype.setZoom = function(zoom, animate) {};

/**
 * This method returns the zoom level that is currently rendered.
 * @return {number}
 */
H.map.ViewModel.prototype.getZoom = function() {};

/**
 * This method returns the currently requested data.
 * @return {!H.map.ViewModel.CameraData}
 */
H.map.ViewModel.prototype.getRequestedCameraData = function() {};

/**
 * A method to signal the begin of a control operation.
 * @param {!H.util.kinetics.IKinetics=} opt_kinetics {H.util.kinetics.IKinetics=} - kinetics settings
 * @param {number=} opt_atX {number=} - x screen coordinate at which control has started
 * @param {number=} opt_atY {number=} - y screen coordinate at which control has started
 * @return {void}
 */
H.map.ViewModel.prototype.startControl = function(opt_kinetics, opt_atX, opt_atY) {};

/**
 * A method to set the values for a continuously modification of the ViewModel on different axes. If the current render engine doesn't support certain modifications then they are ignored.
 * @param {number} moveX {number} - The movement on x-axis as levels per millisecond where a level correlates to the distance between camera and look-at point.
 * @param {number} moveY {number} - The movement on y-axis as levels per millisecond where a level correlates to the distance between camera and look-at point
 * @param {number} moveZ {number} - The movement on z-axis as levels per millisecond.
 * @param {number} angleX {number} - The rotation of on screen's x axis as degrees per millisecond.
 * @param {number} angleY {number} - The rotation of on screen's y axis as degrees per millisecond.
 * @param {number} angleZ {number} - The rotation of on screen's z axis as degrees per millisecond.
 * @param {number=} opt_zoom {number=} - The modification of the zoom level as levels per millisecond
 * @return {void}
 */
H.map.ViewModel.prototype.control = function(moveX, moveY, moveZ, angleX, angleY, angleZ, opt_zoom) {};

/**
 * A method to signal the end of a control operation.
 * @param {boolean=} opt_preventKinetics {boolean=} - A flag to indicate whether a kinetic effect is performed
 * @param {function(!H.map.ViewModel.CameraData): void=} opt_adjustView {function(H.map.ViewModel.CameraData)=} - An callback to adjust the final ViewModel by modifying the passed camera data.
 * @return {void}
 */
H.map.ViewModel.prototype.endControl = function(opt_preventKinetics, opt_adjustView) {};

/**
 * This method will dispatch event on the event target object
 * @param {(string|!H.util.Event)} evt {(H.util.Event | string)} - event object or event name
 * @return {void}
 */
H.map.ViewModel.prototype.dispatchEvent = function(evt) {};

/**
 * Removes listeners from this object. Classes that extend EventTarget may need to override this method in order to remove references to DOM Elements and additional listeners.
 * @return {void}
 */
H.map.ViewModel.prototype.dispose = function() {};

/**
 * This method adds callback which is triggered when the object is being disposed
 * @param {function(): void} callback {Function} - The callback function.
 * @param {!Object=} opt_scope {Object=} - An optional scope to call the callback in.
 * @return {void}
 */
H.map.ViewModel.prototype.addOnDisposeCallback = function(callback, opt_scope) {};
/**
 * @record
 * @struct
 */
H.map.ViewModel.CameraData = function() {};
 /** @type {number} */
H.map.ViewModel.CameraData.prototype.zoom;
 /** @type {!H.geo.IPoint} */
H.map.ViewModel.CameraData.prototype.position;
 /** @type {number} */
H.map.ViewModel.CameraData.prototype.pitch;
 /** @type {number} */
H.map.ViewModel.CameraData.prototype.yaw;
 /** @type {number} */
H.map.ViewModel.CameraData.prototype.roll;
 /** @type {number} */
H.map.ViewModel.CameraData.prototype.fov;
/**
 * @record
 * @struct
 */
H.map.ViewModel.RequestedData = function() {};
 /** @type {!H.map.ViewModel.CameraData} */
H.map.ViewModel.RequestedData.prototype.camera;
 /** @type {number} */
H.map.ViewModel.RequestedData.prototype.zoom;
 /** @type {boolean} */
H.map.ViewModel.RequestedData.prototype.animate;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.ViewModel.RequestedData} requested {H.map.ViewModel.RequestedData}
 */
H.map.ViewModel.UpdateEvent = function(requested) {};
 /** @type {?} */
H.map.ViewModel.UpdateEvent.prototype.target;
 /** @type {?} */
H.map.ViewModel.UpdateEvent.prototype.currentTarget;
 /** @type {string} */
H.map.ViewModel.UpdateEvent.prototype.type;
 /** @type {boolean} */
H.map.ViewModel.UpdateEvent.prototype.defaultPrevented;

/**
 * Sets defaultPrevented to true. Which can be used to prevent some default behavior.
 * @return {void}
 */
H.map.ViewModel.UpdateEvent.prototype.preventDefault = function() {};

/**
 * Stops propagation for current event.
 * @return {void}
 */
H.map.ViewModel.UpdateEvent.prototype.stopPropagation = function() {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!Element} element {Element} - html element were map will be rendered
 * @param {!H.map.ViewPort.Options=} opt_options {H.map.ViewPort.Options=} - optional configuration parameters
 */
H.map.ViewPort = function(element, opt_options) {};
 /** @type {!Element} */
H.map.ViewPort.prototype.element;
 /** @type {number} */
H.map.ViewPort.prototype.width;
 /** @type {number} */
H.map.ViewPort.prototype.height;
 /** @type {number} */
H.map.ViewPort.prototype.margin;
 /** @type {!H.map.ViewPort.Padding} */
H.map.ViewPort.prototype.padding;
 /** @type {!H.math.Point} */
H.map.ViewPort.prototype.center;

/**
 * This method sets the margin on the viewPort
 * @param {number} margin {number} - margin which is used to fetch map data
 * @return {void}
 */
H.map.ViewPort.prototype.setMargin = function(margin) {};

/**
 * This method sets the padding on the viewport. Padding will result in shifted map center which will be the visual center of the padded area.
 * @param {number} top {number} - padding from the top
 * @param {number} right {number} - padding from the right
 * @param {number} bottom {number} - padding from the bottom
 * @param {number} left {number} - padding from the left
 * @return {void}
 */
H.map.ViewPort.prototype.setPadding = function(top, right, bottom, left) {};

/**
 * This method updates size of the viewport according to container size. It must be called whenever the HTML element changed size in order to update the map&#x27;s viewport values.
 * @return {void}
 */
H.map.ViewPort.prototype.resize = function() {};

/**
 * This method starts the interaction with the view port. Should be called every time when new interaction is started i.e mouse grab, or touch start.
 * @param {number} modifiers {number} - a bitmask which specifies what operations should performed during every interaction
 * @param {!H.util.kinetics.IKinetics=} opt_kinetics {H.util.kinetics.IKinetics=} - specifies kinetic move at the end of interaction
 * @return {void}
 */
H.map.ViewPort.prototype.startInteraction = function(modifiers, opt_kinetics) {};

/**
 * This method resolves direct screen (view port) interaction. This function will modify the current view according to values passed in.
 * @param {number} x {number} - viewport x coordinate
 * @param {number} y {number} - viewport y coordinate
 * @param {number=} opt_bx {number=} - x coordinate for second pointer/touch if present
 * @param {number=} opt_by {number=} - y coordinate for secong pointer/touch if present
 * @param {number=} opt_timestamp {number=} - known timestamp which should be passed
 * @return {void}
 */
H.map.ViewPort.prototype.interaction = function(x, y, opt_bx, opt_by, opt_timestamp) {};

/**
 * This method ends interaction and applies kinetic movement if defined by using startInteraction method
 * @param {boolean=} opt_preventKinetics {boolean=} - if set to true will prevent kinetics behaviour at the end of interaction
 * @return {void}
 */
H.map.ViewPort.prototype.endInteraction = function(opt_preventKinetics) {};

/**
 * This method will dispatch event on the event target object
 * @param {(string|!H.util.Event)} evt {(H.util.Event | string)} - event object or event name
 * @return {void}
 */
H.map.ViewPort.prototype.dispatchEvent = function(evt) {};

/**
 * Removes listeners from this object. Classes that extend EventTarget may need to override this method in order to remove references to DOM Elements and additional listeners.
 * @return {void}
 */
H.map.ViewPort.prototype.dispose = function() {};

/**
 * This method adds callback which is triggered when the object is being disposed
 * @param {function(): void} callback {Function} - The callback function.
 * @param {!Object=} opt_scope {Object=} - An optional scope to call the callback in.
 * @return {void}
 */
H.map.ViewPort.prototype.addOnDisposeCallback = function(callback, opt_scope) {};
/**
 * @record
 * @struct
 */
H.map.ViewPort.Options = function() {};
 /** @type {number} */
H.map.ViewPort.Options.prototype.margin;
 /** @type {!H.map.ViewPort.Padding} */
H.map.ViewPort.Options.prototype.padding;
 /** @type {boolean} */
H.map.ViewPort.Options.prototype.fixedCenter;
/**
 * @record
 * @struct
 */
H.map.ViewPort.Padding = function() {};
 /** @type {number} */
H.map.ViewPort.Padding.prototype.top;
 /** @type {number} */
H.map.ViewPort.Padding.prototype.right;
 /** @type {number} */
H.map.ViewPort.Padding.prototype.bottom;
 /** @type {number} */
H.map.ViewPort.Padding.prototype.left;
/** @const */
H.map.layer = {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.provider.TileProvider} provider {H.map.provider.TileProvider} - data source for the TileLayer
 * @param {!H.map.layer.ITileLayer.Options=} opt_options {H.map.layer.ITileLayer.Options=} - additional options
 */
H.map.layer.BaseTileLayer = function(provider, opt_options) {};

/**
 * This method returns the provider which feeds this layer with data.
 * @return {!H.map.provider.TileProvider}
 */
H.map.layer.BaseTileLayer.prototype.getProvider = function() {};

/**
 * This method transforms a geo-rectangle to geometrical projected rectangle at the current projection zoom level or at provided zoom level
 * @param {!H.geo.Rect} geoRect {H.geo.Rect} - geo bounds to be projected
 * @param {number=} opt_zoom {number=} - overrides current projection zoom level
 * @return {!H.math.Rect}
 */
H.map.layer.BaseTileLayer.prototype.geoRectToRect = function(geoRect, opt_zoom) {};

/**
 * This method returns tile grid for a bounding rectangle
 * @param {!H.math.Rect} rectBounds {H.math.Rect} - projected rect bounds which coorespond to geo bounding box
 * @param {number} zoom {number} - current zoom level
 * @return {!H.math.Rect}
 */
H.map.layer.BaseTileLayer.prototype.getTileBounds = function(rectBounds, zoom) {};

/**
 * This method requests a single tile according to tile coordinates. It returns either a Tile object if it is already loaded or undefined and starts loading the tile
 * @param {number} x {number} - tile row position
 * @param {number} y {number} - tile column position
 * @param {number} z {number} - The zoom level for which the tile is requested
 * @param {boolean} cacheOnly {boolean} - indicates whether only cached tiles are to be considered
 * @return {(void|!H.map.provider.Tile)}
 */
H.map.layer.BaseTileLayer.prototype.requestTile = function(x, y, z, cacheOnly) {};

/**
 * This method cancels a previously requested tile.
 * @param {number} x {number} - tile row position
 * @param {number} y {number} - tile column position
 * @param {number} z {number} - zoom level
 * @return {void}
 */
H.map.layer.BaseTileLayer.prototype.cancelTile = function(x, y, z) {};

/**
 * This method requests tiles from the data source (provider). It can return a set of tiles which are currently loaded. All tiles which are not yet loaded will be included in response
 * as soon as they will be available during subsequent calls.
 * @param {!H.math.Rect} tileBounds {H.math.Rect} - bounds in tile grid
 * @param {boolean} isCDB {boolean}
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @param {!H.math.Point} prioCenter {H.math.Point} - The priority center as an offset in screen pixel relative to the center
 * @return {!H.map.layer.ITileLayer.Response}
 */
H.map.layer.BaseTileLayer.prototype.getProviderTiles = function(tileBounds, isCDB, zoomLevel, cacheOnly, prioCenter) {};
/**
 * @record
 * @struct
 */
H.map.layer.IMarkerLayer = function() {};

/**
 * This method requests marker objects for provided bounding rectangle.
 * @param {!H.geo.Rect} boundingRect {H.geo.Rect} - the bounding rectangle for which marker are to be returned
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @param {!H.math.Point} prioCenter {H.math.Point} - The priority center as an offset in screen pixel relative to the center
 * @return {(!H.map.layer.IMarkerLayer.Response|!H.map.layer.IMarkerLayer.TiledResponse)}
 */
H.map.layer.IMarkerLayer.prototype.requestMarkers = function(boundingRect, zoomLevel, cacheOnly, prioCenter) {};

/**
 * This method requests dom marker objects for provided bounding rectangle.
 * @param {!H.geo.Rect} boundingRect {H.geo.Rect} - the bounding rectangle for which marker are to be returned
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @param {!H.math.Point} prioCenter {H.math.Point} - The priority center as an offset in screen pixel relative to the center
 * @return {(!H.map.layer.IMarkerLayer.Response|!H.map.layer.IMarkerLayer.TiledResponse)}
 */
H.map.layer.IMarkerLayer.prototype.requestDomMarkers = function(boundingRect, zoomLevel, cacheOnly, prioCenter) {};
/**
 * @record
 * @struct
 */
H.map.layer.IMarkerLayer.Response = function() {};
 /** @type {number} */
H.map.layer.IMarkerLayer.Response.prototype.total;
 /** @type {!Array<!H.map.AbstractMarker>} */
H.map.layer.IMarkerLayer.Response.prototype.markers;
/**
 * @record
 * @struct
 */
H.map.layer.IMarkerLayer.TiledResponse = function() {};
 /** @type {number} */
H.map.layer.IMarkerLayer.TiledResponse.prototype.number;
 /** @type {number} */
H.map.layer.IMarkerLayer.TiledResponse.prototype.requested;
 /** @type {!Array<!H.map.AbstractMarker>} */
H.map.layer.IMarkerLayer.TiledResponse.prototype.objects;
/**
 * @record
 * @struct
 */
H.map.layer.ITileLayer = function() {};

/**
 * This method requests tiles for the current bounding rectangle at the given zoom level (z-value).
 * @param {!H.geo.Rect} boundingRect {H.geo.Rect} - the bounding rectangle for which tiles are to be returned
 * @param {number} zoomLevel {number} - The zoom level for which the tiles are requested
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached tiles are to be considered
 * @param {!H.math.Point} prioCenter {H.math.Point} - The priority center as an offset in screen pixel relative to the center
 * @return {!H.map.layer.ITileLayer.Response}
 */
H.map.layer.ITileLayer.prototype.requestTiles = function(boundingRect, zoomLevel, cacheOnly, prioCenter) {};

/**
 * This method requests a single tile according to tile coordinates. It returns either a Tile object if it is already loaded or undefined and starts loading the tile
 * @param {number} x {number} - tile row position
 * @param {number} y {number} - tile column position
 * @param {number} z {number} - The zoom level for which the tile is requested
 * @param {boolean} cacheOnly {boolean} - indicates whether only cached tiles are to be considered
 * @return {(void|!H.map.provider.Tile)}
 */
H.map.layer.ITileLayer.prototype.requestTile = function(x, y, z, cacheOnly) {};

/**
 * This method cancels a previously requested tile.
 * @param {number} x {number} - tile row position
 * @param {number} y {number} - tile column position
 * @param {number} z {number} - zoom level
 * @return {void}
 */
H.map.layer.ITileLayer.prototype.cancelTile = function(x, y, z) {};
/**
 * @record
 * @struct
 */
H.map.layer.ITileLayer.Options = function() {};
 /** @type {!H.geo.IProjection} */
H.map.layer.ITileLayer.Options.prototype.projection;
 /** @type {number} */
H.map.layer.ITileLayer.Options.prototype.opacity;
/**
 * @record
 * @struct
 */
H.map.layer.ITileLayer.Response = function() {};
 /** @type {number} */
H.map.layer.ITileLayer.Response.prototype.total;
 /** @type {!Array<!H.map.provider.Tile>} */
H.map.layer.ITileLayer.Response.prototype.tiles;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.layer.Layer.Options=} opt_options {H.map.layer.Layer.Options=} - optional configuration object
 */
H.map.layer.Layer = function(opt_options) {};

/**
 * This method checks if a zoom level can be served by this layer.
 * @param {number} zoomLevel {number} - the zoom level to check
 * @return {boolean}
 */
H.map.layer.Layer.prototype.isValid = function(zoomLevel) {};

/**
 * This method sets the minimum zoom level for which this layer will provide tiles.
 * @param {number} min {number} - The new minimum zoom level of this layer
 * @return {!H.map.layer.Layer}
 */
H.map.layer.Layer.prototype.setMin = function(min) {};

/**
 * This method sets the maximum zoom level for which this layer will provide tiles.
 * @param {number} max {number} - The new maximum zoom level of this layer
 * @return {!H.map.layer.Layer}
 */
H.map.layer.Layer.prototype.setMax = function(max) {};

/**
 * This method returns the copyright of the current data provider.
 * @param {!H.geo.Rect} bounds {H.geo.Rect} - the bounding area for which to retrieve the copyright information
 * @param {number} level {number} - the zoom level for which to retrieve the copyright information
 * @return {!Array<!H.map.ICopyright>}
 */
H.map.layer.Layer.prototype.getCopyrights = function(bounds, level) {};

/**
 * This method will dispatch event on the event target object
 * @param {(string|!H.util.Event)} evt {(H.util.Event | string)} - event object or event name
 * @return {void}
 */
H.map.layer.Layer.prototype.dispatchEvent = function(evt) {};

/**
 * Removes listeners from this object. Classes that extend EventTarget may need to override this method in order to remove references to DOM Elements and additional listeners.
 * @return {void}
 */
H.map.layer.Layer.prototype.dispose = function() {};

/**
 * This method adds callback which is triggered when the object is being disposed
 * @param {function(): void} callback {Function} - The callback function.
 * @param {!Object=} opt_scope {Object=} - An optional scope to call the callback in.
 * @return {void}
 */
H.map.layer.Layer.prototype.addOnDisposeCallback = function(callback, opt_scope) {};
/**
 * @record
 * @struct
 */
H.map.layer.Layer.Options = function() {};
 /** @type {number} */
H.map.layer.Layer.Options.prototype.min;
 /** @type {number} */
H.map.layer.Layer.Options.prototype.max;
 /** @type {boolean} */
H.map.layer.Layer.Options.prototype.dark;
 /** @type {!H.geo.IProjection} */
H.map.layer.Layer.Options.prototype.projection;
 /** @type {number} */
H.map.layer.Layer.Options.prototype.minWorldSize;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.provider.MarkerTileProvider} provider {H.map.provider.MarkerTileProvider}
 * @param {!H.map.layer.ITileLayer.Options=} opt_options {H.map.layer.ITileLayer.Options=}
 */
H.map.layer.MarkerTileLayer = function(provider, opt_options) {};

/**
 * This method requests marker objects for provided bounding rectangle.
 * @param {!H.geo.Rect} boundingRect {H.geo.Rect} - the bounding rectangle for which marker are to be returned
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @param {!H.math.Point} prioCenter {H.math.Point} - The priority center as an offset in screen pixel relative to the center
 * @return {(!H.map.layer.IMarkerLayer.Response|!H.map.layer.IMarkerLayer.TiledResponse)}
 */
H.map.layer.MarkerTileLayer.prototype.requestMarkers = function(boundingRect, zoomLevel, cacheOnly, prioCenter) {};

/**
 * This method requests dom marker objects for provided bounding rectangle.
 * @param {!H.geo.Rect} boundingRect {H.geo.Rect} - the bounding rectangle for which marker are to be returned
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @param {!H.math.Point} prioCenter {H.math.Point} - The priority center as an offset in screen pixel relative to the center
 * @return {(!H.map.layer.IMarkerLayer.Response|!H.map.layer.IMarkerLayer.TiledResponse)}
 */
H.map.layer.MarkerTileLayer.prototype.requestDomMarkers = function(boundingRect, zoomLevel, cacheOnly, prioCenter) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {(!H.clustering.Provider|!H.map.provider.ObjectProvider)} provider {H.map.provider.ObjectProvider} - the ObjectProvider which provides the map objects to this object layer.
 * @param {!H.map.layer.ObjectLayer.Options=} opt_options {H.map.layer.ObjectLayer.Options=} - The options for this layer
 */
H.map.layer.ObjectLayer = function(provider, opt_options) {};

/**
 * This method returns current ObjectLayer's data provider
 * @return {!H.map.provider.ObjectProvider}
 */
H.map.layer.ObjectLayer.prototype.getProvider = function() {};

/**
 * To request overlay objects for the passsed bounding rectangle. It returns all overlay objects which are contained within this bounding rectangle.
 * @param {!H.geo.Rect} bounds {H.geo.Rect} - The bounding rectangle for which overlays are to be returned
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @param {!H.math.Point} prioCenter {H.math.Point} - The priority center as an offset in screen pixel relative to the center
 * @return {!H.map.layer.ObjectLayer.OverlaysResponse}
 */
H.map.layer.ObjectLayer.prototype.requestOverlays = function(bounds, zoomLevel, cacheOnly, prioCenter) {};

/**
 * This method requests tiles for the current bounding rectangle at the given zoom level (z-value).
 * @param {!H.geo.Rect} boundingRect {H.geo.Rect} - the bounding rectangle for which tiles are to be returned
 * @param {number} zoomLevel {number} - The zoom level for which the tiles are requested
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached tiles are to be considered
 * @param {!H.math.Point} prioCenter {H.math.Point} - The priority center as an offset in screen pixel relative to the center
 * @return {!H.map.layer.ITileLayer.Response}
 */
H.map.layer.ObjectLayer.prototype.requestTiles = function(boundingRect, zoomLevel, cacheOnly, prioCenter) {};

/**
 * This method requests a single tile according to tile coordinates. It returns either a Tile object if it is already loaded or undefined and starts loading the tile
 * @param {number} x {number} - tile row position
 * @param {number} y {number} - tile column position
 * @param {number} z {number} - The zoom level for which the tile is requested
 * @param {boolean} cacheOnly {boolean} - indicates whether only cached tiles are to be considered
 * @return {(void|!H.map.provider.Tile)}
 */
H.map.layer.ObjectLayer.prototype.requestTile = function(x, y, z, cacheOnly) {};

/**
 * This method cancels a previously requested tile.
 * @param {number} x {number} - tile row position
 * @param {number} y {number} - tile column position
 * @param {number} z {number} - zoom level
 * @return {void}
 */
H.map.layer.ObjectLayer.prototype.cancelTile = function(x, y, z) {};

/**
 * This method requests marker objects for provided bounding rectangle.
 * @param {!H.geo.Rect} boundingRect {H.geo.Rect} - the bounding rectangle for which marker are to be returned
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @param {!H.math.Point} prioCenter {H.math.Point} - The priority center as an offset in screen pixel relative to the center
 * @return {(!H.map.layer.IMarkerLayer.Response|!H.map.layer.IMarkerLayer.TiledResponse)}
 */
H.map.layer.ObjectLayer.prototype.requestMarkers = function(boundingRect, zoomLevel, cacheOnly, prioCenter) {};

/**
 * This method requests dom marker objects for provided bounding rectangle.
 * @param {!H.geo.Rect} boundingRect {H.geo.Rect} - the bounding rectangle for which marker are to be returned
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @param {!H.math.Point} prioCenter {H.math.Point} - The priority center as an offset in screen pixel relative to the center
 * @return {(!H.map.layer.IMarkerLayer.Response|!H.map.layer.IMarkerLayer.TiledResponse)}
 */
H.map.layer.ObjectLayer.prototype.requestDomMarkers = function(boundingRect, zoomLevel, cacheOnly, prioCenter) {};
/**
 * @record
 * @struct
 */
H.map.layer.ObjectLayer.Options = function() {};
 /** @type {number} */
H.map.layer.ObjectLayer.Options.prototype.tileSize;
 /** @type {number} */
H.map.layer.ObjectLayer.Options.prototype.tileCacheSize;
 /** @type {number} */
H.map.layer.ObjectLayer.Options.prototype.dataCacheSize;
 /** @type {number} */
H.map.layer.ObjectLayer.Options.prototype.pixelRatio;
/**
 * @record
 * @struct
 */
H.map.layer.ObjectLayer.OverlaysResponse = function() {};
 /** @type {number} */
H.map.layer.ObjectLayer.OverlaysResponse.prototype.total;
 /** @type {!Array<!H.map.Overlay>} */
H.map.layer.ObjectLayer.OverlaysResponse.prototype.overlays;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.provider.TileProvider} provider {H.map.provider.TileProvider} - data source for the TileLayer
 * @param {!H.map.layer.ITileLayer.Options=} opt_options {H.map.layer.ITileLayer.Options=} - additional options
 */
H.map.layer.TileLayer = function(provider, opt_options) {};
 /** @type {!H.util.Event} */
H.map.layer.TileLayer.prototype.update;

/**
 * This method requests tiles for the current bounding rectangle at the given zoom level (z-value).
 * @param {!H.geo.Rect} boundingRect {H.geo.Rect} - the bounding rectangle for which tiles are to be returned
 * @param {number} zoomLevel {number} - The zoom level for which the tiles are requested
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached tiles are to be considered
 * @param {!H.math.Point} prioCenter {H.math.Point} - The priority center as an offset in screen pixel relative to the center
 * @return {!H.map.layer.ITileLayer.Response}
 */
H.map.layer.TileLayer.prototype.requestTiles = function(boundingRect, zoomLevel, cacheOnly, prioCenter) {};
/** @const */
H.map.provider = {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.provider.ImageTileProvider.Options} options {H.map.provider.ImageTileProvider.Options} - configuration for tile provider
 */
H.map.provider.ImageTileProvider = function(options) {};
 /** @type {number} */
H.map.provider.ImageTileProvider.prototype.tileSize;
/**
 * @record
 * @struct
 */
H.map.provider.ImageTileProvider.Options = function() {};
 /** @type {string} */
H.map.provider.ImageTileProvider.Options.prototype.uri;
 /** @type {number} */
H.map.provider.ImageTileProvider.Options.prototype.min;
 /** @type {number} */
H.map.provider.ImageTileProvider.Options.prototype.max;
 /** @type {number} */
H.map.provider.ImageTileProvider.Options.prototype.tileSize;
 /** @type {(string|boolean)} */
H.map.provider.ImageTileProvider.Options.prototype.crossOrigin;

/**
 * @param {!H.geo.Rect} rect
 * @param {number} n
 * @return {!Array<!H.map.ICopyright>}
 */
H.map.provider.ImageTileProvider.Options.prototype.getCopyrights = function(rect, n) {};

/**
 * @param {number} n1
 * @param {number} n2
 * @param {number} n3
 * @return {string}
 */
H.map.provider.ImageTileProvider.Options.prototype.getURL = function(n1, n2, n3) {};
/**
 * @constructor
 * @struct
 */
H.map.provider.Invalidations = function() {};
 /** @type {?} */
H.map.provider.Invalidations.MARK_INITIAL;

/**
 * To update invalidation marks accordingly to the given the invalidation types.
 * @param {?} mark {H.map.provider.Invalidations.Mark} - The invalidation mark to set
 * @param {number} types {H.math.BitMask} - The descrete invalidation types to update
 * @return {void}
 */
H.map.provider.Invalidations.prototype.update = function(mark, types) {};

/**
 * This method returns the current invalidation mark of this invalidations object.
 * @return {?}
 */
H.map.provider.Invalidations.prototype.getMark = function() {};

/**
 * Checks whether any change occurred after the specified since mark
 * @param {?} since {H.map.provider.Invalidations.Mark} - The invalidation mark to check against
 * @return {boolean}
 */
H.map.provider.Invalidations.prototype.isAny = function(since) {};

/**
 * Checks whether a visual change occurred after the specified since mark
 * @param {?} since {H.map.provider.Invalidations.Mark} - The invalidation mark to check against
 * @return {boolean}
 */
H.map.provider.Invalidations.prototype.isVisual = function(since) {};

/**
 * Checks whether a spatial change occurred after the specified since mark
 * @param {?} since {H.map.provider.Invalidations.Mark} - The invalidation mark to check against
 * @return {boolean}
 */
H.map.provider.Invalidations.prototype.isSpatial = function(since) {};

/**
 * Checks whether an add-operation occurred after the specified since mark
 * @param {?} since {H.map.provider.Invalidations.Mark} - The invalidation mark to check against
 * @return {boolean}
 */
H.map.provider.Invalidations.prototype.isAdd = function(since) {};

/**
 * Checks whether a remove operation occurred after the specified since mark
 * @param {?} since {H.map.provider.Invalidations.Mark} - The invalidation mark to check against
 * @return {boolean}
 */
H.map.provider.Invalidations.prototype.isRemove = function(since) {};

/**
 * Checks whether a z-order change occurred after the specified since mark
 * @param {?} since {H.map.provider.Invalidations.Mark} - The invalidation mark to check against
 * @return {boolean}
 */
H.map.provider.Invalidations.prototype.isZOrder = function(since) {};

/** @const */
H.map.provider.Invalidations.Flag = {};
/** @const {number} */
H.map.provider.Invalidations.Flag.NONE;
/** @const {number} */
H.map.provider.Invalidations.Flag.VISUAL;
/** @const {number} */
H.map.provider.Invalidations.Flag.SPATIAL;
/** @const {number} */
H.map.provider.Invalidations.Flag.ADD;
/** @const {number} */
H.map.provider.Invalidations.Flag.REMOVE;
/** @const {number} */
H.map.provider.Invalidations.Flag.Z_ORDER;

/** @typedef {?} */
H.map.provider.Invalidations.Mark;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.provider.MarkerTileProvider.Options} options {H.map.provider.MarkerTileProvider.Options} - configuration for tile provider
 */
H.map.provider.MarkerTileProvider = function(options) {};

/**
 * To signal to this provider that a map object has been changed. The method marks tile, that contains that object as invalid and triggers dispatchUpdate()
 * @param {!H.map.AbstractMarker} marker {!H.map.AbstractMarker} - The map object to be invalidated
 * @param {number} flags {H.math.BitMask} - The flags indicating the types of occurred changes
 * @return {void}
 */
H.map.provider.MarkerTileProvider.prototype.invalidateObject = function(marker, flags) {};

/**
 * Checks whether this provider is currently providing H.map.DomMarker map objects.
 * @return {boolean}
 */
H.map.provider.MarkerTileProvider.prototype.providesDomMarkers = function() {};
/**
 * @record
 * @struct
 */
H.map.provider.MarkerTileProvider.Options = function() {};
 /** @type {number} */
H.map.provider.MarkerTileProvider.Options.prototype.min;
 /** @type {number} */
H.map.provider.MarkerTileProvider.Options.prototype.max;
 /** @type {boolean} */
H.map.provider.MarkerTileProvider.Options.prototype.providesDomMarkers;

/**
 * @param {number} n1
 * @param {number} n2
 * @param {number} n3
 * @param {function(!Array<!H.map.AbstractMarker>): void} markerCallback
 * @param {function(): void} f
 * @return {!H.util.ICancelable}
 */
H.map.provider.MarkerTileProvider.Options.prototype.requestData = function(n1, n2, n3, markerCallback, f) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.provider.Provider.Options=} opt_options {H.map.provider.Provider.Options=}
 */
H.map.provider.ObjectProvider = function(opt_options) {};

/**
 * Returns the accumulate invalidations of this provider's objects that have occurred.
 * @param {H.map.Object.Type=} opt_type {H.map.Object.Type=} - The type of objects to consider for the invalidations. If undefined, all types are taken into account.
 * @return {!H.map.provider.Invalidations}
 */
H.map.provider.ObjectProvider.prototype.getInvalidations = function(opt_type) {};

/**
 * To signal to this provider that a map object has been changed. The method updates the Invalidations of this provider and the given map object and triggers dispatchUpdate()
 * @param {!H.map.Object} mapObject {!H.map.Object} - The map object to be invalidated
 * @param {number} changes {H.math.BitMask} - The flags indicating the types of occurred changes
 * @return {void}
 */
H.map.provider.ObjectProvider.prototype.invalidateObject = function(mapObject, changes) {};

/**
 * Checks whether this provider is currently providing overlay map objects. A concrete implementation of ObjectProvider must override it if it currently provides overlays.
 * @return {boolean}
 */
H.map.provider.ObjectProvider.prototype.providesOverlays = function() {};

/**
 * Returns all Overlay objects which intersect with the provided area.
 * @param {!H.geo.Rect} geoRect {H.geo.Rect} - A rectangular area in geo space to intersect with
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} visiblesOnly {boolean} - Indicates whether only invisible objects are to be considered
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @return {!Array<!H.map.Overlay>}
 */
H.map.provider.ObjectProvider.prototype.requestOverlays = function(geoRect, zoomLevel, visiblesOnly, cacheOnly) {};

/**
 * Checks whether this provider is currently providing spatial map objects. A concrete implementation of ObjectProvider must override it if it currently provides Spatials.
 * @return {boolean}
 */
H.map.provider.ObjectProvider.prototype.providesSpatials = function() {};

/**
 * Returns all polyline, polygon, circle and rect objects which intersect with the provided area.
 * @param {!H.geo.Rect} geoRect {H.geo.Rect} - A rectangular area in geo space to intersect with
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} visiblesOnly {boolean} - Indicates whether only invisible objects are to be considered
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @return {!Array<!H.map.Spatial>}
 */
H.map.provider.ObjectProvider.prototype.requestSpatials = function(geoRect, zoomLevel, visiblesOnly, cacheOnly) {};

/**
 * Returns the spatial objects which intersect the given tile
 * @param {!H.map.provider.Tile} tile {H.map.provider.SpatialTile} - The tile for which the objects are requested
 * @param {boolean} visiblesOnly {boolean} - Indicates whether only invisible objects are to be considered
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @return {!Array<!H.map.Spatial>}
 */
H.map.provider.ObjectProvider.prototype.requestSpatialsByTile = function(tile, visiblesOnly, cacheOnly) {};

/**
 * Checks whether this provider is currently providing Marker map objects. A concrete implementation of ObjectProvider must override it if it currently provides Markers.
 * @return {boolean}
 */
H.map.provider.ObjectProvider.prototype.providesMarkers = function() {};

/**
 * Returns all Marker map objects which intersect with the provided rectangular area.
 * @param {!H.geo.Rect} geoRect {H.geo.Rect} - A rectangular area in geo space to intersect with
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} visiblesOnly {boolean} - Indicates whether only invisible objects are to be considered
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @return {!Array<!H.map.Marker>}
 */
H.map.provider.ObjectProvider.prototype.requestMarkers = function(geoRect, zoomLevel, visiblesOnly, cacheOnly) {};

/**
 * Checks whether this provider is currently providing DomMarker map objects. A concrete implementation of ObjectProvider must override it if it currently provides Markers.
 * @return {boolean}
 */
H.map.provider.ObjectProvider.prototype.providesDomMarkers = function() {};

/**
 * Returns all DomMarker map objects which intersect with the provided rectangular area.
 * @param {!H.geo.Rect} geoRect {H.geo.Rect} - A rectangular area in geo space to intersect with
 * @param {number} zoomLevel {number} - The zoom level for which the objects are requested
 * @param {boolean} visiblesOnly {boolean} - Indicates whether only invisible objects are to be considered
 * @param {boolean} cacheOnly {boolean} - Indicates whether only cached objects are to be considered
 * @return {!Array<!H.map.DomMarker>}
 */
H.map.provider.ObjectProvider.prototype.requestDomMarkers = function(geoRect, zoomLevel, visiblesOnly, cacheOnly) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.provider.Provider.Options=} opt_options {H.map.provider.Provider.Options=}
 */
H.map.provider.Provider = function(opt_options) {};
 /** @type {string} */
H.map.provider.Provider.prototype.uri;
 /** @type {number} */
H.map.provider.Provider.prototype.min;
 /** @type {number} */
H.map.provider.Provider.prototype.max;
 /** @type {string} */
H.map.provider.Provider.prototype.uid;

/**
 * This method returns the copyrights of the provided content for a certain geographical area at a specified zoom level.
 * @param {!H.geo.Rect} bounds {H.geo.Rect} - The bounding area for which to retrieve the copyright information
 * @param {number} level {number} - The zoom level for which to retrieve the copyright information
 * @return {!Array<!H.map.ICopyright>}
 */
H.map.provider.Provider.prototype.getCopyrights = function(bounds, level) {};

/**
 * This method will dispatch event on the event target object
 * @param {(string|!H.util.Event)} evt {(H.util.Event | string)} - event object or event name
 * @return {void}
 */
H.map.provider.Provider.prototype.dispatchEvent = function(evt) {};

/**
 * Removes listeners from this object. Classes that extend EventTarget may need to override this method in order to remove references to DOM Elements and additional listeners.
 * @return {void}
 */
H.map.provider.Provider.prototype.dispose = function() {};

/**
 * This method adds callback which is triggered when the object is being disposed
 * @param {function(): void} callback {Function} - The callback function.
 * @param {!Object=} opt_scope {Object=} - An optional scope to call the callback in.
 * @return {void}
 */
H.map.provider.Provider.prototype.addOnDisposeCallback = function(callback, opt_scope) {};
/**
 * @record
 * @struct
 */
H.map.provider.Provider.Options = function() {};
 /** @type {string} */
H.map.provider.Provider.Options.prototype.uri;
 /** @type {number} */
H.map.provider.Provider.Options.prototype.min;
 /** @type {number} */
H.map.provider.Provider.Options.prototype.max;

/**
 * @param {!H.geo.Rect} rect
 * @param {number} n
 * @return {!Array<!H.map.ICopyright>}
 */
H.map.provider.Provider.Options.prototype.getCopyrights = function(rect, n) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.provider.TileProvider.Options} options {H.map.provider.TileProvider.Options} - The options to instantiate this TileProvider
 */
H.map.provider.RemoteTileProvider = function(options) {};

/**
 * This method returns cache which should be used to store tiles
 * @return {!H.util.ICache}
 */
H.map.provider.RemoteTileProvider.prototype.getCache = function() {};

/**
 * This method request tile from remote service
 * @param {number} x {number} - The row number of the tile
 * @param {number} y {number} - The column number of the tile
 * @param {number} z {number} - The zoom level for which the tile is requested
 * @param {function((!HTMLCanvasElement|!Array<!H.map.Object>|!HTMLImageElement|!ArrayBuffer), ?): void=} onResponse {function((Array<H.map.Object> | HTMLImageElement | HTMLCanvasElement | ArrayBuffer | null), *=)} - function which is called after response arrives
 * @param {function(string): void=} onError {function(string=)} - function which is called in case of communication error
 * @param {?=} opt_priority {H.net.Request.Priority=} - optional request priority level
 * @return {!H.util.ICancelable}
 */
H.map.provider.RemoteTileProvider.prototype.requestInternal = function(x, y, z, onResponse, onError, opt_priority) {};

/**
 * This method instructs the provider to reload data from it's source.
 * @param {boolean} hard {boolean} - a boolean flag indicating whether to invalidate in hard mode (true) or in soft mode (false);
 * @return {void}
 */
H.map.provider.RemoteTileProvider.prototype.reload = function(hard) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {number} x {number} - x tile coordinate (row)
 * @param {number} y {number} - y tile coordinate (column)
 * @param {number} z {number} - tile zoom level
 * @param {?=} data {*} - generic data object which cooresponds to the given coordinates
 */
H.map.provider.Tile = function(x, y, z, data) {};
 /** @type {string} */
H.map.provider.Tile.prototype.key;
 /** @type {?} */
H.map.provider.Tile.prototype.data;
 /** @type {boolean} */
H.map.provider.Tile.prototype.valid;
 /** @type {number} */
H.map.provider.Tile.prototype.x;
 /** @type {number} */
H.map.provider.Tile.prototype.y;
 /** @type {number} */
H.map.provider.Tile.prototype.z;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.provider.TileProvider.Options} options {H.map.provider.TileProvider.Options} - The options to instantiate this TileProvider
 */
H.map.provider.TileProvider = function(options) {};
 /** @type {?} */
H.map.provider.TileProvider.prototype.requestTile;
 /** @type {?} */
H.map.provider.TileProvider.prototype.cancelTile;
 /** @type {?} */
H.map.provider.TileProvider.prototype.cancelTileByKey;
 /** @type {string} */
H.map.provider.TileProvider.prototype.uri;
 /** @type {number} */
H.map.provider.TileProvider.prototype.min;
 /** @type {number} */
H.map.provider.TileProvider.prototype.max;
 /** @type {string} */
H.map.provider.TileProvider.prototype.uid;

/**
 * This method creates a tile object with given parameters
 * @param {number} x {number} - x tile coordinate (row)
 * @param {number} y {number} - y tile coordinate (column)
 * @param {number} z {number} - tile coordinate (zoom)
 * @param {(!HTMLCanvasElement|!HTMLImageElement)} data {(HTMLImageElement | HTMLCanvasElement)} - data for the tile
 * @param {!Object<string,?>=} opt_options {Object<string, *>=} - free form options object. These options are meant to be used in tile specific rendering cases
 * @return {!H.map.provider.Tile}
 */
H.map.provider.TileProvider.prototype.createTileInternal = function(x, y, z, data, opt_options) {};

/**
 * This method creates a tile key consisting of the provider&#x27;s uri, and the tile&#x27;s x, y and z coordinates, seperated by underscores e.g.: &quot;4711_7_42_23&quot;
 * @param {number} x {number} - The x tile coordinate (row)
 * @param {number} y {number} - The y tile coordinate (column)
 * @param {number} z {number} - The z tile coordinate (zoom level)
 * @return {string}
 */
H.map.provider.TileProvider.prototype.getTileKey = function(x, y, z) {};
/**
 * @record
 * @struct
 */
H.map.provider.TileProvider.Options = function() {};
 /** @type {string} */
H.map.provider.TileProvider.Options.prototype.uri;
 /** @type {number} */
H.map.provider.TileProvider.Options.prototype.min;
 /** @type {number} */
H.map.provider.TileProvider.Options.prototype.max;
 /** @type {number} */
H.map.provider.TileProvider.Options.prototype.tileSize;

/**
 * @param {!H.geo.Rect} rect
 * @param {number} number
 * @return {!Array<!H.map.ICopyright>}
 */
H.map.provider.TileProvider.Options.prototype.getCopyrights = function(rect, number) {};
/** @const */
H.mapevents = {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.mapevents.MapEvents} mapEvents {H.mapevents.MapEvents} - previously initialized map events instance
 * @param {!H.mapevents.Behavior.Options=} options {H.mapevents.Behavior.Options} - additional options (i.e kinetics)
 */
H.mapevents.Behavior = function(mapEvents, options) {};
 /** @type {number} */
H.mapevents.Behavior.DRAGGING;
 /** @type {number} */
H.mapevents.Behavior.WHEELZOOM;
 /** @type {number} */
H.mapevents.Behavior.DBLTAPZOOM;

/**
 * This method destroys all map interaction handling. Should be used when the behavior functionality is disposed. Behavior object will also be disposed (this function will be called)
 * when attached H.mapevents.MapEvents object is dispose.
 * @return {void}
 */
H.mapevents.Behavior.prototype.dispose = function() {};

/**
 * This method disables the behavior functionality for the map
 * @param {number=} opt_behavior {number=} - The bitmask of behaviors to disable. If no arguments are passed, all behaviors will be disabled.
 * @return {void}
 */
H.mapevents.Behavior.prototype.disable = function(opt_behavior) {};

/**
 * This method re-enables the behavior functionality for the map.
 * @param {number=} opt_behavior {number=} - The bitmask of behaviors to enable. If no arguments are passed, all behaviors will be enabled.
 * @return {void}
 */
H.mapevents.Behavior.prototype.enable = function(opt_behavior) {};

/**
 * This method checks if certain functionality is enabled
 * @param {number} behavior {number} - value like H.mapevents.Behavior.DRAGGING which the check is being performed
 * @return {boolean}
 */
H.mapevents.Behavior.prototype.isEnabled = function(behavior) {};
/**
 * @record
 * @struct
 */
H.mapevents.Behavior.Options = function() {};
 /** @type {!H.util.kinetics.IKinetics} */
H.mapevents.Behavior.Options.prototype.kinetics;
 /** @type {number} */
H.mapevents.Behavior.Options.prototype.enable;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {number} viewportX {number} - The x coordinate on the viewport
 * @param {number} viewportY {number} - The y coordinate on the viewport
 * @param {(!H.Map|!H.map.Object)} target {(H.Map | H.map.Object)} - The event's target element
 * @param {!H.mapevents.Event} originalEvent {Event} - target of the event
 */
H.mapevents.ContextMenuEvent = function(viewportX, viewportY, target, originalEvent) {};
 /** @type {!Array<!H.util.ContextItem>} */
H.mapevents.ContextMenuEvent.prototype.viewportX;
 /** @type {number} */
H.mapevents.ContextMenuEvent.prototype.viewportY;
 /** @type {!H.mapevents.Event} */
H.mapevents.ContextMenuEvent.prototype.originalEvent;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {string} type {string} - type of event
 * @param {!Array<!H.mapevents.Pointer>} pointers {Array<H.mapevents.Pointer>} - pointers which are currently on the screen
 * @param {!Array<!H.mapevents.Pointer>} changedPointers {Array<H.mapevents.Pointer>} - pointers which changed during event
 * @param {!Array<!H.mapevents.Pointer>} targetPointers {Array<H.mapevents.Pointer>} - pointers on the event target
 * @param {!H.mapevents.Pointer} currentPointer {H.mapevents.Pointer} - pointer which triggered the event
 * @param {(!H.Map|!H.map.Object)} target {(H.Map | H.map.Object)} - target map object which triggered event
 * @param {!H.mapevents.Event} originalEvent {Event} - original dom event
 */
H.mapevents.Event = function(type, pointers, changedPointers, targetPointers, currentPointer, target, originalEvent) {};
 /** @type {!Array<!H.mapevents.Pointer>} */
H.mapevents.Event.prototype.pointers;
 /** @type {!Array<!H.mapevents.Pointer>} */
H.mapevents.Event.prototype.changedPointers;
 /** @type {!Array<!H.mapevents.Pointer>} */
H.mapevents.Event.prototype.targetPointers;
 /** @type {!H.mapevents.Pointer} */
H.mapevents.Event.prototype.currentPointer;
 /** @type {!H.mapevents.Event} */
H.mapevents.Event.prototype.originalEvent;
 /** @type {(!H.Map|!H.map.Object)} */
H.mapevents.Event.prototype.target;
 /** @type {(!H.Map|!H.map.Object)} */
H.mapevents.Event.prototype.currentTarget;
 /** @type {string} */
H.mapevents.Event.prototype.type;
 /** @type {boolean} */
H.mapevents.Event.prototype.defaultPrevented;

/**
 * Sets defaultPrevented to true. Which can be used to prevent some default behavior.
 * @return {void}
 */
H.mapevents.Event.prototype.preventDefault = function() {};

/**
 * Stops propagation for current event.
 * @return {void}
 */
H.mapevents.Event.prototype.stopPropagation = function() {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.Map} map {H.Map} - map instance which is used for firing events
 */
H.mapevents.MapEvents = function(map) {};

/**
 * This method destroys the MapEvents by removing all handlers from the map object. After calling this function mapEvents and map objects will not trigger any events. This object will be
 * disposed automatically if the corresponding map object is disposed.
 * @return {void}
 */
H.mapevents.MapEvents.prototype.dispose = function() {};

/**
 * This method returns map into which events are attached
 * @return {!H.Map}
 */
H.mapevents.MapEvents.prototype.getAttachedMap = function() {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {number} viewportX {number} - pointer position on x-axis
 * @param {number} viewportY {number} - pointer position on y-axis
 * @param {number} id {number} - unique pointer identifier among currently available pointers
 * @param {string} type {string} - type of pointer can be i.e 'mouse', 'touch'. 'pen'
 * @param {H.mapevents.Pointer.Button=} opt_button {H.mapevents.Pointer.Button=} - Indicates which pointer device button has changed.
 * @param {number=} opt_buttons {number=} - Indicates which pointer device buttons are being pressed, expressed as a bitmask. Uses the same values, as "buttons" in Pointer Events spec.
 */
H.mapevents.Pointer = function(viewportX, viewportY, id, type, opt_button, opt_buttons) {};
 /** @type {number} */
H.mapevents.Pointer.viewportX;
 /** @type {number} */
H.mapevents.Pointer.viewportY;
 /** @type {(!H.Map|!H.map.Object)} */
H.mapevents.Pointer.target;
 /** @type {number} */
H.mapevents.Pointer.id;
 /** @type {string} */
H.mapevents.Pointer.type;
 /** @type {(!H.Map|!H.map.Object)} */
H.mapevents.Pointer.dragTarget;
 /** @type {H.mapevents.Pointer.Button} */
H.mapevents.Pointer.button;

/** @const */
H.mapevents.Pointer.Button = {};
/** @const {number} */
H.mapevents.Pointer.Button.NONE;
/** @const {number} */
H.mapevents.Pointer.Button.LEFT;
/** @const {number} */
H.mapevents.Pointer.Button.MIDDLE;
/** @const {number} */
H.mapevents.Pointer.Button.RIGHT;

/** @typedef {number} */
H.mapevents.Pointer.Buttons;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {number} deltaY {number} - The wheel move delta on y-axis
 * @param {number} viewportX {number} - The x coordinate on the viewport
 * @param {number} viewportY {number} - The y coordinate on the viewport
 * @param {(!H.Map|!H.map.Object)} target {(H.Map | H.map.Object)} - The event's target element
 * @param {!H.mapevents.Event} originalEvent {Event} - target of the event
 */
H.mapevents.WheelEvent = function(deltaY, viewportX, viewportY, target, originalEvent) {};
 /** @type {number} */
H.mapevents.WheelEvent.prototype.delta;
 /** @type {number} */
H.mapevents.WheelEvent.prototype.viewportX;
 /** @type {number} */
H.mapevents.WheelEvent.prototype.viewportY;
 /** @type {!H.mapevents.Event} */
H.mapevents.WheelEvent.prototype.originalEvent;
/** @const */
H.math = {};

/** @typedef {number} */
H.math.BitMask;
/**
 * @record
 * @struct
 */
H.math.IPoint = function() {};
 /** @type {number} */
H.math.IPoint.prototype.x;
 /** @type {number} */
H.math.IPoint.prototype.y;
/**
 * @record
 * @struct
 */
H.math.ISize = function() {};
 /** @type {number} */
H.math.ISize.prototype.w;
 /** @type {number} */
H.math.ISize.prototype.h;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {number} x {number} - The point's coordinate on X-axis.
 * @param {number} y {number} - The point's coordinate on Y-axis.
 */
H.math.Point = function(x, y) {};
 /** @type {number} */
H.math.Point.prototype.x;
 /** @type {number} */
H.math.Point.prototype.y;

/**
 * Sets the x and y coordinate of this point
 * @param {number} x {number} - The point's coordinate on X-axis.
 * @param {number} y {number} - The point's coordinate on Y-axis.
 * @return {void}
 */
H.math.Point.prototype.set = function(x, y) {};

/**
 * This method creates a copy of the current point.
 * @param {!H.math.Point=} opt_out {H.math.Point=} - An optional point to store the copied values
 * @return {!H.math.Point}
 */
H.math.Point.prototype.clone = function(opt_out) {};

/**
 * This method adds given point coordinates to the current one.
 * @param {!H.math.IPoint} other {H.math.IPoint} - The point to add
 * @return {!H.math.Point}
 */
H.math.Point.prototype.add = function(other) {};

/**
 * This method subtracts given point coordinates from the current point.
 * @param {!H.math.IPoint} other {H.math.IPoint} - The point to subtract
 * @return {!H.math.Point}
 */
H.math.Point.prototype.sub = function(other) {};

/**
 * This method scales the current point coordinates by the given factor(s).
 * @param {number} factor {number} - multiplication factor
 * @param {number=} opt_factorY {number=} - If omitted, the factor argument is used
 * @return {!H.math.Point}
 */
H.math.Point.prototype.scale = function(factor, opt_factorY) {};

/**
 * This method rounds the x and y coordinates of the point.
 * @return {!H.math.Point}
 */
H.math.Point.prototype.round = function() {};

/**
 * Rounds the x and y coordinates to the next smaller integer values.
 * @return {!H.math.Point}
 */
H.math.Point.prototype.floor = function() {};

/**
 * Rounds the x and y coordinates to the next greater integer values.
 * @return {!H.math.Point}
 */
H.math.Point.prototype.ceil = function() {};

/**
 * This method compares current point coordinates with the supplied point coordinates.
 * @param {!H.math.IPoint} other {H.math.IPoint} - The point to compare to.
 * @return {boolean}
 */
H.math.Point.prototype.equals = function(other) {};

/**
 * Calculates the closest point on a given line
 * @param {!H.math.IPoint} start {H.math.IPoint} - The start point of the line
 * @param {!H.math.IPoint} end {H.math.IPoint} - The end point of the line
 * @return {!H.math.IPoint}
 */
H.math.Point.prototype.getNearest = function(start, end) {};

/**
 * This method calculates the distance to a point supplied by the caller.
 * @param {!H.math.IPoint} other {H.math.IPoint}
 * @return {number}
 */
H.math.Point.prototype.distance = function(other) {};

/**
 * This method creates a Point instance from a given IPoint object.
 * @param {!H.math.IPoint} iPoint {H.math.IPoint} - The IPoint object to use
 * @return {!H.math.Point}
 */
H.math.Point.fromIPoint = function(iPoint) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {number} left {number} - The rectangle's left edge x value
 * @param {number} top {number} - The rectangle's top edge y value
 * @param {number} right {number} - The rectangle's right edge x value
 * @param {number} bottom {number} - The rectangle's bottom edge y value
 */
H.math.Rect = function(left, top, right, bottom) {};

/**
 * To set all values of the rectangle's edges
 * @param {number} left {number} - The rectangle's left edge x value
 * @param {number} top {number} - The rectangle's top edge y value
 * @param {number} right {number} - The rectangle's right edge x value
 * @param {number} bottom {number} - The rectangle's bottom edge y value
 * @return {void}
 */
H.math.Rect.prototype.set = function(left, top, right, bottom) {};

/**
 * To get the rectangle's top-left vertex
 * @return {!H.math.Point}
 */
H.math.Rect.prototype.getTopLeft = function() {};

/**
 * To get the rectangle's bottom-right vertex
 * @return {!H.math.Point}
 */
H.math.Rect.prototype.getBottomRight = function() {};

/**
 * Method checks if provided coordinates lie within rectangle.
 * @param {number} x {number} - x-coordinate to check
 * @param {number} y {number} - y-coordinate to check
 * @return {boolean}
 */
H.math.Rect.prototype.containsXY = function(x, y) {};

/**
 * To create a rectangle from a top-left and bottom-right point pair.
 * @param {!H.math.IPoint} topLeft {H.math.IPoint} - the top-left vertex of the rectanle
 * @param {!H.math.IPoint} bottomRight {H.math.IPoint} - the bottom-right vertex of the rectanle
 * @return {!H.math.Rect}
 */
H.math.Rect.fromPoints = function(topLeft, bottomRight) {};

/**
 * To clone a rectangle
 * @return {!H.math.Rect}
 */
H.math.Rect.prototype.clone = function() {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {number} width {number} - Width.
 * @param {number} height {number} - Height.
 */
H.math.Size = function(width, height) {};
 /** @type {number} */
H.math.Size.prototype.w;
 /** @type {number} */
H.math.Size.prototype.h;
/** @const */
H.net = {};
/** @const */
H.net.Request = {};

/** @const */
H.net.Request.State = {};
/** @const {number} */
H.net.Request.State.DONE;
/** @const {number} */
H.net.Request.State.OPENED;
/** @const {number} */
H.net.Request.State.UNSENT;

/** @typedef {?} */
H.net.Request.Priority;
/** @const */
H.service = {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {?=} opt_options {H.service.AbstractRestService.Options=}
 */
H.service.AbstractRestService = function(opt_options) {};

/**
 * This methods receive configuration parameters from the platform, that can be used by the object implementing the interface.
 * @param {string} appId {string} - The application ID to identify the client against the platform (mandatory to provide)
 * @param {string} appCode {string} - The application code to identify the client against the platform (mandatory to provide)
 * @param {boolean} useHTTPS {boolean} - Indicates whether secure communication should be used, default is false
 * @param {boolean} useCIT {boolean} - Indicates whether the Customer Integration Testing should be used, default is false
 * @param {!H.service.Url=} opt_baseUrl {H.service.Url=} - The base URL of the platform, default is http://api.here.com. Note that if useHTTPS flag is passed it will override the URL scheme specified in
 * the opt_baseUrl to use HTTPS.
 * @return {!H.service.IConfigurable}
 */
H.service.AbstractRestService.prototype.configure = function(appId, appCode, useHTTPS, useCIT, opt_baseUrl) {};

/** @typedef {?} */
H.service.AbstractRestService.Options;
/**
 * @record
 * @struct
 */
H.service.DefaultLayers = function() {};
 /** @type {!H.service.MapType} */
H.service.DefaultLayers.prototype.normal;
 /** @type {!H.service.MapType} */
H.service.DefaultLayers.prototype.satellite;
 /** @type {!H.service.MapType} */
H.service.DefaultLayers.prototype.terrain;
 /** @type {!H.map.layer.MarkerTileLayer} */
H.service.DefaultLayers.prototype.incidents;
 /** @type {!H.map.layer.TileLayer} */
H.service.DefaultLayers.prototype.venues;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.service.EnterpriseRoutingService.Options=} opt_options {H.service.EnterpriseRoutingService.Options=}
 */
H.service.EnterpriseRoutingService = function(opt_options) {};

/**
 * This method sends a "calculateroute" request to Enterprise Routing REST API and calls the onResult callback function once the service response was received - providing
 * a H.service.ServiceResult object - or the onError callback if a communication error occurred.
 * @param {!H.service.ServiceParameters} calculateRouteParams {H.service.ServiceParameters} - the service parameters to be sent with the routing request.
 * @param {function(!H.service.ServiceResult): void} onResult {function(H.service.ServiceResult)} - this function will be called once the Enterprise Routing REST API provides a response to the request.
 * @param {function(!Error): void} onError {function(Error)} - this function will be called if a communication error occurs during the JSON-P request
 * @return {void}
 */
H.service.EnterpriseRoutingService.prototype.calculateRoute = function(calculateRouteParams, onResult, onError) {};

/**
 * This method sends a "getroute" request to Enterprise Routing REST API and calls the onResult callback function once the service response was received - providing
 * a H.service.ServiceResult object - or the onError callback if a communication error occurred.
 * @param {!H.service.ServiceParameters} getRouteParams {H.service.ServiceParameters} - the service parameters to be sent with the routing request.
 * @param {function(!H.service.ServiceResult): void} onResult {function(H.service.ServiceResult)} - this function will be called once the Enterprise Routing REST API provides a response to the request.
 * @param {function(!Error): void} onError {function(Error)} - this function will be called if a communication error occurs during the JSON-P request
 * @return {void}
 */
H.service.EnterpriseRoutingService.prototype.getRoute = function(getRouteParams, onResult, onError) {};

/**
 * This method sends a "getlinkinfo" request to Enterprise Routing REST API and calls the onResult callback function once the service response was received - providing
 * a H.service.ServiceResult object - or the onError callback if a communication error occured.
 * @param {!H.service.ServiceParameters} getLinkInfoParams {H.service.ServiceParameters} - the service parameters to be sent with the routing request.
 * @param {function(!H.service.ServiceResult): void} onResult {function(H.service.ServiceResult)} - this function will be called once the Enterprise Routing REST API provides a response to the request.
 * @param {function(!Error): void} onError {function(Error)} - this function will be called if a communication error occurs during the JSON-P request
 * @return {void}
 */
H.service.EnterpriseRoutingService.prototype.getLinkInfo = function(getLinkInfoParams, onResult, onError) {};

/**
 * This method sends a "calculateisoline" request to Enterprise Routing REST API and calls the onResult callback function once the service response was received - providing
 * a H.service.ServiceResult object - or the onError callback if a communication error occurred.
 * @param {!H.service.ServiceParameters} calculateIsolineParams {H.service.ServiceParameters} - the service parameters to be sent with the routing request.
 * @param {function(!H.service.ServiceResult): void} onResult {function(H.service.ServiceResult)} - this function will be called once the Enterprise Routing REST API provides a response to the request.
 * @param {function(!Error): void} onError {function(Error)} - this function will be called if a communication error occurs during the JSON-P request
 * @return {void}
 */
H.service.EnterpriseRoutingService.prototype.calculateIsoline = function(calculateIsolineParams, onResult, onError) {};
/**
 * @record
 * @struct
 */
H.service.EnterpriseRoutingService.Options = function() {};
 /** @type {string} */
H.service.EnterpriseRoutingService.Options.prototype.subDomain;
 /** @type {string} */
H.service.EnterpriseRoutingService.Options.prototype.path;
 /** @type {!H.service.Url} */
H.service.EnterpriseRoutingService.Options.prototype.baseUrl;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.service.GeocodingService.Options=} opt_options {H.service.GeocodingService.Options=}
 */
H.service.GeocodingService = function(opt_options) {};

/**
 * This method sends a reverse geocoding request to Geocoder REST API and calls the onResult callback function once the service response was received - providing a H.service.ServiceResult
 * object - or the onError callback if a communication error occured.
 * @param {!H.service.ServiceParameters} geoodingParams {H.service.ServiceParameters} - the service parameters to be sent with the geocoding request.
 * @param {function(!H.service.ServiceResult): void} onResult {function(H.service.ServiceResult)} - this function will be called once the Geocoder REST API provides a response to the request.
 * @param {function(!Error): void} onError {function(Error)} - this function will be called if a communication error occurs during the JSON-P request
 * @return {!H.service.JsonpRequestHandle}
 */
H.service.GeocodingService.prototype.geocode = function(geoodingParams, onResult, onError) {};

/**
 * This method sends a reverse geocoding request to Geocoder REST API and calls the onResult callback function once the service response was received - providing a H.service.ServiceResult
 * object - or the onError callback if a communication error occured.
 * @param {!H.service.ServiceParameters} reverseGeocodingParams {H.service.ServiceParameters} - the service parameters to be sent with the reverse geocoding request
 * @param {function(!H.service.ServiceResult): void} onResult {function(H.service.ServiceResult)} - this function will be called once the Geocoder REST API provides a response to the request.
 * @param {function(!Error): void} onError {function(Error)} - this function will be called if a communication error occurs during the JSON-P request
 * @return {!H.service.JsonpRequestHandle}
 */
H.service.GeocodingService.prototype.reverseGeocode = function(reverseGeocodingParams, onResult, onError) {};

/**
 * This method sends a landmark search request to Geocoder REST API and calls the onResult callback function once the service response was received - providing a H.service.ServiceResult
 * object - or the onError callback if a communication error occured.
 * @param {!H.service.ServiceParameters} searchParams {H.service.ServiceParameters} - the service parameters to be sent with the reverse geocoding request
 * @param {function(!H.service.ServiceResult): void} onResult {function(H.service.ServiceResult)} - this function will be called once the Geocoder REST API provides a response to the request.
 * @param {function(!Error): void} onError {function(Error)} - this function will be called if a communication error occurs during the JSON-P request
 * @return {!H.service.JsonpRequestHandle}
 */
H.service.GeocodingService.prototype.search = function(searchParams, onResult, onError) {};
/**
 * @record
 * @struct
 */
H.service.GeocodingService.Options = function() {};
 /** @type {string} */
H.service.GeocodingService.Options.prototype.subDomain;
 /** @type {string} */
H.service.GeocodingService.Options.prototype.path;
/**
 * @record
 * @struct
 */
H.service.IConfigurable = function() {};

/**
 * This methods receive configuration parameters from the platform, that can be used by the object implementing the interface.
 * @param {string} appId {string} - The application ID to identify the client against the platform (mandatory to provide)
 * @param {string} appCode {string} - The application code to identify the client against the platform (mandatory to provide)
 * @param {boolean} useHTTPS {boolean} - Indicates whether secure communication should be used, default is false
 * @param {boolean} useCIT {boolean} - Indicates whether the Customer Integration Testing should be used, default is false
 * @param {!H.service.Url=} opt_baseUrl {H.service.Url=} - The base URL of the platform, default is http://api.here.com. Note that if useHTTPS flag is passed it will override the URL scheme specified in
 * the opt_baseUrl to use HTTPS.
 * @return {!H.service.IConfigurable}
 */
H.service.IConfigurable.prototype.configure = function(appId, appCode, useHTTPS, useCIT, opt_baseUrl) {};
/**
 * @record
 * @struct
 */
H.service.JsonpRequestHandle = function() {};
 /** @type {number} */
H.service.JsonpRequestHandle.prototype.id;

/**
 * @return {void}
 */
H.service.JsonpRequestHandle.prototype.cancel = function() {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.service.MapTileService.Options=} opt_options {H.service.MapTileService.Options=}
 */
H.service.MapTileService = function(opt_options) {};

/**
 * This method returns the map tile type provided by this service.
 * @return {string}
 */
H.service.MapTileService.prototype.getType = function() {};

/**
 * This method returns the map tile service's newest version hash.
 * @return {string}
 */
H.service.MapTileService.prototype.getVersion = function() {};

/**
 * This method returns the map tile service's meta information. The method will return an object once the map tile service's data has been fetched.
 * @return {(void|!H.service.MapTileService.Info)}
 */
H.service.MapTileService.prototype.getInfo = function() {};

/**
 * This method creates a tile provider which uses the specified map tiles. This provider can be used as a data source for an ImageTileLayer.
 * @param {string} tileType {string} - the tile type
 * @param {string} scheme {string} - the tile scheme
 * @param {number} tileSize {number} - the tile size
 * @param {string} format {string} - the tile image format
 * @param {!H.service.ServiceParameters=} opt_additionalParameters {H.service.ServiceParameters=} - a hash of additional parameters to be
 * @param {!H.service.TileProviderOptions=} opt_options {H.service.TileProviderOptions=} - additional set of options for the provider
 * @return {!H.map.provider.ImageTileProvider}
 */
H.service.MapTileService.prototype.createTileProvider = function(tileType, scheme, tileSize, format, opt_additionalParameters, opt_options) {};

/**
 * This method creates a tile layer. This layer can be used as a layer on a map's data model.
 * @param {string} tileType {string} - the tile type
 * @param {string} scheme {string} - the tile scheme
 * @param {number} tileSize {number} - the tile size
 * @param {string} format {string} - the tile image format
 * @param {!H.service.ServiceParameters=} opt_additionalParameters {H.service.ServiceParameters=} - Additional parameters for the map tile service
 * @param {number=} opt_opacity {number=} - The opacity of this layer
 * @param {boolean=} opt_dark {boolean=} - Indicates whether the content of this layer is mainly dark, default is false See also H.Map.Options#autoColor
 * @param {!H.service.TileProviderOptions=} opt_options {H.service.TileProviderOptions=} - additional set of options for the provider
 * @return {!H.map.layer.TileLayer}
 */
H.service.MapTileService.prototype.createTileLayer = function(tileType, scheme, tileSize, format, opt_additionalParameters, opt_opacity, opt_dark, opt_options) {};

/**
 * This methods receive configuration parameters from the platform, that can be used by the object implementing the interface.
 * @param {string} appId {string} - The application ID to identify the client against the platform (mandatory to provide)
 * @param {string} appCode {string} - The application code to identify the client against the platform (mandatory to provide)
 * @param {boolean} useHTTPS {boolean} - Indicates whether secure communication should be used, default is false
 * @param {boolean} useCIT {boolean} - Indicates whether the Customer Integration Testing should be used, default is false
 * @param {!H.service.Url=} opt_baseUrl {H.service.Url=} - The base URL of the platform, default is http://api.here.com. Note that if useHTTPS flag is passed it will override the URL scheme specified in
 * the opt_baseUrl to use HTTPS.
 * @return {!H.service.IConfigurable}
 */
H.service.MapTileService.prototype.configure = function(appId, appCode, useHTTPS, useCIT, opt_baseUrl) {};
/**
 * @record
 * @struct
 */
H.service.MapTileService.Info = function() {};
 /** @type {!Object<string,?>} */
H.service.MapTileService.Info.prototype.maps;
 /** @type {!Object<string,?>} */
H.service.MapTileService.Info.prototype.schemes;
 /** @type {!Object<string,?>} */
H.service.MapTileService.Info.prototype.tiletypes;
 /** @type {!Object<string,?>} */
H.service.MapTileService.Info.prototype.formats;
 /** @type {!Object<string,?>} */
H.service.MapTileService.Info.prototype.resolutions;
 /** @type {!Object<string,?>} */
H.service.MapTileService.Info.prototype.languages;
/**
 * @record
 * @struct
 */
H.service.MapTileService.Options = function() {};
 /** @type {string} */
H.service.MapTileService.Options.prototype.type;
 /** @type {string} */
H.service.MapTileService.Options.prototype.version;
 /** @type {string} */
H.service.MapTileService.Options.prototype.subDomain;
 /** @type {string} */
H.service.MapTileService.Options.prototype.path;
/**
 * @record
 * @struct
 */
H.service.MapType = function() {};
 /** @type {!H.map.layer.TileLayer} */
H.service.MapType.prototype.map;
 /** @type {!H.map.layer.TileLayer} */
H.service.MapType.prototype.mapnight;
 /** @type {!H.map.layer.TileLayer} */
H.service.MapType.prototype.xbase;
 /** @type {!H.map.layer.TileLayer} */
H.service.MapType.prototype.xbasenight;
 /** @type {!H.map.layer.TileLayer} */
H.service.MapType.prototype.base;
 /** @type {!H.map.layer.TileLayer} */
H.service.MapType.prototype.basenight;
 /** @type {!H.map.layer.TileLayer} */
H.service.MapType.prototype.traffic;
 /** @type {!H.map.layer.TileLayer} */
H.service.MapType.prototype.trafficnight;
 /** @type {!H.map.layer.TileLayer} */
H.service.MapType.prototype.transit;
 /** @type {!H.map.layer.TileLayer} */
H.service.MapType.prototype.panorama;
 /** @type {!H.map.layer.TileLayer} */
H.service.MapType.prototype.panoramanight;
 /** @type {!H.map.layer.TileLayer} */
H.service.MapType.prototype.labels;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.service.PlacesService.Options=} opt_options {H.service.PlacesService.Options=}
 */
H.service.PlacesService = function(opt_options) {};

/**
 * This is generic method to query places RestAPI.
 * @param {H.service.PlacesService.EntryPoint} entryPoint {H.service.PlacesService.EntryPoint} - can be one of available entry points H.service.PlacesService.EntryPoint i.e value of H.service.PlacesService.EntryPoint.SEARCH
 * @param {!Object} entryPointParams {Object} - parameter map key value pairs will be transformed into the url key=value parametes. For entry point parameters description please refer to places
 * restful api documentation documentation for available parameters for chose entry point
 * @param {function(!H.service.ServiceResult): void} onResult {Function} - callback which is called when result is returned
 * @param {function(!Error): void} onError {Function} - callback which is called when error occured (i.e request timeout)
 * @return {!H.service.JsonpRequestHandle}
 */
H.service.PlacesService.prototype.request = function(entryPoint, entryPointParams, onResult, onError) {};

/**
 * Function triggers places api 'search' entry point. Please refer to documentation for parameter specification and response handling.
 * @param {!H.service.ServiceParameters} searchParams {H.service.ServiceParameters} - places api search entry point parameters please refer to places api documentation
 * @param {function(!H.service.ServiceResult): void} onResult {Function}
 * @param {function(!Error): void} onError {Function}
 * @return {!H.service.JsonpRequestHandle}
 */
H.service.PlacesService.prototype.search = function(searchParams, onResult, onError) {};

/**
 * Function triggers places api 'suggestions' entry point. Please refer to documentation for parameter specification and response handling.
 * @param {!H.service.ServiceParameters} suggestParams {H.service.ServiceParameters} - places api suggest entry point parameters please refer to places api documentation
 * @param {function(!H.service.ServiceResult): void} onResult {Function}
 * @param {function(!Error): void} onError {Function}
 * @return {!H.service.JsonpRequestHandle}
 */
H.service.PlacesService.prototype.suggest = function(suggestParams, onResult, onError) {};

/**
 * Function triggers places api 'explore' entry point. Please refer to documentation for parameter specification and response handling.
 * @param {!H.service.ServiceParameters} exploreParams {H.service.ServiceParameters} - places api explore entry point parameters please refer to places api documentation
 * @param {function(!H.service.ServiceResult): void} onResult {Function}
 * @param {function(!Error): void} onError {Function}
 * @return {!H.service.JsonpRequestHandle}
 */
H.service.PlacesService.prototype.explore = function(exploreParams, onResult, onError) {};

/**
 * Function triggers places api 'around' entry point. Please refer to documentation for parameter specification and response handling.
 * @param {!H.service.ServiceParameters} aroundParams {H.service.ServiceParameters} - places api around entry point parameters please refer to places api documentation
 * @param {function(!H.service.ServiceResult): void} onResult {Function}
 * @param {function(!Error): void} onError {Function}
 * @return {!H.service.JsonpRequestHandle}
 */
H.service.PlacesService.prototype.around = function(aroundParams, onResult, onError) {};

/**
 * Function triggers places api 'here' entry point. Please refer to documentation for parameter specification and response handling.
 * @param {!H.service.ServiceParameters} hereParams {H.service.ServiceParameters} - places api here entry point parameters please refer to places api documentation
 * @param {function(!H.service.ServiceResult): void} onResult {Function}
 * @param {function(!Error): void} onError {Function}
 * @return {!H.service.JsonpRequestHandle}
 */
H.service.PlacesService.prototype.here = function(hereParams, onResult, onError) {};

/**
 * Function triggers places api 'categories' entry point. Please refer to documentation for parameter specification and response handling.
 * @param {!H.service.ServiceParameters} categoriesParams {H.service.ServiceParameters} - places api here entry point parameters please refer to places api documentation
 * @param {function(!H.service.ServiceResult): void} onResult {Function}
 * @param {function(!Error): void} onError {Function}
 * @return {!H.service.JsonpRequestHandle}
 */
H.service.PlacesService.prototype.categories = function(categoriesParams, onResult, onError) {};

/**
 * This method should be used to follow hyperlinks available in results returned by dicovery queries.
 * @param {string} hyperlink {string}
 * @param {function(!H.service.ServiceResult): void} onResult {Function}
 * @param {function(!Error): void} onError {Function}
 * @param {!Object=} opt_additionalParameters {Object=} - additional parameters to send with request
 * @return {!H.service.JsonpRequestHandle}
 */
H.service.PlacesService.prototype.follow = function(hyperlink, onResult, onError, opt_additionalParameters) {};

/** @const */
H.service.PlacesService.EntryPoint = {};
/** @const {number} */
H.service.PlacesService.EntryPoint.SEARCH;
/** @const {number} */
H.service.PlacesService.EntryPoint.SUGGEST;
/** @const {number} */
H.service.PlacesService.EntryPoint.EXPLORE;
/** @const {number} */
H.service.PlacesService.EntryPoint.AROUND;
/** @const {number} */
H.service.PlacesService.EntryPoint.HERE;
/** @const {number} */
H.service.PlacesService.EntryPoint.CATEGORIES;
/**
 * @record
 * @struct
 */
H.service.PlacesService.Options = function() {};
 /** @type {string} */
H.service.PlacesService.Options.prototype.subDomain;
 /** @type {string} */
H.service.PlacesService.Options.prototype.path;
 /** @type {!H.service.Url} */
H.service.PlacesService.Options.prototype.baseUrl;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.service.Platform.Options} options {H.service.Platform.Options}
 */
H.service.Platform = function(options) {};

/**
 * Method attempts to configure object that implements H.service.IConfigurable
 * @param {!H.service.IConfigurable} configurable {H.service.IConfigurable}
 * @return {!H.service.IConfigurable}
 */
H.service.Platform.prototype.configure = function(configurable) {};

/**
 * This method enables or disables HTTPS communication with the platform
 * @param {boolean} useHTTPS {boolean} - a boolean value indicating whether to communicate with the platform via HTTPS
 * @return {void}
 */
H.service.Platform.prototype.setUseHTTPS = function(useHTTPS) {};

/**
 * This method configures whether to use the "customer integration testing" instance of the platform.
 * @param {boolean} useCIT {boolean} - a boolean value indicating whether the CIT platform instance is to be used
 * @return {void}
 */
H.service.Platform.prototype.setUseCIT = function(useCIT) {};

/**
 * This method modifies the base URL to be used when creating service stubs.
 * @param {!H.service.Url} baseUrl {H.service.Url} - the new base URL to use
 * @return {void}
 */
H.service.Platform.prototype.setBaseUrl = function(baseUrl) {};

/**
 * This method returns the currently used base URL.
 * @return {!H.service.Url}
 */
H.service.Platform.prototype.getBaseUrl = function() {};

/**
 * This method returns an instance of H.service.TrafficIncidentsService to query the Traffic API Traffic Incident Data
 * @return {!H.service.TrafficIncidentsService}
 */
H.service.Platform.prototype.getTrafficIncidentsService = function() {};

/**
 * This method returns an instance of H.service.MapTileService to query the Map Tile API.
 * @param {!H.service.MapTileService.Options=} opt_options {H.service.MapTileService.Options=}
 * @return {!H.service.MapTileService}
 */
H.service.Platform.prototype.getMapTileService = function(opt_options) {};

/**
 * This method returns an instance of H.service.venues.Service to query the Venue Maps API
 * @param {!H.service.venues.Service.Options=} opt_params {H.service.venues.Service.Options=} - additional service parameters
 * @return {!H.service.venues.Service}
 */
H.service.Platform.prototype.getVenueService = function(opt_params) {};

/**
 * This method returns an instance of H.service.metaInfo.Service to query the Map Tile API Metainfo Tiles
 * @param {!H.service.metaInfo.Service.Options=} opt_params {H.service.metaInfo.Service.Options=} - additional service parameters
 * @return {!H.service.metaInfo.Service}
 */
H.service.Platform.prototype.getMetaInfoService = function(opt_params) {};

/**
 * This method creates a pre-configured set of HERE tile layers for convenient use with the map.
 * @param {(number|!H.service.Platform.DefaultLayersOptions)=} opt_tileSize {(H.service.Platform.DefaultLayersOptions | number)=} - When a number  optional tile size to be queried from the HERE Map Tile API, default is 256.
 * If this parameter is a number, it indicates the tile size to be queried from the HERE Map Tile API (the default value is 256); if this parameter is an object, it represents
 * configuration options for the layer and all the remaining parameters (below) should be omitted
 * @param {number=} opt_ppi {number=} - optional 'ppi' parameter to use when querying tiles, default is not specified
 * @param {string=} opt_lang {string=} - optional primary language parameter, default is not specified
 * @param {string=} opt_secondaryLang {string=} - optional secondary language parameter, default is not specified
 * @param {string=} opt_style {string=} - optional 'style' parameter to use when querying map tiles, default is not specified
 * @param {(string|boolean)=} opt_pois {(string | boolean)=} - indicates if pois are displayed on the map. Pass true to indicate that all pois should be visible. Alternatively you can specify mask for the
 * POI Categories as described at the Map Tile API documentation POI Categories chapter.
 * @return {!H.service.DefaultLayers}
 */
H.service.Platform.prototype.createDefaultLayers = function(opt_tileSize, opt_ppi, opt_lang, opt_secondaryLang, opt_style, opt_pois) {};

/**
 * This method returns an instance of H.service.RoutingService to query the Routing API.
 * @param {!H.service.RoutingService.Options=} opt_options {H.service.RoutingService.Options=}
 * @return {!H.service.RoutingService}
 */
H.service.Platform.prototype.getRoutingService = function(opt_options) {};

/**
 * This method returns an instance of H.service.GeocodingService to query the Geocoder API
 * @param {!H.service.GeocodingService.Options=} opt_options {H.service.GeocodingService.Options=} - an optional set of options for the new geocoding service to connect to
 * @return {!H.service.GeocodingService}
 */
H.service.Platform.prototype.getGeocodingService = function(opt_options) {};

/**
 * This method returns an instance of H.service.PlacesService to query the Places API.
 * @return {!H.service.PlacesService}
 */
H.service.Platform.prototype.getPlacesService = function() {};

/**
 * This method returns an instance of H.service.EnterpriseRoutingService to query the Enterprise Routing API.
 * @param {!H.service.EnterpriseRoutingService.Options=} opt_options {H.service.EnterpriseRoutingService.Options=}
 * @return {!H.service.EnterpriseRoutingService}
 */
H.service.Platform.prototype.getEnterpriseRoutingService = function(opt_options) {};
/**
 * @record
 * @struct
 */
H.service.Platform.DefaultLayersOptions = function() {};
 /** @type {number} */
H.service.Platform.DefaultLayersOptions.prototype.tileSize;
 /** @type {number} */
H.service.Platform.DefaultLayersOptions.prototype.ppi;
 /** @type {string} */
H.service.Platform.DefaultLayersOptions.prototype.lg;
 /** @type {string} */
H.service.Platform.DefaultLayersOptions.prototype.lg2;
 /** @type {string} */
H.service.Platform.DefaultLayersOptions.prototype.style;
 /** @type {boolean} */
H.service.Platform.DefaultLayersOptions.prototype.pois;
 /** @type {(string|boolean)} */
H.service.Platform.DefaultLayersOptions.prototype.crossOrigin;
/**
 * @record
 * @struct
 */
H.service.Platform.Options = function() {};
 /** @type {string} */
H.service.Platform.Options.prototype.app_id;
 /** @type {string} */
H.service.Platform.Options.prototype.app_code;
 /** @type {!H.service.Url} */
H.service.Platform.Options.prototype.baseUrl;
 /** @type {boolean} */
H.service.Platform.Options.prototype.useCIT;
 /** @type {boolean} */
H.service.Platform.Options.prototype.useHTTPS;
/**
 * @record
 * @struct
 */
H.service.Platform.MapTypes = function() {};
 /** @type {!H.service.MapType} */
H.service.Platform.MapTypes.prototype.normal;
 /** @type {!H.service.MapType} */
H.service.Platform.MapTypes.prototype.satellite;
 /** @type {!H.service.MapType} */
H.service.Platform.MapTypes.prototype.terrain;

/* TODO: IndexSignature: H.service.Platform */

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.service.RoutingService.Options=} opt_options {H.service.RoutingService.Options=}
 */
H.service.RoutingService = function(opt_options) {};

/**
 * This method sends a "calculateroute" request to Routing REST API and calls the onResult callback function once the service response was received - providing a
 * H.service.ServiceResult object - or the onError callback if a communication error occured.
 * @param {!H.service.ServiceParameters} calculateRouteParams {H.service.ServiceParameters} - the service parameters to be sent with the routing request.
 * @param {function(!H.service.ServiceResult): void} onResult {function(H.service.ServiceResult)} - this function will be called once the Routing REST API provides a response to the request.
 * @param {function(!Error): void} onError {function(Error)} - this function will be called if a communication error occurs during the JSON-P request
 * @return {void}
 */
H.service.RoutingService.prototype.calculateRoute = function(calculateRouteParams, onResult, onError) {};
/**
 * @record
 * @struct
 */
H.service.RoutingService.Options = function() {};
 /** @type {string} */
H.service.RoutingService.Options.prototype.subDomain;
 /** @type {string} */
H.service.RoutingService.Options.prototype.path;
 /** @type {!H.service.Url} */
H.service.RoutingService.Options.prototype.baseUrl;
/**
 * @record
 * @struct
 */
H.service.ServiceParameters = function() {};

/* TODO: IndexSignature: H.service */
/**
 * @record
 * @struct
 */
H.service.ServiceResult = function() {};

/* TODO: IndexSignature: H.service */
 /** @type {{language: string, route: !Array<{leg: !Array<{maneuver: !Array<{id: string, instruction: string, length: number, note: !Array<string>, position: {latitude: number, longitude: number}, shape: !Array<string>, travelTime: number, _type: string}>}>, mode: {feature: !Array<?>, trafficMode: string, transportModes: !Array<string>, type: string}, shape: !Array<string>, summary: {baseTime: number, distance: number, flags: !Array<string>, text: string, trafficTime: number, travelTime: number}, waypoint: !Array<{label: string, linkId: string, mappedPosition: {latitude: number, longitude: number}, mappedRoadName: string, originalPosition: {latitude: number, longitude: number}, shapeIndex: number, sideOfStreet: string, spot: number, type: string}>}>, metaInfo: !Object}} */
H.service.ServiceResult.prototype.response;
 /** @type {{items: !Array<?>, next: string}} */
H.service.ServiceResult.prototype.results;
 /** @type {{context: {href: string, location: {address: {city: string, country: string, countryCode: string, county: string, district: string, house: string, postalCode: string, stateCode: string, street: string, text: string}, position: !Array<number>}, type: string}}} */
H.service.ServiceResult.prototype.search;
 /** @type {{MetaInfo: {Timestamp: string}, View: !Array<{Result: !Array<{Location: {Address: {AdditionalData: !Array<{key: string, value: string}>, City: string, Country: string, County: string, District: string, HouseNumber: string, Label: string, PostalCode: string, State: string, Street: string}, DisplayPosition: {Latitude: number, Longitude: number}, LocationId: string, LocationType: string, MapView: {BottomRight: {Latitude: number, Longitude: number}, TopLeft: {Latitude: number, Longitude: number}}, NavigationPosition: !Array<{Latitude: number, Longitude: number}>}, MatchLevel: string, MatchQuality: {City: number, HouseNumber: number, Street: !Array<number>}, MatchType: string, Relevance: number}>}>, isolines: !Array<?>}} */
H.service.ServiceResult.prototype.Response;
/**
 * @record
 * @struct
 */
H.service.TileProviderOptions = function() {};
 /** @type {boolean} */
H.service.TileProviderOptions.prototype.crossOrigin;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.service.TrafficIncidentsService.Options=} opt_options {H.service.TrafficIncidentsService.Options=}
 */
H.service.TrafficIncidentsService = function(opt_options) {};

/**
 * This method requests traffic incidents based on the service parameters provided.
 * @param {!H.service.ServiceParameters} serviceParams {H.service.ServiceParameters}
 * @param {function(!H.service.ServiceResult): void} onResponse {function(H.service.ServiceResult)}
 * @param {function(!Error): void} onError {function()}
 * @return {!H.service.JsonpRequestHandle}
 */
H.service.TrafficIncidentsService.prototype.requestIncidents = function(serviceParams, onResponse, onError) {};

/**
 * This method requests traffic incident information by tile coordinates
 * @param {number} x {number} - tile column number
 * @param {number} y {number} - tile row number
 * @param {number} z {number} - zoom level
 * @param {function(!H.service.ServiceResult): void} onResponse {function(H.service.ServiceResult)} - callback to handle service resposne
 * @param {function(!Error): void} onError {function()} - callback to habdle communication error
 * @param {!H.service.ServiceParameters=} opt_serviceParams {H.service.ServiceParameters=} - optional service parameters to be added to the request
 * @return {!H.service.JsonpRequestHandle}
 */
H.service.TrafficIncidentsService.prototype.requestIncidentsByTile = function(x, y, z, onResponse, onError, opt_serviceParams) {};
/**
 * @record
 * @struct
 */
H.service.TrafficIncidentsService.Options = function() {};
 /** @type {string} */
H.service.TrafficIncidentsService.Options.prototype.subDomain;
 /** @type {string} */
H.service.TrafficIncidentsService.Options.prototype.path;
 /** @type {!H.service.Url} */
H.service.TrafficIncidentsService.Options.prototype.baseUrl;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {string} scheme {string} - the URL scheme (e.g. "http" or "https" or "mailto")
 * @param {string} host {string} - the host (or domain) part of the URL
 * @param {string=} opt_path {string=} - the path following the host pointing to a resource
 * @param {!Object=} opt_params {Object=} - the query string parameters of this URL
 * @param {number=} opt_port {number=} - The port of the host on which the host listens. If a string is passed it must be convertible to an integer.
 * @param {string=} opt_anchor {string=} - an optional anchor part of the URL (usually preceded by '#');
 */
H.service.Url = function(scheme, host, opt_path, opt_params, opt_port, opt_anchor) {};

/**
 * This function parses a URL string and returns a H.service.Url object. The URL string must contain at least a scheme and a host.
 * @param {string} url {string} - The URL string to parse.
 * @param {string=} opt_baseURL {string=} - The base URL to use to resolve relative URLs. If ommited the base URL of the document which loaded the API is taken.
 * @return {!H.service.Url}
 */
H.service.Url.parse = function(url, opt_baseURL) {};

/**
 * Clones this URL object. Optionally, mutations can be passed to this function to modify properties of the cloned object. Note that URL parameters are not replaced but merged with the
 * parameters of this instance.
 * @return {!H.service.Url}
 */
H.service.Url.prototype.clone = function() {};

/**
 * This function sets the scheme of this URL object.
 * @param {string} scheme {string} - the new scheme
 * @return {!H.service.Url}
 */
H.service.Url.prototype.setScheme = function(scheme) {};

/**
 * This function returns the scheme of this Url object.
 * @return {string}
 */
H.service.Url.prototype.getScheme = function() {};

/**
 * This function sets the host of this URL object.
 * @param {string} host {string} - the new host
 * @return {!H.service.Url}
 */
H.service.Url.prototype.setHost = function(host) {};

/**
 * This function returns the host name of this Url object.
 * @return {string}
 */
H.service.Url.prototype.getHost = function() {};

/**
 * This function sets the path of this URL object.
 * @param {(string|boolean)} path {(string | undefined)} - the new path or a boolean to clear the path
 * @return {!H.service.Url}
 */
H.service.Url.prototype.setPath = function(path) {};

/**
 * This function returns the path part of this Url object.
 * @return {(string|void)}
 */
H.service.Url.prototype.getPath = function() {};

/**
 * This function sets the specified parameters for this URL object. Keys in this object, which are associated with undefined values will be treated as query string parameters
 * with no value.
 * @param {(boolean|!Object)=} params {(Object | undefined)} - a hash of query string parameters specifying the parameters to be set.or a boolean to clear the parameters.
 * @return {!H.service.Url}
 */
H.service.Url.prototype.setQuery = function(params) {};

/**
 * This function returns a boolean value indicating whether there are any query string parameter associated with this URL.
 * @return {boolean}
 */
H.service.Url.prototype.hasQuery = function() {};

/**
 * This function returns the query object of this Url object.
 * @return {!Object}
 */
H.service.Url.prototype.getQuery = function() {};

/**
 * This function sets the anchor of this URL object.
 * @param {(string|boolean)=} anchor {(string | boolean | undefined)} - the new anchor or undefined to clear the anchor
 * @return {!H.service.Url}
 */
H.service.Url.prototype.setAnchor = function(anchor) {};

/**
 * This function returns the anchor of this Url object.
 * @return {(string|void)}
 */
H.service.Url.prototype.getAnchor = function() {};

/**
 * This function merges the provided parameters into this URL's existing parameters. Key-value pairs which are defined in the argument and this URL's parameters will be overwritten.
 * Key-value pairs which are defined in the argument and are not defined in this URL's parameters will be added. Prototype properties and function properties will not be merged.
 * @param {!Object} other {Object} - the parmeters to be merged into this URL's query string parameters
 * @return {!H.service.Url}
 */
H.service.Url.prototype.mergeQuery = function(other) {};

/**
 * This function adds a sub-domain to the host of this URL object.
 * @param {string} subDomain {string} - the sub domain (non-empty string) to be added
 * @return {!H.service.Url}
 */
H.service.Url.prototype.addSubDomain = function(subDomain) {};

/**
 * This function adds a sub-path to this URL's path
 * @param {string} subPath {string} - the path to be added
 * @return {!H.service.Url}
 */
H.service.Url.prototype.addSubPath = function(subPath) {};

/**
 * This function formats this URL object to a full URL string.
 * @return {string}
 */
H.service.Url.prototype.toString = function() {};
/** @const */
H.service.metaInfo = {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.service.metaInfo.Service.Options=} opt_options {H.service.metaInfo.Service.Options=} - additional service parameters
 */
H.service.metaInfo.Service = function(opt_options) {};

/**
 * This method returns the meta info tile service's newest version hash.
 * @return {string}
 */
H.service.metaInfo.Service.prototype.getVersion = function() {};

/**
 * This method returns the meta info tile service's meta information. The method will return an object once the map tile service's data has been fetched.
 * @return {(void|!H.service.metaInfo.Service.Info)}
 */
H.service.metaInfo.Service.prototype.getInfo = function() {};

/**
 * This method creates a tile provider which uses the meta info tile backend. This provider can be used as a data source for an TileLayer.
 * @param {number} tileSize {number} - The tile size
 * @param {number} pixelRatio {number} - The tile's pixel ratio, should be aligned with base map tile
 * @param {!Array<string>=} opt_categoryFilter {Array<string>=} - A list of meta-info category names which should be suppressed. See Metainfo Tile for valid category names.
 * @param {!H.service.ServiceParameters=} opt_additionalParameters {H.service.ServiceParameters=} - Additional parameters for the meta info service
 * @param {string=} opt_tileType {string=} - the tile type (default is 'maptile')
 * @param {string=} opt_scheme {string=} - the scheme for which the meta info tiles a requested (default is 'normal.day')
 * @return {!H.map.provider.TileProvider}
 */
H.service.metaInfo.Service.prototype.createTileProvider = function(tileSize, pixelRatio, opt_categoryFilter, opt_additionalParameters, opt_tileType, opt_scheme) {};

/**
 * This method creates a tile layer. This layer can be used as a layer on a map's data model.
 * @param {number} tileSize {number} - The tile size
 * @param {number} pixelRatio {number} - The tile's pixel ratio, should be aligned with base map tile
 * @param {!Array<string>=} opt_categoryFilter {Array<string>=} - A list of meta-info category names which should be suppressed. See Metainfo Tile for valid category names.
 * @param {!H.service.ServiceParameters=} opt_additionalParameters {H.service.ServiceParameters=} - Additional parameters for the meta info service
 * @param {string=} opt_tileType {string=} - the tile type (default is 'maptile')
 * @param {string=} opt_scheme {string=} - the scheme for which the meta info tiles a requested (default is 'normal.day')
 * @return {!H.map.layer.TileLayer}
 */
H.service.metaInfo.Service.prototype.createTileLayer = function(tileSize, pixelRatio, opt_categoryFilter, opt_additionalParameters, opt_tileType, opt_scheme) {};

/**
 * This methods receive configuration parameters from the platform, that can be used by the object implementing the interface.
 * @param {string} appId {string} - The application ID to identify the client against the platform (mandatory to provide)
 * @param {string} appCode {string} - The application code to identify the client against the platform (mandatory to provide)
 * @param {boolean} useHTTPS {boolean} - Indicates whether secure communication should be used, default is false
 * @param {boolean} useCIT {boolean} - Indicates whether the Customer Integration Testing should be used, default is false
 * @param {!H.service.Url=} opt_baseUrl {H.service.Url=} - The base URL of the platform, default is http://api.here.com. Note that if useHTTPS flag is passed it will override the URL scheme specified
 * in the opt_baseUrl to use HTTPS.
 * @return {!H.service.IConfigurable}
 */
H.service.metaInfo.Service.prototype.configure = function(appId, appCode, useHTTPS, useCIT, opt_baseUrl) {};
/**
 * @record
 * @struct
 */
H.service.metaInfo.Service.Info = function() {};
 /** @type {!Object<string,?>} */
H.service.metaInfo.Service.Info.prototype.maps;
 /** @type {!Object<string,?>} */
H.service.metaInfo.Service.Info.prototype.schemes;
 /** @type {!Object<string,?>} */
H.service.metaInfo.Service.Info.prototype.tiletypes;
 /** @type {!Object<string,?>} */
H.service.metaInfo.Service.Info.prototype.formats;
 /** @type {!Object<string,?>} */
H.service.metaInfo.Service.Info.prototype.resolutions;
 /** @type {!Object<string,?>} */
H.service.metaInfo.Service.Info.prototype.languages;
/**
 * @record
 * @struct
 */
H.service.metaInfo.Service.Options = function() {};
 /** @type {string} */
H.service.metaInfo.Service.Options.prototype.type;
 /** @type {string} */
H.service.metaInfo.Service.Options.prototype.version;
 /** @type {string} */
H.service.metaInfo.Service.Options.prototype.subDomain;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {(!H.service.MapTileService|!H.service.metaInfo.Service)} service {(H.service.metaInfo.Service | H.service.MapTileService)} - the tile service which holds information from about the source of the tiles
 * @param {!H.service.ServiceParameters=} opt_params {H.service.ServiceParameters=} - an additional set of URL parameters
 * @param {!H.service.metaInfo.TileProvider.Options=} opt_options {H.service.metaInfo.TileProvider.Options=} - additional parameters
 */
H.service.metaInfo.TileProvider = function(service, opt_params, opt_options) {};
/**
 * @record
 * @struct
 */
H.service.metaInfo.TileProvider.Options = function() {};
 /** @type {string} */
H.service.metaInfo.TileProvider.Options.prototype.tileType;
 /** @type {string} */
H.service.metaInfo.TileProvider.Options.prototype.scheme;
 /** @type {number} */
H.service.metaInfo.TileProvider.Options.prototype.tileCacheSize;
 /** @type {number} */
H.service.metaInfo.TileProvider.Options.prototype.tileSize;
 /** @type {number} */
H.service.metaInfo.TileProvider.Options.prototype.pixelRatio;
 /** @type {!Array<string>} */
H.service.metaInfo.TileProvider.Options.prototype.categoryFilter;
/** @const */
H.service.venues = {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.provider.ObjectProvider} provider {H.map.provider.ObjectProvider} - The object provider of this venue building
 * @param {string} uid {string} - The unique identifier of this building
 * @param {number} minLevel {number} - The minimum floor level of this building
 * @param {number} maxLevel {number} - The maximum floor level of this building
 */
H.service.venues.Building = function(provider, uid, minLevel, maxLevel) {};

/**
 * Method returns the parent object - venue (see H.service.venues.Venue) to which the building belongs to.
 * @return {!H.service.venues.Venue}
 */
H.service.venues.Building.prototype.getVenue = function() {};

/**
 * Method returns the minimum floor level of this building.
 * @return {number}
 */
H.service.venues.Building.prototype.getMinLevel = function() {};

/**
 * Method returns the maximum floor level of this building
 * @return {number}
 */
H.service.venues.Building.prototype.getMaxLevel = function() {};

/**
 * Method returns the floor (see H.service.venues.Floor) if one was already loaded. This method doesn't make attempt to fetch the floor data.
 * @param {number} level {number} - floor level within minimum and maximum level boundaries for the building
 * @return {(void|!H.service.venues.Floor)}
 */
H.service.venues.Building.prototype.getFloor = function(level) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.provider.ObjectProvider} provider {H.map.provider.ObjectProvider} - The object provider of this venue floor
 * @param {?} data {*} - The meta data of this floor
 * @param {number} level {number} - The level of this floor
 */
H.service.venues.Floor = function(provider, data, level) {};

/**
 * Method returns the level of the floor in the building.
 * @return {number}
 */
H.service.venues.Floor.prototype.getLevel = function() {};

/**
 * Method returns map geometry that represents floor boundaries.
 * @return {(void|!H.service.venues.Space)}
 */
H.service.venues.Floor.prototype.getFloorSpace = function() {};

/**
 * Method returns the H.map.Group of all spaces that belong to the floor.
 * @return {!H.map.Group}
 */
H.service.venues.Floor.prototype.getSpaces = function() {};

/**
 * Method returns parent object - building (see H.service.venues.Building) of the floor.
 * @return {!H.service.venues.Building}
 */
H.service.venues.Floor.prototype.getBuilding = function() {};

/**
 * Method returns raw data associated with the floor. For more details on data format see
 * http://developer.here.com/rest-apis/documentation/venue-maps/topics/resource-type-venue-interaction-tile-floor.html
 * @return {?}
 */
H.service.venues.Floor.prototype.getData = function() {};

/**
 * Method returns the space object with the given ID, that belongs to the floor.
 * @param {string} id {string} - The ID of the space.
 * @return {(void|!H.service.venues.Space)}
 */
H.service.venues.Floor.prototype.getSpace = function(id) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.service.venues.Service.Options=} opt_options {H.service.venues.Service.Options=} - additional service parameters
 */
H.service.venues.Service = function(opt_options) {};

/**
 * This method sends a discovery request to the Venue Maps API and calls the onResult callback function once the service response was received - providing a H.service.ServiceResult
 * object, or the onError callback if a communication error occured.
 * @param {!H.service.ServiceParameters} serviceParams {H.service.ServiceParameters} - the service parameters to be sent with the discovery request
 * @param {function(!H.service.ServiceResult): void} onResult {function(H.service.ServiceResult)} - this function will be called once the Venue Maps API provides a response to the request
 * @param {function(string): void} onError {function(string)} - this function will be called if a communication error occurs during request and error type is passed as an argument
 * @return {void}
 */
H.service.venues.Service.prototype.discover = function(serviceParams, onResult, onError) {};

/**
 * This method creates a tile layer which can be added to the map in order to see the venues. It uses Interaction Tile endpoint of the Venue Maps API, more at
 * http://developer.here.com/rest-apis/documentation/venue-maps/topics/quick-start-get-interaction-tile.html.
 * @param {!H.service.venues.TileProvider.Options=} opt_options {H.service.venues.TileProvider.Options=} - Tile provider options
 * @return {!H.map.layer.TileLayer}
 */
H.service.venues.Service.prototype.createTileLayer = function(opt_options) {};

/**
 * Method returns current state of the service.
 * @return {H.service.venues.Service.State}
 */
H.service.venues.Service.prototype.getState = function() {};

/**
 * This methods receive configuration parameters from the platform, that can be used by the object implementing the interface.
 * @param {string} appId {string} - The application ID to identify the client against the platform (mandatory to provide)
 * @param {string} appCode {string} - The application code to identify the client against the platform (mandatory to provide)
 * @param {boolean} useHTTPS {boolean} - Indicates whether secure communication should be used, default is false
 * @param {boolean} useCIT {boolean} - Indicates whether the Customer Integration Testing should be used, default is false
 * @param {!H.service.Url=} opt_baseUrl {H.service.Url=} - The base URL of the platform, default is http://api.here.com. Note that if useHTTPS flag is passed it will override the URL scheme specified
 * in the opt_baseUrl to use HTTPS.
 * @return {!H.service.IConfigurable}
 */
H.service.venues.Service.prototype.configure = function(appId, appCode, useHTTPS, useCIT, opt_baseUrl) {};
/**
 * @record
 * @struct
 */
H.service.venues.Service.Options = function() {};
 /** @type {string} */
H.service.venues.Service.Options.prototype.subDomain;
 /** @type {string} */
H.service.venues.Service.Options.prototype.path;

/** @const */
H.service.venues.Service.State = {};
/** @const {number} */
H.service.venues.Service.State.ERROR;
/** @const {number} */
H.service.venues.Service.State.INIT;
/** @const {number} */
H.service.venues.Service.State.READY;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.provider.ObjectProvider} provider {H.map.provider.ObjectProvider} - The provider of this object.
 * @param {string} uid {string} - The unique identifier of this space
 * @param {?=} data {*} - The meta data of this space
 * @param {boolean=} opt_isFloorSpace {boolean=} - Indicates whether this space represents a floor itself, defaults to false
 */
H.service.venues.Space = function(provider, uid, data, opt_isFloorSpace) {};

/**
 * The method indicates whether the spatial object represents the whole floor space or a space within a floor boundaries, that belongs to the floor.
 * @return {boolean}
 */
H.service.venues.Space.prototype.isFloorSpace = function() {};

/**
 * This method sets custom style to use for rendering the labels. Should be called before the first render of the space, otherwise has no any effect. Note that due to the design
 * consistency currently it is not allowed to change the font family and the size of the labels.
 * @param {(!H.map.SpatialStyle|!H.map.SpatialStyle.Options)} labelStyle {(H.map.SpatialStyle | H.map.SpatialStyle.Options)} - Custom label style
 * @return {void}
 */
H.service.venues.Space.prototype.initLabelStyle = function(labelStyle) {};

/**
 * Method returns parent object - floor (see H.service.venues.Floor) of the space.
 * @return {!H.service.venues.Floor}
 */
H.service.venues.Space.prototype.getFloor = function() {};

/**
 * Method returns raw data associated with the space. For more details on data format see
 * http://developer.here.com/rest-apis/documentation/venue-maps/topics/resource-type-venue-interaction-tile-space.html
 * @return {!Object}
 */
H.service.venues.Space.prototype.getData = function() {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.service.venues.Service} service {H.service.venues.Service}
 * @param {!H.service.venues.TileProvider.Options=} opt_options {H.service.venues.TileProvider.Options=}
 */
H.service.venues.TileProvider = function(service, opt_options) {};

/**
 * Method specifies which floor level of the venues must be fetched by provider. Floor level is global to all venues and defaults to 0.
 * @param {number} level {number}
 * @return {void}
 */
H.service.venues.TileProvider.prototype.setCurrentLevel = function(level) {};

/**
 * Method returns the floor level that provider uses for tile fetching.
 * @return {number}
 */
H.service.venues.TileProvider.prototype.getCurrentLevel = function() {};
/**
 * @record
 * @struct
 */
H.service.venues.TileProvider.Options = function() {};
 /** @type {number} */
H.service.venues.TileProvider.Options.prototype.tileCacheSize;
 /** @type {number} */
H.service.venues.TileProvider.Options.prototype.pixelRatio;

/**
 * @param {!H.service.venues.Space} space
 * @return {void}
 */
H.service.venues.TileProvider.Options.prototype.onSpaceCreated = function(space) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.map.provider.ObjectProvider} provider {H.map.provider.ObjectProvider} - The object provider of this venue
 * @param {string} uid {string} - The unique identifier of this venue
 */
H.service.venues.Venue = function(provider, uid) {};

/**
 * Method returns the building object, that belongs to the venue, with the given ID . The method doesn't attempt to fetch building data.
 * @param {string} id {string} - the ID of the building
 * @return {(void|!H.service.venues.Building)}
 */
H.service.venues.Venue.prototype.getBuilding = function(id) {};

/**
 * Method returns map of all loaded buildings associated with the venue.
 * @return {?}
 */
H.service.venues.Venue.prototype.getBuildings = function() {};
/** @const */
H.ui = {};
/**
 * @extends {H.ui.base.Container}
 * @constructor
 * @struct
 */
H.ui.Control = function() {};

/**
 * This abstract method can be overridden by deriving classes to be invoked when the UI object&#x27;s unit system changes.
 * @param {H.ui.UnitSystem} unitSystem {H.ui.UnitSystem} - the unit system the UI currently uses
 * @return {void}
 */
H.ui.Control.prototype.onUnitSystemChange = function(unitSystem) {};

/**
 * This abstract method can be overridden by deriving classes to be invoked when the underlying map engine changes.
 * @param {H.Map.EngineType} engineType {H.Map.EngineType} - the engine type the map currently uses
 * @return {void}
 */
H.ui.Control.prototype.onMapEngineTypeChange = function(engineType) {};

/**
 * This method returns the map to which this control is attached.
 * @return {!H.Map}
 */
H.ui.Control.prototype.getMap = function() {};

/**
 * This method returns the localization object which corresponds to the UI&#x27;s current locale.
 * @return {!H.ui.i18n.Localization}
 */
H.ui.Control.prototype.getLocalization = function() {};

/**
 * This method returns this control&#x27;s layout alignment.
 * @return {H.ui.LayoutAlignment}
 */
H.ui.Control.prototype.getAlignment = function() {};

/**
 * This method sets the control&#x27;s layout alignments.
 * @param {H.ui.LayoutAlignment} alignment {H.ui.LayoutAlignment} - The new alignment of the control
 * @return {!H.ui.Control}
 */
H.ui.Control.prototype.setAlignment = function(alignment) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.ui.DistanceMeasurement.Options=} opt_options {H.ui.DistanceMeasurement.Options=} - optional parameters to be passed to this control
 */
H.ui.DistanceMeasurement = function(opt_options) {};
/**
 * @record
 * @struct
 */
H.ui.DistanceMeasurement.Options = function() {};
 /** @type {H.ui.LayoutAlignment} */
H.ui.DistanceMeasurement.Options.prototype.alignment;
 /** @type {!H.map.Icon} */
H.ui.DistanceMeasurement.Options.prototype.startIcon;
 /** @type {!H.map.Icon} */
H.ui.DistanceMeasurement.Options.prototype.stopoverIcon;
 /** @type {!H.map.Icon} */
H.ui.DistanceMeasurement.Options.prototype.endIcon;
 /** @type {!H.map.Icon} */
H.ui.DistanceMeasurement.Options.prototype.splitIcon;
 /** @type {(!H.map.SpatialStyle|!H.map.SpatialStyle.Options)} */
H.ui.DistanceMeasurement.Options.prototype.lineStyle;

/**
 * @param {number} n
 * @return {void}
 */
H.ui.DistanceMeasurement.Options.prototype.distanceFormatter = function(n) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.geo.IPoint} position {H.geo.IPoint} - the geo-position to which this info bubble corresponds
 * @param {!H.ui.InfoBubble.Options=} opt_options {H.ui.InfoBubble.Options=} - optional parameters to be passed to the info bubble
 */
H.ui.InfoBubble = function(position, opt_options) {};

/**
 * This method sets the geo-position of this info bubble
 * @param {(!H.geo.IPoint|!H.geo.Point)} position {(H.geo.IPoint | H.geo.Point)} - the new geo-position of this bubble
 * @return {void}
 */
H.ui.InfoBubble.prototype.setPosition = function(position) {};

/**
 * This method returns this info bubble's current state.
 * @return {H.ui.InfoBubble.State}
 */
H.ui.InfoBubble.prototype.getState = function() {};

/**
 * This method sets the info bubble's state.
 * @param {H.ui.InfoBubble.State} state {H.ui.InfoBubble.State} - the new state
 * @return {void}
 */
H.ui.InfoBubble.prototype.setState = function(state) {};

/**
 * This method closes the info bubble (setting its state to CLOSED)
 * @return {void}
 */
H.ui.InfoBubble.prototype.close = function() {};

/**
 * This method opens the info bubble (setting its state to OPEN)
 * @return {void}
 */
H.ui.InfoBubble.prototype.open = function() {};

/**
 * This method returns the bubble's content element.
 * 
 * Note: Before adding an info bubble to a UI object the content element is null.
 * @return {!HTMLElement}
 */
H.ui.InfoBubble.prototype.getContentElement = function() {};

/**
 * This methods sets the content of the info bubble. This can either be a string (applied as innerHTML) to the content element of this info bubble or a HTML node which is appended
 * to the content element.
 * @param {(string|!Node)} content {(string | Node)} - the content for this bubble
 * @return {void}
 */
H.ui.InfoBubble.prototype.setContent = function(content) {};

/** @const */
H.ui.InfoBubble.State = {};
/** @const {number} */
H.ui.InfoBubble.State.OPEN;
/** @const {number} */
H.ui.InfoBubble.State.CLOSED;
/**
 * @record
 * @struct
 */
H.ui.InfoBubble.Options = function() {};
 /** @type {(string|!Node)} */
H.ui.InfoBubble.Options.prototype.content;

/**
 * a callback to be invoked when the info bubble's state changes
 * @param {!H.util.Event} event {H.util.Event}
 * @return {void}
 */
H.ui.InfoBubble.Options.prototype.onStateChange = function(event) {};

/** @const */
H.ui.LayoutAlignment = {};
/** @const {number} */
H.ui.LayoutAlignment.TOP_LEFT;
/** @const {number} */
H.ui.LayoutAlignment.TOP_CENTER;
/** @const {number} */
H.ui.LayoutAlignment.TOP_RIGHT;
/** @const {number} */
H.ui.LayoutAlignment.LEFT_TOP;
/** @const {number} */
H.ui.LayoutAlignment.LEFT_MIDDLE;
/** @const {number} */
H.ui.LayoutAlignment.LEFT_BOTTOM;
/** @const {number} */
H.ui.LayoutAlignment.RIGHT_TOP;
/** @const {number} */
H.ui.LayoutAlignment.RIGHT_MIDDLE;
/** @const {number} */
H.ui.LayoutAlignment.RIGHT_BOTTOM;
/** @const {number} */
H.ui.LayoutAlignment.BOTTOM_LEFT;
/** @const {number} */
H.ui.LayoutAlignment.BOTTOM_CENTER;
/** @const {number} */
H.ui.LayoutAlignment.BOTTOM_RIGHT;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.ui.MapSettingsControl.Options=} opt_options {H.ui.MapSettingsControl.Options=} - optional parameters to be passed to this control
 */
H.ui.MapSettingsControl = function(opt_options) {};

/**
 * Sets the traffic incidents layer to be shown when activating the respective button on the map settings control.
 * @param {!H.map.layer.Layer} incidentsLayer {H.map.layer.Layer} - the incidents layer
 * @return {void}
 */
H.ui.MapSettingsControl.prototype.setIncidentsLayer = function(incidentsLayer) {};
/**
 * @record
 * @struct
 */
H.ui.MapSettingsControl.MapTypeEntry = function() {};
 /** @type {string} */
H.ui.MapSettingsControl.MapTypeEntry.prototype.name;
 /** @type {!H.service.MapType} */
H.ui.MapSettingsControl.MapTypeEntry.prototype.mapType;
/**
 * @record
 * @struct
 */
H.ui.MapSettingsControl.Options = function() {};
 /** @type {H.ui.LayoutAlignment} */
H.ui.MapSettingsControl.Options.prototype.alignment;
 /** @type {!Array<!H.ui.MapSettingsControl.MapTypeEntry>} */
H.ui.MapSettingsControl.Options.prototype.entries;
 /** @type {!H.map.layer.Layer} */
H.ui.MapSettingsControl.Options.prototype.incidents;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.ui.Pano.Options=} opt_options {H.ui.Pano.Options=} - optional parameters to be passed to the map.
 */
H.ui.Pano = function(opt_options) {};
/**
 * @record
 * @struct
 */
H.ui.Pano.Options = function() {};
 /** @type {H.ui.LayoutAlignment} */
H.ui.Pano.Options.prototype.alignment;
 /** @type {!H.service.MapType} */
H.ui.Pano.Options.prototype.mapTypes;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.ui.ScaleBar.Options=} opt_options {H.ui.ScaleBar.Options=} - optional parameters to be passed to this scale bar.
 */
H.ui.ScaleBar = function(opt_options) {};
/**
 * @record
 * @struct
 */
H.ui.ScaleBar.Options = function() {};
 /** @type {H.ui.LayoutAlignment} */
H.ui.ScaleBar.Options.prototype.alignment;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.Map} map {H.Map}
 * @param {!H.ui.UI.Options=} opt_options {H.ui.UI.Options=}
 */
H.ui.UI = function(map, opt_options) {};

/**
 * This method returns this ui's root element.
 * @return {!Element}
 */
H.ui.UI.prototype.getElement = function() {};

/**
 * Returns the map instance to which this UI was added.
 * @return {!H.Map}
 */
H.ui.UI.prototype.getMap = function() {};

/**
 * This method returns this UI object's current unit system.
 * @return {H.ui.UnitSystem}
 */
H.ui.UI.prototype.getUnitSystem = function() {};

/**
 * This method sets this UI object's unit system for displaying distances.
 * @param {H.ui.UnitSystem} unitSystem {H.ui.UnitSystem} - the unit system to use
 * @return {void}
 */
H.ui.UI.prototype.setUnitSystem = function(unitSystem) {};

/**
 * Toggles this UI's unit system between {\@link H.ui.UnitSystem.METRIC} and {\@link H.ui.UnitSystem.IMPERIAL}.
 * @return {void}
 */
H.ui.UI.prototype.toggleUnitSystem = function() {};

/**
 * This method adds an info bubble to the UI.
 * @param {!H.ui.InfoBubble} bubble {H.ui.InfoBubble} - the info bubble to be added
 * @return {void}
 */
H.ui.UI.prototype.addBubble = function(bubble) {};

/**
 * This method removes a previously added info bubble from the UI.
 * @param {!H.ui.InfoBubble} bubble {H.ui.InfoBubble} - the info bubble to be removed
 * @return {void}
 */
H.ui.UI.prototype.removeBubble = function(bubble) {};

/**
 * This method returns a list of info bubble objects which are currently attached to this UI.
 * @return {!Array<!H.ui.InfoBubble>}
 */
H.ui.UI.prototype.getBubbles = function() {};

/**
 * This method appends a control to the UI.
 * @param {string} name {string} - the name under which to register this control
 * @param {!H.ui.Control} control {H.ui.Control} - the control to add to this UI
 * @return {void}
 */
H.ui.UI.prototype.addControl = function(name, control) {};

/**
 * Removes a previously registered control from the UI object.
 * @param {string} name {string} - the name under which this control was previously registered
 * @return {!H.ui.Control}
 */
H.ui.UI.prototype.removeControl = function(name) {};

/**
 * This method returns a UI control which was previously registered with the provided name.
 * @param {string} name {string} - the name under which the control was registered.
 * @return {!H.ui.Control}
 */
H.ui.UI.prototype.getControl = function(name) {};

/**
 * This function creates the default UI including the zoom control,
 * map settings control and scalebar and panorama discovery control.
 * The default controls will be assigned the following values:
 * 
 * Zoom control:
 *     id: 'zoom'
 *     alignment: 'right-middle'
 * Map settings control:
 *     id: 'mapsettings'
 *     alignment: 'bottom-right'
 * Scalebar:
 *     id: 'scalebar'
 *     alignment: 'bottom-right'
 * Pano:
 *     id: 'panorama'
 *     alignment: 'top-right'
 * 
 * @param {!H.Map} map {H.Map} - The map instance to which to append the UI
 * @param {(!H.service.DefaultLayers|!H.service.Platform.MapTypes)} mapTypes {Object<H.service.MapType>} - The map types to use
 * @param {(string|!H.ui.i18n.Localization)=} opt_locale {(H.ui.i18n.Localization | string)=} - the language to use (or a full localization object).
 * @return {!H.ui.UI}
 */
H.ui.UI.createDefault = function(map, mapTypes, opt_locale) {};

/**
 * This method is used to capture the element view
 * @param {!HTMLCanvasElement} canvas {HTMLCanvasElement} - HTML Canvas element to draw the view of the capturable element
 * @param {number} pixelRation {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
 * @param {function(!HTMLCanvasElement): void} callback {ICapturable~captureCallback} - Callback function to call once result of the capturing is ready
 * @param {function(string): void=} opt_errback {ICapturable~errorCallback} - Callback function to call if error occurred during capturing
 * @return {void}
 */
H.ui.UI.prototype.capture = function(canvas, pixelRation, callback, opt_errback) {};
/**
 * @record
 * @struct
 */
H.ui.UI.Options = function() {};
 /** @type {H.ui.UnitSystem} */
H.ui.UI.Options.prototype.unitSystem;
 /** @type {(boolean|!H.ui.ZoomControl.Options)} */
H.ui.UI.Options.prototype.zoom;
 /** @type {(boolean|!H.ui.ZoomRectangle.Options)} */
H.ui.UI.Options.prototype.zoomrectangle;
 /** @type {(boolean|!H.ui.MapSettingsControl.Options)} */
H.ui.UI.Options.prototype.mapsettings;
 /** @type {(boolean|!H.ui.ScaleBar.Options)} */
H.ui.UI.Options.prototype.scalebar;
 /** @type {(boolean|!H.ui.Pano.Options)} */
H.ui.UI.Options.prototype.panorama;
 /** @type {(boolean|!H.ui.DistanceMeasurement.Options)} */
H.ui.UI.Options.prototype.distancemeasurement;
 /** @type {(string|!H.ui.i18n.Localization)} */
H.ui.UI.Options.prototype.locale;

/** @const */
H.ui.UnitSystem = {};
/** @const {number} */
H.ui.UnitSystem.IMPERIAL;
/** @const {number} */
H.ui.UnitSystem.METRIC;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.ui.ZoomControl.Options=} opt_options {H.ui.ZoomControl.Options=} - optional parameters to be passed to the map.
 */
H.ui.ZoomControl = function(opt_options) {};

/**
 * This method returns the zoom speed (in levels per millisecond) which is applied when the button is pressed constantly.
 * @return {number}
 */
H.ui.ZoomControl.prototype.getZoomSpeed = function() {};
/**
 * @record
 * @struct
 */
H.ui.ZoomControl.Options = function() {};
 /** @type {number} */
H.ui.ZoomControl.Options.prototype.zoomSpeed;
 /** @type {H.ui.LayoutAlignment} */
H.ui.ZoomControl.Options.prototype.alignment;
 /** @type {boolean} */
H.ui.ZoomControl.Options.prototype.slider;
 /** @type {boolean} */
H.ui.ZoomControl.Options.prototype.sliderSnaps;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.ui.ZoomRectangle.Options=} opt_options {H.ui.ZoomRectangle.Options=} - optional parameters to be passed to this control
 */
H.ui.ZoomRectangle = function(opt_options) {};
/**
 * @record
 * @struct
 */
H.ui.ZoomRectangle.Options = function() {};
 /** @type {H.ui.LayoutAlignment} */
H.ui.ZoomRectangle.Options.prototype.alignment;

/**
 * @param {number} n
 * @param {!H.Map} m
 * @return {number}
 */
H.ui.ZoomRectangle.Options.prototype.adjustZoom = function(n, m) {};

/** @typedef {!Element} */
H.ui.ES6Element;
/** @const */
H.ui.base = {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {string=} opt_elementType {string=} - the type of HTML element this UI element renders as, default is 'div'
 * @param {string=} opt_className {string=} - an optional class name to be used on this element
 * @param {!Array<!H.ui.base.Element>=} opt_children {Array<H.ui.base.Element>=} - optional child elements to be added to this container
 */
H.ui.base.Container = function(opt_elementType, opt_className, opt_children) {};

/**
 * Adds a child element to be rendered within the container element.
 * @param {!H.ui.base.Element} child {H.ui.base.Element} - the child element to be added
 * @return {!H.ui.base.Container}
 */
H.ui.base.Container.prototype.addChild = function(child) {};

/**
 * Returns the child collection of this container.
 * @return {!Array<!H.ui.base.Element>}
 */
H.ui.base.Container.prototype.getChildren = function() {};

/**
 * Removes a child element from this container's child collection.
 * @param {!H.ui.base.Element} child {H.ui.base.Element} - the child element to be removed
 * @return {void}
 */
H.ui.base.Container.prototype.removeChild = function(child) {};

/**
 * This method is the concrete implementation of the UI element. This method receives the pre-rendered HTML element which may be modified by deriving classes.
 * @param {!Element} element {Element} - this UI element's HTML representation
 * @param {!Document} doc {Document} - the HTML document into which the element is currently being rendered
 * @return {void}
 */
H.ui.base.Container.prototype.renderInternal = function(element, doc) {};

/**
 * This method returns this UI element's disabled state as a boolean value.
 * @return {boolean}
 */
H.ui.base.Container.prototype.isDisabled = function() {};

/**
 * This method set's the disabled state of this UI element.
 * @param {boolean} disabled {boolean} - true to disable the element, false to enable it
 * @param {boolean=} opt_force {boolean=} - an optional boolean flag indicating that the value should be set and propagated even if it is the same as the current state
 * @return {!Element}
 */
H.ui.base.Container.prototype.setDisabled = function(disabled, opt_force) {};

/**
 * This method returns a previously stored arbitrary data from this element.
 * @return {?}
 */
H.ui.base.Container.prototype.getData = function() {};

/**
 * This method stores arbitrary data with this UI element.
 * @param {?} data {*} - the data to be stored
 * @return {void}
 */
H.ui.base.Container.prototype.setData = function(data) {};

/**
 * This method returns the HTML element this UI element renders.
 * 
 * Note: Before the UI element was rendered the method returns null.
 * @return {!HTMLElement}
 */
H.ui.base.Container.prototype.getElement = function() {};

/**
 * Sets the visibility of this element.
 * @param {boolean} visibility {boolean} - visibility
 * @return {void}
 */
H.ui.base.Container.prototype.setVisibility = function(visibility) {};

/**
 * Returns the visibility of this element.
 * @return {boolean}
 */
H.ui.base.Container.prototype.getVisibility = function() {};

/**
 * This method adds a CSS class to this UI element (if it is not already present).
 * @param {string} className {string} - the CSS class name to add
 * @return {!H.ui.base.Element}
 */
H.ui.base.Container.prototype.addClass = function(className) {};

/**
 * This method removes a CSS class from this UI element (if it is present).
 * @param {string} className {string} - the CSS class name to remove
 * @return {!H.ui.base.Element}
 */
H.ui.base.Container.prototype.removeClass = function(className) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {string=} opt_elementType {string=} - the type of HTML element this UI element renders as, default is 'div'
 * @param {string=} opt_className {string=} - an optional class name to be used on this element
 */
H.ui.base.Element = function(opt_elementType, opt_className) {};

/**
 * This method is the concrete implementation of the UI element. This method receives the pre-rendered HTML element which may be modified by deriving classes.
 * @param {!Element} element {Element} - this UI element's HTML representation
 * @param {!Document} doc {Document} - the HTML document into which the element is currently being rendered
 * @return {void}
 */
H.ui.base.Element.prototype.renderInternal = function(element, doc) {};

/**
 * This method returns this UI element's disabled state as a boolean value.
 * @return {boolean}
 */
H.ui.base.Element.prototype.isDisabled = function() {};

/**
 * This method set's the disabled state of this UI element.
 * @param {boolean} disabled {boolean} - true to disable the element, false to enable it
 * @param {boolean=} opt_force {boolean=} - an optional boolean flag indicating that the value should be set and propagated even if it is the same as the current state
 * @return {!Element}
 */
H.ui.base.Element.prototype.setDisabled = function(disabled, opt_force) {};

/**
 * This method returns a previously stored arbitrary data from this element.
 * @return {?}
 */
H.ui.base.Element.prototype.getData = function() {};

/**
 * This method stores arbitrary data with this UI element.
 * @param {?} data {*} - the data to be stored
 * @return {void}
 */
H.ui.base.Element.prototype.setData = function(data) {};

/**
 * This method returns the HTML element this UI element renders.
 * 
 * Note: Before the UI element was rendered the method returns null.
 * @return {!HTMLElement}
 */
H.ui.base.Element.prototype.getElement = function() {};

/**
 * Sets the visibility of this element.
 * @param {boolean} visibility {boolean} - visibility
 * @return {void}
 */
H.ui.base.Element.prototype.setVisibility = function(visibility) {};

/**
 * Returns the visibility of this element.
 * @return {boolean}
 */
H.ui.base.Element.prototype.getVisibility = function() {};

/**
 * This method adds a CSS class to this UI element (if it is not already present).
 * @param {string} className {string} - the CSS class name to add
 * @return {!H.ui.base.Element}
 */
H.ui.base.Element.prototype.addClass = function(className) {};

/**
 * This method removes a CSS class from this UI element (if it is present).
 * @param {string} className {string} - the CSS class name to remove
 * @return {!H.ui.base.Element}
 */
H.ui.base.Element.prototype.removeClass = function(className) {};
/** @const */
H.ui.i18n = {};
 /** @type {!Array<string>} */
H.ui.i18n.defaultLocales;

/**
 * @constructor
 * @struct
 * @param {string} locale
 * @param {?=} opt_translationMap
 */
H.ui.i18n.Localization = function(locale, opt_translationMap) {};

/**
 * This method returns current locale code i.e 'en-US'
 * @return {string}
 */
H.ui.i18n.Localization.prototype.getLocale = function() {};

/**
 * This method returns translation keys for current locale. Keys from this set can be used to get translations via translate method.
 * @return {!Array<string>}
 */
H.ui.i18n.Localization.prototype.getKeys = function() {};

/**
 * This method returns a boolean value indicating whether this localization object has a translation for the specified translation key.
 * @param {string} key {string} - a translation key
 * @return {boolean}
 */
H.ui.i18n.Localization.prototype.hasKey = function(key) {};

/**
 * This method returns translation for provided key. It throws exception if translation is not available
 * @param {string} key {string} - a translation key
 * @return {string}
 */
H.ui.i18n.Localization.prototype.translate = function(key) {};
/** @const */
H.util = {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {number} maxSize {number} - the maximum size of the cache
 * @param {function(string, ?, number): void=} opt_onDrop {function(string, ?, number)=} - A callback to be invoked when a data element is dropped from the cache
 * @param {function(string, ?, number): boolean=} opt_filter {(function(string, ?, number) : boolean)=} - A function to filter data elements that are not to be cached
 */
H.util.Cache = function(maxSize, opt_onDrop, opt_filter) {};

/**
 * This method sets this cache's maximum size to a new size. If the cache's contents exceed the new size, least recently used data elements will be dropped.
 * @param {number} maxSize {number} - the new maximum size of this cache.
 * @return {!H.util.Cache}
 */
H.util.Cache.prototype.setMaxSize = function(maxSize) {};

/**
 * This method returns the maximum size of this cache.
 * @return {number}
 */
H.util.Cache.prototype.getMaxSize = function() {};

/**
 * This method returns the current size of this cache.
 * @return {number}
 */
H.util.Cache.prototype.getCurrentSize = function() {};

/**
 * This method adds an element to the cache.
 * @param {?} id {*} - The identifier of this data element, the value is converted to a string.
 * @param {?} data {*} - the actual data to be stored
 * @param {number} size {number} - the size of the data element
 * @return {boolean}
 */
H.util.Cache.prototype.add = function(id, data, size) {};

/**
 * This method retrieves an element from the cache.
 * @param {string} id {string} - the ID of the data element to be retrieved.
 * @param {boolean=} opt_noUpdate {boolean=} - and optional flag to indicate that the retrieved object should not be marked as 'most recently used'.
 * @return {?}
 */
H.util.Cache.prototype.get = function(id, opt_noUpdate) {};

/**
 * This method explicitly drops an element from the cache.
 * @param {?} id {*} - the id of the item to drop
 * @return {void}
 */
H.util.Cache.prototype.drop = function(id) {};

/**
 * This method will execute the provided callback function on each of the cache's entries. If the optional match predicate is passed to this method the callback will only be executed
 * on those entries for which the predicated returns true.
 * @param {function(string, ?, number): void} callback {function(string, ?, number)} - the callback to be invoked for each entry
 * @param {?=} opt_ctx {Object=} - an optional context object to be used as this within the callback
 * @param {function(string, ?, number): boolean=} opt_matcher {(function(string, ?, number) : boolean)=} - an optional match predicate to customize on which entries the callback will be called
 * @return {void}
 */
H.util.Cache.prototype.forEach = function(callback, opt_ctx, opt_matcher) {};

/**
 * This method removes all data elements from the cache. If the optional match predicate is passed to this method only those data elements will be removed for which the predicate
 * return true.
 * @param {function(string, ?, number): boolean=} opt_matcher {(function(string, ?, number) : boolean)=} - an optional function that receives an entries id, data and size and may return true or false to either remove it or
 * leave the entry in the cache respectively
 * @return {void}
 */
H.util.Cache.prototype.removeAll = function(opt_matcher) {};

/**
 * This method registers a callback that should be called each time an entry is dropped from the cache.
 * @param {function(string, ?, number): void} callback {(function(string, ?, number))} - the callback to be invoked for each entry
 * @return {void}
 */
H.util.Cache.prototype.registerOnDrop = function(callback) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {string} type {string} - The type of the event
 * @param {?} newValue {*} - The new value of the property
 * @param {?} oldValue {*} - The previous value of the property
 */
H.util.ChangeEvent = function(type, newValue, oldValue) {};
 /** @type {?} */
H.util.ChangeEvent.prototype.target;
 /** @type {?} */
H.util.ChangeEvent.prototype.currentTarget;
 /** @type {string} */
H.util.ChangeEvent.prototype.type;
 /** @type {boolean} */
H.util.ChangeEvent.prototype.defaultPrevented;

/**
 * Sets defaultPrevented to true. Which can be used to prevent some default behavior.
 * @return {void}
 */
H.util.ChangeEvent.prototype.preventDefault = function() {};

/**
 * Stops propagation for current event.
 * @return {void}
 */
H.util.ChangeEvent.prototype.stopPropagation = function() {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.util.ContextItem.Options=} opt_options {H.util.ContextItem.Options=} - The values to initialize this context item
 */
H.util.ContextItem = function(opt_options) {};
 /** @type {!H.util.ContextItem} */
H.util.ContextItem.SEPARATOR;

/**
 * This method returns label of the context item
 * @return {string}
 */
H.util.ContextItem.prototype.getLabel = function() {};

/**
 * This method changes context item label to the specified one
 * @param {string} label {string} - New label for the context item
 * @return {!H.util.ContextItem}
 */
H.util.ContextItem.prototype.setLabel = function(label) {};

/**
 * This method returns disabled state of the context item.
 * @return {boolean}
 */
H.util.ContextItem.prototype.isDisabled = function() {};

/**
 * This method enables/disables the context item
 * @param {boolean} disabled {boolean} -  true to disable and false to enabled it
 * @return {!H.util.ContextItem}
 */
H.util.ContextItem.prototype.setDisabled = function(disabled) {};

/**
 * This method will dispatch event on the event target object
 * @param {(string|!H.util.Event)} evt {(H.util.Event | string)} - event object or event name
 * @return {void}
 */
H.util.ContextItem.prototype.dispatchEvent = function(evt) {};

/**
 * Removes listeners from this object. Classes that extend EventTarget may need to override this method in order to remove references to DOM Elements and additional listeners.
 * @return {void}
 */
H.util.ContextItem.prototype.dispose = function() {};

/**
 * This method adds callback which is triggered when the object is being disposed
 * @param {function(): void} callback {Function} - The callback function.
 * @param {!Object=} opt_scope {Object=} - An optional scope to call the callback in.
 * @return {void}
 */
H.util.ContextItem.prototype.addOnDisposeCallback = function(callback, opt_scope) {};
/**
 * @record
 * @struct
 */
H.util.ContextItem.Options = function() {};
 /** @type {string} */
H.util.ContextItem.Options.prototype.label;
 /** @type {boolean} */
H.util.ContextItem.Options.prototype.disabled;

/**
 * @param {!H.util.Event} event
 * @return {void}
 */
H.util.ContextItem.Options.prototype.callback = function(event) {};

/**
 * @constructor
 * @struct
 * Constructor
 */
H.util.Disposable = function() {};

/**
 * Method adds a callback which will be triggered when the object is disposed
 * @param {function(): void} callback {Function}
 * @param {!Object=} opt_scope {Object=}
 * @return {void}
 */
H.util.Disposable.prototype.addOnDisposeCallback = function(callback, opt_scope) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {string} type {string} - Event Type.
 * @param {?=} opt_target {Object=} - Reference to the object that is the target of this event. It has to implement the {\@link EventTargetInstance} interface.
 */
H.util.Event = function(type, opt_target) {};
 /** @type {?} */
H.util.Event.prototype.target;
 /** @type {?} */
H.util.Event.prototype.currentTarget;
 /** @type {string} */
H.util.Event.prototype.type;
 /** @type {boolean} */
H.util.Event.prototype.defaultPrevented;

/**
 * Sets defaultPrevented to true. Which can be used to prevent some default behavior.
 * @return {void}
 */
H.util.Event.prototype.preventDefault = function() {};

/**
 * Stops propagation for current event.
 * @return {void}
 */
H.util.Event.prototype.stopPropagation = function() {};

/**
 * @constructor
 * @struct
 * Constructor
 */
H.util.EventTarget = function() {};

/**
 * This method allows to listen for specific event triggered by the object. Keep in mind, that you must removeEventListener manually or dispose an object when you no longer need it.
 * Otherwise memory leak is possible.
 * @param {string} type {string} - name of event
 * @param {(!EventListener|!EventListenerObject)} handler {Function} - event handler function
 * @param {boolean=} opt_capture {boolean=} - if set to true will listen in the capture phase (bubble otherwise)
 * @param {?=} opt_scope {Object=} - scope for the handler function
 * @return {void}
 */
H.util.EventTarget.prototype.addEventListener = function(type, handler, opt_capture, opt_scope) {};

/**
 * This method will removed previously added listener from the event target
 * @param {string} type {string} - name of event
 * @param {(!EventListener|!EventListenerObject)} handler {Function} - event handler function
 * @param {boolean=} opt_capture {boolean=} - if set to true will listen in the capture phase (bubble otherwise)
 * @param {?=} opt_scope {Object=} - scope for the handler function
 * @return {void}
 */
H.util.EventTarget.prototype.removeEventListener = function(type, handler, opt_capture, opt_scope) {};

/**
 * This method will dispatch event on the event target object
 * @param {(string|!H.util.Event)} evt {H.util.Event | string} - event object or event name
 * @return {void}
 */
H.util.EventTarget.prototype.dispatchEvent = function(evt) {};

/**
 * Removes listeners from this object. Classes that extend EventTarget may need to override this method in order to remove references to DOM Elements and additional listeners.
 * @return {void}
 */
H.util.EventTarget.prototype.dispose = function() {};

/**
 * This method adds callback which is triggered when the object is being disposed
 * @param {function(): void} callback {Function} - The callback function.
 * @param {?=} opt_scope {Object=} - An optional scope to call the callback in.
 * @return {void}
 */
H.util.EventTarget.prototype.addOnDisposeCallback = function(callback, opt_scope) {};
/**
 * @record
 * @struct
 */
H.util.ICache = function() {};

/**
 * This method adds an element to the cache.
 * @param {?} id {*} - The identifier of this data element, the value is converted to a string.
 * @param {?} data {*} - the actual data to be stored
 * @param {number} size {number} - the size of the data element
 * @return {boolean}
 */
H.util.ICache.prototype.add = function(id, data, size) {};

/**
 * This method retrieves an element from the cache.
 * @param {string} id {string} - the ID of the data element to be retrieved.
 * @param {boolean=} opt_noUpdate {boolean=} - and optional flag to indicate that the retrieved object should not be marked as 'most recently used'.
 * @return {?}
 */
H.util.ICache.prototype.get = function(id, opt_noUpdate) {};

/**
 * This method explicitly drops an element from the cache.
 * @param {?} id {*} - the id of the item to drop
 * @return {void}
 */
H.util.ICache.prototype.drop = function(id) {};

/**
 * This method will execute the provided callback function on each of the cache's entries. If the optional match predicate is passed to this method the callback will only be executed on
 * those entries for which the predicated returns true.
 * @param {function(string, ?, number): void} callback {function(string, ?, number)} - the callback to be invoked for each entry
 * @param {!Object=} opt_ctx {Object=} - an optional context object to be used as this within the callback
 * @param {function(string, ?, number): boolean=} opt_matcher {(function(string, ?, number) : boolean)=} - an optional match predicate to customize on which entries the callback will be called
 * @return {void}
 */
H.util.ICache.prototype.forEach = function(callback, opt_ctx, opt_matcher) {};

/**
 * This method removes all data elements from the cache. If the optional match predicate is passed to this method only those data elements will be removed for which the predicate
 * return true.
 * @param {function(string, ?, number): boolean=} opt_matcher {(function(string, ?, number) : boolean)=} - an optional function that receives an entries id, data and size and may return true or false to either remove it or
 * leave the entry in the cache respectively
 * @return {void}
 */
H.util.ICache.prototype.removeAll = function(opt_matcher) {};

/**
 * This method registers a callback that should be called each time an entry is dropped from the cache.
 * @param {function(string, ?, number): void} callback {(function(string, ?, number))} - the callback to be invoked for each entry
 * @return {void}
 */
H.util.ICache.prototype.registerOnDrop = function(callback) {};
/**
 * @record
 * @struct
 */
H.util.ICancelable = function() {};

/**
 * This method is used to cancel current action
 * @return {void}
 */
H.util.ICancelable.prototype.cancel = function() {};
/**
 * @record
 * @struct
 */
H.util.ICapturable = function() {};

/**
 * This method is used to capture the element view
 * @param {!HTMLCanvasElement} canvas {HTMLCanvasElement} - HTML Canvas element to draw the view of the capturable element
 * @param {number} pixelRation {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
 * @param {function(!HTMLCanvasElement): void} callback {ICapturable~captureCallback} - Callback function to call once result of the capturing is ready
 * @param {function(string): void=} opt_errback {ICapturable~errorCallback} - Callback function to call if error occurred during capturing
 * @return {void}
 */
H.util.ICapturable.prototype.capture = function(canvas, pixelRation, callback, opt_errback) {};
/**
 * @extends {H.util.EventTarget}
 * @constructor
 * @struct
 */
H.util.OList = function() {};

/**
 * This method inserts an entry to the list. Optionally it can place new entry at provided index.
 * @param {?} entry {?} - The entry to insert
 * @param {number=} opt_idx {number=} - The index where the new entry should be inserted; if omitted or greater then the current size of the list, the entry is added at the end of the list;
 * a negative index is treated as being relative from the end of the list
 * @return {void}
 */
H.util.OList.prototype.add = function(entry, opt_idx) {};

/**
 * This method removes an entry by a given index from the list.
 * @param {number} idx {number} - The index of the entry which should be removed; a negative index is treated as being relative from the end of the list
 * @return {?}
 */
H.util.OList.prototype.removeAt = function(idx) {};

/**
 * This method removes the the first entry which is identical with the given entry.
 * @param {?} entry {?} - The entry to remove
 * @return {boolean}
 */
H.util.OList.prototype.remove = function(entry) {};

/**
 * This method replaces an entry at the given index with the given entry.
 * @param {number} idx {number} - The index of the entry which should be replaced; a negative index is treated as being relative from the end of the list
 * @param {?} entry {?} - The entry which replaces the existing one
 * @return {?}
 */
H.util.OList.prototype.set = function(idx, entry) {};

/**
 * This method retrieves the index of the first object in this list that is identical with the object supplied by the caller.
 * @param {?} entry {?} - The entry for which to return the index.
 * @return {number}
 */
H.util.OList.prototype.indexOf = function(entry) {};

/**
 * To get the entry at the specified index.
 * @param {number} idx {number} - The index of the entry to get a negative index is treated as being relative from the end of the list
 * @return {?}
 */
H.util.OList.prototype.get = function(idx) {};

/**
 * This method returns the length of the list.
 * @return {number}
 */
H.util.OList.prototype.getLength = function() {};

/**
 * This method returns all list's entries as an array.
 * @return {!Array<?>}
 */
H.util.OList.prototype.asArray = function() {};

/**
 * This method removes all entries from the list.
 * @return {void}
 */
H.util.OList.prototype.flush = function() {};

/**
 * This method will dispatch event on the event target object
 * @param {(string|!H.util.Event)} evt {(H.util.Event | string)} - event object or event name
 * @return {void}
 */
H.util.OList.prototype.dispatchEvent = function(evt) {};

/**
 * Removes listeners from this object. Classes that extend EventTarget may need to override this method in order to remove references to DOM Elements and additional listeners.
 * @return {void}
 */
H.util.OList.prototype.dispose = function() {};

/**
 * This method adds callback which is triggered when the object is being disposed
 * @param {function(): void} callback {Function} - The callback function.
 * @param {!Object=} opt_scope {Object=} - An optional scope to call the callback in.
 * @return {void}
 */
H.util.OList.prototype.addOnDisposeCallback = function(callback, opt_scope) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.util.OList} list {H.util.OList} - The OList instance which is emitting the event
 * @param {string} type {H.util.OList.prototype.EventType} - The type of the event
 * @param {number} idx {number} - The affected index within this list
 * @param {?} added {?*} - The value of the entry which was added or set
 * @param {?} removed {?*} - The value of the entry which was removed or replaced
 * @param {?} moved {?*} - The value of the entry which was moved
 */
H.util.OList.Event = function(list, type, idx, added, removed, moved) {};
 /** @type {?} */
H.util.OList.Event.prototype.target;
 /** @type {?} */
H.util.OList.Event.prototype.currentTarget;
 /** @type {string} */
H.util.OList.Event.prototype.type;
 /** @type {boolean} */
H.util.OList.Event.prototype.defaultPrevented;

/**
 * Sets defaultPrevented to true. Which can be used to prevent some default behavior.
 * @return {void}
 */
H.util.OList.Event.prototype.preventDefault = function() {};

/**
 * Stops propagation for current event.
 * @return {void}
 */
H.util.OList.Event.prototype.stopPropagation = function() {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {function(!H.util.Request): void=} opt_onprogress {function(H.util.Request)=} - A callback to invoke every time when the request's progress state changes
 * @param {number=} opt_total {number=} - The total number of processing steps to complete this request, default is 1
 */
H.util.Request = function(opt_onprogress, opt_total) {};

/**
 * Returns the state of this request
 * @return {H.util.Request.State}
 */
H.util.Request.prototype.getState = function() {};

/**
 * Returns the number of processing steps to complete this request
 * @return {number}
 */
H.util.Request.prototype.getTotal = function() {};

/**
 * Returns the number of steps which are already processed by this request
 * @return {number}
 */
H.util.Request.prototype.getProcessed = function() {};

/**
 * Returns the number of processingsteps which have been failed
 * @return {number}
 */
H.util.Request.prototype.getFailed = function() {};

/** @const */
H.util.Request.State = {};
/** @const {number} */
H.util.Request.State.PENDING;
/** @const {number} */
H.util.Request.State.PROCESSING;
/** @const {number} */
H.util.Request.State.COMPLETE;
/** @const {number} */
H.util.Request.State.CANCELLED;
/** @const {number} */
H.util.Request.State.ERROR;
/** @const */
H.util.animation = {};
/**
 * @constructor
 * @struct
 */
H.util.animation.ease = function() {};

/**
 * This function defines linear ease.
 * @param {number} val {number} - A value in range [0..1] to translate
 * @return {number}
 */
H.util.animation.ease.LINEAR = function(val) {};

/**
 * This function defines quadratic ease in.
 * @param {number} val {number} - A value in range [0..1] to translate
 * @return {number}
 */
H.util.animation.ease.EASE_IN_QUAD = function(val) {};

/**
 * This function defines quadratic ease out.
 * @param {number} val {number} - A value in range [0..1] to translate
 * @return {number}
 */
H.util.animation.ease.EASE_OUT_QUAD = function(val) {};

/**
 * This function defines ease in and out with slope.
 * @param {number} val {number} - A value in range [0..1] to translate
 * @return {number}
 */
H.util.animation.ease.EASE_IN_OUT_QUINT = function(val) {};

/**
 * This function defines ease out with circ function.
 * @param {number} val {number} - A value in range [0..1] to translate
 * @return {number}
 */
H.util.animation.ease.EASE_OUT_CIRC = function(val) {};
/** @const */
H.util.kinetics = {};
/**
 * @record
 * @struct
 */
H.util.kinetics.IKinetics = function() {};
 /** @type {number} */
H.util.kinetics.IKinetics.prototype.power;
 /** @type {number} */
H.util.kinetics.IKinetics.prototype.duration;

/**
 * Easing function modifies animation progress. In example it can modify the animation in a way it starts rapidly and then slows down at the end.
 * @param {number} p {number} - current progress
 * @return {number}
 */
H.util.kinetics.IKinetics.prototype.ease = function(p) {};
