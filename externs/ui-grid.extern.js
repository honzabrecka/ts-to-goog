/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/ui-grid/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
/** @const */
var uiGrid = {};
/**
 * @record
 * @struct
 */
uiGrid.IUiGridConstants = function() {};
 /** @type {boolean} */
uiGrid.IUiGridConstants.prototype.LOG_DEBUG_MESSAGES;
 /** @type {boolean} */
uiGrid.IUiGridConstants.prototype.LOG_WARN_MESSAGES;
 /** @type {boolean} */
uiGrid.IUiGridConstants.prototype.LOG_ERROR_MESSAGES;
 /** @type {!RegExp} */
uiGrid.IUiGridConstants.prototype.CUSTOM_FILTERS;
 /** @type {!RegExp} */
uiGrid.IUiGridConstants.prototype.COL_FIELD;
 /** @type {!RegExp} */
uiGrid.IUiGridConstants.prototype.MODEL_COL_FIELD;
 /** @type {!RegExp} */
uiGrid.IUiGridConstants.prototype.TOOLTIP;
 /** @type {!RegExp} */
uiGrid.IUiGridConstants.prototype.DISPLAY_CELL_TEMPLATE;
 /** @type {!RegExp} */
uiGrid.IUiGridConstants.prototype.TEMPLATE_REGEXP;
 /** @type {!RegExp} */
uiGrid.IUiGridConstants.prototype.FUNC_REGEXP;
 /** @type {!RegExp} */
uiGrid.IUiGridConstants.prototype.DOT_REGEXP;
 /** @type {!RegExp} */
uiGrid.IUiGridConstants.prototype.APOS_REGEXP;
 /** @type {!RegExp} */
uiGrid.IUiGridConstants.prototype.BRACKET_REGEXP;
 /** @type {string} */
uiGrid.IUiGridConstants.prototype.COL_CLASS_PREFIX;
 /** @type {{GRID_SCROLL: string, COLUMN_MENU_SHOWN: string, ITEM_DRAGGING: string, COLUMN_HEADER_CLICK: string}} */
uiGrid.IUiGridConstants.prototype.events;
 /** @type {{TAB: number, STRG: number, CAPSLOCK: number, CTRL: number, CTRLRIGHT: number, CTRLR: number, SHIFT: number, RETURN: number, ENTER: number, BACKSPACE: number, BCKSP: number, ALT: number, ALTR: number, ALTRIGHT: number, SPACE: number, WIN: number, MAC: number, FN: number, PG_UP: number, PG_DOWN: number, UP: number, DOWN: number, LEFT: number, RIGHT: number, ESC: number, DEL: number, F1: number, F2: number, F3: number, F4: number, F5: number, F6: number, F7: number, F8: number, F9: number, F10: number, F11: number, F12: number}} */
uiGrid.IUiGridConstants.prototype.keymap;
 /** @type {string} */
uiGrid.IUiGridConstants.prototype.ASC;
 /** @type {string} */
uiGrid.IUiGridConstants.prototype.DESC;
 /** @type {{STARTS_WITH: number, ENDS_WITH: number, EXACT: number, CONTAINS: number, GREATER_THAN: number, GREATER_THAN_OR_EQUAL: number, LESS_THAN: number, LESS_THAN_OR_EQUAL: number, NOT_EQUAL: number, SELECT: string, INPUT: string}} */
uiGrid.IUiGridConstants.prototype.filter;
 /** @type {{UP: string, DOWN: string, LEFT: string, RIGHT: string, NONE: string}} */
uiGrid.IUiGridConstants.prototype.scrollDirection;
 /** @type {{sum: number, count: number, avg: number, min: number, max: number}} */
uiGrid.IUiGridConstants.prototype.aggregationTypes;
 /** @type {!Array<string>} */
uiGrid.IUiGridConstants.prototype.CURRENCY_SYMBOLS;
 /** @type {{ALL: string, EDIT: string, ROW: string, COLUMN: string, OPTIONS: string}} */
uiGrid.IUiGridConstants.prototype.dataChange;
 /** @type {{NEVER: number, ALWAYS: number}} */
uiGrid.IUiGridConstants.prototype.scrollbars;

/** @typedef {!uiGrid.IGridInstanceOf<?>} */
uiGrid.IGridInstance;
/**
 * @record
 * @struct
 */
uiGrid.IGridInstanceOf = function() {};
 /** @type {!angular.IScope} */
uiGrid.IGridInstanceOf.prototype.appScope;
 /** @type {!Array<!uiGrid.IGridColumnOf<?>>} */
uiGrid.IGridInstanceOf.prototype.columns;
 /** @type {number} */
uiGrid.IGridInstanceOf.prototype.columnFooterHeight;
 /** @type {number} */
uiGrid.IGridInstanceOf.prototype.footerHeight;
 /** @type {number} */
uiGrid.IGridInstanceOf.prototype.gridHeight;
 /** @type {boolean} */
uiGrid.IGridInstanceOf.prototype.isScrollingHorizontally;
 /** @type {boolean} */
uiGrid.IGridInstanceOf.prototype.isScrollingVertically;
 /** @type {number} */
uiGrid.IGridInstanceOf.prototype.scrollDirection;

/**
 * adds a row header column to the grid
 * @param {!uiGrid.IColumnDefOf<TEntity>} colDef
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.addRowHeaderColumn = function(colDef) {};

/**
 * uses the first row of data to assign colDef.type for any types not defined.
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.assignTypes = function() {};

/**
 * Populates columnDefs from the provided data
 * @param {!uiGrid.IRowBuilder<TEntity>} rowBuilder
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.buildColumnDefsFromData = function(rowBuilder) {};

/**
 * creates GridColumn objects from the columnDefinition.
 * Calls each registered columnBuilder to further process the column
 *        * orderByColumnDefs: defaults to false.  When true, buildColumns will order existing columns
 *        according to the order within the column definitions
 * @param {!uiGrid.IBuildColumnsOptions} options
 * @return {!angular.IPromise<?>}
 */
uiGrid.IGridInstanceOf.prototype.buildColumns = function(options) {};

/**
 * calls each styleComputation function
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.buildStyles = function() {};

/**
 * Calls the callbacks based on the type of data change that has occurred.
 * Always calls the ALL callbacks, calls the ROW, EDIT, COLUMN and OPTIONS callbacks
 * if the event type is matching, or if the type is ALL.
 *        (ALL, ROW, EDIT, COLUMN, OPTIONS
 * @param {number} type
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.callDataChangeCallbacks = function(type) {};

/**
 * Clears all filters and optionally refreshes the visible rows.
 * @param {boolean} refreshRows
 * @param {boolean} clearConditions
 * @param {boolean} clearFlags
 * @return {!angular.IPromise<?>}
 */
uiGrid.IGridInstanceOf.prototype.clearAllFilters = function(refreshRows, clearConditions, clearFlags) {};

/**
 * refreshes the grid when a column refresh is notified, which triggers handling of the visible flag.
 * This is called on uiGridConstants.dataChange.COLUMN, and is registered as a dataChangeCallback in grid.js
 * @param {string} name
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.columnRefreshCallback = function(name) {};

/**
 * creates the left render container if it doesn't already exist
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.createLeftContainer = function() {};

/**
 * creates the right render container if it doesn't already exist
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.createRightContainer = function() {};

/**
 * sets isScrollingHorizontally to true and sets it to false in a debounced function
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.flagScrollingHorizontally = function() {};

/**
 * sets isScrollingVertically to true and sets it to false in a debounced function
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.flagScrollingVertically = function() {};

/**
 * Gets the displayed value of a cell after applying any the cellFilter
 * @param {!uiGrid.IGridRowOf<TEntity>} row
 * @param {!uiGrid.IGridColumnOf<TEntity>} col
 * @return {string}
 */
uiGrid.IGridInstanceOf.prototype.getCellDisplayValue = function(row, col) {};

/**
 * Gets the displayed value of a cell
 * @param {!uiGrid.IGridRowOf<TEntity>} row
 * @param {!uiGrid.IGridColumnOf<TEntity>} col
 * @return {?}
 */
uiGrid.IGridInstanceOf.prototype.getCellValue = function(row, col) {};

/**
 * returns a grid colDef for the column name
 * @param {string} name
 * @return {!uiGrid.IColumnDefOf<TEntity>}
 */
uiGrid.IGridInstanceOf.prototype.getColDef = function(name) {};

/**
 * returns a grid column by name
 * @param {string} name
 * @return {!uiGrid.IGridColumnOf<TEntity>}
 */
uiGrid.IGridInstanceOf.prototype.getColumn = function(name) {};

/**
 * Return the columns that the grid is currently being sorted by
 * @return {!Array<!uiGrid.IGridColumnOf<TEntity>>}
 */
uiGrid.IGridInstanceOf.prototype.getColumnSorting = function() {};

/**
 * Returns the $parse-able accessor for a column within its $scope
 * @param {!uiGrid.IGridColumnOf<TEntity>} col
 * @return {string}
 */
uiGrid.IGridInstanceOf.prototype.getGridQualifiedColField = function(col) {};

/**
 * returns all columns except for rowHeader columns
 * @return {!Array<!uiGrid.IGridColumnOf<TEntity>>}
 */
uiGrid.IGridInstanceOf.prototype.getOnlyDataColumns = function() {};

/**
 * returns the GridRow that contains the rowEntity
 * @param {TEntity} rowEntity
 * @param {!Array<!uiGrid.IGridRowOf<TEntity>>=} rows
 * @return {!uiGrid.IGridRowOf<TEntity>}
 */
uiGrid.IGridInstanceOf.prototype.getRow = function(rowEntity, rows) {};

/**
 * Triggered when the browser window resizes; automatically resizes the grid
 * @param {!angular.IAngularEvent} $event
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.handleWindowResize = function($event) {};

/**
 * returns true if leftContainer exists
 * @return {boolean}
 */
uiGrid.IGridInstanceOf.prototype.hasLeftContainer = function() {};

/**
 * returns true if rightContainer exists
 * @return {boolean}
 */
uiGrid.IGridInstanceOf.prototype.hasRightContainer = function() {};

/**
 * returns true if leftContainer has columns
 * @return {boolean}
 */
uiGrid.IGridInstanceOf.prototype.hasLeftContainerColumns = function() {};

/**
 * returns true if rightContainer has columns
 * @return {boolean}
 */
uiGrid.IGridInstanceOf.prototype.hasRightContainerColumns = function() {};

/**
 * Is grid right to left
 * @return {boolean}
 */
uiGrid.IGridInstanceOf.prototype.isRTL = function() {};

/**
 * Checks if column is a row header
 * @param {!uiGrid.IGridColumnOf<TEntity>} column
 * @return {boolean}
 */
uiGrid.IGridInstanceOf.prototype.isRowHeaderColumn = function(column) {};

/**
 * creates or removes GridRow objects from the newRawData array.  Calls each registered
 * rowBuilder to further process the row
 * 
 * This method aims to achieve three things:
 * 1. the resulting rows array is in the same order as the newRawData, we'll call
 * rowsProcessors immediately after to sort the data anyway
 * 2. if we have row hashing available, we try to use the rowHash to find the row
 * 3. no memory leaks - rows that are no longer in newRawData need to be garbage collected
 * 
 * The basic logic flow makes use of the newRawData, oldRows and oldHash, and creates
 * the newRows and newHash
 * 
 * Rows are identified using the hashKey if configured.  If not configured, then rows
 * are identified using the gridOptions.rowEquality function
 * @param {!Array<TEntity>} newRawData
 * @return {!angular.IPromise<?>}
 */
uiGrid.IGridInstanceOf.prototype.modifyRows = function(newRawData) {};

/**
 * Notify the grid that a data or config change has occurred,
 * where that change isn't something the grid was otherwise noticing.  This
 * might be particularly relevant where you've changed values within the data
 * and you'd like cell classes to be re-evaluated, or changed config within
 * the columnDef and you'd like headerCellClasses to be re-evaluated.
 * us which refreshes to fire
 * @param {string} type
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.notifyDataChange = function(type) {};

/**
 * precompiles all cell templates
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.precompileCellTemplates = function() {};

/**
 * processes all RowBuilders for the gridRow
 * @param {!uiGrid.IGridRowOf<TEntity>} gridRow
 * @return {!uiGrid.IGridRowOf<TEntity>}
 */
uiGrid.IGridInstanceOf.prototype.processRowBuilders = function(gridRow) {};

/**
 * calls the row processors, specifically
 * intended to reset the sorting when an edit is called,
 * registered as a dataChangeCallback on uiGridConstants.dataChange.EDIT
 * @param {string} name
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.processRowsCallback = function(name) {};

/**
 * queues a grid refresh, a way of debouncing all the refreshes we might otherwise issue
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.queueGridRefresh = function() {};

/**
 * queues a grid refreshCanvas, a way of debouncing all the refreshes we might otherwise issue
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.queueRefresh = function() {};

/**
 * Redraw the rows and columns based on our current scroll position
 *        recalculated
 * @param {boolean=} rowsAdded
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.redrawCanvas = function(rowsAdded) {};

/**
 * Refresh the rendered grid on screen.
 * The refresh method re-runs both the columnProcessors and the
 * rowProcessors, as well as calling refreshCanvas to update all
 * the grid sizing.  In general you should prefer to use queueGridRefresh
 * instead, which is basically a debounced version of refresh.
 * 
 * If you only want to resize the grid, not regenerate all the rows
 * and columns, you should consider directly calling refreshCanvas instead.
 * @param {boolean=} rowsAltered
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.refresh = function(rowsAltered) {};

/**
 * Builds all styles and recalculates much of the grid sizing
 *          has been refreshed
 * @param {boolean=} buildStyles
 * @return {!angular.IPromise<?>}
 */
uiGrid.IGridInstanceOf.prototype.refreshCanvas = function(buildStyles) {};

/**
 * Refresh the rendered rows on screen?  Note: not functional at present
 * @return {!angular.IPromise<?>}
 */
uiGrid.IGridInstanceOf.prototype.refreshRows = function() {};

/**
 * When the build creates columns from column definitions, the columnbuilders will be called to add
 * additional properties to the column.
 * @param {!uiGrid.IColumnBuilder<TEntity>} columnBuilder
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.registerColumnBuilder = function(columnBuilder) {};

/**
 * Register a "columns processor" function. When the columns are updated,
 * the grid calls each registered "columns processor", which has a chance
 * to alter the set of columns, as long as the count is not modified.
 *        is run in the context of the grid (i.e. this for the function will be the grid), and
 *        which must return an updated renderedColumnsToProcess which can be passed to the next processor
 *        in the chain
 * for other people to inject columns processors at intermediate priorities.
 * Lower priority columnsProcessors run earlier.priority
 * @param {!uiGrid.IColumnProcessor<TEntity>} columnProcessor
 * @param {number} priority
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.registerColumnsProcessor = function(columnProcessor, priority) {};

/**
 * When a data change occurs, the data change callbacks of the specified type
 * will be called.  The rules are:
 * 
 * - when the data watch fires, that is considered a ROW change (the data watch only notices
 *   added or removed rows)
 * - when the api is called to inform us of a change, the declared type of that change is used
 * - when a cell edit completes, the EDIT callbacks are triggered
 * - when the columnDef watch fires, the COLUMN callbacks are triggered
 * - when the options watch fires, the OPTIONS callbacks are triggered
 * 
 * For a given event:
 * - ALL calls ROW, EDIT, COLUMN, OPTIONS and ALL callbacks
 * - ROW calls ROW and ALL callbacks
 * - EDIT calls EDIT and ALL callbacks
 * - COLUMN calls COLUMN and ALL callbacks
 * - OPTIONS calls OPTIONS and ALL callbacks
 * 
 * the uiGridConstants.dataChange values ( ALL, EDIT, ROW, COLUMN, OPTIONS ).  Optional and defaults to
 * ALL
 * @param {function(!uiGrid.IGridInstanceOf): void} callback
 * @param {!Array<string>=} types
 * @return {!Function}
 */
uiGrid.IGridInstanceOf.prototype.registerDataChangeCallback = function(callback, types) {};

/**
 * When the build creates rows from gridOptions.data, the rowBuilders will be called to add
 * additional properties to the row.
 * @param {!uiGrid.IRowBuilder<TEntity>} rowBuilder
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.registerRowBuilder = function(rowBuilder) {};

/**
 * Register a "rows processor" function. When the rows are updated,
 * the grid calls each registered "rows processor", which has a chance
 * to alter the set of rows (sorting, etc) as long as the count is not
 * modified.
 * 
 * is run in the context of the grid (i.e. this for the function will be the grid), and must
 * return the updated rows list, which is passed to the next processor in the chain
 *        In general we try to do them in 100s to leave room for other people to inject rows processors at
 *        intermediate priorities.  Lower priority rowsProcessors run earlier. At present all rows visible
 *        is running at 50, filter is running at 100, sort is at 200, grouping at 400, selectable rows at
 *        500, pagination at 900 (pagination will generally want to be last)
 * @param {!uiGrid.IRowProcessor<TEntity>} rowProcessor
 * @param {number} priority
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.registerRowsProcessor = function(rowProcessor, priority) {};

/**
 * registered a styleComputation function
 * 
 * If the function returns a value it will be appended into the grid's `<style>` block
 * @param {function(!angular.IScope): string} styleComputation
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.registerStyleComputation = function(styleComputation) {};

/**
 * Remove a registered rows processor
 * @param {!uiGrid.IRowProcessor<TEntity>} rows
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.removeRowsProcessor = function(rows) {};

/**
 * Return the columns that the grid is currently being sorted by
 * @param {!uiGrid.IGridColumnOf<TEntity>} excludedColumn
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.resetColumnSorting = function(excludedColumn) {};

/**
 * Scroll the grid such that the specified
 * row and column is in view
 * @param {TEntity=} rowEntity
 * @param {!uiGrid.IColumnDefOf<TEntity>=} colDef
 * @return {!angular.IPromise<?>}
 */
uiGrid.IGridInstanceOf.prototype.scrollTo = function(rowEntity, colDef) {};

/**
 * Scrolls the grid to make a certain row and column combo visible,
 * in the case that it is not completely visible on the screen already.
 * @param {!uiGrid.IGridRowOf<TEntity>} gridRow
 * @param {!uiGrid.IGridColumnOf<TEntity>} gridCol
 * @return {!angular.IPromise<?>}
 */
uiGrid.IGridInstanceOf.prototype.scrollToIfNecessary = function(gridRow, gridCol) {};

/**
 * Set the sorting on a given column, optionally resetting any existing sorting on the Grid.
 * Emits the sortChanged event whenever the sort criteria are changed.
 *        either descending or ascending.  If not provided, the column will iterate through the sort
 *        directions: ascending, descending, unsorted.
 *        reset any existing sorting and sort by this column only
 * @param {!uiGrid.IGridColumnOf<TEntity>} column
 * @param {string=} direction
 * @param {boolean=} add
 * @return {!angular.IPromise<!uiGrid.IGridColumnOf<TEntity>>}
 */
uiGrid.IGridInstanceOf.prototype.sortColumn = function(column, direction, add) {};

/**
 * flags all render containers to update their canvas height
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.updateCanvasHeight = function() {};

/**
 * recalculates the footer height,
 * registered as a dataChangeCallback on uiGridConstants.dataChange.OPTIONS
 * @param {string} name
 * @return {void}
 */
uiGrid.IGridInstanceOf.prototype.updateFooterHeightCallback = function(name) {};
/**
 * @record
 * @struct
 */
uiGrid.IBuildColumnsOptions = function() {};
 /** @type {boolean} */
uiGrid.IBuildColumnsOptions.prototype.orderByColumnDefs;
/**
 * @record
 * @struct
 */
uiGrid.IStyleComputation = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.IColumnBuilder = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.IRowBuilder = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.IRowProcessor = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.IColumnProcessor = function() {};

/* TODO: CallSignature: uiGrid */

/** @typedef {!uiGrid.IGridOptionsOf<?>} */
uiGrid.IGridOptions;
/**
 * @extends {uiGrid.cellNav.IGridOptions}
 * @extends {uiGrid.edit.IGridOptions}
 * @extends {uiGrid.expandable.IGridOptions}
 * @extends {uiGrid.exporter.IGridOptions}
 * @extends {uiGrid.grouping.IGridOptions}
 * @extends {uiGrid.importer.IGridOptions}
 * @extends {uiGrid.infiniteScroll.IGridOptions}
 * @extends {uiGrid.moveColumns.IGridOptions}
 * @extends {uiGrid.pagination.IGridOptions}
 * @extends {uiGrid.pinning.IGridOptions}
 * @extends {uiGrid.resizeColumns.IGridOptions}
 * @extends {uiGrid.rowEdit.IGridOptions}
 * @extends {uiGrid.saveState.IGridOptions}
 * @extends {uiGrid.selection.IGridOptions}
 * @extends {uiGrid.treeBase.IGridOptions}
 * @extends {uiGrid.treeView.IGridOptions}
 * @record
 * @struct
 */
uiGrid.IGridOptionsOf = function() {};
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.aggregationCalcThrottle;
 /** @type {(!Object|!angular.IScope)} */
uiGrid.IGridOptionsOf.prototype.appScopeProvider;
 /** @type {!Array<!uiGrid.IColumnDefOf<TEntity>>} */
uiGrid.IGridOptionsOf.prototype.columnDefs;
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.columnFooterHeight;
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.columnVirtualizationThreshold;
 /** @type {(string|!Array<TEntity>)} */
uiGrid.IGridOptionsOf.prototype.data;
 /** @type {boolean} */
uiGrid.IGridOptionsOf.prototype.enableColumnMenus;
 /** @type {boolean} */
uiGrid.IGridOptionsOf.prototype.enableFiltering;
 /** @type {boolean} */
uiGrid.IGridOptionsOf.prototype.enableGridMenu;
 /** @type {(number|boolean)} */
uiGrid.IGridOptionsOf.prototype.enableHorizontalScrollbar;
 /** @type {boolean} */
uiGrid.IGridOptionsOf.prototype.enableMinHeightCheck;
 /** @type {boolean} */
uiGrid.IGridOptionsOf.prototype.enableRowHashing;
 /** @type {boolean} */
uiGrid.IGridOptionsOf.prototype.enableSorting;
 /** @type {(number|boolean)} */
uiGrid.IGridOptionsOf.prototype.enableVerticalScrollbar;
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.excessColumns;
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.excessRows;
 /** @type {!Array<string>} */
uiGrid.IGridOptionsOf.prototype.excludeProperties;
 /** @type {boolean} */
uiGrid.IGridOptionsOf.prototype.flatEntityAccess;
 /** @type {string} */
uiGrid.IGridOptionsOf.prototype.footerTemplate;
 /** @type {string} */
uiGrid.IGridOptionsOf.prototype.gridFooterTemplate;
 /** @type {string} */
uiGrid.IGridOptionsOf.prototype.headerTemplate;
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.horizontalScrollThreshold;
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.infiniteScrollRowsFromEnd;
 /** @type {boolean} */
uiGrid.IGridOptionsOf.prototype.infiniteScrollUp;
 /** @type {boolean} */
uiGrid.IGridOptionsOf.prototype.infiniteScrollDown;
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.maxVisibleColumnCount;
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.minRowsToShow;
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.minimumColumnSize;
 /** @type {function(!uiGrid.IGridApiOf<TEntity>): void} */
uiGrid.IGridOptionsOf.prototype.onRegisterApi;
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.rowHeight;
 /** @type {string} */
uiGrid.IGridOptionsOf.prototype.rowTemplate;
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.scrollDebounce;
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.scrollThreshold;
 /** @type {boolean} */
uiGrid.IGridOptionsOf.prototype.showColumnFooter;
 /** @type {boolean} */
uiGrid.IGridOptionsOf.prototype.showGridFooter;
 /** @type {boolean} */
uiGrid.IGridOptionsOf.prototype.showHeader;
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.virtualizationThreshold;
 /** @type {boolean} */
uiGrid.IGridOptionsOf.prototype.useExternalFiltering;
 /** @type {boolean} */
uiGrid.IGridOptionsOf.prototype.useExternalSorting;
 /** @type {number} */
uiGrid.IGridOptionsOf.prototype.wheelScrollThrottle;

/**
 * This function returns the identity value uniquely identifying this row,
 * if one is not present it does not set it.
 * 
 * By default it returns the `$$hashKey` property but can be overridden to use any property
 * or set of properties you want.
 * @param {!uiGrid.IGridRowOf<TEntity>} row
 * @return {?}
 */
uiGrid.IGridOptionsOf.prototype.getRowIdentity = function(row) {};

/**
 * By default, rows are compared using object equality.  This option can be overridden
 * to compare on any data item property or function
 * @param {TEntity} entityA
 * @param {TEntity} entityB
 * @return {boolean}
 */
uiGrid.IGridOptionsOf.prototype.rowEquality = function(entityA, entityB) {};

/**
 * This function is used to get and, if necessary, set the value uniquely identifying this row
 * (i.e. if an identity is not present it will set one).
 * 
 * By default it returns the `$$hashKey` property if it exists. If it doesn't it uses gridUtil.nextUid()
 * to generate one
 * @param {!uiGrid.IGridRowOf<TEntity>} row
 * @return {?}
 */
uiGrid.IGridOptionsOf.prototype.rowIdentity = function(row) {};
/**
 * @record
 * @struct
 */
uiGrid.IGridCoreApi = function() {};
 /** @type {{canvasHeightChanged: function(!angular.IScope, !uiGrid.canvasHeightChangedHandler): void, columnVisibilityChanged: function(!angular.IScope, !uiGrid.columnVisibilityChangedHandler<TEntity>): void, filterChanged: function(!angular.IScope, !uiGrid.filterChangedHandler<TEntity>): void, rowsRendered: function(!angular.IScope, !uiGrid.rowsRenderedHandler<TEntity>): void, rowsVisibleChanged: function(!angular.IScope, !uiGrid.rowsVisibleChangedHandler<TEntity>): void, scrollBegin: function(!angular.IScope, !uiGrid.scrollBeginHandler): void, scrollEnd: function(!angular.IScope, !uiGrid.scrollEndHandler): void, sortChanged: function(!angular.IScope, !uiGrid.sortChangedHandler<TEntity>): void}} */
uiGrid.IGridCoreApi.prototype.on;

/**
 * adds a row header column to the grid
 * @param {!uiGrid.IColumnDefOf<TEntity>} column
 * @return {void}
 */
uiGrid.IGridCoreApi.prototype.addRowHeaderColumn = function(column) {};

/**
 * add items to the grid menu.  Used by features
 * to add their menu items if they are enabled, can also be used by
 * end users to add menu items.  This method has the advantage of allowing
 * remove again, which can simplify management of which items are included
 * in the menu when.  (Noting that in most cases the shown and active functions
 * provide a better way to handle visibility of menu items)
 * the added note that if you want to use remove you must also specify an `id` field,
 * which is provided when you want to remove an item.  The id should be unique.
 * @param {!uiGrid.IGridInstanceOf<TEntity>} grid
 * @param {!Array<!uiGrid.IMenuItem>} items
 * @return {void}
 */
uiGrid.IGridCoreApi.prototype.addToGridMenu = function(grid, items) {};

/**
 * Clears all filters and optionally refreshes the visible rows.
 * @param {boolean=} refreshRows
 * @param {boolean=} clearConditions
 * @param {boolean=} clearFlags
 * @return {!angular.IPromise<!Array<!uiGrid.IGridRowOf<TEntity>>>}
 */
uiGrid.IGridCoreApi.prototype.clearAllFilters = function(refreshRows, clearConditions, clearFlags) {};

/**
 * Clears any override on visibility for the row so that it returns to
 * using normal filtering and other visibility calculations.
 * If the row is currently invisible then sets it to visible and calls
 * both grid refresh and emits the rowsVisibleChanged event
 * TODO: if a filter is active then we can't just set it to visible?
 * @param {TEntity} rowEntity
 * @return {void}
 */
uiGrid.IGridCoreApi.prototype.clearRowInvisible = function(rowEntity) {};

/**
 * Returns all visible rows
 * @param {!uiGrid.IGridInstanceOf<TEntity>} grid
 * @return {!Array<!uiGrid.IGridRowOf<TEntity>>}
 */
uiGrid.IGridCoreApi.prototype.getVisibleRows = function(grid) {};

/**
 * Trigger a grid resize, normally this would be picked
 * up by a watch on window size, but in some circumstances it is necessary
 * to call this manually
 * @return {void}
 */
uiGrid.IGridCoreApi.prototype.handleWindowResize = function() {};

/**
 * Notify the grid that a data or config change has occurred,
 * where that change isn't something the grid was otherwise noticing.  This
 * might be particularly relevant where you've changed values within the data
 * and you'd like cell classes to be re-evaluated, or changed config within
 * the columnDef and you'd like headerCellClasses to be re-evaluated.
 *        uiGridConstants.dataChange values (ALL, ROW, EDIT, COLUMN), which tells
 *        us which refreshes to fire.
 * @param {string} type
 * @return {void}
 */
uiGrid.IGridCoreApi.prototype.notifyDataChange = function(type) {};

/**
 * Refresh the rendered grid on screen.
 * 
 * @param {boolean=} rowsAltered
 * @return {!angular.IPromise<?>}
 */
uiGrid.IGridCoreApi.prototype.refresh = function(rowsAltered) {};

/**
 * Refresh the rendered rows on screen?  Note: not functional at present
 * @return {!angular.IPromise<boolean>}
 */
uiGrid.IGridCoreApi.prototype.refreshRows = function() {};

/**
 * Register a "columns processor" function. When the columns are updated,
 * the grid calls each registered "columns processor", which has a chance
 * to alter the set of columns as long as the count is not
 * modified.
 * 
 *        is run in the context of the grid (i.e. this for the function will be the grid), and must
 *        return the updated columns list, which is passed to the next processor in the chain
 *        for other people to inject columns processors at intermediate priorities.  Lower priority
 *        columnsProcessors run earlier.
 * 
 * At present allRowsVisible is running at 50, filter is running at 100, sort is at 200, grouping at 400,
 * selectable rows at 500, pagination at 900 (pagination will generally want to be last)
 * @param {!uiGrid.IColumnProcessor<TEntity>} processorFunction
 * @param {number} priority
 * @return {void}
 */
uiGrid.IGridCoreApi.prototype.registerColumnsProcessor = function(processorFunction, priority) {};

/**
 * Register a "rows processor" function. When the rows are updated,
 * the grid calls each registered "rows processor", which has a chance
 * to alter the set of rows (sorting, etc) as long as the count is not
 * modified.
 * 
 *        is run in the context of the grid (i.e. this for the function will be the grid), and must
 *        return the updated rows list, which is passed to the next processor in the chain
 *        for other people to inject rows processors at intermediate priorities.  Lower priority rowsProcessors
 *        run earlier.
 * 
 * At present all rows visible is running at 50, filter is running at 100, sort is at 200, grouping at 400,
 * selectable rows at 500, pagination at 900 (pagination will generally want to be last)
 * @param {!uiGrid.IRowProcessor<TEntity>} rowProcessor
 * @param {number} priority
 * @return {void}
 */
uiGrid.IGridCoreApi.prototype.registerRowsProcessor = function(rowProcessor, priority) {};

/**
 * Scroll the grid such that the specified
 * row and column is in view
 * @param {TEntity} entity
 * @param {!uiGrid.IColumnDefOf<TEntity>} colDef
 * @return {void}
 */
uiGrid.IGridCoreApi.prototype.scrollTo = function(entity, colDef) {};

/**
 * Scrolls the grid to make a certain row and column combo visible,
 * in the case that it is not completely visible on the screen already.
 * @param {!uiGrid.IGridRowOf<TEntity>} gridRow
 * @param {!uiGrid.IGridColumnOf<TEntity>} gridCol
 * @return {void}
 */
uiGrid.IGridCoreApi.prototype.scrollToIfNecessary = function(gridRow, gridCol) {};

/**
 * A null handling method that can be used when building custom sort
 * functions
 * a sort value that should be passed back from the sort function
 * @param {?} a
 * @param {?} b
 * @return {number}
 */
uiGrid.IGridCoreApi.prototype.sortHandleNulls = function(a, b) {};

/**
 * queues a grid refresh, a way of debouncing all the refreshes we might otherwise issue
 * @return {void}
 */
uiGrid.IGridCoreApi.prototype.queueGridRefresh = function() {};

/**
 * queues a grid refreshCanvas, a way of debouncing all the refreshes we might otherwise issue
 * @return {void}
 */
uiGrid.IGridCoreApi.prototype.queueRefresh = function() {};
/**
 * @record
 * @struct
 */
uiGrid.columnVisibilityChangedHandler = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.canvasHeightChangedHandler = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.filterChangedHandler = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.rowsRenderedHandler = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.rowsVisibleChangedHandler = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.scrollBeginHandler = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.scrollEndHandler = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.sortChangedHandler = function() {};

/* TODO: CallSignature: uiGrid */
/** @const */
uiGrid.cellNav = {};
/**
 * @record
 * @struct
 */
uiGrid.cellNav.IColumnDef = function() {};
 /** @type {boolean} */
uiGrid.cellNav.IColumnDef.prototype.allowCellFocus;
/**
 * @record
 * @struct
 */
uiGrid.cellNav.IGridOptions = function() {};
 /** @type {boolean} */
uiGrid.cellNav.IGridOptions.prototype.modifierKeysToMultiSelectCells;
/**
 * @record
 * @struct
 */
uiGrid.cellNav.IGridRow = function() {};
 /** @type {boolean} */
uiGrid.cellNav.IGridRow.prototype.allowCellFocus;
/**
 * @record
 * @struct
 */
uiGrid.cellNav.ICellNavApi = function() {};
 /** @type {{navigate: function(!angular.IScope, !uiGrid.cellNav.navigateHandler<TEntity>): void, viewportKeyDown: function(!angular.IScope, !uiGrid.cellNav.viewportKeyDownHandler<TEntity>): void, viewportKeyPress: function(!angular.IScope, !uiGrid.cellNav.viewportKeyPressHandler<TEntity>): void}} */
uiGrid.cellNav.ICellNavApi.prototype.on;

/**
 * Gets the currently selected rows and columns.  array is empty if no selection has occurred
 * @return {!Array<!uiGrid.cellNav.IRowCol<TEntity>>}
 */
uiGrid.cellNav.ICellNavApi.prototype.getCurrentSelection = function() {};

/**
 * Gets the current focused cell.  value is null if no selection has occurred
 * @return {!uiGrid.cellNav.IRowCol<TEntity>}
 */
uiGrid.cellNav.ICellNavApi.prototype.getFocusedCell = function() {};

/**
 * Gets the index of the passed rowCol.  Returns -1 if the RowCol isn't selected
 * @param {!uiGrid.cellNav.IRowCol<TEntity>} rowCol
 * @return {number} the index in the order in which the RowCol was selected
 */
uiGrid.cellNav.ICellNavApi.prototype.rowColSelectIndex = function(rowCol) {};

/**
 * Brings the specified row and column into view, and sets focus to that cell
 * @param {TEntity} rowEntity
 * @param {!uiGrid.cellNav.IColumnDef} colDef
 * @return {!angular.IPromise<?>}
 */
uiGrid.cellNav.ICellNavApi.prototype.scrollToFocus = function(rowEntity, colDef) {};
/**
 * @record
 * @struct
 */
uiGrid.cellNav.navigateHandler = function() {};

/* TODO: CallSignature: uiGrid.cellNav */
/**
 * @record
 * @struct
 */
uiGrid.cellNav.viewportKeyDownHandler = function() {};

/* TODO: CallSignature: uiGrid.cellNav */
/**
 * @record
 * @struct
 */
uiGrid.cellNav.viewportKeyPressHandler = function() {};

/* TODO: CallSignature: uiGrid.cellNav */
/**
 * @record
 * @struct
 */
uiGrid.cellNav.IRowColConstructor = function() {};

/* TODO: ConstructSignature: uiGrid.cellNav */
/**
 * @record
 * @struct
 */
uiGrid.cellNav.IRowCol = function() {};
 /** @type {!uiGrid.IGridRowOf<TEntity>} */
uiGrid.cellNav.IRowCol.prototype.row;
 /** @type {!uiGrid.IGridColumnOf<TEntity>} */
uiGrid.cellNav.IRowCol.prototype.col;

/**
 * Gets the intersection of where the row and column meet
 * @return {(!Object|!String|!Number)} The value from the grid data that this RowCol points to.  If the column has a cellFilter this
 *          will NOT return the filtered value.
 */
uiGrid.cellNav.IRowCol.prototype.getIntersectionValueRaw = function() {};

/**
 * Gets the intersection of where the row and column meet.
 * @return {(!Object|!String|!Number)} The value from the grid data that this RowCol points to.  If the column has a cellFilter this
 *          will also apply the filter to it and return the value that the filter displays
 */
uiGrid.cellNav.IRowCol.prototype.getIntersectionValueFiltered = function() {};
/**
 * @record
 * @struct
 */
uiGrid.cellNav.IUiGridCellNavConstants = function() {};
 /** @type {string} */
uiGrid.cellNav.IUiGridCellNavConstants.prototype.FEATURE_NAME;
 /** @type {string} */
uiGrid.cellNav.IUiGridCellNavConstants.prototype.CELL_NAV_EVENT;
 /** @type {{LEFT: number, RIGHT: number, UP: number, DOWN: number, PG_UP: number, PG_DOWN: number}} */
uiGrid.cellNav.IUiGridCellNavConstants.prototype.direction;
 /** @type {{KEYDOWN: number, CLICK: number, CLEAR: number}} */
uiGrid.cellNav.IUiGridCellNavConstants.prototype.EVENT_TYPE;
/** @const */
uiGrid.edit = {};
/**
 * @record
 * @struct
 */
uiGrid.edit.IColumnDef = function() {};
 /** @type {?} */
uiGrid.edit.IColumnDef.prototype.cellEditableCondition;
 /** @type {string} */
uiGrid.edit.IColumnDef.prototype.editDropdownFilter;
 /** @type {string} */
uiGrid.edit.IColumnDef.prototype.editDropdownIdLabel;
 /** @type {!Array<!uiGrid.edit.IEditDropdown>} */
uiGrid.edit.IColumnDef.prototype.editDropdownOptionsArray;
 /** @type {string} */
uiGrid.edit.IColumnDef.prototype.editDropdownRowEntityOptionsArrayPath;
 /** @type {string} */
uiGrid.edit.IColumnDef.prototype.editDropdownValueLabel;
 /** @type {function(!uiGrid.IGridRowOf<TEntity>, !uiGrid.IGridColumnOf<TEntity>, !FileList): void} */
uiGrid.edit.IColumnDef.prototype.editFileChooserCallback;
 /** @type {string} */
uiGrid.edit.IColumnDef.prototype.editModelField;
 /** @type {string} */
uiGrid.edit.IColumnDef.prototype.editableCellTemplate;
 /** @type {boolean} */
uiGrid.edit.IColumnDef.prototype.enableCellEdit;
 /** @type {boolean} */
uiGrid.edit.IColumnDef.prototype.enableCellEditOnFocus;
/**
 * @record
 * @struct
 */
uiGrid.edit.IEditDropdown = function() {};
 /** @type {(string|number)} */
uiGrid.edit.IEditDropdown.prototype.id;
 /** @type {?} */
uiGrid.edit.IEditDropdown.prototype.value;
/**
 * @record
 * @struct
 */
uiGrid.edit.IGridOptions = function() {};
 /** @type {?} */
uiGrid.edit.IGridOptions.prototype.cellEditableCondition;
 /** @type {string} */
uiGrid.edit.IGridOptions.prototype.editableCellTemplate;
 /** @type {boolean} */
uiGrid.edit.IGridOptions.prototype.enableCellEdit;
 /** @type {boolean} */
uiGrid.edit.IGridOptions.prototype.enableCellEditOnFocus;
/**
 * @record
 * @struct
 */
uiGrid.edit.IGridRow = function() {};
 /** @type {boolean} */
uiGrid.edit.IGridRow.prototype.enableCellEdit;
/**
 * @record
 * @struct
 */
uiGrid.edit.IGridEditApi = function() {};
 /** @type {{afterCellEdit: function(!angular.IScope, !uiGrid.edit.afterCellEditHandler<TEntity>): void, beginCellEdit: function(!angular.IScope, !uiGrid.edit.beginCellEditHandler<TEntity>): void, cancelCellEdit: function(!angular.IScope, !uiGrid.edit.cancelCellEditHandler<TEntity>): void}} */
uiGrid.edit.IGridEditApi.prototype.on;
/**
 * @record
 * @struct
 */
uiGrid.edit.afterCellEditHandler = function() {};

/* TODO: CallSignature: uiGrid.edit */
/**
 * @record
 * @struct
 */
uiGrid.edit.beginCellEditHandler = function() {};

/* TODO: CallSignature: uiGrid.edit */
/**
 * @record
 * @struct
 */
uiGrid.edit.cancelCellEditHandler = function() {};

/* TODO: CallSignature: uiGrid.edit */
/**
 * @record
 * @struct
 */
uiGrid.edit.IUiGridEditConstants = function() {};
 /** @type {string} */
uiGrid.edit.IUiGridEditConstants.prototype.EDITABLE_CELL_TEMPLATE;
 /** @type {string} */
uiGrid.edit.IUiGridEditConstants.prototype.EDITABLE_CELL_DIRECTIVE;
 /** @type {{BEGIN_CELL_EDIT: string, END_CELL_EDIT: string, CANCEL_CELL_EDIT: string}} */
uiGrid.edit.IUiGridEditConstants.prototype.events;
/** @const */
uiGrid.expandable = {};
/**
 * @record
 * @struct
 */
uiGrid.expandable.IGridOptions = function() {};
 /** @type {number} */
uiGrid.expandable.IGridOptions.prototype.expandableRowHeaderWidth;
 /** @type {boolean} */
uiGrid.expandable.IGridOptions.prototype.enableExpandable;
 /** @type {boolean} */
uiGrid.expandable.IGridOptions.prototype.enableExpandableRowHeader;
 /** @type {number} */
uiGrid.expandable.IGridOptions.prototype.expandableRowHeight;
 /** @type {(!Object|!angular.IScope)} */
uiGrid.expandable.IGridOptions.prototype.expandableRowScope;
 /** @type {string} */
uiGrid.expandable.IGridOptions.prototype.expandableRowTemplate;
/**
 * @record
 * @struct
 */
uiGrid.expandable.IGridExpandableApi = function() {};
 /** @type {{rowExpandedStateChanged: function(!angular.IScope, !uiGrid.expandable.rowExpandedStateChangedHandler<TEntity>): void}} */
uiGrid.expandable.IGridExpandableApi.prototype.on;

/**
 * Collapse all subgrids.
 * @return {void}
 */
uiGrid.expandable.IGridExpandableApi.prototype.collapseAllRows = function() {};

/**
 * expand all subgrids
 * @return {void}
 */
uiGrid.expandable.IGridExpandableApi.prototype.expandAllRows = function() {};

/**
 * Toggle all subgrids
 * @return {void}
 */
uiGrid.expandable.IGridExpandableApi.prototype.toggleAllRows = function() {};

/**
 * Toggle a specific row
 * @param {TEntity} rowEntity
 * @return {void}
 */
uiGrid.expandable.IGridExpandableApi.prototype.toggleRowExpansion = function(rowEntity) {};
/**
 * @record
 * @struct
 */
uiGrid.expandable.rowExpandedStateChangedHandler = function() {};

/* TODO: CallSignature: uiGrid.expandable */
/**
 * @record
 * @struct
 */
uiGrid.expandable.IGridRow = function() {};
 /** @type {boolean} */
uiGrid.expandable.IGridRow.prototype.isExpanded;
/** @const */
uiGrid.exporter = {};
/**
 * @record
 * @struct
 */
uiGrid.exporter.IColumnDef = function() {};
 /** @type {string} */
uiGrid.exporter.IColumnDef.prototype.exporterPdfAlign;
 /** @type {boolean} */
uiGrid.exporter.IColumnDef.prototype.exporterSuppressExport;
/**
 * @record
 * @struct
 */
uiGrid.exporter.IGridOptions = function() {};
 /** @type {function(): !angular.IPromise<!Array<TEntity>>} */
uiGrid.exporter.IGridOptions.prototype.exporterAllDataFn;
 /** @type {function(): !angular.IPromise<!Array<TEntity>>} */
uiGrid.exporter.IGridOptions.prototype.exporterAllDataPromise;
 /** @type {string} */
uiGrid.exporter.IGridOptions.prototype.exporterCsvColumnSeparator;
 /** @type {string} */
uiGrid.exporter.IGridOptions.prototype.exporterCsvFilename;
 /** @type {function(!uiGrid.IGridInstanceOf<TEntity>, !uiGrid.IGridRowOf<TEntity>, !uiGrid.IGridColumnOf<TEntity>, ?): ?} */
uiGrid.exporter.IGridOptions.prototype.exporterFieldCallback;
 /** @type {function(string): string} */
uiGrid.exporter.IGridOptions.prototype.exporterHeaderFilter;
 /** @type {boolean} */
uiGrid.exporter.IGridOptions.prototype.exporterHeaderFilterUseName;
 /** @type {boolean} */
uiGrid.exporter.IGridOptions.prototype.exporterMenuCsv;
 /** @type {string} */
uiGrid.exporter.IGridOptions.prototype.exporterMenuLabel;
 /** @type {boolean} */
uiGrid.exporter.IGridOptions.prototype.exporterMenuPdf;
 /** @type {boolean} */
uiGrid.exporter.IGridOptions.prototype.exporterOlderExcelCompatibility;
 /** @type {function(?): ?} */
uiGrid.exporter.IGridOptions.prototype.exporterPdfCustomFormatter;
 /** @type {?} */
uiGrid.exporter.IGridOptions.prototype.exporterPdfDefaultStyle;
 /** @type {string} */
uiGrid.exporter.IGridOptions.prototype.exporterPdfFilename;
 /** @type {?} */
uiGrid.exporter.IGridOptions.prototype.exporterPdfFooter;
 /** @type {?} */
uiGrid.exporter.IGridOptions.prototype.exporterPdfHeader;
 /** @type {number} */
uiGrid.exporter.IGridOptions.prototype.exporterPdfMaxGridWidth;
 /** @type {string} */
uiGrid.exporter.IGridOptions.prototype.exporterPdfOrientation;
 /** @type {string} */
uiGrid.exporter.IGridOptions.prototype.exporterPdfPageSize;
 /** @type {?} */
uiGrid.exporter.IGridOptions.prototype.exporterPdfTableHeaderStyle;
 /** @type {?} */
uiGrid.exporter.IGridOptions.prototype.exporterPdfTableLayout;
 /** @type {?} */
uiGrid.exporter.IGridOptions.prototype.exporterPdfTableStyle;
 /** @type {!Array<string>} */
uiGrid.exporter.IGridOptions.prototype.exporterSuppressColumns;
 /** @type {boolean} */
uiGrid.exporter.IGridOptions.prototype.exporterSuppressMenu;
/**
 * @record
 * @struct
 */
uiGrid.exporter.IGridRow = function() {};
 /** @type {boolean} */
uiGrid.exporter.IGridRow.prototype.exporterEnableExporting;
/**
 * @record
 * @struct
 */
uiGrid.exporter.IGridExporterApi = function() {};

/**
 * Exports rows from the grid in csv format, the data exported is selected based on the provided options
 * uiGridExporterConstants.VISIBLE, uiGridExporterConstants.SELECTED
 * uiGridExporterConstants.VISIBLE
 * @param {string} rowTypes
 * @param {string} colTypes
 * @return {void}
 */
uiGrid.exporter.IGridExporterApi.prototype.csvExport = function(rowTypes, colTypes) {};

/**
 * Exports rows from the grid in pdf format, the data exported is selected based on the provided options
 * Note that this function has a dependency on pdfMake, all going well this has been installed for you. The
 * resulting pdf opens in a new browser window.
 * uiGridExporterConstants.VISIBLE, uiGridExporterConstants.SELECTED
 * uiGridExporterConstants.VISIBLE
 * @param {string} rowTypes
 * @param {string} colTypes
 * @return {void}
 */
uiGrid.exporter.IGridExporterApi.prototype.pdfExport = function(rowTypes, colTypes) {};
/**
 * @record
 * @struct
 */
uiGrid.exporter.IUiGridExporterConstants = function() {};
 /** @type {string} */
uiGrid.exporter.IUiGridExporterConstants.prototype.featureName;
 /** @type {string} */
uiGrid.exporter.IUiGridExporterConstants.prototype.ALL;
 /** @type {string} */
uiGrid.exporter.IUiGridExporterConstants.prototype.VISIBLE;
 /** @type {string} */
uiGrid.exporter.IUiGridExporterConstants.prototype.SELECTED;
 /** @type {string} */
uiGrid.exporter.IUiGridExporterConstants.prototype.CSV_CONTENT;
 /** @type {string} */
uiGrid.exporter.IUiGridExporterConstants.prototype.BUTTON_LABEL;
 /** @type {string} */
uiGrid.exporter.IUiGridExporterConstants.prototype.FILE_NAME;
/** @const */
uiGrid.grouping = {};
/**
 * @record
 * @struct
 */
uiGrid.grouping.IColumnDef = function() {};
 /** @type {boolean} */
uiGrid.grouping.IColumnDef.prototype.enableGrouping;
 /** @type {{groupPriority: number}} */
uiGrid.grouping.IColumnDef.prototype.grouping;
 /** @type {boolean} */
uiGrid.grouping.IColumnDef.prototype.groupingShowAggregationMenu;
 /** @type {boolean} */
uiGrid.grouping.IColumnDef.prototype.groupingShowGroupingMenu;
/**
 * @record
 * @struct
 */
uiGrid.grouping.IGridOptions = function() {};
 /** @type {boolean} */
uiGrid.grouping.IGridOptions.prototype.enableGrouping;
 /** @type {boolean} */
uiGrid.grouping.IGridOptions.prototype.enableGroupHeaderSelection;
 /** @type {string} */
uiGrid.grouping.IGridOptions.prototype.groupingNullLabel;
 /** @type {boolean} */
uiGrid.grouping.IGridOptions.prototype.groupingShowCounts;
/**
 * @record
 * @struct
 */
uiGrid.grouping.IGridGroupingApi = function() {};
 /** @type {{aggregationChanged: function(!angular.IScope, !uiGrid.grouping.aggregationChangedHandler<TEntity>): void, groupingChanged: function(!angular.IScope, !uiGrid.grouping.groupingChangedHandler<TEntity>): void}} */
uiGrid.grouping.IGridGroupingApi.prototype.on;

/**
 * Sets the aggregation type on a column.
 * If the column is currently grouped then it removes the grouping first.
 * If the aggregationDef is null then will result in the aggregation being removed.
 * a custom aggregation function.
 * @param {string} columnName
 * @param {(string|!Function)} or
 * @param {string=} aggregationLabel
 * @return {void}
 */
uiGrid.grouping.IGridGroupingApi.prototype.aggregateColumn = function(columnName, or, aggregationLabel) {};

/**
 * Clear any grouped columns and any aggregations.
 * Doesn't remove sorting, as we don't know whether that sorting was added by grouping or was there
 * beforehand
 * @return {void}
 */
uiGrid.grouping.IGridGroupingApi.prototype.clearGrouping = function() {};

/**
 * Get the grouping configuration for this grid, used by the saveState feature.
 * Adds expandedState to the information provided by the internal getGrouping,
 * and removes any aggregations that have a source of grouping
 * (i.e. will be automatically reapplied when we regroup the column)
 * @param {boolean} getExpanded
 * @return {!uiGrid.grouping.IGridGroupingConfiguration}
 */
uiGrid.grouping.IGridGroupingApi.prototype.getGrouping = function(getExpanded) {};

/**
 * Adds this column to the existing grouping, at the end of the priority order.
 * If the column doesn't have a sort, adds one, by default ASC.
 * This column will move to the left of any non-group columns.
 * The move is handled in a columnProcessor, so it gets called as part of refresh.
 * @param {string} columnName
 * @return {void}
 */
uiGrid.grouping.IGridGroupingApi.prototype.groupColumn = function(columnName) {};

/**
 * Set the grouping configuration for this grid, used by the saveState feature,
 * but can also be used by any user to specify a combined grouping and aggregation configuration
 * @param {!uiGrid.grouping.IGridGroupingConfiguration} config
 * @return {void}
 */
uiGrid.grouping.IGridGroupingApi.prototype.setGrouping = function(config) {};

/**
 * Removes the groupPriority from this column.
 * If the column was previously aggregated the aggregation will come back. The sort will remain.
 * 
 * This column will move to the right of any other group columns, the move is handled in a columnProcessor,
 * so it gets called as part of refresh
 * @param {string} columnName
 * @return {void}
 */
uiGrid.grouping.IGridGroupingApi.prototype.ungroupColumn = function(columnName) {};
/**
 * @record
 * @struct
 */
uiGrid.grouping.IGridGroupingConfiguration = function() {};
 /** @type {!Array<!uiGrid.grouping.IGripGroup>} */
uiGrid.grouping.IGridGroupingConfiguration.prototype.grouping;
 /** @type {!Array<!uiGrid.grouping.IGridTreeAggregations>} */
uiGrid.grouping.IGridGroupingConfiguration.prototype.treeAggregations;
 /** @type {!uiGrid.grouping.IGridExpandedHash} */
uiGrid.grouping.IGridGroupingConfiguration.prototype.expandedState;
/**
 * @record
 * @struct
 */
uiGrid.grouping.IGripGroup = function() {};
 /** @type {string} */
uiGrid.grouping.IGripGroup.prototype.field;
 /** @type {string} */
uiGrid.grouping.IGripGroup.prototype.colName;
 /** @type {number} */
uiGrid.grouping.IGripGroup.prototype.groupPriority;
/**
 * @record
 * @struct
 */
uiGrid.grouping.IGridTreeAggregations = function() {};
 /** @type {string} */
uiGrid.grouping.IGridTreeAggregations.prototype.field;
 /** @type {string} */
uiGrid.grouping.IGridTreeAggregations.prototype.colName;
 /** @type {string} */
uiGrid.grouping.IGridTreeAggregations.prototype.aggregation;
/**
 * @record
 * @struct
 */
uiGrid.grouping.IGridExpandedHash = function() {};

/* TODO: IndexSignature: uiGrid.grouping */
/**
 * @record
 * @struct
 */
uiGrid.grouping.aggregationChangedHandler = function() {};

/* TODO: CallSignature: uiGrid.grouping */
/**
 * @record
 * @struct
 */
uiGrid.grouping.groupingChangedHandler = function() {};

/* TODO: CallSignature: uiGrid.grouping */
/**
 * @extends {uiGrid.ISharedTreeConstants}
 * @record
 * @struct
 */
uiGrid.grouping.IUiGridGroupingConstants = function() {};
 /** @type {string} */
uiGrid.grouping.IUiGridGroupingConstants.prototype.featureName;
/** @const */
uiGrid.importer = {};
/**
 * @record
 * @struct
 */
uiGrid.importer.IGridOptions = function() {};
 /** @type {function(!uiGrid.IGridInstanceOf<TEntity>, !Array<TEntity>): void} */
uiGrid.importer.IGridOptions.prototype.importerDataAddCallback;
 /** @type {function(!uiGrid.IGridInstanceOf<TEntity>, string, string, ?): void} */
uiGrid.importer.IGridOptions.prototype.importerErrorCallback;
 /** @type {function(string): string} */
uiGrid.importer.IGridOptions.prototype.importerHeaderFilter;
 /** @type {function(!uiGrid.IGridInstanceOf<TEntity>, TEntity): TEntity} */
uiGrid.importer.IGridOptions.prototype.importerObjectCallback;
 /** @type {function(!uiGrid.IGridInstanceOf<TEntity>, !Array<string>): !Array<string>} */
uiGrid.importer.IGridOptions.prototype.importerProcessHeaders;
 /** @type {boolean} */
uiGrid.importer.IGridOptions.prototype.enableImporter;
 /** @type {!Function} */
uiGrid.importer.IGridOptions.prototype.importerNewObject;
 /** @type {boolean} */
uiGrid.importer.IGridOptions.prototype.importerShowMenu;
/**
 * @record
 * @struct
 */
uiGrid.importer.IGridImporterApi = function() {};

/**
 * Imports a file into the grid using the file object provided. Bypasses the grid menu
 * @param {!File} fileObject
 * @return {void}
 */
uiGrid.importer.IGridImporterApi.prototype.importFile = function(fileObject) {};
/**
 * @record
 * @struct
 */
uiGrid.importer.IUiGridImporterConstants = function() {};
 /** @type {string} */
uiGrid.importer.IUiGridImporterConstants.prototype.featureName;
/** @const */
uiGrid.infiniteScroll = {};
/**
 * @record
 * @struct
 */
uiGrid.infiniteScroll.IGridOptions = function() {};
 /** @type {boolean} */
uiGrid.infiniteScroll.IGridOptions.prototype.enableInfiniteScroll;
/**
 * @record
 * @struct
 */
uiGrid.infiniteScroll.IGridInfiniteScrollApi = function() {};
 /** @type {{needLoadMoreData: !Function, needLoadMoreDataTop: !Function}} */
uiGrid.infiniteScroll.IGridInfiniteScrollApi.prototype.on;

/**
 * Call this function when you have loaded the additional data requested.
 * You should set scrollUp and scrollDown to indicate whether there are still more pages in each direction.
 * 
 * If you call dataLoaded without first calling saveScrollPercentage, then we will scroll the user to the
 * start of the newly loaded data.  This usually makes scrolling smooth, but be jumpy with large
 * infiniteScrollRowsFromEnd values, and on variable speed internet connections.
 * Using saveScrollPercentage as demonstrated in the tutorial should give a smoother scrolling experience
 * for users.
 * 
 * See infinite_scroll tutorial for example of usage
 *        more infinite scroll events upward
 *        any more infinite scroll events downward
 *          If you're planning to remove pages, you should wait on this promise first, or you'll break the
 *          scroll positioning
 * @param {boolean} scrollUp
 * @param {boolean} scrollDown
 * @return {!angular.IPromise<?>}
 */
uiGrid.infiniteScroll.IGridInfiniteScrollApi.prototype.dataLoaded = function(scrollUp, scrollDown) {};

/**
 * Adjusts the scroll position after you've removed data at the bottom
 * Adjusts the scroll position after you've removed data at the bottom.
 * You should have called saveScrollPercentage before you remove the data,
 * and if you're doing this in response to a needMoreData you should wait
 * until the promise from loadData has resolved before you start removing data
 * 
 * @param {boolean|!uiGrid.IGridInstanceOf<TEntity>} scrollUp_or_grid
 * @param {boolean} scrollDown_or_scrollUp
 * @param {boolean=} scrollDown
 * @return {!angular.IPromise<?>}
 */
uiGrid.infiniteScroll.IGridInfiniteScrollApi.prototype.dataRemovedBottom = function(scrollUp_or_grid, scrollDown_or_scrollUp, scrollDown) {};

/**
 * Adjusts the scroll position after you've removed data at the bottom
 * Adjusts the scroll position after you've removed data at the bottom.
 * You should have called saveScrollPercentage before you remove the data,
 * and if you're doing this in response to a needMoreData you should wait
 * until the promise from loadData has resolved before you start removing data
 * 
 * @param {boolean|!uiGrid.IGridInstanceOf<TEntity>} scrollUp_or_grid
 * @param {boolean} scrollDown_or_scrollUp
 * @param {boolean=} scrollDown
 * @return {!angular.IPromise<?>}
 */
uiGrid.infiniteScroll.IGridInfiniteScrollApi.prototype.dataRemovedTop = function(scrollUp_or_grid, scrollDown_or_scrollUp, scrollDown) {};

/**
 * Call this function when you have taken some action that makes the current scroll position invalid.
 * For example, if you're using external sorting and you've resorted then you might reset the scroll,
 * or if you've otherwise substantially changed the data, perhaps you've reused an
 * existing grid for a new data set
 * 
 * You must tell us whether there is data upwards or downwards after the reset
 * @param {boolean} scrollUp
 * @param {boolean} scrollDown
 * @return {!angular.IPromise<?>}
 */
uiGrid.infiniteScroll.IGridInfiniteScrollApi.prototype.resetScroll = function(scrollUp, scrollDown) {};

/**
 * Saves the scroll percentage and number of visible rows before you adjust the data,
 * used if you're subsequently going to call dataRemovedTop or dataRemovedBottom
 * @return {void}
 */
uiGrid.infiniteScroll.IGridInfiniteScrollApi.prototype.saveScrollPercentage = function() {};
/** @const */
uiGrid.moveColumns = {};
/**
 * @record
 * @struct
 */
uiGrid.moveColumns.IColumnDef = function() {};
 /** @type {boolean} */
uiGrid.moveColumns.IColumnDef.prototype.enableColumnMoving;
/**
 * @record
 * @struct
 */
uiGrid.moveColumns.IGridOptions = function() {};
 /** @type {boolean} */
uiGrid.moveColumns.IGridOptions.prototype.enableColumnMoving;
/**
 * @record
 * @struct
 */
uiGrid.moveColumns.IGridMoveColumnsApi = function() {};
 /** @type {{columnPositionChanged: function(!angular.IScope, !uiGrid.moveColumns.columnPositionChangedHandler): void}} */
uiGrid.moveColumns.IGridMoveColumnsApi.prototype.on;

/**
 * Method can be used to change column position
 * @param {number} originalPosition
 * @param {number} newPosition
 * @return {void}
 */
uiGrid.moveColumns.IGridMoveColumnsApi.prototype.moveColumn = function(originalPosition, newPosition) {};
/**
 * @record
 * @struct
 */
uiGrid.moveColumns.columnPositionChangedHandler = function() {};

/* TODO: CallSignature: uiGrid.moveColumns */
/** @const */
uiGrid.pagination = {};
/**
 * @record
 * @struct
 */
uiGrid.pagination.IGridOptions = function() {};
 /** @type {boolean} */
uiGrid.pagination.IGridOptions.prototype.enablePagination;
 /** @type {boolean} */
uiGrid.pagination.IGridOptions.prototype.enablePaginationControls;
 /** @type {number} */
uiGrid.pagination.IGridOptions.prototype.paginationCurrentPage;
 /** @type {number} */
uiGrid.pagination.IGridOptions.prototype.paginationPageSize;
 /** @type {!Array<number>} */
uiGrid.pagination.IGridOptions.prototype.paginationPageSizes;
 /** @type {string} */
uiGrid.pagination.IGridOptions.prototype.paginationTemplate;
 /** @type {number} */
uiGrid.pagination.IGridOptions.prototype.totalItems;
 /** @type {boolean} */
uiGrid.pagination.IGridOptions.prototype.useExternalPagination;
/**
 * @record
 * @struct
 */
uiGrid.pagination.IGridPaginationApi = function() {};
 /** @type {{paginationChanged: function(!angular.IScope, !uiGrid.pagination.paginationChangedHandler): void}} */
uiGrid.pagination.IGridPaginationApi.prototype.on;

/**
 * Get the current page
 * @return {number}
 */
uiGrid.pagination.IGridPaginationApi.prototype.getPage = function() {};

/**
 * Get the total number of pages
 * @return {number}
 */
uiGrid.pagination.IGridPaginationApi.prototype.getTotalPages = function() {};

/**
 * Moves to the next page if possible
 * @return {void}
 */
uiGrid.pagination.IGridPaginationApi.prototype.nextPage = function() {};

/**
 * Moves to the previous page if we're not on the first page.
 * @return {void}
 */
uiGrid.pagination.IGridPaginationApi.prototype.previousPage = function() {};

/**
 * Moves to the requested page
 * @param {number} page
 * @return {void}
 */
uiGrid.pagination.IGridPaginationApi.prototype.seek = function(page) {};
/**
 * @record
 * @struct
 */
uiGrid.pagination.paginationChangedHandler = function() {};

/* TODO: CallSignature: uiGrid.pagination */
/** @const */
uiGrid.pinning = {};
/**
 * @record
 * @struct
 */
uiGrid.pinning.IColumnDef = function() {};
 /** @type {boolean} */
uiGrid.pinning.IColumnDef.prototype.enablePinning;
 /** @type {boolean} */
uiGrid.pinning.IColumnDef.prototype.pinnedLeft;
 /** @type {boolean} */
uiGrid.pinning.IColumnDef.prototype.pinnedRight;
/**
 * @record
 * @struct
 */
uiGrid.pinning.IGridOptions = function() {};
 /** @type {boolean} */
uiGrid.pinning.IGridOptions.prototype.enablePinning;
/**
 * @record
 * @struct
 */
uiGrid.pinning.IGridPinningApi = function() {};
 /** @type {function(!angular.IScope, !uiGrid.pinning.columnPinHandler): void} */
uiGrid.pinning.IGridPinningApi.prototype.columnPin;

/**
 * Pin column left, right, or none
 * @param {!uiGrid.IGridColumnOf<TEntity>} col
 * @param {string} container
 * @return {void}
 */
uiGrid.pinning.IGridPinningApi.prototype.pinColumn = function(col, container) {};
/**
 * @record
 * @struct
 */
uiGrid.pinning.columnPinHandler = function() {};

/* TODO: CallSignature: uiGrid.pinning */
/**
 * @record
 * @struct
 */
uiGrid.pinning.IUiGridPinningConstants = function() {};
 /** @type {{LEFT: string, RIGHT: string, NONE: string}} */
uiGrid.pinning.IUiGridPinningConstants.prototype.container;
/** @const */
uiGrid.resizeColumns = {};
/**
 * @record
 * @struct
 */
uiGrid.resizeColumns.IColumnDef = function() {};
 /** @type {boolean} */
uiGrid.resizeColumns.IColumnDef.prototype.enableColumnResizing;
/**
 * @record
 * @struct
 */
uiGrid.resizeColumns.IGridOptions = function() {};
 /** @type {boolean} */
uiGrid.resizeColumns.IGridOptions.prototype.enableColumnResizing;
/**
 * @record
 * @struct
 */
uiGrid.resizeColumns.IGridResizeColumnsApi = function() {};
 /** @type {{columnSizeChanged: function(!angular.IScope, !uiGrid.resizeColumns.columnSizeChangedHandler): void}} */
uiGrid.resizeColumns.IGridResizeColumnsApi.prototype.on;
/**
 * @record
 * @struct
 */
uiGrid.resizeColumns.columnSizeChangedHandler = function() {};

/* TODO: CallSignature: uiGrid.resizeColumns */
/** @const */
uiGrid.rowEdit = {};
/**
 * @record
 * @struct
 */
uiGrid.rowEdit.IGridOptions = function() {};
 /** @type {number} */
uiGrid.rowEdit.IGridOptions.prototype.rowEditWaitInterval;
/**
 * @record
 * @struct
 */
uiGrid.rowEdit.IGridRowEditApi = function() {};
 /** @type {{saveRow: function(!angular.IScope, !uiGrid.rowEdit.saveRowHandler<TEntity>): void}} */
uiGrid.rowEdit.IGridRowEditApi.prototype.on;

/**
 * Triggers a save event for all currently dirty rows.
 * Could be used where user presses a save button or navigates away from the page
 *          promises.  i.e. it will be resolved when all the individual save promises have been resolved.
 * @param {!uiGrid.IGridInstanceOf<TEntity>=} grid
 * @return {!angular.IPromise<!Array<?>>}
 */
uiGrid.rowEdit.IGridRowEditApi.prototype.flushDirtyRows = function(grid) {};

/**
 * Returns all currently dirty rows
 * @param {!uiGrid.IGridInstanceOf<TEntity>=} grid
 * @return {!Array<!uiGrid.IGridRowOf<TEntity>>}
 */
uiGrid.rowEdit.IGridRowEditApi.prototype.getDirtyRows = function(grid) {};

/**
 * Returns all currently errored rows
 * @param {!uiGrid.IGridInstanceOf<TEntity>=} grid
 * @return {!Array<!uiGrid.IGridRowOf<TEntity>>}
 */
uiGrid.rowEdit.IGridRowEditApi.prototype.getErrorRows = function(grid) {};

/**
 * Sets each of the rows passed in dataRows to be clean,
 * removing them from the dirty cache and the error cache,
 * and clearing the error flag and the dirty flag
 * @param {!Array<TEntity>} dataRows
 * @return {void}
 */
uiGrid.rowEdit.IGridRowEditApi.prototype.setRowsClean = function(dataRows) {};

/**
 * Sets each of the rows passed in dataRows to be dirty,
 * Note that if you have only just inserted the rows into your data,
 * you will need to wait for a $digest cycle before the gridRows are present.  As a result, this is often
 * wrapped with $interval or $timeout.
 * @param {!Array<TEntity>} dataRows
 * @return {void}
 */
uiGrid.rowEdit.IGridRowEditApi.prototype.setRowsDirty = function(dataRows) {};

/**
 * Sets the promise associated with the row save, mandatory that the saveRow event handler calls this method
 * somewhere before returning
 *        rejected if the save fails
 * @param {!Object} rowEntity
 * @param {!angular.IPromise<?>} savePromise
 * @return {void}
 */
uiGrid.rowEdit.IGridRowEditApi.prototype.setSavePromise = function(rowEntity, savePromise) {};
/**
 * @record
 * @struct
 */
uiGrid.rowEdit.saveRowHandler = function() {};

/* TODO: CallSignature: uiGrid.rowEdit */
/** @const */
uiGrid.saveState = {};
/**
 * @record
 * @struct
 */
uiGrid.saveState.IGridOptions = function() {};
 /** @type {boolean} */
uiGrid.saveState.IGridOptions.prototype.saveFilter;
 /** @type {boolean} */
uiGrid.saveState.IGridOptions.prototype.saveFocus;
 /** @type {boolean} */
uiGrid.saveState.IGridOptions.prototype.saveGrouping;
 /** @type {boolean} */
uiGrid.saveState.IGridOptions.prototype.saveGroupingExpandedStates;
 /** @type {boolean} */
uiGrid.saveState.IGridOptions.prototype.saveOrder;
 /** @type {boolean} */
uiGrid.saveState.IGridOptions.prototype.savePinning;
 /** @type {boolean} */
uiGrid.saveState.IGridOptions.prototype.saveRowIdentity;
 /** @type {boolean} */
uiGrid.saveState.IGridOptions.prototype.saveScroll;
 /** @type {boolean} */
uiGrid.saveState.IGridOptions.prototype.saveSelection;
 /** @type {boolean} */
uiGrid.saveState.IGridOptions.prototype.saveSort;
 /** @type {boolean} */
uiGrid.saveState.IGridOptions.prototype.saveTreeView;
 /** @type {boolean} */
uiGrid.saveState.IGridOptions.prototype.saveVisible;
 /** @type {boolean} */
uiGrid.saveState.IGridOptions.prototype.saveWidths;
/**
 * @record
 * @struct
 */
uiGrid.saveState.IGridSaveStateApi = function() {};

/**
 * Restores the provided state into the grid
 * @param {!angular.IScope} $scope
 * @param {!uiGrid.saveState.IGridSavedState} state
 * @return {void}
 */
uiGrid.saveState.IGridSaveStateApi.prototype.restore = function($scope, state) {};

/**
 * Packages the current state of the grid into an object, and provides it to the user for saving
 * @return {!uiGrid.saveState.IGridSavedState}
 */
uiGrid.saveState.IGridSaveStateApi.prototype.save = function() {};
/**
 * @record
 * @struct
 */
uiGrid.saveState.IGridSavedState = function() {};
 /** @type {!Array<!uiGrid.saveState.ISavedColumn>} */
uiGrid.saveState.IGridSavedState.prototype.columns;
 /** @type {!uiGrid.saveState.ISavedScrollFocus} */
uiGrid.saveState.IGridSavedState.prototype.scrollFocus;
 /** @type {!Array<!uiGrid.saveState.IRowVal>} */
uiGrid.saveState.IGridSavedState.prototype.selection;
 /** @type {!uiGrid.grouping.IGridGroupingConfiguration} */
uiGrid.saveState.IGridSavedState.prototype.grouping;
 /** @type {!uiGrid.treeBase.ITreeState} */
uiGrid.saveState.IGridSavedState.prototype.treeView;
/**
 * @record
 * @struct
 */
uiGrid.saveState.ISavedColumn = function() {};
 /** @type {string} */
uiGrid.saveState.ISavedColumn.prototype.name;
 /** @type {boolean} */
uiGrid.saveState.ISavedColumn.prototype.visible;
 /** @type {number} */
uiGrid.saveState.ISavedColumn.prototype.width;
 /** @type {!uiGrid.ISortInfo} */
uiGrid.saveState.ISavedColumn.prototype.sort;
 /** @type {!Array<!uiGrid.IFilterOptions>} */
uiGrid.saveState.ISavedColumn.prototype.filters;
 /** @type {string} */
uiGrid.saveState.ISavedColumn.prototype.pinned;
/**
 * @record
 * @struct
 */
uiGrid.saveState.ISavedScrollFocus = function() {};
 /** @type {boolean} */
uiGrid.saveState.ISavedScrollFocus.prototype.focus;
 /** @type {string} */
uiGrid.saveState.ISavedScrollFocus.prototype.colName;
 /** @type {!uiGrid.saveState.IRowVal} */
uiGrid.saveState.ISavedScrollFocus.prototype.rowVal;
/**
 * @record
 * @struct
 */
uiGrid.saveState.IRowVal = function() {};
 /** @type {boolean} */
uiGrid.saveState.IRowVal.prototype.identity;
 /** @type {?} */
uiGrid.saveState.IRowVal.prototype.row;
/** @const */
uiGrid.selection = {};
/**
 * @record
 * @struct
 */
uiGrid.selection.IGridOptions = function() {};
 /** @type {boolean} */
uiGrid.selection.IGridOptions.prototype.enableFooterTotalSelected;
 /** @type {boolean} */
uiGrid.selection.IGridOptions.prototype.enableFullRowSelection;
 /** @type {boolean} */
uiGrid.selection.IGridOptions.prototype.enableRowHeaderSelection;
 /** @type {boolean} */
uiGrid.selection.IGridOptions.prototype.enableRowSelection;
 /** @type {boolean} */
uiGrid.selection.IGridOptions.prototype.enableSelectAll;
 /** @type {boolean} */
uiGrid.selection.IGridOptions.prototype.enableSelectionBatchEvent;
 /** @type {function(!uiGrid.selection.IGridRow): boolean} */
uiGrid.selection.IGridOptions.prototype.isRowSelectable;
 /** @type {boolean} */
uiGrid.selection.IGridOptions.prototype.modifierKeysToMultiSelect;
 /** @type {boolean} */
uiGrid.selection.IGridOptions.prototype.multiSelect;
 /** @type {boolean} */
uiGrid.selection.IGridOptions.prototype.noUnselect;
 /** @type {number} */
uiGrid.selection.IGridOptions.prototype.selectionRowHeaderWidth;
/**
 * @record
 * @struct
 */
uiGrid.selection.IGridRow = function() {};
 /** @type {boolean} */
uiGrid.selection.IGridRow.prototype.enableSelection;
 /** @type {boolean} */
uiGrid.selection.IGridRow.prototype.isSelected;

/**
 * Sets the isSelected property and updates the selectedCount
 * Changes to isSelected state should only be made via this function
 * @param {boolean} selected Value to set
 * @return {void}
 */
uiGrid.selection.IGridRow.prototype.setSelected = function(selected) {};
/**
 * @record
 * @struct
 */
uiGrid.selection.IGridSelectionApi = function() {};
 /** @type {{rowSelectionChanged: function(!angular.IScope, !uiGrid.selection.rowSelectionChangedHandler<TEntity>): void, rowSelectionChangedBatch: function(!angular.IScope, !uiGrid.selection.rowSelectionChangedBatchHandler<TEntity>): void}} */
uiGrid.selection.IGridSelectionApi.prototype.on;

/**
 * Unselects All Rows
 * @param {!angular.IAngularEvent=} event
 * @return {void}
 */
uiGrid.selection.IGridSelectionApi.prototype.clearSelectedRows = function(event) {};

/**
 * Returns whether or not the selectAll checkbox is currently ticked.
 * The grid doesn't automatically select rows when you add extra data -
 * so when you add data you need to explicitly check whether the selectAll is set,
 * and then call setVisible rows if it is
 * @return {boolean}
 */
uiGrid.selection.IGridSelectionApi.prototype.getSelectAllState = function() {};

/**
 * returns all selected rows as gridRows
 * @return {!Array<!uiGrid.IGridRowOf<TEntity>>}
 */
uiGrid.selection.IGridSelectionApi.prototype.getSelectedGridRows = function() {};

/**
 * Gets selected rows as entities
 * @return {!Array<TEntity>}
 */
uiGrid.selection.IGridSelectionApi.prototype.getSelectedRows = function() {};

/**
 * Selects all rows.  Does nothing if multiselect = false
 * @param {!angular.IAngularEvent=} event
 * @return {void}
 */
uiGrid.selection.IGridSelectionApi.prototype.selectAllRows = function(event) {};

/**
 * Selects all visible rows.  Does nothing if multiselect = false
 * @param {!angular.IAngularEvent=} event
 * @return {void}
 */
uiGrid.selection.IGridSelectionApi.prototype.selectAllVisibleRows = function(event) {};

/**
 * Select row by data
 * @param {TEntity} rowEntity
 * @param {!angular.IAngularEvent=} event
 * @return {void}
 */
uiGrid.selection.IGridSelectionApi.prototype.selectRow = function(rowEntity, event) {};

/**
 * Select the specified row by visible index
 * (i.e. if you specify row 0 you'll get the first visible row selected).
 * 
 * In this context visible means of those rows that are theoretically visible (i.e. not filtered),
 * rather than rows currently rendered on the screen.
 * 
 * @param {number} index
 * @param {!angular.IAngularEvent=} event
 * @return {void}
 */
uiGrid.selection.IGridSelectionApi.prototype.selectRowByVisibleIndex = function(index, event) {};

/**
 * Sets the current gridOption.modifierKeysToMultiSelect to true or false
 * @param {boolean} multiSelect
 * @return {void}
 */
uiGrid.selection.IGridSelectionApi.prototype.setModifierKeysToMultiSelect = function(multiSelect) {};

/**
 * Sets the current gridOption.multiSelect to true or false
 * @param {boolean} multiSelect
 * @return {void}
 */
uiGrid.selection.IGridSelectionApi.prototype.setMultiSelect = function(multiSelect) {};

/**
 * Toggles data row as selected or unselected
 * @param {TEntity} rowEntity
 * @param {!angular.IAngularEvent=} event
 * @return {void}
 */
uiGrid.selection.IGridSelectionApi.prototype.toggleRowSelection = function(rowEntity, event) {};

/**
 * UnSelect the data row
 * @param {TEntity} rowEntity
 * @param {!angular.IAngularEvent=} event
 * @return {void}
 */
uiGrid.selection.IGridSelectionApi.prototype.unSelectRow = function(rowEntity, event) {};
/**
 * @record
 * @struct
 */
uiGrid.selection.rowSelectionChangedHandler = function() {};

/* TODO: CallSignature: uiGrid.selection */
/**
 * @record
 * @struct
 */
uiGrid.selection.rowSelectionChangedBatchHandler = function() {};

/* TODO: CallSignature: uiGrid.selection */
/** @const */
uiGrid.treeBase = {};
/**
 * @record
 * @struct
 */
uiGrid.treeBase.IColumnDef = function() {};
 /** @type {function(!uiGrid.treeBase.IGridTreeBaseAggregationObject): void} */
uiGrid.treeBase.IColumnDef.prototype.customTreeAggregationFinalizerFn;
 /** @type {function(!uiGrid.treeBase.IGridTreeBaseAggregationObject, ?, number, !uiGrid.IGridRowOf<TEntity>): void} */
uiGrid.treeBase.IColumnDef.prototype.customTreeAggregationFn;
 /** @type {string} */
uiGrid.treeBase.IColumnDef.prototype.treeAggregationLabel;
 /** @type {string} */
uiGrid.treeBase.IColumnDef.prototype.treeAggregationType;
 /** @type {boolean} */
uiGrid.treeBase.IColumnDef.prototype.treeAggregationUpdateEntity;
/**
 * @record
 * @struct
 */
uiGrid.treeBase.IGridOptions = function() {};
 /** @type {boolean} */
uiGrid.treeBase.IGridOptions.prototype.showTreeExpandNoChildren;
 /** @type {boolean} */
uiGrid.treeBase.IGridOptions.prototype.showTreeRowHeader;
 /** @type {!Object<string,!uiGrid.treeBase.IGridTreeBaseCustomAggregation<TEntity>>} */
uiGrid.treeBase.IGridOptions.prototype.treeCustomAggregations;
 /** @type {number} */
uiGrid.treeBase.IGridOptions.prototype.treeIndent;
 /** @type {boolean} */
uiGrid.treeBase.IGridOptions.prototype.treeRowHeaderAlwaysVisible;
 /** @type {number} */
uiGrid.treeBase.IGridOptions.prototype.treeRowHeaderBaseWidth;
/**
 * @record
 * @struct
 */
uiGrid.treeBase.IGridTreeBaseCustomAggregation = function() {};
 /** @type {string} */
uiGrid.treeBase.IGridTreeBaseCustomAggregation.prototype.label;
 /** @type {function(!uiGrid.treeBase.IGridTreeBaseAggregationObject, ?, number, !uiGrid.IGridRowOf<TEntity>): void} */
uiGrid.treeBase.IGridTreeBaseCustomAggregation.prototype.aggregationFn;
 /** @type {function(!uiGrid.treeBase.IGridTreeBaseAggregationObject): void} */
uiGrid.treeBase.IGridTreeBaseCustomAggregation.prototype.finalizerFn;
/**
 * @record
 * @struct
 */
uiGrid.treeBase.IGridTreeBaseAggregationObject = function() {};
 /** @type {number} */
uiGrid.treeBase.IGridTreeBaseAggregationObject.prototype.count;
 /** @type {number} */
uiGrid.treeBase.IGridTreeBaseAggregationObject.prototype.sum;
 /** @type {number} */
uiGrid.treeBase.IGridTreeBaseAggregationObject.prototype.value;
 /** @type {string} */
uiGrid.treeBase.IGridTreeBaseAggregationObject.prototype.rendered;
/**
 * @record
 * @struct
 */
uiGrid.treeBase.IGridTreeBaseApi = function() {};
 /** @type {{rowCollapsed: function(!angular.IScope, !uiGrid.treeBase.rowCollapsedHandler<TEntity>): void, rowExpanded: function(!angular.IScope, !uiGrid.treeBase.rowExpandedHandler<TEntity>): void}} */
uiGrid.treeBase.IGridTreeBaseApi.prototype.on;

/**
 * Collapse all tree rows
 * @return {void}
 */
uiGrid.treeBase.IGridTreeBaseApi.prototype.collapseAllRows = function() {};

/**
 * collapse the specified row. When you expand the row again, all grandchildren will retain their state
 * @param {!uiGrid.IGridRowOf<TEntity>} row
 * @return {void}
 */
uiGrid.treeBase.IGridTreeBaseApi.prototype.collapseRow = function(row) {};

/**
 * collapse all children of the specified row. When you expand the row again, all grandchildren will be
 * collapsed
 * @param {!uiGrid.IGridRowOf<TEntity>} row
 * @return {void}
 */
uiGrid.treeBase.IGridTreeBaseApi.prototype.collapseRowChildren = function(row) {};

/**
 * Expands all tree rows
 * @return {void}
 */
uiGrid.treeBase.IGridTreeBaseApi.prototype.expandAllRows = function() {};

/**
 * Expand the immediate children of the specified row
 * @param {!uiGrid.IGridRowOf<TEntity>} row
 * @return {void}
 */
uiGrid.treeBase.IGridTreeBaseApi.prototype.expandRow = function(row) {};

/**
 * Get the children of the specified row
 * @param {!uiGrid.IGridRowOf<TEntity>} row
 * @return {!Array<!uiGrid.IGridRowOf<TEntity>>} Array<IGridRow> Array of children rows
 */
uiGrid.treeBase.IGridTreeBaseApi.prototype.getRowChildren = function(row) {};

/**
 * Get the tree state for this grid, used by the saveState feature Returned treeState as an object
 * ```{ expandedState: { uid: 'expanded', uid: 'collapsed' } }```
 * where expandedState is a hash of row uid and the current expanded state
 * NOTE this is an incomplete feature in uiGrid
 * @return {!uiGrid.treeBase.ITreeState}
 */
uiGrid.treeBase.IGridTreeBaseApi.prototype.getTreeState = function() {};

/**
 * Set the expanded states of the tree
 * @param {!uiGrid.treeBase.ITreeState} config
 * @return {void}
 */
uiGrid.treeBase.IGridTreeBaseApi.prototype.setTreeState = function(config) {};

/**
 * call expand if row is collapsed, and collapse if it is expanded
 * @param {!uiGrid.IGridRowOf<TEntity>} row
 * @return {void}
 */
uiGrid.treeBase.IGridTreeBaseApi.prototype.toggleRowTreeState = function(row) {};
/**
 * @record
 * @struct
 */
uiGrid.treeBase.ITreeState = function() {};
 /** @type {!Object<string,string>} */
uiGrid.treeBase.ITreeState.prototype.expandedState;
/**
 * @record
 * @struct
 */
uiGrid.treeBase.rowCollapsedHandler = function() {};

/* TODO: CallSignature: uiGrid.treeBase */
/**
 * @record
 * @struct
 */
uiGrid.treeBase.rowExpandedHandler = function() {};

/* TODO: CallSignature: uiGrid.treeBase */
/**
 * @extends {uiGrid.ISharedTreeConstants}
 * @record
 * @struct
 */
uiGrid.treeBase.IUiGridTreeBaseConstants = function() {};
 /** @type {string} */
uiGrid.treeBase.IUiGridTreeBaseConstants.prototype.featureName;
/** @const */
uiGrid.treeView = {};
/**
 * @record
 * @struct
 */
uiGrid.treeView.IGridOptions = function() {};
 /** @type {boolean} */
uiGrid.treeView.IGridOptions.prototype.enableTreeView;
/**
 * @extends {uiGrid.ISharedTreeConstants}
 * @record
 * @struct
 */
uiGrid.treeView.IUiGridTreeViewConstants = function() {};
 /** @type {string} */
uiGrid.treeView.IUiGridTreeViewConstants.prototype.featureName;
/**
 * @record
 * @struct
 */
uiGrid.ISharedTreeConstants = function() {};
 /** @type {string} */
uiGrid.ISharedTreeConstants.prototype.rowHeaderColName;
 /** @type {string} */
uiGrid.ISharedTreeConstants.prototype.EXPANDED;
 /** @type {string} */
uiGrid.ISharedTreeConstants.prototype.COLLAPSED;
 /** @type {{COUNT: string, SUM: string, MAX: string, MIN: string, AVG: string}} */
uiGrid.ISharedTreeConstants.prototype.aggregation;
/**
 * @record
 * @struct
 */
uiGrid.IGridApiConstructor = function() {};

/* TODO: ConstructSignature: uiGrid */

/** @typedef {!uiGrid.IGridApiOf<?>} */
uiGrid.IGridApi;
/**
 * @record
 * @struct
 */
uiGrid.IGridApiOf = function() {};
 /** @type {!uiGrid.IGridCoreApi<TEntity>} */
uiGrid.IGridApiOf.prototype.core;
 /** @type {!uiGrid.cellNav.ICellNavApi<TEntity>} */
uiGrid.IGridApiOf.prototype.cellNav;
 /** @type {!uiGrid.moveColumns.IGridMoveColumnsApi} */
uiGrid.IGridApiOf.prototype.colMovable;
 /** @type {!uiGrid.resizeColumns.IGridResizeColumnsApi} */
uiGrid.IGridApiOf.prototype.colResizable;
 /** @type {!uiGrid.edit.IGridEditApi<TEntity>} */
uiGrid.IGridApiOf.prototype.edit;
 /** @type {!uiGrid.expandable.IGridExpandableApi<TEntity>} */
uiGrid.IGridApiOf.prototype.expandable;
 /** @type {!uiGrid.exporter.IGridExporterApi} */
uiGrid.IGridApiOf.prototype.exporter;
 /** @type {!uiGrid.grouping.IGridGroupingApi<TEntity>} */
uiGrid.IGridApiOf.prototype.grouping;
 /** @type {!uiGrid.importer.IGridImporterApi} */
uiGrid.IGridApiOf.prototype.importer;
 /** @type {!uiGrid.infiniteScroll.IGridInfiniteScrollApi<TEntity>} */
uiGrid.IGridApiOf.prototype.infiniteScroll;
 /** @type {!uiGrid.pagination.IGridPaginationApi} */
uiGrid.IGridApiOf.prototype.pagination;
 /** @type {!uiGrid.pinning.IGridPinningApi<TEntity>} */
uiGrid.IGridApiOf.prototype.pinning;
 /** @type {!uiGrid.rowEdit.IGridRowEditApi<TEntity>} */
uiGrid.IGridApiOf.prototype.rowEdit;
 /** @type {!uiGrid.saveState.IGridSaveStateApi} */
uiGrid.IGridApiOf.prototype.saveState;
 /** @type {!uiGrid.selection.IGridSelectionApi<TEntity>} */
uiGrid.IGridApiOf.prototype.selection;
 /** @type {!uiGrid.treeBase.IGridTreeBaseApi<TEntity>} */
uiGrid.IGridApiOf.prototype.treeBase;
 /** @type {!uiGrid.IGridInstanceOf<TEntity>} */
uiGrid.IGridApiOf.prototype.grid;

/**
 * Registers a new event for the given feature. The event will get a .raise and .on prepended to it
 * 
 * .raise.eventName() - takes no arguments
 * 
 * .on.eventName(scope, callBackFn, _this)
 * scope - a scope reference to add a deregister call to the scopes .$on('destroy').
 * Scope is optional and can be a null value, but in this case you must deregister it yourself via the returned
 * deregister function
 * callBackFn - The function to call
 * _this - optional this context variable for callbackFn. If omitted, grid.api will be used for the context
 * 
 * .on.eventName returns a dereg function that will remove the listener. It's not necessary to use it as the
 * listener will be removed when the scope is destroyed.
 * @param {string} featureName name of the feature that raises the event
 * @param {string} eventName name of the event
 * @return {void}
 */
uiGrid.IGridApiOf.prototype.registerEvent = function(featureName, eventName) {};

/**
 * Registers features and events from a simple objectMap.
 * eventObjectMap must be in this format (multiple features allowed)
 * @param {?} eventObjectMap map of feature/event names
 * @return {void}
 */
uiGrid.IGridApiOf.prototype.registerEventsFromObject = function(eventObjectMap) {};

/**
 * Registers a new event for the given feature
 * @param {string} featureName name of the feature
 * @param {string} methodName name of the method
 * @param {!Function} callBackFn function to execute
 * @param {?} _this binds to callBackFn. Defaults to gridApi.grid
 * @return {void}
 */
uiGrid.IGridApiOf.prototype.registerMethod = function(featureName, methodName, callBackFn, _this) {};

/**
 * Registers features and methods from a simple objectMap.
 * eventObjectMap must be in this format (multiple features allowed)
 * {featureName: { methodNameOne:function(args){}, methodNameTwo:function(args){} }
 * @param {?} eventObjectMap map of feature/event names
 * @param {?} _this binds this to _this for all functions. Defaults to gridApi.grid
 * @return {void}
 */
uiGrid.IGridApiOf.prototype.registerMethodsFromObject = function(eventObjectMap, _this) {};

/**
 * Used to execute a function while disabling the specified event listeners.
 * Disables the listenerFunctions, executes the callbackFn, and then enables the listenerFunctions again
 * @param {(!Function|!Array<!Function>)} listenerFuncs listenerFunc or array of listenerFuncs to suppress.
 *                      These must be the same functions that were used in the .on.eventName method
 * @param {!Function} callBackFn function to execute
 * @return {void}
 */
uiGrid.IGridApiOf.prototype.suppressEvents = function(listenerFuncs, callBackFn) {};
/**
 * @record
 * @struct
 */
uiGrid.IGridRowConstructor = function() {};

/* TODO: ConstructSignature: uiGrid */

/** @typedef {!uiGrid.IGridRowOf<?>} */
uiGrid.IGridRow;
/**
 * @extends {uiGrid.cellNav.IGridRow}
 * @extends {uiGrid.edit.IGridRow}
 * @extends {uiGrid.exporter.IGridRow}
 * @extends {uiGrid.selection.IGridRow}
 * @extends {uiGrid.expandable.IGridRow}
 * @record
 * @struct
 */
uiGrid.IGridRowOf = function() {};
 /** @type {TEntity} */
uiGrid.IGridRowOf.prototype.entity;
 /** @type {!uiGrid.IGridInstanceOf<TEntity>} */
uiGrid.IGridRowOf.prototype.grid;
 /** @type {number} */
uiGrid.IGridRowOf.prototype.height;
 /** @type {string} */
uiGrid.IGridRowOf.prototype.uid;
 /** @type {boolean} */
uiGrid.IGridRowOf.prototype.visible;
 /** @type {boolean} */
uiGrid.IGridRowOf.prototype.exporterEnableExporting;

/**
 * Clears an override on the row that forces it to always be invisible.
 * Emits the rowsVisibleChanged event if it changed the row visibility.
 * 
 * This method can be called from the api, passing in the gridRow we want altered.
 * It should really work by calling gridRow.clearRowInvisible,
 * but that's not the way I coded it, and too late to change now.
 * Changed to just call the internal function row.clearThisRowInvisible().
 * Clears any override on the row visibility, returning it to normal visibility calculations.
 * Emits the rowsVisibleChanged event
 * @param {!uiGrid.IGridRowOf|string} row_or_reason the row we want to clear the invisible flag / the reason (usually the module) for the row to be invisible. E.g. grouping, user, filter
 * @param {boolean=} fromRowsProcessor whether we were called from a rowsProcessor, passed through to evaluateRowVisibility
 * @return {void}
 */
uiGrid.IGridRowOf.prototype.clearRowInvisible = function(row_or_reason, fromRowsProcessor) {};

/**
 * Determines whether the row should be visible based on invisibleReason,
 * and if it changes the row visibility, then emits the rowsVisibleChanged event.
 * Queues a grid refresh, but doesn't call it directly to avoid hitting lots of
 * grid refreshes.
 * @param {boolean} fromRowProcessor
 * @return {void}
 */
uiGrid.IGridRowOf.prototype.evaluateRowVisibility = function(fromRowProcessor) {};

/**
 * returns the qualified field name minus the row path ie: entity.fieldA
 * @param {!uiGrid.IGridColumnOf<TEntity>} col column instance
 * @return {string} resulting name that can be evaluated against a row
 */
uiGrid.IGridRowOf.prototype.getEntityQualifiedColField = function(col) {};

/**
 * returns the qualified field name as it exists on scope ie: row.entity.fieldA
 * @param {!uiGrid.IGridColumnOf<TEntity>} col column instance
 * @return {string} resulting name that can be evaluated on scope
 */
uiGrid.IGridRowOf.prototype.getQualifiedColField = function(col) {};

/**
 * Sets an override on the row that forces it to always be invisible.
 * Emits the rowsVisibleChanged event if it changed the row visibility.
 * This method can be called from the api, passing in the gridRow we want altered.
 * It should really work by calling gridRow.setRowInvisible,
 * but that's not the way I coded it, and too late to change now.
 * Changed to just call the internal function row.setThisRowInvisible().
 * @param {!uiGrid.IGridRowOf} row the row we want to set to invisible
 * @return {void}
 */
uiGrid.IGridRowOf.prototype.setRowInvisible = function(row) {};

/**
 * Sets an override on the row that forces it to always be invisible.
 * Emits the rowsVisibleChanged event if it changed the row visibility
 * @param {string} reason the reason (usually the module) for the row to be invisible. E.g. grouping, user, filter
 * @param {boolean} fromRowsProcessor whether we were called from a rowsProcessor, passed through to evaluateRowVisibility
 * @return {void}
 */
uiGrid.IGridRowOf.prototype.setThisRowInvisible = function(reason, fromRowsProcessor) {};
/**
 * @record
 * @struct
 */
uiGrid.IGridColumnConstructor = function() {};

/* TODO: ConstructSignature: uiGrid */

/** @typedef {!uiGrid.IGridColumnOf<?>} */
uiGrid.IGridColumn;
/**
 * @record
 * @struct
 */
uiGrid.IGridColumnOf = function() {};
 /** @type {!uiGrid.IColumnDefOf<TEntity>} */
uiGrid.IGridColumnOf.prototype.colDef;
 /** @type {string} */
uiGrid.IGridColumnOf.prototype.displayName;
 /** @type {string} */
uiGrid.IGridColumnOf.prototype.field;
 /** @type {!uiGrid.IFilterOptions} */
uiGrid.IGridColumnOf.prototype.filter;
 /** @type {!Array<!uiGrid.IFilterOptions>} */
uiGrid.IGridColumnOf.prototype.filters;
 /** @type {!uiGrid.IGridInstanceOf<TEntity>} */
uiGrid.IGridColumnOf.prototype.grid;
 /** @type {string} */
uiGrid.IGridColumnOf.prototype.name;
 /** @type {!uiGrid.ISortInfo} */
uiGrid.IGridColumnOf.prototype.sort;
 /** @type {function(?, ?, !uiGrid.IGridRowOf<TEntity>, !uiGrid.IGridRowOf<TEntity>, string): number} */
uiGrid.IGridColumnOf.prototype.sortingAlgorithm;
 /** @type {number} */
uiGrid.IGridColumnOf.prototype.width;

/**
 * Initializes a column
 * @param {!uiGrid.IColumnDefOf<TEntity>} colDef the column def to associate with this column
 * @param {number} uid The unique and immutable uid we'd like to allocate to this column
 * @param {!uiGrid.IGridInstanceOf<TEntity>} grid the grid we'd like to create this column in
 * @return {void}
 */
uiGrid.IGridColumnOf.prototype.GridColumn = function(colDef, uid, grid) {};

/**
 * Gets the aggregation label from colDef.aggregationLabel if specified or by using i18n,
 * including deciding whether or not to display based on colDef.aggregationHideLabel.
 * @param {string} label the i18n lookup value to use for the column label
 * @return {void}
 */
uiGrid.IGridColumnOf.prototype.getAggregationText = function(label) {};

/**
 * gets the aggregation value based on the aggregation type for this column.
 * Debounced using scrollDebounce option setting
 * @return {string}
 */
uiGrid.IGridColumnOf.prototype.getAggregationValue = function() {};

/**
 * Returns the class name for the column
 * @param {boolean} prefixDot if true, will return .className instead of className
 * @return {string}
 */
uiGrid.IGridColumnOf.prototype.getColClass = function(prefixDot) {};

/**
 * Returns the class definition for th column
 * @return {string}
 */
uiGrid.IGridColumnOf.prototype.getColClassDefinition = function() {};

/**
 * Returns the render container object that this column belongs to.
 * Columns will be default be in the body render container
 * if they aren't allocated to one specifically.
 * @return {?}
 */
uiGrid.IGridColumnOf.prototype.getRenderContainer = function() {};

/**
 * Hides the column by setting colDef.visible = false
 * @return {void}
 */
uiGrid.IGridColumnOf.prototype.hideColumn = function() {};

/**
 * Returns true if column is in the left render container
 * @return {boolean}
 */
uiGrid.IGridColumnOf.prototype.isPinnedLeft = function() {};

/**
 * Returns true if column is in the right render container
 * @return {boolean}
 */
uiGrid.IGridColumnOf.prototype.isPinnedRight = function() {};

/**
 * Sets a property on the column using the passed in columnDef,
 * and setting the defaultValue if the value cannot be found on the colDef
 * @param {!uiGrid.IColumnDefOf<TEntity>} colDef the column def to look in for the property value
 * @param {string} propName the property name we'd like to set
 * @param {?} defaultValue the value to use if the colDef doesn't provide the setting
 * @return {void}
 */
uiGrid.IGridColumnOf.prototype.setPropertyOrDefault = function(colDef, propName, defaultValue) {};

/**
 * Makes the column visible by setting colDef.visible = true
 * @return {void}
 */
uiGrid.IGridColumnOf.prototype.showColumn = function() {};

/**
 * Moves settings from the columnDef down onto the column, and sets properties as appropriate
 * @param {!uiGrid.IColumnDefOf<TEntity>} colDef the column def to look in for property value
 * @param {boolean} isNew whether the column is being newly created, if not we're updating an existing
 *              column, and some items such as the sort shouldn't be copied down
 * @return {void}
 */
uiGrid.IGridColumnOf.prototype.updateColumnDef = function(colDef, isNew) {};

/** @typedef {!uiGrid.IColumnDefOf<?>} */
uiGrid.IColumnDef;
/**
 * @extends {uiGrid.cellNav.IColumnDef}
 * @extends {uiGrid.edit.IColumnDef}
 * @extends {uiGrid.exporter.IColumnDef}
 * @extends {uiGrid.grouping.IColumnDef}
 * @extends {uiGrid.moveColumns.IColumnDef}
 * @extends {uiGrid.pinning.IColumnDef}
 * @extends {uiGrid.resizeColumns.IColumnDef}
 * @extends {uiGrid.treeBase.IColumnDef}
 * @record
 * @struct
 */
uiGrid.IColumnDefOf = function() {};
 /** @type {boolean} */
uiGrid.IColumnDefOf.prototype.aggregationHideLabel;
 /** @type {(number|!Function)} */
uiGrid.IColumnDefOf.prototype.aggregationType;
 /** @type {(string|!uiGrid.ICellClassGetter<TEntity>)} */
uiGrid.IColumnDefOf.prototype.cellClass;
 /** @type {string} */
uiGrid.IColumnDefOf.prototype.cellFilter;
 /** @type {string} */
uiGrid.IColumnDefOf.prototype.cellTemplate;
 /** @type {(string|boolean|!uiGrid.ICellTooltipGetter<TEntity>)} */
uiGrid.IColumnDefOf.prototype.cellTooltip;
 /** @type {string} */
uiGrid.IColumnDefOf.prototype.displayName;
 /** @type {boolean} */
uiGrid.IColumnDefOf.prototype.enableColumnMenu;
 /** @type {boolean} */
uiGrid.IColumnDefOf.prototype.enableColumnMenus;
 /** @type {boolean} */
uiGrid.IColumnDefOf.prototype.enableFiltering;
 /** @type {boolean} */
uiGrid.IColumnDefOf.prototype.enableHiding;
 /** @type {boolean} */
uiGrid.IColumnDefOf.prototype.enableSorting;
 /** @type {string} */
uiGrid.IColumnDefOf.prototype.field;
 /** @type {!uiGrid.IFilterOptions} */
uiGrid.IColumnDefOf.prototype.filter;
 /** @type {boolean} */
uiGrid.IColumnDefOf.prototype.filterCellFiltered;
 /** @type {string} */
uiGrid.IColumnDefOf.prototype.filterHeaderTemplate;
 /** @type {!Array<!uiGrid.IFilterOptions>} */
uiGrid.IColumnDefOf.prototype.filters;
 /** @type {(string|!uiGrid.IHeaderFooterCellClassGetter<TEntity>)} */
uiGrid.IColumnDefOf.prototype.footerCellClass;
 /** @type {string} */
uiGrid.IColumnDefOf.prototype.footerCellFilter;
 /** @type {string} */
uiGrid.IColumnDefOf.prototype.footerCellTemplate;
 /** @type {(string|!uiGrid.IHeaderFooterCellClassGetter<TEntity>)} */
uiGrid.IColumnDefOf.prototype.headerCellClass;
 /** @type {string} */
uiGrid.IColumnDefOf.prototype.headerCellFilter;
 /** @type {string} */
uiGrid.IColumnDefOf.prototype.headerCellTemplate;
 /** @type {(string|boolean|!uiGrid.IHeaderTooltipGetter<TEntity>)} */
uiGrid.IColumnDefOf.prototype.headerTooltip;
 /** @type {number} */
uiGrid.IColumnDefOf.prototype.maxWidth;
 /** @type {!Array<!uiGrid.IMenuItem>} */
uiGrid.IColumnDefOf.prototype.menuItems;
 /** @type {number} */
uiGrid.IColumnDefOf.prototype.minWidth;
 /** @type {string} */
uiGrid.IColumnDefOf.prototype.name;
 /** @type {!uiGrid.ISortInfo} */
uiGrid.IColumnDefOf.prototype.sort;
 /** @type {boolean} */
uiGrid.IColumnDefOf.prototype.sortCellFiltered;
 /** @type {!Array<string>} */
uiGrid.IColumnDefOf.prototype.sortDirectionCycle;
 /** @type {function(?, ?, !uiGrid.IGridRowOf<TEntity>, !uiGrid.IGridRowOf<TEntity>, string): number} */
uiGrid.IColumnDefOf.prototype.sortingAlgorithm;
 /** @type {boolean} */
uiGrid.IColumnDefOf.prototype.suppressRemoveSort;
 /** @type {string} */
uiGrid.IColumnDefOf.prototype.type;
 /** @type {boolean} */
uiGrid.IColumnDefOf.prototype.visible;
 /** @type {(string|number)} */
uiGrid.IColumnDefOf.prototype.width;
/**
 * @record
 * @struct
 */
uiGrid.ICellClassGetter = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.ICellTooltipGetter = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.IHeaderTooltipGetter = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.IHeaderFooterCellClassGetter = function() {};

/* TODO: CallSignature: uiGrid */
/**
 * @record
 * @struct
 */
uiGrid.IMenuItem = function() {};
 /** @type {string} */
uiGrid.IMenuItem.prototype.title;
 /** @type {string} */
uiGrid.IMenuItem.prototype.icon;
 /** @type {function(!angular.IAngularEvent): void} */
uiGrid.IMenuItem.prototype.action;
 /** @type {function(): boolean} */
uiGrid.IMenuItem.prototype.shown;
 /** @type {function(): boolean} */
uiGrid.IMenuItem.prototype.active;
 /** @type {?} */
uiGrid.IMenuItem.prototype.context;
 /** @type {boolean} */
uiGrid.IMenuItem.prototype.leaveOpen;
/**
 * @record
 * @struct
 */
uiGrid.ISortInfo = function() {};
 /** @type {string} */
uiGrid.ISortInfo.prototype.direction;
 /** @type {boolean} */
uiGrid.ISortInfo.prototype.ignoreSort;
 /** @type {number} */
uiGrid.ISortInfo.prototype.priority;
/**
 * @record
 * @struct
 */
uiGrid.IFilterOptions = function() {};
 /** @type {(number|function(string, ?, !uiGrid.IGridRowOf<?>, !uiGrid.IGridColumnOf<?>): boolean)} */
uiGrid.IFilterOptions.prototype.condition;
 /** @type {string} */
uiGrid.IFilterOptions.prototype.term;
 /** @type {string} */
uiGrid.IFilterOptions.prototype.placeholder;
 /** @type {string} */
uiGrid.IFilterOptions.prototype.ariaLabel;
 /** @type {boolean} */
uiGrid.IFilterOptions.prototype.noTerm;
 /** @type {!uiGrid.IFilterFlags} */
uiGrid.IFilterOptions.prototype.flags;
 /** @type {(string|number)} */
uiGrid.IFilterOptions.prototype.type;
 /** @type {!Array<!uiGrid.ISelectOption>} */
uiGrid.IFilterOptions.prototype.selectOptions;
 /** @type {boolean} */
uiGrid.IFilterOptions.prototype.disableCancelFilterButton;
/**
 * @record
 * @struct
 */
uiGrid.ISelectOption = function() {};
 /** @type {(string|number)} */
uiGrid.ISelectOption.prototype.value;
 /** @type {string} */
uiGrid.ISelectOption.prototype.label;
/**
 * @record
 * @struct
 */
uiGrid.IFilterFlags = function() {};
 /** @type {boolean} */
uiGrid.IFilterFlags.prototype.caseSensitive;
