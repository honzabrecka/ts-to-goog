/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/rosie/index.d.ts:
/** @const */
var rosie = {};
/**
 * @record
 * @struct
 */
rosie.IFactoryStatic = function() {};

/**
 * Defines a factory by name and constructor function. Call #attr and #option
 * on the result to define the properties of this factory.
 * 
 * @param {!String} name
 * @param {!Function=} constructor
 * @return {!rosie.IFactory}
 */
rosie.IFactoryStatic.prototype.define = function(name, constructor) {};

/**
 * Locates a factory by name and calls #build on it.
 * 
 * @param {string} name
 * @param {?=} attributes
 * @param {!Object=} options
 * @return {!Object}
 */
rosie.IFactoryStatic.prototype.build = function(name, attributes, options) {};

/**
 * Builds a collection of objects using the named factory.
 * 
 * @param {string} name
 * @param {number} size
 * @param {?=} attributes
 * @param {!Object=} options
 * @return {!Array<!Object>}
 */
rosie.IFactoryStatic.prototype.buildList = function(name, size, attributes, options) {};

/**
 * Locates a factory by name and calls #attributes on it.
 * 
 * @param {string} name
 * @param {!Object} attributes
 * @param {!Object=} options
 * @return {!Object}
 */
rosie.IFactoryStatic.prototype.attributes = function(name, attributes, options) {};
/**
 * @record
 * @struct
 */
rosie.IFactory = function() {};

/**
 * Define an attribute on this factory. Attributes can optionally define a
 * default value, either as a value (e.g. a string or number) or as a builder
 * function. For example:
 * 
 *   // no default value for age
 *   Factory.define('Person').attr('age')
 * 
 *   // static default value for age
 *   Factory.define('Person').attr('age', 18)
 * 
 *   // dynamic default value for age
 *   Factory.define('Person').attr('age', function() {
 *      return Math.random() * 100;
 *   })
 * 
 * Attributes with dynamic default values can depend on options or other
 * attributes:
 * 
 *   Factory.define('Person').attr('age', ['name'], function(name) {
 *     return name === 'Brian' ? 30 : 18;
 *   });
 * 
 * By default if the consumer of your factory provides a value for an
 * attribute your builder function will not be called. You can override this
 * behavior by declaring that your attribute depends on itself:
 * 
 *   Factory.define('Person').attr('spouse', ['spouse'], function(spouse) {
 *     return Factory.build('Person', spouse);
 *   });
 * 
 * As in the example above, this can be a useful way to fill in
 * partially-specified child objects.
 * 
 * @param {string} name
 * @param {?} dependenciesOrValue
 * @param {?=} value
 * @return {!rosie.IFactory}
 */
rosie.IFactory.prototype.attr = function(name, dependenciesOrValue, value) {};

/**
 * Define an option for this factory. Options are values that may inform
 * dynamic attribute behavior but are not included in objects built by the
 * factory. Like attributes, options may have dependencies. Unlike
 * attributes, options may only depend on other options.
 * 
 *   Factory.define('Person')
 *     .option('includeRelationships', false)
 *     .attr(
 *       'spouse',
 *       ['spouse', 'includeRelationships'],
 *       function(spouse, includeRelationships) {
 *         return includeRelationships ?
 *           Factory.build('Person', spouse) :
 *           null;
 *       });
 * 
 *   Factory.build('Person', null, { includeRelationships: true });
 * 
 * Options may have either static or dynamic default values, just like
 * attributes. Options without default values must have a value specified
 * when building.
 * 
 * @param {string} name
 * @param {?=} dependenciesOrValue
 * @param {?=} value
 * @return {!rosie.IFactory}
 */
rosie.IFactory.prototype.option = function(name, dependenciesOrValue, value) {};

/**
 * Defines an attribute that, by default, simply has an auto-incrementing
 * numeric value starting at 1. You can provide your own builder function
 * that accepts the number of the sequence and returns whatever value you'd
 * like it to be.
 * 
 * Sequence values are inherited such that a factory derived from another
 * with a sequence will share the state of that sequence and they will never
 * conflict.
 * 
 *   Factory.define('Person').sequence('id');
 * 
 * @param {string} name
 * @param {(!Function|!Array<string>)=} dependenciesOrBuilder
 * @param {!Function=} builder
 * @return {!rosie.IFactory}
 */
rosie.IFactory.prototype.sequence = function(name, dependenciesOrBuilder, builder) {};

/**
 * Sets a post-processor callback that will receive built objects and the
 * options for the build just before they are returned from the #build
 * function.
 * 
 * @param {!Function} functionArg
 * @return {!rosie.IFactory}
 */
rosie.IFactory.prototype.after = function(functionArg) {};

/**
 * Sets the constructor for this factory to be another factory. This can be
 * used to create more specific sub-types of factories.
 * 
 * @param {!Function} functionArg
 * @return {!rosie.IFactory}
 */
rosie.IFactory.prototype.inherits = function(functionArg) {};

/**
 * Builds a plain object containing values for each of the declared
 * attributes. The result of this is the same as the result when using #build
 * when there is no constructor registered.
 * 
 * @param {!Object} attributes
 * @param {!Object} options
 * @return {!Object}
 */
rosie.IFactory.prototype.attributes = function(attributes, options) {};

/**
 * Generates values for all the registered options using the values given.
 * 
 * @param {!Object} options
 * @return {!Object}
 */
rosie.IFactory.prototype.options = function(options) {};

/**
 * Builds objects by getting values for all attributes and optionally passing
 * the result to a constructor function.
 * 
 * @param {!Object} attributes
 * @param {!Object} options
 * @return {!Object}
 */
rosie.IFactory.prototype.build = function(attributes, options) {};

/**
 * @param {number} size
 * @param {!Object} attributes
 * @param {!Object} options
 * @return {!Array<!Object>}
 */
rosie.IFactory.prototype.buildList = function(size, attributes, options) {};

/**
 * Extends a given factory by copying over its attributes, options,
 * callbacks, and constructor. This can be useful when you want to make
 * different types which all share certain attributes.
 * 
 * @param {(!String|!rosie.IFactory)} name
 * @return {!rosie.IFactory}
 */
rosie.IFactory.prototype.extend = function(name) {};
 /** @type {{Factory: !rosie.IFactoryStatic}} */
var rosie;

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
