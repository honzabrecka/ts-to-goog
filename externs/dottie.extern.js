/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/dottie/index.d.ts:
 /** @type {!dottie.Dottie} */
var dottie;

/* TODO: ExportAssignment in  */

/** @typedef {(string|!Array<string>)} */
dottie.DottiePath;
/**
 * @record
 * @struct
 */
dottie.FlatPaths = function() {};

/* TODO: IndexSignature: dottie */
/**
 * @record
 * @struct
 */
dottie.SetOptions = function() {};
 /** @type {boolean} */
dottie.SetOptions.prototype.force;
/**
 * @record
 * @struct
 */
dottie.TransformOptions = function() {};
 /** @type {string} */
dottie.TransformOptions.prototype.delimiter;
/**
 * @record
 * @struct
 */
dottie.Dottie = function() {};
 /** @type {boolean} */
dottie.Dottie.prototype.memoizePath;

/**
 * Check path exists in object
 * 
 * \@example 
 * const values = {
 *  some: {
 *    key: 'foobar';
 *  },
 * }
 * 
 * dottie.exists(values, 'some.key'); // true
 * dottie.exists(values, 'some.otherKey'); // false
 * @param {!Object} obj
 * @param {(string|!Array<string>)} path
 * @return {boolean}
 */
dottie.Dottie.prototype.exists = function(obj, path) {};

/**
 * Gets nested value, or undefined if unreachable, or a default value if passed.
 * 
 * \@example 
 * const values = {
 *  some: {
 *    nested: {
 *      key: 'foobar';
 *    }
 *  },
 *  'some.dot.included': {
 *    key: 'barfoo'
 *  }
 * }
 * 
 * dottie.get<string>(values, 'some.nested.key'); // 'foobar'
 * dottie.get<string>(values, 'some.undefined.key'); // undefined
 * dottie.get<string>(values, 'some.undefined.key', 'defaultval'); // 'defaultval'
 * dottie.get<string>(values, ['some.dot.included', 'key']); // 'barfoo'
 * @template T
 * @param {!Object} obj
 * @param {(string|!Array<string>)} path
 * @param {T=} defaultValue
 * @return {T}
 */
dottie.Dottie.prototype.get = function(obj, path, defaultValue) {};

/**
 * Sets nested value, creates nested structure if needed
 * 
 * \@example 
 * dottie.set(values, 'some.nested.value', someValue);
 * dottie.set(values, ['some.dot.included', 'value'], someValue);
 * dottie.set(values, 'some.nested.object', someValue, { force: true });
 * @param {!Object} obj
 * @param {(string|!Array<string>)} path
 * @param {?} value
 * @param {!dottie.SetOptions=} options
 * @return {void}
 */
dottie.Dottie.prototype.set = function(obj, path, value, options) {};

/**
 * Set the default value if path does not exist
 * 
 * \@example 
 * dottie.default({}, 'some.value', 'a') as MyType; // { some: { value: 'a' }}
 * dottie.default({ some: { value: 'a' }}, 'some.value', 'b') as MyType; // { some: { value: 'a' }}
 * @param {!Object} obj
 * @param {(string|!Array<string>)} path
 * @param {?} value
 * @return {?}
 */
dottie.Dottie.prototype.default = function(obj, path, value) {};

/**
 * Transform object from keys with dottie notation to nested objects
 * 
 * \@example 
 * const values = {
 *   'user.name': 'Gummy Bear',
 *   'user.email': 'gummybear\@candymountain.com',
 *   'user.professional.title': 'King',
 *   'user.professional.employer': 'Candy Mountain'
 * };
 * const transformed = dottie.transform(values) as MyType;
 * 
 * assert.deepEqual(transformed, {
 *   user: {
 *     name: 'Gummy Bear',
 *     email: 'gummybear\@candymountain.com',
 *     professional: {
 *       title: 'King',
 *       employer: 'Candy Mountain'
 *     }
 *   }
 * });
 * 
 * \@example with custom delimiter
 * const values = {
 *   'user_name': 'Mick Hansen',
 *   'user_email': 'maker\@mhansen.io'
 * };
 * const transformed = dottie.transform(values, { delimiter: '_' }) as MyType;
 * 
 * assert.deepEqual(transformed, {
 *   user: {
 *     name: 'Mick Hansen',
 *     email: 'maker\@mhansen.io'
 *   }
 * });
 * @param {!dottie.FlatPaths} obj
 * @param {!dottie.TransformOptions=} options
 * @return {?}
 */
dottie.Dottie.prototype.transform = function(obj, options) {};

/**
 * Opposite of transform. Flattens a nested object
 * 
 * \@example 
 * const values = {
 *   user: {
 *     name: 'Gummy Bear',
 *     email: 'gummybear\@candymountain.com',
 *     professional: {
 *       title: 'King',
 *       employer: 'Candy Mountain'
 *     }
 *   }
 * };
 * const transformed = dottie.transform(values);
 * 
 * assert.deepEqual(transformed, {
 *   'user.name': 'Gummy Bear',
 *   'user.email': 'gummybear\@candymountain.com',
 *   'user.professional.title': 'King',
 *   'user.professional.employer': 'Candy Mountain'
 * });
 * 
 * \@example with custom delimiter
 * const values = {
 *   user: {
 *     name: 'Mick Hansen',
 *     email: 'maker\@mhansen.io'
 *   }
 * };
 * const transformed = dottie.flatten(values, '_');
 * 
 * assert.deepEqual(transformed, {
 *   'user_name': 'Mick Hansen',
 *   'user_email': 'maker\@mhansen.io'
 * });
 * @param {!Object} obj
 * @param {string=} delimiter
 * @return {!dottie.FlatPaths}
 */
dottie.Dottie.prototype.flatten = function(obj, delimiter) {};

/**
 * Get paths in object
 * 
 * \@example 
 * const object = {
 *   a: 1,
 *   b: {
 *     c: 2,
 *     d: { e: 3 }
 *   }
 * };
 * 
 * dottie.paths(object); // ["a", "b.c", "b.d.e"];
 * @param {!Object} obj
 * @return {!Array<string>}
 */
dottie.Dottie.prototype.paths = function(obj) {};
