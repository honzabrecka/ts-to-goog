/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/websocket/index.d.ts:

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */
/**
 * @record
 * @struct
 */
function IStringified() {}
 /** @type {?} */
IStringified.prototype.toString;
/**
 * @record
 * @struct
 */
function IConfig() {}
 /** @type {number} */
IConfig.prototype.maxReceivedFrameSize;
 /** @type {number} */
IConfig.prototype.maxReceivedMessageSize;
 /** @type {boolean} */
IConfig.prototype.fragmentOutgoingMessages;
 /** @type {number} */
IConfig.prototype.fragmentationThreshold;
 /** @type {boolean} */
IConfig.prototype.assembleFragments;
 /** @type {number} */
IConfig.prototype.closeTimeout;
/**
 * @extends {IConfig}
 * @record
 * @struct
 */
function IServerConfig() {}
 /** @type {!Server} */
IServerConfig.prototype.httpServer;
 /** @type {number} */
IServerConfig.prototype.maxReceivedFrameSize;
 /** @type {number} */
IServerConfig.prototype.maxReceivedMessageSize;
 /** @type {boolean} */
IServerConfig.prototype.keepalive;
 /** @type {number} */
IServerConfig.prototype.keepaliveInterval;
 /** @type {boolean} */
IServerConfig.prototype.dropConnectionOnKeepaliveTimeout;
 /** @type {number} */
IServerConfig.prototype.keepaliveGracePeriod;
 /** @type {boolean} */
IServerConfig.prototype.autoAcceptConnections;
 /** @type {boolean} */
IServerConfig.prototype.disableNagleAlgorithm;

/**
 * @constructor
 * @struct
 * @param {?=} serverConfig
 */
function server(serverConfig) {}
 /** @type {?} */
server.prototype.config;
 /** @type {!Array<!connection>} */
server.prototype.connections;

/**
 * Send binary message for each connection
 * Send UTF-8 message for each connection
 * @param {?} data
 * @return {void}
 */
server.prototype.broadcast = function(data) {};

/**
 * Send binary message for each connection
 * @param {?} data
 * @return {void}
 */
server.prototype.broadcastBytes = function(data) {};

/**
 * Send UTF-8 message for each connection
 * @param {?} data
 * @return {void}
 */
server.prototype.broadcastUTF = function(data) {};

/**
 * Attach the `server` instance to a Node http.Server instance
 * @param {?} serverConfig
 * @return {void}
 */
server.prototype.mount = function(serverConfig) {};

/**
 * Detach the `server` instance from the Node http.Server instance.
 * All existing connections are left alone and will not be affected,
 * but no new WebSocket connections will be accepted.
 * @return {void}
 */
server.prototype.unmount = function() {};

/**
 * Close all open WebSocket connections
 * @return {void}
 */
server.prototype.closeAllConnections = function() {};

/**
 * Close all open WebSocket connections and unmount the server
 * @return {void}
 */
server.prototype.shutDown = function() {};

/**
 * @param {string} event
 * @param {function(): void|function(!request): void|function(!connection): void|function(!connection, number, string): void} listener_or_cb
 * @return {server}
 */
server.prototype.on = function(event, listener_or_cb) {};

/**
 * @param {string} event
 * @param {function(): void|function(!request): void|function(!connection): void|function(!connection, number, string): void} listener_or_cb
 * @return {server}
 */
server.prototype.addListener = function(event, listener_or_cb) {};
/**
 * @record
 * @struct
 */
function ICookie() {}
 /** @type {string} */
ICookie.prototype.name;
 /** @type {string} */
ICookie.prototype.value;
 /** @type {string} */
ICookie.prototype.path;
 /** @type {string} */
ICookie.prototype.domain;
 /** @type {!Date} */
ICookie.prototype.expires;
 /** @type {number} */
ICookie.prototype.maxage;
 /** @type {boolean} */
ICookie.prototype.secure;
 /** @type {boolean} */
ICookie.prototype.httponly;
/**
 * @record
 * @struct
 */
function IExtension() {}
 /** @type {string} */
IExtension.prototype.name;
 /** @type {string} */
IExtension.prototype.value;

/**
 * @constructor
 * @struct
 * @param {?} socket
 * @param {!IncomingMessage} httpRequest
 * @param {?} config
 */
function request(socket, httpRequest, config) {}
 /** @type {!IncomingMessage} */
request.prototype.httpRequest;
 /** @type {string} */
request.prototype.host;
 /** @type {string} */
request.prototype.resource;
 /** @type {string} */
request.prototype.key;
 /** @type {!Url} */
request.prototype.resourceURL;
 /** @type {string} */
request.prototype.remoteAddress;
 /** @type {string} */
request.prototype.origin;
 /** @type {number} */
request.prototype.webSocketVersion;
 /** @type {!Array<?>} */
request.prototype.requestedExtensions;
 /** @type {!Array<?>} */
request.prototype.cookies;
 /** @type {?} */
request.prototype.socket;
 /** @type {!Array<string>} */
request.prototype.requestedProtocols;
 /** @type {!Object<string,string>} */
request.prototype.protocolFullCaseMap;

/**
 * After inspecting the `request` properties, call this function on the
 * request object to accept the connection. If you don't have a particular subprotocol
 * you wish to speak, you may pass `null` for the `acceptedProtocol` parameter.
 * 
 * @param {string=} acceptedProtocol
 * @param {string=} allowedOrigin
 * @param {!Array<?>=} cookies
 * @return {!connection}
 */
request.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {};

/**
 * Reject connection.
 * You may optionally pass in an HTTP Status code (such as 404) and a textual
 * description that will be sent to the client in the form of an
 * `X-WebSocket-Reject-Reason` header.
 * Optional extra http headers can be added via Object key/values on extraHeaders.
 * @param {number=} httpStatus
 * @param {string=} reason
 * @param {!Object=} extraHeaders
 * @return {void}
 */
request.prototype.reject = function(httpStatus, reason, extraHeaders) {};

/**
 * @param {string} event
 * @param {function(): void|function(!connection): void} listener_or_cb
 * @return {request}
 */
request.prototype.on = function(event, listener_or_cb) {};

/**
 * @param {string} event
 * @param {function(): void|function(!connection): void} listener_or_cb
 * @return {request}
 */
request.prototype.addListener = function(event, listener_or_cb) {};
/**
 * @record
 * @struct
 */
function IMessage() {}
 /** @type {string} */
IMessage.prototype.type;
 /** @type {string} */
IMessage.prototype.utf8Data;
 /** @type {?} */
IMessage.prototype.binaryData;
/**
 * @record
 * @struct
 */
function IBufferList() {}
 /** @type {string} */
IBufferList.prototype.encoding;
 /** @type {number} */
IBufferList.prototype.length;

/**
 * @param {?} buf
 * @return {boolean}
 */
IBufferList.prototype.write = function(buf) {};

/**
 * @param {?} buf
 * @return {void}
 */
IBufferList.prototype.end = function(buf) {};

/**
 * For each buffer, perform some action.
 * If fn's result is a true value, cut out early.
 * @param {?} fn
 * @return {void}
 */
IBufferList.prototype.forEach = function(fn) {};

/**
 * Create a single buffer out of all the chunks
 * @param {number} start
 * @param {number} end
 * @return {?}
 */
IBufferList.prototype.join = function(start, end) {};

/**
 * Join all the chunks to existing buffer
 * @param {?} buf
 * @param {number} offset
 * @param {number} start
 * @param {number} end
 * @return {?}
 */
IBufferList.prototype.joinInto = function(buf, offset, start, end) {};

/**
 * Advance the buffer stream by `n` bytes.
 * If `n` the aggregate advance offset passes the end of the buffer list,
 * operations such as `take` will return empty strings until enough data is pushed.
 * @param {number} n
 * @return {?}
 */
IBufferList.prototype.advance = function(n) {};

/**
 * Take `n` bytes from the start of the buffers.
 * If there are less than `n` bytes in all the buffers or `n` is undefined,
 * returns the entire concatenated buffer string.
 * @param {number|string=} n_or_encoding
 * @param {string=} encoding
 * @return {?}
 */
IBufferList.prototype.take = function(n_or_encoding, encoding) {};

/**
 * @param {string} event
 * @param {?} listener_or_cb
 * @return {?}
 */
IBufferList.prototype.on = function(event, listener_or_cb) {};

/**
 * @param {string} event
 * @param {?} listener_or_cb
 * @return {?}
 */
IBufferList.prototype.addListener = function(event, listener_or_cb) {};

/**
 * @constructor
 * @struct
 * @param {?} socket
 * @param {!Array<?>} extensions
 * @param {string} protocol
 * @param {boolean} maskOutgoingPackets
 * @param {?} config
 */
function connection(socket, extensions, protocol, maskOutgoingPackets, config) {}
 /** @type {number} */
connection.CLOSE_REASON_NORMAL;
 /** @type {number} */
connection.CLOSE_REASON_GOING_AWAY;
 /** @type {number} */
connection.CLOSE_REASON_PROTOCOL_ERROR;
 /** @type {number} */
connection.CLOSE_REASON_UNPROCESSABLE_INPUT;
 /** @type {number} */
connection.CLOSE_REASON_RESERVED;
 /** @type {number} */
connection.CLOSE_REASON_NOT_PROVIDED;
 /** @type {number} */
connection.CLOSE_REASON_ABNORMAL;
 /** @type {number} */
connection.CLOSE_REASON_INVALID_DATA;
 /** @type {number} */
connection.CLOSE_REASON_POLICY_VIOLATION;
 /** @type {number} */
connection.CLOSE_REASON_MESSAGE_TOO_BIG;
 /** @type {number} */
connection.CLOSE_REASON_EXTENSION_REQUIRED;
 /** @type {string} */
connection.prototype.closeDescription;
 /** @type {number} */
connection.prototype.closeReasonCode;
 /** @type {string} */
connection.prototype.protocol;
 /** @type {?} */
connection.prototype.config;
 /** @type {?} */
connection.prototype.socket;
 /** @type {boolean} */
connection.prototype.maskOutgoingPackets;
 /** @type {?} */
connection.prototype.maskBytes;
 /** @type {?} */
connection.prototype.frameHeader;
 /** @type {?} */
connection.prototype.bufferList;
 /** @type {!frame} */
connection.prototype.currentFrame;
 /** @type {number} */
connection.prototype.fragmentationSize;
 /** @type {!Array<!frame>} */
connection.prototype.frameQueue;
 /** @type {string} */
connection.prototype.state;
 /** @type {boolean} */
connection.prototype.waitingForCloseResponse;
 /** @type {number} */
connection.prototype.closeTimeout;
 /** @type {number} */
connection.prototype.assembleFragments;
 /** @type {number} */
connection.prototype.maxReceivedMessageSize;
 /** @type {boolean} */
connection.prototype.outputPaused;
 /** @type {number} */
connection.prototype.bytesWaitingToFlush;
 /** @type {boolean} */
connection.prototype.socketHadError;
 /** @type {!Array<?>} */
connection.prototype.extensions;
 /** @type {string} */
connection.prototype.remoteAddress;
 /** @type {number} */
connection.prototype.webSocketVersion;
 /** @type {boolean} */
connection.prototype.connected;

/**
 * Close the connection. A close frame will be sent to the remote peer indicating
 * that we wish to close the connection, and we will then wait for up to
 * `config.closeTimeout` milliseconds for an acknowledgment from the remote peer
 * before terminating the underlying socket connection.
 * @return {void}
 */
connection.prototype.close = function() {};

/**
 * Send a close frame to the remote peer and immediately close the socket without
 * waiting for a response. This should generally be used only in error conditions.
 * @param {number=} reasonCode
 * @param {string=} description
 * @return {void}
 */
connection.prototype.drop = function(reasonCode, description) {};

/**
 * Immediately sends the specified string as a UTF-8 WebSocket message to the remote
 * peer. If `config.fragmentOutgoingMessages` is true the message may be sent as
 * multiple fragments if it exceeds `config.fragmentationThreshold` bytes.
 * @param {?} data
 * @return {void}
 */
connection.prototype.sendUTF = function(data) {};

/**
 * Immediately sends the specified Node Buffer object as a Binary WebSocket message
 * to the remote peer. If config.fragmentOutgoingMessages is true the message may be
 * sent as multiple fragments if it exceeds config.fragmentationThreshold bytes.
 * @param {?} buffer
 * @return {void}
 */
connection.prototype.sendBytes = function(buffer) {};

/**
 * Auto-detect the data type and send UTF-8 or Binary message
 * @param {?} data
 * @return {void}
 */
connection.prototype.send = function(data) {};

/**
 * Sends a ping frame. Ping frames must not exceed 125 bytes in length.
 * @param {?} data
 * @return {void}
 */
connection.prototype.ping = function(data) {};

/**
 * Sends a pong frame. Pong frames may be sent unsolicited and such pong frames will
 * trigger no action on the receiving peer. Pong frames sent in response to a ping
 * frame must mirror the payload data of the ping frame exactly.
 * The `connection` object handles this internally for you, so there should
 * be no need to use this method to respond to pings.
 * Pong frames must not exceed 125 bytes in length.
 * @param {?} buffer
 * @return {void}
 */
connection.prototype.pong = function(buffer) {};

/**
 * Serializes a `frame` object into binary data and immediately sends it to
 * the remote peer. This is an advanced function, requiring you to manually compose
 * your own `frame`. You should probably use sendUTF or sendBytes instead.
 * @param {!frame} frame
 * @param {boolean|function(string): void=} force_or_cb
 * @param {function(string): void=} cb
 * @return {void}
 */
connection.prototype.sendFrame = function(frame, force_or_cb, cb) {};

/**
 * Set or reset the `keepalive` timer when data is received
 * @return {void}
 */
connection.prototype.setKeepaliveTimer = function() {};

/**
 * @return {void}
 */
connection.prototype.setGracePeriodTimer = function() {};

/**
 * @return {void}
 */
connection.prototype.setCloseTimer = function() {};

/**
 * @return {void}
 */
connection.prototype.clearCloseTimer = function() {};

/**
 * @param {!frame} frame
 * @return {void}
 */
connection.prototype.processFrame = function(frame) {};

/**
 * @param {!frame} frame
 * @param {function(!Error): void=} cb
 * @return {void}
 */
connection.prototype.fragmentAndSend = function(frame, cb) {};

/**
 * @param {number=} reasonCode
 * @param {string=} reasonText
 * @param {boolean=} force
 * @return {void}
 */
connection.prototype.sendCloseFrame = function(reasonCode, reasonText, force) {};

/**
 * @param {string} event
 * @param {function(): void|function(?): void|function(!frame): void|function(number, string): void|function(!Error): void} listener_or_cb
 * @return {connection}
 */
connection.prototype.on = function(event, listener_or_cb) {};

/**
 * @param {string} event
 * @param {function(): void|function(?): void|function(!frame): void|function(number, string): void|function(!Error): void} listener_or_cb
 * @return {connection}
 */
connection.prototype.addListener = function(event, listener_or_cb) {};
/**
 * @constructor
 * @struct
 */
function frame() {}
 /** @type {boolean} */
frame.prototype.fin;
 /** @type {boolean} */
frame.prototype.rsv1;
 /** @type {boolean} */
frame.prototype.rsv2;
 /** @type {boolean} */
frame.prototype.rsv3;
 /** @type {number} */
frame.prototype.mask;
 /** @type {number} */
frame.prototype.opcode;
 /** @type {number} */
frame.prototype.length;
 /** @type {?} */
frame.prototype.binaryPayload;
 /** @type {?} */
frame.prototype.maskBytes;
 /** @type {?} */
frame.prototype.frameHeader;
 /** @type {?} */
frame.prototype.config;
 /** @type {number} */
frame.prototype.maxReceivedFrameSize;
 /** @type {boolean} */
frame.prototype.protocolError;
 /** @type {boolean} */
frame.prototype.frameTooLarge;
 /** @type {boolean} */
frame.prototype.invalidCloseFrameLength;
 /** @type {number} */
frame.prototype.closeStatus;

/**
 * @param {?} bufferList
 * @return {boolean}
 */
frame.prototype.addData = function(bufferList) {};

/**
 * @param {?} bufferList
 * @return {boolean}
 */
frame.prototype.throwAwayPayload = function(bufferList) {};

/**
 * @param {boolean} nullMask
 * @return {?}
 */
frame.prototype.toBuffer = function(nullMask) {};
/**
 * @extends {IConfig}
 * @record
 * @struct
 */
function IClientConfig() {}
 /** @type {number} */
IClientConfig.prototype.webSocketVersion;
 /** @type {number} */
IClientConfig.prototype.maxReceivedFrameSize;
 /** @type {number} */
IClientConfig.prototype.maxReceivedMessageSize;
 /** @type {!RequestOptions} */
IClientConfig.prototype.tlsOptions;

/**
 * @constructor
 * @struct
 * @param {?=} clientConfig
 */
function client(clientConfig) {}
 /** @type {!Array<string>} */
client.prototype.protocols;
 /** @type {string} */
client.prototype.origin;
 /** @type {!Url} */
client.prototype.url;
 /** @type {boolean} */
client.prototype.secure;
 /** @type {?} */
client.prototype.socket;
 /** @type {!IncomingMessage} */
client.prototype.response;

/**
 * Establish a connection. The remote server will select the best subprotocol that
 * it supports and send that back when establishing the connection.
 * 
 * @param {!Url|string} requestUrl should be a standard websocket url
 * @param {!Array<string>|string=} protocols
 * @param {string=} origin
 * @param {!Array<?>=} headers
 * @return {void}
 */
client.prototype.connect = function(requestUrl, protocols, origin, headers) {};

/**
 * @param {string} event
 * @param {function(): void|function(!connection): void|function(!Error): void} listener_or_cb
 * @return {client}
 */
client.prototype.on = function(event, listener_or_cb) {};

/**
 * @param {string} event
 * @param {function(): void|function(!connection): void|function(!Error): void} listener_or_cb
 * @return {client}
 */
client.prototype.addListener = function(event, listener_or_cb) {};

/**
 * @constructor
 * @struct
 * @param {!request} webSocketRequest
 * @param {string} resolvedProtocol
 */
function routerRequest(webSocketRequest, resolvedProtocol) {}
 /** @type {!IncomingMessage} */
routerRequest.prototype.httpRequest;
 /** @type {string} */
routerRequest.prototype.resource;
 /** @type {!Url} */
routerRequest.prototype.resourceURL;
 /** @type {string} */
routerRequest.prototype.remoteAddress;
 /** @type {string} */
routerRequest.prototype.origin;
 /** @type {number} */
routerRequest.prototype.webSocketVersion;
 /** @type {!Array<?>} */
routerRequest.prototype.requestedExtensions;
 /** @type {!Array<?>} */
routerRequest.prototype.cookies;

/**
 * After inspecting the `request` properties, call this function on the
 * request object to accept the connection. If you don't have a particular subprotocol
 * you wish to speak, you may pass `null` for the `acceptedProtocol` parameter.
 * 
 * @param {string=} acceptedProtocol
 * @param {string=} allowedOrigin
 * @param {!Array<?>=} cookies
 * @return {!connection}
 */
routerRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {};

/**
 * Reject connection.
 * You may optionally pass in an HTTP Status code (such as 404) and a textual
 * description that will be sent to the client in the form of an
 * `X-WebSocket-Reject-Reason` header.
 * @param {number=} httpStatus
 * @param {string=} reason
 * @return {void}
 */
routerRequest.prototype.reject = function(httpStatus, reason) {};

/**
 * @param {string} event
 * @param {function(): void|function(!connection): void} listener_or_cb
 * @return {routerRequest}
 */
routerRequest.prototype.on = function(event, listener_or_cb) {};

/**
 * @param {string} event
 * @param {function(): void|function(!connection): void} listener_or_cb
 * @return {routerRequest}
 */
routerRequest.prototype.addListener = function(event, listener_or_cb) {};
/**
 * @record
 * @struct
 */
function IRouterConfig() {}
 /** @type {!server} */
IRouterConfig.prototype.server;

/**
 * @constructor
 * @struct
 * @param {?=} config
 */
function router(config) {}

/**
 * Attach to WebSocket server
 * @param {!server} server
 * @return {void}
 */
router.prototype.attachServer = function(server) {};

/**
 * Detach from WebSocket server
 * @return {void}
 */
router.prototype.detachServer = function() {};

/**
 * @param {string|!RegExp} path
 * @param {function(!routerRequest): void|string} cb_or_protocol
 * @param {function(!routerRequest): void=} cb
 * @return {void}
 */
router.prototype.mount = function(path, cb_or_protocol, cb) {};

/**
 * @param {string|!RegExp} path
 * @param {string=} protocol
 * @return {void}
 */
router.prototype.unmount = function(path, protocol) {};
 /** @type {string} */
var version;
 /** @type {{DEBUG: boolean}} */
var constants;
