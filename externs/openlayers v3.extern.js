/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/openlayers v3/index.d.ts:

/** @typedef {!Object} */
var GlobalObject;
/** @const */
var ol = {};
/** @const */
ol.animation = {};

/**
 * Generate an animated transition that will "bounce" the resolution as it
 * approaches the final value.
 * \@api
 * @param {!olx.animation.BounceOptions} options
 * @return {function(!ol.Map, !olx.FrameState): boolean}
 */
ol.animation.bounce = function(options) {};

/**
 * Generate an animated transition while updating the view center.
 * \@api
 * @param {!olx.animation.PanOptions} options
 * @return {function(!ol.Map, !olx.FrameState): boolean}
 */
ol.animation.pan = function(options) {};

/**
 * Generate an animated transition while updating the view rotation.
 * \@api
 * @param {!olx.animation.RotateOptions} options
 * @return {function(!ol.Map, !olx.FrameState): boolean}
 */
ol.animation.rotate = function(options) {};

/**
 * Generate an animated transition while updating the view resolution.
 * \@api
 * @param {!olx.animation.ZoomOptions} options
 * @return {function(!ol.Map, !olx.FrameState): boolean}
 */
ol.animation.zoom = function(options) {};

/**
 * @constructor
 * @struct
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * @see {\@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}
 * @param {number} code
 */
ol.AssertionError = function(code) {};
 /** @type {number} */
ol.AssertionError.prototype.code;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * An attribution for a layer source.
 * 
 * Example:
 * 
 *     source: new ol.source.OSM({
 *       attributions: [
 *         new ol.Attribution({
 *           html: 'All maps &copy; ' +
 *               '<a href="http://www.opencyclemap.org/">OpenCycleMap</a>'
 *         }),
 *         ol.source.OSM.ATTRIBUTION
 *       ],
 *     ..
 * 
 * @struct
 * \@api stable
 * @param {!olx.AttributionOptions} options
 */
ol.Attribution = function(options) {};

/**
 * Get the attribution markup.
 * \@api stable
 * @return {string}
 */
ol.Attribution.prototype.getHTML = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 * 
 * \@fires ol.Collection.Event
 * \@api stable
 * @param {!Array<T>=} opt_array
 */
ol.Collection = function(opt_array) {};

/**
 * Remove all elements from the collection.
 * \@api stable
 * @return {void}
 */
ol.Collection.prototype.clear = function() {};

/**
 * Add elements to the collection.  This pushes each item in the provided array
 * to the end of the collection.
 * \@api stable
 * @param {!Array<T>} arr
 * @return {!ol.Collection}
 */
ol.Collection.prototype.extend = function(arr) {};

/**
 * Iterate over each element, calling the provided callback.
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array). The return value is ignored.
 * \@api stable
 * @template S
 * @param {function(T, number, !Array<T>): ?} f
 * @param {S=} opt_this
 * @return {void}
 */
ol.Collection.prototype.forEach = function(f, opt_this) {};

/**
 * Get a reference to the underlying Array object. Warning: if the array
 * is mutated, no events will be dispatched by the collection, and the
 * collection's "length" property won't be in sync with the actual length
 * of the array.
 * \@api stable
 * @return {!Array<T>}
 */
ol.Collection.prototype.getArray = function() {};

/**
 * Get the element at the provided index.
 * \@api stable
 * @param {number} index
 * @return {T}
 */
ol.Collection.prototype.item = function(index) {};

/**
 * Get the length of this collection.
 * \@observable
 * \@api stable
 * @return {number}
 */
ol.Collection.prototype.getLength = function() {};

/**
 * Insert an element at the provided index.
 * \@api stable
 * @param {number} index
 * @param {T} elem
 * @return {void}
 */
ol.Collection.prototype.insertAt = function(index, elem) {};

/**
 * Remove the last element of the collection and return it.
 * Return `undefined` if the collection is empty.
 * \@api stable
 * @return {T}
 */
ol.Collection.prototype.pop = function() {};

/**
 * Insert the provided element at the end of the collection.
 * \@api stable
 * @param {T} elem
 * @return {number}
 */
ol.Collection.prototype.push = function(elem) {};

/**
 * Remove the first occurrence of an element from the collection.
 * \@api stable
 * @param {T} elem
 * @return {T}
 */
ol.Collection.prototype.remove = function(elem) {};

/**
 * Remove the element at the provided index and return it.
 * Return `undefined` if the collection does not contain this index.
 * \@api stable
 * @param {number} index
 * @return {T}
 */
ol.Collection.prototype.removeAt = function(index) {};

/**
 * Set the element at the provided index.
 * \@api stable
 * @param {number} index
 * @param {T} elem
 * @return {void}
 */
ol.Collection.prototype.setAt = function(index, elem) {};

/** @typedef {string} */
ol.Collection.EventType;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Events emitted by {\@link ol.Collection} instances are instances of this
 * type.
 * 
 * @param {string} type
 * @param {?=} opt_element
 */
ol.Collection.Event = function(type, opt_element) {};
 /** @type {?} */
ol.Collection.Event.prototype.element;
/** @const */
ol.color = {};

/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * \@api
 * @param {(string|!Array<?>|!Uint8Array|!Uint8ClampedArray)} color
 * @return {(!Array<?>|!Uint8Array|!Uint8ClampedArray)}
 */
ol.color.asArray = function(color) {};

/**
 * Return the color as an rgba string.
 * \@api
 * @param {(string|!Array<?>|!Uint8Array|!Uint8ClampedArray)} color
 * @return {string}
 */
ol.color.asString = function(color) {};
/** @const */
ol.colorlike = {};

/**
 * \@api
 * @param {(string|!Array<?>|!Uint8Array|!Uint8ClampedArray|!CanvasPattern|!CanvasGradient)} color
 * @return {(string|!CanvasPattern|!CanvasGradient)}
 */
ol.colorlike.asColorLike = function(color) {};
/** @const */
ol.control = {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 * 
 * \@api stable
 * @param {!olx.control.AttributionOptions=} opt_options
 */
ol.control.Attribution = function(opt_options) {};

/**
 * Update the attribution element.
 * \@api
 * @param {!ol.MapEvent} mapEvent
 * @return {void}
 */
ol.control.Attribution.render = function(mapEvent) {};

/**
 * Return `true` if the attribution is collapsible, `false` otherwise.
 * \@api stable
 * @return {boolean}
 */
ol.control.Attribution.prototype.getCollapsible = function() {};

/**
 * Set whether the attribution should be collapsible.
 * \@api stable
 * @param {boolean} collapsible
 * @return {void}
 */
ol.control.Attribution.prototype.setCollapsible = function(collapsible) {};

/**
 * Collapse or expand the attribution according to the passed parameter. Will
 * not do anything if the attribution isn't collapsible or if the current
 * collapsed state is already the one requested.
 * \@api stable
 * @param {boolean} collapsed
 * @return {void}
 */
ol.control.Attribution.prototype.setCollapsed = function(collapsed) {};

/**
 * Return `true` when the attribution is currently collapsed or `false`
 * otherwise.
 * \@api stable
 * @return {boolean}
 */
ol.control.Attribution.prototype.getCollapsed = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 * 
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * var myControl = new ol.control.Control({element: myElement});
 * ```
 * and then adding this to the map.
 * 
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be `ol.Object`s in a `ol.Collection`, so you can use their
 * methods.
 * 
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 * 
 * \@api stable
 * @param {!olx.control.ControlOptions} options
 */
ol.control.Control = function(options) {};

/**
 * Get the map associated with this control.
 * \@api stable
 * @return {!ol.Map}
 */
ol.control.Control.prototype.getMap = function() {};

/**
 * Remove the control from its current map and attach it to the new map.
 * Subclasses may set up event handlers to get notified about changes to
 * the map here.
 * \@api stable
 * @param {!ol.Map} map
 * @return {void}
 */
ol.control.Control.prototype.setMap = function(map) {};

/**
 * This function is used to set a target element for the control. It has no
 * effect if it is called after the control has been added to the map (i.e.
 * after `setMap` is called on the control). If no `target` is set in the
 * options passed to the control constructor and if `setTarget` is not called
 * then the control is added to the map's overlay container.
 * \@api
 * @param {(string|!Element)} target
 * @return {void}
 */
ol.control.Control.prototype.setTarget = function(target) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Provides a button that when clicked fills up the full screen with the map.
 * The full screen source element is by default the element containing the map viewport unless
 * overriden by providing the `source` option. In which case, the dom
 * element introduced using this parameter will be displayed in full screen.
 * 
 * When in full screen mode, a close button is shown to exit full screen mode.
 * The [Fullscreen API](http://www.w3.org/TR/fullscreen/) is used to
 * toggle the map in full screen mode.
 * 
 * 
 * \@api stable
 * @param {!olx.control.FullScreenOptions=} opt_options
 */
ol.control.FullScreen = function(opt_options) {};

/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {\@link ol.control.Zoom}
 * * {\@link ol.control.Rotate}
 * * {\@link ol.control.Attribution}
 * 
 * \@api stable
 * @param {!olx.control.DefaultsOptions=} opt_options
 * @return {!ol.Collection<!ol.control.Control>}
 */
ol.control.defaults = function(opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A control to show the 2D coordinates of the mouse cursor. By default, these
 * are in the view projection, but can be in any supported projection.
 * By default the control is shown in the top right corner of the map, but this
 * can be changed by using the css selector `.ol-mouse-position`.
 * 
 *     options.
 * \@api stable
 * @param {!olx.control.MousePositionOptions=} opt_options
 */
ol.control.MousePosition = function(opt_options) {};

/**
 * Update the mouseposition element.
 * \@api
 * @param {!ol.MapEvent} mapEvent
 * @return {void}
 */
ol.control.MousePosition.render = function(mapEvent) {};

/**
 * Return the coordinate format type used to render the current position or
 * undefined.
 *     position in.
 * \@observable
 * \@api stable
 * @return {function(!Array<?>): string}
 */
ol.control.MousePosition.prototype.getCoordinateFormat = function() {};

/**
 * Return the projection that is used to report the mouse position.
 *     position in.
 * \@observable
 * \@api stable
 * @return {!ol.proj.Projection}
 */
ol.control.MousePosition.prototype.getProjection = function() {};

/**
 * Set the coordinate format type used to render the current position.
 *     position in.
 * \@observable
 * \@api stable
 * @param {function(!Array<?>): string} format
 * @return {void}
 */
ol.control.MousePosition.prototype.setCoordinateFormat = function(format) {};

/**
 * Set the projection that is used to report the mouse position.
 *     position in.
 * \@observable
 * \@api stable
 * @param {!ol.proj.Projection} projection
 * @return {void}
 */
ol.control.MousePosition.prototype.setProjection = function(projection) {};

/**
 * @constructor
 * @struct
 * Create a new control with a map acting as an overview map for an other
 * defined map.
 * \@api
 * @param {!olx.control.OverviewMapOptions=} opt_options
 */
ol.control.OverviewMap = function(opt_options) {};

/**
 * Update the overview map element.
 * \@api
 * @param {!ol.MapEvent} mapEvent
 * @return {void}
 */
ol.control.OverviewMap.render = function(mapEvent) {};

/**
 * Return `true` if the overview map is collapsible, `false` otherwise.
 * \@api stable
 * @return {boolean}
 */
ol.control.OverviewMap.prototype.getCollapsible = function() {};

/**
 * Set whether the overview map should be collapsible.
 * \@api stable
 * @param {boolean} collapsible
 * @return {void}
 */
ol.control.OverviewMap.prototype.setCollapsible = function(collapsible) {};

/**
 * Collapse or expand the overview map according to the passed parameter. Will
 * not do anything if the overview map isn't collapsible or if the current
 * collapsed state is already the one requested.
 * \@api stable
 * @param {boolean} collapsed
 * @return {void}
 */
ol.control.OverviewMap.prototype.setCollapsed = function(collapsed) {};

/**
 * Determine if the overview map is collapsed.
 * \@api stable
 * @return {boolean}
 */
ol.control.OverviewMap.prototype.getCollapsed = function() {};

/**
 * Return the overview map.
 * \@api
 * @return {!ol.Map}
 */
ol.control.OverviewMap.prototype.getOverviewMap = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 * 
 * \@api stable
 * @param {!olx.control.RotateOptions=} opt_options
 */
ol.control.Rotate = function(opt_options) {};

/**
 * Update the rotate control element.
 * \@api
 * @param {!ol.MapEvent} mapEvent
 * @return {void}
 */
ol.control.Rotate.render = function(mapEvent) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A control displaying rough y-axis distances, calculated for the center of the
 * viewport. For conformal projections (e.g. EPSG:3857, the default view
 * projection in OpenLayers), the scale is valid for all directions.
 * No scale line will be shown when the y-axis distance of a pixel at the
 * viewport center cannot be calculated in the view projection.
 * By default the scale line will show in the bottom left portion of the map,
 * but this can be changed by using the css selector `.ol-scale-line`.
 * 
 * \@api stable
 * @param {!olx.control.ScaleLineOptions=} opt_options
 */
ol.control.ScaleLine = function(opt_options) {};

/**
 * Return the units to use in the scale line.
 *     line.
 * \@observable
 * \@api stable
 * @return {string}
 */
ol.control.ScaleLine.prototype.getUnits = function() {};

/**
 * Update the scale line element.
 * \@api
 * @param {!ol.MapEvent} mapEvent
 * @return {void}
 */
ol.control.ScaleLine.render = function(mapEvent) {};

/**
 * Set the units to use in the scale line.
 * \@observable
 * \@api stable
 * @param {string} units
 * @return {void}
 */
ol.control.ScaleLine.prototype.setUnits = function(units) {};

/** @typedef {string} */
ol.control.ScaleLine.Property;

/** @typedef {string} */
ol.control.ScaleLine.Units;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 * 
 * \@api stable
 * @param {!olx.control.ZoomOptions=} opt_options
 */
ol.control.Zoom = function(opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A slider type of control for zooming.
 * 
 * Example:
 * 
 *     map.addControl(new ol.control.ZoomSlider());
 * 
 * \@api stable
 * @param {!olx.control.ZoomSliderOptions=} opt_options
 */
ol.control.ZoomSlider = function(opt_options) {};

/**
 * Update the zoomslider element.
 * \@api
 * @param {!ol.MapEvent} mapEvent
 * @return {void}
 */
ol.control.ZoomSlider.render = function(mapEvent) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A button control which, when pressed, changes the map view to a specific
 * extent. To style this control use the css selector `.ol-zoom-extent`.
 * 
 * \@api stable
 * @param {!olx.control.ZoomToExtentOptions=} opt_options
 */
ol.control.ZoomToExtent = function(opt_options) {};
/** @const */
ol.coordinate = {};

/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 * 
 * Example:
 * 
 *     var coord = [7.85, 47.983333];
 *     ol.coordinate.add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 * 
 * \@api stable
 * @param {!Array<?>} coordinate
 * @param {!Array<?>} delta
 * @return {!Array<?>}
 */
ol.coordinate.add = function(coordinate, delta) {};

/**
 * Returns a {\@link ol.CoordinateFormatType} function that can be used to format
 * a {ol.Coordinate} to a string.
 * 
 * Example without specifying the fractional digits:
 * 
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = ol.coordinate.createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 * 
 * Example with explicitly specifying 2 fractional digits:
 * 
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = ol.coordinate.createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 * 
 *    after the decimal point. Default is `0`.
 * \@api stable
 * @param {number=} opt_fractionDigits
 * @return {function(!Array<?>): string}
 */
ol.coordinate.createStringXY = function(opt_fractionDigits) {};

/**
 * Transforms the given {\@link ol.Coordinate} to a string using the given string
 * template. The strings `{x}` and `{y}` in the template will be replaced with
 * the first and second coordinate values respectively.
 * 
 * Example without specifying the fractional digits:
 * 
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = ol.coordinate.format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 * 
 * Example explicitly specifying the fractional digits:
 * 
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = ol.coordinate.format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 * 
 *     that will be replaced by first and second coordinate values.
 *    after the decimal point. Default is `0`.
 * \@api stable
 * @param {!Array<?>} coordinate
 * @param {string} template
 * @param {number=} opt_fractionDigits
 * @return {string}
 */
ol.coordinate.format = function(coordinate, template, opt_fractionDigits) {};

/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 * 
 * Example:
 * 
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     ol.coordinate.rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 * 
 * \@api stable
 * @param {!Array<?>} coordinate
 * @param {number} angle
 * @return {!Array<?>}
 */
ol.coordinate.rotate = function(coordinate, angle) {};

/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 * 
 * Example without specifying fractional digits:
 * 
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 * 
 * Example explicitly specifying 1 fractional digit:
 * 
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 * 
 *    after the decimal point. Default is `0`.
 * \@api stable
 * @param {!Array<?>=} coordinate
 * @param {number=} opt_fractionDigits
 * @return {string}
 */
ol.coordinate.toStringHDMS = function(coordinate, opt_fractionDigits) {};

/**
 * Format a coordinate as a comma delimited string.
 * 
 * Example without specifying fractional digits:
 * 
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringXY(coord);
 *     // out is now '8, 48'
 * 
 * Example explicitly specifying 1 fractional digit:
 * 
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 * 
 *    after the decimal point. Default is `0`.
 * \@api stable
 * @param {!Array<?>=} coordinate
 * @param {number=} opt_fractionDigits
 * @return {string}
 */
ol.coordinate.toStringXY = function(coordinate, opt_fractionDigits) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * The ol.DeviceOrientation class provides access to information from
 * DeviceOrientation events.  See the [HTML 5 DeviceOrientation Specification](
 * http://www.w3.org/TR/orientation-event/) for more details.
 * 
 * Many new computers, and especially mobile phones
 * and tablets, provide hardware support for device orientation. Web
 * developers targeting mobile devices will be especially interested in this
 * class.
 * 
 * Device orientation data are relative to a common starting point. For mobile
 * devices, the starting point is to lay your phone face up on a table with the
 * top of the phone pointing north. This represents the zero state. All
 * angles are then relative to this state. For computers, it is the same except
 * the screen is open at 90 degrees.
 * 
 * Device orientation is reported as three angles - `alpha`, `beta`, and
 * `gamma` - relative to the starting position along the three planar axes X, Y
 * and Z. The X axis runs from the left edge to the right edge through the
 * middle of the device. Similarly, the Y axis runs from the bottom to the top
 * of the device through the middle. The Z axis runs from the back to the front
 * through the middle. In the starting position, the X axis points to the
 * right, the Y axis points away from you and the Z axis points straight up
 * from the device lying flat.
 * 
 * The three angles representing the device orientation are relative to the
 * three axes. `alpha` indicates how much the device has been rotated around the
 * Z axis, which is commonly interpreted as the compass heading (see note
 * below). `beta` indicates how much the device has been rotated around the X
 * axis, or how much it is tilted from front to back.  `gamma` indicates how
 * much the device has been rotated around the Y axis, or how much it is tilted
 * from left to right.
 * 
 * For most browsers, the `alpha` value returns the compass heading so if the
 * device points north, it will be 0.  With Safari on iOS, the 0 value of
 * `alpha` is calculated from when device orientation was first requested.
 * ol.DeviceOrientation provides the `heading` property which normalizes this
 * behavior across all browsers for you.
 * 
 * It is important to note that the HTML 5 DeviceOrientation specification
 * indicates that `alpha`, `beta` and `gamma` are in degrees while the
 * equivalent properties in ol.DeviceOrientation are in radians for consistency
 * with all other uses of angles throughout OpenLayers.
 * 
 * To get notified of device orientation changes, register a listener for the
 * generic `change` event on your `ol.DeviceOrientation` instance.
 * 
 * @see {\@link http://www.w3.org/TR/orientation-event/}
 * 
 * \@api
 * @param {!olx.DeviceOrientationOptions=} opt_options
 */
ol.DeviceOrientation = function(opt_options) {};

/**
 * Rotation around the device z-axis (in radians).
 *     standard Z axis.
 * \@observable
 * \@api
 * @return {number}
 */
ol.DeviceOrientation.prototype.getAlpha = function() {};

/**
 * Rotation around the device x-axis (in radians).
 *     planar X axis.
 * \@observable
 * \@api
 * @return {number}
 */
ol.DeviceOrientation.prototype.getBeta = function() {};

/**
 * Rotation around the device y-axis (in radians).
 *     planar Y axis.
 * \@observable
 * \@api
 * @return {number}
 */
ol.DeviceOrientation.prototype.getGamma = function() {};

/**
 * The heading of the device relative to north (in radians).
 *     radians, normalizing for different browser behavior.
 * \@observable
 * \@api
 * @return {number}
 */
ol.DeviceOrientation.prototype.getHeading = function() {};

/**
 * Determine if orientation is being tracked.
 * \@observable
 * \@api
 * @return {boolean}
 */
ol.DeviceOrientation.prototype.getTracking = function() {};

/**
 * Enable or disable tracking of device orientation events.
 *     gamma. If true, changes are tracked and reported immediately.
 * \@observable
 * \@api
 * @param {boolean} tracking
 * @return {void}
 */
ol.DeviceOrientation.prototype.setTracking = function(tracking) {};

/**
 * @constructor
 * @struct
 * Objects that need to clean up after themselves.
 */
ol.Disposable = function() {};
/** @const */
ol.easing = {};

/**
 * Start slow and speed up.
 * \@api
 * @param {number} t
 * @return {number}
 */
ol.easing.easeIn = function(t) {};

/**
 * Start fast and slow down.
 * \@api
 * @param {number} t
 * @return {number}
 */
ol.easing.easeOut = function(t) {};

/**
 * Start slow, speed up, and then slow down again.
 * \@api
 * @param {number} t
 * @return {number}
 */
ol.easing.inAndOut = function(t) {};

/**
 * Maintain a constant speed over time.
 * \@api
 * @param {number} t
 * @return {number}
 */
ol.easing.linear = function(t) {};

/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {\@link ol.easing.inAndOut}, but the final slowdown
 * is delayed.
 * \@api
 * @param {number} t
 * @return {number}
 */
ol.easing.upAndDown = function(t) {};
/** @const */
ol.events = {};
/** @const */
ol.events.condition = {};

/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 * 
 * \@api stable
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.events.condition.altKeyOnly = function(mapBrowserEvent) {};

/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 * 
 * \@api stable
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.events.condition.altShiftKeysOnly = function(mapBrowserEvent) {};

/**
 * Return always true.
 * 
 * \@api stable
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.events.condition.always = function(mapBrowserEvent) {};

/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 * 
 * \@api stable
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.events.condition.click = function(mapBrowserEvent) {};

/**
 * Return always false.
 * 
 * \@api stable
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.events.condition.never = function(mapBrowserEvent) {};

/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 * 
 * \@api
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.events.condition.pointerMove = function(mapBrowserEvent) {};

/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 * 
 * \@api stable
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.events.condition.singleClick = function(mapBrowserEvent) {};

/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 * 
 * \@api stable
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.events.condition.doubleClick = function(mapBrowserEvent) {};

/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 * 
 * \@api stable
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.events.condition.noModifierKeys = function(mapBrowserEvent) {};

/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 * 
 * \@api stable
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.events.condition.platformModifierKeyOnly = function(mapBrowserEvent) {};

/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 * 
 * \@api stable
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.events.condition.shiftKeyOnly = function(mapBrowserEvent) {};

/**
 * Return `true` if the target element is not editable, i.e. not a `<input>`-,
 * `<select>`- or `<textarea>`-element, `false` otherwise.
 * 
 * \@api
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.events.condition.targetNotEditable = function(mapBrowserEvent) {};

/**
 * Return `true` if the event originates from a mouse device.
 * 
 * \@api stable
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.events.condition.mouseOnly = function(mapBrowserEvent) {};

/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * @see http://www.w3.org/TR/pointerevents/#button-states
 * 
 * \@api
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.events.condition.primaryAction = function(mapBrowserEvent) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * @see {\@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface}
 * 
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {\@link ol.events.EventTarget}.
 * 
 * @param {string} type
 */
ol.events.Event = function(type) {};
 /** @type {string} */
ol.events.Event.prototype.type;
 /** @type {!Object} */
ol.events.Event.prototype.target;

/**
 * Stop event propagation.
 * \@api stable
 * @return {void}
 */
ol.events.Event.prototype.preventDefault = function() {};

/**
 * Stop event propagation.
 * \@api stable
 * @return {void}
 */
ol.events.Event.prototype.stopPropagation = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * @see {\@link https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}
 * 
 * There are two important simplifications compared to the specification:
 * 
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 * 
 */
ol.events.EventTarget = function() {};
/** @const */
ol.extent = {};

/**
 * Build an extent that includes all given coordinates.
 * 
 * \@api stable
 * @param {!Array<!Array<?>>} coordinates
 * @return {!Array<?>}
 */
ol.extent.boundingExtent = function(coordinates) {};

/**
 * Return extent increased by the provided value.
 * \@api stable
 * @param {!Array<?>} extent
 * @param {number} value
 * @param {!Array<?>=} opt_extent
 * @return {!Array<?>}
 */
ol.extent.buffer = function(extent, value, opt_extent) {};

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 * 
 * \@api stable
 * @param {!Array<?>} extent
 * @param {!Array<?>} coordinate
 * @return {boolean}
 */
ol.extent.containsCoordinate = function(extent, coordinate) {};

/**
 * Check if one extent contains another.
 * 
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 * 
 *     first.
 * \@api stable
 * @param {!Array<?>} extent1
 * @param {!Array<?>} extent2
 * @return {boolean}
 */
ol.extent.containsExtent = function(extent1, extent2) {};

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 * 
 * \@api stable
 * @param {!Array<?>} extent
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
ol.extent.containsXY = function(extent, x, y) {};

/**
 * Create an empty extent.
 * \@api stable
 * @return {!Array<?>}
 */
ol.extent.createEmpty = function() {};

/**
 * Determine if two extents are equivalent.
 * \@api stable
 * @param {!Array<?>} extent1
 * @param {!Array<?>} extent2
 * @return {boolean}
 */
ol.extent.equals = function(extent1, extent2) {};

/**
 * Modify an extent to include another extent.
 * \@api stable
 * @param {!Array<?>} extent1
 * @param {!Array<?>} extent2
 * @return {!Array<?>}
 */
ol.extent.extend = function(extent1, extent2) {};

/**
 * Get the bottom left coordinate of an extent.
 * \@api stable
 * @param {!Array<?>} extent
 * @return {!Array<?>}
 */
ol.extent.getBottomLeft = function(extent) {};

/**
 * Get the bottom right coordinate of an extent.
 * \@api stable
 * @param {!Array<?>} extent
 * @return {!Array<?>}
 */
ol.extent.getBottomRight = function(extent) {};

/**
 * Get the center coordinate of an extent.
 * \@api stable
 * @param {!Array<?>} extent
 * @return {!Array<?>}
 */
ol.extent.getCenter = function(extent) {};

/**
 * Get the height of an extent.
 * \@api stable
 * @param {!Array<?>} extent
 * @return {number}
 */
ol.extent.getHeight = function(extent) {};

/**
 * Get the intersection of two extents.
 * \@api stable
 * @param {!Array<?>} extent1
 * @param {!Array<?>} extent2
 * @param {!Array<?>=} opt_extent
 * @return {!Array<?>}
 */
ol.extent.getIntersection = function(extent1, extent2, opt_extent) {};

/**
 * Get the size (width, height) of an extent.
 * \@api stable
 * @param {!Array<?>} extent
 * @return {!Array<?>}
 */
ol.extent.getSize = function(extent) {};

/**
 * Get the top left coordinate of an extent.
 * \@api stable
 * @param {!Array<?>} extent
 * @return {!Array<?>}
 */
ol.extent.getTopLeft = function(extent) {};

/**
 * Get the top right coordinate of an extent.
 * \@api stable
 * @param {!Array<?>} extent
 * @return {!Array<?>}
 */
ol.extent.getTopRight = function(extent) {};

/**
 * Get the width of an extent.
 * \@api stable
 * @param {!Array<?>} extent
 * @return {number}
 */
ol.extent.getWidth = function(extent) {};

/**
 * Determine if one extent intersects another.
 * \@api stable
 * @param {!Array<?>} extent1
 * @param {!Array<?>} extent2
 * @return {boolean}
 */
ol.extent.intersects = function(extent1, extent2) {};

/**
 * Determine if an extent is empty.
 * \@api stable
 * @param {!Array<?>} extent
 * @return {boolean}
 */
ol.extent.isEmpty = function(extent) {};

/**
 * Apply a transform function to the extent.
 * [minX, minY, maxX, maxY] extent coordinates.
 * \@api stable
 * @param {!Array<?>} extent
 * @param {function(!Array<number>, !Array<number>, number): !Array<number>} transformFn
 * @param {!Array<?>=} opt_extent
 * @return {!Array<?>}
 */
ol.extent.applyTransform = function(extent, transformFn, opt_extent) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 * 
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 * 
 * Note that attribute properties are set as {\@link ol.Object} properties on
 * the feature object, so they are observable, and have get/set accessors.
 * 
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 * 
 * ```js
 * var feature = new ol.Feature({
 *   geometry: new ol.geom.Polygon(polyCoords),
 *   labelPoint: new ol.geom.Point(labelCoords),
 *   name: 'My Polygon'
 * });
 * 
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 * 
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 * 
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 * 
 *     You may pass a Geometry object directly, or an object literal
 *     containing properties.  If you pass an object literal, you may
 *     include a Geometry associated with a `geometry` key.
 * \@api stable
 * @param {(!ol.geom.Geometry|!Object<string,?>)=} opt_geometryOrProperties
 */
ol.Feature = function(opt_geometryOrProperties) {};

/**
 * Clone this feature. If the original feature has a geometry it
 * is also cloned. The feature id is not set in the clone.
 * \@api stable
 * @return {!ol.Feature}
 */
ol.Feature.prototype.clone = function() {};

/**
 * Get the feature's default geometry.  A feature may have any number of named
 * geometries.  The "default" geometry (the one that is rendered by default) is
 * set when calling {\@link ol.Feature#setGeometry}.
 * \@api stable
 * \@observable
 * @return {!ol.geom.Geometry}
 */
ol.Feature.prototype.getGeometry = function() {};

/**
 * Get the feature identifier.  This is a stable identifier for the feature and
 * is either set when reading data from a remote source or set explicitly by
 * calling {\@link ol.Feature#setId}.
 * \@api stable
 * \@observable
 * @return {(string|number)}
 */
ol.Feature.prototype.getId = function() {};

/**
 * Get the name of the feature's default geometry.  By default, the default
 * geometry is named `geometry`.
 *     for this feature.
 * \@api stable
 * @return {string}
 */
ol.Feature.prototype.getGeometryName = function() {};

/**
 * Get the feature's style.  This return for this method depends on what was
 * provided to the {\@link ol.Feature#setStyle} method.
 *     ol.FeatureStyleFunction} The feature style.
 * \@api stable
 * \@observable
 * @return {(!ol.style.Style|!Array<!ol.style.Style>|function(number): (!ol.style.Style|!Array<!ol.style.Style>))}
 */
ol.Feature.prototype.getStyle = function() {};

/**
 * Get the feature's style function.
 * representing the current style of this feature.
 * \@api stable
 * @return {function(number): (!ol.style.Style|!Array<!ol.style.Style>)}
 */
ol.Feature.prototype.getStyleFunction = function() {};

/**
 * Set the default geometry for the feature.  This will update the property
 * with the name returned by {\@link ol.Feature#getGeometryName}.
 * \@api stable
 * \@observable
 * @param {!ol.geom.Geometry} geometry
 * @return {void}
 */
ol.Feature.prototype.setGeometry = function(geometry) {};

/**
 * Set the style for the feature.  This can be a single style object, an array
 * of styles, or a function that takes a resolution and returns an array of
 * styles. If it is `null` the feature has no style (a `null` style).
 *     ol.FeatureStyleFunction} style Style for this feature.
 * \@api stable
 * \@observable
 * @param {(!ol.style.Style|!Array<!ol.style.Style>|function(number): (!ol.style.Style|!Array<!ol.style.Style>))} style
 * @return {void}
 */
ol.Feature.prototype.setStyle = function(style) {};

/**
 * Set the feature id.  The feature id is considered stable and may be used when
 * requesting features or comparing identifiers returned from a remote source.
 * The feature id can be used with the {\@link ol.source.Vector#getFeatureById}
 * method.
 * \@api stable
 * \@observable
 * @param {(string|number)} id
 * @return {void}
 */
ol.Feature.prototype.setId = function(id) {};

/**
 * Set the property name to be used when getting the feature's default geometry.
 * When calling {\@link ol.Feature#getGeometry}, the value of the property with
 * this name will be returned.
 * \@api stable
 * @param {string} name
 * @return {void}
 */
ol.Feature.prototype.setGeometryName = function(name) {};
/** @const */
ol.featureloader = {};

/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector tile.
 * \@api
 * @param {(string|function(!Array<?>, number, !ol.proj.Projection): string)} url
 * @param {!ol.format.Feature} format
 * @return {function(!Array<?>, number, !ol.proj.Projection): void}
 */
ol.featureloader.tile = function(url, format) {};

/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * \@api
 * @param {(string|function(!Array<?>, number, !ol.proj.Projection): string)} url
 * @param {!ol.format.Feature} format
 * @return {function(!Array<?>, number, !ol.proj.Projection): void}
 */
ol.featureloader.xhr = function(url, format) {};
/** @const */
ol.format = {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Feature format for reading and writing data in the EsriJSON format.
 * 
 * \@api
 * @param {!olx.format.EsriJSONOptions=} opt_options
 */
ol.format.EsriJSON = function(opt_options) {};

/**
 * Read a feature from a EsriJSON Feature source.  Only works for Feature,
 * use `readFeatures` to read FeatureCollection source.
 * 
 * \@api
 * @param {(string|!Object|!Node|!ArrayBuffer|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!ol.Feature}
 */
ol.format.EsriJSON.prototype.readFeature = function(source, opt_options) {};

/**
 * Read all features from a EsriJSON source.  Works with both Feature and
 * FeatureCollection sources.
 * 
 * \@api
 * @param {(string|!Object|!Node|!ArrayBuffer|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!Array<!ol.Feature>}
 */
ol.format.EsriJSON.prototype.readFeatures = function(source, opt_options) {};

/**
 * Read a geometry from a EsriJSON source.
 * 
 * \@api
 * @param {(string|!Object|!Node|!ArrayBuffer|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!ol.geom.Geometry}
 */
ol.format.EsriJSON.prototype.readGeometry = function(source, opt_options) {};

/**
 * Read the projection from a EsriJSON source.
 * 
 * \@api
 * @param {(string|!Object|!Node|!ArrayBuffer|!Document)} source
 * @return {!ol.proj.Projection}
 */
ol.format.EsriJSON.prototype.readProjection = function(source) {};

/**
 * Encode a geometry as a EsriJSON string.
 * 
 * \@api
 * @param {!ol.geom.Geometry} geometry
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {string}
 */
ol.format.EsriJSON.prototype.writeGeometry = function(geometry, opt_options) {};

/**
 * Encode a geometry as a EsriJSON object.
 * 
 * \@api
 * @param {!ol.geom.Geometry} geometry
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {!JSON}
 */
ol.format.EsriJSON.prototype.writeGeometryObject = function(geometry, opt_options) {};

/**
 * Encode a feature as a EsriJSON Feature string.
 * 
 * \@api
 * @param {!ol.Feature} feature
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {string}
 */
ol.format.EsriJSON.prototype.writeFeature = function(feature, opt_options) {};

/**
 * Encode a feature as a esriJSON Feature object.
 * 
 * \@api
 * @param {!ol.Feature} feature
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {!Object}
 */
ol.format.EsriJSON.prototype.writeFeatureObject = function(feature, opt_options) {};

/**
 * Encode an array of features as EsriJSON.
 * 
 * \@api
 * @param {!Array<!ol.Feature>} features
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {string}
 */
ol.format.EsriJSON.prototype.writeFeatures = function(features, opt_options) {};

/**
 * Encode an array of features as a EsriJSON object.
 * 
 * \@api
 * @param {!Array<!ol.Feature>} features
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {!Object}
 */
ol.format.EsriJSON.prototype.writeFeaturesObject = function(features, opt_options) {};

/** @typedef {!JSON} */
ol.format.EsriJSONGeometry;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {ol.format.Feature} subclasses provide the ability to decode and encode
 * {\@link ol.Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 * 
 * \@api stable
 */
ol.format.Feature = function() {};

/** @typedef {!JSON} */
ol.format.GeoJSONFeature;

/** @typedef {!JSON} */
ol.format.GeoJSONFeatureCollection;

/** @typedef {!JSON} */
ol.format.GeoJSONGeometry;

/** @typedef {!JSON} */
ol.format.GeoJSONGeometryCollection;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Feature format for reading and writing data in the GeoJSON format.
 * 
 * \@api stable
 * @param {!olx.format.GeoJSONOptions=} opt_options
 */
ol.format.GeoJSON = function(opt_options) {};

/**
 * Read a feature from a GeoJSON Feature source.  Only works for Feature,
 * use `readFeatures` to read FeatureCollection source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!ol.Feature}
 */
ol.format.GeoJSON.prototype.readFeature = function(source, opt_options) {};

/**
 * Read all features from a GeoJSON source.  Works with both Feature and
 * FeatureCollection sources.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!Array<!ol.Feature>}
 */
ol.format.GeoJSON.prototype.readFeatures = function(source, opt_options) {};

/**
 * Read a geometry from a GeoJSON source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!ol.geom.Geometry}
 */
ol.format.GeoJSON.prototype.readGeometry = function(source, opt_options) {};

/**
 * Read the projection from a GeoJSON source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @return {!ol.proj.Projection}
 */
ol.format.GeoJSON.prototype.readProjection = function(source) {};

/**
 * Encode a feature as a GeoJSON Feature string.
 * 
 * \@api stable
 * @param {!ol.Feature} feature
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {string}
 */
ol.format.GeoJSON.prototype.writeFeature = function(feature, opt_options) {};

/**
 * Encode a feature as a GeoJSON Feature object.
 * 
 * \@api stable
 * @param {!ol.Feature} feature
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {!JSON}
 */
ol.format.GeoJSON.prototype.writeFeatureObject = function(feature, opt_options) {};

/**
 * Encode an array of features as GeoJSON.
 * 
 * \@api stable
 * @param {!Array<!ol.Feature>} features
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {string}
 */
ol.format.GeoJSON.prototype.writeFeatures = function(features, opt_options) {};

/**
 * Encode an array of features as a GeoJSON object.
 * 
 * \@api stable
 * @param {!Array<!ol.Feature>} features
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {!JSON}
 */
ol.format.GeoJSON.prototype.writeFeaturesObject = function(features, opt_options) {};

/**
 * Encode a geometry as a GeoJSON string.
 * 
 * \@api stable
 * @param {!ol.geom.Geometry} geometry
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {string}
 */
ol.format.GeoJSON.prototype.writeGeometry = function(geometry, opt_options) {};

/**
 * Encode a geometry as a GeoJSON object.
 * 
 * \@api stable
 * @param {!ol.geom.Geometry} geometry
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {!JSON}
 */
ol.format.GeoJSON.prototype.writeGeometryObject = function(geometry, opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Feature format for reading and writing data in the GML format
 * version 3.1.1.
 * Currently only supports GML 3.1.1 Simple Features profile.
 * 
 *     Optional configuration object.
 * \@api stable
 * @param {!olx.format.GMLOptions=} opt_options
 */
ol.format.GML = function(opt_options) {};

/**
 * Encode an array of features in GML 3.1.1 Simple Features.
 * 
 * \@api stable
 * @param {!Array<!ol.Feature>} features
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {string}
 */
ol.format.GML.prototype.writeFeatures = function(features, opt_options) {};

/**
 * Encode an array of features in the GML 3.1.1 format as an XML node.
 * 
 * \@api
 * @param {!Array<!ol.Feature>} features
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {!Node}
 */
ol.format.GML.prototype.writeFeaturesNode = function(features, opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Feature format for reading and writing data in the GML format,
 * version 2.1.2.
 * 
 * \@api
 * @param {!olx.format.GMLOptions=} opt_options
 */
ol.format.GML2 = function(opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Feature format for reading and writing data in the GML format
 * version 3.1.1.
 * Currently only supports GML 3.1.1 Simple Features profile.
 * 
 *     Optional configuration object.
 * \@api
 * @param {!olx.format.GMLOptions=} opt_options
 */
ol.format.GML3 = function(opt_options) {};

/**
 * Encode a geometry in GML 3.1.1 Simple Features.
 * 
 * \@api
 * @param {!ol.geom.Geometry} geometry
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {!Node}
 */
ol.format.GML3.prototype.writeGeometryNode = function(geometry, opt_options) {};

/**
 * Encode an array of features in GML 3.1.1 Simple Features.
 * 
 * \@api stable
 * @param {!Array<!ol.Feature>} features
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {string}
 */
ol.format.GML3.prototype.writeFeatures = function(features, opt_options) {};

/**
 * Encode an array of features in the GML 3.1.1 format as an XML node.
 * 
 * \@api
 * @param {!Array<!ol.Feature>} features
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {!Node}
 */
ol.format.GML3.prototype.writeFeaturesNode = function(features, opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Feature base format for reading and writing data in the GML format.
 * This class cannot be instantiated, it contains only base content that
 * is shared with versioned format classes ol.format.GML2 and
 * ol.format.GML3.
 * 
 *     Optional configuration object.
 * @param {!olx.format.GMLOptions=} opt_options
 */
ol.format.GMLBase = function(opt_options) {};

/**
 * Read all features from a GML FeatureCollection.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!Array<!ol.Feature>}
 */
ol.format.GMLBase.prototype.readFeatures = function(source, opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Feature format for reading and writing data in the GPX format.
 * 
 * \@api stable
 * @param {!olx.format.GPXOptions=} opt_options
 */
ol.format.GPX = function(opt_options) {};

/**
 * Read the first feature from a GPX source.
 * Routes (`<rte>`) are converted into LineString geometries, and tracks (`<trk>`)
 * into MultiLineString. Any properties on route and track waypoints are ignored.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!ol.Feature}
 */
ol.format.GPX.prototype.readFeature = function(source, opt_options) {};

/**
 * Read all features from a GPX source.
 * Routes (`<rte>`) are converted into LineString geometries, and tracks (`<trk>`)
 * into MultiLineString. Any properties on route and track waypoints are ignored.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!Array<!ol.Feature>}
 */
ol.format.GPX.prototype.readFeatures = function(source, opt_options) {};

/**
 * Read the projection from a GPX source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @return {!ol.proj.Projection}
 */
ol.format.GPX.prototype.readProjection = function(source) {};

/**
 * Encode an array of features in the GPX format.
 * LineString geometries are output as routes (`<rte>`), and MultiLineString
 * as tracks (`<trk>`).
 * 
 * \@api stable
 * @param {!Array<!ol.Feature>} features
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {string}
 */
ol.format.GPX.prototype.writeFeatures = function(features, opt_options) {};

/**
 * Encode an array of features in the GPX format as an XML node.
 * LineString geometries are output as routes (`<rte>`), and MultiLineString
 * as tracks (`<trk>`).
 * 
 * \@api
 * @param {!Array<!ol.Feature>} features
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {!Node}
 */
ol.format.GPX.prototype.writeFeaturesNode = function(features, opt_options) {};

/** @typedef {string} */
ol.format.IGCZ;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Feature format for `*.igc` flight recording files.
 * 
 * \@api
 * @param {!olx.format.IGCOptions=} opt_options
 */
ol.format.IGC = function(opt_options) {};

/**
 * Read the feature from the IGC source.
 * 
 * \@api
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!ol.Feature}
 */
ol.format.IGC.prototype.readFeature = function(source, opt_options) {};

/**
 * Read the feature from the source. As IGC sources contain a single
 * feature, this will return the feature in an array.
 * 
 * \@api
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!Array<!ol.Feature>}
 */
ol.format.IGC.prototype.readFeatures = function(source, opt_options) {};

/**
 * Read the projection from the IGC source.
 * 
 * \@api
 * @param {(string|!Object|!Node|!Document)} source
 * @return {!ol.proj.Projection}
 */
ol.format.IGC.prototype.readProjection = function(source) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 * 
 */
ol.format.JSONFeature = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Feature format for reading and writing data in the KML format.
 * 
 * Note that the KML format uses the URL() constructor. Older browsers such as IE
 * which do not support this will need a URL polyfill to be loaded before use.
 * 
 * \@api stable
 * @param {!olx.format.KMLOptions=} opt_options
 */
ol.format.KML = function(opt_options) {};

/**
 * Read the first feature from a KML source. MultiGeometries are converted into
 * GeometryCollections if they are a mix of geometry types, and into MultiPoint/
 * MultiLineString/MultiPolygon if they are all of the same type.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!ol.Feature}
 */
ol.format.KML.prototype.readFeature = function(source, opt_options) {};

/**
 * Read all features from a KML source. MultiGeometries are converted into
 * GeometryCollections if they are a mix of geometry types, and into MultiPoint/
 * MultiLineString/MultiPolygon if they are all of the same type.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!Array<!ol.Feature>}
 */
ol.format.KML.prototype.readFeatures = function(source, opt_options) {};

/**
 * Read the name of the KML.
 * 
 * \@api stable
 * @param {(string|!Node|!Document)} source
 * @return {string}
 */
ol.format.KML.prototype.readName = function(source) {};

/**
 * Read the network links of the KML.
 * 
 * \@api
 * @param {(string|!Node|!Document)} source
 * @return {!Array<!Object>}
 */
ol.format.KML.prototype.readNetworkLinks = function(source) {};

/**
 * Read the projection from a KML source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @return {!ol.proj.Projection}
 */
ol.format.KML.prototype.readProjection = function(source) {};

/**
 * Encode an array of features in the KML format. GeometryCollections, MultiPoints,
 * MultiLineStrings, and MultiPolygons are output as MultiGeometries.
 * 
 * \@api stable
 * @param {!Array<!ol.Feature>} features
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {string}
 */
ol.format.KML.prototype.writeFeatures = function(features, opt_options) {};

/**
 * Encode an array of features in the KML format as an XML node. GeometryCollections,
 * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.
 * 
 * \@api
 * @param {!Array<!ol.Feature>} features
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {!Node}
 */
ol.format.KML.prototype.writeFeaturesNode = function(features, opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Feature format for reading data in the Mapbox MVT format.
 * 
 * \@api
 * @param {!olx.format.MVTOptions=} opt_options
 */
ol.format.MVT = function(opt_options) {};

/**
 * @inheritDoc
 * \@api
 * @param {(string|!Object|!Node|!ArrayBuffer|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!Array<!ol.Feature>}
 */
ol.format.MVT.prototype.readFeatures = function(source, opt_options) {};

/**
 * @inheritDoc
 * \@api
 * @param {(string|!Object|!Node|!Document)} source
 * @return {!ol.proj.Projection}
 */
ol.format.MVT.prototype.readProjection = function(source) {};

/**
 * Sets the layers that features will be read from.
 * \@api
 * @param {!Array<string>} layers
 * @return {void}
 */
ol.format.MVT.prototype.setLayers = function(layers) {};
/** @const */
ol.format.filter = {};
/**
 * @record
 * @struct
 */
ol.format.filter.Filter = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Feature format for reading data in the
 * [OSMXML format](http://wiki.openstreetmap.org/wiki/OSM_XML).
 * 
 * \@api stable
 */
ol.format.OSMXML = function() {};

/**
 * Read all features from an OSM source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!Array<!ol.Feature>}
 */
ol.format.OSMXML.prototype.readFeatures = function(source, opt_options) {};

/**
 * Read the projection from an OSM source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @return {!ol.proj.Projection}
 */
ol.format.OSMXML.prototype.readProjection = function(source) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Feature format for reading and writing data in the Encoded
 * Polyline Algorithm Format.
 * 
 *     Optional configuration object.
 * \@api stable
 * @param {!olx.format.PolylineOptions=} opt_options
 */
ol.format.Polyline = function(opt_options) {};

/**
 * Encode a list of n-dimensional points and return an encoded string
 * 
 * Attention: This function will modify the passed array!
 * 
 *     multiplied. The remaining decimal places will get rounded away.
 *     Default is `1e5`.
 * \@api
 * @param {!Array<number>} numbers
 * @param {number} stride
 * @param {number=} opt_factor
 * @return {string}
 */
ol.format.Polyline.encodeDeltas = function(numbers, stride, opt_factor) {};

/**
 * Decode a list of n-dimensional points from an encoded string
 * 
 *     encoded string.
 *     be divided. Default is `1e5`.
 * \@api
 * @param {string} encoded
 * @param {number} stride
 * @param {number=} opt_factor
 * @return {!Array<number>}
 */
ol.format.Polyline.decodeDeltas = function(encoded, stride, opt_factor) {};

/**
 * Encode a list of floating point numbers and return an encoded string
 * 
 * Attention: This function will modify the passed array!
 * 
 *     multiplied. The remaining decimal places will get rounded away.
 *     Default is `1e5`.
 * \@api
 * @param {!Array<number>} numbers
 * @param {number=} opt_factor
 * @return {string}
 */
ol.format.Polyline.encodeFloats = function(numbers, opt_factor) {};

/**
 * Decode a list of floating point numbers from an encoded string
 * 
 *     Default is `1e5`.
 * \@api
 * @param {string} encoded
 * @param {number=} opt_factor
 * @return {!Array<number>}
 */
ol.format.Polyline.decodeFloats = function(encoded, opt_factor) {};

/**
 * Read the feature from the Polyline source. The coordinates are assumed to be
 * in two dimensions and in latitude, longitude order.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!ol.Feature}
 */
ol.format.Polyline.prototype.readFeature = function(source, opt_options) {};

/**
 * Read the feature from the source. As Polyline sources contain a single
 * feature, this will return the feature in an array.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!Array<!ol.Feature>}
 */
ol.format.Polyline.prototype.readFeatures = function(source, opt_options) {};

/**
 * Read the geometry from the source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!ol.geom.Geometry}
 */
ol.format.Polyline.prototype.readGeometry = function(source, opt_options) {};

/**
 * Read the projection from a Polyline source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @return {!ol.proj.Projection}
 */
ol.format.Polyline.prototype.readProjection = function(source) {};

/**
 * Write a single geometry in Polyline format.
 * 
 * \@api stable
 * @param {!ol.geom.Geometry} geometry
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {string}
 */
ol.format.Polyline.prototype.writeGeometry = function(geometry, opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for text feature formats.
 * 
 */
ol.format.TextFeature = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Feature format for reading data in the TopoJSON format.
 * 
 * \@api stable
 * @param {!olx.format.TopoJSONOptions=} opt_options
 */
ol.format.TopoJSON = function(opt_options) {};

/**
 * Read all features from a TopoJSON source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @return {!Array<!ol.Feature>}
 */
ol.format.TopoJSON.prototype.readFeatures = function(source) {};

/**
 * Read the projection from a TopoJSON source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} object
 * @return {!ol.proj.Projection}
 */
ol.format.TopoJSON.prototype.readProjection = function(object) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Feature format for reading and writing data in the WFS format.
 * By default, supports WFS version 1.1.0. You can pass a GML format
 * as option if you want to read a WFS that contains GML2 (WFS 1.0.0).
 * Also see {\@link ol.format.GMLBase} which is used by this format.
 * 
 *     Optional configuration object.
 * \@api stable
 * @param {!olx.format.WFSOptions=} opt_options
 */
ol.format.WFS = function(opt_options) {};

/**
 * Read all features from a WFS FeatureCollection.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!Array<!ol.Feature>}
 */
ol.format.WFS.prototype.readFeatures = function(source, opt_options) {};

/**
 * Read transaction response of the source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @return {!ol.Object}
 */
ol.format.WFS.prototype.readTransactionResponse = function(source) {};

/**
 * Read feature collection metadata of the source.
 * 
 *     FeatureCollection metadata.
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @return {!ol.Object}
 */
ol.format.WFS.prototype.readFeatureCollectionMetadata = function(source) {};

/**
 * Encode format as WFS `GetFeature` and return the Node.
 * 
 * \@api stable
 * @param {!olx.format.WFSWriteGetFeatureOptions} options
 * @return {!Node}
 */
ol.format.WFS.prototype.writeGetFeature = function(options) {};

/**
 * Encode format as WFS `Transaction` and return the Node.
 * 
 * \@api stable
 * @param {!Array<!ol.Feature>} inserts
 * @param {!Array<!ol.Feature>} updates
 * @param {!Array<!ol.Feature>} deletes
 * @param {!olx.format.WFSWriteTransactionOptions} options
 * @return {!Node}
 */
ol.format.WFS.prototype.writeTransaction = function(inserts, updates, deletes, options) {};

/**
 * Read the projection from a WFS source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @return {!ol.proj.Projection}
 */
ol.format.WFS.prototype.readProjection = function(source) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Geometry format for reading and writing data in the `WellKnownText` (WKT)
 * format.
 * 
 * \@api stable
 * @param {!olx.format.WKTOptions=} opt_options
 */
ol.format.WKT = function(opt_options) {};

/**
 * Read a feature from a WKT source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!ol.Feature}
 */
ol.format.WKT.prototype.readFeature = function(source, opt_options) {};

/**
 * Read all features from a WKT source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!Array<!ol.Feature>}
 */
ol.format.WKT.prototype.readFeatures = function(source, opt_options) {};

/**
 * Read a single geometry from a WKT source.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!ol.geom.Geometry}
 */
ol.format.WKT.prototype.readGeometry = function(source, opt_options) {};

/**
 * Encode a feature as a WKT string.
 * 
 * \@api stable
 * @param {!ol.Feature} feature
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {string}
 */
ol.format.WKT.prototype.writeFeature = function(feature, opt_options) {};

/**
 * Encode an array of features as a WKT string.
 * 
 * \@api stable
 * @param {!Array<!ol.Feature>} features
 * @param {!olx.format.WriteOptions=} opt_options
 * @return {string}
 */
ol.format.WKT.prototype.writeFeatures = function(features, opt_options) {};

/**
 * Write a single geometry as a WKT string.
 * 
 * \@api stable
 * @param {!ol.geom.Geometry} geometry
 * @return {string}
 */
ol.format.WKT.prototype.writeGeometry = function(geometry) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Format for reading WMS capabilities data
 * 
 * \@api
 */
ol.format.WMSCapabilities = function() {};

/**
 * Read a WMS capabilities document.
 * 
 * \@api
 * @param {(string|!Node|!Document)} source
 * @return {!Object}
 */
ol.format.WMSCapabilities.prototype.read = function(source) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Format for reading WMSGetFeatureInfo format. It uses
 * {\@link ol.format.GML2} to read features.
 * 
 * \@api
 * @param {!olx.format.WMSGetFeatureInfoOptions=} opt_options
 */
ol.format.WMSGetFeatureInfo = function(opt_options) {};

/**
 * Read all features from a WMSGetFeatureInfo response.
 * 
 * \@api stable
 * @param {(string|!Object|!Node|!Document)} source
 * @param {!olx.format.ReadOptions=} opt_options
 * @return {!Array<!ol.Feature>}
 */
ol.format.WMSGetFeatureInfo.prototype.readFeatures = function(source, opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Format for reading WMTS capabilities data.
 * 
 * \@api
 */
ol.format.WMTSCapabilities = function() {};

/**
 * Read a WMTS capabilities document.
 * 
 * \@api
 * @param {(string|!Node|!Document)} source
 * @return {!Object}
 */
ol.format.WMTSCapabilities.prototype.read = function(source) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Generic format for reading non-feature XML data
 * 
 * @struct
 */
ol.format.XML = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for XML feature formats.
 * 
 */
ol.format.XMLFeature = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Helper class for providing HTML5 Geolocation capabilities.
 * The [Geolocation API](http://www.w3.org/TR/geolocation-API/)
 * is used to locate a user's position.
 * 
 * To get notified of position changes, register a listener for the generic
 * `change` event on your instance of `ol.Geolocation`.
 * 
 * Example:
 * 
 *     var geolocation = new ol.Geolocation({
 *       // take the projection to use from the map's view
 *       projection: view.getProjection()
 *     });
 *     // listen to changes in position
 *     geolocation.on('change', function(evt) {
 *       window.console.log(geolocation.getPosition());
 *     });
 * 
 * \@fires error
 * \@api stable
 * @param {!olx.GeolocationOptions=} opt_options
 */
ol.Geolocation = function(opt_options) {};

/**
 * Get the accuracy of the position in meters.
 *     meters.
 * \@observable
 * \@api stable
 * @return {number}
 */
ol.Geolocation.prototype.getAccuracy = function() {};

/**
 * Get a geometry of the position accuracy.
 * \@observable
 * \@api stable
 * @return {!ol.geom.Geometry}
 */
ol.Geolocation.prototype.getAccuracyGeometry = function() {};

/**
 * Get the altitude associated with the position.
 *     sea level.
 * \@observable
 * \@api stable
 * @return {number}
 */
ol.Geolocation.prototype.getAltitude = function() {};

/**
 * Get the altitude accuracy of the position.
 *     meters.
 * \@observable
 * \@api stable
 * @return {number}
 */
ol.Geolocation.prototype.getAltitudeAccuracy = function() {};

/**
 * Get the heading as radians clockwise from North.
 * \@observable
 * \@api stable
 * @return {number}
 */
ol.Geolocation.prototype.getHeading = function() {};

/**
 * Get the position of the device.
 *     in the current projection.
 * \@observable
 * \@api stable
 * @return {!Array<?>}
 */
ol.Geolocation.prototype.getPosition = function() {};

/**
 * Get the projection associated with the position.
 *     reported in.
 * \@observable
 * \@api stable
 * @return {!ol.proj.Projection}
 */
ol.Geolocation.prototype.getProjection = function() {};

/**
 * Get the speed in meters per second.
 *     per second.
 * \@observable
 * \@api stable
 * @return {number}
 */
ol.Geolocation.prototype.getSpeed = function() {};

/**
 * Determine if the device location is being tracked.
 * \@observable
 * \@api stable
 * @return {boolean}
 */
ol.Geolocation.prototype.getTracking = function() {};

/**
 * Get the tracking options.
 * @see http://www.w3.org/TR/geolocation-API/#position-options
 *     the [HTML5 Geolocation spec
 *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
 * \@observable
 * \@api stable
 * @return {!PositionOptions}
 */
ol.Geolocation.prototype.getTrackingOptions = function() {};

/**
 * Set the projection to use for transforming the coordinates.
 *     reported in.
 * \@observable
 * \@api stable
 * @param {!ol.proj.Projection} projection
 * @return {void}
 */
ol.Geolocation.prototype.setProjection = function(projection) {};

/**
 * Enable or disable tracking.
 * \@observable
 * \@api stable
 * @param {boolean} tracking
 * @return {void}
 */
ol.Geolocation.prototype.setTracking = function(tracking) {};

/**
 * Set the tracking options.
 * @see http://www.w3.org/TR/geolocation-API/#position-options
 *     [HTML5 Geolocation spec
 *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
 * \@observable
 * \@api stable
 * @param {!PositionOptions} options
 * @return {void}
 */
ol.Geolocation.prototype.setTrackingOptions = function(options) {};
/** @const */
ol.geom = {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Circle geometry.
 * 
 * \@api
 * @param {!Array<?>} center
 * @param {number=} opt_radius
 * @param {string=} opt_layout
 */
ol.geom.Circle = function(center, opt_radius, opt_layout) {};

/**
 * Make a complete copy of the geometry.
 * \@api
 * @return {!ol.geom.Circle}
 */
ol.geom.Circle.prototype.clone = function() {};

/**
 * Return the center of the circle as {\@link ol.Coordinate coordinate}.
 * \@api
 * @return {!Array<?>}
 */
ol.geom.Circle.prototype.getCenter = function() {};

/**
 * Return the radius of the circle.
 * \@api
 * @return {number}
 */
ol.geom.Circle.prototype.getRadius = function() {};

/**
 * @inheritDoc
 * \@api
 * @return {string}
 */
ol.geom.Circle.prototype.getType = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @param {!Array<?>} extent
 * @return {boolean}
 */
ol.geom.Circle.prototype.intersectsExtent = function(extent) {};

/**
 * Set the center of the circle as {\@link ol.Coordinate coordinate}.
 * \@api
 * @param {!Array<?>} center
 * @return {void}
 */
ol.geom.Circle.prototype.setCenter = function(center) {};

/**
 * Set the center (as {\@link ol.Coordinate coordinate}) and the radius (as
 * number) of the circle.
 * \@api
 * @param {!Array<?>} center
 * @param {number} radius
 * @param {string=} opt_layout
 * @return {void}
 */
ol.geom.Circle.prototype.setCenterAndRadius = function(center, radius, opt_layout) {};

/**
 * Set the radius of the circle. The radius is in the units of the projection.
 * \@api
 * @param {number} radius
 * @return {void}
 */
ol.geom.Circle.prototype.setRadius = function(radius) {};

/** @typedef {string} */
ol.geom.GeometryType;

/** @typedef {string} */
ol.geom.GeometryLayout;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 * 
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 * 
 * \@api stable
 */
ol.geom.Geometry = function() {};

/**
 * Return the closest point of the geometry to the passed point as
 * {\@link ol.Coordinate coordinate}.
 * \@api stable
 * @param {!Array<?>} point
 * @param {!Array<?>=} opt_closestPoint
 * @return {!Array<?>}
 */
ol.geom.Geometry.prototype.getClosestPoint = function(point, opt_closestPoint) {};

/**
 * Returns true if this geometry includes the specified coordinate. If the
 * coordinate is on the boundary of the geometry, returns false.
 * \@api
 * @param {!Array<?>} coordinate
 * @return {boolean}
 */
ol.geom.Geometry.prototype.intersectsCoordinate = function(coordinate) {};

/**
 * Get the extent of the geometry.
 * \@api stable
 * @param {!Array<?>=} opt_extent
 * @return {!Array<?>}
 */
ol.geom.Geometry.prototype.getExtent = function(opt_extent) {};

/**
 * Rotate the geometry around a given coordinate. This modifies the geometry
 * coordinates in place.
 * @abstract
 * \@api
 * @param {number} angle
 * @param {!Array<?>} anchor
 * @return {void}
 */
ol.geom.Geometry.prototype.rotate = function(angle, anchor) {};

/**
 * Scale the geometry (with an optional origin).  This modifies the geometry
 * coordinates in place.
 * @abstract 
 *     sx).
 *     of the geometry extent).
 * \@api
 * @param {number} sx
 * @param {number=} opt_sy
 * @param {!Array<?>=} opt_anchor
 * @return {void}
 */
ol.geom.Geometry.prototype.scale = function(sx, opt_sy, opt_anchor) {};

/**
 * Create a simplified version of this geometry.  For linestrings, this uses
 * the the {\@link
 * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
 * Douglas Peucker} algorithm.  For polygons, a quantization-based
 * simplification is used to preserve topology.
 *     geometry.
 * \@api
 * @param {number} tolerance
 * @return {!ol.geom.Geometry}
 */
ol.geom.Geometry.prototype.simplify = function(tolerance) {};

/**
 * Transform each coordinate of the geometry from one coordinate reference
 * system to another. The geometry is modified in place.
 * For example, a line will be transformed to a line and a circle to a circle.
 * If you do not want the geometry modified in place, first `clone()` it and
 * then use this function on the clone.
 * 
 *     string identifier or a {\@link ol.proj.Projection} object.
 *     string identifier or a {\@link ol.proj.Projection} object.
 *     modified in place.
 * \@api stable
 * @param {(string|!ol.proj.Projection)} source
 * @param {(string|!ol.proj.Projection)} destination
 * @return {!ol.geom.Geometry}
 */
ol.geom.Geometry.prototype.transform = function(source, destination) {};

/**
 * Get the type of this geometry.
 * @abstract
 * @return {string}
 */
ol.geom.Geometry.prototype.getType = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * An array of {\@link ol.geom.Geometry} objects.
 * 
 * \@api stable
 * @param {!Array<!ol.geom.Geometry>=} opt_geometries
 */
ol.geom.GeometryCollection = function(opt_geometries) {};

/**
 * Make a complete copy of the geometry.
 * \@api stable
 * @return {!ol.geom.GeometryCollection}
 */
ol.geom.GeometryCollection.prototype.clone = function() {};

/**
 * Return the geometries that make up this geometry collection.
 * \@api stable
 * @return {!Array<!ol.geom.Geometry>}
 */
ol.geom.GeometryCollection.prototype.getGeometries = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @return {string}
 */
ol.geom.GeometryCollection.prototype.getType = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @param {!Array<?>} extent
 * @return {boolean}
 */
ol.geom.GeometryCollection.prototype.intersectsExtent = function(extent) {};

/**
 * Set the geometries that make up this geometry collection.
 * \@api stable
 * @param {!Array<!ol.geom.Geometry>} geometries
 * @return {void}
 */
ol.geom.GeometryCollection.prototype.setGeometries = function(geometries) {};

/**
 * @inheritDoc
 * \@api stable
 * @param {function(!Array<number>, !Array<number>, number): !Array<number>} transformFn
 * @return {void}
 */
ol.geom.GeometryCollection.prototype.applyTransform = function(transformFn) {};

/**
 * Translate the geometry.
 * \@api
 * @param {number} deltaX
 * @param {number} deltaY
 * @return {void}
 */
ol.geom.GeometryCollection.prototype.translate = function(deltaX, deltaY) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 * 
 * \@api stable
 * @param {!Array<!Array<?>>} coordinates
 * @param {string=} opt_layout
 */
ol.geom.LinearRing = function(coordinates, opt_layout) {};

/**
 * Make a complete copy of the geometry.
 * \@api stable
 * @return {!ol.geom.LinearRing}
 */
ol.geom.LinearRing.prototype.clone = function() {};

/**
 * Return the area of the linear ring on projected plane.
 * \@api stable
 * @return {number}
 */
ol.geom.LinearRing.prototype.getArea = function() {};

/**
 * Return the coordinates of the linear ring.
 * \@api stable
 * @return {!Array<!Array<?>>}
 */
ol.geom.LinearRing.prototype.getCoordinates = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @return {string}
 */
ol.geom.LinearRing.prototype.getType = function() {};

/**
 * Set the coordinates of the linear ring.
 * \@api stable
 * @param {!Array<!Array<?>>} coordinates
 * @param {string=} opt_layout
 * @return {void}
 */
ol.geom.LinearRing.prototype.setCoordinates = function(coordinates, opt_layout) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Linestring geometry.
 * 
 * \@api stable
 * @param {!Array<!Array<?>>} coordinates
 * @param {string=} opt_layout
 */
ol.geom.LineString = function(coordinates, opt_layout) {};

/**
 * Append the passed coordinate to the coordinates of the linestring.
 * \@api stable
 * @param {!Array<?>} coordinate
 * @return {void}
 */
ol.geom.LineString.prototype.appendCoordinate = function(coordinate) {};

/**
 * Make a complete copy of the geometry.
 * \@api stable
 * @return {!ol.geom.LineString}
 */
ol.geom.LineString.prototype.clone = function() {};

/**
 * Iterate over each segment, calling the provided callback.
 * If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * 
 *     called for each segment.
 *     within callback.
 * \@api
 * @template T, S
 * @param {function(): T} callback
 * @param {S=} opt_this
 * @return {(boolean|T)}
 */
ol.geom.LineString.prototype.forEachSegment = function(callback, opt_this) {};

/**
 * Returns the coordinate at `m` using linear interpolation, or `null` if no
 * such coordinate exists.
 * 
 * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
 * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
 * M will return the first coordinate and Ms greater than the last M will
 * return the last coordinate.
 * 
 * \@api stable
 * @param {number} m
 * @param {boolean=} opt_extrapolate
 * @return {!Array<?>}
 */
ol.geom.LineString.prototype.getCoordinateAtM = function(m, opt_extrapolate) {};

/**
 * Return the coordinates of the linestring.
 * \@api stable
 * @return {!Array<!Array<?>>}
 */
ol.geom.LineString.prototype.getCoordinates = function() {};

/**
 * Return the coordinate at the provided fraction along the linestring.
 * The `fraction` is a number between 0 and 1, where 0 is the start of the
 * linestring and 1 is the end.
 *     be modified. If not provided, a new coordinate will be returned.
 * \@api
 * @param {number} fraction
 * @param {!Array<?>=} opt_dest
 * @return {!Array<?>}
 */
ol.geom.LineString.prototype.getCoordinateAt = function(fraction, opt_dest) {};

/**
 * Return the length of the linestring on projected plane.
 * \@api stable
 * @return {number}
 */
ol.geom.LineString.prototype.getLength = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @return {string}
 */
ol.geom.LineString.prototype.getType = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @param {!Array<?>} extent
 * @return {boolean}
 */
ol.geom.LineString.prototype.intersectsExtent = function(extent) {};

/**
 * Set the coordinates of the linestring.
 * \@api stable
 * @param {!Array<!Array<?>>} coordinates
 * @param {string=} opt_layout
 * @return {void}
 */
ol.geom.LineString.prototype.setCoordinates = function(coordinates, opt_layout) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Multi-linestring geometry.
 * 
 * \@api stable
 * @param {!Array<!Array<!Array<?>>>} coordinates
 * @param {string=} opt_layout
 */
ol.geom.MultiLineString = function(coordinates, opt_layout) {};

/**
 * Append the passed linestring to the multilinestring.
 * \@api stable
 * @param {!ol.geom.LineString} lineString
 * @return {void}
 */
ol.geom.MultiLineString.prototype.appendLineString = function(lineString) {};

/**
 * Make a complete copy of the geometry.
 * \@api stable
 * @return {!ol.geom.MultiLineString}
 */
ol.geom.MultiLineString.prototype.clone = function() {};

/**
 * Returns the coordinate at `m` using linear interpolation, or `null` if no
 * such coordinate exists.
 * 
 * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
 * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
 * M will return the first coordinate and Ms greater than the last M will
 * return the last coordinate.
 * 
 * `opt_interpolate` controls interpolation between consecutive LineStrings
 * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
 * will be linearly interpolated between the last coordinate of one LineString
 * and the first coordinate of the next LineString.  If `opt_interpolate` is
 * `false` then the function will return `null` for Ms falling between
 * LineStrings.
 * 
 * \@api stable
 * @param {number} m
 * @param {boolean=} opt_extrapolate
 * @param {boolean=} opt_interpolate
 * @return {!Array<?>}
 */
ol.geom.MultiLineString.prototype.getCoordinateAtM = function(m, opt_extrapolate, opt_interpolate) {};

/**
 * Return the coordinates of the multilinestring.
 * \@api stable
 * @return {!Array<!Array<!Array<?>>>}
 */
ol.geom.MultiLineString.prototype.getCoordinates = function() {};

/**
 * Return the linestring at the specified index.
 * \@api stable
 * @param {number} index
 * @return {!ol.geom.LineString}
 */
ol.geom.MultiLineString.prototype.getLineString = function(index) {};

/**
 * Return the linestrings of this multilinestring.
 * \@api stable
 * @return {!Array<!ol.geom.LineString>}
 */
ol.geom.MultiLineString.prototype.getLineStrings = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @return {string}
 */
ol.geom.MultiLineString.prototype.getType = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @param {!Array<?>} extent
 * @return {boolean}
 */
ol.geom.MultiLineString.prototype.intersectsExtent = function(extent) {};

/**
 * Set the coordinates of the multilinestring.
 * \@api stable
 * @param {!Array<!Array<!Array<?>>>} coordinates
 * @param {string=} opt_layout
 * @return {void}
 */
ol.geom.MultiLineString.prototype.setCoordinates = function(coordinates, opt_layout) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Multi-point geometry.
 * 
 * \@api stable
 * @param {!Array<!Array<?>>} coordinates
 * @param {string=} opt_layout
 */
ol.geom.MultiPoint = function(coordinates, opt_layout) {};

/**
 * Append the passed point to this multipoint.
 * \@api stable
 * @param {!ol.geom.Point} point
 * @return {void}
 */
ol.geom.MultiPoint.prototype.appendPoint = function(point) {};

/**
 * Make a complete copy of the geometry.
 * \@api stable
 * @return {!ol.geom.MultiPoint}
 */
ol.geom.MultiPoint.prototype.clone = function() {};

/**
 * Return the coordinates of the multipoint.
 * \@api stable
 * @return {!Array<!Array<?>>}
 */
ol.geom.MultiPoint.prototype.getCoordinates = function() {};

/**
 * Return the point at the specified index.
 * \@api stable
 * @param {number} index
 * @return {!ol.geom.Point}
 */
ol.geom.MultiPoint.prototype.getPoint = function(index) {};

/**
 * Return the points of this multipoint.
 * \@api stable
 * @return {!Array<!ol.geom.Point>}
 */
ol.geom.MultiPoint.prototype.getPoints = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @return {string}
 */
ol.geom.MultiPoint.prototype.getType = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @param {!Array<?>} extent
 * @return {boolean}
 */
ol.geom.MultiPoint.prototype.intersectsExtent = function(extent) {};

/**
 * Set the coordinates of the multipoint.
 * \@api stable
 * @param {!Array<!Array<?>>} coordinates
 * @param {string=} opt_layout
 * @return {void}
 */
ol.geom.MultiPoint.prototype.setCoordinates = function(coordinates, opt_layout) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Multi-polygon geometry.
 * 
 * \@api stable
 * @param {!Array<!Array<!Array<!Array<?>>>>} coordinates
 * @param {string=} opt_layout
 */
ol.geom.MultiPolygon = function(coordinates, opt_layout) {};

/**
 * Append the passed polygon to this multipolygon.
 * \@api stable
 * @param {!ol.geom.Polygon} polygon
 * @return {void}
 */
ol.geom.MultiPolygon.prototype.appendPolygon = function(polygon) {};

/**
 * Make a complete copy of the geometry.
 * \@api stable
 * @return {!ol.geom.MultiPolygon}
 */
ol.geom.MultiPolygon.prototype.clone = function() {};

/**
 * Return the area of the multipolygon on projected plane.
 * \@api stable
 * @return {number}
 */
ol.geom.MultiPolygon.prototype.getArea = function() {};

/**
 * Get the coordinate array for this geometry.  This array has the structure
 * of a GeoJSON coordinate array for multi-polygons.
 * 
 *     rule (counter-clockwise for exterior and clockwise for interior rings).
 *     If `false`, coordinates will be oriented according to the left-hand rule
 *     (clockwise for exterior and counter-clockwise for interior rings).
 *     By default, coordinate orientation will depend on how the geometry was
 *     constructed.
 * \@api stable
 * @param {boolean=} opt_right
 * @return {!Array<!Array<!Array<!Array<?>>>>}
 */
ol.geom.MultiPolygon.prototype.getCoordinates = function(opt_right) {};

/**
 * Return the interior points as {\@link ol.geom.MultiPoint multipoint}.
 * \@api stable
 * @return {!ol.geom.MultiPoint}
 */
ol.geom.MultiPolygon.prototype.getInteriorPoints = function() {};

/**
 * Return the polygon at the specified index.
 * \@api stable
 * @param {number} index
 * @return {!ol.geom.Polygon}
 */
ol.geom.MultiPolygon.prototype.getPolygon = function(index) {};

/**
 * Return the polygons of this multipolygon.
 * \@api stable
 * @return {!Array<!ol.geom.Polygon>}
 */
ol.geom.MultiPolygon.prototype.getPolygons = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @return {string}
 */
ol.geom.MultiPolygon.prototype.getType = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @param {!Array<?>} extent
 * @return {boolean}
 */
ol.geom.MultiPolygon.prototype.intersectsExtent = function(extent) {};

/**
 * Set the coordinates of the multipolygon.
 * \@api stable
 * @param {!Array<!Array<!Array<!Array<?>>>>} coordinates
 * @param {string=} opt_layout
 * @return {void}
 */
ol.geom.MultiPolygon.prototype.setCoordinates = function(coordinates, opt_layout) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Point geometry.
 * 
 * \@api stable
 * @param {!Array<?>} coordinates
 * @param {string=} opt_layout
 */
ol.geom.Point = function(coordinates, opt_layout) {};

/**
 * Make a complete copy of the geometry.
 * \@api stable
 * @return {!ol.geom.Point}
 */
ol.geom.Point.prototype.clone = function() {};

/**
 * Return the coordinate of the point.
 * \@api stable
 * @return {!Array<?>}
 */
ol.geom.Point.prototype.getCoordinates = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @return {string}
 */
ol.geom.Point.prototype.getType = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @param {!Array<?>} extent
 * @return {boolean}
 */
ol.geom.Point.prototype.intersectsExtent = function(extent) {};

/**
 * Set the coordinate of the point.
 * \@api stable
 * @param {!Array<?>} coordinates
 * @param {string=} opt_layout
 * @return {void}
 */
ol.geom.Point.prototype.setCoordinates = function(coordinates, opt_layout) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Polygon geometry.
 * 
 * \@api stable
 * @param {!Array<!Array<!Array<?>>>} coordinates
 * @param {string=} opt_layout
 */
ol.geom.Polygon = function(coordinates, opt_layout) {};

/**
 * Append the passed linear ring to this polygon.
 * \@api stable
 * @param {!ol.geom.LinearRing} linearRing
 * @return {void}
 */
ol.geom.Polygon.prototype.appendLinearRing = function(linearRing) {};

/**
 * Make a complete copy of the geometry.
 * \@api stable
 * @return {!ol.geom.Polygon}
 */
ol.geom.Polygon.prototype.clone = function() {};

/**
 * Return the area of the polygon on projected plane.
 * \@api stable
 * @return {number}
 */
ol.geom.Polygon.prototype.getArea = function() {};

/**
 * Get the coordinate array for this geometry.  This array has the structure
 * of a GeoJSON coordinate array for polygons.
 * 
 *     rule (counter-clockwise for exterior and clockwise for interior rings).
 *     If `false`, coordinates will be oriented according to the left-hand rule
 *     (clockwise for exterior and counter-clockwise for interior rings).
 *     By default, coordinate orientation will depend on how the geometry was
 *     constructed.
 * \@api stable
 * @param {boolean=} opt_right
 * @return {!Array<!Array<!Array<?>>>}
 */
ol.geom.Polygon.prototype.getCoordinates = function(opt_right) {};

/**
 * Return an interior point of the polygon.
 * \@api stable
 * @return {!ol.geom.Point}
 */
ol.geom.Polygon.prototype.getInteriorPoint = function() {};

/**
 * Return the number of rings of the polygon,  this includes the exterior
 * ring and any interior rings.
 * 
 * \@api
 * @return {number}
 */
ol.geom.Polygon.prototype.getLinearRingCount = function() {};

/**
 * Return the Nth linear ring of the polygon geometry. Return `null` if the
 * given index is out of range.
 * The exterior linear ring is available at index `0` and the interior rings
 * at index `1` and beyond.
 * 
 * \@api stable
 * @param {number} index
 * @return {!ol.geom.LinearRing}
 */
ol.geom.Polygon.prototype.getLinearRing = function(index) {};

/**
 * Return the linear rings of the polygon.
 * \@api stable
 * @return {!Array<!ol.geom.LinearRing>}
 */
ol.geom.Polygon.prototype.getLinearRings = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @return {string}
 */
ol.geom.Polygon.prototype.getType = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @param {!Array<?>} extent
 * @return {boolean}
 */
ol.geom.Polygon.prototype.intersectsExtent = function(extent) {};

/**
 * Set the coordinates of the polygon.
 * \@api stable
 * @param {!Array<!Array<!Array<?>>>} coordinates
 * @param {string=} opt_layout
 * @return {void}
 */
ol.geom.Polygon.prototype.setCoordinates = function(coordinates, opt_layout) {};

/**
 * Create an approximation of a circle on the surface of a sphere.
 *     the polygon vertices.
 *     polygon. Default is `32`.
 * \@api stable
 * @param {!ol.Sphere} sphere
 * @param {!Array<?>} center
 * @param {number} radius
 * @param {number=} opt_n
 * @return {!ol.geom.Polygon}
 */
ol.geom.Polygon.circular = function(sphere, center, radius, opt_n) {};

/**
 * Create a polygon from an extent. The layout used is `XY`.
 * \@api
 * @param {!Array<?>} extent
 * @return {!ol.geom.Polygon}
 */
ol.geom.Polygon.fromExtent = function(extent) {};

/**
 * Create a regular polygon from a circle.
 *     radians. Default is 0.
 * \@api
 * @param {!ol.geom.Circle} circle
 * @param {number=} opt_sides
 * @param {number=} opt_angle
 * @return {!ol.geom.Polygon}
 */
ol.geom.Polygon.fromCircle = function(circle, opt_sides, opt_angle) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 * 
 * \@api stable
 */
ol.geom.SimpleGeometry = function() {};

/**
 * Return the first coordinate of the geometry.
 * \@api stable
 * @return {!Array<?>}
 */
ol.geom.SimpleGeometry.prototype.getFirstCoordinate = function() {};

/**
 * Return the last coordinate of the geometry.
 * \@api stable
 * @return {!Array<?>}
 */
ol.geom.SimpleGeometry.prototype.getLastCoordinate = function() {};

/**
 * Return the {\@link ol.geom.GeometryLayout layout} of the geometry.
 * \@api stable
 * @return {string}
 */
ol.geom.SimpleGeometry.prototype.getLayout = function() {};

/**
 * @inheritDoc
 * \@api stable
 * @param {function(!Array<number>, !Array<number>, number): !Array<number>} transformFn
 * @return {void}
 */
ol.geom.SimpleGeometry.prototype.applyTransform = function(transformFn) {};

/**
 * @inheritDoc
 * \@api stable
 * @param {number} deltaX
 * @param {number} deltaY
 * @return {void}
 */
ol.geom.SimpleGeometry.prototype.translate = function(deltaX, deltaY) {};

/**
 * @constructor
 * @struct
 * Render a grid for a coordinate system on a map.
 * \@api
 * @param {!olx.GraticuleOptions=} opt_options
 */
ol.Graticule = function(opt_options) {};

/**
 * Get the map associated with this graticule.
 * \@api
 * @return {!ol.Map}
 */
ol.Graticule.prototype.getMap = function() {};

/**
 * Get the list of meridians.  Meridians are lines of equal longitude.
 * \@api
 * @return {!Array<!ol.geom.LineString>}
 */
ol.Graticule.prototype.getMeridians = function() {};

/**
 * Get the list of parallels.  Pallels are lines of equal latitude.
 * \@api
 * @return {!Array<!ol.geom.LineString>}
 */
ol.Graticule.prototype.getParallels = function() {};

/**
 * Set the map for this graticule.  The graticule will be rendered on the
 * provided map.
 * \@api
 * @param {!ol.Map} map
 * @return {void}
 */
ol.Graticule.prototype.setMap = function(map) {};
/** @const */
ol.has = {};
 /** @type {number} */
ol.has.DEVICE_PIXEL_RATIO;
 /** @type {boolean} */
ol.has.CANVAS;
 /** @type {boolean} */
ol.has.DEVICE_ORIENTATION;
 /** @type {boolean} */
ol.has.GEOLOCATION;
 /** @type {boolean} */
ol.has.TOUCH;
 /** @type {boolean} */
ol.has.WEBGL;

/**
 * @constructor
 * @struct
 * @param {!Array<?>} extent
 * @param {number} resolution
 * @param {number} pixelRatio
 * @param {!Array<!ol.Attribution>} attributions
 * @param {string} src
 * @param {string=} crossOrigin
 * @param {function(!ol.Image, string): void=} imageLoadFunction
 */
ol.Image = function(extent, resolution, pixelRatio, attributions, src, crossOrigin, imageLoadFunction) {};

/**
 * Get the HTML image element (may be a Canvas, Image, or Video).
 * \@api
 * @param {!Object=} opt_context
 * @return {(!ol.Image|!HTMLCanvasElement|!HTMLVideoElement)}
 */
ol.Image.prototype.getImage = function(opt_context) {};

/**
 * Load the image or retry if loading previously failed.
 * Loading is taken care of by the tile queue, and calling this method is
 * only needed for preloading or for reloading in case of an error.
 * \@api
 * @return {void}
 */
ol.Image.prototype.load = function() {};

/**
 * @constructor
 * @struct
 * @param {!Array<?>} extent
 * @param {number} resolution
 * @param {number} pixelRatio
 * @param {number} state
 * @param {!Array<!ol.Attribution>} attributions
 */
ol.ImageBase = function(extent, resolution, pixelRatio, state, attributions) {};

/** @typedef {number} */
ol.ImageState;

/**
 * @constructor
 * @struct
 * @param {!Array<?>} tileCoord
 * @param {number} state
 * @param {string} src
 * @param {string=} crossOrigin
 * @param {function(!ol.Tile, string): void=} tileLoadFunction
 */
ol.ImageTile = function(tileCoord, state, src, crossOrigin, tileLoadFunction) {};

/**
 * Get the image element for this tile.
 * @inheritDoc
 * \@api
 * @param {!Object=} opt_context
 * @return {(!HTMLCanvasElement|!HTMLVideoElement|!HTMLImageElement)}
 */
ol.ImageTile.prototype.getImage = function(opt_context) {};

/**
 * Inherit the prototype methods from one constructor into another.
 * 
 * Usage:
 * 
 *     function ParentClass(a, b) { }
 *     ParentClass.prototype.foo = function(a) { }
 * 
 *     function ChildClass(a, b, c) {
 *       // Call parent constructor
 *       ParentClass.call(this, a, b);
 *     }
 *     ol.inherits(ChildClass, ParentClass);
 * 
 *     var child = new ChildClass('a', 'b', 'see');
 *     child.foo(); // This works.
 * 
 * \@api
 * @param {function(): ?} childCtor
 * @param {function(): ?} parentCtor
 * @return {void}
 */
ol.inherits = function(childCtor, parentCtor) {};
/** @const */
ol.interaction = {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Allows the user to zoom by double-clicking on the map.
 * 
 * \@api stable
 * @param {!olx.interaction.DoubleClickZoomOptions=} opt_options
 */
ol.interaction.DoubleClickZoom = function(opt_options) {};

/**
 * Handles the {\@link ol.MapBrowserEvent map browser event} (if it was a
 * doubleclick) and eventually zooms the map.
 * \@api
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.interaction.DoubleClickZoom.handleEvent = function(mapBrowserEvent) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Handles input of vector data by drag and drop.
 * 
 * \@fires ol.interaction.DragAndDropEvent
 * \@api stable
 * @param {!olx.interaction.DragAndDropOptions=} opt_options
 */
ol.interaction.DragAndDrop = function(opt_options) {};
 /** @type {?} */
ol.interaction.DragAndDrop.handleEvent;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Events emitted by {\@link ol.interaction.DragAndDrop} instances are instances
 * of this type.
 * 
 * @param {string} type
 * @param {!File} file
 * @param {!Array<!ol.Feature>=} opt_features
 * @param {!ol.proj.Projection=} opt_projection
 */
ol.interaction.DragAndDrop.Event = function(type, file, opt_features, opt_projection) {};
 /** @type {!Array<!ol.Feature>} */
ol.interaction.DragAndDrop.Event.prototype.features;
 /** @type {!File} */
ol.interaction.DragAndDrop.Event.prototype.file;
 /** @type {!ol.proj.Projection} */
ol.interaction.DragAndDrop.Event.prototype.projection;

/** @typedef {string} */
ol.interaction.DragAndDropEventType;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {\@link ol.events.condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {\@link ol.interaction.DragZoom} and
 * {\@link ol.interaction.DragRotateAndZoom}).
 * 
 * This interaction is only supported for mouse devices.
 * 
 * \@fires ol.DragBoxEvent
 * \@api stable
 * @param {!olx.interaction.DragBoxOptions=} opt_options
 */
ol.interaction.DragBox = function(opt_options) {};

/**
 * Returns geometry of last drawn box.
 * \@api stable
 * @return {!ol.geom.Polygon}
 */
ol.interaction.DragBox.prototype.getGeometry = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Events emitted by {\@link ol.interaction.DragBox} instances are instances of
 * this type.
 * 
 * @param {string} type
 * @param {!Array<?>} coordinate
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 */
ol.interaction.DragBox.Event = function(type, coordinate, mapBrowserEvent) {};
 /** @type {!Array<?>} */
ol.interaction.DragBox.Event.prototype.coordinate;
 /** @type {!ol.MapBrowserEvent} */
ol.interaction.DragBox.Event.prototype.mapBrowserEvent;

/** @typedef {string} */
ol.interaction.DragBoxEventType;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Allows the user to pan the map by dragging the map.
 * 
 * \@api stable
 * @param {!olx.interaction.DragPanOptions=} opt_options
 */
ol.interaction.DragPan = function(opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {\@link ol.events.condition} that limits
 * it to when the alt and shift keys are held down.
 * 
 * This interaction is only supported for mouse devices.
 * 
 * \@api stable
 * @param {!olx.interaction.DragRotateOptions=} opt_options
 */
ol.interaction.DragRotate = function(opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Allows the user to zoom and rotate the map by clicking and dragging
 * on the map.  By default, this interaction is limited to when the shift
 * key is held down.
 * 
 * This interaction is only supported for mouse devices.
 * 
 * And this interaction is not included in the default interactions.
 * 
 * \@api stable
 * @param {!olx.interaction.DragRotateAndZoomOptions=} opt_options
 */
ol.interaction.DragRotateAndZoom = function(opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {\@link ol.events.condition} that limits
 * it to when a key, shift by default, is held down.
 * 
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * 
 * \@api stable
 * @param {!olx.interaction.DragZoomOptions=} opt_options
 */
ol.interaction.DragZoom = function(opt_options) {};
/** @const */
ol.interaction.Draw = {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Events emitted by {\@link ol.interaction.Draw} instances are instances of
 * this type.
 * 
 * @param {string} type
 * @param {!ol.Feature} feature
 */
ol.interaction.Draw.Event = function(type, feature) {};
 /** @type {!ol.Feature} */
ol.interaction.Draw.Event.prototype.feature;

/** @typedef {string} */
ol.interaction.DrawEventType;

/**
 * Remove last point of the feature currently being drawn.
 * \@api
 * @return {void}
 */
ol.interaction.Draw.prototype.removeLastPoint = function() {};

/**
 * Stop drawing and add the sketch feature to the target layer.
 * The {\@link ol.interaction.DrawEventType.DRAWEND} event is dispatched before
 * inserting the feature.
 * \@api
 * @return {void}
 */
ol.interaction.Draw.prototype.finishDrawing = function() {};

/**
 * Extend an existing geometry by adding additional points. This only works
 * on features with `LineString` geometries, where the interaction will
 * extend lines by adding points to the end of the coordinates array.
 * \@api
 * @param {!ol.Feature} feature
 * @return {void}
 */
ol.interaction.Draw.prototype.extend = function(feature) {};

/**
 * Create a `geometryFunction` for `mode: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of an
 * `ol.geom.Circle` geometry.
 *     32.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 *     polygon.
 * \@api
 * @param {number=} opt_sides
 * @param {number=} opt_angle
 * @return {function((!Array<?>|!Array<!Array<?>>|!Array<!Array<!Array<?>>>), !ol.geom.SimpleGeometry): !ol.geom.SimpleGeometry}
 */
ol.interaction.Draw.createRegularPolygon = function(opt_sides, opt_angle) {};

/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {\@link ol.interaction.Interaction} instances and insert them into a
 * {\@link ol.Collection} in the order you want before creating your
 * {\@link ol.Map} instance. The default set of interactions, in sequence, is:
 * * {\@link ol.interaction.DragRotate}
 * * {\@link ol.interaction.DoubleClickZoom}
 * * {\@link ol.interaction.DragPan}
 * * {\@link ol.interaction.PinchRotate}
 * * {\@link ol.interaction.PinchZoom}
 * * {\@link ol.interaction.KeyboardPan}
 * * {\@link ol.interaction.KeyboardZoom}
 * * {\@link ol.interaction.MouseWheelZoom}
 * * {\@link ol.interaction.DragZoom}
 * 
 * interactions to be used with the ol.Map constructor's interactions option.
 * \@api stable
 * @param {!olx.interaction.DefaultsOptions=} opt_options
 * @return {!ol.Collection<!ol.interaction.Interaction>}
 */
ol.interaction.defaults = function(opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {\@link ol.interaction.KeyboardZoom} is functionally the same as
 * {\@link ol.control.Zoom}, but triggered by a keyboard event not a button
 * element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * 
 * \@api
 * @param {!olx.interaction.InteractionOptions} options
 */
ol.interaction.Interaction = function(options) {};

/**
 * Return whether the interaction is currently active.
 * \@observable
 * \@api
 * @return {boolean}
 */
ol.interaction.Interaction.prototype.getActive = function() {};

/**
 * Get the map associated with this interaction.
 * \@api
 * @return {!ol.Map}
 */
ol.interaction.Interaction.prototype.getMap = function() {};

/**
 * Activate or deactivate the interaction.
 * \@observable
 * \@api
 * @param {boolean} active
 * @return {void}
 */
ol.interaction.Interaction.prototype.setActive = function(active) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {\@link ol.Map}. `document` never loses focus but, for any other element,
 * focus will have to be on, and returned to, this element if the keys are to
 * function.
 * See also {\@link ol.interaction.KeyboardZoom}.
 * 
 * \@api stable
 * @param {!olx.interaction.KeyboardPanOptions=} opt_options
 */
ol.interaction.KeyboardPan = function(opt_options) {};

/**
 * Handles the {\@link ol.MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides the direction to pan to (if an arrow key was
 * pressed).
 * \@api
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.interaction.KeyboardPan.handleEvent = function(mapBrowserEvent) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {\@link ol.Map}. `document` never loses focus but, for any other element,
 * focus will have to be on, and returned to, this element if the keys are to
 * function.
 * See also {\@link ol.interaction.KeyboardPan}.
 * 
 * \@api stable
 * @param {!olx.interaction.KeyboardZoomOptions=} opt_options
 */
ol.interaction.KeyboardZoom = function(opt_options) {};

/**
 * Handles the {\@link ol.MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
 * key pressed was '+' or '-').
 * \@api
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.interaction.KeyboardZoom.handleEvent = function(mapBrowserEvent) {};
/** @const */
ol.interaction.Modify = {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Events emitted by {\@link ol.interaction.Modify} instances are instances of
 * this type.
 * 
 *     {\@link ol.MapBrowserPointerEvent}.
 * @param {string} type
 * @param {!ol.Collection<!ol.Feature>} features
 * @param {!ol.MapBrowserPointerEvent} mapBrowserPointerEvent
 */
ol.interaction.Modify.Event = function(type, features, mapBrowserPointerEvent) {};
 /** @type {!ol.Collection<!ol.Feature>} */
ol.interaction.Modify.Event.prototype.features;
 /** @type {!ol.MapBrowserEvent} */
ol.interaction.Modify.Event.prototype.mapBrowserEvent;

/**
 * Removes the vertex currently being pointed.
 * \@api
 * @return {boolean}
 */
ol.interaction.Modify.prototype.removePoint = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * 
 * \@api stable
 * @param {!olx.interaction.MouseWheelZoomOptions=} opt_options
 */
ol.interaction.MouseWheelZoom = function(opt_options) {};

/**
 * Handles the {\@link ol.MapBrowserEvent map browser event} (if it was a
 * mousewheel-event) and eventually zooms the map.
 * \@api
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.interaction.MouseWheelZoom.handleEvent = function(mapBrowserEvent) {};

/**
 * Enable or disable using the mouse's location as an anchor when zooming
 * to zoom to the center of the map
 * \@api
 * @param {boolean} useAnchor
 * @return {void}
 */
ol.interaction.MouseWheelZoom.prototype.setMouseAnchor = function(useAnchor) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * 
 * \@api stable
 * @param {!olx.interaction.PinchRotateOptions=} opt_options
 */
ol.interaction.PinchRotate = function(opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * 
 * \@api stable
 * @param {!olx.interaction.PinchZoomOptions=} opt_options
 */
ol.interaction.PinchZoom = function(opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 * 
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * 
 * \@api
 * @param {!olx.interaction.PointerOptions=} opt_options
 */
ol.interaction.Pointer = function(opt_options) {};

/**
 * Handles the {\@link ol.MapBrowserEvent map browser event} and may call into
 * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
 * detected.
 * \@api
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.interaction.Pointer.handleEvent = function(mapBrowserEvent) {};
/** @const */
ol.interaction.Select = {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Events emitted by {\@link ol.interaction.Select} instances are instances of
 * this type.
 * 
 *     {\@link ol.MapBrowserEvent}.
 * @param {string} type
 * @param {!Array<!ol.Feature>} selected
 * @param {!Array<!ol.Feature>} deselected
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 */
ol.interaction.Select.Event = function(type, selected, deselected, mapBrowserEvent) {};
 /** @type {!Array<!ol.Feature>} */
ol.interaction.Select.Event.prototype.selected;
 /** @type {!Array<!ol.Feature>} */
ol.interaction.Select.Event.prototype.deselected;
 /** @type {!ol.MapBrowserEvent} */
ol.interaction.Select.Event.prototype.mapBrowserEvent;

/**
 * Get the selected features.
 * \@api stable
 * @return {!ol.Collection<!ol.Feature>}
 */
ol.interaction.Select.prototype.getFeatures = function() {};

/**
 * Returns the associated {\@link ol.layer.Vector vectorlayer} of
 * the (last) selected feature. Note that this will not work with any
 * programmatic method like pushing features to
 * {\@link ol.interaction.Select#getFeatures collection}.
 * \@api
 * @param {(!ol.Feature|!ol.render.Feature)} feature
 * @return {!ol.layer.Vector}
 */
ol.interaction.Select.prototype.getLayer = function(feature) {};

/**
 * Handles the {\@link ol.MapBrowserEvent map browser event} and may change the
 * selected state of features.
 * \@api
 * @param {!ol.MapBrowserEvent} mapBrowserEvent
 * @return {boolean}
 */
ol.interaction.Select.handleEvent = function(mapBrowserEvent) {};

/**
 * Remove the interaction from its current map, if any,  and attach it to a new
 * map, if any. Pass `null` to just remove the interaction from the current map.
 * \@api stable
 * @param {!ol.Map} map
 * @return {void}
 */
ol.interaction.Select.prototype.setMap = function(map) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Handles snapping of vector features while modifying or drawing them.  The
 * features can come from a {\@link ol.source.Vector} or {\@link ol.Collection}
 * Any interaction object that allows the user to interact
 * with the features using the mouse can benefit from the snapping, as long
 * as it is added before.
 * 
 * The snap interaction modifies map browser event `coordinate` and `pixel`
 * properties to force the snap to occur to any interaction that them.
 * 
 * Example:
 * 
 *     var snap = new ol.interaction.Snap({
 *       source: source
 *     });
 * 
 * \@api
 * @param {!olx.interaction.SnapOptions=} opt_options
 */
ol.interaction.Snap = function(opt_options) {};

/**
 * Add a feature to the collection of features that we may snap to.
 *     Defaults to `true`.
 * \@api
 * @param {!ol.Feature} feature
 * @param {boolean=} opt_listen
 * @return {void}
 */
ol.interaction.Snap.prototype.addFeature = function(feature, opt_listen) {};

/**
 * Remove a feature from the collection of features that we may snap to.
 *     or not. Defaults to `true`.
 * \@api
 * @param {!ol.Feature} feature
 * @param {boolean=} opt_unlisten
 * @return {void}
 */
ol.interaction.Snap.prototype.removeFeature = function(feature, opt_unlisten) {};
/** @const */
ol.interaction.Translate = {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Events emitted by {\@link ol.interaction.Translate} instances are instances of
 * this type.
 * 
 * @param {string} type
 * @param {!ol.Collection<!ol.Feature>} features
 * @param {!Array<?>} coordinate
 */
ol.interaction.Translate.Event = function(type, features, coordinate) {};
 /** @type {!ol.Collection<!ol.Feature>} */
ol.interaction.Translate.Event.prototype.features;
 /** @type {!Array<?>} */
ol.interaction.Translate.Event.prototype.coordinate;

/** @typedef {string} */
ol.interaction.TranslateEventType;

/**
 * @return {number}
 */
ol.interaction.Translate.prototype.getHitTolerance = function() {};

/**
 * @param {number} hitTolerance
 * @return {void}
 */
ol.interaction.Translate.prototype.setHitTolerance = function(hitTolerance) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Implementation of inertial deceleration for map movement.
 * 
 *     initial values (milliseconds).
 * @struct
 * \@api
 * @param {number} decay
 * @param {number} minVelocity
 * @param {number} delay
 */
ol.Kinetic = function(decay, minVelocity, delay) {};
/** @const */
ol.layer = {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with `ol.layer.Base` and all its subclasses, any property set in
 * the options is set as a {\@link ol.Object} property on the layer object, so
 * is observable, and has get/set accessors.
 * 
 * \@api stable
 * @param {!olx.layer.BaseOptions} options
 */
ol.layer.Base = function(options) {};

/**
 * Return the {\@link ol.Extent extent} of the layer or `undefined` if it
 * will be visible regardless of extent.
 * \@observable
 * \@api stable
 * @return {!Array<?>}
 */
ol.layer.Base.prototype.getExtent = function() {};

/**
 * Return the maximum resolution of the layer.
 * \@observable
 * \@api stable
 * @return {number}
 */
ol.layer.Base.prototype.getMaxResolution = function() {};

/**
 * Return the minimum resolution of the layer.
 * \@observable
 * \@api stable
 * @return {number}
 */
ol.layer.Base.prototype.getMinResolution = function() {};

/**
 * Return the opacity of the layer (between 0 and 1).
 * \@observable
 * \@api stable
 * @return {number}
 */
ol.layer.Base.prototype.getOpacity = function() {};

/**
 * Return the visibility of the layer (`true` or `false`).
 * \@observable
 * \@api stable
 * @return {boolean}
 */
ol.layer.Base.prototype.getVisible = function() {};

/**
 * Return the Z-index of the layer, which is used to order layers before
 * rendering. The default Z-index is 0.
 * \@observable
 * \@api
 * @return {number}
 */
ol.layer.Base.prototype.getZIndex = function() {};

/**
 * Set the extent at which the layer is visible.  If `undefined`, the layer
 * will be visible at all extents.
 * \@observable
 * \@api stable
 * @param {!Array<?>} extent
 * @return {void}
 */
ol.layer.Base.prototype.setExtent = function(extent) {};

/**
 * Set the maximum resolution at which the layer is visible.
 * \@observable
 * \@api stable
 * @param {number} maxResolution
 * @return {void}
 */
ol.layer.Base.prototype.setMaxResolution = function(maxResolution) {};

/**
 * Set the minimum resolution at which the layer is visible.
 * \@observable
 * \@api stable
 * @param {number} minResolution
 * @return {void}
 */
ol.layer.Base.prototype.setMinResolution = function(minResolution) {};

/**
 * Set the opacity of the layer, allowed values range from 0 to 1.
 * \@observable
 * \@api stable
 * @param {number} opacity
 * @return {void}
 */
ol.layer.Base.prototype.setOpacity = function(opacity) {};

/**
 * Set the visibility of the layer (`true` or `false`).
 * \@observable
 * \@api stable
 * @param {boolean} visible
 * @return {void}
 */
ol.layer.Base.prototype.setVisible = function(visible) {};

/**
 * Set Z-index of the layer, which is used to order layers before rendering.
 * The default Z-index is 0.
 * \@observable
 * \@api
 * @param {number} zindex
 * @return {void}
 */
ol.layer.Base.prototype.setZIndex = function(zindex) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A {\@link ol.Collection} of layers that are handled together.
 * 
 * A generic `change` event is triggered when the group/Collection changes.
 * 
 * \@api stable
 * @param {!olx.layer.GroupOptions=} opt_options
 */
ol.layer.Group = function(opt_options) {};

/**
 * Returns the {\@link ol.Collection collection} of {\@link ol.layer.Layer layers}
 * in this group.
 *   {\@link ol.layer.Base layers} that are part of this group.
 * \@observable
 * \@api stable
 * @return {!ol.Collection<!ol.layer.Base>}
 */
ol.layer.Group.prototype.getLayers = function() {};

/**
 * Set the {\@link ol.Collection collection} of {\@link ol.layer.Layer layers}
 * in this group.
 *   {\@link ol.layer.Base layers} that are part of this group.
 * \@observable
 * \@api stable
 * @param {!ol.Collection<!ol.layer.Base>} layers
 * @return {void}
 */
ol.layer.Group.prototype.setLayers = function(layers) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Layer for rendering vector data as a heatmap.
 * Note that any property set in the options is set as a {\@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 * 
 * \@fires ol.render.Event
 * \@api
 * @param {!olx.layer.HeatmapOptions=} opt_options
 */
ol.layer.Heatmap = function(opt_options) {};

/**
 * Return the blur size in pixels.
 * \@api
 * \@observable
 * @return {number}
 */
ol.layer.Heatmap.prototype.getBlur = function() {};

/**
 * Return the gradient colors as array of strings.
 * \@api
 * \@observable
 * @return {!Array<string>}
 */
ol.layer.Heatmap.prototype.getGradient = function() {};

/**
 * Return the size of the radius in pixels.
 * \@api
 * \@observable
 * @return {number}
 */
ol.layer.Heatmap.prototype.getRadius = function() {};

/**
 * Set the blur size in pixels.
 * \@api
 * \@observable
 * @param {number} blur
 * @return {void}
 */
ol.layer.Heatmap.prototype.setBlur = function(blur) {};

/**
 * Set the gradient colors as array of strings.
 * \@api
 * \@observable
 * @param {!Array<string>} colors
 * @return {void}
 */
ol.layer.Heatmap.prototype.setGradient = function(colors) {};

/**
 * Set the size of the radius in pixels.
 * \@api
 * \@observable
 * @param {number} radius
 * @return {void}
 */
ol.layer.Heatmap.prototype.setRadius = function(radius) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {\@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 * 
 * \@fires ol.render.Event
 * \@api stable
 * @param {!olx.layer.ImageOptions=} opt_options
 */
ol.layer.Image = function(opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 * 
 * Layers are usually added to a map with {\@link ol.Map#addLayer}. Components
 * like {\@link ol.interaction.Select} use unmanaged layers internally. These
 * unmanaged layers are associated with the map using
 * {\@link ol.layer.Layer#setMap} instead.
 * 
 * A generic `change` event is fired when the state of the source changes.
 * 
 * \@fires ol.render.Event
 * \@api stable
 * @param {!olx.layer.LayerOptions} options
 */
ol.layer.Layer = function(options) {};

/**
 * Get the layer source.
 * \@observable
 * \@api stable
 * @return {!ol.source.Source}
 */
ol.layer.Layer.prototype.getSource = function() {};

/**
 * Sets the layer to be rendered on top of other layers on a map. The map will
 * not manage this layer in its layers collection, and the callback in
 * {\@link ol.Map#forEachLayerAtPixel} will receive `null` as layer. This
 * is useful for temporary layers. To remove an unmanaged layer from the map,
 * use `#setMap(null)`.
 * 
 * To add the layer to a map and have it managed by the map, use
 * {\@link ol.Map#addLayer} instead.
 * \@api
 * @param {!ol.Map} map
 * @return {void}
 */
ol.layer.Layer.prototype.setMap = function(map) {};

/**
 * Set the layer source.
 * \@observable
 * \@api stable
 * @param {!ol.source.Source} source
 * @return {void}
 */
ol.layer.Layer.prototype.setSource = function(source) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {\@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 * 
 * \@fires ol.render.Event
 * \@api stable
 * @param {!olx.layer.TileOptions=} opt_options
 */
ol.layer.Tile = function(opt_options) {};

/**
 * Return the level as number to which we will preload tiles up to.
 * \@observable
 * \@api
 * @return {number}
 */
ol.layer.Tile.prototype.getPreload = function() {};

/**
 * Set the level as number to which we will preload tiles up to.
 * \@observable
 * \@api
 * @param {number} preload
 * @return {void}
 */
ol.layer.Tile.prototype.setPreload = function(preload) {};

/**
 * Whether we use interim tiles on error.
 * \@observable
 * \@api
 * @return {boolean}
 */
ol.layer.Tile.prototype.getUseInterimTilesOnError = function() {};

/**
 * Set whether we use interim tiles on error.
 * \@observable
 * \@api
 * @param {boolean} useInterimTilesOnError
 * @return {void}
 */
ol.layer.Tile.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {\@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 * 
 * \@fires ol.render.Event
 * \@api stable
 * @param {!olx.layer.VectorOptions=} opt_options
 */
ol.layer.Vector = function(opt_options) {};

/**
 * Return the associated {\@link ol.source.Vector vectorsource} of the layer.
 * \@api stable
 * @return {!ol.source.Vector}
 */
ol.layer.Vector.prototype.getSource = function() {};

/**
 * Get the style for features.  This returns whatever was passed to the `style`
 * option at construction or to the `setStyle` method.
 *     Layer style.
 * \@api stable
 * @return {(!ol.style.Style|!Array<!ol.style.Style>|function((!ol.Feature|!ol.render.Feature), number): (!ol.style.Style|!Array<!ol.style.Style>))}
 */
ol.layer.Vector.prototype.getStyle = function() {};

/**
 * Get the style function.
 * \@api stable
 * @return {function((!ol.Feature|!ol.render.Feature), number): (!ol.style.Style|!Array<!ol.style.Style>)}
 */
ol.layer.Vector.prototype.getStyleFunction = function() {};

/**
 * Set the style for features.  This can be a single style object, an array
 * of styles, or a function that takes a feature and resolution and returns
 * an array of styles. If it is `undefined` the default style is used. If
 * it is `null` the layer has no style (a `null` style), so only features
 * that have their own styles will be rendered in the layer. See
 * {\@link ol.style} for information on the default style.
 *     style Layer style.
 * \@api stable
 * @param {(!ol.style.Style|!Array<!ol.style.Style>|function((!ol.Feature|!ol.render.Feature), number): (!ol.style.Style|!Array<!ol.style.Style>))} style
 * @return {void}
 */
ol.layer.Vector.prototype.setStyle = function(style) {};

/** @typedef {string} */
ol.layer.VectorTileRenderType;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Layer for vector tile data that is rendered client-side.
 * Note that any property set in the options is set as a {\@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 * 
 * \@api
 * @param {!olx.layer.VectorTileOptions=} opt_options
 */
ol.layer.VectorTile = function(opt_options) {};

/**
 * Return the level as number to which we will preload tiles up to.
 * \@observable
 * \@api
 * @return {number}
 */
ol.layer.VectorTile.prototype.getPreload = function() {};

/**
 * Whether we use interim tiles on error.
 * \@observable
 * \@api
 * @return {boolean}
 */
ol.layer.VectorTile.prototype.getUseInterimTilesOnError = function() {};

/**
 * Set the level as number to which we will preload tiles up to.
 * \@observable
 * \@api
 * @param {number} preload
 * @return {void}
 */
ol.layer.VectorTile.prototype.setPreload = function(preload) {};

/**
 * Set whether we use interim tiles on error.
 * \@observable
 * \@api
 * @param {boolean} useInterimTilesOnError
 * @return {void}
 */
ol.layer.VectorTile.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {};
/** @const */
ol.loadingstrategy = {};

/**
 * Strategy function for loading all features with a single request.
 * \@api
 * @param {!Array<?>} extent
 * @param {number} resolution
 * @return {!Array<!Array<?>>}
 */
ol.loadingstrategy.all = function(extent, resolution) {};

/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * \@api
 * @param {!Array<?>} extent
 * @param {number} resolution
 * @return {!Array<!Array<?>>}
 */
ol.loadingstrategy.bbox = function(extent, resolution) {};

/**
 * Creates a strategy function for loading features based on a tile grid.
 * \@api
 * @param {!ol.tilegrid.TileGrid} tileGrid
 * @return {function(!Array<?>, number): !Array<!Array<?>>}
 */
ol.loadingstrategy.tile = function(tileGrid) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 * 
 *     var map = new ol.Map({
 *       view: new ol.View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new ol.layer.Tile({
 *           source: new ol.source.OSM()
 *         })
 *       ],
 *       target: 'map'
 *     });
 * 
 * The above snippet creates a map using a {\@link ol.layer.Tile} to display
 * {\@link ol.source.OSM} OSM data and render it to a DOM element with the
 * id `map`.
 * 
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {\@link ol.Overlay} for the difference). The map itself is placed in
 * a further element within the viewport, either DOM or Canvas, depending on the
 * renderer.
 * 
 * Layers are stored as a `ol.Collection` in layerGroups. A top-level group is
 * provided by the library. This is what is accessed by `getLayerGroup` and
 * `setLayerGroup`. Layers entered in the options are added to this group, and
 * `addLayer` and `removeLayer` change the layer collection in the group.
 * `getLayers` is a convenience function for `getLayerGroup().getLayers()`.
 * Note that `ol.layer.Group` is a subclass of `ol.layer.Base`, so layers
 * entered in the options or added with `addLayer` can be groups, which can
 * contain further groups, and so on.
 * 
 * \@fires ol.MapBrowserEvent
 * \@fires ol.MapEvent
 * \@fires ol.render.Event#postcompose
 * \@fires ol.render.Event#precompose
 * \@api stable
 * @param {!olx.MapOptions} options
 */
ol.Map = function(options) {};

/**
 * Add the given control to the map.
 * \@api stable
 * @param {!ol.control.Control} control
 * @return {void}
 */
ol.Map.prototype.addControl = function(control) {};

/**
 * Add the given interaction to the map.
 * \@api stable
 * @param {!ol.interaction.Interaction} interaction
 * @return {void}
 */
ol.Map.prototype.addInteraction = function(interaction) {};

/**
 * Adds the given layer to the top of this map. If you want to add a layer
 * elsewhere in the stack, use `getLayers()` and the methods available on
 * {\@link ol.Collection}.
 * \@api stable
 * @param {!ol.layer.Base} layer
 * @return {void}
 */
ol.Map.prototype.addLayer = function(layer) {};

/**
 * Add the given overlay to the map.
 * \@api stable
 * @param {!ol.Overlay} overlay
 * @return {void}
 */
ol.Map.prototype.addOverlay = function(overlay) {};

/**
 * Add functions to be called before rendering. This can be used for attaching
 * animations before updating the map's view.  The {\@link ol.animation}
 * namespace provides several static methods for creating prerender functions.
 * \@api
 * @param {function(!ol.Map, !olx.FrameState): boolean} var_args
 * @return {void}
 */
ol.Map.prototype.beforeRender = function(var_args) {};

/**
 * Detect features that intersect a pixel on the viewport, and execute a
 * callback with each intersecting feature. Layers included in the detection can
 * be configured through `opt_layerFilter`.
 *     ol.layer.Layer): T} callback Feature callback. The callback will be
 *     called with two arguments. The first argument is one
 *     {\@link ol.Feature feature} or
 *     {\@link ol.render.Feature render feature} at the pixel, the second is
 *     the {\@link ol.layer.Layer layer} of the feature and will be null for
 *     unmanaged layers. To stop detection, callback functions can return a
 *     truthy value.
 *     filter function. The filter function will receive one argument, the
 *     {\@link ol.layer.Layer layer-candidate} and it should return a boolean
 *     value. Only layers which are visible and for which this function returns
 *     `true` will be tested for features. By default, all visible layers will
 *     be tested.
 * callback execution, or the first truthy callback return value.
 * \@api stable
 * @template T
 * @param {!Array<?>} pixel
 * @param {function((!ol.Feature|!ol.render.Feature), !ol.layer.Layer): T} callback
 * @param {function(!ol.layer.Layer): boolean=} opt_layerFilter
 * @return {T}
 */
ol.Map.prototype.forEachFeatureAtPixel = function(pixel, callback, opt_layerFilter) {};

/**
 * Detect layers that have a color value at a pixel on the viewport, and
 * execute a callback with each matching layer. Layers included in the
 * detection can be configured through `opt_layerFilter`.
 *     callback. This callback will recieve two arguments: first is the
 *     {\@link ol.layer.Layer layer}, second argument is {\@link ol.Color}
 *     and will be null for layer types that do not currently support this
 *     argument. To stop detection callback functions can return a truthy value.
 *     filter function. The filter function will receive one argument, the
 *     {\@link ol.layer.Layer layer-candidate} and it should return a boolean
 *     value. Only layers which are visible and for which this function returns
 *     `true` will be tested for features. By default, all visible layers will
 *     be tested.
 * callback execution, or the first truthy callback return value.
 * \@api stable
 * @template S, T, U
 * @param {!Array<?>} pixel
 * @param {function(!ol.layer.Layer, (!Array<?>|!Uint8Array|!Uint8ClampedArray)): T} callback
 * @param {S=} opt_this
 * @param {function(!ol.layer.Layer): boolean=} opt_layerFilter
 * @param {U=} opt_this2
 * @return {T}
 */
ol.Map.prototype.forEachLayerAtPixel = function(pixel, callback, opt_this, opt_layerFilter, opt_this2) {};

/**
 * Detect if features intersect a pixel on the viewport. Layers included in the
 * detection can be configured through `opt_layerFilter`.
 *     filter function. The filter function will receive one argument, the
 *     {\@link ol.layer.Layer layer-candidate} and it should return a boolean
 *     value. Only layers which are visible and for which this function returns
 *     `true` will be tested for features. By default, all visible layers will
 *     be tested.
 * \@api
 * @param {!Array<?>} pixel
 * @param {function(!ol.layer.Layer): boolean=} opt_layerFilter
 * @return {boolean}
 */
ol.Map.prototype.hasFeatureAtPixel = function(pixel, opt_layerFilter) {};

/**
 * Returns the geographical coordinate for a browser event.
 * \@api stable
 * @param {!Event} event
 * @return {!Array<?>}
 */
ol.Map.prototype.getEventCoordinate = function(event) {};

/**
 * Returns the map pixel position for a browser event relative to the viewport.
 * \@api stable
 * @param {!Event} event
 * @return {!Array<?>}
 */
ol.Map.prototype.getEventPixel = function(event) {};

/**
 * Get the target in which this map is rendered.
 * Note that this returns what is entered as an option or in setTarget:
 * if that was an element, it returns an element; if a string, it returns that.
 *     map is rendered in.
 * \@observable
 * \@api stable
 * @return {(string|!Element)}
 */
ol.Map.prototype.getTarget = function() {};

/**
 * Get the DOM element into which this map is rendered. In contrast to
 * `getTarget` this method always return an `Element`, or `null` if the
 * map has no target.
 * \@api
 * @return {!Element}
 */
ol.Map.prototype.getTargetElement = function() {};

/**
 * Get the coordinate for a given pixel.  This returns a coordinate in the
 * map view projection.
 * \@api stable
 * @param {!Array<?>} pixel
 * @return {!Array<?>}
 */
ol.Map.prototype.getCoordinateFromPixel = function(pixel) {};

/**
 * Get the map controls. Modifying this collection changes the controls
 * associated with the map.
 * \@api stable
 * @return {!ol.Collection<!ol.control.Control>}
 */
ol.Map.prototype.getControls = function() {};

/**
 * Get the map overlays. Modifying this collection changes the overlays
 * associated with the map.
 * \@api stable
 * @return {!ol.Collection<!ol.Overlay>}
 */
ol.Map.prototype.getOverlays = function() {};

/**
 * Get an overlay by its identifier (the value returned by overlay.getId()).
 * Note that the index treats string and numeric identifiers as the same. So
 * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
 * \@api
 * @param {(string|number)} id
 * @return {!ol.Overlay}
 */
ol.Map.prototype.getOverlayById = function(id) {};

/**
 * Get the map interactions. Modifying this collection changes the interactions
 * associated with the map.
 * 
 * Interactions are used for e.g. pan, zoom and rotate.
 * \@api stable
 * @return {!ol.Collection<!ol.interaction.Interaction>}
 */
ol.Map.prototype.getInteractions = function() {};

/**
 * Get the layergroup associated with this map.
 * \@observable
 * \@api stable
 * @return {!ol.layer.Group}
 */
ol.Map.prototype.getLayerGroup = function() {};

/**
 * Get the collection of layers associated with this map.
 * \@api stable
 * @return {!ol.Collection<!ol.layer.Base>}
 */
ol.Map.prototype.getLayers = function() {};

/**
 * Get the pixel for a coordinate.  This takes a coordinate in the map view
 * projection and returns the corresponding pixel.
 * \@api stable
 * @param {!Array<?>} coordinate
 * @return {!Array<?>}
 */
ol.Map.prototype.getPixelFromCoordinate = function(coordinate) {};

/**
 * Get the size of this map.
 * \@observable
 * \@api stable
 * @return {!Array<?>}
 */
ol.Map.prototype.getSize = function() {};

/**
 * Get the view associated with this map. A view manages properties such as
 * center and resolution.
 * \@observable
 * \@api stable
 * @return {!ol.View}
 */
ol.Map.prototype.getView = function() {};

/**
 * Get the element that serves as the map viewport.
 * \@api stable
 * @return {!Element}
 */
ol.Map.prototype.getViewport = function() {};

/**
 * Requests an immediate render in a synchronous manner.
 * \@api stable
 * @return {void}
 */
ol.Map.prototype.renderSync = function() {};

/**
 * Request a map rendering (at the next animation frame).
 * \@api stable
 * @return {void}
 */
ol.Map.prototype.render = function() {};

/**
 * Remove the given control from the map.
 *     if the control was not found).
 * \@api stable
 * @param {!ol.control.Control} control
 * @return {!ol.control.Control}
 */
ol.Map.prototype.removeControl = function(control) {};

/**
 * Remove the given interaction from the map.
 *     undefined if the interaction was not found).
 * \@api stable
 * @param {!ol.interaction.Interaction} interaction
 * @return {!ol.interaction.Interaction}
 */
ol.Map.prototype.removeInteraction = function(interaction) {};

/**
 * Removes the given layer from the map.
 *     layer was not found).
 * \@api stable
 * @param {!ol.layer.Base} layer
 * @return {!ol.layer.Base}
 */
ol.Map.prototype.removeLayer = function(layer) {};

/**
 * Remove the given overlay from the map.
 *     if the overlay was not found).
 * \@api stable
 * @param {!ol.Overlay} overlay
 * @return {!ol.Overlay}
 */
ol.Map.prototype.removeOverlay = function(overlay) {};

/**
 * Sets the layergroup of this map.
 *     this map.
 * \@observable
 * \@api stable
 * @param {!ol.layer.Group} layerGroup
 * @return {void}
 */
ol.Map.prototype.setLayerGroup = function(layerGroup) {};

/**
 * Set the size of this map.
 * \@observable
 * \@api
 * @param {!Array<?>} size
 * @return {void}
 */
ol.Map.prototype.setSize = function(size) {};

/**
 * Set the target element to render this map into.
 *     that the map is rendered in.
 * \@observable
 * \@api stable
 * @param {(string|!Element)} target
 * @return {void}
 */
ol.Map.prototype.setTarget = function(target) {};

/**
 * Set the view for this map.
 * \@observable
 * \@api stable
 * @param {!ol.View} view
 * @return {void}
 */
ol.Map.prototype.setView = function(view) {};

/**
 * Force a recalculation of the map viewport size.  This should be called when
 * third-party code changes the size of the map viewport.
 * \@api stable
 * @return {void}
 */
ol.Map.prototype.updateSize = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Events emitted as map browser events are instances of this type.
 * See {\@link ol.Map} for which events trigger a map browser event.
 * 
 * @param {string} type
 * @param {!ol.Map} map
 * @param {!Event} browserEvent
 * @param {boolean=} opt_dragging
 * @param {!olx.FrameState=} opt_frameState
 */
ol.MapBrowserEvent = function(type, map, browserEvent, opt_dragging, opt_frameState) {};
 /** @type {!Event} */
ol.MapBrowserEvent.prototype.originalEvent;
 /** @type {!Array<?>} */
ol.MapBrowserEvent.prototype.pixel;
 /** @type {!Array<?>} */
ol.MapBrowserEvent.prototype.coordinate;
 /** @type {boolean} */
ol.MapBrowserEvent.prototype.dragging;
/**
 * @extends {ol.MapBrowserEvent}
 * @constructor
 * @struct
 */
ol.MapBrowserPointerEvent = function() {};
 /** @type {!ol.pointer.PointerEvent} */
ol.MapBrowserPointerEvent.prototype.pointerEvent;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Events emitted as map events are instances of this type.
 * See {\@link ol.Map} for which events trigger a map event.
 * 
 * @param {string} type
 * @param {!ol.Map} map
 * @param {!olx.FrameState=} opt_frameState
 */
ol.MapEvent = function(type, map, opt_frameState) {};
 /** @type {!ol.Map} */
ol.MapEvent.prototype.map;
 /** @type {!olx.FrameState} */
ol.MapEvent.prototype.frameState;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Events emitted by {\@link ol.Object} instances are instances of this type.
 * 
 * @param {string} type
 * @param {string} key
 * @param {?} oldValue
 */
ol.ObjectEvent = function(type, key, oldValue) {};
 /** @type {string} */
ol.ObjectEvent.prototype.key;
 /** @type {?} */
ol.ObjectEvent.prototype.oldValue;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 * 
 * This extends {\@link ol.Observable} with observable properties, where each
 * property is observable as well as the object as a whole.
 * 
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {\@link ol.Map} has a `target` property, accessed with `getTarget()`  and
 * changed with `setTarget()`. Not all properties are however settable. There
 * are also general-purpose accessors `get()` and `set()`. For example,
 * `get('target')` is equivalent to `getTarget()`.
 * 
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {\@link ol.View} has a `center`
 * property, so `view.on('change:center', function(evt) {...});` would call the
 * function whenever the value of the center property changes. Within the
 * function, `evt.target` would be the view, so `evt.target.getCenter()` would
 * return the new center.
 * 
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {\@link ol.Object#getProperties object.getProperties()}.
 * 
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 * 
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 * 
 * \@fires ol.ObjectEvent
 * \@api
 * @param {!Object<string,?>=} opt_values
 */
ol.Object = function(opt_values) {};

/**
 * Gets a value.
 * \@api stable
 * @param {string} key
 * @return {?}
 */
ol.Object.prototype.get = function(key) {};

/**
 * Get a list of object property names.
 * \@api stable
 * @return {!Array<string>}
 */
ol.Object.prototype.getKeys = function() {};

/**
 * Get an object of all property names and values.
 * \@api stable
 * @return {!Object<string,?>}
 */
ol.Object.prototype.getProperties = function() {};

/**
 * Sets a value.
 * \@api stable
 * @param {string} key
 * @param {?} value
 * @param {boolean=} opt_silent
 * @return {void}
 */
ol.Object.prototype.set = function(key, value, opt_silent) {};

/**
 * Sets a collection of key-value pairs.  Note that this changes any existing
 * properties and adds new ones (it does not remove any existing properties).
 * \@api stable
 * @param {!Object<string,?>} values
 * @param {boolean=} opt_silent
 * @return {void}
 */
ol.Object.prototype.setProperties = function(values, opt_silent) {};

/**
 * Unsets a property.
 * \@api stable
 * @param {string} key
 * @param {boolean=} opt_silent
 * @return {void}
 */
ol.Object.prototype.unset = function(key, opt_silent) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {\@link ol.Observable#changed}.
 * 
 * \@fires ol.events.Event
 * @struct
 * \@api stable
 */
ol.Observable = function() {};

/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 *     or `once()` (or an array of keys).
 * \@api stable
 * @param {(!ol.Object|!Array<!ol.Object>)} key
 * @return {void}
 */
ol.Observable.unByKey = function(key) {};

/**
 * Increases the revision counter and dispatches a 'change' event.
 * \@api
 * @return {void}
 */
ol.Observable.prototype.changed = function() {};

/**
 * Dispatches an event and calls all listeners listening for events
 * of this type. The event parameter can either be a string or an
 * Object with a `type` property.
 * 
 *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|
 *     string} event Event object.
 * \@api
 * @param {(string|!Object|!ol.events.Event)} event
 * @return {void}
 */
ol.Observable.prototype.dispatchEvent = function(event) {};

/**
 * Get the version number for this object.  Each time the object is modified,
 * its version number will be incremented.
 * \@api
 * @return {number}
 */
ol.Observable.prototype.getRevision = function() {};

/**
 * Listen for a certain type of event.
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * \@api stable
 * @param {(string|!Array<string>)} type
 * @param {!Function} listener
 * @param {!Object=} opt_this
 * @return {(!ol.Object|!Array<!ol.Object>)}
 */
ol.Observable.prototype.on = function(type, listener, opt_this) {};

/**
 * Listen once for a certain type of event.
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * \@api stable
 * @param {(string|!Array<string>)} type
 * @param {!Function} listener
 * @param {!Object=} opt_this
 * @return {(!ol.Object|!Array<!ol.Object>)}
 */
ol.Observable.prototype.once = function(type, listener, opt_this) {};

/**
 * Unlisten for a certain type of event.
 * `listener`.
 * \@api stable
 * @param {(string|!Array<string>)} type
 * @param {!Function} listener
 * @param {!Object=} opt_this
 * @return {void}
 */
ol.Observable.prototype.un = function(type, listener, opt_this) {};

/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * Note that using the {\@link ol.Observable.unByKey} static function is to
 * be preferred.
 *     or `once()` (or an array of keys).
 * \@api stable
 * @param {(!ol.Object|!Array<!ol.Object>)} key
 * @return {void}
 */
ol.Observable.prototype.unByKey = function(key) {};

/** @typedef {string} */
ol.OverlayPositioning;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * An element to be displayed over the map and attached to a single map
 * location.  Like {\@link ol.control.Control}, Overlays are visible widgets.
 * Unlike Controls, they are not in a fixed position on the screen, but are tied
 * to a geographical coordinate, so panning the map will move an Overlay but not
 * a Control.
 * 
 * Example:
 * 
 *     var popup = new ol.Overlay({
 *       element: document.getElementById('popup')
 *     });
 *     popup.setPosition(coordinate);
 *     map.addOverlay(popup);
 * 
 * \@api stable
 * @param {!olx.OverlayOptions} options
 */
ol.Overlay = function(options) {};

/**
 * Get the DOM element of this overlay.
 * \@observable
 * \@api stable
 * @return {!Element}
 */
ol.Overlay.prototype.getElement = function() {};

/**
 * Get the overlay identifier which is set on constructor.
 * \@api
 * @return {(string|number)}
 */
ol.Overlay.prototype.getId = function() {};

/**
 * Get the map associated with this overlay.
 * \@observable
 * \@api stable
 * @return {!ol.Map}
 */
ol.Overlay.prototype.getMap = function() {};

/**
 * Get the offset of this overlay.
 * \@observable
 * \@api stable
 * @return {!Array<number>}
 */
ol.Overlay.prototype.getOffset = function() {};

/**
 * Get the current position of this overlay.
 *     anchored at.
 * \@observable
 * \@api stable
 * @return {!Array<?>}
 */
ol.Overlay.prototype.getPosition = function() {};

/**
 * Get the current positioning of this overlay.
 *     relative to its point on the map.
 * \@observable
 * \@api stable
 * @return {string}
 */
ol.Overlay.prototype.getPositioning = function() {};

/**
 * Set the DOM element to be associated with this overlay.
 * \@observable
 * \@api stable
 * @param {!Element} element
 * @return {void}
 */
ol.Overlay.prototype.setElement = function(element) {};

/**
 * Set the map to be associated with this overlay.
 * \@observable
 * \@api stable
 * @param {!ol.Map} map
 * @return {void}
 */
ol.Overlay.prototype.setMap = function(map) {};

/**
 * Set the offset for this overlay.
 * \@observable
 * \@api stable
 * @param {!Array<number>} offset
 * @return {void}
 */
ol.Overlay.prototype.setOffset = function(offset) {};

/**
 * Set the position for this overlay. If the position is `undefined` the
 * overlay is hidden.
 *     is anchored at.
 * \@observable
 * \@api stable
 * @param {!Array<?>} position
 * @return {void}
 */
ol.Overlay.prototype.setPosition = function(position) {};

/**
 * Set the positioning for this overlay.
 *     positioned relative to its point on the map.
 * \@observable
 * \@api stable
 * @param {string} positioning
 * @return {void}
 */
ol.Overlay.prototype.setPositioning = function(positioning) {};
/** @const */
ol.pointer = {};
/**
 * @constructor
 * @struct
 */
ol.pointer.PointerEvent = function() {};
/** @const */
ol.proj = {};

/** @typedef {string} */
ol.proj.Units;
 /** @type {!Object<string,number>} */
ol.proj.METERS_PER_UNIT;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {\@link ol.proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {\@link ol.ProjectionLike} which means the simple string
 * code will suffice.
 * 
 * You can use {\@link ol.proj.get} to retrieve the object for a particular
 * projection.
 * 
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 * 
 * If you use proj4js, aliases can be added using `proj4.defs()`; see
 * [documentation](https://github.com/proj4js/proj4js). To set an alternative
 * namespace for proj4, use {\@link ol.proj.setProj4}.
 * 
 * @struct
 * \@api stable
 * @param {!olx.ProjectionOptions} options
 */
ol.proj.Projection = function(options) {};

/**
 * Get the code for this projection, e.g. 'EPSG:4326'.
 * \@api stable
 * @return {string}
 */
ol.proj.Projection.prototype.getCode = function() {};

/**
 * Get the validity extent for this projection.
 * \@api stable
 * @return {!Array<?>}
 */
ol.proj.Projection.prototype.getExtent = function() {};

/**
 * Get the units of this projection.
 * \@api stable
 * @return {string}
 */
ol.proj.Projection.prototype.getUnits = function() {};

/**
 * Get the amount of meters per unit of this projection.  If the projection is
 * not configured with `metersPerUnit` or a units identifier, the return is
 * `undefined`.
 * \@api stable
 * @return {number}
 */
ol.proj.Projection.prototype.getMetersPerUnit = function() {};

/**
 * Get the world extent for this projection.
 * \@api
 * @return {!Array<?>}
 */
ol.proj.Projection.prototype.getWorldExtent = function() {};

/**
 * Is this projection a global projection which spans the whole world?
 * \@api stable
 * @return {boolean}
 */
ol.proj.Projection.prototype.isGlobal = function() {};

/**
 * Set if the projection is a global projection which spans the whole world
 * \@api stable
 * @param {boolean} global
 * @return {void}
 */
ol.proj.Projection.prototype.setGlobal = function(global) {};

/**
 * Set the validity extent for this projection.
 * \@api stable
 * @param {!Array<?>} extent
 * @return {void}
 */
ol.proj.Projection.prototype.setExtent = function(extent) {};

/**
 * Set the world extent for this projection.
 *     [minlon, minlat, maxlon, maxlat].
 * \@api
 * @param {!Array<?>} worldExtent
 * @return {void}
 */
ol.proj.Projection.prototype.setWorldExtent = function(worldExtent) {};

/**
 * Set the getPointResolution function for this projection.
 * \@api
 * @param {function(number, !Array<?>): number} func
 * @return {void}
 */
ol.proj.Projection.prototype.setGetPointResolution = function(func) {};

/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. The default for other projections is to estimate
 * the point resolution by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * An alternative implementation may be given when constructing a
 * projection. For many local projections,
 * such a custom function will return the resolution unchanged.
 * \@api
 * @param {number} resolution
 * @param {!Array<?>} point
 * @return {number}
 */
ol.proj.Projection.prototype.getPointResolution = function(resolution, point) {};

/**
 * Register proj4. If not explicitly registered, it will be assumed that
 * proj4js will be loaded in the global namespace. For example in a
 * browserify ES6 environment you could use:
 * 
 *     import ol from 'openlayers';
 *     import proj4 from 'proj4';
 *     ol.proj.setProj4(proj4);
 * 
 * \@api
 * @param {?} proj4
 * @return {void}
 */
ol.proj.setProj4 = function(proj4) {};

/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 * 
 * \@api
 * @param {!Array<!ol.proj.Projection>} projections
 * @return {void}
 */
ol.proj.addEquivalentProjections = function(projections) {};

/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 * 
 * \@api stable
 * @param {!ol.proj.Projection} projection
 * @return {void}
 */
ol.proj.addProjection = function(projection) {};

/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 * 
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {\@link ol.Coordinate} as argument and returns
 *     the transformed {\@link ol.Coordinate}.
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {\@link ol.Coordinate} as argument and returns
 *     the transformed {\@link ol.Coordinate}.
 * \@api stable
 * @param {(string|!ol.proj.Projection)} source
 * @param {(string|!ol.proj.Projection)} destination
 * @param {function(!Array<?>): !Array<?>} forward
 * @param {function(!Array<?>): !Array<?>} inverse
 * @return {void}
 */
ol.proj.addCoordinateTransforms = function(source, destination, forward, inverse) {};

/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 *     an array with longitude as 1st and latitude as 2nd element.
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * \@api stable
 * @param {!Array<?>} coordinate
 * @param {(string|!ol.proj.Projection)=} opt_projection
 * @return {!Array<?>}
 */
ol.proj.fromLonLat = function(coordinate, opt_projection) {};

/**
 * Transforms a coordinate to longitude/latitude.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 *     with longitude as 1st and latitude as 2nd element.
 * \@api stable
 * @param {!Array<?>} coordinate
 * @param {(string|!ol.proj.Projection)=} opt_projection
 * @return {!Array<?>}
 */
ol.proj.toLonLat = function(coordinate, opt_projection) {};

/**
 * Fetches a Projection object for the code specified.
 * 
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * \@api stable
 * @param {(string|!ol.proj.Projection)} projectionLike
 * @return {!ol.proj.Projection}
 */
ol.proj.get = function(projectionLike) {};

/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 * 
 * \@api
 * @param {!ol.proj.Projection} projection1
 * @param {!ol.proj.Projection} projection2
 * @return {boolean}
 */
ol.proj.equivalent = function(projection1, projection2) {};

/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 * 
 * \@api stable
 * @param {(string|!ol.proj.Projection)} source
 * @param {(string|!ol.proj.Projection)} destination
 * @return {function(!Array<number>, !Array<number>, number): !Array<number>}
 */
ol.proj.getTransform = function(source, destination) {};

/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 * 
 * See {\@link ol.proj.transformExtent} for extent transformation.
 * See the transform method of {\@link ol.geom.Geometry} and its subclasses for
 * geometry transforms.
 * 
 * @param {!Array<?>} coordinate
 * @param {(string|!ol.proj.Projection)} source
 * @param {(string|!ol.proj.Projection)} destination
 * @return {!Array<?>}
 */
ol.proj.transform = function(coordinate, source, destination) {};

/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 * 
 * \@api stable
 * @param {!Array<?>} extent
 * @param {(string|!ol.proj.Projection)} source
 * @param {(string|!ol.proj.Projection)} destination
 * @return {!Array<?>}
 */
ol.proj.transformExtent = function(extent, source, destination) {};

/**
 * Get the resolution of the point in degrees or distance units. For
 * projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * estimated by transforming the 'point' pixel to EPSG:4326, measuring
 * its width and height on the normal sphere, and taking the average of
 * the width and height.
 * @param {!ol.proj.Projection} projection
 * @param {number} resolution
 * @param {!Array<?>} point
 * @return {number}
 */
ol.proj.getPointResolution = function(projection, resolution, point) {};
/** @const */
ol.render = {};
/** @const */
ol.render.canvas = {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A concrete subclass of {\@link ol.render.VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {\@link ol.render.Event} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 * 
 * @struct
 * @param {!CanvasRenderingContext2D} context
 * @param {number} pixelRatio
 * @param {!Array<?>} extent
 * @param {?} transform
 * @param {number} viewRotation
 */
ol.render.canvas.Immediate = function(context, pixelRatio, extent, transform, viewRotation) {};

/**
 * Render a circle geometry into the canvas.  Rendering is immediate and uses
 * the current fill and stroke styles.
 * 
 * \@api
 * @param {!ol.geom.Circle} geometry
 * @return {void}
 */
ol.render.canvas.Immediate.prototype.drawCircle = function(geometry) {};

/**
 * Set the rendering style.  Note that since this is an immediate rendering API,
 * any `zIndex` on the provided style will be ignored.
 * 
 * \@api
 * @param {!ol.style.Style} style
 * @return {void}
 */
ol.render.canvas.Immediate.prototype.setStyle = function(style) {};

/**
 * Render a geometry into the canvas.  Call
 * {\@link ol.render.canvas.Immediate#setStyle} first to set the rendering style.
 * 
 * \@api
 * @param {(!ol.geom.Geometry|!ol.render.Feature)} geometry
 * @return {void}
 */
ol.render.canvas.Immediate.prototype.drawGeometry = function(geometry) {};

/**
 * Render a feature into the canvas.  Note that any `zIndex` on the provided
 * style will be ignored - features are rendered immediately in the order that
 * this method is called.  If you need `zIndex` support, you should be using an
 * {\@link ol.layer.Vector} instead.
 * 
 * \@api
 * @param {!ol.Feature} feature
 * @param {!ol.style.Style} style
 * @return {void}
 */
ol.render.canvas.Immediate.prototype.drawFeature = function(feature, style) {};

/**
 * @constructor
 * @struct
 * @param {string} type
 * @param {!ol.render.VectorContext=} opt_vectorContext
 * @param {!olx.FrameState=} opt_frameState
 * @param {!CanvasRenderingContext2D=} opt_context
 * @param {?=} opt_glContext
 */
ol.render.Event = function(type, opt_vectorContext, opt_frameState, opt_context, opt_glContext) {};
 /** @type {!ol.render.VectorContext} */
ol.render.Event.prototype.vectorContext;
 /** @type {!olx.FrameState} */
ol.render.Event.prototype.frameState;
 /** @type {!CanvasRenderingContext2D} */
ol.render.Event.prototype.context;
 /** @type {?} */
ol.render.Event.prototype.glContext;

/** @typedef {string} */
ol.render.EventType;

/**
 * @constructor
 * @struct
 * Lightweight, read-only, {\@link ol.Feature} and {\@link ol.geom.Geometry} like
 * structure, optimized for rendering and styling. Geometry access through the
 * API is limited to getting the type and extent of the geometry.
 * 
 *     to be right-handed for polygons.
 * @param {string} type
 * @param {!Array<number>} flatCoordinates
 * @param {(!Array<number>|!Array<!Array<number>>)} ends
 * @param {!Object<string,?>} properties
 */
ol.render.Feature = function(type, flatCoordinates, ends, properties) {};

/**
 * Get a feature property by its key.
 * \@api
 * @param {string} key
 * @return {?}
 */
ol.render.Feature.prototype.get = function(key) {};

/**
 * Get the extent of this feature's geometry.
 * \@api
 * @return {!Array<?>}
 */
ol.render.Feature.prototype.getExtent = function() {};

/**
 * Get the feature for working with its geometry.
 * \@api
 * @return {!ol.render.Feature}
 */
ol.render.Feature.prototype.getGeometry = function() {};

/**
 * Get the feature properties.
 * \@api
 * @return {!Object<string,?>}
 */
ol.render.Feature.prototype.getProperties = function() {};

/**
 * Get the type of this feature's geometry.
 * \@api
 * @return {string}
 */
ol.render.Feature.prototype.getType = function() {};

/**
 * @constructor
 * @struct
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @struct
 * \@api
 */
ol.render.VectorContext = function() {};

/**
 * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries
 * to the context's canvas.
 * 
 * The units for geometry coordinates are css pixels relative to the top left
 * corner of the canvas element.
 * ```js
 * var canvas = document.createElement('canvas');
 * var render = ol.render.toContext(canvas.getContext('2d'),
 *     { size: [100, 100] });
 * render.setFillStrokeStyle(new ol.style.Fill({ color: blue }));
 * render.drawPolygon(
 *     new ol.geom.Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]]));
 * ```
 * 
 * \@api
 * @param {!CanvasRenderingContext2D} context
 * @param {!olx.render.ToContextOptions=} opt_options
 * @return {!ol.render.canvas.Immediate}
 */
ol.render.toContext = function(context, opt_options) {};

/** @typedef {string} */
ol.RendererType;

/** @typedef {string} */
ol.RasterOperationType;
/** @const */
ol.source = {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Layer source for Bing Maps tile data.
 * 
 * \@api stable
 * @param {!olx.source.BingMapsOptions} options
 */
ol.source.BingMaps = function(options) {};
 /** @type {!ol.Attribution} */
ol.source.BingMaps.TOS_ATTRIBUTION;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Layer source for the CartoDB tiles.
 * 
 * \@api
 * @param {!olx.source.CartoDBOptions} options
 */
ol.source.CartoDB = function(options) {};

/**
 * Returns the current config.
 * \@api
 * @return {!Object}
 */
ol.source.CartoDB.prototype.getConfig = function() {};

/**
 * Updates the carto db config.
 *     in the config.
 * \@api
 * @param {!Object} config
 * @return {void}
 */
ol.source.CartoDB.prototype.updateConfig = function(config) {};

/**
 * Sets the CartoDB config
 *     object.
 * If using named maps, a key-value lookup with the template parameters.
 * \@api
 * @param {!Object} config
 * @return {void}
 */
ol.source.CartoDB.prototype.setConfig = function(config) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Layer source to cluster vector data. Works out of the box with point
 * geometries. For other geometry types, or if not all geometries should be
 * considered for clustering, a custom `geometryFunction` can be defined.
 * 
 * \@api
 * @param {!olx.source.ClusterOptions} options
 */
ol.source.Cluster = function(options) {};

/**
 * Get a reference to the wrapped source.
 * \@api
 * @return {!ol.source.Vector}
 */
ol.source.Cluster.prototype.getSource = function() {};

/**
 * Set the distance in pixels between clusters.
 * \@api
 * @param {number} distance
 * @return {void}
 */
ol.source.Cluster.prototype.setDistance = function(distance) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing a single image.
 * 
 * \@api
 * @param {!ol.SourceImageOptions} options
 */
ol.source.Image = function(options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Events emitted by {\@link ol.source.Image} instances are instances of this
 * type.
 * 
 * @param {string} type
 * @param {!ol.Image} image
 */
ol.source.ImageEvent = function(type, image) {};
 /** @type {!ol.Image} */
ol.source.ImageEvent.prototype.image;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Source for data from ArcGIS Rest services providing single, untiled images.
 * Useful when underlying map service has labels.
 * 
 * If underlying map service is not using labels,
 * take advantage of ol image caching and use
 * {\@link ol.source.TileArcGISRest} data source.
 * 
 * \@fires ol.source.ImageEvent
 * \@api
 * @param {!olx.source.ImageArcGISRestOptions=} opt_options
 */
ol.source.ImageArcGISRest = function(opt_options) {};

/**
 * Get the user-provided params, i.e. those passed to the constructor through
 * the "params" option, and possibly updated using the updateParams method.
 * \@api stable
 * @return {!Object}
 */
ol.source.ImageArcGISRest.prototype.getParams = function() {};

/**
 * Return the image load function of the source.
 * \@api
 * @return {function(!ol.Image, string): void}
 */
ol.source.ImageArcGISRest.prototype.getImageLoadFunction = function() {};

/**
 * Return the URL used for this ArcGIS source.
 * \@api stable
 * @return {string}
 */
ol.source.ImageArcGISRest.prototype.getUrl = function() {};

/**
 * Set the image load function of the source.
 * \@api
 * @param {function(!ol.Image, string): void} imageLoadFunction
 * @return {void}
 */
ol.source.ImageArcGISRest.prototype.setImageLoadFunction = function(imageLoadFunction) {};

/**
 * Set the URL to use for requests.
 * \@api stable
 * @param {string} url
 * @return {void}
 */
ol.source.ImageArcGISRest.prototype.setUrl = function(url) {};

/**
 * Update the user-provided params.
 * \@api stable
 * @param {!Object} params
 * @return {void}
 */
ol.source.ImageArcGISRest.prototype.updateParams = function(params) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Base class for image sources where a canvas element is the image.
 * 
 * \@api
 * @param {!olx.source.ImageCanvasOptions} options
 */
ol.source.ImageCanvas = function(options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Source for images from Mapguide servers
 * 
 * \@fires ol.source.ImageEvent
 * \@api stable
 * @param {!olx.source.ImageMapGuideOptions} options
 */
ol.source.ImageMapGuide = function(options) {};

/**
 * Get the user-provided params, i.e. those passed to the constructor through
 * the "params" option, and possibly updated using the updateParams method.
 * \@api stable
 * @return {!Object}
 */
ol.source.ImageMapGuide.prototype.getParams = function() {};

/**
 * Return the image load function of the source.
 * \@api
 * @return {function(!ol.Image, string): void}
 */
ol.source.ImageMapGuide.prototype.getImageLoadFunction = function() {};

/**
 * Update the user-provided params.
 * \@api stable
 * @param {!Object} params
 * @return {void}
 */
ol.source.ImageMapGuide.prototype.updateParams = function(params) {};

/**
 * Set the image load function of the MapGuide source.
 * \@api
 * @param {function(!ol.Image, string): void} imageLoadFunction
 * @return {void}
 */
ol.source.ImageMapGuide.prototype.setImageLoadFunction = function(imageLoadFunction) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A layer source for displaying a single, static image.
 * 
 * \@api stable
 * @param {!olx.source.ImageStaticOptions} options
 */
ol.source.ImageStatic = function(options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * An image source whose images are canvas elements into which vector features
 * read from a vector source (`ol.source.Vector`) are drawn. An
 * `ol.source.ImageVector` object is to be used as the `source` of an image
 * layer (`ol.layer.Image`). Image layers are rotated, scaled, and translated,
 * as opposed to being re-rendered, during animations and interactions. So, like
 * any other image layer, an image layer configured with an
 * `ol.source.ImageVector` will exhibit this behaviour. This is in contrast to a
 * vector layer, where vector features are re-drawn during animations and
 * interactions.
 * 
 * \@api
 * @param {!olx.source.ImageVectorOptions} options
 */
ol.source.ImageVector = function(options) {};

/**
 * Get a reference to the wrapped source.
 * \@api
 * @return {!ol.source.Vector}
 */
ol.source.ImageVector.prototype.getSource = function() {};

/**
 * Get the style for features.  This returns whatever was passed to the `style`
 * option at construction or to the `setStyle` method.
 *     Layer style.
 * \@api stable
 * @return {(!ol.style.Style|!Array<!ol.style.Style>|function((!ol.Feature|!ol.render.Feature), number): (!ol.style.Style|!Array<!ol.style.Style>))}
 */
ol.source.ImageVector.prototype.getStyle = function() {};

/**
 * Get the style function.
 * \@api stable
 * @return {function((!ol.Feature|!ol.render.Feature), number): (!ol.style.Style|!Array<!ol.style.Style>)}
 */
ol.source.ImageVector.prototype.getStyleFunction = function() {};

/**
 * Set the style for features.  This can be a single style object, an array
 * of styles, or a function that takes a feature and resolution and returns
 * an array of styles. If it is `undefined` the default style is used. If
 * it is `null` the layer has no style (a `null` style), so only features
 * that have their own styles will be rendered in the layer. See
 * {\@link ol.style} for information on the default style.
 *     style Layer style.
 * \@api stable
 * @param {(!ol.style.Style|!Array<!ol.style.Style>|function((!ol.Feature|!ol.render.Feature), number): (!ol.style.Style|!Array<!ol.style.Style>))} style
 * @return {void}
 */
ol.source.ImageVector.prototype.setStyle = function(style) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Source for WMS servers providing single, untiled images.
 * 
 * \@fires ol.source.ImageEvent
 * \@api stable
 * @param {!olx.source.ImageWMSOptions=} opt_options
 */
ol.source.ImageWMS = function(opt_options) {};

/**
 * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
 * projection. Return `undefined` if the GetFeatureInfo URL cannot be
 * constructed.
 *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
 *     in the `LAYERS` parameter will be used. `VERSION` should not be
 *     specified here.
 * \@api stable
 * @param {!Array<?>} coordinate
 * @param {number} resolution
 * @param {(string|!ol.proj.Projection)} projection
 * @param {!Object} params
 * @return {string}
 */
ol.source.ImageWMS.prototype.getGetFeatureInfoUrl = function(coordinate, resolution, projection, params) {};

/**
 * Get the user-provided params, i.e. those passed to the constructor through
 * the "params" option, and possibly updated using the updateParams method.
 * \@api stable
 * @return {!Object}
 */
ol.source.ImageWMS.prototype.getParams = function() {};

/**
 * Return the image load function of the source.
 * \@api
 * @return {function(!ol.Image, string): void}
 */
ol.source.ImageWMS.prototype.getImageLoadFunction = function() {};

/**
 * Return the URL used for this WMS source.
 * \@api stable
 * @return {string}
 */
ol.source.ImageWMS.prototype.getUrl = function() {};

/**
 * Set the image load function of the source.
 * \@api
 * @param {function(!ol.Image, string): void} imageLoadFunction
 * @return {void}
 */
ol.source.ImageWMS.prototype.setImageLoadFunction = function(imageLoadFunction) {};

/**
 * Set the URL to use for requests.
 * \@api stable
 * @param {string} url
 * @return {void}
 */
ol.source.ImageWMS.prototype.setUrl = function(url) {};

/**
 * Update the user-provided params.
 * \@api stable
 * @param {!Object} params
 * @return {void}
 */
ol.source.ImageWMS.prototype.updateParams = function(params) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Layer source for the OpenStreetMap tile server.
 * 
 * \@api stable
 * @param {!olx.source.OSMOptions=} opt_options
 */
ol.source.OSM = function(opt_options) {};
 /** @type {!ol.Attribution} */
ol.source.OSM.ATTRIBUTION;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A source that transforms data from any number of input sources using an array
 * of {\@link ol.RasterOperation} functions to transform input pixel values into
 * output pixel values.
 * 
 * \@fires ol.source.RasterEvent
 * \@api
 * @param {!olx.source.RasterOptions} options
 */
ol.source.Raster = function(options) {};

/**
 * Set the operation.
 *     in a worker.
 * \@api
 * @param {function((!Array<!Array<number>>|!Array<!ImageData>), !Object): (!Array<number>|!ImageData)} operation
 * @param {!Object=} opt_lib
 * @return {void}
 */
ol.source.Raster.prototype.setOperation = function(operation, opt_lib) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Events emitted by {\@link ol.source.Raster} instances are instances of this
 * type.
 * 
 * @param {string} type
 * @param {!olx.FrameState} frameState
 * @param {!Object} data
 */
ol.source.RasterEvent = function(type, frameState, data) {};
 /** @type {!Array<?>} */
ol.source.RasterEvent.prototype.extent;
 /** @type {number} */
ol.source.RasterEvent.prototype.resolution;
 /** @type {!Object} */
ol.source.RasterEvent.prototype.data;

/** @typedef {string} */
ol.source.State;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {\@link ol.layer.Layer} sources.
 * 
 * A generic `change` event is triggered when the state of the source changes.
 * 
 * \@api stable
 * @param {!ol.SourceSourceOptions} options
 */
ol.source.Source = function(options) {};

/**
 * Get the attributions of the source.
 * \@api stable
 * @return {!Array<!ol.Attribution>}
 */
ol.source.Source.prototype.getAttributions = function() {};

/**
 * Get the logo of the source.
 * \@api stable
 * @return {(string|!olx.LogoOptions)}
 */
ol.source.Source.prototype.getLogo = function() {};

/**
 * Get the projection of the source.
 * \@api
 * @return {!ol.proj.Projection}
 */
ol.source.Source.prototype.getProjection = function() {};

/**
 * Get the state of the source, see {\@link ol.source.State} for possible states.
 * \@api
 * @return {string}
 */
ol.source.Source.prototype.getState = function() {};

/**
 * Refreshes the source and finally dispatches a 'change' event.
 * \@api
 * @return {void}
 */
ol.source.Source.prototype.refresh = function() {};

/**
 * Set the attributions of the source.
 *     Can be passed as `string`, `Array<string>`, `{\@link ol.Attribution}`,
 *     `Array<{\@link ol.Attribution}>` or `undefined`.
 * \@api
 * @param {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} attributions
 * @return {void}
 */
ol.source.Source.prototype.setAttributions = function(attributions) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Layer source for the Stamen tile server.
 * 
 * \@api stable
 * @param {!olx.source.StamenOptions} options
 */
ol.source.Stamen = function(options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * 
 * \@api
 * @param {!ol.SourceTileOptions} options
 */
ol.source.Tile = function(options) {};

/**
 * Return the tile grid of the tile source.
 * \@api stable
 * @return {!ol.tilegrid.TileGrid}
 */
ol.source.Tile.prototype.getTileGrid = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Events emitted by {\@link ol.source.Tile} instances are instances of this
 * type.
 * 
 * @param {string} type
 * @param {!ol.Tile} tile
 */
ol.source.TileEvent = function(type, tile) {};
 /** @type {!ol.Tile} */
ol.source.TileEvent.prototype.tile;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Layer source for tile data from ArcGIS Rest services. Map and Image
 * Services are supported.
 * 
 * For cached ArcGIS services, better performance is available using the
 * {\@link ol.source.XYZ} data source.
 * 
 *     options.
 * \@api
 * @param {!olx.source.TileArcGISRestOptions=} opt_options
 */
ol.source.TileArcGISRest = function(opt_options) {};

/**
 * Get the user-provided params, i.e. those passed to the constructor through
 * the "params" option, and possibly updated using the updateParams method.
 * \@api
 * @return {!Object}
 */
ol.source.TileArcGISRest.prototype.getParams = function() {};

/**
 * Update the user-provided params.
 * \@api stable
 * @param {!Object} params
 * @return {void}
 */
ol.source.TileArcGISRest.prototype.updateParams = function(params) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A pseudo tile source, which does not fetch tiles from a server, but renders
 * a grid outline for the tile grid/projection along with the coordinates for
 * each tile. See examples/canvas-tiles for an example.
 * 
 * Uses Canvas context2d, so requires Canvas support.
 * 
 * \@api
 * @param {!olx.source.TileDebugOptions} options
 */
ol.source.TileDebug = function(options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Base class for sources providing images divided into a tile grid.
 * 
 * \@fires ol.source.TileEvent
 * \@api
 * @param {!olx.source.TileImageOptions} options
 */
ol.source.TileImage = function(options) {};

/**
 * Sets whether to render reprojection edges or not (usually for debugging).
 * \@api
 * @param {boolean} render
 * @return {void}
 */
ol.source.TileImage.prototype.setRenderReprojectionEdges = function(render) {};

/**
 * Sets the tile grid to use when reprojecting the tiles to the given
 * projection instead of the default tile grid for the projection.
 * 
 * This can be useful when the default tile grid cannot be created
 * (e.g. projection has no extent defined) or
 * for optimization reasons (custom tile size, resolutions, ...).
 * 
 * \@api
 * @param {(string|!ol.proj.Projection)} projection
 * @param {!ol.tilegrid.TileGrid} tilegrid
 * @return {void}
 */
ol.source.TileImage.prototype.setTileGridForProjection = function(projection, tilegrid) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Layer source for tile data in TileJSON format.
 * 
 * \@api stable
 * @param {!olx.source.TileJSONOptions} options
 */
ol.source.TileJSON = function(options) {};

/**
 * \@api
 * @return {!ol.source.TileJSON}
 */
ol.source.TileJSON.prototype.getTileJSON = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Layer source for UTFGrid interaction data loaded from TileJSON format.
 * 
 * \@api
 * @param {!olx.source.TileUTFGridOptions} options
 */
ol.source.TileUTFGrid = function(options) {};

/**
 * Return the template from TileJSON.
 * \@api
 * @return {string}
 */
ol.source.TileUTFGrid.prototype.getTemplate = function() {};

/**
 * Calls the callback (synchronously by default) with the available data
 * for given coordinate and resolution (or `null` if not yet loaded or
 * in case of an error).
 *                               The tile data is requested if not yet loaded.
 * \@api
 * @template T
 * @param {!Array<?>} coordinate
 * @param {number} resolution
 * @param {function(?): ?} callback
 * @param {T=} opt_this
 * @param {boolean=} opt_request
 * @return {void}
 */
ol.source.TileUTFGrid.prototype.forDataAtCoordinateAndResolution = function(coordinate, resolution, callback, opt_this, opt_request) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Layer source for tile data from WMS servers.
 * 
 * \@api stable
 * @param {!olx.source.TileWMSOptions=} opt_options
 */
ol.source.TileWMS = function(opt_options) {};

/**
 * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
 * projection. Return `undefined` if the GetFeatureInfo URL cannot be
 * constructed.
 *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
 *     in the `LAYERS` parameter will be used. `VERSION` should not be
 *     specified here.
 * \@api stable
 * @param {!Array<?>} coordinate
 * @param {number} resolution
 * @param {(string|!ol.proj.Projection)} projection
 * @param {!Object} params
 * @return {string}
 */
ol.source.TileWMS.prototype.getGetFeatureInfoUrl = function(coordinate, resolution, projection, params) {};

/**
 * Get the user-provided params, i.e. those passed to the constructor through
 * the "params" option, and possibly updated using the updateParams method.
 * \@api stable
 * @return {!Object}
 */
ol.source.TileWMS.prototype.getParams = function() {};

/**
 * Update the user-provided params.
 * \@api stable
 * @param {!Object} params
 * @return {void}
 */
ol.source.TileWMS.prototype.updateParams = function(params) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Base class for sources providing tiles divided into a tile grid over http.
 * 
 * \@fires ol.source.TileEvent
 * @param {!ol.SourceUrlTileOptions} options
 */
ol.source.UrlTile = function(options) {};

/**
 * Return the tile load function of the source.
 * \@api
 * @return {function(!ol.Tile, string): void}
 */
ol.source.UrlTile.prototype.getTileLoadFunction = function() {};

/**
 * Return the tile URL function of the source.
 * \@api
 * @return {function(!Array<?>, number, !ol.proj.Projection): string}
 */
ol.source.UrlTile.prototype.getTileUrlFunction = function() {};

/**
 * Return the URLs used for this source.
 * When a tileUrlFunction is used instead of url or urls,
 * null will be returned.
 * \@api
 * @return {!Array<string>}
 */
ol.source.UrlTile.prototype.getUrls = function() {};

/**
 * Set the tile load function of the source.
 * \@api
 * @param {function(!ol.Tile, string): void} tileLoadFunction
 * @return {void}
 */
ol.source.UrlTile.prototype.setTileLoadFunction = function(tileLoadFunction) {};

/**
 * Set the tile URL function of the source.
 * \@api
 * @param {function(!Array<?>, number, !ol.proj.Projection): string} tileUrlFunction
 * @param {string=} opt_key
 * @return {void}
 */
ol.source.UrlTile.prototype.setTileUrlFunction = function(tileUrlFunction, opt_key) {};

/**
 * Set the URL to use for requests.
 * \@api stable
 * @param {string} url
 * @return {void}
 */
ol.source.UrlTile.prototype.setUrl = function(url) {};

/**
 * Set the URLs to use for requests.
 * \@api stable
 * @param {!Array<string>} urls
 * @return {void}
 */
ol.source.UrlTile.prototype.setUrls = function(urls) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {\@link ol.source.VectorTile} for
 * vector data that is optimized for rendering.
 * 
 * \@fires ol.source.VectorEvent
 * \@api stable
 * @param {!olx.source.VectorOptions=} opt_options
 */
ol.source.Vector = function(opt_options) {};

/**
 * Add a single feature to the source.  If you want to add a batch of features
 * at once, call {\@link ol.source.Vector#addFeatures source.addFeatures()}
 * instead.
 * \@api stable
 * @param {!ol.Feature} feature
 * @return {void}
 */
ol.source.Vector.prototype.addFeature = function(feature) {};

/**
 * Add a batch of features to the source.
 * \@api stable
 * @param {!Array<!ol.Feature>} features
 * @return {void}
 */
ol.source.Vector.prototype.addFeatures = function(features) {};

/**
 * Remove all features from the source.
 * \@api stable
 * @param {boolean=} opt_fast
 * @return {void}
 */
ol.source.Vector.prototype.clear = function(opt_fast) {};

/**
 * Iterate through all features on the source, calling the provided callback
 * with each one.  If the callback returns any "truthy" value, iteration will
 * stop and the function will return the same value.
 * 
 *     on the source.  Return a truthy value to stop iteration.
 * \@api stable
 * @template T, S
 * @param {function(!ol.Feature): S} callback
 * @param {T=} opt_this
 * @return {S}
 */
ol.source.Vector.prototype.forEachFeature = function(callback, opt_this) {};

/**
 * Iterate through all features whose bounding box intersects the provided
 * extent (note that the feature's geometry may not intersect the extent),
 * calling the callback with each feature.  If the callback returns a "truthy"
 * value, iteration will stop and the function will return the same value.
 * 
 * If you are interested in features whose geometry intersects an extent, call
 * the {\@link ol.source.Vector#forEachFeatureIntersectingExtent
 * source.forEachFeatureIntersectingExtent()} method instead.
 * 
 * When `useSpatialIndex` is set to false, this method will loop through all
 * features, equivalent to {\@link ol.source.Vector#forEachFeature}.
 * 
 *     whose bounding box intersects the provided extent.
 * \@api
 * @template T, S
 * @param {!Array<?>} extent
 * @param {function(!ol.Feature): S} callback
 * @param {T=} opt_this
 * @return {S}
 */
ol.source.Vector.prototype.forEachFeatureInExtent = function(extent, callback, opt_this) {};

/**
 * Iterate through all features whose geometry intersects the provided extent,
 * calling the callback with each feature.  If the callback returns a "truthy"
 * value, iteration will stop and the function will return the same value.
 * 
 * If you only want to test for bounding box intersection, call the
 * {\@link ol.source.Vector#forEachFeatureInExtent
 * source.forEachFeatureInExtent()} method instead.
 * 
 *     whose geometry intersects the provided extent.
 * \@api
 * @template T, S
 * @param {!Array<?>} extent
 * @param {function(!ol.Feature): S} callback
 * @param {T=} opt_this
 * @return {S}
 */
ol.source.Vector.prototype.forEachFeatureIntersectingExtent = function(extent, callback, opt_this) {};

/**
 * Get the features collection associated with this source. Will be `null`
 * unless the source was configured with `useSpatialIndex` set to `false`, or
 * with an {\@link ol.Collection} as `features`.
 * \@api
 * @return {!ol.Collection<!ol.Feature>}
 */
ol.source.Vector.prototype.getFeaturesCollection = function() {};

/**
 * Get all features on the source.
 * \@api stable
 * @return {!Array<!ol.Feature>}
 */
ol.source.Vector.prototype.getFeatures = function() {};

/**
 * Get all features whose geometry intersects the provided coordinate.
 * \@api stable
 * @param {!Array<?>} coordinate
 * @return {!Array<!ol.Feature>}
 */
ol.source.Vector.prototype.getFeaturesAtCoordinate = function(coordinate) {};

/**
 * Get all features in the provided extent.  Note that this returns all features
 * whose bounding boxes intersect the given extent (so it may include features
 * whose geometries do not intersect the extent).
 * 
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * \@api
 * @param {!Array<?>} extent
 * @return {!Array<!ol.Feature>}
 */
ol.source.Vector.prototype.getFeaturesInExtent = function(extent) {};

/**
 * Get the closest feature to the provided coordinate.
 * 
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 *     The filter function will receive one argument, the {\@link ol.Feature feature}
 *     and it should return a boolean value. By default, no filtering is made.
 * \@api stable
 * @param {!Array<?>} coordinate
 * @param {function(!ol.Feature): boolean=} opt_filter
 * @return {!ol.Feature}
 */
ol.source.Vector.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {};

/**
 * Get the extent of the features currently in the source.
 * 
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * \@api stable
 * @return {!Array<?>}
 */
ol.source.Vector.prototype.getExtent = function() {};

/**
 * Get a feature by its identifier (the value returned by feature.getId()).
 * Note that the index treats string and numeric identifiers as the same.  So
 * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
 * 
 * \@api stable
 * @param {(string|number)} id
 * @return {!ol.Feature}
 */
ol.source.Vector.prototype.getFeatureById = function(id) {};

/**
 * Get the format associated with this source.
 * 
 * \@api
 * @return {!ol.format.Feature}
 */
ol.source.Vector.prototype.getFormat = function() {};

/**
 * Get the url associated with this source.
 * 
 * \@api
 * @return {(string|function(!Array<?>, number, !ol.proj.Projection): string)}
 */
ol.source.Vector.prototype.getUrl = function() {};

/**
 * Remove a single feature from the source.  If you want to remove all features
 * at once, use the {\@link ol.source.Vector#clear source.clear()} method
 * instead.
 * \@api stable
 * @param {!ol.Feature} feature
 * @return {void}
 */
ol.source.Vector.prototype.removeFeature = function(feature) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Events emitted by {\@link ol.source.Vector} instances are instances of this
 * type.
 * 
 * @param {string} type
 * @param {!ol.Feature=} opt_feature
 */
ol.source.VectorEvent = function(type, opt_feature) {};
 /** @type {!ol.Feature} */
ol.source.VectorEvent.prototype.feature;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Class for layer sources providing vector data divided into a tile grid, to be
 * used with {\@link ol.layer.VectorTile}. Although this source receives tiles
 * with vector features from the server, it is not meant for feature editing.
 * Features are optimized for rendering, their geometries are clipped at or near
 * tile boundaries and simplified for a view resolution. See
 * {\@link ol.source.Vector} for vector sources that are suitable for feature
 * editing.
 * 
 * \@fires ol.source.TileEvent
 * \@api
 * @param {!olx.source.VectorTileOptions} options
 */
ol.source.VectorTile = function(options) {};
/** @const */
ol.source.wms = {};

/** @typedef {string} */
ol.source.wms.ServerType;

/** @typedef {string} */
ol.source.WMTSRequestEncoding;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Layer source for tile data from WMTS servers.
 * 
 * \@api stable
 * @param {!olx.source.WMTSOptions} options
 */
ol.source.WMTS = function(options) {};

/**
 * Get the dimensions, i.e. those passed to the constructor through the
 * "dimensions" option, and possibly updated using the updateDimensions
 * method.
 * \@api
 * @return {!Object}
 */
ol.source.WMTS.prototype.getDimensions = function() {};

/**
 * Return the image format of the WMTS source.
 * \@api
 * @return {string}
 */
ol.source.WMTS.prototype.getFormat = function() {};

/**
 * Return the layer of the WMTS source.
 * \@api
 * @return {string}
 */
ol.source.WMTS.prototype.getLayer = function() {};

/**
 * Return the matrix set of the WMTS source.
 * \@api
 * @return {string}
 */
ol.source.WMTS.prototype.getMatrixSet = function() {};

/**
 * Return the request encoding, either "KVP" or "REST".
 * \@api
 * @return {string}
 */
ol.source.WMTS.prototype.getRequestEncoding = function() {};

/**
 * Return the style of the WMTS source.
 * \@api
 * @return {string}
 */
ol.source.WMTS.prototype.getStyle = function() {};

/**
 * Return the version of the WMTS source.
 * \@api
 * @return {string}
 */
ol.source.WMTS.prototype.getVersion = function() {};

/**
 * Update the dimensions.
 * \@api
 * @param {!Object} dimensions
 * @return {void}
 */
ol.source.WMTS.prototype.updateDimensions = function(dimensions) {};

/**
 * Generate source options from a capabilities object.
 *                  the layer will apply if not provided.
 * 
 * Required config properties:
 *  - layer - {string} The layer identifier.
 * 
 * Optional config properties:
 *  - matrixSet - {string} The matrix set identifier, required if there is
 *       more than one matrix set in the layer capabilities.
 *  - projection - {string} The desired CRS when no matrixSet is specified.
 *       eg: "EPSG:3857". If the desired projection is not available,
 *       an error is thrown.
 *  - requestEncoding - {string} url encoding format for the layer. Default is
 *       the first tile url format found in the GetCapabilities response.
 *  - style - {string} The name of the style
 *  - format - {string} Image format for the layer. Default is the first
 *       format returned in the GetCapabilities response.
 * \@api
 * @param {!Object} wmtsCap
 * @param {!Object} config
 * @return {!olx.source.WMTSOptions}
 */
ol.source.WMTS.optionsFromCapabilities = function(wmtsCap, config) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case,
 * {\@link ol.source.TileImage} can be used with a `tileUrlFunction`
 * such as:
 * 
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *        coordinate[1] + '/' + coordinate[2] + '.png';
 *    }
 * 
 * 
 * \@api stable
 * @param {!olx.source.XYZOptions=} opt_options
 */
ol.source.XYZ = function(opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Layer source for tile data in Zoomify format.
 * 
 * \@api stable
 * @param {!olx.source.ZoomifyOptions=} opt_options
 */
ol.source.Zoomify = function(opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Class to create objects that can be used with {\@link
 * ol.geom.Polygon.circular}.
 * 
 * For example to create a sphere whose radius is equal to the semi-major
 * axis of the WGS84 ellipsoid:
 * 
 * ```js
 * var wgs84Sphere= new ol.Sphere(6378137);
 * ```
 * 
 * \@api
 * @param {number} radius
 */
ol.Sphere = function(radius) {};

/**
 * Returns the geodesic area for a list of coordinates.
 * 
 * [Reference](http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 * 
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * \@api
 * @param {!Array<!Array<?>>} coordinates
 * @return {number}
 */
ol.Sphere.prototype.geodesicArea = function(coordinates) {};

/**
 * Returns the distance from c1 to c2 using the haversine formula.
 * 
 * \@api
 * @param {!Array<?>} c1
 * @param {!Array<?>} c2
 * @return {number}
 */
ol.Sphere.prototype.haversineDistance = function(c1, c2) {};
/** @const */
ol.style = {};

/**
 * @constructor
 * @struct
 * Manages the creation of image atlases.
 * 
 * Images added to this manager will be inserted into an atlas, which
 * will be used for rendering.
 * The `size` given in the constructor is the size for the first
 * atlas. After that, when new atlases are created, they will have
 * twice the size as the latest atlas (until `maxSize` is reached).
 * 
 * If an application uses many images or very large images, it is recommended
 * to set a higher `size` value to avoid the creation of too many atlases.
 * 
 * @struct
 * \@api
 * @param {!olx.style.AtlasManagerOptions=} opt_options
 */
ol.style.AtlasManager = function(opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Set circle style for vector features.
 * 
 * \@api
 * @param {!olx.style.CircleOptions=} opt_options
 */
ol.style.Circle = function(opt_options) {};

/**
 * Get the fill style for the circle.
 * \@api
 * @return {!ol.style.Fill}
 */
ol.style.Circle.prototype.getFill = function() {};

/**
 * Get the image used to render the circle.
 * \@api
 * @param {number} pixelRatio
 * @return {!HTMLCanvasElement}
 */
ol.style.Circle.prototype.getImage = function(pixelRatio) {};

/**
 * Get the circle radius.
 * \@api
 * @return {number}
 */
ol.style.Circle.prototype.getRadius = function() {};

/**
 * Get the stroke style for the circle.
 * \@api
 * @return {!ol.style.Stroke}
 */
ol.style.Circle.prototype.getStroke = function() {};

/**
 * Set the circle radius.
 * 
 * \@api
 * @param {number} radius
 * @return {void}
 */
ol.style.Circle.prototype.setRadius = function(radius) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Set fill style for vector features.
 * 
 * \@api
 * @param {!olx.style.FillOptions=} opt_options
 */
ol.style.Fill = function(opt_options) {};

/**
 * Get the fill color.
 * \@api
 * @return {(string|!Array<?>|!Uint8Array|!Uint8ClampedArray|!CanvasPattern|!CanvasGradient)}
 */
ol.style.Fill.prototype.getColor = function() {};

/**
 * Set the color.
 * 
 * \@api
 * @param {(string|!Array<?>|!Uint8Array|!Uint8ClampedArray|!CanvasPattern|!CanvasGradient)} color
 * @return {void}
 */
ol.style.Fill.prototype.setColor = function(color) {};

/** @typedef {string} */
ol.style.IconAnchorUnits;

/** @typedef {string} */
ol.style.IconOrigin;

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Set icon style for vector features.
 * 
 * \@api
 * @param {!olx.style.IconOptions=} opt_options
 */
ol.style.Icon = function(opt_options) {};

/**
 * @inheritDoc
 * \@api
 * @return {!Array<number>}
 */
ol.style.Icon.prototype.getAnchor = function() {};

/**
 * Get the image icon.
 * \@api
 * @param {number} pixelRatio
 * @return {(!HTMLCanvasElement|!ol.style.Image)}
 */
ol.style.Icon.prototype.getImage = function(pixelRatio) {};

/**
 * @inheritDoc
 * \@api
 * @return {!Array<number>}
 */
ol.style.Icon.prototype.getOrigin = function() {};

/**
 * Get the image URL.
 * \@api
 * @return {string}
 */
ol.style.Icon.prototype.getSrc = function() {};

/**
 * @inheritDoc
 * \@api
 * @return {!Array<?>}
 */
ol.style.Icon.prototype.getSize = function() {};

/**
 * Load not yet loaded URI.
 * When rendering a feature with an icon style, the vector renderer will
 * automatically call this method. However, you might want to call this
 * method yourself for preloading or other purposes.
 * \@api
 * @return {void}
 */
ol.style.Icon.prototype.load = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {\@link ol.style.Icon}, {\@link ol.style.Circle} and
 * {\@link ol.style.RegularShape}.
 * 
 * \@api
 * @param {!ol.StyleImageOptions} options
 */
ol.style.Image = function(options) {};

/**
 * Get the symbolizer opacity.
 * \@api
 * @return {number}
 */
ol.style.Image.prototype.getOpacity = function() {};

/**
 * Determine whether the symbolizer rotates with the map.
 * \@api
 * @return {boolean}
 */
ol.style.Image.prototype.getRotateWithView = function() {};

/**
 * Get the symoblizer rotation.
 * \@api
 * @return {number}
 */
ol.style.Image.prototype.getRotation = function() {};

/**
 * Get the symbolizer scale.
 * \@api
 * @return {number}
 */
ol.style.Image.prototype.getScale = function() {};

/**
 * Determine whether the symbolizer should be snapped to a pixel.
 * \@api
 * @return {boolean}
 */
ol.style.Image.prototype.getSnapToPixel = function() {};

/**
 * Set the opacity.
 * 
 * \@api
 * @param {number} opacity
 * @return {void}
 */
ol.style.Image.prototype.setOpacity = function(opacity) {};

/**
 * Set the rotation.
 * 
 * \@api
 * @param {number} rotation
 * @return {void}
 */
ol.style.Image.prototype.setRotation = function(rotation) {};

/**
 * Set the scale.
 * 
 * \@api
 * @param {number} scale
 * @return {void}
 */
ol.style.Image.prototype.setScale = function(scale) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * 
 * \@api
 * @param {!olx.style.RegularShapeOptions} options
 */
ol.style.RegularShape = function(options) {};

/**
 * @inheritDoc
 * \@api
 * @return {!Array<number>}
 */
ol.style.RegularShape.prototype.getAnchor = function() {};

/**
 * Get the angle used in generating the shape.
 * \@api
 * @return {number}
 */
ol.style.RegularShape.prototype.getAngle = function() {};

/**
 * Get the fill style for the shape.
 * \@api
 * @return {!ol.style.Fill}
 */
ol.style.RegularShape.prototype.getFill = function() {};

/**
 * @inheritDoc
 * \@api
 * @param {number} pixelRatio
 * @return {(!HTMLCanvasElement|!HTMLVideoElement|!ol.style.Image)}
 */
ol.style.RegularShape.prototype.getImage = function(pixelRatio) {};

/**
 * @inheritDoc
 * \@api
 * @return {!Array<number>}
 */
ol.style.RegularShape.prototype.getOrigin = function() {};

/**
 * Get the number of points for generating the shape.
 * \@api
 * @return {number}
 */
ol.style.RegularShape.prototype.getPoints = function() {};

/**
 * Get the (primary) radius for the shape.
 * \@api
 * @return {number}
 */
ol.style.RegularShape.prototype.getRadius = function() {};

/**
 * Get the secondary radius for the shape.
 * \@api
 * @return {number}
 */
ol.style.RegularShape.prototype.getRadius2 = function() {};

/**
 * @inheritDoc
 * \@api
 * @return {!Array<?>}
 */
ol.style.RegularShape.prototype.getSize = function() {};

/**
 * Get the stroke style for the shape.
 * \@api
 * @return {!ol.style.Stroke}
 */
ol.style.RegularShape.prototype.getStroke = function() {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * 
 * \@api
 * @param {!olx.style.StrokeOptions=} opt_options
 */
ol.style.Stroke = function(opt_options) {};

/**
 * Get the stroke color.
 * \@api
 * @return {(string|!Array<?>|!Uint8Array|!Uint8ClampedArray)}
 */
ol.style.Stroke.prototype.getColor = function() {};

/**
 * Get the line cap type for the stroke.
 * \@api
 * @return {string}
 */
ol.style.Stroke.prototype.getLineCap = function() {};

/**
 * Get the line dash style for the stroke.
 * \@api
 * @return {!Array<number>}
 */
ol.style.Stroke.prototype.getLineDash = function() {};

/**
 * Get the line join type for the stroke.
 * \@api
 * @return {string}
 */
ol.style.Stroke.prototype.getLineJoin = function() {};

/**
 * Get the miter limit for the stroke.
 * \@api
 * @return {number}
 */
ol.style.Stroke.prototype.getMiterLimit = function() {};

/**
 * Get the stroke width.
 * \@api
 * @return {number}
 */
ol.style.Stroke.prototype.getWidth = function() {};

/**
 * Set the color.
 * 
 * \@api
 * @param {(string|!Array<?>|!Uint8Array|!Uint8ClampedArray)} color
 * @return {void}
 */
ol.style.Stroke.prototype.setColor = function(color) {};

/**
 * Set the line cap.
 * 
 * \@api
 * @param {string} lineCap
 * @return {void}
 */
ol.style.Stroke.prototype.setLineCap = function(lineCap) {};

/**
 * Set the line dash.
 * 
 * Please note that Internet Explorer 10 and lower [do not support][mdn] the
 * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
 * property will have no visual effect in these browsers.
 * 
 * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
 * 
 * \@api
 * @param {!Array<number>} lineDash
 * @return {void}
 */
ol.style.Stroke.prototype.setLineDash = function(lineDash) {};

/**
 * Set the line join.
 * 
 * \@api
 * @param {string} lineJoin
 * @return {void}
 */
ol.style.Stroke.prototype.setLineJoin = function(lineJoin) {};

/**
 * Set the miter limit.
 * 
 * \@api
 * @param {number} miterLimit
 * @return {void}
 */
ol.style.Stroke.prototype.setMiterLimit = function(miterLimit) {};

/**
 * Set the width.
 * 
 * \@api
 * @param {number} width
 * @return {void}
 */
ol.style.Stroke.prototype.setWidth = function(width) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 * 
 * @struct
 * \@api
 * @param {!olx.style.StyleOptions=} opt_options
 */
ol.style.Style = function(opt_options) {};

/**
 * Get the geometry to be rendered.
 * Feature property or geometry or function that returns the geometry that will
 * be rendered with this style.
 * \@api
 * @return {(string|!ol.geom.Geometry|function((!ol.Feature|!ol.render.Feature)): (!ol.geom.Geometry|!ol.render.Feature))}
 */
ol.style.Style.prototype.getGeometry = function() {};

/**
 * Get the function used to generate a geometry for rendering.
 * and returns the geometry to render instead of the feature's geometry.
 * \@api
 * @return {function((!ol.Feature|!ol.render.Feature)): (!ol.geom.Geometry|!ol.render.Feature)}
 */
ol.style.Style.prototype.getGeometryFunction = function() {};

/**
 * Get the fill style.
 * \@api
 * @return {!ol.style.Fill}
 */
ol.style.Style.prototype.getFill = function() {};

/**
 * Get the image style.
 * \@api
 * @return {!ol.style.Image}
 */
ol.style.Style.prototype.getImage = function() {};

/**
 * Get the stroke style.
 * \@api
 * @return {!ol.style.Stroke}
 */
ol.style.Style.prototype.getStroke = function() {};

/**
 * Get the text style.
 * \@api
 * @return {!ol.style.Text}
 */
ol.style.Style.prototype.getText = function() {};

/**
 * Get the z-index for the style.
 * \@api
 * @return {number}
 */
ol.style.Style.prototype.getZIndex = function() {};

/**
 * Set the fill style.
 * \@api
 * @param {!ol.style.Fill} fill
 * @return {void}
 */
ol.style.Style.prototype.setFill = function(fill) {};

/**
 * Set a geometry that is rendered instead of the feature's geometry.
 * 
 *     Feature property or geometry or function returning a geometry to render
 *     for this style.
 * \@api
 * @param {(string|!ol.geom.Geometry|function((!ol.Feature|!ol.render.Feature)): (!ol.geom.Geometry|!ol.render.Feature))} geometry
 * @return {void}
 */
ol.style.Style.prototype.setGeometry = function(geometry) {};

/**
 * Set the image style.
 * \@api
 * @param {!ol.style.Image} image
 * @return {void}
 */
ol.style.Style.prototype.setImage = function(image) {};

/**
 * Set the stroke style.
 * \@api
 * @param {!ol.style.Stroke} stroke
 * @return {void}
 */
ol.style.Style.prototype.setStroke = function(stroke) {};

/**
 * Set the text style.
 * \@api
 * @param {!ol.style.Text} text
 * @return {void}
 */
ol.style.Style.prototype.setText = function(text) {};

/**
 * Set the z-index.
 * 
 * \@api
 * @param {number} zIndex
 * @return {void}
 */
ol.style.Style.prototype.setZIndex = function(zIndex) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Set text style for vector features.
 * 
 * \@api
 * @param {!olx.style.TextOptions=} opt_options
 */
ol.style.Text = function(opt_options) {};

/**
 * Get the font name.
 * \@api
 * @return {string}
 */
ol.style.Text.prototype.getFont = function() {};

/**
 * Get the x-offset for the text.
 * \@api
 * @return {number}
 */
ol.style.Text.prototype.getOffsetX = function() {};

/**
 * Get the y-offset for the text.
 * \@api
 * @return {number}
 */
ol.style.Text.prototype.getOffsetY = function() {};

/**
 * Get the fill style for the text.
 * \@api
 * @return {!ol.style.Fill}
 */
ol.style.Text.prototype.getFill = function() {};

/**
 * Determine whether the text rotates with the map.
 * \@api
 * @return {boolean}
 */
ol.style.Text.prototype.getRotateWithView = function() {};

/**
 * Get the text rotation.
 * \@api
 * @return {number}
 */
ol.style.Text.prototype.getRotation = function() {};

/**
 * Get the text scale.
 * \@api
 * @return {number}
 */
ol.style.Text.prototype.getScale = function() {};

/**
 * Get the stroke style for the text.
 * \@api
 * @return {!ol.style.Stroke}
 */
ol.style.Text.prototype.getStroke = function() {};

/**
 * Get the text to be rendered.
 * \@api
 * @return {string}
 */
ol.style.Text.prototype.getText = function() {};

/**
 * Get the text alignment.
 * \@api
 * @return {string}
 */
ol.style.Text.prototype.getTextAlign = function() {};

/**
 * Get the text baseline.
 * \@api
 * @return {string}
 */
ol.style.Text.prototype.getTextBaseline = function() {};

/**
 * Set the font.
 * 
 * \@api
 * @param {string} font
 * @return {void}
 */
ol.style.Text.prototype.setFont = function(font) {};

/**
 * Set the x offset.
 * 
 * \@api
 * @param {number} offsetX
 * @return {void}
 */
ol.style.Text.prototype.setOffsetX = function(offsetX) {};

/**
 * Set the y offset.
 * 
 * \@api
 * @param {number} offsetY
 * @return {void}
 */
ol.style.Text.prototype.setOffsetY = function(offsetY) {};

/**
 * Set the fill.
 * 
 * \@api
 * @param {!ol.style.Fill} fill
 * @return {void}
 */
ol.style.Text.prototype.setFill = function(fill) {};

/**
 * Set the rotation.
 * 
 * \@api
 * @param {number} rotation
 * @return {void}
 */
ol.style.Text.prototype.setRotation = function(rotation) {};

/**
 * Set the scale.
 * 
 * \@api
 * @param {number} scale
 * @return {void}
 */
ol.style.Text.prototype.setScale = function(scale) {};

/**
 * Set the stroke.
 * 
 * \@api
 * @param {!ol.style.Stroke} stroke
 * @return {void}
 */
ol.style.Text.prototype.setStroke = function(stroke) {};

/**
 * Set the text.
 * 
 * \@api
 * @param {string} text
 * @return {void}
 */
ol.style.Text.prototype.setText = function(text) {};

/**
 * Set the text alignment.
 * 
 * \@api
 * @param {string} textAlign
 * @return {void}
 */
ol.style.Text.prototype.setTextAlign = function(textAlign) {};

/**
 * Set the text baseline.
 * 
 * \@api
 * @param {string} textBaseline
 * @return {void}
 */
ol.style.Text.prototype.setTextBaseline = function(textBaseline) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Base class for tiles.
 * 
 * @param {!Array<?>} tileCoord
 * @param {number} state
 */
ol.Tile = function(tileCoord, state) {};

/**
 * Get the tile coordinate for this tile.
 * \@api
 * @return {!Array<?>}
 */
ol.Tile.prototype.getTileCoord = function() {};

/**
 * Load the image or retry if loading previously failed.
 * Loading is taken care of by the tile queue, and calling this method is
 * only needed for preloading or for reloading in case of an error.
 * @abstract
 * \@api
 * @return {void}
 */
ol.Tile.prototype.load = function() {};

/** @typedef {number} */
ol.Tile.State;
/** @const */
ol.tilegrid = {};

/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * \@api
 * @param {!olx.tilegrid.XYZOptions=} opt_options
 * @return {!ol.tilegrid.TileGrid}
 */
ol.tilegrid.createXYZ = function(opt_options) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * 
 * @struct
 * \@api stable
 * @param {!olx.tilegrid.TileGridOptions} options
 */
ol.tilegrid.TileGrid = function(options) {};

/**
 * Call a function with each tile coordinate for a given extent and zoom level.
 * 
 * \@api
 * @param {!Array<?>} extent
 * @param {number} zoom
 * @param {function(!Array<?>): ?} callback
 * @return {void}
 */
ol.tilegrid.TileGrid.prototype.forEachTileCoord = function(extent, zoom, callback) {};

/**
 * Get the maximum zoom level for the grid.
 * \@api
 * @return {number}
 */
ol.tilegrid.TileGrid.prototype.getMaxZoom = function() {};

/**
 * Get the minimum zoom level for the grid.
 * \@api
 * @return {number}
 */
ol.tilegrid.TileGrid.prototype.getMinZoom = function() {};

/**
 * Get the origin for the grid at the given zoom level.
 * \@api stable
 * @param {number} z
 * @return {!Array<?>}
 */
ol.tilegrid.TileGrid.prototype.getOrigin = function(z) {};

/**
 * Get the resolution for the given zoom level.
 * \@api stable
 * @param {number} z
 * @return {number}
 */
ol.tilegrid.TileGrid.prototype.getResolution = function(z) {};

/**
 * Get the list of resolutions for the tile grid.
 * \@api stable
 * @return {!Array<number>}
 */
ol.tilegrid.TileGrid.prototype.getResolutions = function() {};

/**
 * Get the extent of a tile coordinate.
 * 
 * \@api
 * @param {!Array<?>} tileCoord
 * @param {!Array<?>=} opt_extent
 * @return {!Array<?>}
 */
ol.tilegrid.TileGrid.prototype.getTileCoordExtent = function(tileCoord, opt_extent) {};

/**
 * Get the tile coordinate for the given map coordinate and resolution.  This
 * method considers that coordinates that intersect tile boundaries should be
 * assigned the higher tile coordinate.
 * 
 * \@api
 * @param {!Array<?>} coordinate
 * @param {number} resolution
 * @param {!Array<?>=} opt_tileCoord
 * @return {!Array<?>}
 */
ol.tilegrid.TileGrid.prototype.getTileCoordForCoordAndResolution = function(coordinate, resolution, opt_tileCoord) {};

/**
 * Get a tile coordinate given a map coordinate and zoom level.
 * \@api
 * @param {!Array<?>} coordinate
 * @param {number} z
 * @param {!Array<?>=} opt_tileCoord
 * @return {!Array<?>}
 */
ol.tilegrid.TileGrid.prototype.getTileCoordForCoordAndZ = function(coordinate, z, opt_tileCoord) {};

/**
 * Get the tile size for a zoom level. The type of the return value matches the
 * `tileSize` or `tileSizes` that the tile grid was configured with. To always
 * get an `ol.Size`, run the result through `ol.size.toSize()`.
 * \@api stable
 * @param {number} z
 * @return {(number|!Array<?>)}
 */
ol.tilegrid.TileGrid.prototype.getTileSize = function(z) {};

/**
 *     If 1, the nearest lower resolution will be used. If -1, the nearest
 *     higher resolution will be used. Default is 0.
 * \@api
 * @param {number} resolution
 * @param {number=} opt_direction
 * @return {number}
 */
ol.tilegrid.TileGrid.prototype.getZForResolution = function(resolution, opt_direction) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * Set the grid pattern for sources accessing WMTS tiled-image servers.
 * 
 * @struct
 * \@api
 * @param {!olx.tilegrid.WMTSOptions} options
 */
ol.tilegrid.WMTS = function(options) {};

/**
 * Get the list of matrix identifiers.
 * \@api
 * @return {!Array<string>}
 */
ol.tilegrid.WMTS.prototype.getMatrixIds = function() {};

/**
 * Create a tile grid from a WMTS capabilities matrix set.
 *     capabilities document.
 *     ranges the server provides.
 * \@api
 * @param {!Object} matrixSet
 * @param {!Array<?>=} opt_extent
 * @return {!ol.tilegrid.WMTS}
 */
ol.tilegrid.WMTS.createFromCapabilitiesMatrixSet = function(matrixSet, opt_extent) {};

/** @typedef {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
ol.AttributionLike;

/** @typedef {function(!Array<?>, number, number, !Array<?>, !ol.proj.Projection): !HTMLCanvasElement} */
ol.CanvasFunctionType;

/** @typedef {(!Array<?>|!Uint8Array|!Uint8ClampedArray)} */
ol.Color;

/** @typedef {(string|!CanvasPattern|!CanvasGradient)} */
ol.ColorLike;

/** @typedef {!Array<?>} */
ol.Coordinate;

/** @typedef {function(!Array<?>): string} */
ol.CoordinateFormatType;

/** @typedef {function(!ol.MapBrowserEvent, !Array<?>, !Array<?>): boolean} */
ol.DragBoxEndConditionType;

/** @typedef {function((!Array<?>|!Array<!Array<?>>|!Array<!Array<!Array<?>>>), !ol.geom.SimpleGeometry): !ol.geom.SimpleGeometry} */
ol.DrawGeometryFunctionType;

/** @typedef {function(!ol.MapBrowserEvent): boolean} */
ol.EventsConditionType;

/** @typedef {!ol.Object} */
ol.EventsKey;

/** @typedef {!Array<?>} */
ol.Extent;

/** @typedef {function(!Array<?>, number, !ol.proj.Projection): void} */
ol.FeatureLoader;

/** @typedef {function(number): (!ol.style.Style|!Array<!ol.style.Style>)} */
ol.FeatureStyleFunction;

/** @typedef {function(!Array<?>, number, !ol.proj.Projection): string} */
ol.FeatureUrlFunction;

/** @typedef {function(!ol.Image, string): void} */
ol.ImageLoadFunctionType;

/** @typedef {function(!Array<?>, number): !Array<!Array<?>>} */
ol.LoadingStrategy;

/** @typedef {string} */
ol.ModifyEventType;

/** @typedef {!Array<?>} */
ol.Pixel;

/** @typedef {function(!ol.Map, !olx.FrameState): boolean} */
ol.PreRenderFunction;

/** @typedef {(string|!ol.proj.Projection)} */
ol.ProjectionLike;

/** @typedef {function((!Array<!Array<number>>|!Array<!ImageData>), !Object): (!Array<number>|!ImageData)} */
ol.RasterOperation;

/** @typedef {function((!ol.Feature|!ol.render.Feature), !ol.layer.Layer): boolean} */
ol.SelectFilterFunction;

/** @typedef {!Array<?>} */
ol.Size;
/**
 * @record
 * @struct
 */
ol.SourceImageOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
ol.SourceImageOptions.prototype.attributions;
 /** @type {!Array<?>} */
ol.SourceImageOptions.prototype.extent;
 /** @type {(string|!olx.LogoOptions)} */
ol.SourceImageOptions.prototype.logo;
 /** @type {(string|!ol.proj.Projection)} */
ol.SourceImageOptions.prototype.projection;
 /** @type {!Array<number>} */
ol.SourceImageOptions.prototype.resolutions;
 /** @type {string} */
ol.SourceImageOptions.prototype.state;
/**
 * @record
 * @struct
 */
ol.SourceSourceOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
ol.SourceSourceOptions.prototype.attributions;
 /** @type {(string|!olx.LogoOptions)} */
ol.SourceSourceOptions.prototype.logo;
 /** @type {(string|!ol.proj.Projection)} */
ol.SourceSourceOptions.prototype.projection;
 /** @type {string} */
ol.SourceSourceOptions.prototype.state;
 /** @type {boolean} */
ol.SourceSourceOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
ol.SourceUrlTileOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
ol.SourceUrlTileOptions.prototype.attributions;
 /** @type {number} */
ol.SourceUrlTileOptions.prototype.cacheSize;
 /** @type {!Array<?>} */
ol.SourceUrlTileOptions.prototype.extent;
 /** @type {(string|!olx.LogoOptions)} */
ol.SourceUrlTileOptions.prototype.logo;
 /** @type {boolean} */
ol.SourceUrlTileOptions.prototype.opaque;
 /** @type {(string|!ol.proj.Projection)} */
ol.SourceUrlTileOptions.prototype.projection;
 /** @type {string} */
ol.SourceUrlTileOptions.prototype.state;
 /** @type {!ol.tilegrid.TileGrid} */
ol.SourceUrlTileOptions.prototype.tileGrid;
 /** @type {function(!ol.Tile, string): void} */
ol.SourceUrlTileOptions.prototype.tileLoadFunction;
 /** @type {number} */
ol.SourceUrlTileOptions.prototype.tilePixelRatio;
 /** @type {function(!Array<?>, number, !ol.proj.Projection): string} */
ol.SourceUrlTileOptions.prototype.tileUrlFunction;
 /** @type {string} */
ol.SourceUrlTileOptions.prototype.url;
 /** @type {!Array<string>} */
ol.SourceUrlTileOptions.prototype.urls;
 /** @type {boolean} */
ol.SourceUrlTileOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
ol.SourceTileOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
ol.SourceTileOptions.prototype.attributions;
 /** @type {number} */
ol.SourceTileOptions.prototype.cacheSize;
 /** @type {!Array<?>} */
ol.SourceTileOptions.prototype.extent;
 /** @type {(string|!olx.LogoOptions)} */
ol.SourceTileOptions.prototype.logo;
 /** @type {boolean} */
ol.SourceTileOptions.prototype.opaque;
 /** @type {number} */
ol.SourceTileOptions.prototype.tilePixelRatio;
 /** @type {(string|!ol.proj.Projection)} */
ol.SourceTileOptions.prototype.projection;
 /** @type {string} */
ol.SourceTileOptions.prototype.state;
 /** @type {!ol.tilegrid.TileGrid} */
ol.SourceTileOptions.prototype.tileGrid;
 /** @type {boolean} */
ol.SourceTileOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
ol.StyleImageOptions = function() {};
 /** @type {number} */
ol.StyleImageOptions.prototype.opacity;
 /** @type {boolean} */
ol.StyleImageOptions.prototype.rotateWithView;
 /** @type {number} */
ol.StyleImageOptions.prototype.rotation;
 /** @type {number} */
ol.StyleImageOptions.prototype.scale;
 /** @type {boolean} */
ol.StyleImageOptions.prototype.snapToPixel;

/** @typedef {function((!ol.Feature|!ol.render.Feature), number): (!ol.style.Style|!Array<!ol.style.Style>)} */
ol.StyleFunction;

/** @typedef {function((!ol.Feature|!ol.render.Feature)): (!ol.geom.Geometry|!ol.render.Feature)} */
ol.StyleGeometryFunction;

/** @typedef {!Array<?>} */
ol.TileCoord;

/** @typedef {function(!ol.Tile, string): void} */
ol.TileLoadFunctionType;

/** @typedef {function(!Array<?>, number, !ol.proj.Projection): string} */
ol.TileUrlFunctionType;

/** @typedef {function(!Array<number>, !Array<number>, number): !Array<number>} */
ol.TransformFunction;

/** @typedef {!ol.Object} */
ol.WFSFeatureCollectionMetadata;

/** @typedef {!ol.Object} */
ol.WFSTransactionResponse;

/**
 * @constructor
 * @struct
 * @param {!Array<?>} tileCoord
 * @param {number} state
 * @param {string} src
 * @param {!ol.format.Feature} format
 * @param {function(!ol.Tile, string): void} tileLoadFunction
 */
ol.VectorTile = function(tileCoord, state, src, format, tileLoadFunction) {};

/**
 * Get the feature format assigned for reading this tile's features.
 * \@api
 * @return {!ol.format.Feature}
 */
ol.VectorTile.prototype.getFormat = function() {};

/**
 * \@api
 * @param {!Array<!ol.Feature>} features
 * @return {void}
 */
ol.VectorTile.prototype.setFeatures = function(features) {};

/**
 * Set the projection of the features that were added with {\@link #setFeatures}.
 * \@api
 * @param {!ol.proj.Projection} projection
 * @return {void}
 */
ol.VectorTile.prototype.setProjection = function(projection) {};

/**
 * Set the feature loader for reading this tile's features.
 * \@api
 * @param {function(!Array<?>, number, !ol.proj.Projection): void} loader
 * @return {void}
 */
ol.VectorTile.prototype.setLoader = function(loader) {};

/**
 * @constructor
 * @struct
 * \@classdesc 
 * An ol.View object represents a simple 2D view of the map.
 * 
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 * 
 * ### The view states
 * 
 * An `ol.View` is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 * 
 * An `ol.View` has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Spherical Mercator (EPSG:3857).
 * 
 * ### The constraints
 * 
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view. Any value can be passed to the setters. And the value
 * that is passed to a setter will effectively be the value set in the view,
 * and returned by the corresponding getter.
 * 
 * But an `ol.View` object also has a *resolution constraint*, a
 * *rotation constraint* and a *center constraint*.
 * 
 * As said above, no constraints are applied when the setters are used to set
 * new states for the view. Applying constraints is done explicitly through
 * the use of the `constrain*` functions (`constrainResolution` and
 * `constrainRotation` and `constrainCenter`).
 * 
 * The main users of the constraints are the interactions and the
 * controls. For example, double-clicking on the map changes the view to
 * the "next" resolution. And releasing the fingers after pinch-zooming
 * snaps to the closest resolution (with an animation).
 * 
 * The *resolution constraint* snaps to specific resolutions. It is
 * determined by the following options: `resolutions`, `maxResolution`,
 * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three
 * options are ignored. See documentation for each option for more
 * information.
 * 
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default the rotation value is snapped to zero when approaching the
 * horizontal.
 * 
 * The *center constraint* is determined by the `extent` option. By
 * default the center is not constrained at all.
 * 
 * \@api stable
 * @param {!olx.ViewOptions=} opt_options
 */
ol.View = function(opt_options) {};

/**
 * Get the constrained center of this view.
 * \@api
 * @param {!Array<?>} center
 * @return {!Array<?>}
 */
ol.View.prototype.constrainCenter = function(center) {};

/**
 * Get the constrained resolution of this view.
 * \@api
 * @param {number} resolution
 * @param {number=} opt_delta
 * @param {number=} opt_direction
 * @return {number}
 */
ol.View.prototype.constrainResolution = function(resolution, opt_delta, opt_direction) {};

/**
 * Get the constrained rotation of this view.
 * \@api
 * @param {number} rotation
 * @param {number=} opt_delta
 * @return {number}
 */
ol.View.prototype.constrainRotation = function(rotation, opt_delta) {};

/**
 * Get the view center.
 * \@observable
 * \@api stable
 * @return {!Array<?>}
 */
ol.View.prototype.getCenter = function() {};

/**
 * Calculate the extent for the current view state and the passed size.
 * The size is the pixel dimensions of the box into which the calculated extent
 * should fit. In most cases you want to get the extent of the entire map,
 * that is `map.getSize()`.
 * \@api stable
 * @param {!Array<?>} size
 * @return {!Array<?>}
 */
ol.View.prototype.calculateExtent = function(size) {};

/**
 * Get the maximum resolution of the view.
 * \@api
 * @return {number}
 */
ol.View.prototype.getMaxResolution = function() {};

/**
 * Get the minimum resolution of the view.
 * \@api
 * @return {number}
 */
ol.View.prototype.getMinResolution = function() {};

/**
 * Get the view projection.
 * \@api stable
 * @return {!ol.proj.Projection}
 */
ol.View.prototype.getProjection = function() {};

/**
 * Get the view resolution.
 * \@observable
 * \@api stable
 * @return {number}
 */
ol.View.prototype.getResolution = function() {};

/**
 * Get the resolutions for the view. This returns the array of resolutions
 * passed to the constructor of the {ol.View}, or undefined if none were given.
 * \@api stable
 * @return {!Array<number>}
 */
ol.View.prototype.getResolutions = function() {};

/**
 * Get the view rotation.
 * \@observable
 * \@api stable
 * @return {number}
 */
ol.View.prototype.getRotation = function() {};

/**
 * Get the current zoom level. Return undefined if the current
 * resolution is undefined or not within the "resolution constraints".
 * \@api stable
 * @return {number}
 */
ol.View.prototype.getZoom = function() {};

/**
 * Fit the given geometry or extent based on the given map size and border.
 * The size is pixel dimensions of the box to fit the extent into.
 * In most cases you will want to use the map size, that is `map.getSize()`.
 * Takes care of the map angle.
 * \@api
 * @param {(!Array<?>|!ol.geom.SimpleGeometry)} geometry
 * @param {!Array<?>} size
 * @param {!olx.view.FitOptions=} opt_options
 * @return {void}
 */
ol.View.prototype.fit = function(geometry, size, opt_options) {};

/**
 * Center on coordinate and view position.
 * \@api
 * @param {!Array<?>} coordinate
 * @param {!Array<?>} size
 * @param {!Array<?>} position
 * @return {void}
 */
ol.View.prototype.centerOn = function(coordinate, size, position) {};

/**
 * Rotate the view around a given coordinate.
 * \@api stable
 * @param {number} rotation
 * @param {!Array<?>=} opt_anchor
 * @return {void}
 */
ol.View.prototype.rotate = function(rotation, opt_anchor) {};

/**
 * Set the center of the current view.
 * \@observable
 * \@api stable
 * @param {!Array<?>} center
 * @return {void}
 */
ol.View.prototype.setCenter = function(center) {};

/**
 * Set the resolution for this view.
 * \@observable
 * \@api stable
 * @param {number} resolution
 * @return {void}
 */
ol.View.prototype.setResolution = function(resolution) {};

/**
 * Set the rotation for this view.
 * \@observable
 * \@api stable
 * @param {number} rotation
 * @return {void}
 */
ol.View.prototype.setRotation = function(rotation) {};

/**
 * Zoom to a specific zoom level.
 * \@api stable
 * @param {number} zoom
 * @return {void}
 */
ol.View.prototype.setZoom = function(zoom) {};

/**
 * Animate the view. The view's center, zoom (or resolution), and
 * rotation can be animated for smooth transitions between view states.
 * \@api experimental
 * @param {...(!olx.animation.AnimateOptions|function(boolean): void)} var_args
 * @return {void}
 */
ol.View.prototype.animate = function(var_args) {};
/** @const */
var olx = {};
/** @const */
olx.animation = {};
/**
 * @record
 * @struct
 */
olx.animation.BounceOptions = function() {};
 /** @type {number} */
olx.animation.BounceOptions.prototype.resolution;
 /** @type {number} */
olx.animation.BounceOptions.prototype.start;
 /** @type {number} */
olx.animation.BounceOptions.prototype.duration;
 /** @type {function(number): number} */
olx.animation.BounceOptions.prototype.easing;
/**
 * @record
 * @struct
 */
olx.animation.PanOptions = function() {};
 /** @type {!Array<?>} */
olx.animation.PanOptions.prototype.source;
 /** @type {number} */
olx.animation.PanOptions.prototype.start;
 /** @type {number} */
olx.animation.PanOptions.prototype.duration;
 /** @type {function(number): number} */
olx.animation.PanOptions.prototype.easing;
/**
 * @record
 * @struct
 */
olx.animation.RotateOptions = function() {};
 /** @type {number} */
olx.animation.RotateOptions.prototype.rotation;
 /** @type {!Array<?>} */
olx.animation.RotateOptions.prototype.anchor;
 /** @type {number} */
olx.animation.RotateOptions.prototype.start;
 /** @type {number} */
olx.animation.RotateOptions.prototype.duration;
 /** @type {function(number): number} */
olx.animation.RotateOptions.prototype.easing;
/**
 * @record
 * @struct
 */
olx.animation.ZoomOptions = function() {};
 /** @type {number} */
olx.animation.ZoomOptions.prototype.resolution;
 /** @type {number} */
olx.animation.ZoomOptions.prototype.start;
 /** @type {number} */
olx.animation.ZoomOptions.prototype.duration;
 /** @type {function(number): number} */
olx.animation.ZoomOptions.prototype.easing;
/**
 * @record
 * @struct
 */
olx.animation.AnimateOptions = function() {};
 /** @type {!Array<?>} */
olx.animation.AnimateOptions.prototype.center;
 /** @type {number} */
olx.animation.AnimateOptions.prototype.zoom;
 /** @type {number} */
olx.animation.AnimateOptions.prototype.resolution;
 /** @type {number} */
olx.animation.AnimateOptions.prototype.rotation;
 /** @type {number} */
olx.animation.AnimateOptions.prototype.anchor;
 /** @type {number} */
olx.animation.AnimateOptions.prototype.duration;
 /** @type {function(number): number} */
olx.animation.AnimateOptions.prototype.easing;

/** @typedef {function(boolean): void} */
olx.animation.AnimateCallback;
/** @const */
olx.control = {};
/**
 * @record
 * @struct
 */
olx.control.AttributionOptions = function() {};
 /** @type {string} */
olx.control.AttributionOptions.prototype.className;
 /** @type {!Element} */
olx.control.AttributionOptions.prototype.target;
 /** @type {boolean} */
olx.control.AttributionOptions.prototype.collapsible;
 /** @type {boolean} */
olx.control.AttributionOptions.prototype.collapsed;
 /** @type {string} */
olx.control.AttributionOptions.prototype.tipLabel;
 /** @type {(string|!Node)} */
olx.control.AttributionOptions.prototype.label;
 /** @type {(string|!Node)} */
olx.control.AttributionOptions.prototype.collapseLabel;
 /** @type {function(!ol.MapEvent): ?} */
olx.control.AttributionOptions.prototype.render;
/**
 * @record
 * @struct
 */
olx.control.ControlOptions = function() {};
 /** @type {!Element} */
olx.control.ControlOptions.prototype.element;
 /** @type {function(!ol.MapEvent): ?} */
olx.control.ControlOptions.prototype.render;
 /** @type {(string|!Element)} */
olx.control.ControlOptions.prototype.target;
/**
 * @record
 * @struct
 */
olx.control.DefaultsOptions = function() {};
 /** @type {boolean} */
olx.control.DefaultsOptions.prototype.attribution;
 /** @type {!olx.control.AttributionOptions} */
olx.control.DefaultsOptions.prototype.attributionOptions;
 /** @type {boolean} */
olx.control.DefaultsOptions.prototype.rotate;
 /** @type {!olx.control.RotateOptions} */
olx.control.DefaultsOptions.prototype.rotateOptions;
 /** @type {boolean} */
olx.control.DefaultsOptions.prototype.zoom;
 /** @type {!olx.control.ZoomOptions} */
olx.control.DefaultsOptions.prototype.zoomOptions;
/**
 * @record
 * @struct
 */
olx.control.FullScreenOptions = function() {};
 /** @type {string} */
olx.control.FullScreenOptions.prototype.className;
 /** @type {(string|!Node)} */
olx.control.FullScreenOptions.prototype.label;
 /** @type {(string|!Node)} */
olx.control.FullScreenOptions.prototype.labelActive;
 /** @type {string} */
olx.control.FullScreenOptions.prototype.tipLabel;
 /** @type {boolean} */
olx.control.FullScreenOptions.prototype.keys;
 /** @type {!Element} */
olx.control.FullScreenOptions.prototype.target;
 /** @type {(string|!Element)} */
olx.control.FullScreenOptions.prototype.source;
/**
 * @record
 * @struct
 */
olx.control.MousePositionOptions = function() {};
 /** @type {string} */
olx.control.MousePositionOptions.prototype.className;
 /** @type {function(!Array<?>): string} */
olx.control.MousePositionOptions.prototype.coordinateFormat;
 /** @type {(string|!ol.proj.Projection)} */
olx.control.MousePositionOptions.prototype.projection;
 /** @type {function(!ol.MapEvent): ?} */
olx.control.MousePositionOptions.prototype.render;
 /** @type {!Element} */
olx.control.MousePositionOptions.prototype.target;
 /** @type {string} */
olx.control.MousePositionOptions.prototype.undefinedHTML;
/**
 * @record
 * @struct
 */
olx.control.OverviewMapOptions = function() {};
 /** @type {boolean} */
olx.control.OverviewMapOptions.prototype.collapsed;
 /** @type {(string|!Node)} */
olx.control.OverviewMapOptions.prototype.collapseLabel;
 /** @type {boolean} */
olx.control.OverviewMapOptions.prototype.collapsible;
 /** @type {(string|!Node)} */
olx.control.OverviewMapOptions.prototype.label;
 /** @type {(!Array<!ol.layer.Layer>|!ol.Collection<!ol.layer.Layer>)} */
olx.control.OverviewMapOptions.prototype.layers;
 /** @type {function(!ol.MapEvent): ?} */
olx.control.OverviewMapOptions.prototype.render;
 /** @type {!Element} */
olx.control.OverviewMapOptions.prototype.target;
 /** @type {string} */
olx.control.OverviewMapOptions.prototype.tipLabel;
 /** @type {!ol.View} */
olx.control.OverviewMapOptions.prototype.view;
/**
 * @record
 * @struct
 */
olx.control.ScaleLineOptions = function() {};
 /** @type {string} */
olx.control.ScaleLineOptions.prototype.className;
 /** @type {number} */
olx.control.ScaleLineOptions.prototype.minWidth;
 /** @type {function(!ol.MapEvent): ?} */
olx.control.ScaleLineOptions.prototype.render;
 /** @type {!Element} */
olx.control.ScaleLineOptions.prototype.target;
 /** @type {string} */
olx.control.ScaleLineOptions.prototype.units;
/**
 * @record
 * @struct
 */
olx.control.RotateOptions = function() {};
 /** @type {string} */
olx.control.RotateOptions.prototype.className;
 /** @type {(string|!Element)} */
olx.control.RotateOptions.prototype.label;
 /** @type {string} */
olx.control.RotateOptions.prototype.tipLabel;
 /** @type {number} */
olx.control.RotateOptions.prototype.duration;
 /** @type {boolean} */
olx.control.RotateOptions.prototype.autoHide;
 /** @type {function(!ol.MapEvent): ?} */
olx.control.RotateOptions.prototype.render;
 /** @type {function(): ?} */
olx.control.RotateOptions.prototype.resetNorth;
 /** @type {!Element} */
olx.control.RotateOptions.prototype.target;
/**
 * @record
 * @struct
 */
olx.control.ZoomOptions = function() {};
 /** @type {number} */
olx.control.ZoomOptions.prototype.duration;
 /** @type {string} */
olx.control.ZoomOptions.prototype.className;
 /** @type {(string|!Node)} */
olx.control.ZoomOptions.prototype.zoomInLabel;
 /** @type {(string|!Node)} */
olx.control.ZoomOptions.prototype.zoomOutLabel;
 /** @type {string} */
olx.control.ZoomOptions.prototype.zoomInTipLabel;
 /** @type {string} */
olx.control.ZoomOptions.prototype.zoomOutTipLabel;
 /** @type {number} */
olx.control.ZoomOptions.prototype.delta;
 /** @type {!Element} */
olx.control.ZoomOptions.prototype.target;
/**
 * @record
 * @struct
 */
olx.control.ZoomSliderOptions = function() {};
 /** @type {string} */
olx.control.ZoomSliderOptions.prototype.className;
 /** @type {number} */
olx.control.ZoomSliderOptions.prototype.duration;
 /** @type {number} */
olx.control.ZoomSliderOptions.prototype.maxResolution;
 /** @type {number} */
olx.control.ZoomSliderOptions.prototype.minResolution;
 /** @type {function(!ol.MapEvent): ?} */
olx.control.ZoomSliderOptions.prototype.render;
/**
 * @record
 * @struct
 */
olx.control.ZoomToExtentOptions = function() {};
 /** @type {string} */
olx.control.ZoomToExtentOptions.prototype.className;
 /** @type {!Element} */
olx.control.ZoomToExtentOptions.prototype.target;
 /** @type {(string|!Node)} */
olx.control.ZoomToExtentOptions.prototype.label;
 /** @type {string} */
olx.control.ZoomToExtentOptions.prototype.tipLabel;
 /** @type {!Array<?>} */
olx.control.ZoomToExtentOptions.prototype.extent;
/** @const */
olx.format = {};
/**
 * @record
 * @struct
 */
olx.format.ReadOptions = function() {};
 /** @type {(string|!ol.proj.Projection)} */
olx.format.ReadOptions.prototype.dataProjection;
 /** @type {(string|!ol.proj.Projection)} */
olx.format.ReadOptions.prototype.featureProjection;
/**
 * @record
 * @struct
 */
olx.format.WriteOptions = function() {};
 /** @type {(string|!ol.proj.Projection)} */
olx.format.WriteOptions.prototype.dataProjection;
 /** @type {(string|!ol.proj.Projection)} */
olx.format.WriteOptions.prototype.featureProjection;
 /** @type {boolean} */
olx.format.WriteOptions.prototype.rightHanded;
 /** @type {number} */
olx.format.WriteOptions.prototype.decimals;
/**
 * @record
 * @struct
 */
olx.format.GeoJSONOptions = function() {};
 /** @type {(string|!ol.proj.Projection)} */
olx.format.GeoJSONOptions.prototype.defaultDataProjection;
 /** @type {(string|!ol.proj.Projection)} */
olx.format.GeoJSONOptions.prototype.featureProjection;
 /** @type {string} */
olx.format.GeoJSONOptions.prototype.geometryName;
/**
 * @record
 * @struct
 */
olx.format.EsriJSONOptions = function() {};
 /** @type {string} */
olx.format.EsriJSONOptions.prototype.geometryName;
/**
 * @record
 * @struct
 */
olx.format.MVTOptions = function() {};
 /** @type {(function((!ol.geom.Geometry|!Object<string,?>)): ?|function(string, !Array<number>, (!Array<number>|!Array<!Array<number>>), !Object<string,?>): ?)} */
olx.format.MVTOptions.prototype.featureClass;
 /** @type {string} */
olx.format.MVTOptions.prototype.geometryName;
 /** @type {string} */
olx.format.MVTOptions.prototype.layerName;
 /** @type {!Array<string>} */
olx.format.MVTOptions.prototype.layers;
/**
 * @record
 * @struct
 */
olx.format.PolylineOptions = function() {};
 /** @type {number} */
olx.format.PolylineOptions.prototype.factor;
 /** @type {string} */
olx.format.PolylineOptions.prototype.geometryLayout;
/**
 * @record
 * @struct
 */
olx.format.TopoJSONOptions = function() {};
 /** @type {(string|!ol.proj.Projection)} */
olx.format.TopoJSONOptions.prototype.defaultDataProjection;
/**
 * @record
 * @struct
 */
olx.format.IGCOptions = function() {};
 /** @type {string} */
olx.format.IGCOptions.prototype.altitudeMode;
/**
 * @record
 * @struct
 */
olx.format.KMLOptions = function() {};
 /** @type {boolean} */
olx.format.KMLOptions.prototype.extractStyles;
 /** @type {boolean} */
olx.format.KMLOptions.prototype.showPointNames;
 /** @type {!Array<!ol.style.Style>} */
olx.format.KMLOptions.prototype.defaultStyle;
 /** @type {boolean} */
olx.format.KMLOptions.prototype.writeStyles;
/**
 * @record
 * @struct
 */
olx.format.GMLOptions = function() {};
 /** @type {(string|!Object<string,string>)} */
olx.format.GMLOptions.prototype.featureNS;
 /** @type {(string|!Array<string>)} */
olx.format.GMLOptions.prototype.featureType;
 /** @type {string} */
olx.format.GMLOptions.prototype.srsName;
 /** @type {boolean} */
olx.format.GMLOptions.prototype.surface;
 /** @type {boolean} */
olx.format.GMLOptions.prototype.curve;
 /** @type {boolean} */
olx.format.GMLOptions.prototype.multiCurve;
 /** @type {boolean} */
olx.format.GMLOptions.prototype.multiSurface;
 /** @type {string} */
olx.format.GMLOptions.prototype.schemaLocation;
/**
 * @record
 * @struct
 */
olx.format.GPXOptions = function() {};
 /** @type {function(!ol.Feature, !Node): ?} */
olx.format.GPXOptions.prototype.readExtensions;
/**
 * @record
 * @struct
 */
olx.format.WFSOptions = function() {};
 /** @type {(string|!Object<string,string>)} */
olx.format.WFSOptions.prototype.featureNS;
 /** @type {(string|!Array<string>)} */
olx.format.WFSOptions.prototype.featureType;
 /** @type {!ol.format.GMLBase} */
olx.format.WFSOptions.prototype.gmlFormat;
 /** @type {string} */
olx.format.WFSOptions.prototype.schemaLocation;
/**
 * @record
 * @struct
 */
olx.format.WFSWriteGetFeatureOptions = function() {};
 /** @type {string} */
olx.format.WFSWriteGetFeatureOptions.prototype.featureNS;
 /** @type {string} */
olx.format.WFSWriteGetFeatureOptions.prototype.featurePrefix;
 /** @type {!Array<string>} */
olx.format.WFSWriteGetFeatureOptions.prototype.featureTypes;
 /** @type {string} */
olx.format.WFSWriteGetFeatureOptions.prototype.srsName;
 /** @type {string} */
olx.format.WFSWriteGetFeatureOptions.prototype.handle;
 /** @type {string} */
olx.format.WFSWriteGetFeatureOptions.prototype.outputFormat;
 /** @type {number} */
olx.format.WFSWriteGetFeatureOptions.prototype.maxFeatures;
 /** @type {string} */
olx.format.WFSWriteGetFeatureOptions.prototype.geometryName;
 /** @type {!Array<string>} */
olx.format.WFSWriteGetFeatureOptions.prototype.propertyNames;
 /** @type {number} */
olx.format.WFSWriteGetFeatureOptions.prototype.startIndex;
 /** @type {number} */
olx.format.WFSWriteGetFeatureOptions.prototype.count;
 /** @type {!Array<?>} */
olx.format.WFSWriteGetFeatureOptions.prototype.bbox;
 /** @type {!ol.format.filter.Filter} */
olx.format.WFSWriteGetFeatureOptions.prototype.filter;
 /** @type {string} */
olx.format.WFSWriteGetFeatureOptions.prototype.resultType;
/**
 * @record
 * @struct
 */
olx.format.WFSWriteTransactionOptions = function() {};
 /** @type {string} */
olx.format.WFSWriteTransactionOptions.prototype.featureNS;
 /** @type {string} */
olx.format.WFSWriteTransactionOptions.prototype.featurePrefix;
 /** @type {string} */
olx.format.WFSWriteTransactionOptions.prototype.featureType;
 /** @type {string} */
olx.format.WFSWriteTransactionOptions.prototype.srsName;
 /** @type {string} */
olx.format.WFSWriteTransactionOptions.prototype.handle;
 /** @type {!Array<!Object>} */
olx.format.WFSWriteTransactionOptions.prototype.nativeElements;
 /** @type {!olx.format.GMLOptions} */
olx.format.WFSWriteTransactionOptions.prototype.gmlOptions;
/**
 * @record
 * @struct
 */
olx.format.WKTOptions = function() {};
 /** @type {boolean} */
olx.format.WKTOptions.prototype.splitCollection;
/**
 * @record
 * @struct
 */
olx.format.WMSGetFeatureInfoOptions = function() {};
 /** @type {!Array<string>} */
olx.format.WMSGetFeatureInfoOptions.prototype.layers;
/** @const */
olx.interaction = {};
/**
 * @record
 * @struct
 */
olx.interaction.InteractionOptions = function() {};
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.InteractionOptions.prototype.handleEvent;
/**
 * @record
 * @struct
 */
olx.interaction.DefaultsOptions = function() {};
 /** @type {boolean} */
olx.interaction.DefaultsOptions.prototype.altShiftDragRotate;
 /** @type {boolean} */
olx.interaction.DefaultsOptions.prototype.doubleClickZoom;
 /** @type {boolean} */
olx.interaction.DefaultsOptions.prototype.keyboard;
 /** @type {boolean} */
olx.interaction.DefaultsOptions.prototype.mouseWheelZoom;
 /** @type {boolean} */
olx.interaction.DefaultsOptions.prototype.shiftDragZoom;
 /** @type {boolean} */
olx.interaction.DefaultsOptions.prototype.dragPan;
 /** @type {boolean} */
olx.interaction.DefaultsOptions.prototype.pinchRotate;
 /** @type {boolean} */
olx.interaction.DefaultsOptions.prototype.pinchZoom;
 /** @type {number} */
olx.interaction.DefaultsOptions.prototype.zoomDelta;
 /** @type {number} */
olx.interaction.DefaultsOptions.prototype.zoomDuration;
/**
 * @record
 * @struct
 */
olx.interaction.DoubleClickZoomOptions = function() {};
 /** @type {number} */
olx.interaction.DoubleClickZoomOptions.prototype.duration;
 /** @type {number} */
olx.interaction.DoubleClickZoomOptions.prototype.delta;
/**
 * @record
 * @struct
 */
olx.interaction.DragAndDropOptions = function() {};
 /** @type {!Array<function(!ol.format.Feature): ?>} */
olx.interaction.DragAndDropOptions.prototype.formatConstructors;
 /** @type {(string|!ol.proj.Projection)} */
olx.interaction.DragAndDropOptions.prototype.projection;
 /** @type {!Element} */
olx.interaction.DragAndDropOptions.prototype.target;
/**
 * @record
 * @struct
 */
olx.interaction.DragBoxOptions = function() {};
 /** @type {string} */
olx.interaction.DragBoxOptions.prototype.className;
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.DragBoxOptions.prototype.condition;
 /** @type {function(!ol.MapBrowserEvent, !Array<?>, !Array<?>): boolean} */
olx.interaction.DragBoxOptions.prototype.boxEndCondition;
/**
 * @record
 * @struct
 */
olx.interaction.DragPanOptions = function() {};
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.DragPanOptions.prototype.condition;
 /** @type {!ol.Kinetic} */
olx.interaction.DragPanOptions.prototype.kinetic;
/**
 * @record
 * @struct
 */
olx.interaction.DragRotateAndZoomOptions = function() {};
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.DragRotateAndZoomOptions.prototype.condition;
 /** @type {number} */
olx.interaction.DragRotateAndZoomOptions.prototype.duration;
/**
 * @record
 * @struct
 */
olx.interaction.DragRotateOptions = function() {};
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.DragRotateOptions.prototype.condition;
 /** @type {number} */
olx.interaction.DragRotateOptions.prototype.duration;
/**
 * @record
 * @struct
 */
olx.interaction.DragZoomOptions = function() {};
 /** @type {string} */
olx.interaction.DragZoomOptions.prototype.className;
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.DragZoomOptions.prototype.condition;
 /** @type {number} */
olx.interaction.DragZoomOptions.prototype.duration;
 /** @type {boolean} */
olx.interaction.DragZoomOptions.prototype.out;
/**
 * @record
 * @struct
 */
olx.interaction.DrawOptions = function() {};
 /** @type {number} */
olx.interaction.DrawOptions.prototype.clickTolerance;
 /** @type {!ol.Collection<!ol.Feature>} */
olx.interaction.DrawOptions.prototype.features;
 /** @type {!ol.source.Vector} */
olx.interaction.DrawOptions.prototype.source;
 /** @type {number} */
olx.interaction.DrawOptions.prototype.snapTolerance;
 /** @type {string} */
olx.interaction.DrawOptions.prototype.type;
 /** @type {number} */
olx.interaction.DrawOptions.prototype.maxPoints;
 /** @type {number} */
olx.interaction.DrawOptions.prototype.minPoints;
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.DrawOptions.prototype.finishCondition;
 /** @type {(!ol.style.Style|!Array<!ol.style.Style>|function((!ol.Feature|!ol.render.Feature), number): (!ol.style.Style|!Array<!ol.style.Style>))} */
olx.interaction.DrawOptions.prototype.style;
 /** @type {function((!Array<?>|!Array<!Array<?>>|!Array<!Array<!Array<?>>>), !ol.geom.SimpleGeometry): !ol.geom.SimpleGeometry} */
olx.interaction.DrawOptions.prototype.geometryFunction;
 /** @type {string} */
olx.interaction.DrawOptions.prototype.geometryName;
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.DrawOptions.prototype.condition;
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.DrawOptions.prototype.freehandCondition;
 /** @type {boolean} */
olx.interaction.DrawOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
olx.interaction.TranslateOptions = function() {};
 /** @type {!ol.Collection<!ol.Feature>} */
olx.interaction.TranslateOptions.prototype.features;
 /** @type {(!Array<!ol.layer.Layer>|function(!ol.layer.Layer): boolean)} */
olx.interaction.TranslateOptions.prototype.layers;
 /** @type {number} */
olx.interaction.TranslateOptions.prototype.hitTolerance;
/**
 * @record
 * @struct
 */
olx.interaction.KeyboardPanOptions = function() {};
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.KeyboardPanOptions.prototype.condition;
 /** @type {number} */
olx.interaction.KeyboardPanOptions.prototype.duration;
 /** @type {number} */
olx.interaction.KeyboardPanOptions.prototype.pixelDelta;
/**
 * @record
 * @struct
 */
olx.interaction.KeyboardZoomOptions = function() {};
 /** @type {number} */
olx.interaction.KeyboardZoomOptions.prototype.duration;
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.KeyboardZoomOptions.prototype.condition;
 /** @type {number} */
olx.interaction.KeyboardZoomOptions.prototype.delta;
/**
 * @record
 * @struct
 */
olx.interaction.ModifyOptions = function() {};
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.ModifyOptions.prototype.condition;
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.ModifyOptions.prototype.deleteCondition;
 /** @type {number} */
olx.interaction.ModifyOptions.prototype.pixelTolerance;
 /** @type {(!ol.style.Style|!Array<!ol.style.Style>|function((!ol.Feature|!ol.render.Feature), number): (!ol.style.Style|!Array<!ol.style.Style>))} */
olx.interaction.ModifyOptions.prototype.style;
 /** @type {!ol.Collection<!ol.Feature>} */
olx.interaction.ModifyOptions.prototype.features;
 /** @type {boolean} */
olx.interaction.ModifyOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
olx.interaction.MouseWheelZoomOptions = function() {};
 /** @type {number} */
olx.interaction.MouseWheelZoomOptions.prototype.duration;
 /** @type {boolean} */
olx.interaction.MouseWheelZoomOptions.prototype.useAnchor;
/**
 * @record
 * @struct
 */
olx.interaction.PinchRotateOptions = function() {};
 /** @type {number} */
olx.interaction.PinchRotateOptions.prototype.duration;
 /** @type {number} */
olx.interaction.PinchRotateOptions.prototype.threshold;
/**
 * @record
 * @struct
 */
olx.interaction.PinchZoomOptions = function() {};
 /** @type {number} */
olx.interaction.PinchZoomOptions.prototype.duration;
/**
 * @record
 * @struct
 */
olx.interaction.PointerOptions = function() {};
 /** @type {function(!ol.MapBrowserPointerEvent): boolean} */
olx.interaction.PointerOptions.prototype.handleDownEvent;
 /** @type {function(!ol.MapBrowserPointerEvent): boolean} */
olx.interaction.PointerOptions.prototype.handleDragEvent;
 /** @type {function(!ol.MapBrowserPointerEvent): boolean} */
olx.interaction.PointerOptions.prototype.handleEvent;
 /** @type {function(!ol.MapBrowserPointerEvent): boolean} */
olx.interaction.PointerOptions.prototype.handleMoveEvent;
 /** @type {function(!ol.MapBrowserPointerEvent): boolean} */
olx.interaction.PointerOptions.prototype.handleUpEvent;
/**
 * @record
 * @struct
 */
olx.interaction.SelectOptions = function() {};
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.SelectOptions.prototype.addCondition;
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.SelectOptions.prototype.condition;
 /** @type {(!Array<!ol.layer.Layer>|function(!ol.layer.Layer): boolean)} */
olx.interaction.SelectOptions.prototype.layers;
 /** @type {(!ol.style.Style|!Array<!ol.style.Style>|function((!ol.Feature|!ol.render.Feature), number): (!ol.style.Style|!Array<!ol.style.Style>))} */
olx.interaction.SelectOptions.prototype.style;
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.SelectOptions.prototype.removeCondition;
 /** @type {function(!ol.MapBrowserEvent): boolean} */
olx.interaction.SelectOptions.prototype.toggleCondition;
 /** @type {boolean} */
olx.interaction.SelectOptions.prototype.multi;
 /** @type {!ol.Collection<!ol.Feature>} */
olx.interaction.SelectOptions.prototype.features;
 /** @type {function((!ol.Feature|!ol.render.Feature), !ol.layer.Layer): boolean} */
olx.interaction.SelectOptions.prototype.filter;
 /** @type {boolean} */
olx.interaction.SelectOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
olx.interaction.SnapOptions = function() {};
 /** @type {!ol.Collection<!ol.Feature>} */
olx.interaction.SnapOptions.prototype.features;
 /** @type {boolean} */
olx.interaction.SnapOptions.prototype.edge;
 /** @type {boolean} */
olx.interaction.SnapOptions.prototype.vertex;
 /** @type {number} */
olx.interaction.SnapOptions.prototype.pixelTolerance;
 /** @type {!ol.source.Vector} */
olx.interaction.SnapOptions.prototype.source;
/** @const */
olx.layer = {};
/**
 * @record
 * @struct
 */
olx.layer.BaseOptions = function() {};
 /** @type {number} */
olx.layer.BaseOptions.prototype.opacity;
 /** @type {boolean} */
olx.layer.BaseOptions.prototype.visible;
 /** @type {!Array<?>} */
olx.layer.BaseOptions.prototype.extent;
 /** @type {number} */
olx.layer.BaseOptions.prototype.zIndex;
 /** @type {number} */
olx.layer.BaseOptions.prototype.minResolution;
 /** @type {number} */
olx.layer.BaseOptions.prototype.maxResolution;
/**
 * @record
 * @struct
 */
olx.layer.LayerOptions = function() {};
 /** @type {number} */
olx.layer.LayerOptions.prototype.opacity;
 /** @type {!ol.source.Source} */
olx.layer.LayerOptions.prototype.source;
 /** @type {boolean} */
olx.layer.LayerOptions.prototype.visible;
 /** @type {!Array<?>} */
olx.layer.LayerOptions.prototype.extent;
 /** @type {number} */
olx.layer.LayerOptions.prototype.zIndex;
 /** @type {number} */
olx.layer.LayerOptions.prototype.minResolution;
 /** @type {number} */
olx.layer.LayerOptions.prototype.maxResolution;
/**
 * @record
 * @struct
 */
olx.layer.GroupOptions = function() {};
 /** @type {number} */
olx.layer.GroupOptions.prototype.opacity;
 /** @type {boolean} */
olx.layer.GroupOptions.prototype.visible;
 /** @type {!Array<?>} */
olx.layer.GroupOptions.prototype.extent;
 /** @type {number} */
olx.layer.GroupOptions.prototype.zIndex;
 /** @type {number} */
olx.layer.GroupOptions.prototype.minResolution;
 /** @type {number} */
olx.layer.GroupOptions.prototype.maxResolution;
 /** @type {(!ol.Collection<!ol.layer.Base>|!Array<!ol.layer.Base>)} */
olx.layer.GroupOptions.prototype.layers;
/**
 * @record
 * @struct
 */
olx.layer.HeatmapOptions = function() {};
 /** @type {!Array<string>} */
olx.layer.HeatmapOptions.prototype.gradient;
 /** @type {number} */
olx.layer.HeatmapOptions.prototype.radius;
 /** @type {number} */
olx.layer.HeatmapOptions.prototype.blur;
 /** @type {number} */
olx.layer.HeatmapOptions.prototype.shadow;
 /** @type {(string|function(!ol.Feature): number)} */
olx.layer.HeatmapOptions.prototype.weight;
 /** @type {!Array<?>} */
olx.layer.HeatmapOptions.prototype.extent;
 /** @type {number} */
olx.layer.HeatmapOptions.prototype.minResolution;
 /** @type {number} */
olx.layer.HeatmapOptions.prototype.maxResolution;
 /** @type {number} */
olx.layer.HeatmapOptions.prototype.opacity;
 /** @type {!ol.source.Vector} */
olx.layer.HeatmapOptions.prototype.source;
 /** @type {boolean} */
olx.layer.HeatmapOptions.prototype.visible;
/**
 * @record
 * @struct
 */
olx.layer.ImageOptions = function() {};
 /** @type {number} */
olx.layer.ImageOptions.prototype.opacity;
 /** @type {!ol.source.Image} */
olx.layer.ImageOptions.prototype.source;
 /** @type {!ol.Map} */
olx.layer.ImageOptions.prototype.map;
 /** @type {boolean} */
olx.layer.ImageOptions.prototype.visible;
 /** @type {!Array<?>} */
olx.layer.ImageOptions.prototype.extent;
 /** @type {number} */
olx.layer.ImageOptions.prototype.minResolution;
 /** @type {number} */
olx.layer.ImageOptions.prototype.maxResolution;
/**
 * @record
 * @struct
 */
olx.layer.TileOptions = function() {};
 /** @type {number} */
olx.layer.TileOptions.prototype.opacity;
 /** @type {number} */
olx.layer.TileOptions.prototype.preload;
 /** @type {!ol.source.Tile} */
olx.layer.TileOptions.prototype.source;
 /** @type {!ol.Map} */
olx.layer.TileOptions.prototype.map;
 /** @type {boolean} */
olx.layer.TileOptions.prototype.visible;
 /** @type {!Array<?>} */
olx.layer.TileOptions.prototype.extent;
 /** @type {number} */
olx.layer.TileOptions.prototype.minResolution;
 /** @type {number} */
olx.layer.TileOptions.prototype.maxResolution;
 /** @type {boolean} */
olx.layer.TileOptions.prototype.useInterimTilesOnError;
/**
 * @record
 * @struct
 */
olx.layer.VectorOptions = function() {};
 /** @type {function(!ol.Feature, !ol.Feature): number} */
olx.layer.VectorOptions.prototype.renderOrder;
 /** @type {!ol.Map} */
olx.layer.VectorOptions.prototype.map;
 /** @type {!Array<?>} */
olx.layer.VectorOptions.prototype.extent;
 /** @type {number} */
olx.layer.VectorOptions.prototype.minResolution;
 /** @type {number} */
olx.layer.VectorOptions.prototype.maxResolution;
 /** @type {number} */
olx.layer.VectorOptions.prototype.opacity;
 /** @type {number} */
olx.layer.VectorOptions.prototype.renderBuffer;
 /** @type {!ol.source.Vector} */
olx.layer.VectorOptions.prototype.source;
 /** @type {(!ol.style.Style|!Array<!ol.style.Style>|function((!ol.Feature|!ol.render.Feature), number): (!ol.style.Style|!Array<!ol.style.Style>))} */
olx.layer.VectorOptions.prototype.style;
 /** @type {boolean} */
olx.layer.VectorOptions.prototype.updateWhileAnimating;
 /** @type {boolean} */
olx.layer.VectorOptions.prototype.updateWhileInteracting;
 /** @type {boolean} */
olx.layer.VectorOptions.prototype.visible;
/**
 * @record
 * @struct
 */
olx.layer.VectorTileOptions = function() {};
 /** @type {number} */
olx.layer.VectorTileOptions.prototype.renderBuffer;
 /** @type {string} */
olx.layer.VectorTileOptions.prototype.renderMode;
 /** @type {function(!ol.Feature, !ol.Feature): number} */
olx.layer.VectorTileOptions.prototype.renderOrder;
 /** @type {!ol.Map} */
olx.layer.VectorTileOptions.prototype.map;
 /** @type {!Array<?>} */
olx.layer.VectorTileOptions.prototype.extent;
 /** @type {number} */
olx.layer.VectorTileOptions.prototype.minResolution;
 /** @type {number} */
olx.layer.VectorTileOptions.prototype.maxResolution;
 /** @type {number} */
olx.layer.VectorTileOptions.prototype.opacity;
 /** @type {!ol.source.VectorTile} */
olx.layer.VectorTileOptions.prototype.source;
 /** @type {(!ol.style.Style|!Array<!ol.style.Style>|function((!ol.Feature|!ol.render.Feature), number): (!ol.style.Style|!Array<!ol.style.Style>))} */
olx.layer.VectorTileOptions.prototype.style;
 /** @type {boolean} */
olx.layer.VectorTileOptions.prototype.updateWhileAnimating;
 /** @type {boolean} */
olx.layer.VectorTileOptions.prototype.updateWhileInteracting;
 /** @type {boolean} */
olx.layer.VectorTileOptions.prototype.visible;
/** @const */
olx.parser = {};
/** @const */
olx.render = {};
/**
 * @record
 * @struct
 */
olx.render.ToContextOptions = function() {};
 /** @type {!Array<?>} */
olx.render.ToContextOptions.prototype.size;
 /** @type {number} */
olx.render.ToContextOptions.prototype.pixelRatio;
/** @const */
olx.source = {};
/**
 * @record
 * @struct
 */
olx.source.BingMapsOptions = function() {};
 /** @type {number} */
olx.source.BingMapsOptions.prototype.cacheSize;
 /** @type {string} */
olx.source.BingMapsOptions.prototype.culture;
 /** @type {string} */
olx.source.BingMapsOptions.prototype.key;
 /** @type {string} */
olx.source.BingMapsOptions.prototype.imagerySet;
 /** @type {number} */
olx.source.BingMapsOptions.prototype.maxZoom;
 /** @type {number} */
olx.source.BingMapsOptions.prototype.reprojectionErrorThreshold;
 /** @type {function(!ol.Tile, string): void} */
olx.source.BingMapsOptions.prototype.tileLoadFunction;
 /** @type {boolean} */
olx.source.BingMapsOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
olx.source.ClusterOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.ClusterOptions.prototype.attributions;
 /** @type {number} */
olx.source.ClusterOptions.prototype.distance;
 /** @type {!Array<?>} */
olx.source.ClusterOptions.prototype.extent;
 /** @type {function(!ol.Feature): !ol.geom.Point} */
olx.source.ClusterOptions.prototype.geometryFunction;
 /** @type {!ol.format.Feature} */
olx.source.ClusterOptions.prototype.format;
 /** @type {string} */
olx.source.ClusterOptions.prototype.logo;
 /** @type {(string|!ol.proj.Projection)} */
olx.source.ClusterOptions.prototype.projection;
 /** @type {!ol.source.Vector} */
olx.source.ClusterOptions.prototype.source;
 /** @type {boolean} */
olx.source.ClusterOptions.prototype.wrapX;

/** @typedef {!JSON} */
olx.source.TileJSON;
/**
 * @record
 * @struct
 */
olx.source.TileUTFGridOptions = function() {};
 /** @type {boolean} */
olx.source.TileUTFGridOptions.prototype.jsonp;
 /** @type {boolean} */
olx.source.TileUTFGridOptions.prototype.preemptive;
 /** @type {!JSON} */
olx.source.TileUTFGridOptions.prototype.tileJSON;
 /** @type {string} */
olx.source.TileUTFGridOptions.prototype.url;
/**
 * @record
 * @struct
 */
olx.source.TileImageOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.TileImageOptions.prototype.attributions;
 /** @type {number} */
olx.source.TileImageOptions.prototype.cacheSize;
 /** @type {string} */
olx.source.TileImageOptions.prototype.crossOrigin;
 /** @type {(string|!olx.LogoOptions)} */
olx.source.TileImageOptions.prototype.logo;
 /** @type {boolean} */
olx.source.TileImageOptions.prototype.opaque;
 /** @type {(string|!ol.proj.Projection)} */
olx.source.TileImageOptions.prototype.projection;
 /** @type {number} */
olx.source.TileImageOptions.prototype.reprojectionErrorThreshold;
 /** @type {string} */
olx.source.TileImageOptions.prototype.state;
 /** @type {function(!ol.ImageTile, !Array<?>, number, string, string, function(!ol.Tile, string): void): ?} */
olx.source.TileImageOptions.prototype.tileClass;
 /** @type {!ol.tilegrid.TileGrid} */
olx.source.TileImageOptions.prototype.tileGrid;
 /** @type {function(!ol.Tile, string): void} */
olx.source.TileImageOptions.prototype.tileLoadFunction;
 /** @type {number} */
olx.source.TileImageOptions.prototype.tilePixelRatio;
 /** @type {function(!Array<?>, number, !ol.proj.Projection): string} */
olx.source.TileImageOptions.prototype.tileUrlFunction;
 /** @type {string} */
olx.source.TileImageOptions.prototype.url;
 /** @type {!Array<string>} */
olx.source.TileImageOptions.prototype.urls;
 /** @type {boolean} */
olx.source.TileImageOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
olx.source.VectorTileOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.VectorTileOptions.prototype.attributions;
 /** @type {number} */
olx.source.VectorTileOptions.prototype.cacheSize;
 /** @type {!ol.format.Feature} */
olx.source.VectorTileOptions.prototype.format;
 /** @type {(string|!olx.LogoOptions)} */
olx.source.VectorTileOptions.prototype.logo;
 /** @type {boolean} */
olx.source.VectorTileOptions.prototype.overlaps;
 /** @type {(string|!ol.proj.Projection)} */
olx.source.VectorTileOptions.prototype.projection;
 /** @type {string} */
olx.source.VectorTileOptions.prototype.state;
 /** @type {function(!ol.VectorTile, !Array<?>, number, string, !ol.format.Feature, function(!ol.Tile, string): void): ?} */
olx.source.VectorTileOptions.prototype.tileClass;
 /** @type {!ol.tilegrid.TileGrid} */
olx.source.VectorTileOptions.prototype.tileGrid;
 /** @type {function(!ol.Tile, string): void} */
olx.source.VectorTileOptions.prototype.tileLoadFunction;
 /** @type {number} */
olx.source.VectorTileOptions.prototype.tilePixelRatio;
 /** @type {function(!Array<?>, number, !ol.proj.Projection): string} */
olx.source.VectorTileOptions.prototype.tileUrlFunction;
 /** @type {string} */
olx.source.VectorTileOptions.prototype.url;
 /** @type {!Array<string>} */
olx.source.VectorTileOptions.prototype.urls;
 /** @type {boolean} */
olx.source.VectorTileOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
olx.source.ImageMapGuideOptions = function() {};
 /** @type {string} */
olx.source.ImageMapGuideOptions.prototype.url;
 /** @type {number} */
olx.source.ImageMapGuideOptions.prototype.displayDpi;
 /** @type {number} */
olx.source.ImageMapGuideOptions.prototype.metersPerUnit;
 /** @type {boolean} */
olx.source.ImageMapGuideOptions.prototype.hidpi;
 /** @type {boolean} */
olx.source.ImageMapGuideOptions.prototype.useOverlay;
 /** @type {(string|!ol.proj.Projection)} */
olx.source.ImageMapGuideOptions.prototype.projection;
 /** @type {number} */
olx.source.ImageMapGuideOptions.prototype.ratio;
 /** @type {!Array<number>} */
olx.source.ImageMapGuideOptions.prototype.resolutions;
 /** @type {function(!ol.Image, string): void} */
olx.source.ImageMapGuideOptions.prototype.imageLoadFunction;
 /** @type {!Object} */
olx.source.ImageMapGuideOptions.prototype.params;
/**
 * @record
 * @struct
 */
olx.source.MapQuestOptions = function() {};
 /** @type {number} */
olx.source.MapQuestOptions.prototype.cacheSize;
 /** @type {string} */
olx.source.MapQuestOptions.prototype.layer;
 /** @type {number} */
olx.source.MapQuestOptions.prototype.reprojectionErrorThreshold;
 /** @type {function(!ol.Tile, string): void} */
olx.source.MapQuestOptions.prototype.tileLoadFunction;
 /** @type {string} */
olx.source.MapQuestOptions.prototype.url;
/**
 * @record
 * @struct
 */
olx.source.TileDebugOptions = function() {};
 /** @type {(string|!ol.proj.Projection)} */
olx.source.TileDebugOptions.prototype.projection;
 /** @type {!ol.tilegrid.TileGrid} */
olx.source.TileDebugOptions.prototype.tileGrid;
 /** @type {boolean} */
olx.source.TileDebugOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
olx.source.OSMOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.OSMOptions.prototype.attributions;
 /** @type {number} */
olx.source.OSMOptions.prototype.cacheSize;
 /** @type {string} */
olx.source.OSMOptions.prototype.crossOrigin;
 /** @type {number} */
olx.source.OSMOptions.prototype.maxZoom;
 /** @type {boolean} */
olx.source.OSMOptions.prototype.opaque;
 /** @type {number} */
olx.source.OSMOptions.prototype.reprojectionErrorThreshold;
 /** @type {function(!ol.Tile, string): void} */
olx.source.OSMOptions.prototype.tileLoadFunction;
 /** @type {string} */
olx.source.OSMOptions.prototype.url;
 /** @type {boolean} */
olx.source.OSMOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
olx.source.ImageArcGISRestOptions = function() {};
 /** @type {!Array<!ol.Attribution>} */
olx.source.ImageArcGISRestOptions.prototype.attributions;
 /** @type {string} */
olx.source.ImageArcGISRestOptions.prototype.crossOrigin;
 /** @type {(string|!olx.LogoOptions)} */
olx.source.ImageArcGISRestOptions.prototype.logo;
 /** @type {function(!ol.Image, string): void} */
olx.source.ImageArcGISRestOptions.prototype.imageLoadFunction;
 /** @type {!Object<string,?>} */
olx.source.ImageArcGISRestOptions.prototype.params;
 /** @type {(string|!ol.proj.Projection)} */
olx.source.ImageArcGISRestOptions.prototype.projection;
 /** @type {number} */
olx.source.ImageArcGISRestOptions.prototype.ratio;
 /** @type {!Array<number>} */
olx.source.ImageArcGISRestOptions.prototype.resolutions;
 /** @type {string} */
olx.source.ImageArcGISRestOptions.prototype.url;
/**
 * @record
 * @struct
 */
olx.source.ImageCanvasOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.ImageCanvasOptions.prototype.attributions;
 /** @type {function(!Array<?>, number, number, !Array<?>, !ol.proj.Projection): !HTMLCanvasElement} */
olx.source.ImageCanvasOptions.prototype.canvasFunction;
 /** @type {(string|!olx.LogoOptions)} */
olx.source.ImageCanvasOptions.prototype.logo;
 /** @type {(string|!ol.proj.Projection)} */
olx.source.ImageCanvasOptions.prototype.projection;
 /** @type {number} */
olx.source.ImageCanvasOptions.prototype.ratio;
 /** @type {!Array<number>} */
olx.source.ImageCanvasOptions.prototype.resolutions;
 /** @type {string} */
olx.source.ImageCanvasOptions.prototype.state;
/**
 * @record
 * @struct
 */
olx.source.ImageVectorOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.ImageVectorOptions.prototype.attributions;
 /** @type {(string|!olx.LogoOptions)} */
olx.source.ImageVectorOptions.prototype.logo;
 /** @type {(string|!ol.proj.Projection)} */
olx.source.ImageVectorOptions.prototype.projection;
 /** @type {number} */
olx.source.ImageVectorOptions.prototype.ratio;
 /** @type {number} */
olx.source.ImageVectorOptions.prototype.renderBuffer;
 /** @type {!Array<number>} */
olx.source.ImageVectorOptions.prototype.resolutions;
 /** @type {!ol.source.Vector} */
olx.source.ImageVectorOptions.prototype.source;
 /** @type {(!ol.style.Style|!Array<!ol.style.Style>|function((!ol.Feature|!ol.render.Feature), number): (!ol.style.Style|!Array<!ol.style.Style>))} */
olx.source.ImageVectorOptions.prototype.style;
/**
 * @record
 * @struct
 */
olx.source.RasterOptions = function() {};
 /** @type {!Array<!ol.source.Source>} */
olx.source.RasterOptions.prototype.sources;
 /** @type {function((!Array<!Array<number>>|!Array<!ImageData>), !Object): (!Array<number>|!ImageData)} */
olx.source.RasterOptions.prototype.operation;
 /** @type {!Object} */
olx.source.RasterOptions.prototype.lib;
 /** @type {number} */
olx.source.RasterOptions.prototype.threads;
 /** @type {string} */
olx.source.RasterOptions.prototype.operationType;
/**
 * @record
 * @struct
 */
olx.source.ImageWMSOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.ImageWMSOptions.prototype.attributions;
 /** @type {string} */
olx.source.ImageWMSOptions.prototype.crossOrigin;
 /** @type {boolean} */
olx.source.ImageWMSOptions.prototype.hidpi;
 /** @type {string} */
olx.source.ImageWMSOptions.prototype.serverType;
 /** @type {function(!ol.Image, string): void} */
olx.source.ImageWMSOptions.prototype.imageLoadFunction;
 /** @type {(string|!olx.LogoOptions)} */
olx.source.ImageWMSOptions.prototype.logo;
 /** @type {!Object<string,?>} */
olx.source.ImageWMSOptions.prototype.params;
 /** @type {(string|!ol.proj.Projection)} */
olx.source.ImageWMSOptions.prototype.projection;
 /** @type {number} */
olx.source.ImageWMSOptions.prototype.ratio;
 /** @type {!Array<number>} */
olx.source.ImageWMSOptions.prototype.resolutions;
 /** @type {string} */
olx.source.ImageWMSOptions.prototype.url;
/**
 * @record
 * @struct
 */
olx.source.StamenOptions = function() {};
 /** @type {number} */
olx.source.StamenOptions.prototype.cacheSize;
 /** @type {string} */
olx.source.StamenOptions.prototype.layer;
 /** @type {number} */
olx.source.StamenOptions.prototype.minZoom;
 /** @type {number} */
olx.source.StamenOptions.prototype.maxZoom;
 /** @type {boolean} */
olx.source.StamenOptions.prototype.opaque;
 /** @type {number} */
olx.source.StamenOptions.prototype.reprojectionErrorThreshold;
 /** @type {function(!ol.Tile, string): void} */
olx.source.StamenOptions.prototype.tileLoadFunction;
 /** @type {string} */
olx.source.StamenOptions.prototype.url;
/**
 * @record
 * @struct
 */
olx.source.ImageStaticOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.ImageStaticOptions.prototype.attributions;
 /** @type {string} */
olx.source.ImageStaticOptions.prototype.crossOrigin;
 /** @type {!Array<?>} */
olx.source.ImageStaticOptions.prototype.imageExtent;
 /** @type {function(!ol.Image, string): void} */
olx.source.ImageStaticOptions.prototype.imageLoadFunction;
 /** @type {(string|!olx.LogoOptions)} */
olx.source.ImageStaticOptions.prototype.logo;
 /** @type {(string|!ol.proj.Projection)} */
olx.source.ImageStaticOptions.prototype.projection;
 /** @type {!Array<?>} */
olx.source.ImageStaticOptions.prototype.imageSize;
 /** @type {string} */
olx.source.ImageStaticOptions.prototype.url;
/**
 * @record
 * @struct
 */
olx.source.TileArcGISRestOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.TileArcGISRestOptions.prototype.attributions;
 /** @type {number} */
olx.source.TileArcGISRestOptions.prototype.cacheSize;
 /** @type {string} */
olx.source.TileArcGISRestOptions.prototype.crossOrigin;
 /** @type {!Object<string,?>} */
olx.source.TileArcGISRestOptions.prototype.params;
 /** @type {(string|!olx.LogoOptions)} */
olx.source.TileArcGISRestOptions.prototype.logo;
 /** @type {!ol.tilegrid.TileGrid} */
olx.source.TileArcGISRestOptions.prototype.tileGrid;
 /** @type {(string|!ol.proj.Projection)} */
olx.source.TileArcGISRestOptions.prototype.projection;
 /** @type {number} */
olx.source.TileArcGISRestOptions.prototype.reprojectionErrorThreshold;
 /** @type {function(!ol.Tile, string): void} */
olx.source.TileArcGISRestOptions.prototype.tileLoadFunction;
 /** @type {string} */
olx.source.TileArcGISRestOptions.prototype.url;
 /** @type {boolean} */
olx.source.TileArcGISRestOptions.prototype.wrapX;
 /** @type {!Array<string>} */
olx.source.TileArcGISRestOptions.prototype.urls;
/**
 * @record
 * @struct
 */
olx.source.TileJSONOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.TileJSONOptions.prototype.attributions;
 /** @type {number} */
olx.source.TileJSONOptions.prototype.cacheSize;
 /** @type {string} */
olx.source.TileJSONOptions.prototype.crossOrigin;
 /** @type {boolean} */
olx.source.TileJSONOptions.prototype.jsonp;
 /** @type {number} */
olx.source.TileJSONOptions.prototype.reprojectionErrorThreshold;
 /** @type {function(!ol.Tile, string): void} */
olx.source.TileJSONOptions.prototype.tileLoadFunction;
 /** @type {string} */
olx.source.TileJSONOptions.prototype.url;
 /** @type {boolean} */
olx.source.TileJSONOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
olx.source.TileWMSOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.TileWMSOptions.prototype.attributions;
 /** @type {number} */
olx.source.TileWMSOptions.prototype.cacheSize;
 /** @type {!Object<string,?>} */
olx.source.TileWMSOptions.prototype.params;
 /** @type {string} */
olx.source.TileWMSOptions.prototype.crossOrigin;
 /** @type {number} */
olx.source.TileWMSOptions.prototype.gutter;
 /** @type {boolean} */
olx.source.TileWMSOptions.prototype.hidpi;
 /** @type {(string|!olx.LogoOptions)} */
olx.source.TileWMSOptions.prototype.logo;
 /** @type {!ol.tilegrid.TileGrid} */
olx.source.TileWMSOptions.prototype.tileGrid;
 /** @type {(string|!ol.proj.Projection)} */
olx.source.TileWMSOptions.prototype.projection;
 /** @type {number} */
olx.source.TileWMSOptions.prototype.reprojectionErrorThreshold;
 /** @type {string} */
olx.source.TileWMSOptions.prototype.serverType;
 /** @type {function(!ol.Tile, string): void} */
olx.source.TileWMSOptions.prototype.tileLoadFunction;
 /** @type {string} */
olx.source.TileWMSOptions.prototype.url;
 /** @type {!Array<string>} */
olx.source.TileWMSOptions.prototype.urls;
 /** @type {boolean} */
olx.source.TileWMSOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
olx.source.VectorOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.VectorOptions.prototype.attributions;
 /** @type {(!Array<!ol.Feature>|!ol.Collection<!ol.Feature>)} */
olx.source.VectorOptions.prototype.features;
 /** @type {!ol.format.Feature} */
olx.source.VectorOptions.prototype.format;
 /** @type {function(!Array<?>, number, !ol.proj.Projection): void} */
olx.source.VectorOptions.prototype.loader;
 /** @type {(string|!olx.LogoOptions)} */
olx.source.VectorOptions.prototype.logo;
 /** @type {boolean} */
olx.source.VectorOptions.prototype.overlaps;
 /** @type {function(!Array<?>, number): !Array<!Array<?>>} */
olx.source.VectorOptions.prototype.strategy;
 /** @type {(string|function(!Array<?>, number, !ol.proj.Projection): string)} */
olx.source.VectorOptions.prototype.url;
 /** @type {boolean} */
olx.source.VectorOptions.prototype.useSpatialIndex;
 /** @type {boolean} */
olx.source.VectorOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
olx.source.WMTSOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.WMTSOptions.prototype.attributions;
 /** @type {number} */
olx.source.WMTSOptions.prototype.cacheSize;
 /** @type {string} */
olx.source.WMTSOptions.prototype.crossOrigin;
 /** @type {(string|!olx.LogoOptions)} */
olx.source.WMTSOptions.prototype.logo;
 /** @type {!ol.tilegrid.WMTS} */
olx.source.WMTSOptions.prototype.tileGrid;
 /** @type {(string|!ol.proj.Projection)} */
olx.source.WMTSOptions.prototype.projection;
 /** @type {number} */
olx.source.WMTSOptions.prototype.reprojectionErrorThreshold;
 /** @type {string} */
olx.source.WMTSOptions.prototype.requestEncoding;
 /** @type {string} */
olx.source.WMTSOptions.prototype.layer;
 /** @type {string} */
olx.source.WMTSOptions.prototype.style;
 /** @type {function(!ol.ImageTile, !Array<?>, number, string, string, function(!ol.Tile, string): void): ?} */
olx.source.WMTSOptions.prototype.tileClass;
 /** @type {number} */
olx.source.WMTSOptions.prototype.tilePixelRatio;
 /** @type {string} */
olx.source.WMTSOptions.prototype.version;
 /** @type {string} */
olx.source.WMTSOptions.prototype.format;
 /** @type {string} */
olx.source.WMTSOptions.prototype.matrixSet;
 /** @type {!Object} */
olx.source.WMTSOptions.prototype.dimensions;
 /** @type {string} */
olx.source.WMTSOptions.prototype.url;
 /** @type {function(!ol.Tile, string): void} */
olx.source.WMTSOptions.prototype.tileLoadFunction;
 /** @type {!Array<string>} */
olx.source.WMTSOptions.prototype.urls;
 /** @type {boolean} */
olx.source.WMTSOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
olx.source.XYZOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.XYZOptions.prototype.attributions;
 /** @type {number} */
olx.source.XYZOptions.prototype.cacheSize;
 /** @type {string} */
olx.source.XYZOptions.prototype.crossOrigin;
 /** @type {(string|!olx.LogoOptions)} */
olx.source.XYZOptions.prototype.logo;
 /** @type {boolean} */
olx.source.XYZOptions.prototype.opaque;
 /** @type {(string|!ol.proj.Projection)} */
olx.source.XYZOptions.prototype.projection;
 /** @type {number} */
olx.source.XYZOptions.prototype.reprojectionErrorThreshold;
 /** @type {number} */
olx.source.XYZOptions.prototype.maxZoom;
 /** @type {number} */
olx.source.XYZOptions.prototype.minZoom;
 /** @type {!ol.tilegrid.TileGrid} */
olx.source.XYZOptions.prototype.tileGrid;
 /** @type {function(!ol.Tile, string): void} */
olx.source.XYZOptions.prototype.tileLoadFunction;
 /** @type {number} */
olx.source.XYZOptions.prototype.tilePixelRatio;
 /** @type {(number|!Array<?>)} */
olx.source.XYZOptions.prototype.tileSize;
 /** @type {function(!Array<?>, number, !ol.proj.Projection): string} */
olx.source.XYZOptions.prototype.tileUrlFunction;
 /** @type {string} */
olx.source.XYZOptions.prototype.url;
 /** @type {!Array<string>} */
olx.source.XYZOptions.prototype.urls;
 /** @type {boolean} */
olx.source.XYZOptions.prototype.wrapX;
/**
 * @record
 * @struct
 */
olx.source.CartoDBOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.CartoDBOptions.prototype.attributions;
 /** @type {number} */
olx.source.CartoDBOptions.prototype.cacheSize;
 /** @type {string} */
olx.source.CartoDBOptions.prototype.crossOrigin;
 /** @type {(string|!olx.LogoOptions)} */
olx.source.CartoDBOptions.prototype.logo;
 /** @type {(string|!ol.proj.Projection)} */
olx.source.CartoDBOptions.prototype.projection;
 /** @type {number} */
olx.source.CartoDBOptions.prototype.maxZoom;
 /** @type {number} */
olx.source.CartoDBOptions.prototype.minZoom;
 /** @type {boolean} */
olx.source.CartoDBOptions.prototype.wrapX;
 /** @type {!Object} */
olx.source.CartoDBOptions.prototype.config;
 /** @type {string} */
olx.source.CartoDBOptions.prototype.map;
 /** @type {string} */
olx.source.CartoDBOptions.prototype.account;
/**
 * @record
 * @struct
 */
olx.source.ZoomifyOptions = function() {};
 /** @type {(string|!ol.Attribution|!Array<string>|!Array<!ol.Attribution>)} */
olx.source.ZoomifyOptions.prototype.attributions;
 /** @type {number} */
olx.source.ZoomifyOptions.prototype.cacheSize;
 /** @type {string} */
olx.source.ZoomifyOptions.prototype.crossOrigin;
 /** @type {(string|!olx.LogoOptions)} */
olx.source.ZoomifyOptions.prototype.logo;
 /** @type {number} */
olx.source.ZoomifyOptions.prototype.reprojectionErrorThreshold;
 /** @type {string} */
olx.source.ZoomifyOptions.prototype.url;
 /** @type {string} */
olx.source.ZoomifyOptions.prototype.tierSizeCalculation;
 /** @type {!Array<?>} */
olx.source.ZoomifyOptions.prototype.size;
/** @const */
olx.style = {};
/**
 * @record
 * @struct
 */
olx.style.CircleOptions = function() {};
 /** @type {!ol.style.Fill} */
olx.style.CircleOptions.prototype.fill;
 /** @type {number} */
olx.style.CircleOptions.prototype.radius;
 /** @type {boolean} */
olx.style.CircleOptions.prototype.snapToPixel;
 /** @type {!ol.style.Stroke} */
olx.style.CircleOptions.prototype.stroke;
 /** @type {!ol.style.AtlasManager} */
olx.style.CircleOptions.prototype.atlasManager;
/**
 * @record
 * @struct
 */
olx.style.FillOptions = function() {};
 /** @type {(string|!Array<?>|!Uint8Array|!Uint8ClampedArray|!CanvasPattern|!CanvasGradient)} */
olx.style.FillOptions.prototype.color;
/**
 * @record
 * @struct
 */
olx.style.IconOptions = function() {};
 /** @type {!Array<number>} */
olx.style.IconOptions.prototype.anchor;
 /** @type {string} */
olx.style.IconOptions.prototype.anchorOrigin;
 /** @type {string} */
olx.style.IconOptions.prototype.anchorXUnits;
 /** @type {string} */
olx.style.IconOptions.prototype.anchorYUnits;
 /** @type {(string|!Array<?>|!Uint8Array|!Uint8ClampedArray)} */
olx.style.IconOptions.prototype.color;
 /** @type {string} */
olx.style.IconOptions.prototype.crossOrigin;
 /** @type {?} */
olx.style.IconOptions.prototype.img;
 /** @type {!Array<number>} */
olx.style.IconOptions.prototype.offset;
 /** @type {string} */
olx.style.IconOptions.prototype.offsetOrigin;
 /** @type {number} */
olx.style.IconOptions.prototype.opacity;
 /** @type {number} */
olx.style.IconOptions.prototype.scale;
 /** @type {boolean} */
olx.style.IconOptions.prototype.snapToPixel;
 /** @type {boolean} */
olx.style.IconOptions.prototype.rotateWithView;
 /** @type {number} */
olx.style.IconOptions.prototype.rotation;
 /** @type {!Array<?>} */
olx.style.IconOptions.prototype.size;
 /** @type {!Array<?>} */
olx.style.IconOptions.prototype.imgSize;
 /** @type {string} */
olx.style.IconOptions.prototype.src;
/**
 * @record
 * @struct
 */
olx.style.RegularShapeOptions = function() {};
 /** @type {!ol.style.Fill} */
olx.style.RegularShapeOptions.prototype.fill;
 /** @type {number} */
olx.style.RegularShapeOptions.prototype.points;
 /** @type {number} */
olx.style.RegularShapeOptions.prototype.radius;
 /** @type {number} */
olx.style.RegularShapeOptions.prototype.radius1;
 /** @type {number} */
olx.style.RegularShapeOptions.prototype.radius2;
 /** @type {number} */
olx.style.RegularShapeOptions.prototype.angle;
 /** @type {boolean} */
olx.style.RegularShapeOptions.prototype.snapToPixel;
 /** @type {!ol.style.Stroke} */
olx.style.RegularShapeOptions.prototype.stroke;
/**
 * @record
 * @struct
 */
olx.style.StrokeOptions = function() {};
 /** @type {(string|!Array<?>|!Uint8Array|!Uint8ClampedArray)} */
olx.style.StrokeOptions.prototype.color;
 /** @type {string} */
olx.style.StrokeOptions.prototype.lineCap;
 /** @type {string} */
olx.style.StrokeOptions.prototype.lineJoin;
 /** @type {!Array<number>} */
olx.style.StrokeOptions.prototype.lineDash;
 /** @type {number} */
olx.style.StrokeOptions.prototype.miterLimit;
 /** @type {number} */
olx.style.StrokeOptions.prototype.width;
/**
 * @record
 * @struct
 */
olx.style.TextOptions = function() {};
 /** @type {string} */
olx.style.TextOptions.prototype.font;
 /** @type {number} */
olx.style.TextOptions.prototype.offsetX;
 /** @type {number} */
olx.style.TextOptions.prototype.offsetY;
 /** @type {number} */
olx.style.TextOptions.prototype.scale;
 /** @type {number} */
olx.style.TextOptions.prototype.rotation;
 /** @type {string} */
olx.style.TextOptions.prototype.text;
 /** @type {string} */
olx.style.TextOptions.prototype.textAlign;
 /** @type {string} */
olx.style.TextOptions.prototype.textBaseline;
 /** @type {!ol.style.Fill} */
olx.style.TextOptions.prototype.fill;
 /** @type {!ol.style.Stroke} */
olx.style.TextOptions.prototype.stroke;
/**
 * @record
 * @struct
 */
olx.style.StyleOptions = function() {};
 /** @type {(string|!ol.geom.Geometry|function((!ol.Feature|!ol.render.Feature)): (!ol.geom.Geometry|!ol.render.Feature))} */
olx.style.StyleOptions.prototype.geometry;
 /** @type {!ol.style.Fill} */
olx.style.StyleOptions.prototype.fill;
 /** @type {!ol.style.Image} */
olx.style.StyleOptions.prototype.image;
 /** @type {!ol.style.Stroke} */
olx.style.StyleOptions.prototype.stroke;
 /** @type {!ol.style.Text} */
olx.style.StyleOptions.prototype.text;
 /** @type {number} */
olx.style.StyleOptions.prototype.zIndex;
/**
 * @record
 * @struct
 */
olx.style.AtlasManagerOptions = function() {};
 /** @type {number} */
olx.style.AtlasManagerOptions.prototype.initialSize;
 /** @type {number} */
olx.style.AtlasManagerOptions.prototype.maxSize;
 /** @type {number} */
olx.style.AtlasManagerOptions.prototype.space;
/** @const */
olx.tilegrid = {};
/**
 * @record
 * @struct
 */
olx.tilegrid.TileGridOptions = function() {};
 /** @type {!Array<?>} */
olx.tilegrid.TileGridOptions.prototype.extent;
 /** @type {number} */
olx.tilegrid.TileGridOptions.prototype.minZoom;
 /** @type {!Array<?>} */
olx.tilegrid.TileGridOptions.prototype.origin;
 /** @type {!Array<!Array<?>>} */
olx.tilegrid.TileGridOptions.prototype.origins;
 /** @type {!Array<number>} */
olx.tilegrid.TileGridOptions.prototype.resolutions;
 /** @type {(number|!Array<?>)} */
olx.tilegrid.TileGridOptions.prototype.tileSize;
 /** @type {!Array<(number|!Array<?>)>} */
olx.tilegrid.TileGridOptions.prototype.tileSizes;
/**
 * @record
 * @struct
 */
olx.tilegrid.WMTSOptions = function() {};
 /** @type {!Array<?>} */
olx.tilegrid.WMTSOptions.prototype.extent;
 /** @type {!Array<?>} */
olx.tilegrid.WMTSOptions.prototype.origin;
 /** @type {!Array<!Array<?>>} */
olx.tilegrid.WMTSOptions.prototype.origins;
 /** @type {!Array<number>} */
olx.tilegrid.WMTSOptions.prototype.resolutions;
 /** @type {!Array<string>} */
olx.tilegrid.WMTSOptions.prototype.matrixIds;
 /** @type {!Array<!Array<?>>} */
olx.tilegrid.WMTSOptions.prototype.sizes;
 /** @type {(number|!Array<?>)} */
olx.tilegrid.WMTSOptions.prototype.tileSize;
 /** @type {!Array<(number|!Array<?>)>} */
olx.tilegrid.WMTSOptions.prototype.tileSizes;
 /** @type {!Array<number>} */
olx.tilegrid.WMTSOptions.prototype.widths;
/**
 * @record
 * @struct
 */
olx.tilegrid.XYZOptions = function() {};
 /** @type {!Array<?>} */
olx.tilegrid.XYZOptions.prototype.extent;
 /** @type {number} */
olx.tilegrid.XYZOptions.prototype.maxZoom;
 /** @type {number} */
olx.tilegrid.XYZOptions.prototype.minZoom;
 /** @type {(number|!Array<?>)} */
olx.tilegrid.XYZOptions.prototype.tileSize;
/**
 * @record
 * @struct
 */
olx.AttributionOptions = function() {};
 /** @type {string} */
olx.AttributionOptions.prototype.html;
/**
 * @record
 * @struct
 */
olx.DeviceOrientationOptions = function() {};
 /** @type {boolean} */
olx.DeviceOrientationOptions.prototype.tracking;
/**
 * @record
 * @struct
 */
olx.GeolocationOptions = function() {};
 /** @type {boolean} */
olx.GeolocationOptions.prototype.tracking;
 /** @type {!PositionOptions} */
olx.GeolocationOptions.prototype.trackingOptions;
 /** @type {(string|!ol.proj.Projection)} */
olx.GeolocationOptions.prototype.projection;
/**
 * @record
 * @struct
 */
olx.LogoOptions = function() {};
 /** @type {string} */
olx.LogoOptions.prototype.href;
 /** @type {string} */
olx.LogoOptions.prototype.src;
/**
 * @record
 * @struct
 */
olx.GraticuleOptions = function() {};
 /** @type {!ol.Map} */
olx.GraticuleOptions.prototype.map;
 /** @type {number} */
olx.GraticuleOptions.prototype.maxLines;
 /** @type {!ol.style.Stroke} */
olx.GraticuleOptions.prototype.strokeStyle;
 /** @type {number} */
olx.GraticuleOptions.prototype.targetSize;
/**
 * @record
 * @struct
 */
olx.MapOptions = function() {};
 /** @type {(!ol.Collection<!ol.control.Control>|!Array<!ol.control.Control>)} */
olx.MapOptions.prototype.controls;
 /** @type {number} */
olx.MapOptions.prototype.pixelRatio;
 /** @type {(!ol.Collection<!ol.interaction.Interaction>|!Array<!ol.interaction.Interaction>)} */
olx.MapOptions.prototype.interactions;
 /** @type {(string|!Element|!Document)} */
olx.MapOptions.prototype.keyboardEventTarget;
 /** @type {(!ol.Collection<!ol.layer.Base>|!Array<!ol.layer.Base>)} */
olx.MapOptions.prototype.layers;
 /** @type {boolean} */
olx.MapOptions.prototype.loadTilesWhileAnimating;
 /** @type {boolean} */
olx.MapOptions.prototype.loadTilesWhileInteracting;
 /** @type {(string|boolean|!Element|!olx.LogoOptions)} */
olx.MapOptions.prototype.logo;
 /** @type {(!ol.Collection<!ol.Overlay>|!Array<!ol.Overlay>)} */
olx.MapOptions.prototype.overlays;
 /** @type {(string|!Array<string>)} */
olx.MapOptions.prototype.renderer;
 /** @type {(string|!Element)} */
olx.MapOptions.prototype.target;
 /** @type {!ol.View} */
olx.MapOptions.prototype.view;
/**
 * @record
 * @struct
 */
olx.OverlayOptions = function() {};
 /** @type {(string|number)} */
olx.OverlayOptions.prototype.id;
 /** @type {!Element} */
olx.OverlayOptions.prototype.element;
 /** @type {!Array<number>} */
olx.OverlayOptions.prototype.offset;
 /** @type {!Array<?>} */
olx.OverlayOptions.prototype.position;
 /** @type {string} */
olx.OverlayOptions.prototype.positioning;
 /** @type {boolean} */
olx.OverlayOptions.prototype.stopEvent;
 /** @type {boolean} */
olx.OverlayOptions.prototype.insertFirst;
 /** @type {boolean} */
olx.OverlayOptions.prototype.autoPan;
 /** @type {!olx.animation.PanOptions} */
olx.OverlayOptions.prototype.autoPanAnimation;
 /** @type {number} */
olx.OverlayOptions.prototype.autoPanMargin;
/**
 * @record
 * @struct
 */
olx.ProjectionOptions = function() {};
 /** @type {string} */
olx.ProjectionOptions.prototype.code;
 /** @type {string} */
olx.ProjectionOptions.prototype.units;
 /** @type {!Array<?>} */
olx.ProjectionOptions.prototype.extent;
 /** @type {string} */
olx.ProjectionOptions.prototype.axisOrientation;
 /** @type {boolean} */
olx.ProjectionOptions.prototype.global;
 /** @type {number} */
olx.ProjectionOptions.prototype.metersPerUnit;
 /** @type {!Array<?>} */
olx.ProjectionOptions.prototype.worldExtent;
 /** @type {function(number, !Array<?>): number} */
olx.ProjectionOptions.prototype.getPointResolution;
/** @const */
olx.view = {};
/**
 * @record
 * @struct
 */
olx.view.FitOptions = function() {};
 /** @type {!Array<number>} */
olx.view.FitOptions.prototype.padding;
 /** @type {boolean} */
olx.view.FitOptions.prototype.constrainResolution;
 /** @type {boolean} */
olx.view.FitOptions.prototype.nearest;
 /** @type {number} */
olx.view.FitOptions.prototype.maxZoom;
 /** @type {number} */
olx.view.FitOptions.prototype.minResolution;
/**
 * @record
 * @struct
 */
olx.ViewOptions = function() {};
 /** @type {!Array<?>} */
olx.ViewOptions.prototype.center;
 /** @type {(number|boolean)} */
olx.ViewOptions.prototype.constrainRotation;
 /** @type {boolean} */
olx.ViewOptions.prototype.enableRotation;
 /** @type {!Array<?>} */
olx.ViewOptions.prototype.extent;
 /** @type {number} */
olx.ViewOptions.prototype.maxResolution;
 /** @type {number} */
olx.ViewOptions.prototype.minResolution;
 /** @type {number} */
olx.ViewOptions.prototype.maxZoom;
 /** @type {number} */
olx.ViewOptions.prototype.minZoom;
 /** @type {(string|!ol.proj.Projection)} */
olx.ViewOptions.prototype.projection;
 /** @type {number} */
olx.ViewOptions.prototype.resolution;
 /** @type {!Array<number>} */
olx.ViewOptions.prototype.resolutions;
 /** @type {number} */
olx.ViewOptions.prototype.rotation;
 /** @type {number} */
olx.ViewOptions.prototype.zoom;
 /** @type {number} */
olx.ViewOptions.prototype.zoomFactor;
/**
 * @record
 * @struct
 */
olx.AtPixelOptions = function() {};
 /** @type {function(!ol.layer.Layer): boolean} */
olx.AtPixelOptions.prototype.layerFilter;
 /** @type {number} */
olx.AtPixelOptions.prototype.hitTolerance;
/**
 * @record
 * @struct
 */
olx.FrameState = function() {};
 /** @type {number} */
olx.FrameState.prototype.pixelRatio;
 /** @type {number} */
olx.FrameState.prototype.time;
 /** @type {!olx.ViewState} */
olx.FrameState.prototype.viewState;
/**
 * @record
 * @struct
 */
olx.ViewState = function() {};
 /** @type {!Array<?>} */
olx.ViewState.prototype.center;
 /** @type {!ol.proj.Projection} */
olx.ViewState.prototype.projection;
 /** @type {number} */
olx.ViewState.prototype.resolution;
 /** @type {number} */
olx.ViewState.prototype.rotation;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "openlayers"
/** @const */
tsickle_declare_module.openlayers = {};

/* TODO: ExportAssignment in tsickle_declare_module.openlayers */
