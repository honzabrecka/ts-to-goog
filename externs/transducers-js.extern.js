/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/transducers-js/index.d.ts:
/**
 * @record
 * @struct
 */
function Reduced() {}

/* TODO: PropertySignature: ['@@transducer/reduced'] */

/* TODO: PropertySignature: ['@@transducer/value'] */

/** @typedef {?} */
var Reducer;

/** @typedef {?} */
var Transducer;
/**
 * @record
 * @struct
 */
function CompletingTransformer() {}

/**
 * @return {(void|?)}
 */
CompletingTransformer.prototype['@@transducer/init'] = function() {};

/**
 * @param {?} result
 * @param {?} input
 * @return {?}
 */
CompletingTransformer.prototype['@@transducer/step'] = function(result, input) {};

/**
 * @param {?} result
 * @return {?}
 */
CompletingTransformer.prototype['@@transducer/result'] = function(result) {};

/** @typedef {?} */
var Transformer;

/**
 * Return a reduced value. Reduced values short circuit transduce.
 * @template TResult
 * @param {?} x
 * @return {?}
 */
function reduced(x) {}

/**
 * Check if a value is reduced.
 * @param {?} x
 * @return {boolean}
 */
function isReduced(x) {}

/**
 * @template T
 * @param {...?} args
 * @return {?}
 */
function comp(args) {}

/**
 * Take a predicate function and return its complement.
 * @template T
 * @param {?} f
 * @return {?}
 */
function complement(f) {}

/**
 * Identity function.
 * @template T
 * @param {?} arg
 * @return {?}
 */
function identity(arg) {}

/**
 * @constructor
 * @struct
 * @param {?} f
 * @param {?} xf
 */
function Map(f, xf) {}

/**
 * @return {?}
 */
Map.prototype['@@transducer/init'] = function() {};

/**
 * @param {?} result
 * @param {?} input
 * @return {?}
 */
Map.prototype['@@transducer/step'] = function(result, input) {};

/**
 * @param {?} result
 * @return {?}
 */
Map.prototype['@@transducer/result'] = function(result) {};

/**
 * Mapping transducer constructor
 * @template TInput, TOutput
 * @param {?} f
 * @return {?}
 */
function map(f) {}

/**
 * @constructor
 * @struct
 * @param {?} pred
 * @param {?} xf
 */
function Filter(pred, xf) {}

/**
 * @return {?}
 */
Filter.prototype['@@transducer/init'] = function() {};

/**
 * @param {?} result
 * @param {?} input
 * @return {?}
 */
Filter.prototype['@@transducer/step'] = function(result, input) {};

/**
 * @param {?} result
 * @return {?}
 */
Filter.prototype['@@transducer/result'] = function(result) {};

/**
 * Filtering transducer constructor
 * @template TInput
 * @param {?} pred
 * @return {?}
 */
function filter(pred) {}

/**
 * Similar to filter except the predicate is used to
 * eliminate values.
 * @template TInput
 * @param {?} pred
 * @return {?}
 */
function remove(pred) {}

/**
 * @constructor
 * @struct
 * @param {?} f
 * @param {?} xf
 */
function Keep(f, xf) {}

/**
 * @return {?}
 */
Keep.prototype['@@transducer/init'] = function() {};

/**
 * @param {?} result
 * @param {?} input
 * @return {?}
 */
Keep.prototype['@@transducer/step'] = function(result, input) {};

/**
 * @param {?} result
 * @return {?}
 */
Keep.prototype['@@transducer/result'] = function(result) {};

/**
 * A keeping transducer. Keep inputs as long as the provided
 * function does not return null or undefined.
 * @template TInput
 * @param {?} f
 * @return {?}
 */
function keep(f) {}

/**
 * @constructor
 * @struct
 * @param {?} f
 * @param {?} xf
 */
function KeepIndexed(f, xf) {}

/**
 * @return {?}
 */
KeepIndexed.prototype['@@transducer/init'] = function() {};

/**
 * @param {?} result
 * @param {?} input
 * @return {?}
 */
KeepIndexed.prototype['@@transducer/step'] = function(result, input) {};

/**
 * @param {?} result
 * @return {?}
 */
KeepIndexed.prototype['@@transducer/result'] = function(result) {};

/**
 * Like keep but the provided function will be passed the
 * index as the fist argument.
 * @template TInput
 * @param {?} f
 * @return {?}
 */
function keepIndexed(f) {}

/**
 * @constructor
 * @struct
 * @param {number} n
 * @param {?} xf
 */
function Take(n, xf) {}

/**
 * @return {?}
 */
Take.prototype['@@transducer/init'] = function() {};

/**
 * @param {?} result
 * @param {?} input
 * @return {?}
 */
Take.prototype['@@transducer/step'] = function(result, input) {};

/**
 * @param {?} result
 * @return {?}
 */
Take.prototype['@@transducer/result'] = function(result) {};

/**
 * A take transducer constructor. Will take n values before
 * returning a reduced result.
 * @template TInput
 * @param {number} n
 * @return {?}
 */
function take(n) {}

/**
 * @constructor
 * @struct
 * @param {?} pred
 * @param {?} xf
 */
function TakeWhile(pred, xf) {}

/**
 * @return {?}
 */
TakeWhile.prototype['@@transducer/init'] = function() {};

/**
 * @param {?} result
 * @param {?} input
 * @return {?}
 */
TakeWhile.prototype['@@transducer/step'] = function(result, input) {};

/**
 * @param {?} result
 * @return {?}
 */
TakeWhile.prototype['@@transducer/result'] = function(result) {};

/**
 * Like the take transducer except takes as long as the pred
 * return true for inputs.
 * @template TInput
 * @param {?} pred
 * @return {?}
 */
function takeWhile(pred) {}

/**
 * @constructor
 * @struct
 * @param {number} n
 * @param {?} xf
 */
function TakeNth(n, xf) {}

/**
 * @return {?}
 */
TakeNth.prototype['@@transducer/init'] = function() {};

/**
 * @param {?} result
 * @param {?} input
 * @return {?}
 */
TakeNth.prototype['@@transducer/step'] = function(result, input) {};

/**
 * @param {?} result
 * @return {?}
 */
TakeNth.prototype['@@transducer/result'] = function(result) {};

/**
 * A transducer that takes every Nth input
 * @template TInput
 * @param {number} n
 * @return {?}
 */
function takeNth(n) {}

/**
 * @constructor
 * @struct
 * @param {number} n
 * @param {?} xf
 */
function Drop(n, xf) {}

/**
 * @return {?}
 */
Drop.prototype['@@transducer/init'] = function() {};

/**
 * @param {?} result
 * @param {?} input
 * @return {?}
 */
Drop.prototype['@@transducer/step'] = function(result, input) {};

/**
 * @param {?} result
 * @return {?}
 */
Drop.prototype['@@transducer/result'] = function(result) {};

/**
 * A dropping transducer constructor
 * @template TInput
 * @param {number} n
 * @return {?}
 */
function drop(n) {}

/**
 * @constructor
 * @struct
 * @param {?} pred
 * @param {?} xf
 */
function DropWhile(pred, xf) {}

/**
 * @return {?}
 */
DropWhile.prototype['@@transducer/init'] = function() {};

/**
 * @param {?} result
 * @param {?} input
 * @return {?}
 */
DropWhile.prototype['@@transducer/step'] = function(result, input) {};

/**
 * @param {?} result
 * @return {?}
 */
DropWhile.prototype['@@transducer/result'] = function(result) {};

/**
 * A dropping transducer that drop inputs as long as
 * pred is true.
 * @template TInput
 * @param {?} pred
 * @return {?}
 */
function dropWhile(pred) {}

/**
 * @constructor
 * @struct
 * @param {?} f
 * @param {?} xf
 */
function PartitionBy(f, xf) {}

/**
 * @return {?}
 */
PartitionBy.prototype['@@transducer/init'] = function() {};

/**
 * @param {?} result
 * @param {?} input
 * @return {?}
 */
PartitionBy.prototype['@@transducer/step'] = function(result, input) {};

/**
 * @param {?} result
 * @return {?}
 */
PartitionBy.prototype['@@transducer/result'] = function(result) {};

/**
 * A partitioning transducer. Collects inputs into
 * arrays as long as predicate remains true for contiguous
 * inputs.
 * @template TInput
 * @param {?} f
 * @return {?}
 */
function partitionBy(f) {}

/**
 * @constructor
 * @struct
 * @param {number} n
 * @param {?} xf
 */
function PartitionAll(n, xf) {}

/**
 * @return {?}
 */
PartitionAll.prototype['@@transducer/init'] = function() {};

/**
 * @param {?} result
 * @param {?} input
 * @return {?}
 */
PartitionAll.prototype['@@transducer/step'] = function(result, input) {};

/**
 * @param {?} result
 * @return {?}
 */
PartitionAll.prototype['@@transducer/result'] = function(result) {};

/**
 * A partitioning transducer. Collects inputs into
 * arrays of size N.
 * @template TResult, TInput
 * @param {number} n
 * @return {?}
 */
function partitionAll(n) {}

/**
 * @constructor
 * @struct
 * @param {?} cf
 * @param {?} xf
 */
function Completing(cf, xf) {}

/**
 * @return {?}
 */
Completing.prototype['@@transducer/init'] = function() {};

/**
 * @param {?} result
 * @param {?} input
 * @return {?}
 */
Completing.prototype['@@transducer/step'] = function(result, input) {};

/**
 * @param {?} result
 * @return {?}
 */
Completing.prototype['@@transducer/result'] = function(result) {};

/**
 * A completing transducer constructor. Useful to provide cleanup
 * logic at the end of a reduction/transduction.
 * @template TResult, TCompleteResult, TInput
 * @param {?} xf
 * @param {?} cf
 * @return {?}
 */
function completing(xf, cf) {}

/**
 * @constructor
 * @struct
 * @param {?} stepFn
 */
function Wrap(stepFn) {}

/**
 * @return {?}
 */
Wrap.prototype['@@transducer/init'] = function() {};

/**
 * @param {?} result
 * @param {?} input
 * @return {?}
 */
Wrap.prototype['@@transducer/step'] = function(result, input) {};

/**
 * @param {?} result
 * @return {?}
 */
Wrap.prototype['@@transducer/result'] = function(result) {};

/**
 * Take a two-arity reducing function where the first argument is the
 * accumluation and the second argument is the next input and convert
 * it into a transducer transformer object.
 * @template TResult, TInput
 * @param {?} stepFn
 * @return {?}
 */
function wrap(stepFn) {}

/**
 * Given a transformer return a concatenating transformer
 * @template TResult, TInput
 * @param {?} xf
 * @return {?}
 */
function cat(xf) {}

/**
 * A mapping concatenating transformer
 * @template TResult, TInput, TOutput
 * @param {?} f
 * @return {?}
 */
function mapcat(f) {}

/**
 * Given a transducer, a builder function, an initial value
 * and a iterable collection - returns the reduction.
 * @template TResult, TInput, TOutput, TCompleteResult
 * @param {?} xf
 * @param {?} f
 * @param {?|!Iterable<?>} init_or_coll
 * @param {!Iterable<?>|?=} coll
 * @return {?}
 */
function transduce(xf, f, init_or_coll, coll) {}

/**
 * Given a transducer, an intial value and a
 * collection - returns the reduction.
 * @template TResult, TInput, TCompleteResult
 * @param {?} xf
 * @param {?} init
 * @param {!Iterable<?>|?} coll
 * @return {?}
 */
function reduce(xf, init, coll) {}

/**
 * Reduce a value into the given empty value using a transducer.
 * @template TInput, TOutput
 * @param {!Array<?>|string|?} empty
 * @param {?} xf
 * @param {!Iterable<?>|?} coll
 * @return {!Array<?>|string|?}
 */
function into(empty, xf, coll) {}

/**
 * Convert a transducer transformer object into a function so
 * that it can be used with existing reduce implementation i.e. native,
 * Underscore, lodash
 * @template TResult, TInput, TOutput
 * @param {?} xf
 * @param {?} builder
 * @return {?}
 */
function toFn(xf, builder) {}

/**
 * A transformer which simply returns the first input.
 * @template TResult, TInput
 * @return {?}
 */
function first() {}

/**
 * Ensure that a value is reduced. If already reduced will not re-wrap.
 * @template TResult
 * @param {?} x
 * @return {?}
 */
function ensureReduced(x) {}

/**
 * Ensure a value is not reduced. Unwraps if reduced.
 * @template TResult
 * @param {?} x
 * @return {?}
 */
function unreduced(x) {}

/**
 * Returns the value of a reduced result.
 * @template TResult
 * @param {?} x
 * @return {?}
 */
function deref(x) {}
