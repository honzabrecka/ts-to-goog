/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/dojo/index.d.ts:
/** @const */
var dojox = {};
/** @const */
dojox.dtl = {};
/**
 * @record
 * @struct
 */
dojox.dtl.__StringArgs = function() {};
/**
 * @record
 * @struct
 */
dojox.dtl.__ObjectArgs = function() {};
/** @const */
var dojo = {};
/**
 * @record
 * @struct
 */
dojo.request = function() {};

/* TODO: CallSignature: dojo */

/**
 * Send an HTTP DELETE request using the default transport for the current platform.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.__BaseOptions=} options               OptionalOptions for the request.
 * @return {!dojo.request.__Promise}
 */
dojo.request.prototype.del = function(url, options) {};

/**
 * Send an HTTP GET request using the default transport for the current platform.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.__BaseOptions=} options               OptionalOptions for the request.
 * @return {!dojo.request.__Promise}
 */
dojo.request.prototype.get = function(url, options) {};

/**
 * Send an HTTP POST request using the default transport for the current platform.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.__BaseOptions=} options               OptionalOptions for the request.
 * @return {?}
 */
dojo.request.prototype.post = function(url, options) {};

/**
 * Send an HTTP POST request using the default transport for the current platform.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.__BaseOptions=} options               OptionalOptions for the request.
 * @return {!dojo.request.__Promise}
 */
dojo.request.prototype.put = function(url, options) {};
/**
 * @record
 * @struct
 */
dojo.request.handlers = function() {};

/* TODO: CallSignature: dojo.request */

/**
 *
 * @param {?} name
 * @param {?} handler
 * @return {void}
 */
dojo.request.handlers.prototype.register = function(name, handler) {};
/**
 * @record
 * @struct
 */
dojo.request.iframe = function() {};

/* TODO: CallSignature: dojo.request */

/**
 *
 * @param {?} name
 * @param {?} onloadstr
 * @param {?} uri
 * @return {?}
 */
dojo.request.iframe.prototype.create = function(name, onloadstr, uri) {};

/**
 *
 * @param {?} iframeNode
 * @return {?}
 */
dojo.request.iframe.prototype.doc = function(iframeNode) {};

/**
 * Send an HTTP GET request using an iframe element with the given URL and options.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.iframe.__BaseOptions=} options               OptionalOptions for the request.
 * @return {!dojo.request.__Promise}
 */
dojo.request.iframe.prototype.get = function(url, options) {};

/**
 * Send an HTTP POST request using an iframe element with the given URL and options.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.iframe.__BaseOptions=} options               OptionalOptions for the request.
 * @return {!dojo.request.__Promise}
 */
dojo.request.iframe.prototype.post = function(url, options) {};

/**
 *
 * @param {?} _iframe
 * @param {?} src
 * @param {?} replace
 * @return {void}
 */
dojo.request.iframe.prototype.setSrc = function(_iframe, src, replace) {};

/**
 * @constructor
 * @struct
 */
dojo.request.iframe.__MethodOptions = function() {};

/* TODO: PropertyDeclaration: dojo.request.iframe."method" */

/**
 * @constructor
 * @struct
 */
dojo.request.iframe.__BaseOptions = function() {};

/* TODO: PropertyDeclaration: dojo.request.iframe."data" */

/* TODO: PropertyDeclaration: dojo.request.iframe."form" */

/* TODO: PropertyDeclaration: dojo.request.iframe."handleAs" */

/* TODO: PropertyDeclaration: dojo.request.iframe."preventCache" */

/* TODO: PropertyDeclaration: dojo.request.iframe."query" */

/* TODO: PropertyDeclaration: dojo.request.iframe."timeout" */

/**
 * @constructor
 * @struct
 */
dojo.request.iframe.__Options = function() {};

/* TODO: PropertyDeclaration: dojo.request.iframe."data" */

/* TODO: PropertyDeclaration: dojo.request.iframe."form" */

/* TODO: PropertyDeclaration: dojo.request.iframe."handleAs" */

/* TODO: PropertyDeclaration: dojo.request.iframe."method" */

/* TODO: PropertyDeclaration: dojo.request.iframe."preventCache" */

/* TODO: PropertyDeclaration: dojo.request.iframe."query" */

/* TODO: PropertyDeclaration: dojo.request.iframe."timeout" */
/**
 * @record
 * @struct
 */
dojo.request.notify = function() {};

/* TODO: CallSignature: dojo.request */

/**
 *
 * @param {?} type
 * @param {?} event
 * @param {?} cancel
 * @return {void}
 */
dojo.request.notify.prototype.emit = function(type, event, cancel) {};
/**
 * @record
 * @struct
 */
dojo.request.registry = function() {};

/* TODO: CallSignature: dojo.request */

/**
 *
 * @param {?} id
 * @param {?} parentRequire
 * @param {?} loaded
 * @param {?} config
 * @return {void}
 */
dojo.request.registry.prototype.load = function(id, parentRequire, loaded, config) {};

/**
 *
 * @param {?} url
 * @param {?} provider
 * @param {?} first
 * @return {void}
 */
dojo.request.registry.prototype.register = function(url, provider, first) {};
/**
 * @record
 * @struct
 */
dojo.request.node = function() {};

/* TODO: CallSignature: dojo.request */

/**
 * Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.node.__BaseOptions=} options               OptionalOptions for the request.
 * @return {!dojo.request.__Promise}
 */
dojo.request.node.prototype.del = function(url, options) {};

/**
 * Send an HTTP GET request using XMLHttpRequest with the given URL and options.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.node.__BaseOptions=} options               OptionalOptions for the request.
 * @return {!dojo.request.__Promise}
 */
dojo.request.node.prototype.get = function(url, options) {};

/**
 * Send an HTTP POST request using XMLHttpRequest with the given URL and options.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.node.__BaseOptions=} options               OptionalOptions for the request.
 * @return {!dojo.request.__Promise}
 */
dojo.request.node.prototype.post = function(url, options) {};

/**
 * Send an HTTP PUT request using XMLHttpRequest with the given URL and options.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.node.__BaseOptions=} options               OptionalOptions for the request.
 * @return {!dojo.request.__Promise}
 */
dojo.request.node.prototype.put = function(url, options) {};

/**
 * @constructor
 * @struct
 */
dojo.request.node.__MethodOptions = function() {};

/* TODO: PropertyDeclaration: dojo.request.node."method" */

/**
 * @constructor
 * @struct
 */
dojo.request.node.__Options = function() {};

/* TODO: PropertyDeclaration: dojo.request.node."data" */

/* TODO: PropertyDeclaration: dojo.request.node."handleAs" */

/* TODO: PropertyDeclaration: dojo.request.node."headers" */

/* TODO: PropertyDeclaration: dojo.request.node."method" */

/* TODO: PropertyDeclaration: dojo.request.node."password" */

/* TODO: PropertyDeclaration: dojo.request.node."preventCache" */

/* TODO: PropertyDeclaration: dojo.request.node."query" */

/* TODO: PropertyDeclaration: dojo.request.node."timeout" */

/* TODO: PropertyDeclaration: dojo.request.node."user" */

/**
 * @constructor
 * @struct
 */
dojo.request.node.__BaseOptions = function() {};

/* TODO: PropertyDeclaration: dojo.request.node."data" */

/* TODO: PropertyDeclaration: dojo.request.node."handleAs" */

/* TODO: PropertyDeclaration: dojo.request.node."headers" */

/* TODO: PropertyDeclaration: dojo.request.node."password" */

/* TODO: PropertyDeclaration: dojo.request.node."preventCache" */

/* TODO: PropertyDeclaration: dojo.request.node."query" */

/* TODO: PropertyDeclaration: dojo.request.node."timeout" */

/* TODO: PropertyDeclaration: dojo.request.node."user" */
/**
 * @record
 * @struct
 */
dojo.request.watch = function() {};

/* TODO: CallSignature: dojo.request */
 /** @type {!Function} */
dojo.request.watch.prototype.ioCheck;
 /** @type {!Function} */
dojo.request.watch.prototype.resHandle;
 /** @type {!Function} */
dojo.request.watch.prototype.validCheck;

/**
 * Cancels all pending IO requests, regardless of IO type
 * 
 * @return {void}
 */
dojo.request.watch.prototype.cancelAll = function() {};
/**
 * @record
 * @struct
 */
dojo.request.script = function() {};

/* TODO: CallSignature: dojo.request */

/**
 * Send an HTTP GET request using a script element with the given URL and options.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.script.__BaseOptions=} options               OptionalOptions for the request.
 * @return {!dojo.request.__Promise}
 */
dojo.request.script.prototype.get = function(url, options) {};

/**
 * @constructor
 * @struct
 */
dojo.request.script.__MethodOptions = function() {};

/* TODO: PropertyDeclaration: dojo.request.script."method" */

/**
 * @constructor
 * @struct
 */
dojo.request.script.__BaseOptions = function() {};

/* TODO: PropertyDeclaration: dojo.request.script."checkString" */

/* TODO: PropertyDeclaration: dojo.request.script."data" */

/* TODO: PropertyDeclaration: dojo.request.script."frameDoc" */

/* TODO: PropertyDeclaration: dojo.request.script."handleAs" */

/* TODO: PropertyDeclaration: dojo.request.script."jsonp" */

/* TODO: PropertyDeclaration: dojo.request.script."preventCache" */

/* TODO: PropertyDeclaration: dojo.request.script."query" */

/* TODO: PropertyDeclaration: dojo.request.script."timeout" */

/**
 * @constructor
 * @struct
 */
dojo.request.script.__Options = function() {};

/* TODO: PropertyDeclaration: dojo.request.script."checkString" */

/* TODO: PropertyDeclaration: dojo.request.script."data" */

/* TODO: PropertyDeclaration: dojo.request.script."frameDoc" */

/* TODO: PropertyDeclaration: dojo.request.script."handleAs" */

/* TODO: PropertyDeclaration: dojo.request.script."jsonp" */

/* TODO: PropertyDeclaration: dojo.request.script."method" */

/* TODO: PropertyDeclaration: dojo.request.script."preventCache" */

/* TODO: PropertyDeclaration: dojo.request.script."query" */

/* TODO: PropertyDeclaration: dojo.request.script."timeout" */
/**
 * @record
 * @struct
 */
dojo.request.xhr = function() {};

/* TODO: CallSignature: dojo.request */

/**
 * Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.xhr.__BaseOptions=} options               OptionalOptions for the request.
 * @return {!dojo.request.__Promise}
 */
dojo.request.xhr.prototype.del = function(url, options) {};

/**
 * Send an HTTP GET request using XMLHttpRequest with the given URL and options.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.xhr.__BaseOptions=} options               OptionalOptions for the request.
 * @return {!dojo.request.__Promise}
 */
dojo.request.xhr.prototype.get = function(url, options) {};

/**
 * Send an HTTP POST request using XMLHttpRequest with the given URL and options.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.xhr.__BaseOptions=} options               OptionalOptions for the request.
 * @return {!dojo.request.__Promise}
 */
dojo.request.xhr.prototype.post = function(url, options) {};

/**
 * Send an HTTP PUT request using XMLHttpRequest with the given URL and options.
 * 
 * @param {!String} url URL to request
 * @param {!dojo.request.xhr.__BaseOptions=} options               OptionalOptions for the request.
 * @return {!dojo.request.__Promise}
 */
dojo.request.xhr.prototype.put = function(url, options) {};

/**
 * @constructor
 * @struct
 */
dojo.request.xhr.__BaseOptions = function() {};

/* TODO: PropertyDeclaration: dojo.request.xhr."data" */

/* TODO: PropertyDeclaration: dojo.request.xhr."handleAs" */

/* TODO: PropertyDeclaration: dojo.request.xhr."headers" */

/* TODO: PropertyDeclaration: dojo.request.xhr."password" */

/* TODO: PropertyDeclaration: dojo.request.xhr."preventCache" */

/* TODO: PropertyDeclaration: dojo.request.xhr."query" */

/* TODO: PropertyDeclaration: dojo.request.xhr."sync" */

/* TODO: PropertyDeclaration: dojo.request.xhr."timeout" */

/* TODO: PropertyDeclaration: dojo.request.xhr."user" */

/* TODO: PropertyDeclaration: dojo.request.xhr."withCredentials" */

/**
 * @constructor
 * @struct
 */
dojo.request.xhr.__MethodOptions = function() {};

/* TODO: PropertyDeclaration: dojo.request.xhr."method" */

/**
 * @constructor
 * @struct
 */
dojo.request.xhr.__Options = function() {};

/* TODO: PropertyDeclaration: dojo.request.xhr."data" */

/* TODO: PropertyDeclaration: dojo.request.xhr."handleAs" */

/* TODO: PropertyDeclaration: dojo.request.xhr."headers" */

/* TODO: PropertyDeclaration: dojo.request.xhr."method" */

/* TODO: PropertyDeclaration: dojo.request.xhr."password" */

/* TODO: PropertyDeclaration: dojo.request.xhr."preventCache" */

/* TODO: PropertyDeclaration: dojo.request.xhr."query" */

/* TODO: PropertyDeclaration: dojo.request.xhr."sync" */

/* TODO: PropertyDeclaration: dojo.request.xhr."timeout" */

/* TODO: PropertyDeclaration: dojo.request.xhr."user" */

/* TODO: PropertyDeclaration: dojo.request.xhr."withCredentials" */

/**
 * @constructor
 * @struct
 */
dojo.request.__BaseOptions = function() {};

/* TODO: PropertyDeclaration: dojo.request."data" */

/* TODO: PropertyDeclaration: dojo.request."handleAs" */

/* TODO: PropertyDeclaration: dojo.request."preventCache" */

/* TODO: PropertyDeclaration: dojo.request."query" */

/* TODO: PropertyDeclaration: dojo.request."timeout" */

/**
 * @constructor
 * @struct
 */
dojo.request.__MethodOptions = function() {};

/* TODO: PropertyDeclaration: dojo.request."method" */

/**
 * @constructor
 * @struct
 */
dojo.request.__Options = function() {};

/* TODO: PropertyDeclaration: dojo.request."data" */

/* TODO: PropertyDeclaration: dojo.request."handleAs" */

/* TODO: PropertyDeclaration: dojo.request."method" */

/* TODO: PropertyDeclaration: dojo.request."preventCache" */

/* TODO: PropertyDeclaration: dojo.request."query" */

/* TODO: PropertyDeclaration: dojo.request."timeout" */

/**
 * @constructor
 * @struct
 */
dojo.request.__Promise = function() {};

/* TODO: PropertyDeclaration: dojo.request."response" */

/**
 * Add a callback to be invoked when the promise is resolved
 * or rejected.
 * 
 * @param {!Function} callbackOrErrback               OptionalA function that is used both as a callback and errback.
 * @return {?}
 */
dojo.request.__Promise.prototype.always = function(callbackOrErrback) {};

/**
 * Inform the deferred it may cancel its asynchronous operation.
 * Inform the deferred it may cancel its asynchronous operation.
 * The deferred's (optional) canceler is invoked and the
 * deferred will be left in a rejected state. Can affect other
 * promises that originate with the same deferred.
 * 
 * @param {?} reason A message that may be sent to the deferred's canceler,explaining why it's being canceled.
 * @param {boolean=} strict               OptionalIf strict, will throw an error if the deferred has alreadybeen fulfilled and consequently cannot be canceled.
 * @return {?}
 */
dojo.request.__Promise.prototype.cancel = function(reason, strict) {};

/**
 * Checks whether the promise has been canceled.
 * 
 * @return {boolean}
 */
dojo.request.__Promise.prototype.isCanceled = function() {};

/**
 * Checks whether the promise has been resolved or rejected.
 * 
 * @return {boolean}
 */
dojo.request.__Promise.prototype.isFulfilled = function() {};

/**
 * Checks whether the promise has been rejected.
 * 
 * @return {boolean}
 */
dojo.request.__Promise.prototype.isRejected = function() {};

/**
 * Checks whether the promise has been resolved.
 * 
 * @return {boolean}
 */
dojo.request.__Promise.prototype.isResolved = function() {};

/**
 * Add new errbacks to the promise.
 * 
 * @param {!Function=} errback               OptionalCallback to be invoked when the promise is rejected.
 * @return {?}
 */
dojo.request.__Promise.prototype.otherwise = function(errback) {};

/**
 * Add new callbacks to the promise.
 * Add new callbacks to the deferred. Callbacks can be added
 * before or after the deferred is fulfilled.
 * 
 * @param {!Function=} callback               OptionalCallback to be invoked when the promise is resolved.Receives the resolution value.
 * @param {!Function=} errback               OptionalCallback to be invoked when the promise is rejected.Receives the rejection error.
 * @param {!Function=} progback               OptionalCallback to be invoked when the promise emits a progressupdate. Receives the progress update.
 * @return {!dojo.promise.Promise<?>}
 */
dojo.request.__Promise.prototype.then = function(callback, errback, progback) {};

/**
 *
 * @return {!String}
 */
dojo.request.__Promise.prototype.toString = function() {};

/**
 *
 * @return {!dojo.promise.Promise<?>}
 */
dojo.request.__Promise.prototype.trace = function() {};

/**
 *
 * @return {!dojo.promise.Promise<?>}
 */
dojo.request.__Promise.prototype.traceRejected = function() {};
/**
 * @record
 * @struct
 */
dojo.request.default_ = function() {};

/**
 *
 * @return {void}
 */
dojo.request.default_.prototype.getPlatformDefaultId = function() {};

/**
 *
 * @param {?} id
 * @param {?} parentRequire
 * @param {?} loaded
 * @param {?} config
 * @return {void}
 */
dojo.request.default_.prototype.load = function(id, parentRequire, loaded, config) {};
/**
 * @record
 * @struct
 */
dojo.request.util = function() {};

/**
 *
 * @param {?} provider
 * @param {?} methods
 * @return {void}
 */
dojo.request.util.prototype.addCommonMethods = function(provider, methods) {};

/**
 *
 * @param {?} stat
 * @return {boolean}
 */
dojo.request.util.prototype.checkStatus = function(stat) {};

/**
 *
 * @param {?} target
 * @param {?} source
 * @return {?}
 */
dojo.request.util.prototype.deepCopy = function(target, source) {};

/**
 *
 * @param {?} source
 * @param {?} properties
 * @return {?}
 */
dojo.request.util.prototype.deepCreate = function(source, properties) {};

/**
 *
 * @param {!Object} response The object used as the value of the request promise.
 * @param {?} cancel
 * @param {?} isValid
 * @param {?} isReady
 * @param {?} handleResponse
 * @param {?} last
 * @return {?}
 */
dojo.request.util.prototype.deferred = function(response, cancel, isValid, isReady, handleResponse, last) {};

/**
 * Register a listener to be notified when an event
 * in dojo/request happens.
 * 
 * @param {!String=} type               OptionalThe event to listen for. Events emitted: "start", "send","load", "error", "done", "stop".
 * @param {!Function=} listener               OptionalA callback to be run when an event happens.
 * @return {?}
 */
dojo.request.util.prototype.notify = function(type, listener) {};

/**
 *
 * @param {?} url
 * @param {?} options
 * @param {?} skipData
 * @return {!Object}
 */
dojo.request.util.prototype.parseArgs = function(url, options, skipData) {};
/**
 * @record
 * @struct
 */
dojo.AdapterRegistry = function() {};

/* TODO: CallSignature: dojo */
 /** @type {!Array<?>} */
dojo.AdapterRegistry.prototype.pairs;
 /** @type {boolean} */
dojo.AdapterRegistry.prototype.returnWrappers;

/**
 * Find an adapter for the given arguments. If no suitable adapter
 * is found, throws an exception. match() accepts any number of
 * arguments, all of which are passed to all matching functions
 * from the registered pairs.
 * 
 * @return {?}
 */
dojo.AdapterRegistry.prototype.match = function() {};

/**
 * register a check function to determine if the wrap function or
 * object gets selected
 * 
 * @param {!String} name a way to identify this matcher.
 * @param {!Function} check a function that arguments are passed to from the adapter'smatch() function.  The check function should return true if thegiven arguments are appropriate for the wrap function.
 * @param {!Function} wrap
 * @param {boolean=} directReturn               OptionalIf directReturn is true, the value passed in for wrap will bereturned instead of being called. Alternately, theAdapterRegistry can be set globally to "return not call" usingthe returnWrappers property. Either way, this behavior allowsthe registry to act as a "search" function instead of afunction interception library.
 * @param {boolean=} override               OptionalIf override is given and true, the check function will be givenhighest priority. Otherwise, it will be the lowest priorityadapter.
 * @return {void}
 */
dojo.AdapterRegistry.prototype.register = function(name, check, wrap, directReturn, override) {};

/**
 * Remove a named adapter from the registry
 * 
 * @param {!String} name The name of the adapter.
 * @return {?}
 */
dojo.AdapterRegistry.prototype.unregister = function(name) {};
/**
 * @record
 * @struct
 */
dojo.cache = function() {};

/* TODO: CallSignature: dojo */

/* TODO: CallSignature: dojo */

/* TODO: CallSignature: dojo */

/* TODO: CallSignature: dojo */
/**
 * @record
 * @struct
 */
dojo.cookie = function() {};

/* TODO: CallSignature: dojo */

/**
 * Use to determine if the current browser supports cookies or not.
 * 
 * Returns true if user allows cookies.
 * Returns false if user doesn't allow cookies.
 * 
 * @return {void}
 */
dojo.cookie.prototype.isSupported = function() {};
/**
 * @record
 * @struct
 */
dojo.domReady = function() {};

/* TODO: CallSignature: dojo */

/**
 *
 * @param {?} id
 * @param {?} req
 * @param {?} load
 * @return {void}
 */
dojo.domReady.prototype.load = function(id, req, load) {};
/**
 * @record
 * @struct
 */
dojo.hash = function() {};

/* TODO: CallSignature: dojo */
/**
 * @record
 * @struct
 */
dojo.has = function() {};

/* TODO: CallSignature: dojo */

/* TODO: CallSignature: dojo */
 /** @type {string} */
dojo.has.prototype.cache;

/**
 * Register a new feature test for some named feature.
 * 
 * Register a new feature test for some named feature.
 * 
 * @param {!String|number} name The name (if a string) or identifier (if an integer) of the feature to test.
 * @param {!Function} test A test function to register. If a function, queued for testing until actuallyneeded. The test function should return a boolean indicatingthe presence of a feature or bug.
 * @param {boolean=} now               OptionalOptional. Omit if test is not a function. Provides a way to immediatelyrun the test and cache the result.
 * @param {boolean=} force               OptionalOptional. If the test already exists and force is truthy, then the existingtest will be replaced; otherwise, add does not replace an existing test (thatis, by default, the first test advice wins).
 * @return {?}
 */
dojo.has.prototype.add = function(name, test, now, force) {};

/**
 * Deletes the contents of the element passed to test functions.
 * 
 * @param {?} element
 * @return {void}
 */
dojo.has.prototype.clearElement = function(element) {};

/**
 * Conditional loading of AMD modules based on a has feature test value.
 * 
 * @param {!String} id Gives the resolved module id to load.
 * @param {!Function} parentRequire The loader require function with respect to the module that contained the plugin resource in it'sdependency list.
 * @param {!Function} loaded Callback to loader that consumes result of plugin demand.
 * @return {void}
 */
dojo.has.prototype.load = function(id, parentRequire, loaded) {};

/**
 * Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).
 * 
 * @param {?} id
 * @param {!Function} toAbsMid Resolves a relative module id into an absolute module id
 * @return {void}
 */
dojo.has.prototype.normalize = function(id, toAbsMid) {};
/**
 * @record
 * @struct
 */
dojo.hccss = function() {};

/* TODO: CallSignature: dojo */
/**
 * @record
 * @struct
 */
dojo.NodeList_data = function() {};

/* TODO: CallSignature: dojo */
/**
 * @record
 * @struct
 */
dojo.NodeList_html = function() {};

/* TODO: CallSignature: dojo */
/**
 * @record
 * @struct
 */
dojo.NodeList_fx = function() {};

/* TODO: CallSignature: dojo */

/**
 * fade all elements of the node list to a specified opacity
 * 
 * @param {?} args
 * @return {?}
 */
dojo.NodeList_fx.prototype.fadeTo = function(args) {};

/**
 * highlight all elements of the node list.
 * Returns an instance of dojo.Animation
 * 
 * @param {?} args
 * @return {?}
 */
dojo.NodeList_fx.prototype.highlight = function(args) {};

/**
 * size all elements of this NodeList. Returns an instance of dojo.Animation
 * 
 * @param {?} args
 * @return {?}
 */
dojo.NodeList_fx.prototype.sizeTo = function(args) {};

/**
 * slide all elements of this NodeList. Returns an instance of dojo.Animation
 * 
 * @param {?} args
 * @return {?}
 */
dojo.NodeList_fx.prototype.slideBy = function(args) {};

/**
 * Wipe all elements of the NodeList to a specified width: or height:
 * 
 * @param {?} args
 * @return {?}
 */
dojo.NodeList_fx.prototype.wipeTo = function(args) {};
/**
 * @record
 * @struct
 */
dojo.NodeList_dom = function() {};

/* TODO: CallSignature: dojo */
/**
 * @record
 * @struct
 */
dojo.NodeList_manipulate = function() {};

/* TODO: CallSignature: dojo */
/**
 * @record
 * @struct
 */
dojo.NodeList_traverse = function() {};

/* TODO: CallSignature: dojo */
/**
 * @record
 * @struct
 */
dojo.on = function() {};

/* TODO: CallSignature: dojo */

/* TODO: CallSignature: dojo */

/* TODO: CallSignature: dojo */

/* TODO: CallSignature: dojo */

/**
 *
 * @param {?} target
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.on.prototype.emit = function(target, type, event) {};

/**
 * This function acts the same as on(), but will only call the listener once. The
 * listener will be called for the first
 * event that takes place and then listener will automatically be removed.
 * 
 * @param {?} target
 * @param {?} type
 * @param {?} listener
 * @param {?=} dontFix
 * @return {?}
 */
dojo.on.prototype.once = function(target, type, listener, dontFix) {};

/**
 *
 * @param {?} target
 * @param {?} type
 * @param {?} listener
 * @param {?} addListener
 * @param {?} dontFix
 * @param {?} matchesTarget
 * @return {?}
 */
dojo.on.prototype.parse = function(target, type, listener, addListener, dontFix, matchesTarget) {};

/**
 * This function acts the same as on(), but with pausable functionality. The
 * returned signal object has pause() and resume() functions. Calling the
 * pause() method will cause the listener to not be called for future events. Calling the
 * resume() method will cause the listener to again be called for future events.
 * 
 * @param {?} target
 * @param {?} type
 * @param {?} listener
 * @param {?} dontFix
 * @return {?}
 */
dojo.on.prototype.pausable = function(target, type, listener, dontFix) {};

/**
 * Creates a new extension event with event delegation. This is based on
 * the provided event type (can be extension event) that
 * only calls the listener when the CSS selector matches the target of the event.
 * 
 * The application must require() an appropriate level of dojo/query to handle the selector.
 * 
 * @param {?} selector The CSS selector to use for filter events and determine the |this| of the event listener.
 * @param {?} eventType The event to listen for
 * @param {?} children Indicates if children elements of the selector should be allowed. This defaults to true
 * @return {!Function}
 */
dojo.on.prototype.selector = function(selector, eventType, children) {};
/**
 * @record
 * @struct
 */
dojo.query = function() {};

/* TODO: CallSignature: dojo */

/* TODO: CallSignature: dojo */

/**
 * can be used as AMD plugin to conditionally load new query engine
 * 
 * @param {?} id
 * @param {?} parentRequire
 * @param {?} loaded
 * @return {void}
 */
dojo.query.prototype.load = function(id, parentRequire, loaded) {};

/**
 * Array-like object which adds syntactic
 * sugar for chaining, common iteration operations, animation, and
 * node manipulation. NodeLists are most often returned as the
 * result of dojo/query() calls.
 * NodeList instances provide many utilities that reflect
 * core Dojo APIs for Array iteration and manipulation, DOM
 * manipulation, and event handling. Instead of needing to dig up
 * functions in the dojo package, NodeLists generally make the
 * full power of Dojo available for DOM manipulation tasks in a
 * simple, chainable way.
 * 
 * @param {?} array
 * @return {!Array<?>}
 */
dojo.query.prototype.NodeList = function(array) {};
/**
 * @record
 * @struct
 */
dojo.ready = function() {};

/* TODO: CallSignature: dojo */
/**
 * @record
 * @struct
 */
dojo.sniff = function() {};

/* TODO: CallSignature: dojo */
/**
 * @record
 * @struct
 */
dojo.when = function() {};

/* TODO: CallSignature: dojo */

/**
 * @constructor
 * @struct
 */
dojo.DeferredList = function() {};

/**
 * Gathers the results of the deferreds for packaging
 * as the parameters to the Deferred Lists' callback
 * 
 * @param {!dojo.DeferredList} deferredList The deferred list from which this function gathers results.
 * @return {?}
 */
dojo.DeferredList.prototype.gatherResults = function(deferredList) {};

/**
 * @constructor
 * @struct
 * @param {!Function=} canceler
 */
dojo.Deferred = function(canceler) {};

/* TODO: PropertyDeclaration: dojo."promise" */

/**
 * Inform the deferred it may cancel its asynchronous operation.
 * Inform the deferred it may cancel its asynchronous operation.
 * The deferred's (optional) canceler is invoked and the
 * deferred will be left in a rejected state. Can affect other
 * promises that originate with the same deferred.
 * 
 * @param {?} reason A message that may be sent to the deferred's canceler,explaining why it's being canceled.
 * @param {boolean=} strict               OptionalIf strict, will throw an error if the deferred has alreadybeen fulfilled and consequently cannot be canceled.
 * @return {?}
 */
dojo.Deferred.prototype.cancel = function(reason, strict) {};

/**
 * Checks whether the deferred has been canceled.
 * 
 * @return {boolean}
 */
dojo.Deferred.prototype.isCanceled = function() {};

/**
 * Checks whether the deferred has been resolved or rejected.
 * 
 * @return {boolean}
 */
dojo.Deferred.prototype.isFulfilled = function() {};

/**
 * Checks whether the deferred has been rejected.
 * 
 * @return {boolean}
 */
dojo.Deferred.prototype.isRejected = function() {};

/**
 * Checks whether the deferred has been resolved.
 * 
 * @return {boolean}
 */
dojo.Deferred.prototype.isResolved = function() {};

/**
 * Emit a progress update on the deferred.
 * Emit a progress update on the deferred. Progress updates
 * can be used to communicate updates about the asynchronous
 * operation before it has finished.
 * 
 * @param {?} update The progress update. Passed to progbacks.
 * @param {boolean=} strict               OptionalIf strict, will throw an error if the deferred has alreadybeen fulfilled and consequently no progress can be emitted.
 * @return {!dojo.promise.Promise<?>}
 */
dojo.Deferred.prototype.progress = function(update, strict) {};

/**
 * Reject the deferred.
 * Reject the deferred, putting it in an error state.
 * 
 * @param {?} error The error result of the deferred. Passed to errbacks.
 * @param {boolean=} strict               OptionalIf strict, will throw an error if the deferred has alreadybeen fulfilled and consequently cannot be rejected.
 * @return {?}
 */
dojo.Deferred.prototype.reject = function(error, strict) {};

/**
 * Resolve the deferred.
 * Resolve the deferred, putting it in a success state.
 * 
 * @param {?} value The result of the deferred. Passed to callbacks.
 * @param {boolean=} strict               OptionalIf strict, will throw an error if the deferred has alreadybeen fulfilled and consequently cannot be resolved.
 * @return {!dojo.promise.Promise<?>}
 */
dojo.Deferred.prototype.resolve = function(value, strict) {};

/**
 * Add new callbacks to the deferred.
 * Add new callbacks to the deferred. Callbacks can be added
 * before or after the deferred is fulfilled.
 * 
 * @param {!Function=} callback               OptionalCallback to be invoked when the promise is resolved.Receives the resolution value.
 * @param {!Function=} errback               OptionalCallback to be invoked when the promise is rejected.Receives the rejection error.
 * @param {!Function=} progback               OptionalCallback to be invoked when the promise emits a progressupdate. Receives the progress update.
 * @return {!dojo.promise.Promise<?>}
 */
dojo.Deferred.prototype.then = function(callback, errback, progback) {};

/**
 *
 * @return {!String}
 */
dojo.Deferred.prototype.toString = function() {};

/**
 * @constructor
 * @struct
 */
dojo.Evented = function() {};

/**
 *
 * @param {!String} type
 * @param {?} data
 * @return {?}
 */
dojo.Evented.prototype.emit = function(type, data) {};

/**
 *
 * @param {!String} type
 * @param {function(?): void} listener
 * @return {{remove: function(): void}}
 */
dojo.Evented.prototype.on = function(type, listener) {};

/**
 * @constructor
 * @struct
 * @param {?} array
 */
dojo.NodeList = function(array) {};

/* TODO: PropertyDeclaration: dojo."events" */

/**
 * adds the specified class to every node in the list
 * 
 * adds the specified class to every node in the list
 * 
 * @param {!String|!Array<?>} className A String class name to add, or several space-separated class names,or an array of class names.
 * @return {void}
 */
dojo.NodeList.prototype.addClass = function(className) {};

/**
 * Animate the effects of adding a class to all nodes in this list.
 * see dojox.fx.addClass
 * 
 * @param {?} cssClass
 * @param {?} args
 * @return {{type: !Function, value: ?}}
 */
dojo.NodeList.prototype.addClassFx = function(cssClass, args) {};

/**
 * add a node, NodeList or some HTML as a string to every item in the
 * list.  Returns the original list.
 * a copy of the HTML content is added to each item in the
 * list, with an optional position argument. If no position
 * argument is provided, the content is appended to the end of
 * each item.
 * 
 * add a node, NodeList or some HTML as a string to every item in the
 * list.  Returns the original list.
 * a copy of the HTML content is added to each item in the
 * list, with an optional position argument. If no position
 * argument is provided, the content is appended to the end of
 * each item.
 * 
 * add a node, NodeList or some HTML as a string to every item in the
 * list.  Returns the original list.
 * a copy of the HTML content is added to each item in the
 * list, with an optional position argument. If no position
 * argument is provided, the content is appended to the end of
 * each item.
 * 
 * add a node, NodeList or some HTML as a string to every item in the
 * list.  Returns the original list.
 * a copy of the HTML content is added to each item in the
 * list, with an optional position argument. If no position
 * argument is provided, the content is appended to the end of
 * each item.
 * 
 * add a node, NodeList or some HTML as a string to every item in the
 * list.  Returns the original list.
 * a copy of the HTML content is added to each item in the
 * list, with an optional position argument. If no position
 * argument is provided, the content is appended to the end of
 * each item.
 * 
 * add a node, NodeList or some HTML as a string to every item in the
 * list.  Returns the original list.
 * a copy of the HTML content is added to each item in the
 * list, with an optional position argument. If no position
 * argument is provided, the content is appended to the end of
 * each item.
 * 
 * add a node, NodeList or some HTML as a string to every item in the
 * list.  Returns the original list.
 * a copy of the HTML content is added to each item in the
 * list, with an optional position argument. If no position
 * argument is provided, the content is appended to the end of
 * each item.
 * 
 * add a node, NodeList or some HTML as a string to every item in the
 * list.  Returns the original list.
 * a copy of the HTML content is added to each item in the
 * list, with an optional position argument. If no position
 * argument is provided, the content is appended to the end of
 * each item.
 * 
 * @param {!String|!HTMLElement|!Object|!dojo.NodeList} content the content to be set on the parent element.This can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes
 * @param {!String|number=} position               Optionalcan be one of:"last"||"end" (default)"first||"start""before""after""replace" (replaces nodes in this NodeList with new content)"only" (removes other children of the nodes so new content is the only child)or an offset in the childNodes property
 * @return {!Function}
 */
dojo.NodeList.prototype.addContent = function(content, position) {};

/**
 * places any/all elements in queryOrListOrNode at a
 * position relative to the first element in this list.
 * Returns a dojo/NodeList of the adopted elements.
 * 
 * places any/all elements in queryOrListOrNode at a
 * position relative to the first element in this list.
 * Returns a dojo/NodeList of the adopted elements.
 * 
 * places any/all elements in queryOrListOrNode at a
 * position relative to the first element in this list.
 * Returns a dojo/NodeList of the adopted elements.
 * 
 * @param {!String|!Array<?>|!HTMLElement} queryOrListOrNode a DOM node or a query string or a query result.Represents the nodes to be adopted relative to thefirst element of this NodeList.
 * @param {!String=} position               Optionalcan be one of:"last" (default)"first""before""after""only""replace"or an offset in the childNodes property
 * @return {?}
 */
dojo.NodeList.prototype.adopt = function(queryOrListOrNode, position) {};

/**
 * Places the content after every node in the NodeList.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * Places the content after every node in the NodeList.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * Places the content after every node in the NodeList.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * @param {!String|!HTMLElement|!dojo.NodeList} content
 * @return {?}
 */
dojo.NodeList.prototype.after = function(content) {};

/**
 * Adds the nodes from the previous dojo/NodeList to the current dojo/NodeList.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * @return {?}
 */
dojo.NodeList.prototype.andSelf = function() {};

/**
 * Animate one or more CSS properties for all nodes in this list.
 * The returned animation object will already be playing when it
 * is returned. See the docs for dojo.anim for full details.
 * 
 * @param {!Object} properties the properties to animate. does NOT support the auto parameter like otherNodeList-fx methods.
 * @param {number=} duration               OptionalOptional. The time to run the animations for
 * @param {!Function=} easing               OptionalOptional. The easing function to use.
 * @param {!Function=} onEnd               OptionalA function to be called when the animation ends
 * @param {number=} delay               Optionalhow long to delay playing the returned animation
 * @return {?}
 */
dojo.NodeList.prototype.anim = function(properties, duration, easing, onEnd, delay) {};

/**
 * Animate all elements of this NodeList across the properties specified.
 * syntax identical to dojo.animateProperty
 * 
 * @param {!Object=} args               OptionalAdditional dojo/_base/fx.Animation arguments to mix into this set with the addition ofan auto parameter.
 * @return {?}
 */
dojo.NodeList.prototype.animateProperty = function(args) {};

/**
 * appends the content to every node in the NodeList.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * appends the content to every node in the NodeList.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * appends the content to every node in the NodeList.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * @param {!String|!HTMLElement|!dojo.NodeList} content
 * @return {?}
 */
dojo.NodeList.prototype.append = function(content) {};

/**
 * appends nodes in this NodeList to the nodes matched by
 * the query passed to appendTo.
 * The nodes in this NodeList will be cloned if the query
 * matches more than one element. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * @param {!String} query
 * @return {?}
 */
dojo.NodeList.prototype.appendTo = function(query) {};

/**
 * Returns a new NodeList comprised of items in this NodeList
 * at the given index or indices.
 * 
 * @param {!Array<number>} index One or more 0-based indices of items in the currentNodeList. A negative index will start at the end of thelist and go backwards.
 * @return {?}
 */
dojo.NodeList.prototype.at = function(index) {};

/**
 * gets or sets the DOM attribute for every element in the
 * NodeList. See also dojo/dom-attr
 * 
 * @param {!String} property the attribute to get/set
 * @param {!String=} value               Optionaloptional. The value to set the property to
 * @return {?}
 */
dojo.NodeList.prototype.attr = function(property, value) {};

/**
 * Places the content before every node in the NodeList.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * Places the content before every node in the NodeList.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * Places the content before every node in the NodeList.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * @param {!String|!HTMLElement|!dojo.NodeList} content
 * @return {?}
 */
dojo.NodeList.prototype.before = function(content) {};

/**
 * Returns all immediate child elements for nodes in this dojo/NodeList.
 * Optionally takes a query to filter the child elements.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * @param {!String=} query               Optionala CSS selector.
 * @return {?}
 */
dojo.NodeList.prototype.children = function(query) {};

/**
 * Clones all the nodes in this NodeList and returns them as a new NodeList.
 * Only the DOM nodes are cloned, not any attached event handlers.
 * 
 * @return {?}
 */
dojo.NodeList.prototype.clone = function() {};

/**
 * Returns closest parent that matches query, including current node in this
 * dojo/NodeList if it matches the query.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * Returns closest parent that matches query, including current node in this
 * dojo/NodeList if it matches the query.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * @param {!String} query a CSS selector.
 * @param {!String|!HTMLElement=} root               OptionalIf specified, query is relative to "root" rather than document body.
 * @return {?}
 */
dojo.NodeList.prototype.closest = function(query, root) {};

/**
 * Returns a new NodeList comprised of items in this NodeList
 * as well as items passed in as parameters
 * This method behaves exactly like the Array.concat method
 * with the caveat that it returns a NodeList and not a
 * raw Array. For more details, see the Array.concat
 * docs
 * 
 * @param {!Object} item               OptionalAny number of optional parameters may be passed in to bespliced into the NodeList
 * @return {?}
 */
dojo.NodeList.prototype.concat = function(item) {};

/**
 * Attach event handlers to every item of the NodeList. Uses dojo.connect()
 * so event properties are normalized.
 * 
 * Application must manually require() "dojo/_base/connect" before using this method.
 * 
 * Attach event handlers to every item of the NodeList. Uses dojo.connect()
 * so event properties are normalized.
 * 
 * Application must manually require() "dojo/_base/connect" before using this method.
 * 
 * Attach event handlers to every item of the NodeList. Uses dojo.connect()
 * so event properties are normalized.
 * 
 * Application must manually require() "dojo/_base/connect" before using this method.
 * 
 * @param {!String} methodName the name of the method to attach to. For DOM events, this should bethe lower-case name of the event
 * @param {!Object|!Function|!String} objOrFunc if 2 arguments are passed (methodName, objOrFunc), objOrFunc shouldreference a function or be the name of the function in the globalnamespace to attach. If 3 arguments are provided(methodName, objOrFunc, funcName), objOrFunc must be the scope tolocate the bound function in
 * @param {!String=} funcName               Optionaloptional. A string naming the function in objOrFunc to bind to theevent. May also be a function reference.
 * @return {void}
 */
dojo.NodeList.prototype.connect = function(methodName, objOrFunc, funcName) {};

/**
 * Deprecated: Use position() for border-box x/y/w/h
 * or marginBox() for margin-box w/h/l/t.
 * Returns the box objects of all elements in a node list as
 * an Array (not a NodeList). Acts like domGeom.coords, though assumes
 * the node passed is each node in this list.
 * 
 * @return {void}
 */
dojo.NodeList.prototype.coords = function() {};

/**
 * stash or get some arbitrary data on/from these nodes.
 * Stash or get some arbitrary data on/from these nodes. This private _data function is
 * exposed publicly on dojo/NodeList, eg: as the result of a dojo/query call.
 * DIFFERS from jQuery.data in that when used as a getter, the entire list is ALWAYS
 * returned. EVEN WHEN THE LIST IS length == 1.
 * 
 * A single-node version of this function is provided as dojo._nodeData, which follows
 * the same signature, though expects a String ID or DomNode reference in the first
 * position, before key/value arguments.
 * 
 * stash or get some arbitrary data on/from these nodes.
 * Stash or get some arbitrary data on/from these nodes. This private _data function is
 * exposed publicly on dojo/NodeList, eg: as the result of a dojo/query call.
 * DIFFERS from jQuery.data in that when used as a getter, the entire list is ALWAYS
 * returned. EVEN WHEN THE LIST IS length == 1.
 * 
 * A single-node version of this function is provided as dojo._nodeData, which follows
 * the same signature, though expects a String ID or DomNode reference in the first
 * position, before key/value arguments.
 * 
 * @param {!Object|!String=} key               OptionalIf an object, act as a setter and iterate over said object setting data items as defined.If a string, and value present, set the data for defined key to valueIf a string, and value absent, act as a getter, returning the data associated with said key
 * @param {?=} value               OptionalThe value to set for said key, provided key is a string (and not an object)
 * @return {?}
 */
dojo.NodeList.prototype.data = function(key, value) {};

/**
 * Monitor nodes in this NodeList for [bubbled] events on nodes that match selector.
 * Calls fn(evt) for those events, where (inside of fn()), this == the node
 * that matches the selector.
 * Sets up event handlers that can catch events on any subnodes matching a given selector,
 * including nodes created after delegate() has been called.
 * 
 * This allows an app to setup a single event handler on a high level node, rather than many
 * event handlers on subnodes. For example, one onclick handler for a Tree widget, rather than separate
 * handlers for each node in the tree.
 * Since setting up many event handlers is expensive, this can increase performance.
 * 
 * Note that delegate() will not work for events that don't bubble, like focus.
 * onmouseenter/onmouseleave also don't currently work.
 * 
 * @param {!String} selector CSS selector valid to dojo.query, like ".foo" or "div > span".  Theselector is relative to the nodes in this NodeList, not the document root.For example myNodeList.delegate("> a", "onclick", ...) will catch events onanchor nodes which are (immediate) children of the nodes in myNodeList.
 * @param {!String} eventName Standard event name used as an argument to dojo.connect, like "onclick".
 * @param {!Function} fn Callback function passed the event object, and where this == the node that matches the selector.That means that for example, after setting up a handler viadojo.query("body").delegate("fieldset", "onclick", ...)clicking on a fieldset or any nodes inside of a fieldset will be reportedas a click on the fieldset itself.
 * @return {?}
 */
dojo.NodeList.prototype.delegate = function(selector, eventName, fn) {};

/**
 * Renders the specified template in each of the NodeList entries.
 * 
 * Renders the specified template in each of the NodeList entries.
 * 
 * Renders the specified template in each of the NodeList entries.
 * 
 * Renders the specified template in each of the NodeList entries.
 * 
 * @param {!dojox.dtl.__StringArgs|!String} template The template string or location
 * @param {!dojox.dtl.__ObjectArgs|!Object} context The context object or location
 * @return {!Function}
 */
dojo.NodeList.prototype.dtl = function(template, context) {};

/**
 * clears all content from each node in the list. Effectively
 * equivalent to removing all child nodes from every item in
 * the list.
 * 
 * @return {?}
 */
dojo.NodeList.prototype.empty = function() {};

/**
 * Ends use of the current NodeList by returning the previous NodeList
 * that generated the current NodeList.
 * Returns the NodeList that generated the current NodeList. If there
 * is no parent NodeList, an empty NodeList is returned.
 * 
 * @return {?}
 */
dojo.NodeList.prototype.end = function() {};

/**
 * Returns the even nodes in this dojo/NodeList as a dojo/NodeList.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * @return {?}
 */
dojo.NodeList.prototype.even = function() {};

/**
 * see dojo/_base/array.every() and the Array.every
 * docs.
 * Takes the same structure of arguments and returns as
 * dojo/_base/array.every() with the caveat that the passed array is
 * implicitly this NodeList
 * 
 * @param {!Function} callback the callback
 * @param {!Object=} thisObject               Optionalthe context
 * @return {?}
 */
dojo.NodeList.prototype.every = function(callback, thisObject) {};

/**
 * fade in all elements of this NodeList via dojo.fadeIn
 * 
 * @param {!Object=} args               OptionalAdditional dojo/_base/fx.Animation arguments to mix into this set with the addition ofan auto parameter.
 * @return {?}
 */
dojo.NodeList.prototype.fadeIn = function(args) {};

/**
 * fade out all elements of this NodeList via dojo.fadeOut
 * 
 * @param {!Object=} args               OptionalAdditional dojo/_base/fx.Animation arguments to mix into this set with the addition ofan auto parameter.
 * @return {?}
 */
dojo.NodeList.prototype.fadeOut = function(args) {};

/**
 * "masks" the built-in javascript filter() method (supported
 * in Dojo via dojo.filter) to support passing a simple
 * string filter in addition to supporting filtering function
 * objects.
 * 
 * "masks" the built-in javascript filter() method (supported
 * in Dojo via dojo.filter) to support passing a simple
 * string filter in addition to supporting filtering function
 * objects.
 * 
 * @param {!String|!Function} filter If a string, a CSS rule like ".thinger" or "div > span".
 * @return {?}
 */
dojo.NodeList.prototype.filter = function(filter) {};

/**
 * Returns the first node in this dojo/NodeList as a dojo/NodeList.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * @return {?}
 */
dojo.NodeList.prototype.first = function() {};

/**
 * see dojo/_base/array.forEach(). The primary difference is that the acted-on
 * array is implicitly this NodeList. If you want the option to break out
 * of the forEach loop, use every() or some() instead.
 * 
 * @param {?} callback
 * @param {?} thisObj
 * @return {!Function}
 */
dojo.NodeList.prototype.forEach = function(callback, thisObj) {};

/**
 * allows setting the innerHTML of each node in the NodeList,
 * if there is a value passed in, otherwise, reads the innerHTML value of the first node.
 * This method is simpler than the dojo/NodeList.html() method provided by
 * dojo/NodeList-html. This method just does proper innerHTML insertion of HTML fragments,
 * and it allows for the innerHTML to be read for the first node in the node list.
 * Since dojo/NodeList-html already took the "html" name, this method is called
 * "innerHTML". However, if dojo/NodeList-html has not been loaded yet, this
 * module will define an "html" method that can be used instead. Be careful if you
 * are working in an environment where it is possible that dojo/NodeList-html could
 * have been loaded, since its definition of "html" will take precedence.
 * The nodes represented by the value argument will be cloned if more than one
 * node is in this NodeList. The nodes in this NodeList are returned in the "set"
 * usage of this method, not the HTML that was inserted.
 * 
 * allows setting the innerHTML of each node in the NodeList,
 * if there is a value passed in, otherwise, reads the innerHTML value of the first node.
 * This method is simpler than the dojo/NodeList.html() method provided by
 * dojo/NodeList-html. This method just does proper innerHTML insertion of HTML fragments,
 * and it allows for the innerHTML to be read for the first node in the node list.
 * Since dojo/NodeList-html already took the "html" name, this method is called
 * "innerHTML". However, if dojo/NodeList-html has not been loaded yet, this
 * module will define an "html" method that can be used instead. Be careful if you
 * are working in an environment where it is possible that dojo/NodeList-html could
 * have been loaded, since its definition of "html" will take precedence.
 * The nodes represented by the value argument will be cloned if more than one
 * node is in this NodeList. The nodes in this NodeList are returned in the "set"
 * usage of this method, not the HTML that was inserted.
 * 
 * allows setting the innerHTML of each node in the NodeList,
 * if there is a value passed in, otherwise, reads the innerHTML value of the first node.
 * This method is simpler than the dojo/NodeList.html() method provided by
 * dojo/NodeList-html. This method just does proper innerHTML insertion of HTML fragments,
 * and it allows for the innerHTML to be read for the first node in the node list.
 * Since dojo/NodeList-html already took the "html" name, this method is called
 * "innerHTML". However, if dojo/NodeList-html has not been loaded yet, this
 * module will define an "html" method that can be used instead. Be careful if you
 * are working in an environment where it is possible that dojo/NodeList-html could
 * have been loaded, since its definition of "html" will take precedence.
 * The nodes represented by the value argument will be cloned if more than one
 * node is in this NodeList. The nodes in this NodeList are returned in the "set"
 * usage of this method, not the HTML that was inserted.
 * 
 * @param {!String|!HTMLElement|!dojo.NodeList=} value               Optional
 * @return {?}
 */
dojo.NodeList.prototype.html = function(value) {};

/**
 * see dojo/_base/array.indexOf(). The primary difference is that the acted-on
 * array is implicitly this NodeList
 * For more details on the behavior of indexOf, see Mozilla's
 * indexOf
 * docs
 * 
 * @param {!Object} value The value to search for.
 * @param {number} fromIndex               OptionalThe location to start searching from. Optional. Defaults to 0.
 * @return {?}
 */
dojo.NodeList.prototype.indexOf = function(value, fromIndex) {};

/**
 * allows setting the innerHTML of each node in the NodeList,
 * if there is a value passed in, otherwise, reads the innerHTML value of the first node.
 * This method is simpler than the dojo/NodeList.html() method provided by
 * dojo/NodeList-html. This method just does proper innerHTML insertion of HTML fragments,
 * and it allows for the innerHTML to be read for the first node in the node list.
 * Since dojo/NodeList-html already took the "html" name, this method is called
 * "innerHTML". However, if dojo/NodeList-html has not been loaded yet, this
 * module will define an "html" method that can be used instead. Be careful if you
 * are working in an environment where it is possible that dojo/NodeList-html could
 * have been loaded, since its definition of "html" will take precedence.
 * The nodes represented by the value argument will be cloned if more than one
 * node is in this NodeList. The nodes in this NodeList are returned in the "set"
 * usage of this method, not the HTML that was inserted.
 * 
 * allows setting the innerHTML of each node in the NodeList,
 * if there is a value passed in, otherwise, reads the innerHTML value of the first node.
 * This method is simpler than the dojo/NodeList.html() method provided by
 * dojo/NodeList-html. This method just does proper innerHTML insertion of HTML fragments,
 * and it allows for the innerHTML to be read for the first node in the node list.
 * Since dojo/NodeList-html already took the "html" name, this method is called
 * "innerHTML". However, if dojo/NodeList-html has not been loaded yet, this
 * module will define an "html" method that can be used instead. Be careful if you
 * are working in an environment where it is possible that dojo/NodeList-html could
 * have been loaded, since its definition of "html" will take precedence.
 * The nodes represented by the value argument will be cloned if more than one
 * node is in this NodeList. The nodes in this NodeList are returned in the "set"
 * usage of this method, not the HTML that was inserted.
 * 
 * allows setting the innerHTML of each node in the NodeList,
 * if there is a value passed in, otherwise, reads the innerHTML value of the first node.
 * This method is simpler than the dojo/NodeList.html() method provided by
 * dojo/NodeList-html. This method just does proper innerHTML insertion of HTML fragments,
 * and it allows for the innerHTML to be read for the first node in the node list.
 * Since dojo/NodeList-html already took the "html" name, this method is called
 * "innerHTML". However, if dojo/NodeList-html has not been loaded yet, this
 * module will define an "html" method that can be used instead. Be careful if you
 * are working in an environment where it is possible that dojo/NodeList-html could
 * have been loaded, since its definition of "html" will take precedence.
 * The nodes represented by the value argument will be cloned if more than one
 * node is in this NodeList. The nodes in this NodeList are returned in the "set"
 * usage of this method, not the HTML that was inserted.
 * 
 * @param {!String|!HTMLElement|!dojo.NodeList=} value               Optional
 * @return {?}
 */
dojo.NodeList.prototype.innerHTML = function(value) {};

/**
 * The nodes in this NodeList will be placed after the nodes
 * matched by the query passed to insertAfter.
 * The nodes in this NodeList will be cloned if the query
 * matches more than one element. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * @param {!String} query
 * @return {?}
 */
dojo.NodeList.prototype.insertAfter = function(query) {};

/**
 * The nodes in this NodeList will be placed after the nodes
 * matched by the query passed to insertAfter.
 * The nodes in this NodeList will be cloned if the query
 * matches more than one element. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * @param {!String} query
 * @return {?}
 */
dojo.NodeList.prototype.insertBefore = function(query) {};

/**
 * Create a new instance of a specified class, using the
 * specified properties and each node in the NodeList as a
 * srcNodeRef.
 * 
 * Create a new instance of a specified class, using the
 * specified properties and each node in the NodeList as a
 * srcNodeRef.
 * 
 * @param {!String|!Object} declaredClass
 * @param {!Object=} properties               Optional
 * @return {?}
 */
dojo.NodeList.prototype.instantiate = function(declaredClass, properties) {};

/**
 * Returns the last node in this dojo/NodeList as a dojo/NodeList.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * @return {?}
 */
dojo.NodeList.prototype.last = function() {};

/**
 * see dojo/_base/array.lastIndexOf(). The primary difference is that the
 * acted-on array is implicitly this NodeList
 * For more details on the behavior of lastIndexOf, see
 * Mozilla's lastIndexOf
 * docs
 * 
 * @param {!Object} value The value to search for.
 * @param {number=} fromIndex               OptionalThe location to start searching from. Optional. Defaults to 0.
 * @return {?}
 */
dojo.NodeList.prototype.lastIndexOf = function(value, fromIndex) {};

/**
 * see dojo/_base/array.map(). The primary difference is that the acted-on
 * array is implicitly this NodeList and the return is a
 * NodeList (a subclass of Array)
 * 
 * @param {!Function} func
 * @param {!Function=} obj               Optional
 * @return {?}
 */
dojo.NodeList.prototype.map = function(func, obj) {};

/**
 * Returns margin-box size of nodes
 * 
 * @return {void}
 */
dojo.NodeList.prototype.marginBox = function() {};

/**
 * Returns the next element for nodes in this dojo/NodeList.
 * Optionally takes a query to filter the next elements.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * @param {!String=} query               Optionala CSS selector.
 * @return {?}
 */
dojo.NodeList.prototype.next = function(query) {};

/**
 * Returns all sibling elements that come after the nodes in this dojo/NodeList.
 * Optionally takes a query to filter the sibling elements.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * @param {!String=} query               Optionala CSS selector.
 * @return {?}
 */
dojo.NodeList.prototype.nextAll = function(query) {};

/**
 * Returns the odd nodes in this dojo/NodeList as a dojo/NodeList.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * @return {?}
 */
dojo.NodeList.prototype.odd = function() {};

/**
 * Listen for events on the nodes in the NodeList. Basic usage is:
 * 
 * @param {?} eventName
 * @param {?} listener
 * @return {?}
 */
dojo.NodeList.prototype.on = function(eventName, listener) {};

/**
 * removes elements in this list that match the filter
 * from their parents and returns them as a new NodeList.
 * 
 * @param {!String=} filter               OptionalCSS selector like ".foo" or "div > span"
 * @return {?}
 */
dojo.NodeList.prototype.orphan = function(filter) {};

/**
 * Returns immediate parent elements for nodes in this dojo/NodeList.
 * Optionally takes a query to filter the parent elements.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * @param {!String=} query               Optionala CSS selector.
 * @return {?}
 */
dojo.NodeList.prototype.parent = function(query) {};

/**
 * Returns all parent elements for nodes in this dojo/NodeList.
 * Optionally takes a query to filter the child elements.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * @param {!String=} query               Optionala CSS selector.
 * @return {?}
 */
dojo.NodeList.prototype.parents = function(query) {};

/**
 * places elements of this node list relative to the first element matched
 * by queryOrNode. Returns the original NodeList. See: dojo/dom-construct.place
 * 
 * places elements of this node list relative to the first element matched
 * by queryOrNode. Returns the original NodeList. See: dojo/dom-construct.place
 * 
 * @param {!String|!HTMLElement} queryOrNode may be a string representing any valid CSS3 selector or a DOM node.In the selector case, only the first matching element will be usedfor relative positioning.
 * @param {!String} position can be one of:"last" (default)"first""before""after""only""replace"or an offset in the childNodes property
 * @return {?}
 */
dojo.NodeList.prototype.place = function(queryOrNode, position) {};

/**
 * Returns border-box objects (x/y/w/h) of all elements in a node list
 * as an Array (not a NodeList). Acts like dojo/dom-geometry-position, though
 * assumes the node passed is each node in this list.
 * 
 * @return {?}
 */
dojo.NodeList.prototype.position = function() {};

/**
 * prepends the content to every node in the NodeList.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * prepends the content to every node in the NodeList.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * prepends the content to every node in the NodeList.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * @param {!String|!HTMLElement|!dojo.NodeList} content
 * @return {?}
 */
dojo.NodeList.prototype.prepend = function(content) {};

/**
 * prepends nodes in this NodeList to the nodes matched by
 * the query passed to prependTo.
 * The nodes in this NodeList will be cloned if the query
 * matches more than one element. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * @param {!String} query
 * @return {?}
 */
dojo.NodeList.prototype.prependTo = function(query) {};

/**
 * Returns the previous element for nodes in this dojo/NodeList.
 * Optionally takes a query to filter the previous elements.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * @param {!String=} query               Optionala CSS selector.
 * @return {?}
 */
dojo.NodeList.prototype.prev = function(query) {};

/**
 * Returns all sibling elements that come before the nodes in this dojo/NodeList.
 * Optionally takes a query to filter the sibling elements.
 * The returned nodes will be in reverse DOM order -- the first node in the list will
 * be the node closest to the original node/NodeList.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * @param {!String=} query               Optionala CSS selector.
 * @return {?}
 */
dojo.NodeList.prototype.prevAll = function(query) {};

/**
 * Returns a new list whose members match the passed query,
 * assuming elements of the current NodeList as the root for
 * each search.
 * 
 * @param {!String} queryStr
 * @return {?}
 */
dojo.NodeList.prototype.query = function(queryStr) {};

/**
 * removes elements in this list that match the filter
 * from their parents and returns them as a new NodeList.
 * 
 * @param {!String=} filter               OptionalCSS selector like ".foo" or "div > span"
 * @return {?}
 */
dojo.NodeList.prototype.remove = function(filter) {};

/**
 * Removes an attribute from each node in the list.
 * 
 * @param {!String} name the name of the attribute to remove
 * @return {void}
 */
dojo.NodeList.prototype.removeAttr = function(name) {};

/**
 * removes the specified class from every node in the list
 * 
 * removes the specified class from every node in the list
 * 
 * @param {!String|!Array<?>=} className               OptionalAn optional String class name to remove, or several space-separatedclass names, or an array of class names. If omitted, all class nameswill be deleted.
 * @return {?}
 */
dojo.NodeList.prototype.removeClass = function(className) {};

/**
 * Animate the effect of removing a class to all nodes in this list.
 * see dojox.fx.removeClass
 * 
 * @param {?} cssClass
 * @param {?} args
 * @return {{type: !Function, value: ?}}
 */
dojo.NodeList.prototype.removeClassFx = function(cssClass, args) {};

/**
 * Remove the data associated with these nodes.
 * 
 * @param {!String=} key               OptionalIf omitted, clean all data for this node.If passed, remove the data item found at key
 * @return {void}
 */
dojo.NodeList.prototype.removeData = function(key) {};

/**
 * replaces nodes matched by the query passed to replaceAll with the nodes
 * in this NodeList.
 * The nodes in this NodeList will be cloned if the query
 * matches more than one element. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * @param {!String} query
 * @return {?}
 */
dojo.NodeList.prototype.replaceAll = function(query) {};

/**
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling removeClass() and addClass()
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling removeClass() and addClass()
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling removeClass() and addClass()
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling removeClass() and addClass()
 * 
 * @param {!String|!Array<?>} addClassStr A String class name to add, or several space-separated class names,or an array of class names.
 * @param {!String|!Array<?>=} removeClassStr               OptionalA String class name to remove, or several space-separated class names,or an array of class names.
 * @return {void}
 */
dojo.NodeList.prototype.replaceClass = function(addClassStr, removeClassStr) {};

/**
 * Replaces each node in ths NodeList with the content passed to replaceWith.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * Replaces each node in ths NodeList with the content passed to replaceWith.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * Replaces each node in ths NodeList with the content passed to replaceWith.
 * The content will be cloned if the length of NodeList
 * is greater than 1. Only the DOM nodes are cloned, not
 * any attached event handlers.
 * 
 * @param {!String|!HTMLElement|!dojo.NodeList} content
 * @return {?}
 */
dojo.NodeList.prototype.replaceWith = function(content) {};

/**
 * Returns all sibling elements for nodes in this dojo/NodeList.
 * Optionally takes a query to filter the sibling elements.
 * .end() can be used on the returned dojo/NodeList to get back to the
 * original dojo/NodeList.
 * 
 * @param {!String=} query               Optionala CSS selector.
 * @return {?}
 */
dojo.NodeList.prototype.siblings = function(query) {};

/**
 * Returns a new NodeList, maintaining this one in place
 * This method behaves exactly like the Array.slice method
 * with the caveat that it returns a dojo/NodeList and not a
 * raw Array. For more details, see Mozilla's slice
 * documentation
 * 
 * @param {number} begin Can be a positive or negative integer, with positiveintegers noting the offset to begin at, and negativeintegers denoting an offset from the end (i.e., to the leftof the end)
 * @param {number=} end               OptionalOptional parameter to describe what position relative tothe NodeList's zero index to end the slice at. Like begin,can be positive or negative.
 * @return {?}
 */
dojo.NodeList.prototype.slice = function(begin, end) {};

/**
 * slide all elements of the node list to the specified place via dojo/fx.slideTo()
 * 
 * @param {!Object=} args               OptionalAdditional dojo/_base/fx.Animation arguments to mix into this set with the addition ofan auto parameter.
 * @return {?}
 */
dojo.NodeList.prototype.slideTo = function(args) {};

/**
 * Takes the same structure of arguments and returns as
 * dojo/_base/array.some() with the caveat that the passed array is
 * implicitly this NodeList.  See dojo/_base/array.some() and Mozilla's
 * Array.some
 * documentation.
 * 
 * @param {!Function} callback the callback
 * @param {!Object=} thisObject               Optionalthe context
 * @return {?}
 */
dojo.NodeList.prototype.some = function(callback, thisObject) {};

/**
 * Returns a new NodeList, manipulating this NodeList based on
 * the arguments passed, potentially splicing in new elements
 * at an offset, optionally deleting elements
 * This method behaves exactly like the Array.splice method
 * with the caveat that it returns a dojo/NodeList and not a
 * raw Array. For more details, see Mozilla's splice
 * documentation
 * For backwards compatibility, calling .end() on the spliced NodeList
 * does not return the original NodeList -- splice alters the NodeList in place.
 * 
 * @param {number} index begin can be a positive or negative integer, with positiveintegers noting the offset to begin at, and negativeintegers denoting an offset from the end (i.e., to the leftof the end)
 * @param {number=} howmany               OptionalOptional parameter to describe what position relative tothe NodeList's zero index to end the slice at. Like begin,can be positive or negative.
 * @param {!Array<!Object>=} item               OptionalAny number of optional parameters may be passed in to bespliced into the NodeList
 * @return {?}
 */
dojo.NodeList.prototype.splice = function(index, howmany, item) {};

/**
 * gets or sets the CSS property for every element in the NodeList
 * 
 * @param {!String} property the CSS property to get/set, in JavaScript notation("lineHieght" instead of "line-height")
 * @param {!String=} value               Optionaloptional. The value to set the property to
 * @return {?}
 */
dojo.NodeList.prototype.style = function(property, value) {};

/**
 * allows setting the text value of each node in the NodeList,
 * if there is a value passed in, otherwise, returns the text value for all the
 * nodes in the NodeList in one string.
 * 
 * @param {!String} value
 * @return {?}
 */
dojo.NodeList.prototype.text = function(value) {};

/**
 * Adds a class to node if not present, or removes if present.
 * Pass a boolean condition if you want to explicitly add or remove.
 * 
 * @param {!String} className the CSS class to add
 * @param {boolean=} condition               OptionalIf passed, true means to add the class, false means to remove.
 * @return {void}
 */
dojo.NodeList.prototype.toggleClass = function(className, condition) {};

/**
 * Animate the effect of adding or removing a class to all nodes in this list.
 * see dojox.fx.toggleClass
 * 
 * @param {?} cssClass
 * @param {?} force
 * @param {?} args
 * @return {{type: !Function, value: ?}}
 */
dojo.NodeList.prototype.toggleClassFx = function(cssClass, force, args) {};

/**
 *
 * @return {?}
 */
dojo.NodeList.prototype.toString = function() {};

/**
 * If a value is passed, allows seting the value property of form elements in this
 * NodeList, or properly selecting/checking the right value for radio/checkbox/select
 * elements. If no value is passed, the value of the first node in this NodeList
 * is returned.
 * 
 * If a value is passed, allows seting the value property of form elements in this
 * NodeList, or properly selecting/checking the right value for radio/checkbox/select
 * elements. If no value is passed, the value of the first node in this NodeList
 * is returned.
 * 
 * @param {!String|!Array<?>} value
 * @return {?}
 */
dojo.NodeList.prototype.val = function(value) {};

/**
 * wipe in all elements of this NodeList via dojo/fx.wipeIn()
 * 
 * @param {!Object=} args               OptionalAdditional dojo/_base/fx.Animation arguments to mix into this set with the addition ofan auto parameter.
 * @return {?}
 */
dojo.NodeList.prototype.wipeIn = function(args) {};

/**
 * wipe out all elements of this NodeList via dojo/fx.wipeOut()
 * 
 * @param {!Object=} args               OptionalAdditional dojo/_base/fx.Animation arguments to mix into this set with the addition ofan auto parameter.
 * @return {?}
 */
dojo.NodeList.prototype.wipeOut = function(args) {};

/**
 * Wrap each node in the NodeList with html passed to wrap.
 * html will be cloned if the NodeList has more than one
 * element. Only DOM nodes are cloned, not any attached
 * event handlers.
 * 
 * Wrap each node in the NodeList with html passed to wrap.
 * html will be cloned if the NodeList has more than one
 * element. Only DOM nodes are cloned, not any attached
 * event handlers.
 * 
 * @param {!String|!HTMLElement} html
 * @return {?}
 */
dojo.NodeList.prototype.wrap = function(html) {};

/**
 * Insert html where the first node in this NodeList lives, then place all
 * nodes in this NodeList as the child of the html.
 * 
 * Insert html where the first node in this NodeList lives, then place all
 * nodes in this NodeList as the child of the html.
 * 
 * @param {!String|!HTMLElement} html
 * @return {?}
 */
dojo.NodeList.prototype.wrapAll = function(html) {};

/**
 * For each node in the NodeList, wrap all its children with the passed in html.
 * html will be cloned if the NodeList has more than one
 * element. Only DOM nodes are cloned, not any attached
 * event handlers.
 * 
 * For each node in the NodeList, wrap all its children with the passed in html.
 * html will be cloned if the NodeList has more than one
 * element. Only DOM nodes are cloned, not any attached
 * event handlers.
 * 
 * @param {!String|!HTMLElement} html
 * @return {?}
 */
dojo.NodeList.prototype.wrapInner = function(html) {};
/**
 * @record
 * @struct
 */
dojo.NodeList._nodeDataCache = function() {};

/**
 * @constructor
 * @struct
 */
dojo.Stateful = function() {};
 /** @type {function(!IArguments): ?} */
dojo.Stateful.prototype.inherited;

/**
 * Get a property on a Stateful instance.
 * Get a named property on a Stateful object. The property may
 * potentially be retrieved via a getter method in subclasses. In the base class
 * this just retrieves the object's property.
 * 
 * @param {!String} name The property to get.
 * @return {?}
 */
dojo.Stateful.prototype.get = function(name) {};

/**
 *
 * @param {!Object=} params               Optional
 * @return {void}
 */
dojo.Stateful.prototype.postscript = function(params) {};

/**
 * Set a property on a Stateful instance
 * Sets named properties on a stateful object and notifies any watchers of
 * the property. A programmatic setter may be defined in subclasses.
 * 
 * @param {!String} name The property to set.
 * @param {!Object} value The value to set in the property.
 * @return {?}
 */
dojo.Stateful.prototype.set = function(name, value) {};

/**
 * Watches a property for changes
 * 
 * @param {string} property
 * @param {function(string, ?, ?): void} callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
 * @return {{unwatch: function(): void}}
 */
dojo.Stateful.prototype.watch = function(property, callback) {};
/** @const */
dojo._base = {};
/**
 * @record
 * @struct
 */
dojo._base.declare = function() {};

/* TODO: CallSignature: dojo._base */

/* TODO: CallSignature: dojo._base */

/**
 * Mix in properties skipping a constructor and decorating functions
 * like it is done by declare().
 * This function is used to mix in properties like lang.mixin does,
 * but it skips a constructor property and decorates functions like
 * declare() does.
 * 
 * It is meant to be used with classes and objects produced with
 * declare. Functions mixed in with dojo.safeMixin can use
 * this.inherited() like normal methods.
 * 
 * This function is used to implement extend() method of a constructor
 * produced with declare().
 * 
 * @param {!Object} target Target object to accept new properties.
 * @param {!Object} source Source object for new properties.
 * @return {!Object}
 */
dojo._base.declare.prototype.safeMixin = function(target, source) {};

/**
 * @constructor
 * @struct
 */
dojo._base.declare.__DeclareCreatedObject = function() {};

/**
 * Create a subclass of the declared class from a list of base classes.
 * Create a constructor using a compact notation for inheritance and
 * prototype extension.
 * 
 * Mixin ancestors provide a type of multiple inheritance.
 * Prototypes of mixin ancestors are copied to the new class:
 * changes to mixin prototypes will not affect classes to which
 * they have been mixed in.
 * 
 * @param {!Array<!Function>} mixins Specifies a list of bases (the left-most one is the most deepestbase).
 * @param {!Object=} props               OptionalAn optional object whose properties are copied to the created prototype.
 * @return {!dojo._base.declare.__DeclareCreatedObject}
 */
dojo._base.declare.__DeclareCreatedObject.prototype.createSubclass = function(mixins, props) {};

/**
 * Adds all properties and methods of source to constructor's
 * prototype, making them available to all instances created with
 * constructor. This method is specific to constructors created with
 * declare().
 * Adds source properties to the constructor's prototype. It can
 * override existing properties.
 * 
 * This method is similar to dojo.extend function, but it is specific
 * to constructors produced by declare(). It is implemented
 * using dojo.safeMixin, and it skips a constructor property,
 * and properly decorates copied functions.
 * 
 * @param {!Object} source Source object which properties are going to be copied to theconstructor's prototype.
 * @return {void}
 */
dojo._base.declare.__DeclareCreatedObject.prototype.extend = function(source) {};

/**
 * Returns a super method.
 * This method is a convenience method for "this.inherited()".
 * It uses the same algorithm but instead of executing a super
 * method, it returns it, or "undefined" if not found.
 * 
 * @param {!String=} name               OptionalThe optional method name. Should be the same as the caller'sname. Usually "name" is specified in complex dynamic cases, whenthe calling method was dynamically added, undecorated bydeclare(), and it cannot be determined.
 * @param {!Object=} args The caller supply this argument, which should be the original"arguments".
 * @return {?}
 */
dojo._base.declare.__DeclareCreatedObject.prototype.getInherited = function(name, args) {};

/**
 * Calls a super method.
 * This method is used inside method of classes produced with
 * declare() to call a super method (next in the chain). It is
 * used for manually controlled chaining. Consider using the regular
 * chaining, because it is faster. Use "this.inherited()" only in
 * complex cases.
 * 
 * This method cannot me called from automatically chained
 * constructors including the case of a special (legacy)
 * constructor chaining. It cannot be called from chained methods.
 * 
 * If "this.inherited()" cannot find the next-in-chain method, it
 * does nothing and returns "undefined". The last method in chain
 * can be a default method implemented in Object, which will be
 * called last.
 * 
 * If "name" is specified, it is assumed that the method that
 * received "args" is the parent method for this call. It is looked
 * up in the chain list and if it is found the next-in-chain method
 * is called. If it is not found, the first-in-chain method is
 * called.
 * 
 * If "name" is not specified, it will be derived from the calling
 * method (using a methoid property "nom").
 * 
 * @param {!String=} name               OptionalThe optional method name. Should be the same as the caller'sname. Usually "name" is specified in complex dynamic cases, whenthe calling method was dynamically added, undecorated bydeclare(), and it cannot be determined.
 * @param {!Object=} args The caller supply this argument, which should be the original"arguments".
 * @param {!Object=} newArgs               OptionalIf "true", the found function will be returned withoutexecuting it.If Array, it will be used to call a super method. Otherwise"args" will be used.
 * @return {?}
 */
dojo._base.declare.__DeclareCreatedObject.prototype.inherited = function(name, args, newArgs) {};

/**
 * Checks the inheritance chain to see if it is inherited from this
 * class.
 * This method is used with instances of classes produced with
 * declare() to determine of they support a certain interface or
 * not. It models "instanceof" operator.
 * 
 * @param {!Function} cls Class constructor.
 * @return {?}
 */
dojo._base.declare.__DeclareCreatedObject.prototype.isInstanceOf = function(cls) {};
/**
 * @record
 * @struct
 */
dojo._base.Deferred = function() {};

/* TODO: CallSignature: dojo._base */
 /** @type {number} */
dojo._base.Deferred.prototype.fired;
 /** @type {!Object} */
dojo._base.Deferred.prototype.promise;

/**
 * Add handler as both successful callback and error callback for this deferred instance.
 * 
 * @param {!Function} callback
 * @return {?}
 */
dojo._base.Deferred.prototype.addBoth = function(callback) {};

/**
 * Adds successful callback for this deferred instance.
 * 
 * @param {!Function} callback
 * @return {?}
 */
dojo._base.Deferred.prototype.addCallback = function(callback) {};

/**
 * Adds callback and error callback for this deferred instance.
 * 
 * @param {!Function=} callback               OptionalThe callback attached to this deferred object.
 * @param {!Function=} errback               OptionalThe error callback attached to this deferred object.
 * @return {?}
 */
dojo._base.Deferred.prototype.addCallbacks = function(callback, errback) {};

/**
 * Adds error callback for this deferred instance.
 * 
 * @param {!Function} errback
 * @return {?}
 */
dojo._base.Deferred.prototype.addErrback = function(errback) {};

/**
 * Fulfills the Deferred instance successfully with the provide value
 * 
 * @param {?} value
 * @return {void}
 */
dojo._base.Deferred.prototype.callback = function(value) {};

/**
 * Cancels the asynchronous operation
 * 
 * @return {void}
 */
dojo._base.Deferred.prototype.cancel = function() {};

/**
 * Fulfills the Deferred instance as an error with the provided error
 * 
 * @param {?} error
 * @return {void}
 */
dojo._base.Deferred.prototype.errback = function(error) {};

/**
 * Checks whether the deferred has been canceled.
 * 
 * @return {boolean}
 */
dojo._base.Deferred.prototype.isCanceled = function() {};

/**
 * Checks whether the deferred has been resolved or rejected.
 * 
 * @return {boolean}
 */
dojo._base.Deferred.prototype.isFulfilled = function() {};

/**
 * Checks whether the deferred has been rejected.
 * 
 * @return {boolean}
 */
dojo._base.Deferred.prototype.isRejected = function() {};

/**
 * Checks whether the deferred has been resolved.
 * 
 * @return {boolean}
 */
dojo._base.Deferred.prototype.isResolved = function() {};

/**
 * Send progress events to all listeners
 * 
 * @param {?} update
 * @return {void}
 */
dojo._base.Deferred.prototype.progress = function(update) {};

/**
 * Fulfills the Deferred instance as an error with the provided error
 * 
 * @param {?} error
 * @return {void}
 */
dojo._base.Deferred.prototype.reject = function(error) {};

/**
 * Fulfills the Deferred instance successfully with the provide value
 * 
 * @param {?} value
 * @return {void}
 */
dojo._base.Deferred.prototype.resolve = function(value) {};

/**
 * Adds a fulfilledHandler, errorHandler, and progressHandler to be called for
 * completion of a promise. The fulfilledHandler is called when the promise
 * is fulfilled. The errorHandler is called when a promise fails. The
 * progressHandler is called for progress events. All arguments are optional
 * and non-function values are ignored. The progressHandler is not only an
 * optional argument, but progress events are purely optional. Promise
 * providers are not required to ever create progress events.
 * 
 * This function will return a new promise that is fulfilled when the given
 * fulfilledHandler or errorHandler callback is finished. This allows promise
 * operations to be chained together. The value returned from the callback
 * handler is the fulfillment value for the returned promise. If the callback
 * throws an error, the returned promise will be moved to failed state.
 * 
 * @param {!Function=} resolvedCallback               Optional
 * @param {!Function=} errorCallback               Optional
 * @param {!Function=} progressCallback               Optional
 * @return {?}
 */
dojo._base.Deferred.prototype.then = function(resolvedCallback, errorCallback, progressCallback) {};

/**
 * Transparently applies callbacks to values and/or promises.
 * Accepts promises but also transparently handles non-promises. If no
 * callbacks are provided returns a promise, regardless of the initial
 * value. Foreign promises are converted.
 * 
 * If callbacks are provided and the initial value is not a promise,
 * the callback is executed immediately with no error handling. Returns
 * a promise if the initial value is a promise, or the result of the
 * callback otherwise.
 * 
 * @param {?=} valueOrPromise Either a regular value or an object with a then() method thatfollows the Promises/A specification.
 * @param {!Function=} callback               OptionalCallback to be invoked when the promise is resolved, or a non-promiseis received.
 * @param {!Function=} errback               OptionalCallback to be invoked when the promise is rejected.
 * @param {!Function=} progback               OptionalCallback to be invoked when the promise emits a progress update.
 * @return {?}
 */
dojo._base.Deferred.prototype.when = function(valueOrPromise, callback, errback, progback) {};
/**
 * @record
 * @struct
 */
dojo._base.url = function() {};

/* TODO: CallSignature: dojo._base */
 /** @type {!Object} */
dojo._base.url.prototype.authority;
 /** @type {!Object} */
dojo._base.url.prototype.fragment;
 /** @type {!Object} */
dojo._base.url.prototype.host;
 /** @type {!Object} */
dojo._base.url.prototype.password;
 /** @type {!Object} */
dojo._base.url.prototype.path;
 /** @type {!Object} */
dojo._base.url.prototype.port;
 /** @type {!Object} */
dojo._base.url.prototype.query;
 /** @type {!Object} */
dojo._base.url.prototype.scheme;
 /** @type {!Object} */
dojo._base.url.prototype.uri;
 /** @type {!Object} */
dojo._base.url.prototype.user;

/**
 *
 * @return {void}
 */
dojo._base.url.prototype.toString = function() {};
/**
 * @record
 * @struct
 */
dojo._base.url.authority = function() {};
/**
 * @record
 * @struct
 */
dojo._base.url.password = function() {};
/**
 * @record
 * @struct
 */
dojo._base.url.port = function() {};
/**
 * @record
 * @struct
 */
dojo._base.url.fragment = function() {};
/**
 * @record
 * @struct
 */
dojo._base.url.query = function() {};
/**
 * @record
 * @struct
 */
dojo._base.url.user = function() {};
/**
 * @record
 * @struct
 */
dojo._base.url.scheme = function() {};
/**
 * @record
 * @struct
 */
dojo._base.xhr = function() {};

/* TODO: CallSignature: dojo._base */
 /** @type {!Object} */
dojo._base.xhr.prototype.contentHandlers;

/**
 * Sends an HTTP DELETE request to the server.
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo._base.xhr.prototype.del = function(args) {};

/**
 * Serialize a form field to a JavaScript object.
 * Returns the value encoded in a form field as
 * as a string or an array of strings. Disabled form elements
 * and unchecked radio and checkboxes are skipped. Multi-select
 * elements are returned as an array of string values.
 * 
 * Serialize a form field to a JavaScript object.
 * Returns the value encoded in a form field as
 * as a string or an array of strings. Disabled form elements
 * and unchecked radio and checkboxes are skipped. Multi-select
 * elements are returned as an array of string values.
 * 
 * @param {!HTMLElement|!String} inputNode
 * @return {?}
 */
dojo._base.xhr.prototype.fieldToObject = function(inputNode) {};

/**
 * Create a serialized JSON string from a form node or string
 * ID identifying the form to serialize
 * 
 * Create a serialized JSON string from a form node or string
 * ID identifying the form to serialize
 * 
 * @param {!HTMLElement|!String} formNode
 * @param {boolean=} prettyPrint               Optional
 * @return {?}
 */
dojo._base.xhr.prototype.formToJson = function(formNode, prettyPrint) {};

/**
 * Serialize a form node to a JavaScript object.
 * Returns the values encoded in an HTML form as
 * string properties in an object which it then returns. Disabled form
 * elements, buttons, and other non-value form elements are skipped.
 * Multi-select elements are returned as an array of string values.
 * 
 * Serialize a form node to a JavaScript object.
 * Returns the values encoded in an HTML form as
 * string properties in an object which it then returns. Disabled form
 * elements, buttons, and other non-value form elements are skipped.
 * Multi-select elements are returned as an array of string values.
 * 
 * @param {!HTMLElement|!String} formNode
 * @return {!Object}
 */
dojo._base.xhr.prototype.formToObject = function(formNode) {};

/**
 * Returns a URL-encoded string representing the form passed as either a
 * node or string ID identifying the form to serialize
 * 
 * Returns a URL-encoded string representing the form passed as either a
 * node or string ID identifying the form to serialize
 * 
 * @param {!HTMLElement|!String} formNode
 * @return {?}
 */
dojo._base.xhr.prototype.formToQuery = function(formNode) {};

/**
 * Sends an HTTP GET request to the server.
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo._base.xhr.prototype.get = function(args) {};

/**
 * takes a name/value mapping object and returns a string representing
 * a URL-encoded version of that object.
 * 
 * @param {!Object} map
 * @return {?}
 */
dojo._base.xhr.prototype.objectToQuery = function(map) {};

/**
 * Sends an HTTP POST request to the server. In addition to the properties
 * listed for the dojo.__XhrArgs type, the following property is allowed:
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo._base.xhr.prototype.post = function(args) {};

/**
 * Sends an HTTP PUT request to the server. In addition to the properties
 * listed for the dojo.__XhrArgs type, the following property is allowed:
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo._base.xhr.prototype.put = function(args) {};

/**
 * Create an object representing a de-serialized query section of a
 * URL. Query keys with multiple values are returned in an array.
 * 
 * @param {!String} str
 * @return {!Object}
 */
dojo._base.xhr.prototype.queryToObject = function(str) {};
/**
 * @record
 * @struct
 */
dojo._base.xhr.contentHandlers = function() {};

/**
 *
 * @param {?} xhr
 * @return {void}
 */
dojo._base.xhr.contentHandlers.prototype.auto = function(xhr) {};

/**
 * A contentHandler which evaluates the response data, expecting it to be valid JavaScript
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.xhr.contentHandlers.prototype.javascript = function(xhr) {};

/**
 * A contentHandler which returns a JavaScript object created from the response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.xhr.contentHandlers.prototype.json = function(xhr) {};

/**
 * A contentHandler which expects comment-filtered JSON.
 * A contentHandler which expects comment-filtered JSON.
 * the json-comment-filtered option was implemented to prevent
 * "JavaScript Hijacking", but it is less secure than standard JSON. Use
 * standard JSON instead. JSON prefixing can be used to subvert hijacking.
 * 
 * Will throw a notice suggesting to use application/json mimetype, as
 * json-commenting can introduce security issues. To decrease the chances of hijacking,
 * use the standard json contentHandler, and prefix your "JSON" with: {}&&
 * 
 * use djConfig.useCommentedJson = true to turn off the notice
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.xhr.contentHandlers.prototype.json_comment_filtered = function(xhr) {};

/**
 * A contentHandler which checks the presence of comment-filtered JSON and
 * alternates between the json and json-comment-filtered contentHandlers.
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.xhr.contentHandlers.prototype.json_comment_optional = function(xhr) {};

/**
 *
 * @param {?} xhr
 * @return {void}
 */
dojo._base.xhr.contentHandlers.prototype.olson_zoneinfo = function(xhr) {};

/**
 * A contentHandler which simply returns the plaintext response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.xhr.contentHandlers.prototype.text = function(xhr) {};

/**
 * A contentHandler returning an XML Document parsed from the response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.xhr.contentHandlers.prototype.xml = function(xhr) {};

/**
 * @constructor
 * @struct
 */
dojo._base.config = function() {};

/* TODO: PropertyDeclaration: dojo._base."addOnLoad" */

/* TODO: PropertyDeclaration: dojo._base."afterOnLoad" */

/* TODO: PropertyDeclaration: dojo._base."baseUrl" */

/* TODO: PropertyDeclaration: dojo._base."callback" */

/* TODO: PropertyDeclaration: dojo._base."debugContainerId" */

/* TODO: PropertyDeclaration: dojo._base."debugHeight" */

/* TODO: PropertyDeclaration: dojo._base."defaultDuration" */

/* TODO: PropertyDeclaration: dojo._base."deferredInstrumentation" */

/* TODO: PropertyDeclaration: dojo._base."deps" */

/* TODO: PropertyDeclaration: dojo._base."dojoBlankHtmlUrl" */

/* TODO: PropertyDeclaration: dojo._base."extraLocale" */

/* TODO: PropertyDeclaration: dojo._base."ioPublish" */

/* TODO: PropertyDeclaration: dojo._base."isDebug" */

/* TODO: PropertyDeclaration: dojo._base."locale" */

/* TODO: PropertyDeclaration: dojo._base."modulePaths" */

/* TODO: PropertyDeclaration: dojo._base."parseOnLoad" */

/* TODO: PropertyDeclaration: dojo._base."require" */

/* TODO: PropertyDeclaration: dojo._base."transparentColor" */

/* TODO: PropertyDeclaration: dojo._base."urchin" */

/* TODO: PropertyDeclaration: dojo._base."useCustomLogger" */

/* TODO: PropertyDeclaration: dojo._base."useDeferredInstrumentation" */
/**
 * @record
 * @struct
 */
dojo._base.config.modulePaths = function() {};

/**
 * @constructor
 * @struct
 * @param {!Array<?>} color
 */
dojo._base.Color = function(color) {};

/* TODO: PropertyDeclaration: dojo._base."a" */

/* TODO: PropertyDeclaration: dojo._base."b" */

/* TODO: PropertyDeclaration: dojo._base."g" */

/* TODO: PropertyDeclaration: dojo._base."named" */

/* TODO: PropertyDeclaration: dojo._base."r" */

/**
 * Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
 * can reuse a previously allocated Color object for the result
 * 
 * @param {!dojo._base.Color} start
 * @param {!dojo._base.Color} end
 * @param {number} weight
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo._base.Color.prototype.blendColors = function(start, end, weight, obj) {};

/**
 * Builds a Color from a 3 or 4 element array, mapping each
 * element in sequence to the rgb(a) values of the color.
 * 
 * @param {!Array<?>} a
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo._base.Color.prototype.fromArray = function(a, obj) {};

/**
 * Converts a hex string with a '#' prefix to a color object.
 * Supports 12-bit #rgb shorthand. Optionally accepts a
 * Color object to update with the parsed value.
 * 
 * @param {!String} color
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo._base.Color.prototype.fromHex = function(color, obj) {};

/**
 * get rgb(a) array from css-style color declarations
 * this function can handle all 4 CSS3 Color Module formats: rgb,
 * rgba, hsl, hsla, including rgb(a) with percentage values.
 * 
 * @param {!String} color
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo._base.Color.prototype.fromRgb = function(color, obj) {};

/**
 * Parses str for a color value. Accepts hex, rgb, and rgba
 * style color values.
 * Acceptable input values for str may include arrays of any form
 * accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
 * rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
 * 10, 50)"
 * 
 * @param {!String} str
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo._base.Color.prototype.fromString = function(str, obj) {};

/**
 * creates a greyscale color with an optional alpha
 * 
 * @param {number} g
 * @param {number=} a               Optional
 * @return {void}
 */
dojo._base.Color.prototype.makeGrey = function(g, a) {};

/**
 * makes sure that the object has correct attributes
 * 
 * @return {void}
 */
dojo._base.Color.prototype.sanitize = function() {};

/**
 * Takes a named string, hex string, array of rgb or rgba values,
 * an object with r, g, b, and a properties, or another Color object
 * and sets this color instance to that value.
 * 
 * Takes a named string, hex string, array of rgb or rgba values,
 * an object with r, g, b, and a properties, or another Color object
 * and sets this color instance to that value.
 * 
 * Takes a named string, hex string, array of rgb or rgba values,
 * an object with r, g, b, and a properties, or another Color object
 * and sets this color instance to that value.
 * 
 * @param {!Array<?>|!String|!Object} color
 * @return {!Function}
 */
dojo._base.Color.prototype.setColor = function(color) {};

/**
 * Convert this Color to a CMY definition.
 * 
 * @return {!Object}
 */
dojo._base.Color.prototype.toCmy = function() {};

/**
 * Convert this Color to a CMYK definition.
 * 
 * @return {!Object}
 */
dojo._base.Color.prototype.toCmyk = function() {};

/**
 * Returns a css color string in rgb(a) representation
 * 
 * @param {boolean=} includeAlpha               Optional
 * @return {!String}
 */
dojo._base.Color.prototype.toCss = function(includeAlpha) {};

/**
 * Returns a CSS color string in hexadecimal representation
 * 
 * @return {!String}
 */
dojo._base.Color.prototype.toHex = function() {};

/**
 * Convert this Color to an HSL definition.
 * 
 * @return {!Object}
 */
dojo._base.Color.prototype.toHsl = function() {};

/**
 * Convert this Color to an HSV definition.
 * 
 * @return {!Object}
 */
dojo._base.Color.prototype.toHsv = function() {};

/**
 * Returns 3 component array of rgb values
 * 
 * @return {!Array<?>}
 */
dojo._base.Color.prototype.toRgb = function() {};

/**
 * Returns a 4 component array of rgba values from the color
 * represented by this object.
 * 
 * @return {!Array<?>}
 */
dojo._base.Color.prototype.toRgba = function() {};

/**
 * Returns a visual representation of the color
 * 
 * @return {?}
 */
dojo._base.Color.prototype.toString = function() {};
/**
 * @record
 * @struct
 */
dojo._base.Color.named = function() {};
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.aliceblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.antiquewhite;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.aqua;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.aquamarine;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.azure;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.beige;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.bisque;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.black;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.blanchedalmond;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.blue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.blueviolet;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.brown;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.burlywood;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.cadetblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.chartreuse;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.chocolate;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.coral;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.cornflowerblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.cornsilk;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.crimson;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.cyan;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkcyan;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkgoldenrod;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkgray;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkgreen;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkgrey;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkkhaki;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkmagenta;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkolivegreen;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkorange;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkorchid;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkred;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darksalmon;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkseagreen;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkslateblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkslategray;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkslategrey;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkturquoise;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.darkviolet;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.deeppink;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.deepskyblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.dimgray;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.dimgrey;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.dodgerblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.firebrick;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.floralwhite;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.forestgreen;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.fuchsia;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.gainsboro;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.ghostwhite;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.gold;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.goldenrod;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.gray;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.green;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.greenyellow;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.grey;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.honeydew;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.hotpink;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.indianred;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.indigo;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.ivory;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.khaki;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lavender;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lavenderblush;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lawngreen;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lemonchiffon;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightcoral;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightcyan;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightgoldenrodyellow;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightgray;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightgreen;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightgrey;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightpink;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightsalmon;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightseagreen;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightskyblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightslategray;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightslategrey;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightsteelblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lightyellow;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.lime;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.limegreen;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.linen;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.magenta;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.maroon;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.mediumaquamarine;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.mediumblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.mediumorchid;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.mediumpurple;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.mediumseagreen;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.mediumslateblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.mediumspringgreen;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.mediumturquoise;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.mediumvioletred;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.midnightblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.mintcream;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.mistyrose;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.moccasin;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.navajowhite;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.navy;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.oldlace;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.olive;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.olivedrab;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.orange;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.orangered;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.orchid;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.palegoldenrod;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.palegreen;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.paleturquoise;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.palevioletred;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.papayawhip;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.peachpuff;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.peru;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.pink;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.plum;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.powderblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.purple;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.red;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.rosybrown;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.royalblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.saddlebrown;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.salmon;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.sandybrown;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.seagreen;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.seashell;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.sienna;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.silver;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.skyblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.slateblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.slategray;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.slategrey;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.snow;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.springgreen;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.steelblue;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.tan;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.teal;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.thistle;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.tomato;
 /** @type {!Object} */
dojo._base.Color.named.prototype.transparent;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.turquoise;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.violet;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.wheat;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.white;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.whitesmoke;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.yellow;
 /** @type {!Array<?>} */
dojo._base.Color.named.prototype.yellowgreen;
/**
 * @record
 * @struct
 */
dojo._base.browser = function() {};
/**
 * @record
 * @struct
 */
dojo._base.array = function() {};

/**
 *
 * @return {void}
 */
dojo._base.array.prototype.clearCache = function() {};

/**
 * Determines whether or not every item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
 * 
 * Determines whether or not every item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
 * 
 * Determines whether or not every item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
 * 
 * Determines whether or not every item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
 * 
 * @param {!Array<?>|!String} arr the array to iterate on. If a string, operates on individual characters.
 * @param {!Function|!String} callback a function is invoked with three arguments: item, index,and array and returns true if the condition is met.
 * @param {!Object=} thisObject               Optionalmay be used to scope the call to callback
 * @return {boolean}
 */
dojo._base.array.prototype.every = function(arr, callback, thisObject) {};

/**
 * Returns a new Array with those items from arr that match the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
 * 
 * Returns a new Array with those items from arr that match the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
 * 
 * @param {!Array<?>} arr the array to iterate over.
 * @param {!Function|!String} callback a function that is invoked with three arguments (item,index, array). The return of this function is expected tobe a boolean which determines whether the passed-in itemwill be included in the returned array.
 * @param {!Object=} thisObject               Optionalmay be used to scope the call to callback
 * @return {!Array<?>}
 */
dojo._base.array.prototype.filter = function(arr, callback, thisObject) {};

/**
 * for every item in arr, callback is invoked. Return values are ignored.
 * If you want to break out of the loop, consider using array.every() or array.some().
 * forEach does not allow breaking out of the loop over the items in arr.
 * This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
 * 
 * for every item in arr, callback is invoked. Return values are ignored.
 * If you want to break out of the loop, consider using array.every() or array.some().
 * forEach does not allow breaking out of the loop over the items in arr.
 * This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
 * 
 * for every item in arr, callback is invoked. Return values are ignored.
 * If you want to break out of the loop, consider using array.every() or array.some().
 * forEach does not allow breaking out of the loop over the items in arr.
 * This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
 * 
 * for every item in arr, callback is invoked. Return values are ignored.
 * If you want to break out of the loop, consider using array.every() or array.some().
 * forEach does not allow breaking out of the loop over the items in arr.
 * This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
 * 
 * @param {!Array<?>|!String} arr
 * @param {!Function|!String} callback
 * @param {!Object=} thisObject               Optional
 * @return {void}
 */
dojo._base.array.prototype.forEach = function(arr, callback, thisObject) {};

/**
 * locates the first index of the provided value in the
 * passed array. If the value is not found, -1 is returned.
 * This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:
 * 
 * when run over sparse arrays, the Dojo function invokes the callback for every index
 * whereas JavaScript 1.6's indexOf skips the holes in the sparse array.
 * uses equality (==) rather than strict equality (===)
 * For details on this method, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf
 * 
 * @param {!Array<?>} arr
 * @param {!Object} value
 * @param {number=} fromIndex               Optional
 * @param {boolean=} findLast               OptionalMakes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.
 * @return {number}
 */
dojo._base.array.prototype.indexOf = function(arr, value, fromIndex, findLast) {};

/**
 * locates the last index of the provided value in the passed
 * array. If the value is not found, -1 is returned.
 * This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:
 * 
 * when run over sparse arrays, the Dojo function invokes the callback for every index
 * whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.
 * uses equality (==) rather than strict equality (===)
 * For details on this method, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf
 * 
 * @param {?} arr
 * @param {?} value
 * @param {number=} fromIndex               Optional
 * @return {number}
 */
dojo._base.array.prototype.lastIndexOf = function(arr, value, fromIndex) {};

/**
 * applies callback to each element of arr and returns
 * an Array with the results
 * This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
 * 
 * applies callback to each element of arr and returns
 * an Array with the results
 * This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
 * 
 * applies callback to each element of arr and returns
 * an Array with the results
 * This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
 * 
 * applies callback to each element of arr and returns
 * an Array with the results
 * This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
 * 
 * @param {!Array<?>|!String} arr the array to iterate on. If a string, operates onindividual characters.
 * @param {!Function|!String} callback a function is invoked with three arguments, (item, index,array),  and returns a value
 * @param {!Object=} thisObject               Optionalmay be used to scope the call to callback
 * @param {?=} Ctr
 * @return {!Array<?>}
 */
dojo._base.array.prototype.map = function(arr, callback, thisObject, Ctr) {};

/**
 * Determines whether or not any item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
 * 
 * Determines whether or not any item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
 * 
 * Determines whether or not any item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
 * 
 * Determines whether or not any item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
 * 
 * @param {!Array<?>|!String} arr the array to iterate over. If a string, operates on individual characters.
 * @param {!Function|!String} callback a function is invoked with three arguments: item, index,and array and returns true if the condition is met.
 * @param {!Object=} thisObject               Optionalmay be used to scope the call to callback
 * @return {boolean}
 */
dojo._base.array.prototype.some = function(arr, callback, thisObject) {};
/**
 * @record
 * @struct
 */
dojo._base.connect = function() {};

/**
 * dojo.connect is a deprecated event handling and delegation method in
 * Dojo. It allows one function to "listen in" on the execution of
 * any other, triggering the second whenever the first is called. Many
 * listeners may be attached to a function, and source functions may
 * be either regular function calls or DOM events.
 * Connects listeners to actions, so that after event fires, a
 * listener is called with the same arguments passed to the original
 * function.
 * 
 * Since dojo.connect allows the source of events to be either a
 * "regular" JavaScript function or a DOM event, it provides a uniform
 * interface for listening to all the types of events that an
 * application is likely to deal with though a single, unified
 * interface. DOM programmers may want to think of it as
 * "addEventListener for everything and anything".
 * 
 * When setting up a connection, the event parameter must be a
 * string that is the name of the method/event to be listened for. If
 * obj is null, kernel.global is assumed, meaning that connections
 * to global methods are supported but also that you may inadvertently
 * connect to a global by passing an incorrect object name or invalid
 * reference.
 * 
 * dojo.connect generally is forgiving. If you pass the name of a
 * function or method that does not yet exist on obj, connect will
 * not fail, but will instead set up a stub method. Similarly, null
 * arguments may simply be omitted such that fewer than 4 arguments
 * may be required to set up a connection See the examples for details.
 * 
 * The return value is a handle that is needed to
 * remove this connection with dojo.disconnect.
 * 
 * dojo.connect is a deprecated event handling and delegation method in
 * Dojo. It allows one function to "listen in" on the execution of
 * any other, triggering the second whenever the first is called. Many
 * listeners may be attached to a function, and source functions may
 * be either regular function calls or DOM events.
 * Connects listeners to actions, so that after event fires, a
 * listener is called with the same arguments passed to the original
 * function.
 * 
 * Since dojo.connect allows the source of events to be either a
 * "regular" JavaScript function or a DOM event, it provides a uniform
 * interface for listening to all the types of events that an
 * application is likely to deal with though a single, unified
 * interface. DOM programmers may want to think of it as
 * "addEventListener for everything and anything".
 * 
 * When setting up a connection, the event parameter must be a
 * string that is the name of the method/event to be listened for. If
 * obj is null, kernel.global is assumed, meaning that connections
 * to global methods are supported but also that you may inadvertently
 * connect to a global by passing an incorrect object name or invalid
 * reference.
 * 
 * dojo.connect generally is forgiving. If you pass the name of a
 * function or method that does not yet exist on obj, connect will
 * not fail, but will instead set up a stub method. Similarly, null
 * arguments may simply be omitted such that fewer than 4 arguments
 * may be required to set up a connection See the examples for details.
 * 
 * The return value is a handle that is needed to
 * remove this connection with dojo.disconnect.
 * 
 * dojo.connect is a deprecated event handling and delegation method in
 * Dojo. It allows one function to "listen in" on the execution of
 * any other, triggering the second whenever the first is called. Many
 * listeners may be attached to a function, and source functions may
 * be either regular function calls or DOM events.
 * Connects listeners to actions, so that after event fires, a
 * listener is called with the same arguments passed to the original
 * function.
 * 
 * Since dojo.connect allows the source of events to be either a
 * "regular" JavaScript function or a DOM event, it provides a uniform
 * interface for listening to all the types of events that an
 * application is likely to deal with though a single, unified
 * interface. DOM programmers may want to think of it as
 * "addEventListener for everything and anything".
 * 
 * When setting up a connection, the event parameter must be a
 * string that is the name of the method/event to be listened for. If
 * obj is null, kernel.global is assumed, meaning that connections
 * to global methods are supported but also that you may inadvertently
 * connect to a global by passing an incorrect object name or invalid
 * reference.
 * 
 * dojo.connect generally is forgiving. If you pass the name of a
 * function or method that does not yet exist on obj, connect will
 * not fail, but will instead set up a stub method. Similarly, null
 * arguments may simply be omitted such that fewer than 4 arguments
 * may be required to set up a connection See the examples for details.
 * 
 * The return value is a handle that is needed to
 * remove this connection with dojo.disconnect.
 * 
 * dojo.connect is a deprecated event handling and delegation method in
 * Dojo. It allows one function to "listen in" on the execution of
 * any other, triggering the second whenever the first is called. Many
 * listeners may be attached to a function, and source functions may
 * be either regular function calls or DOM events.
 * Connects listeners to actions, so that after event fires, a
 * listener is called with the same arguments passed to the original
 * function.
 * 
 * Since dojo.connect allows the source of events to be either a
 * "regular" JavaScript function or a DOM event, it provides a uniform
 * interface for listening to all the types of events that an
 * application is likely to deal with though a single, unified
 * interface. DOM programmers may want to think of it as
 * "addEventListener for everything and anything".
 * 
 * When setting up a connection, the event parameter must be a
 * string that is the name of the method/event to be listened for. If
 * obj is null, kernel.global is assumed, meaning that connections
 * to global methods are supported but also that you may inadvertently
 * connect to a global by passing an incorrect object name or invalid
 * reference.
 * 
 * dojo.connect generally is forgiving. If you pass the name of a
 * function or method that does not yet exist on obj, connect will
 * not fail, but will instead set up a stub method. Similarly, null
 * arguments may simply be omitted such that fewer than 4 arguments
 * may be required to set up a connection See the examples for details.
 * 
 * The return value is a handle that is needed to
 * remove this connection with dojo.disconnect.
 * 
 * @param {!Object} obj               OptionalThe source object for the event function.Defaults to kernel.global if null.If obj is a DOM node, the connection is delegatedto the DOM event manager (unless dontFix is true).
 * @param {!String} event String name of the event function in obj.I.e. identifies a property obj[event].
 * @param {!Object|?} context The object that method will receive as "this".If context is null and method is a function, then methodinherits the context of event.If method is a string then context must be the sourceobject object for method (context[method]). If context is null,kernel.global is used.
 * @param {!String|!Function} method A function reference, or name of a function in context.The function identified by method fires after event does.method receives the same arguments as the event.See context argument comments for information on method's scope.
 * @param {boolean=} dontFix               OptionalIf obj is a DOM node, set dontFix to true to prevent delegationof this connection to the DOM event manager.
 * @return {?}
 */
dojo._base.connect.prototype.connect = function(obj, event, context, method, dontFix) {};

/**
 * Ensure that every time obj.event() is called, a message is published
 * on the topic. Returns a handle which can be passed to
 * dojo.disconnect() to disable subsequent automatic publication on
 * the topic.
 * 
 * @param {!String} topic The name of the topic to publish.
 * @param {!Object} obj               OptionalThe source object for the event function. Defaults to kernel.globalif null.
 * @param {!String} event The name of the event function in obj.I.e. identifies a property obj[event].
 * @return {?}
 */
dojo._base.connect.prototype.connectPublisher = function(topic, obj, event) {};

/**
 * Remove a link created by dojo.connect.
 * Removes the connection between event and the method referenced by handle.
 * 
 * @param {!Object} handle the return value of the dojo.connect call that created the connection.
 * @return {void}
 */
dojo._base.connect.prototype.disconnect = function(handle) {};

/**
 * Checks an event for the copy key (meta on Mac, and ctrl anywhere else)
 * 
 * @param {!Event} e Event object to examine
 * @return {?}
 */
dojo._base.connect.prototype.isCopyKey = function(e) {};

/**
 * Invoke all listener method subscribed to topic.
 * 
 * @param {!String} topic The name of the topic to publish.
 * @param {!Array<?>=} args               OptionalAn array of arguments. The arguments will be appliedto each topic subscriber (as first class parameters, via apply).
 * @return {?}
 */
dojo._base.connect.prototype.publish = function(topic, args) {};

/**
 * Attach a listener to a named topic. The listener function is invoked whenever the
 * named topic is published (see: dojo.publish).
 * Returns a handle which is needed to unsubscribe this listener.
 * 
 * Attach a listener to a named topic. The listener function is invoked whenever the
 * named topic is published (see: dojo.publish).
 * Returns a handle which is needed to unsubscribe this listener.
 * 
 * @param {!String} topic The topic to which to subscribe.
 * @param {!Object=} context               OptionalScope in which method will be invoked, or null for default scope.
 * @param {!String|!Function=} method The name of a function in context, or a function reference. This is the function thatis invoked when topic is published.
 * @return {?}
 */
dojo._base.connect.prototype.subscribe = function(topic, context, method) {};

/**
 * Remove a topic listener.
 * 
 * @param {!Object} handle The handle returned from a call to subscribe.
 * @return {void}
 */
dojo._base.connect.prototype.unsubscribe = function(handle) {};
/**
 * @record
 * @struct
 */
dojo._base.event = function() {};

/**
 * normalizes properties on the event object including event
 * bubbling methods, keystroke normalization, and x/y positions
 * 
 * @param {!Event} evt native event object
 * @param {!HTMLElement} sender node to treat as "currentTarget"
 * @return {!Event}
 */
dojo._base.event.prototype.fix = function(evt, sender) {};

/**
 * prevents propagation and clobbers the default action of the
 * passed event
 * 
 * @param {!Event} evt The event object. If omitted, window.event is used on IE.
 * @return {void}
 */
dojo._base.event.prototype.stop = function(evt) {};
/**
 * @record
 * @struct
 */
dojo._base.html = function() {};
/**
 * @record
 * @struct
 */
dojo._base.json = function() {};
/** @const */
dojo._base.fx = {};
/**
 * @record
 * @struct
 */
dojo._base.fx.Animation = function() {};

/**
 * A simpler interface to animateProperty(), also returns
 * an instance of Animation but begins the animation
 * immediately, unlike nearly every other Dojo animation API.
 * Simpler (but somewhat less powerful) version
 * of animateProperty.  It uses defaults for many basic properties
 * and allows for positional parameters to be used in place of the
 * packed "property bag" which is used for other Dojo animation
 * methods.
 * 
 * The Animation object returned will be already playing, so
 * calling play() on it again is (usually) a no-op.
 * 
 * A simpler interface to animateProperty(), also returns
 * an instance of Animation but begins the animation
 * immediately, unlike nearly every other Dojo animation API.
 * Simpler (but somewhat less powerful) version
 * of animateProperty.  It uses defaults for many basic properties
 * and allows for positional parameters to be used in place of the
 * packed "property bag" which is used for other Dojo animation
 * methods.
 * 
 * The Animation object returned will be already playing, so
 * calling play() on it again is (usually) a no-op.
 * 
 * @param {!HTMLElement|!String} node a DOM node or the id of a node to animate CSS properties on
 * @param {!Object} properties
 * @param {number=} duration               OptionalThe number of milliseconds over which the animationshould run. Defaults to the global animation default duration(350ms).
 * @param {!Function=} easing               OptionalAn easing function over which to calculate accelerationand deceleration of the animation through its duration.A default easing algorithm is provided, but you mayplug in any you wish. A large selection of easing algorithmsare available in dojo/fx/easing.
 * @param {!Function=} onEnd               OptionalA function to be called when the animation finishesrunning.
 * @param {number=} delay               OptionalThe number of milliseconds to delay beginning theanimation by. The default is 0.
 * @return {?}
 */
dojo._base.fx.prototype.anim = function(node, properties, duration, easing, onEnd, delay) {};

/**
 * Returns an animation that will transition the properties of
 * node defined in args depending how they are defined in
 * args.properties
 * Foundation of most dojo/_base/fx
 * animations. It takes an object of "properties" corresponding to
 * style properties, and animates them in parallel over a set
 * duration.
 * 
 * @param {!Object=} args An object with the following properties:properties (Object, optional): A hash map of style properties to Objects describing the transition,such as the properties of _Line with an additional 'units' propertynode (DOMNode|String): The node referenced in the animationduration (Integer, optional): Duration of the animation in milliseconds.easing (Function, optional): An easing function.
 * @return {?}
 */
dojo._base.fx.prototype.animateProperty = function(args) {};

/**
 * Returns an animation that will fade node defined in 'args' from
 * its current opacity to fully opaque.
 * 
 * @param {!Object} args An object with the following properties:node (DOMNode|String): The node referenced in the animationduration (Integer, optional): Duration of the animation in milliseconds.easing (Function, optional): An easing function.
 * @return {?}
 */
dojo._base.fx.prototype.fadeIn = function(args) {};

/**
 * Returns an animation that will fade node defined in 'args'
 * from its current opacity to fully transparent.
 * 
 * @param {!Object} args An object with the following properties:node (DOMNode|String): The node referenced in the animationduration (Integer, optional): Duration of the animation in milliseconds.easing (Function, optional): An easing function.
 * @return {?}
 */
dojo._base.fx.prototype.fadeOut = function(args) {};
/**
 * @record
 * @struct
 */
dojo._base.query = function() {};
/**
 * @record
 * @struct
 */
dojo._base.NodeList = function() {};
/**
 * @record
 * @struct
 */
dojo._base.sniff = function() {};
/**
 * @record
 * @struct
 */
dojo._base.lang = function() {};

/**
 * Clones objects (including DOM nodes) and all children.
 * Warning: do not clone cyclic structures.
 * 
 * @param {?} src The object to clone
 * @return {?}
 */
dojo._base.lang.prototype.clone = function(src) {};

/**
 * Returns a new object which "looks" to obj for properties which it
 * does not have a value for. Optionally takes a bag of properties to
 * seed the returned object with initially.
 * This is a small implementation of the Boodman/Crockford delegation
 * pattern in JavaScript. An intermediate object constructor mediates
 * the prototype chain for the returned object, using it to delegate
 * down to obj for property lookup when object-local lookup fails.
 * This can be thought of similarly to ES4's "wrap", save that it does
 * not act on types but rather on pure objects.
 * 
 * @param {!Object} obj The object to delegate to for properties not found directly on thereturn object or in props.
 * @param {!Array<!Object>} props an object containing properties to assign to the returned object
 * @return {?}
 */
dojo._base.lang.prototype.delegate = function(obj, props) {};

/**
 * determine if an object supports a given method
 * useful for longer api chains where you have to test each object in
 * the chain. Useful for object and method detection.
 * 
 * @param {!String} name Path to an object, in the form "A.B.C".
 * @param {!Object=} obj               OptionalObject to use as root of path. Defaults to'dojo.global'. Null may be passed.
 * @return {boolean}
 */
dojo._base.lang.prototype.exists = function(name, obj) {};

/**
 * Adds all properties and methods of props to constructor's
 * prototype, making them available to all instances created with
 * constructor.
 * 
 * @param {!Object} ctor Target constructor to extend.
 * @param {!Object} props One or more objects to mix into ctor.prototype
 * @return {!Object}
 */
dojo._base.lang.prototype.extend = function(ctor, props) {};

/**
 * Get a property from a dot-separated string, such as "A.B.C"
 * Useful for longer api chains where you have to test each object in
 * the chain, or when you have an object reference in string format.
 * 
 * @param {!String} name Path to an property, in the form "A.B.C".
 * @param {boolean=} create               OptionalOptional. Defaults to false. If true, Objects will becreated at any point along the 'path' that is undefined.
 * @param {!Object=} context               OptionalOptional. Object to use as root of path. Defaults to'dojo.global'. Null may be passed.
 * @return {?}
 */
dojo._base.lang.prototype.getObject = function(name, create, context) {};

/**
 * Returns a function that will only ever execute in the a given scope.
 * This allows for easy use of object member functions
 * in callbacks and other places in which the "this" keyword may
 * otherwise not reference the expected scope.
 * Any number of default positional arguments may be passed as parameters
 * beyond "method".
 * Each of these values will be used to "placehold" (similar to curry)
 * for the hitched function.
 * 
 * Returns a function that will only ever execute in the a given scope.
 * This allows for easy use of object member functions
 * in callbacks and other places in which the "this" keyword may
 * otherwise not reference the expected scope.
 * Any number of default positional arguments may be passed as parameters
 * beyond "method".
 * Each of these values will be used to "placehold" (similar to curry)
 * for the hitched function.
 * 
 * @param {!Object} scope The scope to use when method executes. If method is a string,scope is also the object containing method.
 * @param {function(!Array<?>): ?|string} method A function to be hitched to scope, or the name of the method inscope to be hitched.
 * @param {...?} args
 * @return {?}
 */
dojo._base.lang.prototype.hitch = function(scope, method, args) {};

/**
 * Returns true if it is a built-in function or some other kind of
 * oddball that should report as a function but doesn't
 * 
 * @param {?} it
 * @return {?}
 */
dojo._base.lang.prototype.isAlien = function(it) {};

/**
 * Return true if it is an Array.
 * Does not work on Arrays created in other windows.
 * 
 * @param {?} it Item to test.
 * @return {?}
 */
dojo._base.lang.prototype.isArray = function(it) {};

/**
 * similar to isArray() but more permissive
 * Doesn't strongly test for "arrayness".  Instead, settles for "isn't
 * a string or number and has a length property". Arguments objects
 * and DOM collections will return true when passed to
 * isArrayLike(), but will return false when passed to
 * isArray().
 * 
 * @param {?} it Item to test.
 * @return {?}
 */
dojo._base.lang.prototype.isArrayLike = function(it) {};

/**
 * Return true if it is a Function
 * 
 * @param {?} it Item to test.
 * @return {boolean}
 */
dojo._base.lang.prototype.isFunction = function(it) {};

/**
 * Returns true if it is a JavaScript object (or an Array, a Function
 * or null)
 * 
 * @param {?} it Item to test.
 * @return {boolean}
 */
dojo._base.lang.prototype.isObject = function(it) {};

/**
 * Return true if it is a String
 * 
 * @param {?} it Item to test.
 * @return {boolean}
 */
dojo._base.lang.prototype.isString = function(it) {};

/**
 * Copies/adds all properties of one or more sources to dest; returns dest.
 * All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
 * found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
 * The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
 * executes a so-called "shallow copy" and aggregate types are copied/added by reference.
 * 
 * @template T, U, V, W
 * @param {T|!Object} dest The object to which to copy/add all properties contained in source. If dest is falsy, thena new object is manufactured before copying/adding properties begins.
 * @param {...U|!Object} source_or_source1_or_sources
 * @return {T|?}
 */
dojo._base.lang.prototype.mixin = function(dest, source_or_source1_or_sources) {};

/**
 * similar to hitch() except that the scope object is left to be
 * whatever the execution context eventually becomes.
 * Calling lang.partial is the functional equivalent of calling:
 * 
 * lang.hitch(null, funcName, ...);
 * 
 * similar to hitch() except that the scope object is left to be
 * whatever the execution context eventually becomes.
 * Calling lang.partial is the functional equivalent of calling:
 * 
 * lang.hitch(null, funcName, ...);
 * 
 * @param {!Function|!String} method The function to "wrap"
 * @return {?}
 */
dojo._base.lang.prototype.partial = function(method) {};

/**
 * Performs parameterized substitutions on a string. Throws an
 * exception if any parameter is unmatched.
 * 
 * Performs parameterized substitutions on a string. Throws an
 * exception if any parameter is unmatched.
 * 
 * @param {!String} tmpl String to be used as a template.
 * @param {!Object|!Function} map If an object, it is used as a dictionary to look up substitutions.If a function, it is called for every substitution with following parameters:a whole match, a name, an offset, and the whole templatestring (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replacefor more details).
 * @param {!RegExp=} pattern               OptionalOptional regular expression objects that overrides the default pattern.Must be global and match one item. The default is: /{([^}]+)}/g,which matches patterns like that: "{xxx}", where "xxx" is any sequenceof characters, which doesn't include "}".
 * @return {!String}
 */
dojo._base.lang.prototype.replace = function(tmpl, map, pattern) {};

/**
 * Set a property from a dot-separated string, such as "A.B.C"
 * Useful for longer api chains where you have to test each object in
 * the chain, or when you have an object reference in string format.
 * Objects are created as needed along path. Returns the passed
 * value if setting is successful or undefined if not.
 * 
 * @param {!String} name Path to a property, in the form "A.B.C".
 * @param {?} value value or object to place at location given by name
 * @param {!Object=} context               OptionalOptional. Object to use as root of path. Defaults todojo.global.
 * @return {?}
 */
dojo._base.lang.prototype.setObject = function(name, value, context) {};

/**
 * Trims whitespace from both sides of the string
 * This version of trim() was selected for inclusion into the base due
 * to its compact size and relatively good performance
 * (see Steven Levithan's blog
 * Uses String.prototype.trim instead, if available.
 * The fastest but longest version of this function is located at
 * lang.string.trim()
 * 
 * @param {!String} str String to be trimmed
 * @return {!String}
 */
dojo._base.lang.prototype.trim = function(str) {};
/**
 * @record
 * @struct
 */
dojo._base.unload = function() {};

/**
 * registers a function to be triggered when the page unloads.
 * The first time that addOnUnload is called Dojo will
 * register a page listener to trigger your unload handler
 * with.
 * 
 * In a browser environment, the functions will be triggered
 * during the window.onbeforeunload event. Be careful of doing
 * too much work in an unload handler. onbeforeunload can be
 * triggered if a link to download a file is clicked, or if
 * the link is a javascript: link. In these cases, the
 * onbeforeunload event fires, but the document is not
 * actually destroyed. So be careful about doing destructive
 * operations in a dojo.addOnUnload callback.
 * 
 * Further note that calling dojo.addOnUnload will prevent
 * browsers from using a "fast back" cache to make page
 * loading via back button instantaneous.
 * 
 * registers a function to be triggered when the page unloads.
 * The first time that addOnUnload is called Dojo will
 * register a page listener to trigger your unload handler
 * with.
 * 
 * In a browser environment, the functions will be triggered
 * during the window.onbeforeunload event. Be careful of doing
 * too much work in an unload handler. onbeforeunload can be
 * triggered if a link to download a file is clicked, or if
 * the link is a javascript: link. In these cases, the
 * onbeforeunload event fires, but the document is not
 * actually destroyed. So be careful about doing destructive
 * operations in a dojo.addOnUnload callback.
 * 
 * Further note that calling dojo.addOnUnload will prevent
 * browsers from using a "fast back" cache to make page
 * loading via back button instantaneous.
 * 
 * registers a function to be triggered when the page unloads.
 * The first time that addOnUnload is called Dojo will
 * register a page listener to trigger your unload handler
 * with.
 * 
 * In a browser environment, the functions will be triggered
 * during the window.onbeforeunload event. Be careful of doing
 * too much work in an unload handler. onbeforeunload can be
 * triggered if a link to download a file is clicked, or if
 * the link is a javascript: link. In these cases, the
 * onbeforeunload event fires, but the document is not
 * actually destroyed. So be careful about doing destructive
 * operations in a dojo.addOnUnload callback.
 * 
 * Further note that calling dojo.addOnUnload will prevent
 * browsers from using a "fast back" cache to make page
 * loading via back button instantaneous.
 * 
 * registers a function to be triggered when the page unloads.
 * The first time that addOnUnload is called Dojo will
 * register a page listener to trigger your unload handler
 * with.
 * 
 * In a browser environment, the functions will be triggered
 * during the window.onbeforeunload event. Be careful of doing
 * too much work in an unload handler. onbeforeunload can be
 * triggered if a link to download a file is clicked, or if
 * the link is a javascript: link. In these cases, the
 * onbeforeunload event fires, but the document is not
 * actually destroyed. So be careful about doing destructive
 * operations in a dojo.addOnUnload callback.
 * 
 * Further note that calling dojo.addOnUnload will prevent
 * browsers from using a "fast back" cache to make page
 * loading via back button instantaneous.
 * 
 * @param {!Object|!Function=} obj               Optional
 * @param {!String|!Function=} functionName               Optional
 * @return {void}
 */
dojo._base.unload.prototype.addOnUnload = function(obj, functionName) {};

/**
 * registers a function to be triggered when window.onunload
 * fires.
 * The first time that addOnWindowUnload is called Dojo
 * will register a page listener to trigger your unload
 * handler with. Note that registering these handlers may
 * destroy "fastback" page caching in browsers that support
 * it. Be careful trying to modify the DOM or access
 * JavaScript properties during this phase of page unloading:
 * they may not always be available. Consider
 * addOnUnload() if you need to modify the DOM or do
 * heavy JavaScript work since it fires at the equivalent of
 * the page's "onbeforeunload" event.
 * 
 * registers a function to be triggered when window.onunload
 * fires.
 * The first time that addOnWindowUnload is called Dojo
 * will register a page listener to trigger your unload
 * handler with. Note that registering these handlers may
 * destroy "fastback" page caching in browsers that support
 * it. Be careful trying to modify the DOM or access
 * JavaScript properties during this phase of page unloading:
 * they may not always be available. Consider
 * addOnUnload() if you need to modify the DOM or do
 * heavy JavaScript work since it fires at the equivalent of
 * the page's "onbeforeunload" event.
 * 
 * registers a function to be triggered when window.onunload
 * fires.
 * The first time that addOnWindowUnload is called Dojo
 * will register a page listener to trigger your unload
 * handler with. Note that registering these handlers may
 * destroy "fastback" page caching in browsers that support
 * it. Be careful trying to modify the DOM or access
 * JavaScript properties during this phase of page unloading:
 * they may not always be available. Consider
 * addOnUnload() if you need to modify the DOM or do
 * heavy JavaScript work since it fires at the equivalent of
 * the page's "onbeforeunload" event.
 * 
 * registers a function to be triggered when window.onunload
 * fires.
 * The first time that addOnWindowUnload is called Dojo
 * will register a page listener to trigger your unload
 * handler with. Note that registering these handlers may
 * destroy "fastback" page caching in browsers that support
 * it. Be careful trying to modify the DOM or access
 * JavaScript properties during this phase of page unloading:
 * they may not always be available. Consider
 * addOnUnload() if you need to modify the DOM or do
 * heavy JavaScript work since it fires at the equivalent of
 * the page's "onbeforeunload" event.
 * 
 * @param {!Object|!Function=} obj               Optional
 * @param {!String|!Function=} functionName               Optional
 * @return {void}
 */
dojo._base.unload.prototype.addOnWindowUnload = function(obj, functionName) {};
/**
 * @record
 * @struct
 */
dojo._base.window = function() {};
 /** @type {!Object} */
dojo._base.window.prototype.doc;
 /** @type {!Object} */
dojo._base.window.prototype.global;

/**
 * Return the body element of the specified document or of dojo/_base/window::doc.
 * 
 * @param {!HTMLDocument=} doc               Optional
 * @return {?}
 */
dojo._base.window.prototype.body = function(doc) {};

/**
 * changes the behavior of many core Dojo functions that deal with
 * namespace and DOM lookup, changing them to work in a new global
 * context (e.g., an iframe). The varibles dojo.global and dojo.doc
 * are modified as a result of calling this function and the result of
 * dojo.body() likewise differs.
 * 
 * @param {!Object} globalObject
 * @param {!HTMLDocument} globalDocument
 * @return {void}
 */
dojo._base.window.prototype.setContext = function(globalObject, globalDocument) {};

/**
 * Invoke callback with documentObject as dojo/_base/window::doc.
 * Invoke callback with documentObject as dojo/_base/window::doc. If provided,
 * callback will be executed in the context of object thisObject
 * When callback() returns or throws an error, the dojo/_base/window::doc will
 * be restored to its previous state.
 * 
 * @param {!HTMLDocument} documentObject
 * @param {!Function} callback
 * @param {!Object=} thisObject               Optional
 * @param {!Array<?>=} cbArguments               Optional
 * @return {?}
 */
dojo._base.window.prototype.withDoc = function(documentObject, callback, thisObject, cbArguments) {};

/**
 * Invoke callback with globalObject as dojo.global and
 * globalObject.document as dojo.doc.
 * Invoke callback with globalObject as dojo.global and
 * globalObject.document as dojo.doc. If provided, globalObject
 * will be executed in the context of object thisObject
 * When callback() returns or throws an error, the dojo.global
 * and dojo.doc will be restored to its previous state.
 * 
 * @param {!Object} globalObject
 * @param {!Function} callback
 * @param {!Object=} thisObject               Optional
 * @param {!Array<?>=} cbArguments               Optional
 * @return {?}
 */
dojo._base.window.prototype.withGlobal = function(globalObject, callback, thisObject, cbArguments) {};
/**
 * @record
 * @struct
 */
dojo._base.window.doc = function() {};
 /** @type {!Object} */
dojo._base.window.doc.prototype.documentElement;
 /** @type {boolean} */
dojo._base.window.doc.prototype.dojoClick;
/**
 * @record
 * @struct
 */
dojo._base.window.global = function() {};

/**
 *
 * @return {?}
 */
dojo._base.window.global.prototype.$ = function() {};

/**
 *
 * @param {?} start
 * @param {?} data
 * @param {?} responseCode
 * @param {?} errorMsg
 * @return {void}
 */
dojo._base.window.global.prototype.GoogleSearchStoreCallback_undefined_NaN = function(start, data, responseCode, errorMsg) {};

/**
 *
 * @return {?}
 */
dojo._base.window.global.prototype.jQuery = function() {};

/**
 *
 * @return {void}
 */
dojo._base.window.global.prototype.swfIsInHTML = function() {};

/**
 *
 * @return {void}
 */
dojo._base.window.global.prototype.undefined_onload = function() {};
/**
 * @record
 * @struct
 */
dojo._base.kernel = function() {};
 /** @type {!Object} */
dojo._base.kernel.prototype.back;
 /** @type {string} */
dojo._base.kernel.prototype.baseUrl;
 /** @type {!Object} */
dojo._base.kernel.prototype.behavior;
 /** @type {!Object} */
dojo._base.kernel.prototype.cldr;
 /** @type {!Object} */
dojo._base.kernel.prototype.colors;
 /** @type {!Object} */
dojo._base.kernel.prototype.config;
 /** @type {!Object} */
dojo._base.kernel.prototype.connectPublisher;
 /** @type {!Object} */
dojo._base.kernel.prototype.contentHandlers;
 /** @type {!Object} */
dojo._base.kernel.prototype.currency;
 /** @type {!Object} */
dojo._base.kernel.prototype.data;
 /** @type {!Object} */
dojo._base.kernel.prototype.date;
 /** @type {!Object} */
dojo._base.kernel.prototype.dijit;
 /** @type {!Object} */
dojo._base.kernel.prototype.dnd;
 /** @type {!Object} */
dojo._base.kernel.prototype.doc;
 /** @type {!Object} */
dojo._base.kernel.prototype.dojox;
 /** @type {!Object} */
dojo._base.kernel.prototype.fx;
 /** @type {!Object} */
dojo._base.kernel.prototype.gears;
 /** @type {!Object} */
dojo._base.kernel.prototype.global;
 /** @type {!Object} */
dojo._base.kernel.prototype.html;
 /** @type {!Object} */
dojo._base.kernel.prototype.i18n;
 /** @type {!Object} */
dojo._base.kernel.prototype.io;
 /** @type {boolean} */
dojo._base.kernel.prototype.isAir;
 /** @type {number} */
dojo._base.kernel.prototype.isAndroid;
 /** @type {boolean} */
dojo._base.kernel.prototype.isAsync;
 /** @type {boolean} */
dojo._base.kernel.prototype.isBrowser;
 /** @type {number} */
dojo._base.kernel.prototype.isChrome;
 /** @type {!Object} */
dojo._base.kernel.prototype.isCopyKey;
 /** @type {!Object} */
dojo._base.kernel.prototype.isFF;
 /** @type {number} */
dojo._base.kernel.prototype.isIE;
 /** @type {number} */
dojo._base.kernel.prototype.isIos;
 /** @type {number} */
dojo._base.kernel.prototype.isKhtml;
 /** @type {boolean} */
dojo._base.kernel.prototype.isMac;
 /** @type {!Object} */
dojo._base.kernel.prototype.isMoz;
 /** @type {!Object} */
dojo._base.kernel.prototype.isMozilla;
 /** @type {number} */
dojo._base.kernel.prototype.isOpera;
 /** @type {boolean} */
dojo._base.kernel.prototype.isQuirks;
 /** @type {number} */
dojo._base.kernel.prototype.isSafari;
 /** @type {boolean} */
dojo._base.kernel.prototype.isSpidermonkey;
 /** @type {number} */
dojo._base.kernel.prototype.isWebKit;
 /** @type {boolean} */
dojo._base.kernel.prototype.isWii;
 /** @type {!Object} */
dojo._base.kernel.prototype.keys;
 /** @type {!Object} */
dojo._base.kernel.prototype.locale;
 /** @type {!Object} */
dojo._base.kernel.prototype.mouseButtons;
 /** @type {!Object} */
dojo._base.kernel.prototype.number;
 /** @type {string} */
dojo._base.kernel.prototype.parser;
 /** @type {!Object} */
dojo._base.kernel.prototype.publish;
 /** @type {!Object} */
dojo._base.kernel.prototype.query;
 /** @type {!Object} */
dojo._base.kernel.prototype.regexp;
 /** @type {!Object} */
dojo._base.kernel.prototype.rpc;
 /** @type {!Object} */
dojo._base.kernel.prototype.scopeMap;
 /** @type {!Object} */
dojo._base.kernel.prototype.store;
 /** @type {!Object} */
dojo._base.kernel.prototype.string;
 /** @type {!Object} */
dojo._base.kernel.prototype.subscribe;
 /** @type {!Object} */
dojo._base.kernel.prototype.tests;
 /** @type {string} */
dojo._base.kernel.prototype.toJsonIndentStr;
 /** @type {!Object} */
dojo._base.kernel.prototype.touch;
 /** @type {!Object} */
dojo._base.kernel.prototype.version;
 /** @type {!Object} */
dojo._base.kernel.prototype.window;

/**
 * A registry to make contextual calling/searching easier.
 * Objects of this class keep list of arrays in the form [name, check,
 * wrap, directReturn] that are used to determine what the contextual
 * result of a set of checked arguments is. All check/wrap functions
 * in this registry should be of the same arity.
 * 
 * @param {boolean=} returnWrappers               Optional
 * @return {void}
 */
dojo._base.kernel.prototype.AdapterRegistry = function(returnWrappers) {};

/**
 * Adds the specified classes to the end of the class list on the
 * passed node. Will not re-apply duplicate classes.
 * 
 * Adds the specified classes to the end of the class list on the
 * passed node. Will not re-apply duplicate classes.
 * 
 * Adds the specified classes to the end of the class list on the
 * passed node. Will not re-apply duplicate classes.
 * 
 * Adds the specified classes to the end of the class list on the
 * passed node. Will not re-apply duplicate classes.
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to add a class string too
 * @param {!String|!Array<?>} classStr A String class name to add, or several space-separated class names,or an array of class names.
 * @return {void}
 */
dojo._base.kernel.prototype.addClass = function(node, classStr) {};

/**
 * Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
 * In most cases, the domReady plug-in should suffice and this method should not be needed.
 * 
 * When called in a non-browser environment, just checks that all requested modules have arrived and been
 * evaluated.
 * 
 * @param {number} priority               OptionalThe order in which to exec this callback relative to other callbacks, defaults to 1000
 * @param {?} context The context in which to run execute callback, or a callback if not using context
 * @param {!Function=} callback               OptionalThe function to execute.
 * @return {void}
 */
dojo._base.kernel.prototype.addOnLoad = function(priority, context, callback) {};

/**
 * registers a function to be triggered when the page unloads.
 * The first time that addOnUnload is called Dojo will
 * register a page listener to trigger your unload handler
 * with.
 * 
 * In a browser environment, the functions will be triggered
 * during the window.onbeforeunload event. Be careful of doing
 * too much work in an unload handler. onbeforeunload can be
 * triggered if a link to download a file is clicked, or if
 * the link is a javascript: link. In these cases, the
 * onbeforeunload event fires, but the document is not
 * actually destroyed. So be careful about doing destructive
 * operations in a dojo.addOnUnload callback.
 * 
 * Further note that calling dojo.addOnUnload will prevent
 * browsers from using a "fast back" cache to make page
 * loading via back button instantaneous.
 * 
 * registers a function to be triggered when the page unloads.
 * The first time that addOnUnload is called Dojo will
 * register a page listener to trigger your unload handler
 * with.
 * 
 * In a browser environment, the functions will be triggered
 * during the window.onbeforeunload event. Be careful of doing
 * too much work in an unload handler. onbeforeunload can be
 * triggered if a link to download a file is clicked, or if
 * the link is a javascript: link. In these cases, the
 * onbeforeunload event fires, but the document is not
 * actually destroyed. So be careful about doing destructive
 * operations in a dojo.addOnUnload callback.
 * 
 * Further note that calling dojo.addOnUnload will prevent
 * browsers from using a "fast back" cache to make page
 * loading via back button instantaneous.
 * 
 * registers a function to be triggered when the page unloads.
 * The first time that addOnUnload is called Dojo will
 * register a page listener to trigger your unload handler
 * with.
 * 
 * In a browser environment, the functions will be triggered
 * during the window.onbeforeunload event. Be careful of doing
 * too much work in an unload handler. onbeforeunload can be
 * triggered if a link to download a file is clicked, or if
 * the link is a javascript: link. In these cases, the
 * onbeforeunload event fires, but the document is not
 * actually destroyed. So be careful about doing destructive
 * operations in a dojo.addOnUnload callback.
 * 
 * Further note that calling dojo.addOnUnload will prevent
 * browsers from using a "fast back" cache to make page
 * loading via back button instantaneous.
 * 
 * registers a function to be triggered when the page unloads.
 * The first time that addOnUnload is called Dojo will
 * register a page listener to trigger your unload handler
 * with.
 * 
 * In a browser environment, the functions will be triggered
 * during the window.onbeforeunload event. Be careful of doing
 * too much work in an unload handler. onbeforeunload can be
 * triggered if a link to download a file is clicked, or if
 * the link is a javascript: link. In these cases, the
 * onbeforeunload event fires, but the document is not
 * actually destroyed. So be careful about doing destructive
 * operations in a dojo.addOnUnload callback.
 * 
 * Further note that calling dojo.addOnUnload will prevent
 * browsers from using a "fast back" cache to make page
 * loading via back button instantaneous.
 * 
 * @param {!Object|!Function=} obj               Optional
 * @param {!String|!Function=} functionName               Optional
 * @return {void}
 */
dojo._base.kernel.prototype.addOnUnload = function(obj, functionName) {};

/**
 * registers a function to be triggered when window.onunload fires.
 * Be careful trying to modify the DOM or access JavaScript properties
 * during this phase of page unloading: they may not always be available.
 * Consider dojo.addOnUnload() if you need to modify the DOM or do heavy
 * JavaScript work.
 * 
 * registers a function to be triggered when window.onunload fires.
 * Be careful trying to modify the DOM or access JavaScript properties
 * during this phase of page unloading: they may not always be available.
 * Consider dojo.addOnUnload() if you need to modify the DOM or do heavy
 * JavaScript work.
 * 
 * @param {!Object=} obj               Optional
 * @param {!String|!Function=} functionName               Optional
 * @return {void}
 */
dojo._base.kernel.prototype.addOnWindowUnload = function(obj, functionName) {};

/**
 * A simpler interface to animateProperty(), also returns
 * an instance of Animation but begins the animation
 * immediately, unlike nearly every other Dojo animation API.
 * Simpler (but somewhat less powerful) version
 * of animateProperty.  It uses defaults for many basic properties
 * and allows for positional parameters to be used in place of the
 * packed "property bag" which is used for other Dojo animation
 * methods.
 * 
 * The Animation object returned will be already playing, so
 * calling play() on it again is (usually) a no-op.
 * 
 * A simpler interface to animateProperty(), also returns
 * an instance of Animation but begins the animation
 * immediately, unlike nearly every other Dojo animation API.
 * Simpler (but somewhat less powerful) version
 * of animateProperty.  It uses defaults for many basic properties
 * and allows for positional parameters to be used in place of the
 * packed "property bag" which is used for other Dojo animation
 * methods.
 * 
 * The Animation object returned will be already playing, so
 * calling play() on it again is (usually) a no-op.
 * 
 * @param {!HTMLElement|!String} node a DOM node or the id of a node to animate CSS properties on
 * @param {!Object} properties
 * @param {number=} duration               OptionalThe number of milliseconds over which the animationshould run. Defaults to the global animation default duration(350ms).
 * @param {!Function=} easing               OptionalAn easing function over which to calculate accelerationand deceleration of the animation through its duration.A default easing algorithm is provided, but you mayplug in any you wish. A large selection of easing algorithmsare available in dojo/fx/easing.
 * @param {!Function=} onEnd               OptionalA function to be called when the animation finishesrunning.
 * @param {number=} delay               OptionalThe number of milliseconds to delay beginning theanimation by. The default is 0.
 * @return {?}
 */
dojo._base.kernel.prototype.anim = function(node, properties, duration, easing, onEnd, delay) {};

/**
 * Returns an animation that will transition the properties of
 * node defined in args depending how they are defined in
 * args.properties
 * Foundation of most dojo/_base/fx
 * animations. It takes an object of "properties" corresponding to
 * style properties, and animates them in parallel over a set
 * duration.
 * 
 * @param {!Object} args An object with the following properties:properties (Object, optional): A hash map of style properties to Objects describing the transition,such as the properties of _Line with an additional 'units' propertynode (DOMNode|String): The node referenced in the animationduration (Integer, optional): Duration of the animation in milliseconds.easing (Function, optional): An easing function.
 * @return {?}
 */
dojo._base.kernel.prototype.animateProperty = function(args) {};

/**
 * A generic animation class that fires callbacks into its handlers
 * object at various states.
 * A generic animation class that fires callbacks into its handlers
 * object at various states. Nearly all dojo animation functions
 * return an instance of this method, usually without calling the
 * .play() method beforehand. Therefore, you will likely need to
 * call .play() on instances of Animation when one is
 * returned.
 * 
 * @param {!Object} args The 'magic argument', mixing all the properties into thisanimation instance.
 * @return {void}
 */
dojo._base.kernel.prototype.Animation = function(args) {};

/**
 * Gets or sets an attribute on an HTML element.
 * Handles normalized getting and setting of attributes on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Gets or sets an attribute on an HTML element.
 * Handles normalized getting and setting of attributes on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Gets or sets an attribute on an HTML element.
 * Handles normalized getting and setting of attributes on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Gets or sets an attribute on an HTML element.
 * Handles normalized getting and setting of attributes on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to get or set the attribute on
 * @param {!String|!Object} name the name of the attribute to get or set.
 * @param {!String=} value               OptionalThe value to set for the attribute
 * @return {?}
 */
dojo._base.kernel.prototype.attr = function(node, name, value) {};

/**
 * Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
 * can reuse a previously allocated Color object for the result
 * 
 * @param {!dojo._base.Color} start
 * @param {!dojo._base.Color} end
 * @param {number} weight
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo._base.kernel.prototype.blendColors = function(start, end, weight, obj) {};

/**
 * Return the body element of the specified document or of dojo/_base/window::doc.
 * 
 * @param {!HTMLDocument=} doc               Optional
 * @return {?}
 */
dojo._base.kernel.prototype.body = function(doc) {};

/**
 * Returns DOM node with matching id attribute or falsy value (ex: null or undefined)
 * if not found.  If id is a DomNode, this function is a no-op.
 * 
 * Returns DOM node with matching id attribute or falsy value (ex: null or undefined)
 * if not found.  If id is a DomNode, this function is a no-op.
 * 
 * @param {!String|!HTMLElement} id A string to match an HTML id attribute or a reference to a DOM Node
 * @param {!HTMLDocument=} doc               OptionalDocument to work in. Defaults to the current value ofdojo/_base/window.doc.  Can be used to retrievenode references from other documents.
 * @return {?}
 */
dojo._base.kernel.prototype.byId = function(id, doc) {};

/**
 * A getter and setter for storing the string content associated with the
 * module and url arguments.
 * If module is a string that contains slashes, then it is interpretted as a fully
 * resolved path (typically a result returned by require.toUrl), and url should not be
 * provided. This is the preferred signature. If module is a string that does not
 * contain slashes, then url must also be provided and module and url are used to
 * call dojo.moduleUrl() to generate a module URL. This signature is deprecated.
 * If value is specified, the cache value for the moduleUrl will be set to
 * that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
 * in its internal cache and return that cached value for the URL. To clear
 * a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
 * the URL contents, only modules on the same domain of the page can use this capability.
 * The build system can inline the cache values though, to allow for xdomain hosting.
 * 
 * A getter and setter for storing the string content associated with the
 * module and url arguments.
 * If module is a string that contains slashes, then it is interpretted as a fully
 * resolved path (typically a result returned by require.toUrl), and url should not be
 * provided. This is the preferred signature. If module is a string that does not
 * contain slashes, then url must also be provided and module and url are used to
 * call dojo.moduleUrl() to generate a module URL. This signature is deprecated.
 * If value is specified, the cache value for the moduleUrl will be set to
 * that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
 * in its internal cache and return that cached value for the URL. To clear
 * a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
 * the URL contents, only modules on the same domain of the page can use this capability.
 * The build system can inline the cache values though, to allow for xdomain hosting.
 * 
 * A getter and setter for storing the string content associated with the
 * module and url arguments.
 * If module is a string that contains slashes, then it is interpretted as a fully
 * resolved path (typically a result returned by require.toUrl), and url should not be
 * provided. This is the preferred signature. If module is a string that does not
 * contain slashes, then url must also be provided and module and url are used to
 * call dojo.moduleUrl() to generate a module URL. This signature is deprecated.
 * If value is specified, the cache value for the moduleUrl will be set to
 * that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
 * in its internal cache and return that cached value for the URL. To clear
 * a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
 * the URL contents, only modules on the same domain of the page can use this capability.
 * The build system can inline the cache values though, to allow for xdomain hosting.
 * 
 * A getter and setter for storing the string content associated with the
 * module and url arguments.
 * If module is a string that contains slashes, then it is interpretted as a fully
 * resolved path (typically a result returned by require.toUrl), and url should not be
 * provided. This is the preferred signature. If module is a string that does not
 * contain slashes, then url must also be provided and module and url are used to
 * call dojo.moduleUrl() to generate a module URL. This signature is deprecated.
 * If value is specified, the cache value for the moduleUrl will be set to
 * that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
 * in its internal cache and return that cached value for the URL. To clear
 * a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
 * the URL contents, only modules on the same domain of the page can use this capability.
 * The build system can inline the cache values though, to allow for xdomain hosting.
 * 
 * @param {!String|!Object} module dojo/cldr/supplemental
 * @param {!String} url The rest of the path to append to the path derived from the module argument. Ifmodule is an object, then this second argument should be the "value" argument instead.
 * @param {!String|!Object=} value               OptionalIf a String, the value to use in the cache for the module/url combination.If an Object, it can have two properties: value and sanitize. The value propertyshould be the value to use in the cache, and sanitize can be set to true or false,to indicate if XML declarations should be removed from the value and if the HTMLinside a body tag in the value should be extracted as the real value. The value argumentor the value property on the value argument are usually only used by the build systemas it inlines cache content.
 * @return {?}
 */
dojo._base.kernel.prototype.cache = function(module, url, value) {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.prototype.clearCache = function() {};

/**
 * Takes a named string, hex string, array of rgb or rgba values,
 * an object with r, g, b, and a properties, or another Color object
 * and creates a new Color instance to work from.
 * 
 * Takes a named string, hex string, array of rgb or rgba values,
 * an object with r, g, b, and a properties, or another Color object
 * and creates a new Color instance to work from.
 * 
 * Takes a named string, hex string, array of rgb or rgba values,
 * an object with r, g, b, and a properties, or another Color object
 * and creates a new Color instance to work from.
 * 
 * @param {!Array<?>|!String|!Object} color
 * @return {void}
 */
dojo._base.kernel.prototype.Color = function(color) {};

/**
 * Builds a Color from a 3 or 4 element array, mapping each
 * element in sequence to the rgb(a) values of the color.
 * 
 * @param {!Array<?>} a
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo._base.kernel.prototype.colorFromArray = function(a, obj) {};

/**
 * Converts a hex string with a '#' prefix to a color object.
 * Supports 12-bit #rgb shorthand. Optionally accepts a
 * Color object to update with the parsed value.
 * 
 * @param {!String} color
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo._base.kernel.prototype.colorFromHex = function(color, obj) {};

/**
 * get rgb(a) array from css-style color declarations
 * this function can handle all 4 CSS3 Color Module formats: rgb,
 * rgba, hsl, hsla, including rgb(a) with percentage values.
 * 
 * @param {!String} color
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo._base.kernel.prototype.colorFromRgb = function(color, obj) {};

/**
 * Parses str for a color value. Accepts hex, rgb, and rgba
 * style color values.
 * Acceptable input values for str may include arrays of any form
 * accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
 * rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
 * 10, 50)"
 * 
 * @param {!String} str
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo._base.kernel.prototype.colorFromString = function(str, obj) {};

/**
 * dojo.connect is a deprecated event handling and delegation method in
 * Dojo. It allows one function to "listen in" on the execution of
 * any other, triggering the second whenever the first is called. Many
 * listeners may be attached to a function, and source functions may
 * be either regular function calls or DOM events.
 * Connects listeners to actions, so that after event fires, a
 * listener is called with the same arguments passed to the original
 * function.
 * 
 * Since dojo.connect allows the source of events to be either a
 * "regular" JavaScript function or a DOM event, it provides a uniform
 * interface for listening to all the types of events that an
 * application is likely to deal with though a single, unified
 * interface. DOM programmers may want to think of it as
 * "addEventListener for everything and anything".
 * 
 * When setting up a connection, the event parameter must be a
 * string that is the name of the method/event to be listened for. If
 * obj is null, kernel.global is assumed, meaning that connections
 * to global methods are supported but also that you may inadvertently
 * connect to a global by passing an incorrect object name or invalid
 * reference.
 * 
 * dojo.connect generally is forgiving. If you pass the name of a
 * function or method that does not yet exist on obj, connect will
 * not fail, but will instead set up a stub method. Similarly, null
 * arguments may simply be omitted such that fewer than 4 arguments
 * may be required to set up a connection See the examples for details.
 * 
 * The return value is a handle that is needed to
 * remove this connection with dojo.disconnect.
 * 
 * dojo.connect is a deprecated event handling and delegation method in
 * Dojo. It allows one function to "listen in" on the execution of
 * any other, triggering the second whenever the first is called. Many
 * listeners may be attached to a function, and source functions may
 * be either regular function calls or DOM events.
 * Connects listeners to actions, so that after event fires, a
 * listener is called with the same arguments passed to the original
 * function.
 * 
 * Since dojo.connect allows the source of events to be either a
 * "regular" JavaScript function or a DOM event, it provides a uniform
 * interface for listening to all the types of events that an
 * application is likely to deal with though a single, unified
 * interface. DOM programmers may want to think of it as
 * "addEventListener for everything and anything".
 * 
 * When setting up a connection, the event parameter must be a
 * string that is the name of the method/event to be listened for. If
 * obj is null, kernel.global is assumed, meaning that connections
 * to global methods are supported but also that you may inadvertently
 * connect to a global by passing an incorrect object name or invalid
 * reference.
 * 
 * dojo.connect generally is forgiving. If you pass the name of a
 * function or method that does not yet exist on obj, connect will
 * not fail, but will instead set up a stub method. Similarly, null
 * arguments may simply be omitted such that fewer than 4 arguments
 * may be required to set up a connection See the examples for details.
 * 
 * The return value is a handle that is needed to
 * remove this connection with dojo.disconnect.
 * 
 * dojo.connect is a deprecated event handling and delegation method in
 * Dojo. It allows one function to "listen in" on the execution of
 * any other, triggering the second whenever the first is called. Many
 * listeners may be attached to a function, and source functions may
 * be either regular function calls or DOM events.
 * Connects listeners to actions, so that after event fires, a
 * listener is called with the same arguments passed to the original
 * function.
 * 
 * Since dojo.connect allows the source of events to be either a
 * "regular" JavaScript function or a DOM event, it provides a uniform
 * interface for listening to all the types of events that an
 * application is likely to deal with though a single, unified
 * interface. DOM programmers may want to think of it as
 * "addEventListener for everything and anything".
 * 
 * When setting up a connection, the event parameter must be a
 * string that is the name of the method/event to be listened for. If
 * obj is null, kernel.global is assumed, meaning that connections
 * to global methods are supported but also that you may inadvertently
 * connect to a global by passing an incorrect object name or invalid
 * reference.
 * 
 * dojo.connect generally is forgiving. If you pass the name of a
 * function or method that does not yet exist on obj, connect will
 * not fail, but will instead set up a stub method. Similarly, null
 * arguments may simply be omitted such that fewer than 4 arguments
 * may be required to set up a connection See the examples for details.
 * 
 * The return value is a handle that is needed to
 * remove this connection with dojo.disconnect.
 * 
 * dojo.connect is a deprecated event handling and delegation method in
 * Dojo. It allows one function to "listen in" on the execution of
 * any other, triggering the second whenever the first is called. Many
 * listeners may be attached to a function, and source functions may
 * be either regular function calls or DOM events.
 * Connects listeners to actions, so that after event fires, a
 * listener is called with the same arguments passed to the original
 * function.
 * 
 * Since dojo.connect allows the source of events to be either a
 * "regular" JavaScript function or a DOM event, it provides a uniform
 * interface for listening to all the types of events that an
 * application is likely to deal with though a single, unified
 * interface. DOM programmers may want to think of it as
 * "addEventListener for everything and anything".
 * 
 * When setting up a connection, the event parameter must be a
 * string that is the name of the method/event to be listened for. If
 * obj is null, kernel.global is assumed, meaning that connections
 * to global methods are supported but also that you may inadvertently
 * connect to a global by passing an incorrect object name or invalid
 * reference.
 * 
 * dojo.connect generally is forgiving. If you pass the name of a
 * function or method that does not yet exist on obj, connect will
 * not fail, but will instead set up a stub method. Similarly, null
 * arguments may simply be omitted such that fewer than 4 arguments
 * may be required to set up a connection See the examples for details.
 * 
 * The return value is a handle that is needed to
 * remove this connection with dojo.disconnect.
 * 
 * @param {!Object} obj               OptionalThe source object for the event function.Defaults to kernel.global if null.If obj is a DOM node, the connection is delegatedto the DOM event manager (unless dontFix is true).
 * @param {!String} event String name of the event function in obj.I.e. identifies a property obj[event].
 * @param {!Object|?} context The object that method will receive as "this".If context is null and method is a function, then methodinherits the context of event.If method is a string then context must be the sourceobject object for method (context[method]). If context is null,kernel.global is used.
 * @param {!String|!Function} method A function reference, or name of a function in context.The function identified by method fires after event does.method receives the same arguments as the event.See context argument comments for information on method's scope.
 * @param {boolean=} dontFix               OptionalIf obj is a DOM node, set dontFix to true to prevent delegationof this connection to the DOM event manager.
 * @return {?}
 */
dojo._base.kernel.prototype.connect = function(obj, event, context, method, dontFix) {};

/**
 * Getter/setter for the content-box of node.
 * Returns an object in the expected format of box (regardless if box is passed).
 * The object might look like:
 * { l: 50, t: 200, w: 300: h: 150 }
 * for a node offset from its parent 50px to the left, 200px from
 * the top with a content width of 300px and a content-height of
 * 150px. Note that the content box may have a much larger border
 * or margin box, depending on the box model currently in use and
 * CSS values set/inherited for node.
 * While the getter will return top and left values, the
 * setter only accepts setting the width and height.
 * 
 * Getter/setter for the content-box of node.
 * Returns an object in the expected format of box (regardless if box is passed).
 * The object might look like:
 * { l: 50, t: 200, w: 300: h: 150 }
 * for a node offset from its parent 50px to the left, 200px from
 * the top with a content width of 300px and a content-height of
 * 150px. Note that the content box may have a much larger border
 * or margin box, depending on the box model currently in use and
 * CSS values set/inherited for node.
 * While the getter will return top and left values, the
 * setter only accepts setting the width and height.
 * 
 * @param {!HTMLElement|!String} node id or reference to DOM Node to get/set box for
 * @param {!Object=} box               OptionalIf passed, denotes that dojo.contentBox() shouldupdate/set the content box for node. Box is an object in theabove format, but only w (width) and h (height) are supported.All properties are optional if passed.
 * @return {?}
 */
dojo._base.kernel.prototype.contentBox = function(node, box) {};

/**
 * Get or set a cookie.
 * If one argument is passed, returns the value of the cookie
 * For two or more arguments, acts as a setter.
 * 
 * @param {!String} name Name of the cookie
 * @param {!String=} value               OptionalValue for the cookie
 * @param {!Object=} props               OptionalProperties for the cookie
 * @return {?}
 */
dojo._base.kernel.prototype.cookie = function(name, value, props) {};

/**
 * Deprecated: Use position() for border-box x/y/w/h
 * or marginBox() for margin-box w/h/l/t.
 * 
 * Returns an object that measures margin-box (w)idth/(h)eight
 * and absolute position x/y of the border-box. Also returned
 * is computed (l)eft and (t)op values in pixels from the
 * node's offsetParent as returned from marginBox().
 * Return value will be in the form:
 * 
 * { l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }
 * Does not act as a setter. If includeScroll is passed, the x and
 * 
 * y params are affected as one would expect in dojo.position().
 * 
 * Deprecated: Use position() for border-box x/y/w/h
 * or marginBox() for margin-box w/h/l/t.
 * 
 * Returns an object that measures margin-box (w)idth/(h)eight
 * and absolute position x/y of the border-box. Also returned
 * is computed (l)eft and (t)op values in pixels from the
 * node's offsetParent as returned from marginBox().
 * Return value will be in the form:
 * 
 * { l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }
 * Does not act as a setter. If includeScroll is passed, the x and
 * 
 * y params are affected as one would expect in dojo.position().
 * 
 * @param {!HTMLElement|!String} node
 * @param {boolean=} includeScroll               Optional
 * @return {?}
 */
dojo._base.kernel.prototype.coords = function(node, includeScroll) {};

/**
 * Create an element, allowing for optional attribute decoration
 * and placement.
 * A DOM Element creation function. A shorthand method for creating a node or
 * a fragment, and allowing for a convenient optional attribute setting step,
 * as well as an optional DOM placement reference.
 * 
 * Attributes are set by passing the optional object through dojo.setAttr.
 * See dojo.setAttr for noted caveats and nuances, and API if applicable.
 * 
 * Placement is done via dojo.place, assuming the new node to be the action
 * node, passing along the optional reference node and position.
 * 
 * Create an element, allowing for optional attribute decoration
 * and placement.
 * A DOM Element creation function. A shorthand method for creating a node or
 * a fragment, and allowing for a convenient optional attribute setting step,
 * as well as an optional DOM placement reference.
 * 
 * Attributes are set by passing the optional object through dojo.setAttr.
 * See dojo.setAttr for noted caveats and nuances, and API if applicable.
 * 
 * Placement is done via dojo.place, assuming the new node to be the action
 * node, passing along the optional reference node and position.
 * 
 * Create an element, allowing for optional attribute decoration
 * and placement.
 * A DOM Element creation function. A shorthand method for creating a node or
 * a fragment, and allowing for a convenient optional attribute setting step,
 * as well as an optional DOM placement reference.
 * 
 * Attributes are set by passing the optional object through dojo.setAttr.
 * See dojo.setAttr for noted caveats and nuances, and API if applicable.
 * 
 * Placement is done via dojo.place, assuming the new node to be the action
 * node, passing along the optional reference node and position.
 * 
 * Create an element, allowing for optional attribute decoration
 * and placement.
 * A DOM Element creation function. A shorthand method for creating a node or
 * a fragment, and allowing for a convenient optional attribute setting step,
 * as well as an optional DOM placement reference.
 * 
 * Attributes are set by passing the optional object through dojo.setAttr.
 * See dojo.setAttr for noted caveats and nuances, and API if applicable.
 * 
 * Placement is done via dojo.place, assuming the new node to be the action
 * node, passing along the optional reference node and position.
 * 
 * @param {!HTMLElement|!String} tag A string of the element to create (eg: "div", "a", "p", "li", "script", "br"),or an existing DOM node to process.
 * @param {!Object} attrs An object-hash of attributes to set on the newly created node.Can be null, if you don't want to set any attributes/styles.See: dojo.setAttr for a description of available attributes.
 * @param {!HTMLElement|!String=} refNode               OptionalOptional reference node. Used by dojo.place to place the newly creatednode somewhere in the dom relative to refNode. Can be a DomNode referenceor String ID of a node.
 * @param {!String=} pos               OptionalOptional positional reference. Defaults to "last" by way of dojo.place,though can be set to "first","after","before","last", "replace" or "only"to further control the placement of the new node relative to the refNode.'refNode' is required if a 'pos' is specified.
 * @return {?}
 */
dojo._base.kernel.prototype.create = function(tag, attrs, refNode, pos) {};

/**
 * Create a feature-rich constructor from compact notation.
 * Create a constructor using a compact notation for inheritance and
 * prototype extension.
 * 
 * Mixin ancestors provide a type of multiple inheritance.
 * Prototypes of mixin ancestors are copied to the new class:
 * changes to mixin prototypes will not affect classes to which
 * they have been mixed in.
 * 
 * Ancestors can be compound classes created by this version of
 * declare(). In complex cases all base classes are going to be
 * linearized according to C3 MRO algorithm
 * (see http://www.python.org/download/releases/2.3/mro/ for more
 * details).
 * 
 * "className" is cached in "declaredClass" property of the new class,
 * if it was supplied. The immediate super class will be cached in
 * "superclass" property of the new class.
 * 
 * Methods in "props" will be copied and modified: "nom" property
 * (the declared name of the method) will be added to all copied
 * functions to help identify them for the internal machinery. Be
 * very careful, while reusing methods: if you use the same
 * function under different names, it can produce errors in some
 * cases.
 * 
 * It is possible to use constructors created "manually" (without
 * declare()) as bases. They will be called as usual during the
 * creation of an instance, their methods will be chained, and even
 * called by "this.inherited()".
 * 
 * Special property "-chains-" governs how to chain methods. It is
 * a dictionary, which uses method names as keys, and hint strings
 * as values. If a hint string is "after", this method will be
 * called after methods of its base classes. If a hint string is
 * "before", this method will be called before methods of its base
 * classes.
 * 
 * If "constructor" is not mentioned in "-chains-" property, it will
 * be chained using the legacy mode: using "after" chaining,
 * calling preamble() method before each constructor, if available,
 * and calling postscript() after all constructors were executed.
 * If the hint is "after", it is chained as a regular method, but
 * postscript() will be called after the chain of constructors.
 * "constructor" cannot be chained "before", but it allows
 * a special hint string: "manual", which means that constructors
 * are not going to be chained in any way, and programmer will call
 * them manually using this.inherited(). In the latter case
 * postscript() will be called after the construction.
 * 
 * All chaining hints are "inherited" from base classes and
 * potentially can be overridden. Be very careful when overriding
 * hints! Make sure that all chained methods can work in a proposed
 * manner of chaining.
 * 
 * Once a method was chained, it is impossible to unchain it. The
 * only exception is "constructor". You don't need to define a
 * method in order to supply a chaining hint.
 * 
 * If a method is chained, it cannot use this.inherited() because
 * all other methods in the hierarchy will be called automatically.
 * 
 * Usually constructors and initializers of any kind are chained
 * using "after" and destructors of any kind are chained as
 * "before". Note that chaining assumes that chained methods do not
 * return any value: any returned value will be discarded.
 * 
 * Create a feature-rich constructor from compact notation.
 * Create a constructor using a compact notation for inheritance and
 * prototype extension.
 * 
 * Mixin ancestors provide a type of multiple inheritance.
 * Prototypes of mixin ancestors are copied to the new class:
 * changes to mixin prototypes will not affect classes to which
 * they have been mixed in.
 * 
 * Ancestors can be compound classes created by this version of
 * declare(). In complex cases all base classes are going to be
 * linearized according to C3 MRO algorithm
 * (see http://www.python.org/download/releases/2.3/mro/ for more
 * details).
 * 
 * "className" is cached in "declaredClass" property of the new class,
 * if it was supplied. The immediate super class will be cached in
 * "superclass" property of the new class.
 * 
 * Methods in "props" will be copied and modified: "nom" property
 * (the declared name of the method) will be added to all copied
 * functions to help identify them for the internal machinery. Be
 * very careful, while reusing methods: if you use the same
 * function under different names, it can produce errors in some
 * cases.
 * 
 * It is possible to use constructors created "manually" (without
 * declare()) as bases. They will be called as usual during the
 * creation of an instance, their methods will be chained, and even
 * called by "this.inherited()".
 * 
 * Special property "-chains-" governs how to chain methods. It is
 * a dictionary, which uses method names as keys, and hint strings
 * as values. If a hint string is "after", this method will be
 * called after methods of its base classes. If a hint string is
 * "before", this method will be called before methods of its base
 * classes.
 * 
 * If "constructor" is not mentioned in "-chains-" property, it will
 * be chained using the legacy mode: using "after" chaining,
 * calling preamble() method before each constructor, if available,
 * and calling postscript() after all constructors were executed.
 * If the hint is "after", it is chained as a regular method, but
 * postscript() will be called after the chain of constructors.
 * "constructor" cannot be chained "before", but it allows
 * a special hint string: "manual", which means that constructors
 * are not going to be chained in any way, and programmer will call
 * them manually using this.inherited(). In the latter case
 * postscript() will be called after the construction.
 * 
 * All chaining hints are "inherited" from base classes and
 * potentially can be overridden. Be very careful when overriding
 * hints! Make sure that all chained methods can work in a proposed
 * manner of chaining.
 * 
 * Once a method was chained, it is impossible to unchain it. The
 * only exception is "constructor". You don't need to define a
 * method in order to supply a chaining hint.
 * 
 * If a method is chained, it cannot use this.inherited() because
 * all other methods in the hierarchy will be called automatically.
 * 
 * Usually constructors and initializers of any kind are chained
 * using "after" and destructors of any kind are chained as
 * "before". Note that chaining assumes that chained methods do not
 * return any value: any returned value will be discarded.
 * 
 * @param {!String} className               OptionalThe optional name of the constructor (loosely, a "class")stored in the "declaredClass" property in the created prototype.It will be used as a global name for a created constructor.
 * @param {!Function|!Array<!Function>} superclass May be null, a Function, or an Array of Functions. This argumentspecifies a list of bases (the left-most one is the most deepestbase).
 * @param {!Object} props An object whose properties are copied to the created prototype.Add an instance-initialization function by making it a propertynamed "constructor".
 * @return {!dojo._base.declare.__DeclareCreatedObject}
 */
dojo._base.kernel.prototype.declare = function(className, superclass, props) {};

/**
 * Deprecated.   This module defines the legacy dojo/_base/Deferred API.
 * New code should use dojo/Deferred instead.
 * The Deferred API is based on the concept of promises that provide a
 * generic interface into the eventual completion of an asynchronous action.
 * The motivation for promises fundamentally is about creating a
 * separation of concerns that allows one to achieve the same type of
 * call patterns and logical data flow in asynchronous code as can be
 * achieved in synchronous code. Promises allows one
 * to be able to call a function purely with arguments needed for
 * execution, without conflating the call with concerns of whether it is
 * sync or async. One shouldn't need to alter a call's arguments if the
 * implementation switches from sync to async (or vice versa). By having
 * async functions return promises, the concerns of making the call are
 * separated from the concerns of asynchronous interaction (which are
 * handled by the promise).
 * 
 * The Deferred is a type of promise that provides methods for fulfilling the
 * promise with a successful result or an error. The most important method for
 * working with Dojo's promises is the then() method, which follows the
 * CommonJS proposed promise API. An example of using a Dojo promise:
 * 
 * var resultingPromise = someAsyncOperation.then(function(result){
 *     ... handle result ...
 * },
 * function(error){
 *     ... handle error ...
 * });
 * The .then() call returns a new promise that represents the result of the
 * execution of the callback. The callbacks will never affect the original promises value.
 * 
 * The Deferred instances also provide the following functions for backwards compatibility:
 * 
 * addCallback(handler)
 * addErrback(handler)
 * callback(result)
 * errback(result)
 * Callbacks are allowed to return promises themselves, so
 * you can build complicated sequences of events with ease.
 * 
 * The creator of the Deferred may specify a canceller.  The canceller
 * is a function that will be called if Deferred.cancel is called
 * before the Deferred fires. You can use this to implement clean
 * aborting of an XMLHttpRequest, etc. Note that cancel will fire the
 * deferred with a CancelledError (unless your canceller returns
 * another kind of error), so the errbacks should be prepared to
 * handle that error for cancellable Deferreds.
 * 
 * @param {!Function} canceller               Optional
 * @return {void}
 */
dojo._base.kernel.prototype.Deferred = function(canceller) {};

/**
 * Deprecated, use dojo/promise/all instead.
 * Provides event handling for a group of Deferred objects.
 * DeferredList takes an array of existing deferreds and returns a new deferred of its own
 * this new deferred will typically have its callback fired when all of the deferreds in
 * the given list have fired their own deferreds.  The parameters fireOnOneCallback and
 * fireOnOneErrback, will fire before all the deferreds as appropriate
 * 
 * @param {!Array<?>} list The list of deferreds to be synchronizied with this DeferredList
 * @param {boolean=} fireOnOneCallback               OptionalWill cause the DeferredLists callback to be fired as soon as anyof the deferreds in its list have been fired instead of waiting untilthe entire list has finished
 * @param {boolean=} fireOnOneErrback               Optional
 * @param {boolean=} consumeErrors               Optional
 * @param {!Function=} canceller               OptionalA deferred canceller function, see dojo.Deferred
 * @return {void}
 */
dojo._base.kernel.prototype.DeferredList = function(list, fireOnOneCallback, fireOnOneErrback, consumeErrors, canceller) {};

/**
 * Log a debug message to indicate that a behavior has been
 * deprecated.
 * 
 * @param {!String} behaviour The API or behavior being deprecated. Usually in the formof "myApp.someFunction()".
 * @param {!String=} extra               OptionalText to append to the message. Often provides advice on anew function or facility to achieve the same goal duringthe deprecation period.
 * @param {!String=} removal               OptionalText to indicate when in the future the behavior will beremoved. Usually a version number.
 * @return {void}
 */
dojo._base.kernel.prototype.deprecated = function(behaviour, extra, removal) {};

/**
 *
 * @param {?} node
 * @return {void}
 */
dojo._base.kernel.prototype.destroy = function(node) {};

/**
 * Remove a link created by dojo.connect.
 * Removes the connection between event and the method referenced by handle.
 * 
 * @param {!Object} handle the return value of the dojo.connect call that created the connection.
 * @return {void}
 */
dojo._base.kernel.prototype.disconnect = function(handle) {};

/**
 * Returns an object with {node, x, y} with corresponding offsets.
 * 
 * @param {!HTMLDocument=} doc               OptionalOptional document to query.   If unspecified, use win.doc.
 * @return {!Object}
 */
dojo._base.kernel.prototype.docScroll = function(doc) {};

/**
 *
 * @param {?} node
 * @return {void}
 */
dojo._base.kernel.prototype.empty = function(node) {};

/**
 * A legacy method created for use exclusively by internal Dojo methods. Do not use this method
 * directly unless you understand its possibly-different implications on the platforms your are targeting.
 * Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
 * that support indirect eval.
 * 
 * As usual, IE does not. On IE, the only way to implement global eval is to
 * use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
 * This implementation uses the technique of executing eval in the scope of a function that is a single scope
 * frame below the global scope; thereby coming close to the global scope. Note carefully that
 * 
 * dojo.eval("var pi = 3.14;");
 * 
 * will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
 * to define a global variable using dojo.eval, write something like
 * 
 * dojo.eval("window.pi = 3.14;")
 * 
 * @param {?} scriptText The text to evaluation.
 * @return {?}
 */
dojo._base.kernel.prototype.eval = function(scriptText) {};

/**
 * Determines whether or not every item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
 * 
 * Determines whether or not every item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
 * 
 * Determines whether or not every item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
 * 
 * Determines whether or not every item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
 * 
 * @param {!Array<?>|!String} arr the array to iterate on. If a string, operates on individual characters.
 * @param {!Function|!String} callback a function is invoked with three arguments: item, index,and array and returns true if the condition is met.
 * @param {!Object=} thisObject               Optionalmay be used to scope the call to callback
 * @return {boolean}
 */
dojo._base.kernel.prototype.every = function(arr, callback, thisObject) {};

/**
 *
 * @param {?} exitcode
 * @return {void}
 */
dojo._base.kernel.prototype.exit = function(exitcode) {};

/**
 * Marks code as experimental.
 * This can be used to mark a function, file, or module as
 * experimental.    Experimental code is not ready to be used, and the
 * APIs are subject to change without notice.  Experimental code may be
 * completed deleted without going through the normal deprecation
 * process.
 * 
 * @param {!String} moduleName The name of a module, or the name of a module file or a specificfunction
 * @param {!String=} extra               Optionalsome additional message for the user
 * @return {void}
 */
dojo._base.kernel.prototype.experimental = function(moduleName, extra) {};

/**
 * Returns an animation that will fade node defined in 'args' from
 * its current opacity to fully opaque.
 * 
 * @param {!Object} args An object with the following properties:node (DOMNode|String): The node referenced in the animationduration (Integer, optional): Duration of the animation in milliseconds.easing (Function, optional): An easing function.
 * @return {?}
 */
dojo._base.kernel.prototype.fadeIn = function(args) {};

/**
 * Returns an animation that will fade node defined in 'args'
 * from its current opacity to fully transparent.
 * 
 * @param {!Object} args An object with the following properties:node (DOMNode|String): The node referenced in the animationduration (Integer, optional): Duration of the animation in milliseconds.easing (Function, optional): An easing function.
 * @return {?}
 */
dojo._base.kernel.prototype.fadeOut = function(args) {};

/**
 * Serialize a form field to a JavaScript object.
 * Returns the value encoded in a form field as
 * as a string or an array of strings. Disabled form elements
 * and unchecked radio and checkboxes are skipped. Multi-select
 * elements are returned as an array of string values.
 * 
 * Serialize a form field to a JavaScript object.
 * Returns the value encoded in a form field as
 * as a string or an array of strings. Disabled form elements
 * and unchecked radio and checkboxes are skipped. Multi-select
 * elements are returned as an array of string values.
 * 
 * @param {!HTMLElement|!String} inputNode
 * @return {!Object}
 */
dojo._base.kernel.prototype.fieldToObject = function(inputNode) {};

/**
 * Returns a new Array with those items from arr that match the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
 * 
 * Returns a new Array with those items from arr that match the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
 * 
 * @param {!Array<?>} arr the array to iterate over.
 * @param {!Function|!String} callback a function that is invoked with three arguments (item,index, array). The return of this function is expected tobe a boolean which determines whether the passed-in itemwill be included in the returned array.
 * @param {!Object=} thisObject               Optionalmay be used to scope the call to callback
 * @return {!Array<?>}
 */
dojo._base.kernel.prototype.filter = function(arr, callback, thisObject) {};

/**
 * normalizes properties on the event object including event
 * bubbling methods, keystroke normalization, and x/y positions
 * 
 * @param {!Event} evt native event object
 * @param {!HTMLElement} sender node to treat as "currentTarget"
 * @return {!Event}
 */
dojo._base.kernel.prototype.fixEvent = function(evt, sender) {};

/**
 * In RTL direction, scrollLeft should be a negative value, but IE
 * returns a positive one. All codes using documentElement.scrollLeft
 * must call this function to fix this error, otherwise the position
 * will offset to right when there is a horizontal scrollbar.
 * 
 * @param {number} scrollLeft
 * @param {!HTMLDocument=} doc               OptionalOptional document to query.   If unspecified, use win.doc.
 * @return {number}
 */
dojo._base.kernel.prototype.fixIeBiDiScrollLeft = function(scrollLeft, doc) {};

/**
 * for every item in arr, callback is invoked. Return values are ignored.
 * If you want to break out of the loop, consider using array.every() or array.some().
 * forEach does not allow breaking out of the loop over the items in arr.
 * This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
 * 
 * for every item in arr, callback is invoked. Return values are ignored.
 * If you want to break out of the loop, consider using array.every() or array.some().
 * forEach does not allow breaking out of the loop over the items in arr.
 * This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
 * 
 * for every item in arr, callback is invoked. Return values are ignored.
 * If you want to break out of the loop, consider using array.every() or array.some().
 * forEach does not allow breaking out of the loop over the items in arr.
 * This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
 * 
 * for every item in arr, callback is invoked. Return values are ignored.
 * If you want to break out of the loop, consider using array.every() or array.some().
 * forEach does not allow breaking out of the loop over the items in arr.
 * This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
 * 
 * @param {!Array<?>|!String} arr
 * @param {!Function|!String} callback
 * @param {!Object=} thisObject               Optional
 * @return {void}
 */
dojo._base.kernel.prototype.forEach = function(arr, callback, thisObject) {};

/**
 * Create a serialized JSON string from a form node or string
 * ID identifying the form to serialize
 * 
 * Create a serialized JSON string from a form node or string
 * ID identifying the form to serialize
 * 
 * @param {!HTMLElement|!String} formNode
 * @param {boolean=} prettyPrint               Optional
 * @return {!String}
 */
dojo._base.kernel.prototype.formToJson = function(formNode, prettyPrint) {};

/**
 * Serialize a form node to a JavaScript object.
 * Returns the values encoded in an HTML form as
 * string properties in an object which it then returns. Disabled form
 * elements, buttons, and other non-value form elements are skipped.
 * Multi-select elements are returned as an array of string values.
 * 
 * Serialize a form node to a JavaScript object.
 * Returns the values encoded in an HTML form as
 * string properties in an object which it then returns. Disabled form
 * elements, buttons, and other non-value form elements are skipped.
 * Multi-select elements are returned as an array of string values.
 * 
 * @param {!HTMLElement|!String} formNode
 * @return {!Object}
 */
dojo._base.kernel.prototype.formToObject = function(formNode) {};

/**
 * Returns a URL-encoded string representing the form passed as either a
 * node or string ID identifying the form to serialize
 * 
 * Returns a URL-encoded string representing the form passed as either a
 * node or string ID identifying the form to serialize
 * 
 * @param {!HTMLElement|!String} formNode
 * @return {!String}
 */
dojo._base.kernel.prototype.formToQuery = function(formNode) {};

/**
 * Parses a JavaScript expression and returns a JavaScript value.
 * Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
 * always delegates to eval(). The content passed to this method must therefore come
 * from a trusted source.
 * It is recommend that you use dojo/json's parse function for an
 * implementation uses the (faster) native JSON parse when available.
 * 
 * @param {!String} js a string literal of a JavaScript expression, for instance:'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'
 * @return {?}
 */
dojo._base.kernel.prototype.fromJson = function(js) {};

/**
 * Gets an attribute on an HTML element.
 * Handles normalized getting of attributes on DOM Nodes.
 * 
 * Gets an attribute on an HTML element.
 * Handles normalized getting of attributes on DOM Nodes.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to get the attribute on
 * @param {!String} name the name of the attribute to get.
 * @return {?}
 */
dojo._base.kernel.prototype.getAttr = function(node, name) {};

/**
 * returns an object with properties useful for noting the border
 * dimensions.
 * l/t/r/b = the sum of left/top/right/bottom border (respectively)
 * w = the sum of the left and right border
 * h = the sum of the top and bottom border
 * The w/h are used for calculating boxes.
 * Normally application code will not need to invoke this
 * directly, and will use the ...box... functions instead.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo._base.kernel.prototype.getBorderExtents = function(node, computedStyle) {};

/**
 * Returns a "computed style" object.
 * Gets a "computed style" object which can be used to gather
 * information about the current state of the rendered node.
 * 
 * Note that this may behave differently on different browsers.
 * Values may have different formats and value encodings across
 * browsers.
 * 
 * Note also that this method is expensive.  Wherever possible,
 * reuse the returned object.
 * 
 * Use the dojo/dom-style.get() method for more consistent (pixelized)
 * return values.
 * 
 * @param {!HTMLElement} node A reference to a DOM node. Does NOT support taking anID string for speed reasons.
 * @return {void}
 */
dojo._base.kernel.prototype.getComputedStyle = function(node) {};

/**
 * Returns an object that encodes the width, height, left and top
 * positions of the node's content box, irrespective of the
 * current box model.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo._base.kernel.prototype.getContentBox = function(node, computedStyle) {};

/**
 * returns the offset in x and y from the document body to the
 * visual edge of the page for IE
 * The following values in IE contain an offset:
 * 
 * event.clientX
 * event.clientY
 * node.getBoundingClientRect().left
 * node.getBoundingClientRect().top
 * But other position related values do not contain this offset,
 * 
 * such as node.offsetLeft, node.offsetTop, node.style.left and
 * node.style.top. The offset is always (2, 2) in LTR direction.
 * When the body is in RTL direction, the offset counts the width
 * of left scroll bar's width.  This function computes the actual
 * offset.
 * 
 * @param {!HTMLDocument=} doc               OptionalOptional document to query.   If unspecified, use win.doc.
 * @return {!Object}
 */
dojo._base.kernel.prototype.getIeDocumentElementOffset = function(doc) {};

/**
 *
 * @param {?} moduleName
 * @param {?} bundleName
 * @param {?} locale
 * @return {!String}
 */
dojo._base.kernel.prototype.getL10nName = function(moduleName, bundleName, locale) {};

/**
 * returns an object that encodes the width, height, left and top
 * positions of the node's margin box.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo._base.kernel.prototype.getMarginBox = function(node, computedStyle) {};

/**
 * returns object with properties useful for box fitting with
 * regards to box margins (i.e., the outer-box).
 * 
 * l/t = marginLeft, marginTop, respectively
 * w = total width, margin inclusive
 * h = total height, margin inclusive
 * The w/h are used for calculating boxes.
 * Normally application code will not need to invoke this
 * directly, and will use the ...box... functions instead.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo._base.kernel.prototype.getMarginExtents = function(node, computedStyle) {};

/**
 * returns an object that encodes the width and height of
 * the node's margin box
 * 
 * returns an object that encodes the width and height of
 * the node's margin box
 * 
 * @param {!HTMLElement|!String} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo._base.kernel.prototype.getMarginSize = function(node, computedStyle) {};

/**
 * Returns an effective value of a property or an attribute.
 * 
 * Returns an effective value of a property or an attribute.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to remove the attribute from
 * @param {!String} name the name of the attribute
 * @return {?}
 */
dojo._base.kernel.prototype.getNodeProp = function(node, name) {};

/**
 * Returns object with properties useful for box fitting with
 * regards to padding.
 * l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
 * w = the sum of the left and right padding and border
 * h = the sum of the top and bottom padding and border
 * The w/h are used for calculating boxes.
 * Normally application code will not need to invoke this
 * directly, and will use the ...box... functions instead.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo._base.kernel.prototype.getPadBorderExtents = function(node, computedStyle) {};

/**
 * Returns object with special values specifically useful for node
 * fitting.
 * Returns an object with w, h, l, t properties:
 * 
 * l/t/r/b = left/top/right/bottom padding (respectively)
 * w = the total of the left and right padding
 * h = the total of the top and bottom padding
 * If 'node' has position, l/t forms the origin for child nodes.
 * 
 * The w/h are used for calculating boxes.
 * Normally application code will not need to invoke this
 * directly, and will use the ...box... functions instead.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo._base.kernel.prototype.getPadExtents = function(node, computedStyle) {};

/**
 * Gets a property on an HTML element.
 * Handles normalized getting of properties on DOM nodes.
 * 
 * Gets a property on an HTML element.
 * Handles normalized getting of properties on DOM nodes.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to get the property on
 * @param {!String} name the name of the property to get.
 * @return {?}
 */
dojo._base.kernel.prototype.getProp = function(node, name) {};

/**
 * Accesses styles on a node.
 * Getting the style value uses the computed style for the node, so the value
 * will be a calculated value, not just the immediate node.style value.
 * Also when getting values, use specific style names,
 * like "borderBottomWidth" instead of "border" since compound values like
 * "border" are not necessarily reflected as expected.
 * If you want to get node dimensions, use dojo/dom-geometry.getMarginBox(),
 * dojo/dom-geometry.getContentBox() or dojo/dom-geometry.getPosition().
 * 
 * Accesses styles on a node.
 * Getting the style value uses the computed style for the node, so the value
 * will be a calculated value, not just the immediate node.style value.
 * Also when getting values, use specific style names,
 * like "borderBottomWidth" instead of "border" since compound values like
 * "border" are not necessarily reflected as expected.
 * If you want to get node dimensions, use dojo/dom-geometry.getMarginBox(),
 * dojo/dom-geometry.getContentBox() or dojo/dom-geometry.getPosition().
 * 
 * @param {!HTMLElement|!String} node id or reference to node to get style for
 * @param {!String=} name               Optionalthe style property to get
 * @return {?}
 */
dojo._base.kernel.prototype.getStyle = function(node, name) {};

/**
 * Returns true if the requested attribute is specified on the
 * given element, and false otherwise.
 * 
 * Returns true if the requested attribute is specified on the
 * given element, and false otherwise.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to check
 * @param {!String} name the name of the attribute
 * @return {boolean}
 */
dojo._base.kernel.prototype.hasAttr = function(node, name) {};

/**
 * Returns whether or not the specified classes are a portion of the
 * class list currently applied to the node.
 * 
 * Returns whether or not the specified classes are a portion of the
 * class list currently applied to the node.
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to check the class for.
 * @param {!String} classStr A string class name to look for.
 * @return {boolean}
 */
dojo._base.kernel.prototype.hasClass = function(node, classStr) {};

/**
 * Gets or sets the hash string in the browser URL.
 * Handles getting and setting of location.hash.
 * 
 * If no arguments are passed, acts as a getter.
 * If a string is passed, acts as a setter.
 * 
 * @param {!String=} hash               Optionalthe hash is set - #string.
 * @param {boolean=} replace               OptionalIf true, updates the hash value in the current historystate instead of creating a new history state.
 * @return {?}
 */
dojo._base.kernel.prototype.hash = function(hash, replace) {};

/**
 * locates the first index of the provided value in the
 * passed array. If the value is not found, -1 is returned.
 * This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:
 * 
 * when run over sparse arrays, the Dojo function invokes the callback for every index
 * whereas JavaScript 1.6's indexOf skips the holes in the sparse array.
 * uses equality (==) rather than strict equality (===)
 * For details on this method, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf
 * 
 * @param {!Array<?>} arr
 * @param {!Object} value
 * @param {number=} fromIndex               Optional
 * @param {boolean=} findLast               OptionalMakes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.
 * @return {number}
 */
dojo._base.kernel.prototype.indexOf = function(arr, value, fromIndex, findLast) {};

/**
 * Returns true if the current language is left-to-right, and false otherwise.
 * 
 * @param {!HTMLDocument=} doc               OptionalOptional document to query.   If unspecified, use win.doc.
 * @return {boolean}
 */
dojo._base.kernel.prototype.isBodyLtr = function(doc) {};

/**
 * Returns true if node is a descendant of ancestor
 * 
 * Returns true if node is a descendant of ancestor
 * 
 * Returns true if node is a descendant of ancestor
 * 
 * Returns true if node is a descendant of ancestor
 * 
 * @param {!HTMLElement|!String} node string id or node reference to test
 * @param {!HTMLElement|!String} ancestor string id or node reference of potential parent to test against
 * @return {boolean}
 */
dojo._base.kernel.prototype.isDescendant = function(node, ancestor) {};

/**
 * locates the last index of the provided value in the passed
 * array. If the value is not found, -1 is returned.
 * This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:
 * 
 * when run over sparse arrays, the Dojo function invokes the callback for every index
 * whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.
 * uses equality (==) rather than strict equality (===)
 * For details on this method, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf
 * 
 * @param {?} arr
 * @param {?} value
 * @param {number=} fromIndex               Optional
 * @return {number}
 */
dojo._base.kernel.prototype.lastIndexOf = function(arr, value, fromIndex) {};

/**
 *
 * @param {?} f
 * @return {void}
 */
dojo._base.kernel.prototype.loadInit = function(f) {};

/**
 * applies callback to each element of arr and returns
 * an Array with the results
 * This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
 * 
 * applies callback to each element of arr and returns
 * an Array with the results
 * This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
 * 
 * applies callback to each element of arr and returns
 * an Array with the results
 * This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
 * 
 * applies callback to each element of arr and returns
 * an Array with the results
 * This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
 * 
 * @param {!Array<?>|!String} arr the array to iterate on. If a string, operates onindividual characters.
 * @param {!Function|!String} callback a function is invoked with three arguments, (item, index,array),  and returns a value
 * @param {!Object} thisObject               Optionalmay be used to scope the call to callback
 * @param {?} Ctr
 * @return {!Array<?>}
 */
dojo._base.kernel.prototype.map = function(arr, callback, thisObject, Ctr) {};

/**
 * Getter/setter for the margin-box of node.
 * Getter/setter for the margin-box of node.
 * Returns an object in the expected format of box (regardless
 * if box is passed). The object might look like:
 * { l: 50, t: 200, w: 300: h: 150 }
 * for a node offset from its parent 50px to the left, 200px from
 * the top with a margin width of 300px and a margin-height of
 * 150px.
 * 
 * Getter/setter for the margin-box of node.
 * Getter/setter for the margin-box of node.
 * Returns an object in the expected format of box (regardless
 * if box is passed). The object might look like:
 * { l: 50, t: 200, w: 300: h: 150 }
 * for a node offset from its parent 50px to the left, 200px from
 * the top with a margin width of 300px and a margin-height of
 * 150px.
 * 
 * @param {!HTMLElement|!String} node id or reference to DOM Node to get/set box for
 * @param {!Object=} box               OptionalIf passed, denotes that dojo.marginBox() shouldupdate/set the margin box for node. Box is an object in theabove format. All properties are optional if passed.
 * @return {?}
 */
dojo._base.kernel.prototype.marginBox = function(node, box) {};

/**
 * Returns a URL relative to a module.
 * 
 * @param {!String} module dojo/dom-class
 * @param {!String=} url               Optional
 * @return {!String}
 */
dojo._base.kernel.prototype.moduleUrl = function(module, url) {};

/**
 * Array-like object which adds syntactic
 * sugar for chaining, common iteration operations, animation, and
 * node manipulation. NodeLists are most often returned as the
 * result of dojo/query() calls.
 * NodeList instances provide many utilities that reflect
 * core Dojo APIs for Array iteration and manipulation, DOM
 * manipulation, and event handling. Instead of needing to dig up
 * functions in the dojo package, NodeLists generally make the
 * full power of Dojo available for DOM manipulation tasks in a
 * simple, chainable way.
 * 
 * @param {?} array
 * @return {!Array<?>}
 */
dojo._base.kernel.prototype.NodeList = function(array) {};

/**
 * takes a name/value mapping object and returns a string representing
 * a URL-encoded version of that object.
 * 
 * @param {!Object} map
 * @return {?}
 */
dojo._base.kernel.prototype.objectToQuery = function(map) {};

/**
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * @param {!HTMLElement|!String} node id or node reference, or HTML fragment starting with "<" to place relative to refNode
 * @param {!HTMLElement|!String} refNode id or node reference to use as basis for placement
 * @param {!String|number=} position               Optionalstring noting the position of node relative to refNode or anumber indicating the location in the childNodes collection of refNode.Accepted string values are:beforeafterreplaceonlyfirstlast"first" and "last" indicate positions as children of refNode, "replace" replaces refNode,"only" replaces all children.  position defaults to "last" if not specified
 * @return {!HTMLElement}
 */
dojo._base.kernel.prototype.place = function(node, refNode, position) {};

/**
 * require one or more modules based on which host environment
 * Dojo is currently operating in
 * This method takes a "map" of arrays which one can use to
 * optionally load dojo modules. The map is indexed by the
 * possible dojo.name values, with two additional values:
 * "default" and "common". The items in the "default" array will
 * be loaded if none of the other items have been choosen based on
 * dojo.name, set by your host environment. The items in the
 * "common" array will always be loaded, regardless of which
 * list is chosen.
 * 
 * @param {!Object} modMap
 * @return {void}
 */
dojo._base.kernel.prototype.platformRequire = function(modMap) {};

/**
 * If the context stack contains elements, ensure that
 * subsequent code executes in the previous context to the
 * current context. The current context set ([global,
 * document]) is returned.
 * 
 * @return {void}
 */
dojo._base.kernel.prototype.popContext = function() {};

/**
 * Gets the position and size of the passed element relative to
 * the viewport (if includeScroll==false), or relative to the
 * document root (if includeScroll==true).
 * Returns an object of the form:
 * { x: 100, y: 300, w: 20, h: 15 }.
 * If includeScroll==true, the x and y values will include any
 * document offsets that may affect the position relative to the
 * viewport.
 * Uses the border-box model (inclusive of border and padding but
 * not margin).  Does not act as a setter.
 * 
 * Gets the position and size of the passed element relative to
 * the viewport (if includeScroll==false), or relative to the
 * document root (if includeScroll==true).
 * Returns an object of the form:
 * { x: 100, y: 300, w: 20, h: 15 }.
 * If includeScroll==true, the x and y values will include any
 * document offsets that may affect the position relative to the
 * viewport.
 * Uses the border-box model (inclusive of border and padding but
 * not margin).  Does not act as a setter.
 * 
 * @param {!HTMLElement|!String} node
 * @param {boolean=} includeScroll               Optional
 * @return {!Object}
 */
dojo._base.kernel.prototype.position = function(node, includeScroll) {};

/**
 * Gets or sets a property on an HTML element.
 * Handles normalized getting and setting of properties on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Gets or sets a property on an HTML element.
 * Handles normalized getting and setting of properties on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Gets or sets a property on an HTML element.
 * Handles normalized getting and setting of properties on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Gets or sets a property on an HTML element.
 * Handles normalized getting and setting of properties on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to get or set the property on
 * @param {!String|!Object} name the name of the property to get or set.
 * @param {!String=} value               OptionalThe value to set for the property
 * @return {?}
 */
dojo._base.kernel.prototype.prop = function(node, name, value) {};

/**
 *
 * @param {?} mid
 * @return {void}
 */
dojo._base.kernel.prototype.provide = function(mid) {};

/**
 * causes subsequent calls to Dojo methods to assume the
 * passed object and, optionally, document as the default
 * scopes to use. A 2-element array of the previous global and
 * document are returned.
 * dojo.pushContext treats contexts as a stack. The
 * auto-detected contexts which are initially provided using
 * dojo.setContext() require authors to keep state in order to
 * "return" to a previous context, whereas the
 * dojo.pushContext and dojo.popContext methods provide a more
 * natural way to augment blocks of code to ensure that they
 * execute in a different window or frame without issue. If
 * called without any arguments, the default context (the
 * context when Dojo is first loaded) is instead pushed into
 * the stack. If only a single string is passed, a node in the
 * intitial context's document is looked up and its
 * contextWindow and contextDocument properties are used as
 * the context to push. This means that iframes can be given
 * an ID and code can be executed in the scope of the iframe's
 * document in subsequent calls easily.
 * 
 * causes subsequent calls to Dojo methods to assume the
 * passed object and, optionally, document as the default
 * scopes to use. A 2-element array of the previous global and
 * document are returned.
 * dojo.pushContext treats contexts as a stack. The
 * auto-detected contexts which are initially provided using
 * dojo.setContext() require authors to keep state in order to
 * "return" to a previous context, whereas the
 * dojo.pushContext and dojo.popContext methods provide a more
 * natural way to augment blocks of code to ensure that they
 * execute in a different window or frame without issue. If
 * called without any arguments, the default context (the
 * context when Dojo is first loaded) is instead pushed into
 * the stack. If only a single string is passed, a node in the
 * intitial context's document is looked up and its
 * contextWindow and contextDocument properties are used as
 * the context to push. This means that iframes can be given
 * an ID and code can be executed in the scope of the iframe's
 * document in subsequent calls easily.
 * 
 * @param {!Object|!String=} g               OptionalThe global context. If a string, the id of the frame tosearch for a context and document.
 * @param {!HTMLDocument=} d               OptionalThe document element to execute subsequent code with.
 * @return {void}
 */
dojo._base.kernel.prototype.pushContext = function(g, d) {};

/**
 * Create an object representing a de-serialized query section of a
 * URL. Query keys with multiple values are returned in an array.
 * 
 * @param {!String} str
 * @return {!Object}
 */
dojo._base.kernel.prototype.queryToObject = function(str) {};

/**
 * Sends an HTTP POST request to the server. In addition to the properties
 * listed for the dojo.__XhrArgs type, the following property is allowed:
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo._base.kernel.prototype.rawXhrPost = function(args) {};

/**
 * Sends an HTTP PUT request to the server. In addition to the properties
 * listed for the dojo.__XhrArgs type, the following property is allowed:
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo._base.kernel.prototype.rawXhrPut = function(args) {};

/**
 * Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
 * In most cases, the domReady plug-in should suffice and this method should not be needed.
 * 
 * When called in a non-browser environment, just checks that all requested modules have arrived and been
 * evaluated.
 * 
 * @param {number} priority               OptionalThe order in which to exec this callback relative to other callbacks, defaults to 1000
 * @param {?} context The context in which to run execute callback, or a callback if not using context
 * @param {!Function=} callback               OptionalThe function to execute.
 * @return {void}
 */
dojo._base.kernel.prototype.ready = function(priority, context, callback) {};

/**
 * Maps a module name to a path
 * An unregistered module is given the default path of ../[module],
 * relative to Dojo root. For example, module acme is mapped to
 * ../acme.  If you want to use a different module name, use
 * dojo.registerModulePath.
 * 
 * @param {!String} moduleName
 * @param {!String} prefix
 * @return {void}
 */
dojo._base.kernel.prototype.registerModulePath = function(moduleName, prefix) {};

/**
 * Removes an attribute from an HTML element.
 * 
 * Removes an attribute from an HTML element.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to remove the attribute from
 * @param {!String} name the name of the attribute to remove
 * @return {void}
 */
dojo._base.kernel.prototype.removeAttr = function(node, name) {};

/**
 * Removes the specified classes from node. No contains()
 * check is required.
 * 
 * Removes the specified classes from node. No contains()
 * check is required.
 * 
 * Removes the specified classes from node. No contains()
 * check is required.
 * 
 * Removes the specified classes from node. No contains()
 * check is required.
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to remove the class from.
 * @param {!String|!Array<?>=} classStr               OptionalAn optional String class name to remove, or several space-separatedclass names, or an array of class names. If omitted, all class nameswill be deleted.
 * @return {void}
 */
dojo._base.kernel.prototype.removeClass = function(node, classStr) {};

/**
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to remove the class from.
 * @param {!String|!Array<?>} addClassStr A String class name to add, or several space-separated class names,or an array of class names.
 * @param {!String|!Array<?>=} removeClassStr               OptionalA String class name to remove, or several space-separated class names,or an array of class names.
 * @return {void}
 */
dojo._base.kernel.prototype.replaceClass = function(node, addClassStr, removeClassStr) {};

/**
 * loads a Javascript module from the appropriate URI
 * Modules are loaded via dojo.require by using one of two loaders: the normal loader
 * and the xdomain loader. The xdomain loader is used when dojo was built with a
 * custom build that specified loader=xdomain and the module lives on a modulePath
 * that is a whole URL, with protocol and a domain. The versions of Dojo that are on
 * the Google and AOL CDNs use the xdomain loader.
 * 
 * If the module is loaded via the xdomain loader, it is an asynchronous load, since
 * the module is added via a dynamically created script tag. This
 * means that dojo.require() can return before the module has loaded. However, this
 * should only happen in the case where you do dojo.require calls in the top-level
 * HTML page, or if you purposely avoid the loader checking for dojo.require
 * dependencies in your module by using a syntax like dojo["require"] to load the module.
 * 
 * Sometimes it is useful to not have the loader detect the dojo.require calls in the
 * module so that you can dynamically load the modules as a result of an action on the
 * page, instead of right at module load time.
 * 
 * Also, for script blocks in an HTML page, the loader does not pre-process them, so
 * it does not know to download the modules before the dojo.require calls occur.
 * 
 * So, in those two cases, when you want on-the-fly module loading or for script blocks
 * in the HTML page, special care must be taken if the dojo.required code is loaded
 * asynchronously. To make sure you can execute code that depends on the dojo.required
 * modules, be sure to add the code that depends on the modules in a dojo.addOnLoad()
 * callback. dojo.addOnLoad waits for all outstanding modules to finish loading before
 * executing.
 * 
 * This type of syntax works with both xdomain and normal loaders, so it is good
 * practice to always use this idiom for on-the-fly code loading and in HTML script
 * blocks. If at some point you change loaders and where the code is loaded from,
 * it will all still work.
 * 
 * More on how dojo.require
 * dojo.require("A.B") first checks to see if symbol A.B is
 * defined. If it is, it is simply returned (nothing to do).
 * 
 * If it is not defined, it will look for A/B.js in the script root
 * directory.
 * 
 * dojo.require throws an exception if it cannot find a file
 * to load, or if the symbol A.B is not defined after loading.
 * 
 * It returns the object A.B, but note the caveats above about on-the-fly loading and
 * HTML script blocks when the xdomain loader is loading a module.
 * 
 * dojo.require() does nothing about importing symbols into
 * the current namespace.  It is presumed that the caller will
 * take care of that.
 * 
 * @param {!String} moduleName module name to load, using periods for separators, e.g. "dojo.date.locale".  Module paths are de-referenced by dojo'sinternal mapping of locations to names and are disambiguated bylongest prefix. See dojo.registerModulePath() for details onregistering new modules.
 * @param {boolean} omitModuleCheck               Optionalif true, omitModuleCheck skips the step of ensuring that theloaded file actually defines the symbol it is referenced by.For example if it called as dojo.require("a.b.c") and thefile located at a/b/c.js does not define an object a.b.c,and exception will be throws whereas no exception is raisedwhen called as dojo.require("a.b.c", true)
 * @return {?}
 */
dojo._base.kernel.prototype.require = function(moduleName, omitModuleCheck) {};

/**
 * If the condition is true then call dojo.require() for the specified
 * resource
 * 
 * @param {boolean} condition
 * @param {!String} moduleName
 * @param {boolean=} omitModuleCheck               Optional
 * @return {void}
 */
dojo._base.kernel.prototype.requireAfterIf = function(condition, moduleName, omitModuleCheck) {};

/**
 * If the condition is true then call dojo.require() for the specified
 * resource
 * 
 * @param {boolean} condition
 * @param {!String} moduleName
 * @param {boolean=} omitModuleCheck               Optional
 * @return {void}
 */
dojo._base.kernel.prototype.requireIf = function(condition, moduleName, omitModuleCheck) {};

/**
 *
 * @param {!String} moduleName
 * @param {!String} bundleName
 * @param {!String=} locale               Optional
 * @return {void}
 */
dojo._base.kernel.prototype.requireLocalization = function(moduleName, bundleName, locale) {};

/**
 * Mix in properties skipping a constructor and decorating functions
 * like it is done by declare().
 * This function is used to mix in properties like lang.mixin does,
 * but it skips a constructor property and decorates functions like
 * declare() does.
 * 
 * It is meant to be used with classes and objects produced with
 * declare. Functions mixed in with dojo.safeMixin can use
 * this.inherited() like normal methods.
 * 
 * This function is used to implement extend() method of a constructor
 * produced with declare().
 * 
 * @param {!Object} target Target object to accept new properties.
 * @param {!Object} source Source object for new properties.
 * @return {!Object}
 */
dojo._base.kernel.prototype.safeMixin = function(target, source) {};

/**
 * Sets an attribute on an HTML element.
 * Handles normalized setting of attributes on DOM Nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets an attribute on an HTML element.
 * Handles normalized setting of attributes on DOM Nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets an attribute on an HTML element.
 * Handles normalized setting of attributes on DOM Nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets an attribute on an HTML element.
 * Handles normalized setting of attributes on DOM Nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to set the attribute on
 * @param {!String|!Object} name the name of the attribute to set, or a hash of key-value pairs to set.
 * @param {!String=} value               Optionalthe value to set for the attribute, if the name is a string.
 * @return {?}
 */
dojo._base.kernel.prototype.setAttr = function(node, name, value) {};

/**
 * Sets the size of the node's contents, irrespective of margins,
 * padding, or borders.
 * 
 * @param {!HTMLElement} node
 * @param {!Object} box hash with optional "w", and "h" properties for "width", and "height"respectively. All specified properties should have numeric values in whole pixels.
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {void}
 */
dojo._base.kernel.prototype.setContentSize = function(node, box, computedStyle) {};

/**
 * changes the behavior of many core Dojo functions that deal with
 * namespace and DOM lookup, changing them to work in a new global
 * context (e.g., an iframe). The varibles dojo.global and dojo.doc
 * are modified as a result of calling this function and the result of
 * dojo.body() likewise differs.
 * 
 * @param {!Object} globalObject
 * @param {!HTMLDocument} globalDocument
 * @return {void}
 */
dojo._base.kernel.prototype.setContext = function(globalObject, globalDocument) {};

/**
 * sets the size of the node's margin box and placement
 * (left/top), irrespective of box model. Think of it as a
 * passthrough to setBox that handles box-model vagaries for
 * you.
 * 
 * @param {!HTMLElement} node
 * @param {!Object} box hash with optional "l", "t", "w", and "h" properties for "left", "right", "width", and "height"respectively. All specified properties should have numeric values in whole pixels.
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {void}
 */
dojo._base.kernel.prototype.setMarginBox = function(node, box, computedStyle) {};

/**
 * Sets a property on an HTML element.
 * Handles normalized setting of properties on DOM nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets a property on an HTML element.
 * Handles normalized setting of properties on DOM nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets a property on an HTML element.
 * Handles normalized setting of properties on DOM nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets a property on an HTML element.
 * Handles normalized setting of properties on DOM nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to set the property on
 * @param {!String|!Object} name the name of the property to set, or a hash object to setmultiple properties at once.
 * @param {!String=} value               OptionalThe value to set for the property
 * @return {?}
 */
dojo._base.kernel.prototype.setProp = function(node, name, value) {};

/**
 *
 * @param {?} node
 * @param {?} selectable
 * @return {void}
 */
dojo._base.kernel.prototype.setSelectable = function(node, selectable) {};

/**
 * Sets styles on a node.
 * 
 * Sets styles on a node.
 * 
 * Sets styles on a node.
 * 
 * Sets styles on a node.
 * 
 * @param {!HTMLElement|!String} node id or reference to node to set style for
 * @param {!String|!Object} name the style property to set in DOM-accessor format("borderWidth", not "border-width") or an object with key/valuepairs suitable for setting each property.
 * @param {!String=} value               OptionalIf passed, sets value on the node for style, handlingcross-browser concerns.  When setting a pixel value,be sure to include "px" in the value. For instance, top: "200px".Otherwise, in some cases, some browsers will not apply the style.
 * @return {!String}
 */
dojo._base.kernel.prototype.setStyle = function(node, name, value) {};

/**
 * Determines whether or not any item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
 * 
 * Determines whether or not any item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
 * 
 * Determines whether or not any item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
 * 
 * Determines whether or not any item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
 * 
 * @param {!Array<?>|!String} arr the array to iterate over. If a string, operates on individual characters.
 * @param {!Function|!String} callback a function is invoked with three arguments: item, index,and array and returns true if the condition is met.
 * @param {!Object=} thisObject               Optionalmay be used to scope the call to callback
 * @return {boolean}
 */
dojo._base.kernel.prototype.some = function(arr, callback, thisObject) {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.prototype.Stateful = function() {};

/**
 * prevents propagation and clobbers the default action of the
 * passed event
 * 
 * @param {!Event} evt The event object. If omitted, window.event is used on IE.
 * @return {void}
 */
dojo._base.kernel.prototype.stopEvent = function(evt) {};

/**
 * Accesses styles on a node. If 2 arguments are
 * passed, acts as a getter. If 3 arguments are passed, acts
 * as a setter.
 * Getting the style value uses the computed style for the node, so the value
 * will be a calculated value, not just the immediate node.style value.
 * Also when getting values, use specific style names,
 * like "borderBottomWidth" instead of "border" since compound values like
 * "border" are not necessarily reflected as expected.
 * If you want to get node dimensions, use dojo.marginBox(),
 * dojo.contentBox() or dojo.position().
 * 
 * Accesses styles on a node. If 2 arguments are
 * passed, acts as a getter. If 3 arguments are passed, acts
 * as a setter.
 * Getting the style value uses the computed style for the node, so the value
 * will be a calculated value, not just the immediate node.style value.
 * Also when getting values, use specific style names,
 * like "borderBottomWidth" instead of "border" since compound values like
 * "border" are not necessarily reflected as expected.
 * If you want to get node dimensions, use dojo.marginBox(),
 * dojo.contentBox() or dojo.position().
 * 
 * Accesses styles on a node. If 2 arguments are
 * passed, acts as a getter. If 3 arguments are passed, acts
 * as a setter.
 * Getting the style value uses the computed style for the node, so the value
 * will be a calculated value, not just the immediate node.style value.
 * Also when getting values, use specific style names,
 * like "borderBottomWidth" instead of "border" since compound values like
 * "border" are not necessarily reflected as expected.
 * If you want to get node dimensions, use dojo.marginBox(),
 * dojo.contentBox() or dojo.position().
 * 
 * Accesses styles on a node. If 2 arguments are
 * passed, acts as a getter. If 3 arguments are passed, acts
 * as a setter.
 * Getting the style value uses the computed style for the node, so the value
 * will be a calculated value, not just the immediate node.style value.
 * Also when getting values, use specific style names,
 * like "borderBottomWidth" instead of "border" since compound values like
 * "border" are not necessarily reflected as expected.
 * If you want to get node dimensions, use dojo.marginBox(),
 * dojo.contentBox() or dojo.position().
 * 
 * @param {!HTMLElement|!String} node id or reference to node to get/set style for
 * @param {!String|!Object=} name               Optionalthe style property to set in DOM-accessor format("borderWidth", not "border-width") or an object with key/valuepairs suitable for setting each property.
 * @param {!String=} value               OptionalIf passed, sets value on the node for style, handlingcross-browser concerns.  When setting a pixel value,be sure to include "px" in the value. For instance, top: "200px".Otherwise, in some cases, some browsers will not apply the style.
 * @return {?}
 */
dojo._base.kernel.prototype.style = function(node, name, value) {};

/**
 * instantiates an HTML fragment returning the corresponding DOM.
 * 
 * @param {!String} frag the HTML fragment
 * @param {!HTMLDocument=} doc               Optionaloptional document to use when creating DOM nodes, defaults todojo/_base/window.doc if not specified.
 * @return {?}
 */
dojo._base.kernel.prototype.toDom = function(frag, doc) {};

/**
 * Adds a class to node if not present, or removes if present.
 * Pass a boolean condition if you want to explicitly add or remove.
 * Returns the condition that was specified directly or indirectly.
 * 
 * Adds a class to node if not present, or removes if present.
 * Pass a boolean condition if you want to explicitly add or remove.
 * Returns the condition that was specified directly or indirectly.
 * 
 * Adds a class to node if not present, or removes if present.
 * Pass a boolean condition if you want to explicitly add or remove.
 * Returns the condition that was specified directly or indirectly.
 * 
 * Adds a class to node if not present, or removes if present.
 * Pass a boolean condition if you want to explicitly add or remove.
 * Returns the condition that was specified directly or indirectly.
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to toggle a class string
 * @param {!String|!Array<?>} classStr A String class name to toggle, or several space-separated class names,or an array of class names.
 * @param {boolean} condition               OptionalIf passed, true means to add the class, false means to remove.Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
 * @return {boolean}
 */
dojo._base.kernel.prototype.toggleClass = function(node, classStr, condition) {};

/**
 * Returns a JSON serialization of an object.
 * Returns a JSON serialization of an object.
 * Note that this doesn't check for infinite recursion, so don't do that!
 * It is recommend that you use dojo/json's stringify function for an lighter
 * and faster implementation that matches the native JSON API and uses the
 * native JSON serializer when available.
 * 
 * @param {!Object} it an object to be serialized. Objects may define their ownserialization via a special "json" or "json" functionproperty. If a specialized serializer has been defined, it willbe used as a fallback.Note that in 1.6, toJson would serialize undefined, but this no longer supportedsince it is not supported by native JSON serializer.
 * @param {boolean=} prettyPrint               Optionalif true, we indent objects and arrays to make the output prettier.The variable dojo.toJsonIndentStr is used as the indent string --to use something other than the default (tab), change that variablebefore calling dojo.toJson().Note that if native JSON support is available, it will be used for serialization,and native implementations vary on the exact spacing used in pretty printing.
 * @return {?}
 */
dojo._base.kernel.prototype.toJson = function(it, prettyPrint) {};

/**
 * converts style value to pixels on IE or return a numeric value.
 * 
 * @param {!HTMLElement} node
 * @param {!String} value
 * @return {number}
 */
dojo._base.kernel.prototype.toPixelValue = function(node, value) {};

/**
 * Remove a topic listener.
 * 
 * @param {!Object} handle The handle returned from a call to subscribe.
 * @return {void}
 */
dojo._base.kernel.prototype.unsubscribe = function(handle) {};

/**
 * Transparently applies callbacks to values and/or promises.
 * Accepts promises but also transparently handles non-promises. If no
 * callbacks are provided returns a promise, regardless of the initial
 * value. Foreign promises are converted.
 * 
 * If callbacks are provided and the initial value is not a promise,
 * the callback is executed immediately with no error handling. Returns
 * a promise if the initial value is a promise, or the result of the
 * callback otherwise.
 * 
 * @param {?} valueOrPromise Either a regular value or an object with a then() method thatfollows the Promises/A specification.
 * @param {!Function=} callback               OptionalCallback to be invoked when the promise is resolved, or a non-promiseis received.
 * @param {!Function=} errback               OptionalCallback to be invoked when the promise is rejected.
 * @param {!Function=} progback               OptionalCallback to be invoked when the promise emits a progress update.
 * @return {!dojo.promise.Promise<?>}
 */
dojo._base.kernel.prototype.when = function(valueOrPromise, callback, errback, progback) {};

/**
 * signal fired by impending window destruction. You may use
 * dojo.addOnWIndowUnload() or dojo.connect() to this method to perform
 * page/application cleanup methods. See dojo.addOnWindowUnload for more info.
 * 
 * @return {void}
 */
dojo._base.kernel.prototype.windowUnloaded = function() {};

/**
 * Invoke callback with documentObject as dojo/_base/window::doc.
 * Invoke callback with documentObject as dojo/_base/window::doc. If provided,
 * callback will be executed in the context of object thisObject
 * When callback() returns or throws an error, the dojo/_base/window::doc will
 * be restored to its previous state.
 * 
 * @param {!HTMLDocument} documentObject
 * @param {!Function} callback
 * @param {!Object=} thisObject               Optional
 * @param {!Array<?>=} cbArguments               Optional
 * @return {?}
 */
dojo._base.kernel.prototype.withDoc = function(documentObject, callback, thisObject, cbArguments) {};

/**
 * Invoke callback with globalObject as dojo.global and
 * globalObject.document as dojo.doc.
 * Invoke callback with globalObject as dojo.global and
 * globalObject.document as dojo.doc. If provided, globalObject
 * will be executed in the context of object thisObject
 * When callback() returns or throws an error, the dojo.global
 * and dojo.doc will be restored to its previous state.
 * 
 * @param {!Object} globalObject
 * @param {!Function} callback
 * @param {!Object=} thisObject               Optional
 * @param {!Array<?>=} cbArguments               Optional
 * @return {?}
 */
dojo._base.kernel.prototype.withGlobal = function(globalObject, callback, thisObject, cbArguments) {};

/**
 *
 * @param {?} method
 * @param {?} args
 * @return {?}
 */
dojo._base.kernel.prototype.xhr = function(method, args) {};

/**
 * Sends an HTTP DELETE request to the server.
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo._base.kernel.prototype.xhrDelete = function(args) {};

/**
 * Sends an HTTP GET request to the server.
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo._base.kernel.prototype.xhrGet = function(args) {};

/**
 * Sends an HTTP POST request to the server. In addition to the properties
 * listed for the dojo.__XhrArgs type, the following property is allowed:
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo._base.kernel.prototype.xhrPost = function(args) {};

/**
 * Sends an HTTP PUT request to the server. In addition to the properties
 * listed for the dojo.__XhrArgs type, the following property is allowed:
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo._base.kernel.prototype.xhrPut = function(args) {};

/**
 * @constructor
 * @struct
 */
dojo._base.kernel.__IoCallbackArgs = function() {};

/* TODO: PropertyDeclaration: dojo._base.kernel."args" */

/* TODO: PropertyDeclaration: dojo._base.kernel."canDelete" */

/* TODO: PropertyDeclaration: dojo._base.kernel."handleAs" */

/* TODO: PropertyDeclaration: dojo._base.kernel."id" */

/* TODO: PropertyDeclaration: dojo._base.kernel."json" */

/* TODO: PropertyDeclaration: dojo._base.kernel."query" */

/* TODO: PropertyDeclaration: dojo._base.kernel."url" */

/* TODO: PropertyDeclaration: dojo._base.kernel."xhr" */

/**
 * @constructor
 * @struct
 */
dojo._base.kernel.__IoPublish = function() {};

/* TODO: PropertyDeclaration: dojo._base.kernel."done" */

/* TODO: PropertyDeclaration: dojo._base.kernel."error" */

/* TODO: PropertyDeclaration: dojo._base.kernel."load" */

/* TODO: PropertyDeclaration: dojo._base.kernel."send" */

/* TODO: PropertyDeclaration: dojo._base.kernel."start" */

/* TODO: PropertyDeclaration: dojo._base.kernel."stop" */

/**
 * @constructor
 * @struct
 */
dojo._base.kernel.__IoArgs = function() {};

/* TODO: PropertyDeclaration: dojo._base.kernel."content" */

/* TODO: PropertyDeclaration: dojo._base.kernel."form" */

/* TODO: PropertyDeclaration: dojo._base.kernel."handleAs" */

/* TODO: PropertyDeclaration: dojo._base.kernel."ioPublish" */

/* TODO: PropertyDeclaration: dojo._base.kernel."preventCache" */

/* TODO: PropertyDeclaration: dojo._base.kernel."rawBody" */

/* TODO: PropertyDeclaration: dojo._base.kernel."timeout" */

/* TODO: PropertyDeclaration: dojo._base.kernel."url" */

/**
 * This function will
 * be called when the request fails due to a network or server error, the url
 * is invalid, etc. It will also be called if the load or handle callback throws an
 * exception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications
 * to continue to run even when a logic error happens in the callback, while making
 * it easier to troubleshoot while in debug mode.
 * 
 * @param {!Object} response The response in the format as defined with handleAs.
 * @param {!dojo.main.__IoCallbackArgs} ioArgs Provides additional information about the request.
 * @return {void}
 */
dojo._base.kernel.__IoArgs.prototype.error = function(response, ioArgs) {};

/**
 * This function will
 * be called at the end of every request, whether or not an error occurs.
 * 
 * @param {!String} loadOrError Provides a string that tells you whether this functionwas called because of success (load) or failure (error).
 * @param {!Object} response The response in the format as defined with handleAs.
 * @param {!dojo.main.__IoCallbackArgs} ioArgs Provides additional information about the request.
 * @return {void}
 */
dojo._base.kernel.__IoArgs.prototype.handle = function(loadOrError, response, ioArgs) {};

/**
 * This function will be
 * called on a successful HTTP response code.
 * 
 * @param {!Object} response The response in the format as defined with handleAs.
 * @param {!dojo.main.__IoCallbackArgs} ioArgs Provides additional information about the request.
 * @return {void}
 */
dojo._base.kernel.__IoArgs.prototype.load = function(response, ioArgs) {};

/**
 * @constructor
 * @struct
 */
dojo._base.kernel.__XhrArgs = function() {};

/* TODO: PropertyDeclaration: dojo._base.kernel."content" */

/* TODO: PropertyDeclaration: dojo._base.kernel."contentType" */

/* TODO: PropertyDeclaration: dojo._base.kernel."failOk" */

/* TODO: PropertyDeclaration: dojo._base.kernel."form" */

/* TODO: PropertyDeclaration: dojo._base.kernel."handleAs" */

/* TODO: PropertyDeclaration: dojo._base.kernel."headers" */

/* TODO: PropertyDeclaration: dojo._base.kernel."ioPublish" */

/* TODO: PropertyDeclaration: dojo._base.kernel."preventCache" */

/* TODO: PropertyDeclaration: dojo._base.kernel."rawBody" */

/* TODO: PropertyDeclaration: dojo._base.kernel."sync" */

/* TODO: PropertyDeclaration: dojo._base.kernel."timeout" */

/* TODO: PropertyDeclaration: dojo._base.kernel."url" */

/**
 * This function will
 * be called when the request fails due to a network or server error, the url
 * is invalid, etc. It will also be called if the load or handle callback throws an
 * exception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications
 * to continue to run even when a logic error happens in the callback, while making
 * it easier to troubleshoot while in debug mode.
 * 
 * @param {!Object} response The response in the format as defined with handleAs.
 * @param {!dojo.main.__IoCallbackArgs} ioArgs Provides additional information about the request.
 * @return {void}
 */
dojo._base.kernel.__XhrArgs.prototype.error = function(response, ioArgs) {};

/**
 * This function will
 * be called at the end of every request, whether or not an error occurs.
 * 
 * @param {!String} loadOrError Provides a string that tells you whether this functionwas called because of success (load) or failure (error).
 * @param {!Object} response The response in the format as defined with handleAs.
 * @param {!dojo.main.__IoCallbackArgs} ioArgs Provides additional information about the request.
 * @return {void}
 */
dojo._base.kernel.__XhrArgs.prototype.handle = function(loadOrError, response, ioArgs) {};

/**
 * This function will be
 * called on a successful HTTP response code.
 * 
 * @param {!Object} response The response in the format as defined with handleAs.
 * @param {!dojo.main.__IoCallbackArgs} ioArgs Provides additional information about the request.
 * @return {void}
 */
dojo._base.kernel.__XhrArgs.prototype.load = function(response, ioArgs) {};

/**
 * @constructor
 * @struct
 */
dojo._base.kernel.Stateful = function() {};

/**
 * Get a property on a Stateful instance.
 * Get a named property on a Stateful object. The property may
 * potentially be retrieved via a getter method in subclasses. In the base class
 * this just retrieves the object's property.
 * 
 * @param {!String} name The property to get.
 * @return {?}
 */
dojo._base.kernel.Stateful.prototype.get = function(name) {};

/**
 *
 * @param {!Object=} params               Optional
 * @return {void}
 */
dojo._base.kernel.Stateful.prototype.postscript = function(params) {};

/**
 * Set a property on a Stateful instance
 * Sets named properties on a stateful object and notifies any watchers of
 * the property. A programmatic setter may be defined in subclasses.
 * 
 * @param {!String} name The property to set.
 * @param {!Object} value The value to set in the property.
 * @return {?}
 */
dojo._base.kernel.Stateful.prototype.set = function(name, value) {};

/**
 * Watches a property for changes
 * 
 * @param {string} property
 * @param {function(string, ?, ?): void} callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
 * @return {{unwatch: function(): void}}
 */
dojo._base.kernel.Stateful.prototype.watch = function(property, callback) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel._contentHandlers = function() {};

/**
 *
 * @param {?} xhr
 * @return {void}
 */
dojo._base.kernel._contentHandlers.prototype.auto = function(xhr) {};

/**
 * A contentHandler which evaluates the response data, expecting it to be valid JavaScript
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.kernel._contentHandlers.prototype.javascript = function(xhr) {};

/**
 * A contentHandler which returns a JavaScript object created from the response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.kernel._contentHandlers.prototype.json = function(xhr) {};

/**
 * A contentHandler which expects comment-filtered JSON.
 * A contentHandler which expects comment-filtered JSON.
 * the json-comment-filtered option was implemented to prevent
 * "JavaScript Hijacking", but it is less secure than standard JSON. Use
 * standard JSON instead. JSON prefixing can be used to subvert hijacking.
 * 
 * Will throw a notice suggesting to use application/json mimetype, as
 * json-commenting can introduce security issues. To decrease the chances of hijacking,
 * use the standard json contentHandler, and prefix your "JSON" with: {}&&
 * 
 * use djConfig.useCommentedJson = true to turn off the notice
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.kernel._contentHandlers.prototype.json_comment_filtered = function(xhr) {};

/**
 * A contentHandler which checks the presence of comment-filtered JSON and
 * alternates between the json and json-comment-filtered contentHandlers.
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.kernel._contentHandlers.prototype.json_comment_optional = function(xhr) {};

/**
 *
 * @param {?} xhr
 * @return {void}
 */
dojo._base.kernel._contentHandlers.prototype.olson_zoneinfo = function(xhr) {};

/**
 * A contentHandler which simply returns the plaintext response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.kernel._contentHandlers.prototype.text = function(xhr) {};

/**
 * A contentHandler returning an XML Document parsed from the response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.kernel._contentHandlers.prototype.xml = function(xhr) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel._hasResource = function() {};
/**
 * @record
 * @struct
 */
dojo._base.kernel._nodeDataCache = function() {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.back = function() {};

/**
 * adds a state object (args) to the history list.
 * To support getting back button notifications, the object
 * argument should implement a function called either "back",
 * "backButton", or "handle". The string "back" will be passed as
 * the first and only argument to this callback.
 * 
 * To support getting forward button notifications, the object
 * argument should implement a function called either "forward",
 * "forwardButton", or "handle". The string "forward" will be
 * passed as the first and only argument to this callback.
 * 
 * If you want the browser location string to change, define "changeUrl" on the object. If the
 * value of "changeUrl" is true, then a unique number will be appended to the URL as a fragment
 * identifier (http://some.domain.com/path#uniquenumber). If it is any other value that does
 * not evaluate to false, that value will be used as the fragment identifier. For example,
 * if changeUrl: 'page1', then the URL will look like: http://some.domain.com/path#page1
 * 
 * There are problems with using dojo/back with semantically-named fragment identifiers
 * ("hash values" on an URL). In most browsers it will be hard for dojo/back to know
 * distinguish a back from a forward event in those cases. For back/forward support to
 * work best, the fragment ID should always be a unique value (something using new Date().getTime()
 * for example). If you want to detect hash changes using semantic fragment IDs, then
 * consider using dojo/hash instead (in Dojo 1.4+).
 * 
 * @param {!Object} args The state object that will be added to the history list.
 * @return {void}
 */
dojo._base.kernel.back.prototype.addToHistory = function(args) {};

/**
 *
 * @return {?}
 */
dojo._base.kernel.back.prototype.getHash = function() {};

/**
 * private method. Do not call this directly.
 * 
 * @return {void}
 */
dojo._base.kernel.back.prototype.goBack = function() {};

/**
 * private method. Do not call this directly.
 * 
 * @return {void}
 */
dojo._base.kernel.back.prototype.goForward = function() {};

/**
 * Initializes the undo stack. This must be called from a
 * block that lives inside the <code>&lt;body&gt;</code> tag to prevent bugs on IE.
 * </p>
 * <p>Only call this method before the page&#39;s DOM is finished loading. Otherwise
 * it will not work. Be careful with xdomain loading or djConfig.debugAtAllCosts scenarios,
 * in order for this method to work, dojo/back will need to be part of a build layer.</p>
 * </div>
 *       </div>
 *       <div class="jsdoc-field extension-module">
 *         <div class="jsdoc-title"><a name="1_9dojo__base_kernel_back_setHash"></a><span class="functionIcon">setHash</span><span class="parameters">(h)</span>
 *         </div>
 *         <div class="jsdoc-inheritance">Defined by <a href="/api/1.9/dojo/back" class="jsdoc-link">dojo/back</a><span title="Must manually require () dojo/back to access" class="jsdoc-extension"></span>
 *         </div>
 *         <div class="jsdoc-full-summary"></div>
 *         <table class="jsdoc-parameters">
 *           <tr>
 *             <th>Parameter</th>
 *             <th>Type</th>
 *             <th>Description</th>
 *           </tr>
 *           <tr>
 *             <td class="jsdoc-param-name">h</td>
 *             <td class="jsdoc-param-type">undefined</td>
 *             <td class="jsdoc-param-description">
 *             </td>
 *           </tr>
 *         </table>
 *       </div>
 *       <div class="jsdoc-field extension-module">
 *         <div class="jsdoc-title"><a name="1_9dojo__base_kernel_back_setInitialState"></a><span class="functionIcon">setInitialState</span><span class="parameters">(args)</span>
 *         </div>
 *         <div class="jsdoc-inheritance">Defined by <a href="/api/1.9/dojo/back" class="jsdoc-link">dojo/back</a><span title="Must manually require () dojo/back to access" class="jsdoc-extension"></span>
 *         </div>
 *         <div class="jsdoc-full-summary"><p>Sets the state object and back callback for the very first page
 * that is loaded.
 * </p>
 * <p>It is recommended that you call this method as part of an event
 * listener that is registered via dojo/ready.</p>
 * </div>
 *         <table class="jsdoc-parameters">
 *           <tr>
 *             <th>Parameter</th>
 *             <th>Type</th>
 *             <th>Description</th>
 *           </tr>
 *           <tr>
 *             <td class="jsdoc-param-name">args</td>
 *             <td class="jsdoc-param-type">Object</td>
 *             <td class="jsdoc-param-description"><p>See the addToHistory() function for the list of valid args properties.</p>
 * 
 *             </td>
 *           </tr>
 *         </table>
 *       </div>
 *     </div>
 *   </div>
 * </div><a href="https://docs.google.com/spreadsheet/viewform?hl=en_US&amp;formkey=dFlDcHEyaHMwbEd4MFBObkNrX0E1MFE6MQ&amp;entry_0=/api/1.9/dojo/_base/kernel.back" class="feedback">Error in the documentation? Can't find what you are looking for? Let us know!</a>
 * @return {void}
 */
dojo._base.kernel.back.prototype.init = function() {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.cldr = function() {};
 /** @type {!Object} */
dojo._base.kernel.cldr.prototype.monetary;
 /** @type {!Object} */
dojo._base.kernel.cldr.prototype.supplemental;
/**
 * @record
 * @struct
 */
dojo._base.kernel.colors = function() {};

/**
 * creates a greyscale color with an optional alpha
 * 
 * @param {number} g
 * @param {number=} a               Optional
 * @return {void}
 */
dojo._base.kernel.colors.prototype.makeGrey = function(g, a) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.config = function() {};
 /** @type {!Function} */
dojo._base.kernel.config.prototype.addOnLoad;
 /** @type {boolean} */
dojo._base.kernel.config.prototype.afterOnLoad;
 /** @type {!Object} */
dojo._base.kernel.config.prototype.baseUrl;
 /** @type {!Function} */
dojo._base.kernel.config.prototype.callback;
 /** @type {string} */
dojo._base.kernel.config.prototype.debugContainerId;
 /** @type {number} */
dojo._base.kernel.config.prototype.debugHeight;
 /** @type {number} */
dojo._base.kernel.config.prototype.defaultDuration;
 /** @type {boolean} */
dojo._base.kernel.config.prototype.deferredInstrumentation;
 /** @type {!Function} */
dojo._base.kernel.config.prototype.deps;
 /** @type {string} */
dojo._base.kernel.config.prototype.dojoBlankHtmlUrl;
 /** @type {!Array<?>} */
dojo._base.kernel.config.prototype.extraLocale;
 /** @type {!Object} */
dojo._base.kernel.config.prototype.ioPublish;
 /** @type {boolean} */
dojo._base.kernel.config.prototype.isDebug;
 /** @type {string} */
dojo._base.kernel.config.prototype.locale;
 /** @type {!Object} */
dojo._base.kernel.config.prototype.modulePaths;
 /** @type {boolean} */
dojo._base.kernel.config.prototype.parseOnLoad;
 /** @type {!Object} */
dojo._base.kernel.config.prototype.require;
 /** @type {!Array<?>} */
dojo._base.kernel.config.prototype.transparentColor;
 /** @type {string} */
dojo._base.kernel.config.prototype.urchin;
 /** @type {!Object} */
dojo._base.kernel.config.prototype.useCustomLogger;
 /** @type {boolean} */
dojo._base.kernel.config.prototype.useDeferredInstrumentation;
/**
 * @record
 * @struct
 */
dojo._base.kernel.contentHandlers = function() {};

/**
 *
 * @param {?} xhr
 * @return {void}
 */
dojo._base.kernel.contentHandlers.prototype.auto = function(xhr) {};

/**
 * A contentHandler which evaluates the response data, expecting it to be valid JavaScript
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.kernel.contentHandlers.prototype.javascript = function(xhr) {};

/**
 * A contentHandler which returns a JavaScript object created from the response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.kernel.contentHandlers.prototype.json = function(xhr) {};

/**
 * A contentHandler which expects comment-filtered JSON.
 * A contentHandler which expects comment-filtered JSON.
 * the json-comment-filtered option was implemented to prevent
 * "JavaScript Hijacking", but it is less secure than standard JSON. Use
 * standard JSON instead. JSON prefixing can be used to subvert hijacking.
 * 
 * Will throw a notice suggesting to use application/json mimetype, as
 * json-commenting can introduce security issues. To decrease the chances of hijacking,
 * use the standard json contentHandler, and prefix your "JSON" with: {}&&
 * 
 * use djConfig.useCommentedJson = true to turn off the notice
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.kernel.contentHandlers.prototype.json_comment_filtered = function(xhr) {};

/**
 * A contentHandler which checks the presence of comment-filtered JSON and
 * alternates between the json and json-comment-filtered contentHandlers.
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.kernel.contentHandlers.prototype.json_comment_optional = function(xhr) {};

/**
 *
 * @param {?} xhr
 * @return {void}
 */
dojo._base.kernel.contentHandlers.prototype.olson_zoneinfo = function(xhr) {};

/**
 * A contentHandler which simply returns the plaintext response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.kernel.contentHandlers.prototype.text = function(xhr) {};

/**
 * A contentHandler returning an XML Document parsed from the response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo._base.kernel.contentHandlers.prototype.xml = function(xhr) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.dnd = function() {};
 /** @type {!Object} */
dojo._base.kernel.dnd.prototype.autoscroll;
 /** @type {!Object} */
dojo._base.kernel.dnd.prototype.move;

/**
 *
 * @return {void}
 */
dojo._base.kernel.dnd.prototype.AutoSource = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dnd.prototype.Avatar = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dnd.prototype.Container = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dnd.prototype.Manager = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dnd.prototype.Moveable = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dnd.prototype.Mover = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dnd.prototype.Selector = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dnd.prototype.Source = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dnd.prototype.Target = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dnd.prototype.TimedMoveable = function() {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.date = function() {};
 /** @type {!Object} */
dojo._base.kernel.date.prototype.stamp;

/**
 * Add to a Date in intervals of different size, from milliseconds to years
 * 
 * @param {!Date} date Date object to start with
 * @param {!String} interval A string representing the interval.  One of the following:"year", "month", "day", "hour", "minute", "second","millisecond", "quarter", "week", "weekday"
 * @param {number} amount How much to add to the date.
 * @return {?}
 */
dojo._base.kernel.date.prototype.add = function(date, interval, amount) {};

/**
 * Compare two date objects by date, time, or both.
 * Returns 0 if equal, positive if a > b, else negative.
 * 
 * @param {!Date} date1 Date object
 * @param {!Date=} date2               OptionalDate object.  If not specified, the current Date is used.
 * @param {!String=} portion               OptionalA string indicating the "date" or "time" portion of a Date object.Compares both "date" and "time" by default.  One of the following:"date", "time", "datetime"
 * @return {number}
 */
dojo._base.kernel.date.prototype.compare = function(date1, date2, portion) {};

/**
 * Get the difference in a specific unit of time (e.g., number of
 * months, weeks, days, etc.) between two dates, rounded to the
 * nearest integer.
 * 
 * @param {!Date} date1 Date object
 * @param {!Date=} date2               OptionalDate object.  If not specified, the current Date is used.
 * @param {!String=} interval               OptionalA string representing the interval.  One of the following:"year", "month", "day", "hour", "minute", "second","millisecond", "quarter", "week", "weekday"Defaults to "day".
 * @return {?}
 */
dojo._base.kernel.date.prototype.difference = function(date1, date2, interval) {};

/**
 * Returns the number of days in the month used by dateObject
 * 
 * @param {!Date} dateObject
 * @return {number}
 */
dojo._base.kernel.date.prototype.getDaysInMonth = function(dateObject) {};

/**
 * Get the user's time zone as provided by the browser
 * Try to get time zone info from toString or toLocaleString method of
 * the Date object -- UTC offset is not a time zone.  See
 * http://www.twinsun.com/tz/tz-link.htm Note: results may be
 * inconsistent across browsers.
 * 
 * @param {!Date} dateObject Needed because the timezone may vary with time (daylight savings)
 * @return {?}
 */
dojo._base.kernel.date.prototype.getTimezoneName = function(dateObject) {};

/**
 * Determines if the year of the dateObject is a leap year
 * Leap years are years with an additional day YYYY-02-29, where the
 * year number is a multiple of four with the following exception: If
 * a year is a multiple of 100, then it is only a leap year if it is
 * also a multiple of 400. For example, 1900 was not a leap year, but
 * 2000 is one.
 * 
 * @param {!Date} dateObject
 * @return {boolean}
 */
dojo._base.kernel.date.prototype.isLeapYear = function(dateObject) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.doc = function() {};
 /** @type {!Object} */
dojo._base.kernel.doc.prototype.documentElement;
 /** @type {boolean} */
dojo._base.kernel.doc.prototype.dojoClick;
/**
 * @record
 * @struct
 */
dojo._base.kernel.data = function() {};
 /** @type {!Object} */
dojo._base.kernel.data.prototype.api;
 /** @type {!Object} */
dojo._base.kernel.data.prototype.util;

/**
 *
 * @return {void}
 */
dojo._base.kernel.data.prototype.ItemFileReadStore = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.data.prototype.ItemFileWriteStore = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.data.prototype.ObjectStore = function() {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.currency = function() {};

/**
 * Format a Number as a currency, using locale-specific settings
 * Create a string from a Number using a known, localized pattern.
 * Formatting patterns
 * appropriate to the locale are chosen from the CLDR
 * as well as the appropriate symbols and delimiters and number of decimal places.
 * 
 * @param {number} value the number to be formatted.
 * @param {!dojo.currency.__FormatOptions} options               Optional
 * @return {?}
 */
dojo._base.kernel.currency.prototype.format = function(value, options) {};

/**
 *
 * @param {!String} expression
 * @param {!Object=} options               OptionalAn object with the following properties:type (String, optional): Should not be set.  Value is assumed to be currency.currency (String, optional): an ISO4217 currency code, a three letter sequence like "USD".For use with dojo.currency only.symbol (String, optional): localized currency symbol. The default will be looked up in table of supported currencies in dojo.cldrA ISO4217 currency code will be used if not found.places (Number, optional): fixed number of decimal places to accept.  The default is determined based on which currency is used.fractional (Boolean|Array, optional): Whether to include the fractional portion, where the number of decimal places are implied by the currencyor explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.By default for currencies, it the fractional portion is optional.pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.  Literal characters in patterns are not supported.locale (String, optional): override the locale used to determine formatting rulesstrict (Boolean, optional): strict parsing, false by default.  Strict parsing requires input as produced by the format() method.Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
 * @return {?}
 */
dojo._base.kernel.currency.prototype.parse = function(expression, options) {};

/**
 *
 * @param {!Object} options               OptionalAn object with the following properties:pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.type (String, optional): choose a format type based on the locale from the following:decimal, scientific (not yet supported), percent, currency. decimal by default.locale (String, optional): override the locale used to determine formatting rulesstrict (Boolean, optional): strict parsing, false by default.  Strict parsing requires input as produced by the format() method.Non-strict is more permissive, e.g. flexible on white space, omitting thousands separatorsplaces (Number|String, optional): number of decimal places to accept: Infinity, a positive number, ora range "n,m".  Defined by pattern or Infinity if pattern not provided.
 * @return {?}
 */
dojo._base.kernel.currency.prototype.regexp = function(options) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.dijit = function() {};
 /** @type {!Object} */
dojo._base.kernel.dijit.prototype.form;
 /** @type {!Object} */
dojo._base.kernel.dijit.prototype.layout;
 /** @type {!Object} */
dojo._base.kernel.dijit.prototype.range;
 /** @type {!Object} */
dojo._base.kernel.dijit.prototype.registry;
 /** @type {!Object} */
dojo._base.kernel.dijit.prototype.tree;

/**
 *
 * @param {?} id
 * @return {?}
 */
dojo._base.kernel.dijit.prototype.byId = function(id) {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.Calendar = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.CalendarLite = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.CheckedMenuItem = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.ColorPalette = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.Declaration = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.Destroyable = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.Dialog = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.DialogUnderlay = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.DropDownMenu = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.Dye = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.Editor = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.Fieldset = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.InlineEditBox = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.Menu = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.MenuBar = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.MenuBarItem = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.MenuItem = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.MenuSeparator = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.PopupMenuBarItem = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.PopupMenuItem = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.ProgressBar = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.RadioButtonMenuItem = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.TitlePane = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.Toolbar = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.ToolbarSeparator = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.Tooltip = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.TooltipDialog = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.Tree = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.dijit.prototype.WidgetSet = function() {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.global = function() {};

/**
 *
 * @return {?}
 */
dojo._base.kernel.global.prototype.$ = function() {};

/**
 *
 * @param {?} start
 * @param {?} data
 * @param {?} responseCode
 * @param {?} errorMsg
 * @return {void}
 */
dojo._base.kernel.global.prototype.GoogleSearchStoreCallback_undefined_NaN = function(start, data, responseCode, errorMsg) {};

/**
 *
 * @return {?}
 */
dojo._base.kernel.global.prototype.jQuery = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.global.prototype.swfIsInHTML = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.global.prototype.undefined_onload = function() {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.gears = function() {};
 /** @type {!Object} */
dojo._base.kernel.gears.prototype.available;
/**
 * @record
 * @struct
 */
dojo._base.kernel.fx = function() {};
 /** @type {!Object} */
dojo._base.kernel.fx.prototype.easing;

/**
 * Chain a list of dojo/_base/fx.Animations to run in sequence
 * Return a dojo/_base/fx.Animation which will play all passed
 * dojo/_base/fx.Animation instances in sequence, firing its own
 * synthesized events simulating a single animation. (eg:
 * onEnd of this animation means the end of the chain,
 * not the individual animations within)
 * 
 * @param {!Array<!dojo._base.fx.Animation>} animations
 * @return {?}
 */
dojo._base.kernel.fx.prototype.chain = function(animations) {};

/**
 * Combine a list of dojo/_base/fx.Animations to run in parallel
 * Combine an array of dojo/_base/fx.Animations to run in parallel,
 * providing a new dojo/_base/fx.Animation instance encompasing each
 * animation, firing standard animation events.
 * 
 * @param {!Array<!dojo._base.fx.Animation>} animations
 * @return {?}
 */
dojo._base.kernel.fx.prototype.combine = function(animations) {};

/**
 * Slide a node to a new top/left position
 * Returns an animation that will slide "node"
 * defined in args Object from its current position to
 * the position defined by (args.left, args.top).
 * 
 * @param {!Object} args A hash-map of standard dojo/_base/fx.Animation constructor properties(such as easing: node: duration: and so on). Special args membersare top and left, which indicate the new position to slide to.
 * @return {?}
 */
dojo._base.kernel.fx.prototype.slideTo = function(args) {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.fx.prototype.Toggler = function() {};

/**
 * Expand a node to it's natural height.
 * Returns an animation that will expand the
 * node defined in 'args' object from it's current height to
 * it's natural height (with no scrollbar).
 * Node must have no margin/border/padding.
 * 
 * @param {!Object} args A hash-map of standard dojo/_base/fx.Animation constructor properties(such as easing: node: duration: and so on)
 * @return {?}
 */
dojo._base.kernel.fx.prototype.wipeIn = function(args) {};

/**
 * Shrink a node to nothing and hide it.
 * Returns an animation that will shrink node defined in "args"
 * from it's current height to 1px, and then hide it.
 * 
 * @param {!Object} args A hash-map of standard dojo/_base/fx.Animation constructor properties(such as easing: node: duration: and so on)
 * @return {?}
 */
dojo._base.kernel.fx.prototype.wipeOut = function(args) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.html = function() {};

/**
 * inserts (replaces) the given content into the given node. dojo/dom-construct.place(cont, node, "only")
 * may be a better choice for simple HTML insertion.
 * Unless you need to use the params capabilities of this method, you should use
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct..place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct..place does not handle NodeList insertions
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct.place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct.place does not handle NodeList insertions
 * or the other capabilities as defined by the params object for this method.
 * 
 * inserts (replaces) the given content into the given node. dojo/dom-construct.place(cont, node, "only")
 * may be a better choice for simple HTML insertion.
 * Unless you need to use the params capabilities of this method, you should use
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct..place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct..place does not handle NodeList insertions
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct.place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct.place does not handle NodeList insertions
 * or the other capabilities as defined by the params object for this method.
 * 
 * inserts (replaces) the given content into the given node. dojo/dom-construct.place(cont, node, "only")
 * may be a better choice for simple HTML insertion.
 * Unless you need to use the params capabilities of this method, you should use
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct..place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct..place does not handle NodeList insertions
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct.place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct.place does not handle NodeList insertions
 * or the other capabilities as defined by the params object for this method.
 * 
 * @param {!HTMLElement} node the parent element that will receive the content
 * @param {!String|!HTMLElement|!dojo._base.NodeList} cont the content to be set on the parent element.This can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes
 * @param {!Object=} params               OptionalOptional flags/properties to configure the content-setting. See dojo/html/_ContentSetter
 * @return {?}
 */
dojo._base.kernel.html.prototype.set = function(node, cont, params) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.io = function() {};
 /** @type {!Object} */
dojo._base.kernel.io.prototype.iframe;
 /** @type {!Object} */
dojo._base.kernel.io.prototype.script;
/**
 * @record
 * @struct
 */
dojo._base.kernel.dojox = function() {};
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.analytics;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.app;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.atom;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.av;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.BidiComplex;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.calc;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.calendar;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.charting;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.collections;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.color;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.css3;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.data;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.date;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.dgauges;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.dnd;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.drawing;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.dtl;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.editor;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.embed;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.encoding;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.enhanced;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.flash;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.form;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.fx;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.gantt;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.gauges;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.geo;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.gesture;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.gfx;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.gfx3d;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.grid;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.help;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.highlight;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.html;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.image;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.io;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.jq;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.json;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.jsonPath;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.lang;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.layout;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.math;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.mdnd;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.mobile;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.mvc;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.openlayers;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.rails;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.robot;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.rpc;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.secure;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.sketch;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.sql;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.string;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.testing;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.timing;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.treemap;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.uuid;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.validate;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.widget;
 /** @type {!Object} */
dojo._base.kernel.dojox.prototype.xml;

/**
 * Provides a simple socket connection using WebSocket, or alternate
 * communication mechanisms in legacy browsers for comet-style communication. This is based
 * on the WebSocket API and returns an object that implements the WebSocket interface:
 * http://dev.w3.org/html5/websockets/#websocket
 * Provides socket connections. This can be used with virtually any Comet protocol.
 * 
 * @param {!Object} argsOrUrl This uses the same arguments as the other I/O functions in Dojo, or aURL to connect to. The URL should be a relative URL in order to properlywork with WebSockets (it can still be host relative, like //other-site.org/endpoint)
 * @return {?}
 */
dojo._base.kernel.dojox.prototype.socket = function(argsOrUrl) {};

/**
 *
 * @param {!String} format
 * @param {?} filler
 * @return {void}
 */
dojo._base.kernel.dojox.prototype.sprintf = function(format, filler) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.i18n = function() {};
 /** @type {!Object} */
dojo._base.kernel.i18n.prototype.cache;
 /** @type {boolean} */
dojo._base.kernel.i18n.prototype.dynamic;
 /** @type {!Array<?>} */
dojo._base.kernel.i18n.prototype.unitTests;

/**
 *
 * @param {?} moduleName
 * @param {?} bundleName
 * @param {?} locale
 * @return {!String}
 */
dojo._base.kernel.i18n.prototype.getL10nName = function(moduleName, bundleName, locale) {};

/**
 *
 * @param {?} moduleName
 * @param {?} bundleName
 * @param {?} locale
 * @return {?}
 */
dojo._base.kernel.i18n.prototype.getLocalization = function(moduleName, bundleName, locale) {};

/**
 * id is in one of the following formats
 * 
 * /nls/
 *  => load the bundle, localized to config.locale; load all bundles localized to
 *  config.extraLocale (if any); return the loaded bundle localized to config.locale.
 * /nls//
 *  => load then return the bundle localized to
 * preload/nls//
 *  => for config.locale and all config.extraLocale, load all bundles found
 *  in the best-matching bundle rollup. A value of 1 is returned, which
 *  is meaningless other than to say the plugin is executing the requested
 *  preloads
 * 
 * In cases 1 and 2,  is always normalized to an absolute module id upon entry; see
 * normalize. In case 3, it  is assumed to be absolute; this is arranged by the builder.
 * 
 * To load a bundle means to insert the bundle into the plugin's cache and publish the bundle
 * value to the loader. Given , , and a particular , the cache key
 * 
 * <path>/nls/<bundle>/<locale>
 * will hold the value. Similarly, then plugin will publish this value to the loader by
 * 
 * define("<path>/nls/<bundle>/<locale>", <bundle-value>);
 * Given this algorithm, other machinery can provide fast load paths be preplacing
 * values in the plugin's cache, which is public. When a load is demanded the
 * cache is inspected before starting any loading. Explicitly placing values in the plugin
 * cache is an advanced/experimental feature that should not be needed; use at your own risk.
 * 
 * For the normal AMD algorithm, the root bundle is loaded first, which instructs the
 * plugin what additional localized bundles are required for a particular locale. These
 * additional locales are loaded and a mix of the root and each progressively-specific
 * locale is returned. For example:
 * 
 * The client demands "dojo/i18n!some/path/nls/someBundle
 * The loader demands load(some/path/nls/someBundle)
 * This plugin require's "some/path/nls/someBundle", which is the root bundle.
 * Assuming config.locale is "ab-cd-ef" and the root bundle indicates that localizations
 * are available for "ab" and "ab-cd-ef" (note the missing "ab-cd", then the plugin
 * requires "some/path/nls/ab/someBundle" and "some/path/nls/ab-cd-ef/someBundle"
 * Upon receiving all required bundles, the plugin constructs the value of the bundle
 * ab-cd-ef as...
 *  mixin(mixin(mixin({}, require("some/path/nls/someBundle"),
 *      require("some/path/nls/ab/someBundle")),
 *      require("some/path/nls/ab-cd-ef/someBundle"));
 * 
 * This value is inserted into the cache and published to the loader at the
 * key/module-id some/path/nls/someBundle/ab-cd-ef.
 * 
 * The special preload signature (case 3) instructs the plugin to stop servicing all normal requests
 * (further preload requests will be serviced) until all ongoing preloading has completed.
 * 
 * The preload signature instructs the plugin that a special rollup module is available that contains
 * one or more flattened, localized bundles. The JSON array of available locales indicates which locales
 * are available. Here is an example:
 * 
 * *preload*some/path/nls/someModule*["root", "ab", "ab-cd-ef"]
 * This indicates the following rollup modules are available:
 * 
 * some/path/nls/someModule_ROOT
 * some/path/nls/someModule_ab
 * some/path/nls/someModule_ab-cd-ef
 * Each of these modules is a normal AMD module that contains one or more flattened bundles in a hash.
 * For example, assume someModule contained the bundles some/bundle/path/someBundle and
 * some/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:
 * 
 * define({
 *     some/bundle/path/someBundle:<value of someBundle, flattened with respect to locale ab>,
 *     some/bundle/path/someOtherBundle:<value of someOtherBundle, flattened with respect to locale ab>,
 * });
 * E.g., given this design, preloading for locale=="ab" can execute the following algorithm:
 * 
 * require(["some/path/nls/someModule_ab"], function(rollup){
 *     for(var p in rollup){
 *         var id = p + "/ab",
 *         cache[id] = rollup[p];
 *         define(id, rollup[p]);
 *     }
 * });
 * Similarly, if "ab-cd" is requested, the algorithm can determine that "ab" is the best available and
 * load accordingly.
 * 
 * The builder will write such rollups for every layer if a non-empty localeList  profile property is
 * provided. Further, the builder will include the following cache entry in the cache associated with
 * any layer.
 * 
 * "*now":function(r){r(['dojo/i18n!*preload*<path>/nls/<module>*<JSON array of available locales>']);}
 * The *now special cache module instructs the loader to apply the provided function to context-require
 * with respect to the particular layer being defined. This causes the plugin to hold all normal service
 * requests until all preloading is complete.
 * 
 * Notice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case
 * where the target locale has a single segment and a layer depends on a single bundle:
 * 
 * Without Preloads:
 * 
 * Layer loads root bundle.
 * bundle is demanded; plugin loads single localized bundle.
 * With Preloads:
 * 
 * Layer causes preloading of target bundle.
 * bundle is demanded; service is delayed until preloading complete; bundle is returned.
 * In each case a single transaction is required to load the target bundle. In cases where multiple bundles
 * are required and/or the locale has multiple segments, preloads still requires a single transaction whereas
 * the normal path requires an additional transaction for each additional bundle/locale-segment. However all
 * of these additional transactions can be done concurrently. Owing to this analysis, the entire preloading
 * algorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.
 * 
 * @param {?} id
 * @param {?} require
 * @param {?} load
 * @return {void}
 */
dojo._base.kernel.i18n.prototype.load = function(id, require, load) {};

/**
 * id may be relative.
 * preload has form *preload*<path>/nls/<module>*<flattened locales> and
 * therefore never looks like a relative
 * 
 * @param {?} id
 * @param {?} toAbsMid
 * @return {?}
 */
dojo._base.kernel.i18n.prototype.normalize = function(id, toAbsMid) {};

/**
 *
 * @param {?} locale
 * @return {?}
 */
dojo._base.kernel.i18n.prototype.normalizeLocale = function(locale) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.mouseButtons = function() {};
 /** @type {number} */
dojo._base.kernel.mouseButtons.prototype.LEFT;
 /** @type {number} */
dojo._base.kernel.mouseButtons.prototype.MIDDLE;
 /** @type {number} */
dojo._base.kernel.mouseButtons.prototype.RIGHT;

/**
 * Checks an event object for a pressed button
 * 
 * @param {!Event} e Event object to examine
 * @param {number} button The button value (example: dojo.mouseButton.LEFT)
 * @return {boolean}
 */
dojo._base.kernel.mouseButtons.prototype.isButton = function(e, button) {};

/**
 * Checks an event object for the pressed left button
 * 
 * @param {!Event} e Event object to examine
 * @return {boolean}
 */
dojo._base.kernel.mouseButtons.prototype.isLeft = function(e) {};

/**
 * Checks an event object for the pressed middle button
 * 
 * @param {!Event} e Event object to examine
 * @return {boolean}
 */
dojo._base.kernel.mouseButtons.prototype.isMiddle = function(e) {};

/**
 * Checks an event object for the pressed right button
 * 
 * @param {!Event} e Event object to examine
 * @return {boolean}
 */
dojo._base.kernel.mouseButtons.prototype.isRight = function(e) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.rpc = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.rpc.prototype.JsonpService = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.rpc.prototype.JsonService = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.rpc.prototype.RpcService = function() {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.regexp = function() {};

/**
 * Builds a regular expression that groups subexpressions
 * A utility function used by some of the RE generators. The
 * subexpressions are constructed by the function, re, in the second
 * parameter.  re builds one subexpression for each elem in the array
 * a, in the first parameter. Returns a string for a regular
 * expression that groups all the subexpressions.
 * 
 * Builds a regular expression that groups subexpressions
 * A utility function used by some of the RE generators. The
 * subexpressions are constructed by the function, re, in the second
 * parameter.  re builds one subexpression for each elem in the array
 * a, in the first parameter. Returns a string for a regular
 * expression that groups all the subexpressions.
 * 
 * @param {!Object|!Array<?>} arr A single value or an array of values.
 * @param {!Function} re A function. Takes one parameter and converts it to a regularexpression.
 * @param {boolean=} nonCapture               OptionalIf true, uses non-capturing match, otherwise matches are retainedby regular expression. Defaults to false
 * @return {?}
 */
dojo._base.kernel.regexp.prototype.buildGroupRE = function(arr, re, nonCapture) {};

/**
 * Adds escape sequences for special characters in regular expressions
 * 
 * @param {!String} str
 * @param {!String=} except               Optionala String with special characters to be left unescaped
 * @return {?}
 */
dojo._base.kernel.regexp.prototype.escapeString = function(str, except) {};

/**
 * adds group match to expression
 * 
 * @param {!String} expression
 * @param {boolean=} nonCapture               OptionalIf true, uses non-capturing match, otherwise matches are retainedby regular expression.
 * @return {!String}
 */
dojo._base.kernel.regexp.prototype.group = function(expression, nonCapture) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.number_ = function() {};

/**
 * Format a Number as a String, using locale-specific settings
 * Create a string from a Number using a known localized pattern.
 * Formatting patterns appropriate to the locale are chosen from the
 * Common Locale Data Repository as well as the appropriate symbols and
 * delimiters.
 * If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.
 * 
 * @param {number} value the number to be formatted
 * @param {!Object=} options               OptionalAn object with the following properties:pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.  Literal characters in patterns are not supported.type (String, optional): choose a format type based on the locale from the following:decimal, scientific (not yet supported), percent, currency. decimal by default.places (Number, optional): fixed number of decimal places to show.  This overrides anyinformation in the provided pattern.round (Number, optional): 5 rounds to nearest .5; 0 rounds to nearest whole (default). -1means do not round.locale (String, optional): override the locale used to determine formatting rulesfractional (Boolean, optional): If false, show no decimal places, overriding places and pattern settings.
 * @return {?}
 */
dojo._base.kernel.number_.prototype.format = function(value, options) {};

/**
 * Convert a properly formatted string to a primitive Number, using
 * locale-specific settings.
 * Create a Number from a string using a known localized pattern.
 * Formatting patterns are chosen appropriate to the locale
 * and follow the syntax described by
 * unicode.org TR35
 * Note that literal characters in patterns are not supported.
 * 
 * @param {!String} expression A string representation of a Number
 * @param {!Object=} options               OptionalAn object with the following properties:pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.  Literal characters in patterns are not supported.type (String, optional): choose a format type based on the locale from the following:decimal, scientific (not yet supported), percent, currency. decimal by default.locale (String, optional): override the locale used to determine formatting rulesstrict (Boolean, optional): strict parsing, false by default.  Strict parsing requires input as produced by the format() method.Non-strict is more permissive, e.g. flexible on white space, omitting thousands separatorsfractional (Boolean|Array, optional): Whether to include the fractional portion, where the number of decimal places are implied by patternor explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.
 * @return {number}
 */
dojo._base.kernel.number_.prototype.parse = function(expression, options) {};

/**
 * Builds the regular needed to parse a number
 * Returns regular expression with positive and negative match, group
 * and decimal separators
 * 
 * @param {!Object} options               OptionalAn object with the following properties:pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.type (String, optional): choose a format type based on the locale from the following:decimal, scientific (not yet supported), percent, currency. decimal by default.locale (String, optional): override the locale used to determine formatting rulesstrict (Boolean, optional): strict parsing, false by default.  Strict parsing requires input as produced by the format() method.Non-strict is more permissive, e.g. flexible on white space, omitting thousands separatorsplaces (Number|String, optional): number of decimal places to accept: Infinity, a positive number, ora range "n,m".  Defined by pattern or Infinity if pattern not provided.
 * @return {?}
 */
dojo._base.kernel.number_.prototype.regexp = function(options) {};

/**
 * Rounds to the nearest value with the given number of decimal places, away from zero
 * Rounds to the nearest value with the given number of decimal places, away from zero if equal.
 * Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
 * fractional increments also, such as the nearest quarter.
 * NOTE: Subject to floating point errors.  See dojox/math/round for experimental workaround.
 * 
 * @param {number} value The number to round
 * @param {number=} places               OptionalThe number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.Must be non-negative.
 * @param {number=} increment               OptionalRounds next place to nearest value of increment/10.  10 by default.
 * @return {number}
 */
dojo._base.kernel.number_.prototype.round = function(value, places, increment) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.scopeMap = function() {};
 /** @type {!Array<?>} */
dojo._base.kernel.scopeMap.prototype.dijit;
 /** @type {!Array<?>} */
dojo._base.kernel.scopeMap.prototype.dojo;
 /** @type {!Array<?>} */
dojo._base.kernel.scopeMap.prototype.dojox;
/**
 * @record
 * @struct
 */
dojo._base.kernel.tests = function() {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.keys = function() {};
 /** @type {number} */
dojo._base.kernel.keys.prototype.ALT;
 /** @type {number} */
dojo._base.kernel.keys.prototype.BACKSPACE;
 /** @type {number} */
dojo._base.kernel.keys.prototype.CAPS_LOCK;
 /** @type {number} */
dojo._base.kernel.keys.prototype.CLEAR;
 /** @type {number} */
dojo._base.kernel.keys.prototype.copyKey;
 /** @type {number} */
dojo._base.kernel.keys.prototype.CTRL;
 /** @type {number} */
dojo._base.kernel.keys.prototype.DELETE;
 /** @type {number} */
dojo._base.kernel.keys.prototype.DOWN_ARROW;
 /** @type {number} */
dojo._base.kernel.keys.prototype.DOWN_DPAD;
 /** @type {number} */
dojo._base.kernel.keys.prototype.END;
 /** @type {number} */
dojo._base.kernel.keys.prototype.ENTER;
 /** @type {number} */
dojo._base.kernel.keys.prototype.ESCAPE;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F1;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F10;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F11;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F12;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F13;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F14;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F15;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F2;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F3;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F4;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F5;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F6;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F7;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F8;
 /** @type {number} */
dojo._base.kernel.keys.prototype.F9;
 /** @type {number} */
dojo._base.kernel.keys.prototype.HELP;
 /** @type {number} */
dojo._base.kernel.keys.prototype.HOME;
 /** @type {number} */
dojo._base.kernel.keys.prototype.INSERT;
 /** @type {number} */
dojo._base.kernel.keys.prototype.LEFT_ARROW;
 /** @type {number} */
dojo._base.kernel.keys.prototype.LEFT_DPAD;
 /** @type {number} */
dojo._base.kernel.keys.prototype.LEFT_WINDOW;
 /** @type {number} */
dojo._base.kernel.keys.prototype.META;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUM_LOCK;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_0;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_1;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_2;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_3;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_4;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_5;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_6;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_7;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_8;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_9;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_DIVIDE;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_ENTER;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_MINUS;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_MULTIPLY;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_PERIOD;
 /** @type {number} */
dojo._base.kernel.keys.prototype.NUMPAD_PLUS;
 /** @type {number} */
dojo._base.kernel.keys.prototype.PAGE_DOWN;
 /** @type {number} */
dojo._base.kernel.keys.prototype.PAGE_UP;
 /** @type {number} */
dojo._base.kernel.keys.prototype.PAUSE;
 /** @type {number} */
dojo._base.kernel.keys.prototype.RIGHT_ARROW;
 /** @type {number} */
dojo._base.kernel.keys.prototype.RIGHT_DPAD;
 /** @type {number} */
dojo._base.kernel.keys.prototype.RIGHT_WINDOW;
 /** @type {number} */
dojo._base.kernel.keys.prototype.SCROLL_LOCK;
 /** @type {number} */
dojo._base.kernel.keys.prototype.SELECT;
 /** @type {number} */
dojo._base.kernel.keys.prototype.SHIFT;
 /** @type {number} */
dojo._base.kernel.keys.prototype.SPACE;
 /** @type {number} */
dojo._base.kernel.keys.prototype.TAB;
 /** @type {number} */
dojo._base.kernel.keys.prototype.UP_ARROW;
 /** @type {number} */
dojo._base.kernel.keys.prototype.UP_DPAD;
/**
 * @record
 * @struct
 */
dojo._base.kernel.store = function() {};
 /** @type {!Object} */
dojo._base.kernel.store.prototype.util;

/**
 *
 * @param {?} masterStore
 * @param {?} cachingStore
 * @param {?} options
 * @return {?}
 */
dojo._base.kernel.store.prototype.Cache = function(masterStore, cachingStore, options) {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.store.prototype.DataStore = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.store.prototype.JsonRest = function() {};

/**
 *
 * @return {void}
 */
dojo._base.kernel.store.prototype.Memory = function() {};

/**
 * The Observable store wrapper takes a store and sets an observe method on query()
 * results that can be used to monitor results for changes.
 * Observable wraps an existing store so that notifications can be made when a query
 * is performed.
 * 
 * @param {!dojo.store.api.Store} store
 * @return {?}
 */
dojo._base.kernel.store.prototype.Observable = function(store) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.string_ = function() {};

/**
 * Pad a string to guarantee that it is at least size length by
 * filling with the character ch at either the start or end of the
 * string. Pads at the start, by default.
 * 
 * @param {!String} text the string to pad
 * @param {number} size length to provide padding
 * @param {!String=} ch               Optionalcharacter to pad, defaults to '0'
 * @param {boolean=} end               Optionaladds padding at the end if true, otherwise pads at start
 * @return {number}
 */
dojo._base.kernel.string_.prototype.pad = function(text, size, ch, end) {};

/**
 * Efficiently replicate a string n times.
 * 
 * @param {!String} str the string to replicate
 * @param {number} num number of times to replicate the string
 * @return {!String}
 */
dojo._base.kernel.string_.prototype.rep = function(str, num) {};

/**
 * Performs parameterized substitutions on a string. Throws an
 * exception if any parameter is unmatched.
 * 
 * Performs parameterized substitutions on a string. Throws an
 * exception if any parameter is unmatched.
 * 
 * @param {!String} template a string with expressions in the form ${key} to be replaced or${key:format} which specifies a format function. keys are case-sensitive.
 * @param {!Object|!Array<?>} map hash to search for substitutions
 * @param {!Function=} transform               Optionala function to process all parameters before substitution takesplace, e.g. mylib.encodeXML
 * @param {!Object=} thisObject               Optionalwhere to look for optional format function; default to the globalnamespace
 * @return {?}
 */
dojo._base.kernel.string_.prototype.substitute = function(template, map, transform, thisObject) {};

/**
 * Trims whitespace from both sides of the string
 * This version of trim() was taken from Steven Levithan's blog.
 * The short yet performant version of this function is dojo/_base/lang.trim(),
 * which is part of Dojo base.  Uses String.prototype.trim instead, if available.
 * 
 * @param {!String} str String to be trimmed
 * @return {!String}
 */
dojo._base.kernel.string_.prototype.trim = function(str) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.version = function() {};
 /** @type {string} */
dojo._base.kernel.version.prototype.flag;
 /** @type {number} */
dojo._base.kernel.version.prototype.major;
 /** @type {number} */
dojo._base.kernel.version.prototype.minor;
 /** @type {number} */
dojo._base.kernel.version.prototype.patch;
 /** @type {number} */
dojo._base.kernel.version.prototype.revision;

/**
 *
 * @return {!String}
 */
dojo._base.kernel.version.prototype.toString = function() {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.touch = function() {};

/**
 * Register a listener to 'touchcancel'|'mouseleave' for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo._base.kernel.touch.prototype.cancel = function(node, listener) {};

/**
 * Register a listener to mouse.enter or touch equivalent for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo._base.kernel.touch.prototype.enter = function(node, listener) {};

/**
 * Register a listener to mouse.leave or touch equivalent for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo._base.kernel.touch.prototype.leave = function(node, listener) {};

/**
 * Register a listener that fires when the mouse cursor or a finger is dragged over the given node.
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo._base.kernel.touch.prototype.move = function(node, listener) {};

/**
 * Register a listener to 'mouseout' or touch equivalent for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo._base.kernel.touch.prototype.out = function(node, listener) {};

/**
 * Register a listener to 'mouseover' or touch equivalent for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo._base.kernel.touch.prototype.over = function(node, listener) {};

/**
 * Register a listener to 'touchstart'|'mousedown' for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo._base.kernel.touch.prototype.press = function(node, listener) {};

/**
 * Register a listener to releasing the mouse button while the cursor is over the given node
 * (i.e. "mouseup") or for removing the finger from the screen while touching the given node.
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo._base.kernel.touch.prototype.release = function(node, listener) {};
/**
 * @record
 * @struct
 */
dojo._base.kernel.window = function() {};

/**
 * Get window object associated with document doc.
 * 
 * @param {!HTMLDocument} doc The document to get the associated window for.
 * @return {?}
 */
dojo._base.kernel.window.prototype.get = function(doc) {};

/**
 * Returns the dimensions and scroll position of the viewable area of a browser window
 * 
 * @param {!HTMLDocument=} doc               Optional
 * @return {!Object}
 */
dojo._base.kernel.window.prototype.getBox = function(doc) {};

/**
 * Scroll the passed node into view using minimal movement, if it is not already.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} pos               Optional
 * @return {void}
 */
dojo._base.kernel.window.prototype.scrollIntoView = function(node, pos) {};
/** @const */
dojo._firebug = {};
/** @const */
dojo._firebug.firebug = {};
/** @const */
dojo.cldr = {};
/**
 * @record
 * @struct
 */
dojo.cldr.monetary = function() {};

/**
 * A mapping of currency code to currency-specific formatting information. Returns a unique object with properties: places, round.
 * 
 * @param {!String} code an ISO 4217 currency code
 * @return {!Object}
 */
dojo.cldr.monetary.prototype.getData = function(code) {};
/**
 * @record
 * @struct
 */
dojo.cldr.supplemental = function() {};

/**
 * Returns a zero-based index for first day of the week
 * Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
 * e.g. Sunday (returns 0), or Monday (returns 1)
 * 
 * @param {!String=} locale               Optional
 * @return {number}
 */
dojo.cldr.supplemental.prototype.getFirstDayOfWeek = function(locale) {};

/**
 * Returns a hash containing the start and end days of the weekend
 * Returns a hash containing the start and end days of the weekend according to local custom using locale,
 * or by default in the user's locale.
 * e.g. {start:6, end:0}
 * 
 * @param {!String=} locale               Optional
 * @return {!Object}
 */
dojo.cldr.supplemental.prototype.getWeekend = function(locale) {};
/** @const */
dojo.data = {};

/**
 * @constructor
 * @struct
 * @param {!Object} keywordParameters
 */
dojo.data.ItemFileReadStore = function(keywordParameters) {};

/* TODO: PropertyDeclaration: dojo.data."clearOnClose" */

/* TODO: PropertyDeclaration: dojo.data."data" */

/* TODO: PropertyDeclaration: dojo.data."failOk" */

/* TODO: PropertyDeclaration: dojo.data."hierarchical" */

/* TODO: PropertyDeclaration: dojo.data."typeMap" */

/* TODO: PropertyDeclaration: dojo.data."url" */

/* TODO: PropertyDeclaration: dojo.data."urlPreventCache" */

/**
 * See dojo/data/api/Read.close()
 * 
 * See dojo/data/api/Read.close()
 * 
 * @param {!dojo.data.api.Request|!Object=} request               Optional
 * @return {void}
 */
dojo.data.ItemFileReadStore.prototype.close = function(request) {};

/**
 * See dojo/data/api/Read.containsValue()
 * 
 * @param {!dojo.data.api.Item} item
 * @param {!String} attribute
 * @param {?} value
 * @return {?}
 */
dojo.data.ItemFileReadStore.prototype.containsValue = function(item, attribute, value) {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.data.ItemFileReadStore.prototype.emit = function(type, event) {};

/**
 * The error handler when there is an error fetching items.  This function should not be called
 * directly and is used by simpleFetch.fetch().
 * 
 * @param {!Object} errorData
 * @param {!Object} requestObject
 * @return {void}
 */
dojo.data.ItemFileReadStore.prototype.errorHandler = function(errorData, requestObject) {};

/**
 * The simpleFetch mixin is designed to serve as a set of function(s) that can
 * be mixed into other datastore implementations to accelerate their development.
 * The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
 * call by returning an array of all the found items that matched the query.  The simpleFetch mixin
 * is not designed to work for datastores that respond to a fetch() call by incrementally
 * loading items, or sequentially loading partial batches of the result
 * set.  For datastores that mixin simpleFetch, simpleFetch
 * implements a fetch method that automatically handles eight of the fetch()
 * arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
 * The class mixing in simpleFetch should not implement fetch(),
 * but should instead implement a _fetchItems() method.  The _fetchItems()
 * method takes three arguments, the keywordArgs object that was passed
 * to fetch(), a callback function to be called when the result array is
 * available, and an error callback to be called if something goes wrong.
 * The _fetchItems() method should ignore any keywordArgs parameters for
 * start, count, onBegin, onItem, onComplete, onError, sort, and scope.
 * The _fetchItems() method needs to correctly handle any other keywordArgs
 * parameters, including the query parameter and any optional parameters
 * (such as includeChildren).  The _fetchItems() method should create an array of
 * result items and pass it to the fetchHandler along with the original request object --
 * or, the _fetchItems() method may, if it wants to, create an new request object
 * with other specifics about the request that are specific to the datastore and pass
 * that as the request object to the handler.
 * 
 * For more information on this specific function, see dojo/data/api/Read.fetch()
 * 
 * @param {!Object} request               OptionalThe keywordArgs parameter may either be an instance ofconforming to dojo/data/api/Request or may be a simple anonymous objectthat may contain any of the following:{    query: query-object or query-string,    queryOptions: object,    onBegin: Function,    onItem: Function,    onComplete: Function,    onError: Function,    scope: object,    start: int    count: int    sort: array}All implementations should accept keywordArgs objects with any ofthe 9 standard properties: query, onBegin, onItem, onComplete, onErrorscope, sort, start, and count.  Some implementations may accept additionalproperties in the keywordArgs object as valid parameters, such as{includeOutliers:true}.The query parameterThe query may be optional in some data store implementations.The dojo/data/api/Read API does not specify the syntax or semanticsof the query itself -- each different data store implementationmay have its own notion of what a query should look like.However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.dataand dojox.data support an object structure query, where the object is a set ofname/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of thedijit widgets, such as ComboBox assume this to be the case when working with a datastorewhen they dynamically update the query.  Therefore, for maximum compatibility with dijitwidgets the recommended query parameter is a key/value object.  That does not mean that thethe datastore may not take alternative query forms, such as a simple string, a Date, a number,or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the queryformat.Further note:  In general for query objects that accept strings as attributevalue matches, the store should also support basic filtering capability, such as (match any character) and ? (match single character).  An example query that is a query objectwould be like: { attrFoo: "value"}.  Which generally means match all items where they havean attribute named attrFoo, with a value that starts with 'value'.The queryOptions parameterThe queryOptions parameter is an optional parameter used to specify options that may modifythe query in some fashion, such as doing a case insensitive search, or doing a deep searchwhere all items in a hierarchical representation of data are scanned instead of just the rootitems.  It currently defines two options that all datastores should attempt to honor if possible:{    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.    deep: boolean   // Whether or not a fetch should do a deep search of items and all child                    // items instead of just root-level items in a datastore.  Default is false.}The onBegin parameter.function(size, request);If an onBegin callback function is provided, the callback functionwill be called just once, before the first onItem callback is called.The onBegin callback function will be passed two arguments, thethe total number of items identified and the Request object.  If the total number isunknown, then size will be -1.  Note that size is not necessarily the size of thecollection of items returned from the query, as the request may have specified to return only asubset of the total set of items through the use of the start and count parameters.The onItem parameter.function(item, request);If an onItem callback function is provided, the callback functionwill be called as each item in the result is received. The callbackfunction will be passed two arguments: the item itself, and theRequest object.The onComplete parameter.function(items, request);If an onComplete callback function is provided, the callback functionwill be called just once, after the last onItem callback is called.Note that if the onItem callback is not present, then onComplete will be passedan array containing all items which matched the query and the request object.If the onItem callback is present, then onComplete is called as:onComplete(null, request).The onError parameter.function(errorData, request);If an onError callback function is provided, the callback functionwill be called if there is any sort of error while attempting toexecute the query.The onError callback function will be passed two arguments:an Error object and the Request object.The scope parameter.If a scope object is provided, all of the callback functions (onItem,onComplete, onError, etc) will be invoked in the context of the scopeobject.  In the body of the callback function, the value of the "this"keyword will be the scope object.   If no scope object is provided,the callback functions will be called in the context of dojo.global().For example, onItem.call(scope, item, request) vs.onItem.call(dojo.global(), item, request)The start parameter.If a start parameter is specified, this is a indication to the datastore toonly start returning items once the start number of items have been located andskipped.  When this parameter is paired with 'count', the store should be ableto page across queries with millions of hits by only returning subsets of thehits for each queryThe count parameter.If a count parameter is specified, this is a indication to the datastore toonly return up to that many items.  This allows a fetch call that may havemillions of item matches to be paired down to something reasonable.The sort parameter.If a sort parameter is specified, this is a indication to the datastore tosort the items in some manner before returning the items.  The array is an array ofjavascript objects that must conform to the following format to be applied to thefetching of items:{    attribute: attribute || attribute-name-string,    descending: true|false;   // Optional.  Default is false.}Note that when comparing attributes, if an item contains no value for the attribute(undefined), then it the default ascending sort logic should push it to the bottomof the list.  In the descending order case, it such items should appear at the top of the list.
 * @return {void}
 */
dojo.data.ItemFileReadStore.prototype.fetch = function(request) {};

/**
 * The handler when items are sucessfully fetched.  This function should not be called directly
 * and is used by simpleFetch.fetch().
 * 
 * @param {!Array<?>} items
 * @param {!Object} requestObject
 * @return {void}
 */
dojo.data.ItemFileReadStore.prototype.fetchHandler = function(items, requestObject) {};

/**
 * See dojo/data/api/Identity.fetchItemByIdentity()
 * 
 * @param {!Object} keywordArgs
 * @return {void}
 */
dojo.data.ItemFileReadStore.prototype.fetchItemByIdentity = function(keywordArgs) {};

/**
 * This method handles the basic filtering needs for ItemFile* based stores.
 * 
 * @param {!Object} requestArgs
 * @param {!Array<?>} arrayOfItems
 * @param {!Function} findCallback
 * @return {void}
 */
dojo.data.ItemFileReadStore.prototype.filter = function(requestArgs, arrayOfItems, findCallback) {};

/**
 * See dojo/data/api/Read.getAttributes()
 * 
 * @param {!dojo.data.api.Item} item
 * @return {!Array<?>}
 */
dojo.data.ItemFileReadStore.prototype.getAttributes = function(item) {};

/**
 * See dojo/data/api/Read.getFeatures()
 * 
 * @return {?}
 */
dojo.data.ItemFileReadStore.prototype.getFeatures = function() {};

/**
 * See dojo/data/api/Identity.getIdentity()
 * 
 * @param {!dojo.data.api.Item} item
 * @return {?}
 */
dojo.data.ItemFileReadStore.prototype.getIdentity = function(item) {};

/**
 * See dojo/data/api/Identity.getIdentityAttributes()
 * 
 * @param {!dojo.data.api.Item} item
 * @return {?}
 */
dojo.data.ItemFileReadStore.prototype.getIdentityAttributes = function(item) {};

/**
 * See dojo/data/api/Read.getLabel()
 * 
 * @param {!dojo.data.api.Item} item
 * @return {?}
 */
dojo.data.ItemFileReadStore.prototype.getLabel = function(item) {};

/**
 * See dojo/data/api/Read.getLabelAttributes()
 * 
 * @param {!dojo.data.api.Item} item
 * @return {?}
 */
dojo.data.ItemFileReadStore.prototype.getLabelAttributes = function(item) {};

/**
 * See dojo/data/api/Read.getValue()
 * 
 * @param {!dojo.data.api.Item} item
 * @param {!String} attribute
 * @param {?=} defaultValue               Optional
 * @return {?}
 */
dojo.data.ItemFileReadStore.prototype.getValue = function(item, attribute, defaultValue) {};

/**
 * See dojo/data/api/Read.getValues()
 * 
 * @param {!dojo.data.api.Item} item
 * @param {!String} attribute
 * @return {?}
 */
dojo.data.ItemFileReadStore.prototype.getValues = function(item, attribute) {};

/**
 * See dojo/data/api/Read.hasAttribute()
 * 
 * @param {!dojo.data.api.Item} item
 * @param {!String} attribute
 * @return {boolean}
 */
dojo.data.ItemFileReadStore.prototype.hasAttribute = function(item, attribute) {};

/**
 * See dojo/data/api/Read.isItem()
 * 
 * @param {?} something
 * @return {boolean}
 */
dojo.data.ItemFileReadStore.prototype.isItem = function(something) {};

/**
 * See dojo/data/api/Read.isItemLoaded()
 * 
 * @param {?} something
 * @return {?}
 */
dojo.data.ItemFileReadStore.prototype.isItemLoaded = function(something) {};

/**
 * See dojo/data/api/Read.loadItem()
 * 
 * @param {!Object} keywordArgs
 * @return {void}
 */
dojo.data.ItemFileReadStore.prototype.loadItem = function(keywordArgs) {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.data.ItemFileReadStore.prototype.on = function(type, listener) {};

/**
 * @constructor
 * @struct
 * @param {?} options
 */
dojo.data.ObjectStore = function(options) {};

/* TODO: PropertyDeclaration: dojo.data."labelProperty" */

/* TODO: PropertyDeclaration: dojo.data."objectStore" */

/**
 * adds an object to the list of dirty objects.  This object
 * contains a reference to the object itself as well as a
 * cloned and trimmed version of old object for use with
 * revert.
 * 
 * @param {!Object} object Indicates that the given object is changing and should be marked as dirty for the next save
 * @param {boolean} _deleting
 * @return {void}
 */
dojo.data.ObjectStore.prototype.changing = function(object, _deleting) {};

/**
 * See dojo/data/api/Read.close()
 * 
 * @param {?} request
 * @return {?}
 */
dojo.data.ObjectStore.prototype.close = function(request) {};

/**
 * Checks to see if 'item' has 'value' at 'attribute'
 * 
 * @param {!Object} item The item to check
 * @param {!String} attribute The attribute to check
 * @param {?} value The value to look for
 * @return {boolean}
 */
dojo.data.ObjectStore.prototype.containsValue = function(item, attribute, value) {};

/**
 * deletes item and any references to that item from the store.
 * 
 * @param {?} item item to delete
 * @return {void}
 */
dojo.data.ObjectStore.prototype.deleteItem = function(item) {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.data.ObjectStore.prototype.emit = function(type, event) {};

/**
 * See dojo/data/api/Read.fetch()
 * 
 * @param {?} args
 * @return {?}
 */
dojo.data.ObjectStore.prototype.fetch = function(args) {};

/**
 * fetch an item by its identity, by looking in our index of what we have loaded
 * 
 * @param {?} args
 * @return {?}
 */
dojo.data.ObjectStore.prototype.fetchItemByIdentity = function(args) {};

/**
 * Gets the available attributes of an item's 'property' and returns
 * it as an array.
 * 
 * @param {!Object} item
 * @return {!Array<?>}
 */
dojo.data.ObjectStore.prototype.getAttributes = function(item) {};

/**
 * return the store feature set
 * 
 * @return {!Object}
 */
dojo.data.ObjectStore.prototype.getFeatures = function() {};

/**
 * returns the identity of the given item
 * See dojo/data/api/Read.getIdentity()
 * 
 * @param {?} item
 * @return {?}
 */
dojo.data.ObjectStore.prototype.getIdentity = function(item) {};

/**
 * returns the attributes which are used to make up the
 * identity of an item.    Basically returns this.objectStore.idProperty
 * See dojo/data/api/Read.getIdentityAttributes()
 * 
 * @param {?} item
 * @return {!Array<?>}
 */
dojo.data.ObjectStore.prototype.getIdentityAttributes = function(item) {};

/**
 * See dojo/data/api/Read.getLabel()
 * 
 * @param {!dojo.data.api.Item} item
 * @return {?}
 */
dojo.data.ObjectStore.prototype.getLabel = function(item) {};

/**
 * See dojo/data/api/Read.getLabelAttributes()
 * 
 * @param {!dojo.data.api.Item} item
 * @return {!Array<?>}
 */
dojo.data.ObjectStore.prototype.getLabelAttributes = function(item) {};

/**
 * Gets the value of an item's 'property'
 * 
 * @param {!Object} item The item to get the value from
 * @param {!String} property property to look up value for
 * @param {?=} defaultValue               Optionalthe default value
 * @return {?}
 */
dojo.data.ObjectStore.prototype.getValue = function(item, property, defaultValue) {};

/**
 * Gets the value of an item's 'property' and returns
 * it. If this value is an array it is just returned,
 * if not, the value is added to an array and that is returned.
 * 
 * @param {!Object} item
 * @param {!String} property property to look up value for
 * @return {!Array<?>}
 */
dojo.data.ObjectStore.prototype.getValues = function(item, property) {};

/**
 * Checks to see if item has attribute
 * 
 * @param {!Object} item The item to check
 * @param {!String} attribute The attribute to check
 * @return {boolean}
 */
dojo.data.ObjectStore.prototype.hasAttribute = function(item, attribute) {};

/**
 * returns true if the item is marked as dirty or true if there are any dirty items
 * 
 * @param {!Object} item The item to check
 * @return {?}
 */
dojo.data.ObjectStore.prototype.isDirty = function(item) {};

/**
 * Checks to see if the argument is an item
 * 
 * @param {!Object} item The item to check
 * @return {boolean}
 */
dojo.data.ObjectStore.prototype.isItem = function(item) {};

/**
 * Checks to see if the item is loaded.
 * 
 * @param {!Object} item The item to check
 * @return {?}
 */
dojo.data.ObjectStore.prototype.isItemLoaded = function(item) {};

/**
 * Loads an item and calls the callback handler. Note, that this will call the callback
 * handler even if the item is loaded. Consequently, you can use loadItem to ensure
 * that an item is loaded is situations when the item may or may not be loaded yet.
 * If you access a value directly through property access, you can use this to load
 * a lazy value as well (doesn't need to be an item).
 * 
 * @param {!Object} args See dojo/data/api/Read.fetch()
 * @return {?}
 */
dojo.data.ObjectStore.prototype.loadItem = function(args) {};

/**
 * adds a new item to the store at the specified point.
 * Takes two parameters, data, and options.
 * 
 * @param {!Object} data See dojo/data/api/Write.newItem()
 * @param {?} parentInfo
 * @return {!Object}
 */
dojo.data.ObjectStore.prototype.newItem = function(data, parentInfo) {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.data.ObjectStore.prototype.on = function(type, listener) {};

/**
 * returns any modified data to its original state prior to a save();
 * 
 * @return {void}
 */
dojo.data.ObjectStore.prototype.revert = function() {};

/**
 * Saves the dirty data using object store provider. See dojo/data/api/Write for API.
 * 
 * @param {?} kwArgs kwArgs.global:This will cause the save to commit the dirty data for allObjectStores as a single transaction.kwArgs.revertOnError:This will cause the changes to be reverted if there is anerror on the save. By default a revert is executed unlessa value of false is provide for this parameter.kwArgs.onError:Called when an error occurs in the commitkwArgs.onComplete:Called when an the save/commit is completed
 * @return {void}
 */
dojo.data.ObjectStore.prototype.save = function(kwArgs) {};

/**
 * sets 'attribute' on 'item' to 'value'
 * See dojo/data/api/Write.setValue()
 * 
 * @param {?} item
 * @param {?} attribute
 * @param {?} value
 * @return {void}
 */
dojo.data.ObjectStore.prototype.setValue = function(item, attribute, value) {};

/**
 * sets 'attribute' on 'item' to 'value' value
 * must be an array.
 * See dojo/data/api/Write.setValues()
 * 
 * @param {?} item
 * @param {?} attribute
 * @param {?} values
 * @return {void}
 */
dojo.data.ObjectStore.prototype.setValues = function(item, attribute, values) {};

/**
 * unsets 'attribute' on 'item'
 * See dojo/data/api/Write.unsetAttribute()
 * 
 * @param {?} item
 * @param {?} attribute
 * @return {void}
 */
dojo.data.ObjectStore.prototype.unsetAttribute = function(item, attribute) {};

/**
 * See dojo/data/api/Notification.onDelete()
 * 
 * @return {void}
 */
dojo.data.ObjectStore.prototype.onDelete = function() {};

/**
 * Called when a fetch occurs
 * 
 * @param {?} results
 * @return {void}
 */
dojo.data.ObjectStore.prototype.onFetch = function(results) {};

/**
 * See dojo/data/api/Notification.onNew()
 * 
 * @return {void}
 */
dojo.data.ObjectStore.prototype.onNew = function() {};

/**
 * See dojo/data/api/Notification.onSet()
 * 
 * @return {void}
 */
dojo.data.ObjectStore.prototype.onSet = function() {};

/**
 * @constructor
 * @struct
 * @param {!Object} keywordParameters
 */
dojo.data.ItemFileWriteStore = function(keywordParameters) {};

/* TODO: PropertyDeclaration: dojo.data."clearOnClose" */

/* TODO: PropertyDeclaration: dojo.data."data" */

/* TODO: PropertyDeclaration: dojo.data."failOk" */

/* TODO: PropertyDeclaration: dojo.data."hierarchical" */

/* TODO: PropertyDeclaration: dojo.data."referenceIntegrity" */

/* TODO: PropertyDeclaration: dojo.data."typeMap" */

/* TODO: PropertyDeclaration: dojo.data."url" */

/* TODO: PropertyDeclaration: dojo.data."urlPreventCache" */

/**
 * Over-ride of base close function of ItemFileReadStore to add in check for store state.
 * Over-ride of base close function of ItemFileReadStore to add in check for store state.
 * If the store is still dirty (unsaved changes), then an error will be thrown instead of
 * clearing the internal state for reload from the url.
 * 
 * @param {!Object=} request               Optional
 * @return {void}
 */
dojo.data.ItemFileWriteStore.prototype.close = function(request) {};

/**
 * See dojo/data/api/Read.containsValue()
 * 
 * @param {!dojo.data.api.Item} item
 * @param {!String} attribute
 * @param {?} value
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.containsValue = function(item, attribute, value) {};

/**
 * See dojo/data/api/Write.deleteItem()
 * 
 * @param {!dojo.data.api.Item} item
 * @return {boolean}
 */
dojo.data.ItemFileWriteStore.prototype.deleteItem = function(item) {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.emit = function(type, event) {};

/**
 * The error handler when there is an error fetching items.  This function should not be called
 * directly and is used by simpleFetch.fetch().
 * 
 * @param {!Object} errorData
 * @param {!Object} requestObject
 * @return {void}
 */
dojo.data.ItemFileWriteStore.prototype.errorHandler = function(errorData, requestObject) {};

/**
 * The simpleFetch mixin is designed to serve as a set of function(s) that can
 * be mixed into other datastore implementations to accelerate their development.
 * The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
 * call by returning an array of all the found items that matched the query.  The simpleFetch mixin
 * is not designed to work for datastores that respond to a fetch() call by incrementally
 * loading items, or sequentially loading partial batches of the result
 * set.  For datastores that mixin simpleFetch, simpleFetch
 * implements a fetch method that automatically handles eight of the fetch()
 * arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
 * The class mixing in simpleFetch should not implement fetch(),
 * but should instead implement a _fetchItems() method.  The _fetchItems()
 * method takes three arguments, the keywordArgs object that was passed
 * to fetch(), a callback function to be called when the result array is
 * available, and an error callback to be called if something goes wrong.
 * The _fetchItems() method should ignore any keywordArgs parameters for
 * start, count, onBegin, onItem, onComplete, onError, sort, and scope.
 * The _fetchItems() method needs to correctly handle any other keywordArgs
 * parameters, including the query parameter and any optional parameters
 * (such as includeChildren).  The _fetchItems() method should create an array of
 * result items and pass it to the fetchHandler along with the original request object --
 * or, the _fetchItems() method may, if it wants to, create an new request object
 * with other specifics about the request that are specific to the datastore and pass
 * that as the request object to the handler.
 * 
 * For more information on this specific function, see dojo/data/api/Read.fetch()
 * 
 * @param {!Object} request               OptionalThe keywordArgs parameter may either be an instance ofconforming to dojo/data/api/Request or may be a simple anonymous objectthat may contain any of the following:{    query: query-object or query-string,    queryOptions: object,    onBegin: Function,    onItem: Function,    onComplete: Function,    onError: Function,    scope: object,    start: int    count: int    sort: array}All implementations should accept keywordArgs objects with any ofthe 9 standard properties: query, onBegin, onItem, onComplete, onErrorscope, sort, start, and count.  Some implementations may accept additionalproperties in the keywordArgs object as valid parameters, such as{includeOutliers:true}.The query parameterThe query may be optional in some data store implementations.The dojo/data/api/Read API does not specify the syntax or semanticsof the query itself -- each different data store implementationmay have its own notion of what a query should look like.However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.dataand dojox.data support an object structure query, where the object is a set ofname/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of thedijit widgets, such as ComboBox assume this to be the case when working with a datastorewhen they dynamically update the query.  Therefore, for maximum compatibility with dijitwidgets the recommended query parameter is a key/value object.  That does not mean that thethe datastore may not take alternative query forms, such as a simple string, a Date, a number,or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the queryformat.Further note:  In general for query objects that accept strings as attributevalue matches, the store should also support basic filtering capability, such as (match any character) and ? (match single character).  An example query that is a query objectwould be like: { attrFoo: "value"}.  Which generally means match all items where they havean attribute named attrFoo, with a value that starts with 'value'.The queryOptions parameterThe queryOptions parameter is an optional parameter used to specify options that may modifythe query in some fashion, such as doing a case insensitive search, or doing a deep searchwhere all items in a hierarchical representation of data are scanned instead of just the rootitems.  It currently defines two options that all datastores should attempt to honor if possible:{    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.    deep: boolean   // Whether or not a fetch should do a deep search of items and all child                    // items instead of just root-level items in a datastore.  Default is false.}The onBegin parameter.function(size, request);If an onBegin callback function is provided, the callback functionwill be called just once, before the first onItem callback is called.The onBegin callback function will be passed two arguments, thethe total number of items identified and the Request object.  If the total number isunknown, then size will be -1.  Note that size is not necessarily the size of thecollection of items returned from the query, as the request may have specified to return only asubset of the total set of items through the use of the start and count parameters.The onItem parameter.function(item, request);If an onItem callback function is provided, the callback functionwill be called as each item in the result is received. The callbackfunction will be passed two arguments: the item itself, and theRequest object.The onComplete parameter.function(items, request);If an onComplete callback function is provided, the callback functionwill be called just once, after the last onItem callback is called.Note that if the onItem callback is not present, then onComplete will be passedan array containing all items which matched the query and the request object.If the onItem callback is present, then onComplete is called as:onComplete(null, request).The onError parameter.function(errorData, request);If an onError callback function is provided, the callback functionwill be called if there is any sort of error while attempting toexecute the query.The onError callback function will be passed two arguments:an Error object and the Request object.The scope parameter.If a scope object is provided, all of the callback functions (onItem,onComplete, onError, etc) will be invoked in the context of the scopeobject.  In the body of the callback function, the value of the "this"keyword will be the scope object.   If no scope object is provided,the callback functions will be called in the context of dojo.global().For example, onItem.call(scope, item, request) vs.onItem.call(dojo.global(), item, request)The start parameter.If a start parameter is specified, this is a indication to the datastore toonly start returning items once the start number of items have been located andskipped.  When this parameter is paired with 'count', the store should be ableto page across queries with millions of hits by only returning subsets of thehits for each queryThe count parameter.If a count parameter is specified, this is a indication to the datastore toonly return up to that many items.  This allows a fetch call that may havemillions of item matches to be paired down to something reasonable.The sort parameter.If a sort parameter is specified, this is a indication to the datastore tosort the items in some manner before returning the items.  The array is an array ofjavascript objects that must conform to the following format to be applied to thefetching of items:{    attribute: attribute || attribute-name-string,    descending: true|false;   // Optional.  Default is false.}Note that when comparing attributes, if an item contains no value for the attribute(undefined), then it the default ascending sort logic should push it to the bottomof the list.  In the descending order case, it such items should appear at the top of the list.
 * @return {void}
 */
dojo.data.ItemFileWriteStore.prototype.fetch = function(request) {};

/**
 * The handler when items are sucessfully fetched.  This function should not be called directly
 * and is used by simpleFetch.fetch().
 * 
 * @param {!Array<?>} items
 * @param {!Object} requestObject
 * @return {void}
 */
dojo.data.ItemFileWriteStore.prototype.fetchHandler = function(items, requestObject) {};

/**
 * See dojo/data/api/Identity.fetchItemByIdentity()
 * 
 * @param {!Object} keywordArgs
 * @return {void}
 */
dojo.data.ItemFileWriteStore.prototype.fetchItemByIdentity = function(keywordArgs) {};

/**
 * This method handles the basic filtering needs for ItemFile* based stores.
 * 
 * @param {!Object} requestArgs
 * @param {!Array<?>} arrayOfItems
 * @param {!Function} findCallback
 * @return {void}
 */
dojo.data.ItemFileWriteStore.prototype.filter = function(requestArgs, arrayOfItems, findCallback) {};

/**
 * See dojo/data/api/Read.getAttributes()
 * 
 * @param {!dojo.data.api.Item} item
 * @return {!Array<?>}
 */
dojo.data.ItemFileWriteStore.prototype.getAttributes = function(item) {};

/**
 * See dojo/data/api/Read.getFeatures()
 * 
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.getFeatures = function() {};

/**
 * See dojo/data/api/Identity.getIdentity()
 * 
 * @param {!dojo.data.api.Item} item
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.getIdentity = function(item) {};

/**
 * See dojo/data/api/Identity.getIdentityAttributes()
 * 
 * @param {!dojo.data.api.Item} item
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.getIdentityAttributes = function(item) {};

/**
 * See dojo/data/api/Read.getLabel()
 * 
 * @param {!dojo.data.api.Item} item
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.getLabel = function(item) {};

/**
 * See dojo/data/api/Read.getLabelAttributes()
 * 
 * @param {!dojo.data.api.Item} item
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.getLabelAttributes = function(item) {};

/**
 * See dojo/data/api/Read.getValue()
 * 
 * @param {!dojo.data.api.Item} item
 * @param {!String} attribute
 * @param {?=} defaultValue               Optional
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.getValue = function(item, attribute, defaultValue) {};

/**
 * See dojo/data/api/Read.getValues()
 * 
 * @param {!dojo.data.api.Item} item
 * @param {!String} attribute
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.getValues = function(item, attribute) {};

/**
 * See dojo/data/api/Read.hasAttribute()
 * 
 * @param {!dojo.data.api.Item} item
 * @param {!String} attribute
 * @return {boolean}
 */
dojo.data.ItemFileWriteStore.prototype.hasAttribute = function(item, attribute) {};

/**
 * See dojo/data/api/Write.isDirty()
 * 
 * @param {?=} item               Optional
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.isDirty = function(item) {};

/**
 * See dojo/data/api/Read.isItem()
 * 
 * @param {?} something
 * @return {boolean}
 */
dojo.data.ItemFileWriteStore.prototype.isItem = function(something) {};

/**
 * See dojo/data/api/Read.isItemLoaded()
 * 
 * @param {?} something
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.isItemLoaded = function(something) {};

/**
 * See dojo/data/api/Read.loadItem()
 * 
 * @param {!Object} keywordArgs
 * @return {void}
 */
dojo.data.ItemFileWriteStore.prototype.loadItem = function(keywordArgs) {};

/**
 * See dojo/data/api/Write.newItem()
 * 
 * @param {!Object=} keywordArgs               Optional
 * @param {!Object=} parentInfo               Optional
 * @return {!Object}
 */
dojo.data.ItemFileWriteStore.prototype.newItem = function(keywordArgs, parentInfo) {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.on = function(type, listener) {};

/**
 * See dojo/data/api/Write.revert()
 * 
 * @return {boolean}
 */
dojo.data.ItemFileWriteStore.prototype.revert = function() {};

/**
 * See dojo/data/api/Write.save()
 * 
 * @param {!Object} keywordArgs
 * @return {void}
 */
dojo.data.ItemFileWriteStore.prototype.save = function(keywordArgs) {};

/**
 * See dojo/data/api/Write.set()
 * 
 * @param {!dojo.data.api.Item} item
 * @param {!String} attribute
 * @param {?} value
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.setValue = function(item, attribute, value) {};

/**
 * See dojo/data/api/Write.setValues()
 * 
 * @param {!dojo.data.api.Item} item
 * @param {!String} attribute
 * @param {!Array<?>} values
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.setValues = function(item, attribute, values) {};

/**
 * See dojo/data/api/Write.unsetAttribute()
 * 
 * @param {!dojo.data.api.Item} item
 * @param {!String} attribute
 * @return {?}
 */
dojo.data.ItemFileWriteStore.prototype.unsetAttribute = function(item, attribute) {};

/**
 * See dojo/data/api/Notification.onDelete()
 * 
 * @param {!dojo.data.api.Item} deletedItem
 * @return {void}
 */
dojo.data.ItemFileWriteStore.prototype.onDelete = function(deletedItem) {};

/**
 * See dojo/data/api/Notification.onNew()
 * 
 * @param {!dojo.data.api.Item} newItem
 * @param {!Object=} parentInfo               Optional
 * @return {void}
 */
dojo.data.ItemFileWriteStore.prototype.onNew = function(newItem, parentInfo) {};

/**
 * See dojo/data/api/Notification.onSet()
 * 
 * See dojo/data/api/Notification.onSet()
 * 
 * See dojo/data/api/Notification.onSet()
 * 
 * See dojo/data/api/Notification.onSet()
 * 
 * @param {!dojo.data.api.Item} item
 * @param {!String} attribute
 * @param {!Object|!Array<?>} oldValue
 * @param {!Object|!Array<?>} newValue
 * @return {void}
 */
dojo.data.ItemFileWriteStore.prototype.onSet = function(item, attribute, oldValue, newValue) {};
/** @const */
dojo.data.api = {};

/**
 * @constructor
 * @struct
 */
dojo.data.api.Item = function() {};

/**
 * @constructor
 * @struct
 */
dojo.data.api.Identity = function() {};

/**
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.  In general, this API
 * expects to receive as a parameter a request object returned from a fetch.
 * It will then close out anything associated with that request, such as
 * clearing any internal datastore caches and closing any 'open' connections.
 * For some store implementations, this call may be a no-op.
 * 
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.  In general, this API
 * expects to receive as a parameter a request object returned from a fetch.
 * It will then close out anything associated with that request, such as
 * clearing any internal datastore caches and closing any 'open' connections.
 * For some store implementations, this call may be a no-op.
 * 
 * @param {!dojo.data.api.Request|!Object=} request               OptionalAn instance of a request for the store to use to identify what to close out.If no request is passed, then the store should clear all internal caches (if any)and close out all 'open' connections.  It does not render the store unusable fromthere on, it merely cleans out any current data and resets the store to initialstate.
 * @return {void}
 */
dojo.data.api.Identity.prototype.close = function(request) {};

/**
 * Returns true if the given value is one of the values that getValues()
 * would return.
 * 
 * @param {!dojo.data.api.Item} item The item to access values on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @param {?} value The value to match as a value for the attribute.
 * @return {void}
 */
dojo.data.api.Identity.prototype.containsValue = function(item, attribute, value) {};

/**
 * Given a query and set of defined options, such as a start and count of items to return,
 * this method executes the query and makes the results available as data items.
 * The format and expectations of stores is that they operate in a generally asynchronous
 * manner, therefore callbacks are always used to return items located by the fetch parameters.
 * A Request object will always be returned and is returned immediately.
 * The basic request is nothing more than the keyword args passed to fetch and
 * an additional function attached, abort().  The returned request object may then be used
 * to cancel a fetch.  All data items returns are passed through the callbacks defined in the
 * fetch parameters and are not present on the 'request' object.
 * 
 * This does not mean that custom stores can not add methods and properties to the request object
 * returned, only that the API does not require it.  For more info about the Request API,
 * see dojo/data/api/Request
 * 
 * @param {!Object} keywordArgs The keywordArgs parameter may either be an instance ofconforming to dojo/data/api/Request or may be a simple anonymous objectthat may contain any of the following:{    query: query-object or query-string,    queryOptions: object,    onBegin: Function,    onItem: Function,    onComplete: Function,    onError: Function,    scope: object,    start: int    count: int    sort: array}All implementations should accept keywordArgs objects with any ofthe 9 standard properties: query, onBegin, onItem, onComplete, onErrorscope, sort, start, and count.  Some implementations may accept additionalproperties in the keywordArgs object as valid parameters, such as{includeOutliers:true}.The query parameterThe query may be optional in some data store implementations.The dojo/data/api/Read API does not specify the syntax or semanticsof the query itself -- each different data store implementationmay have its own notion of what a query should look like.However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.dataand dojox.data support an object structure query, where the object is a set ofname/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of thedijit widgets, such as ComboBox assume this to be the case when working with a datastorewhen they dynamically update the query.  Therefore, for maximum compatibility with dijitwidgets the recommended query parameter is a key/value object.  That does not mean that thethe datastore may not take alternative query forms, such as a simple string, a Date, a number,or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the queryformat.Further note:  In general for query objects that accept strings as attributevalue matches, the store should also support basic filtering capability, such as (match any character) and ? (match single character).  An example query that is a query objectwould be like: { attrFoo: "value"}.  Which generally means match all items where they havean attribute named attrFoo, with a value that starts with 'value'.The queryOptions parameterThe queryOptions parameter is an optional parameter used to specify options that may modifythe query in some fashion, such as doing a case insensitive search, or doing a deep searchwhere all items in a hierarchical representation of data are scanned instead of just the rootitems.  It currently defines two options that all datastores should attempt to honor if possible:{    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.    deep: boolean   // Whether or not a fetch should do a deep search of items and all child                    // items instead of just root-level items in a datastore.  Default is false.}The onBegin parameter.function(size, request);If an onBegin callback function is provided, the callback functionwill be called just once, before the first onItem callback is called.The onBegin callback function will be passed two arguments, thethe total number of items identified and the Request object.  If the total number isunknown, then size will be -1.  Note that size is not necessarily the size of thecollection of items returned from the query, as the request may have specified to return only asubset of the total set of items through the use of the start and count parameters.The onItem parameter.function(item, request);If an onItem callback function is provided, the callback functionwill be called as each item in the result is received. The callbackfunction will be passed two arguments: the item itself, and theRequest object.The onComplete parameter.function(items, request);If an onComplete callback function is provided, the callback functionwill be called just once, after the last onItem callback is called.Note that if the onItem callback is not present, then onComplete will be passedan array containing all items which matched the query and the request object.If the onItem callback is present, then onComplete is called as:onComplete(null, request).The onError parameter.function(errorData, request);If an onError callback function is provided, the callback functionwill be called if there is any sort of error while attempting toexecute the query.The onError callback function will be passed two arguments:an Error object and the Request object.The scope parameter.If a scope object is provided, all of the callback functions (onItem,onComplete, onError, etc) will be invoked in the context of the scopeobject.  In the body of the callback function, the value of the "this"keyword will be the scope object.   If no scope object is provided,the callback functions will be called in the context of dojo.global().For example, onItem.call(scope, item, request) vs.onItem.call(dojo.global(), item, request)The start parameter.If a start parameter is specified, this is a indication to the datastore toonly start returning items once the start number of items have been located andskipped.  When this parameter is paired with 'count', the store should be ableto page across queries with millions of hits by only returning subsets of thehits for each queryThe count parameter.If a count parameter is specified, this is a indication to the datastore toonly return up to that many items.  This allows a fetch call that may havemillions of item matches to be paired down to something reasonable.The sort parameter.If a sort parameter is specified, this is a indication to the datastore tosort the items in some manner before returning the items.  The array is an array ofjavascript objects that must conform to the following format to be applied to thefetching of items:{    attribute: attribute || attribute-name-string,    descending: true|false;   // Optional.  Default is false.}Note that when comparing attributes, if an item contains no value for the attribute(undefined), then it the default ascending sort logic should push it to the bottomof the list.  In the descending order case, it such items should appear at the top of the list.
 * @return {?}
 */
dojo.data.api.Identity.prototype.fetch = function(keywordArgs) {};

/**
 * Given the identity of an item, this method returns the item that has
 * that identity through the onItem callback.  Conforming implementations
 * should return null if there is no item with the given identity.
 * Implementations of fetchItemByIdentity() may sometimes return an item
 * from a local cache and may sometimes fetch an item from a remote server,
 * 
 * @param {!Object} keywordArgs An anonymous object that defines the item to locate and callbacks to invoke when theitem has been located and load has completed.  The format of the object is as follows:{    identity: string|object,    onItem: Function,    onError: Function,    scope: object}The identity parameterThe identity parameter is the identity of the item you wish to locate and loadThis attribute is required.  It should be a string or an object that toString()can be called on.The onItem parameterFunction(item)The onItem parameter is the callback to invoke when the item has been loaded.  It takes only oneparameter, the item located, or null if none found.The onError parameterFunction(error)The onError parameter is the callback to invoke when the item load encountered an error.  It takes only oneparameter, the error objectThe scope parameterIf a scope object is provided, all of the callback functions (onItem,onError, etc) will be invoked in the context of the scope object.In the body of the callback function, the value of the "this"keyword will be the scope object.   If no scope object is provided,the callback functions will be called in the context of dojo.global.For example, onItem.call(scope, item, request) vs.onItem.call(dojo.global, item, request)
 * @return {void}
 */
dojo.data.api.Identity.prototype.fetchItemByIdentity = function(keywordArgs) {};

/**
 * Returns an array with all the attributes that this item has.  This
 * method will always return an array; if the item has no attributes
 * at all, getAttributes() will return an empty array: [].
 * 
 * @param {!dojo.data.api.Item} item The item to access attributes on.
 * @return {void}
 */
dojo.data.api.Identity.prototype.getAttributes = function(item) {};

/**
 * See dojo/data/api/Read.getFeatures()
 * 
 * @return {!Object}
 */
dojo.data.api.Identity.prototype.getFeatures = function() {};

/**
 * Returns a unique identifier for an item.  The return value will be
 * either a string or something that has a toString() method (such as,
 * for example, a dojox/uuid object).
 * 
 * @param {!dojo.data.api.Item} item The item from the store from which to obtain its identifier.
 * @return {void}
 */
dojo.data.api.Identity.prototype.getIdentity = function(item) {};

/**
 * Returns an array of attribute names that are used to generate the identity.
 * For most stores, this is a single attribute, but for some complex stores
 * such as RDB backed stores that use compound (multi-attribute) identifiers
 * it can be more than one.  If the identity is not composed of attributes
 * on the item, it will return null.  This function is intended to identify
 * the attributes that comprise the identity so that so that during a render
 * of all attributes, the UI can hide the the identity information if it
 * chooses.
 * 
 * @param {!dojo.data.api.Item} item The item from the store from which to obtain the array of public attributes thatcompose the identifier, if any.
 * @return {void}
 */
dojo.data.api.Identity.prototype.getIdentityAttributes = function(item) {};

/**
 * Method to inspect the item and return a user-readable 'label' for the item
 * that provides a general/adequate description of what the item is.
 * Method to inspect the item and return a user-readable 'label' for the item
 * that provides a general/adequate description of what the item is.  In general
 * most labels will be a specific attribute value or collection of the attribute
 * values that combine to label the item in some manner.  For example for an item
 * that represents a person it may return the label as:  "firstname lastlame" where
 * the firstname and lastname are attributes on the item.  If the store is unable
 * to determine an adequate human readable label, it should return undefined.  Users that wish
 * to customize how a store instance labels items should replace the getLabel() function on
 * their instance of the store, or extend the store and replace the function in
 * the extension class.
 * 
 * @param {!dojo.data.api.Item} item The item to return the label for.
 * @return {?}
 */
dojo.data.api.Identity.prototype.getLabel = function(item) {};

/**
 * Method to inspect the item and return an array of what attributes of the item were used
 * to generate its label, if any.
 * Method to inspect the item and return an array of what attributes of the item were used
 * to generate its label, if any.  This function is to assist UI developers in knowing what
 * attributes can be ignored out of the attributes an item has when displaying it, in cases
 * where the UI is using the label as an overall identifer should they wish to hide
 * redundant information.
 * 
 * @param {!dojo.data.api.Item} item The item to return the list of label attributes for.
 * @return {?}
 */
dojo.data.api.Identity.prototype.getLabelAttributes = function(item) {};

/**
 * Returns a single attribute value.
 * Returns defaultValue if and only if item does not have a value for attribute.
 * Returns null if and only if null was explicitly set as the attribute value.
 * Returns undefined if and only if the item does not have a value for the
 * given attribute (which is the same as saying the item does not have the attribute).
 * Saying that an "item x does not have a value for an attribute y"
 * is identical to saying that an "item x does not have attribute y".
 * It is an oxymoron to say "that attribute is present but has no values"
 * or "the item has that attribute but does not have any attribute values".
 * If store.hasAttribute(item, attribute) returns false, then
 * store.getValue(item, attribute) will return undefined.
 * 
 * @param {!dojo.data.api.Item} item The item to access values on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @param {?=} defaultValue               OptionalOptional.  A default value to use for the getValue return in the attribute does not exist or has no value.
 * @return {?}
 */
dojo.data.api.Identity.prototype.getValue = function(item, attribute, defaultValue) {};

/**
 * This getValues() method works just like the getValue() method, but getValues()
 * always returns an array rather than a single attribute value.  The array
 * may be empty, may contain a single attribute value, or may contain
 * many attribute values.
 * If the item does not have a value for the given attribute, then getValues()
 * will return an empty array: [].  (So, if store.hasAttribute(item, attribute)
 * has a return of false, then store.getValues(item, attribute) will return [].)
 * 
 * @param {!dojo.data.api.Item} item The item to access values on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @return {?}
 */
dojo.data.api.Identity.prototype.getValues = function(item, attribute) {};

/**
 * Returns true if the given item has a value for the given attribute.
 * 
 * @param {!dojo.data.api.Item} item The item to access attributes on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @return {void}
 */
dojo.data.api.Identity.prototype.hasAttribute = function(item, attribute) {};

/**
 * Returns true if something is an item and came from the store instance.
 * Returns false if something is a literal, an item from another store instance,
 * or is any object other than an item.
 * 
 * @param {?} something Can be anything.
 * @return {void}
 */
dojo.data.api.Identity.prototype.isItem = function(something) {};

/**
 * Returns false if isItem(something) is false.  Returns false if
 * if isItem(something) is true but the the item is not yet loaded
 * in local memory (for example, if the item has not yet been read
 * from the server).
 * 
 * @param {?} something Can be anything.
 * @return {void}
 */
dojo.data.api.Identity.prototype.isItemLoaded = function(something) {};

/**
 * Given an item, this method loads the item so that a subsequent call
 * to store.isItemLoaded(item) will return true.  If a call to
 * isItemLoaded() returns true before loadItem() is even called,
 * then loadItem() need not do any work at all and will not even invoke
 * the callback handlers.  So, before invoking this method, check that
 * the item has not already been loaded.
 * 
 * @param {!Object} keywordArgs An anonymous object that defines the item to load and callbacks to invoke when theload has completed.  The format of the object is as follows:{    item: object,    onItem: Function,    onError: Function,    scope: object}The item parameterThe item parameter is an object that represents the item in question that should becontained by the store.  This attribute is required.The onItem parameterFunction(item)The onItem parameter is the callback to invoke when the item has been loaded.  It takes only oneparameter, the fully loaded item.The onError parameterFunction(error)The onError parameter is the callback to invoke when the item load encountered an error.  It takes only oneparameter, the error objectThe scope parameterIf a scope object is provided, all of the callback functions (onItem,onError, etc) will be invoked in the context of the scope object.In the body of the callback function, the value of the "this"keyword will be the scope object.   If no scope object is provided,the callback functions will be called in the context of dojo.global().For example, onItem.call(scope, item, request) vs.onItem.call(dojo.global(), item, request)
 * @return {void}
 */
dojo.data.api.Identity.prototype.loadItem = function(keywordArgs) {};

/**
 * @constructor
 * @struct
 */
dojo.data.api.Request = function() {};

/**
 * This function is a hook point for stores to provide as a way for
 * a fetch to be halted mid-processing.
 * This function is a hook point for stores to provide as a way for
 * a fetch to be halted mid-processing.  For more details on the fetch() api,
 * please see dojo/data/api/Read.fetch().
 * 
 * @return {void}
 */
dojo.data.api.Request.prototype.abort = function() {};

/**
 * @constructor
 * @struct
 */
dojo.data.api.Notification = function() {};

/**
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.  In general, this API
 * expects to receive as a parameter a request object returned from a fetch.
 * It will then close out anything associated with that request, such as
 * clearing any internal datastore caches and closing any 'open' connections.
 * For some store implementations, this call may be a no-op.
 * 
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.  In general, this API
 * expects to receive as a parameter a request object returned from a fetch.
 * It will then close out anything associated with that request, such as
 * clearing any internal datastore caches and closing any 'open' connections.
 * For some store implementations, this call may be a no-op.
 * 
 * @param {!dojo.data.api.Request|!Object=} request               OptionalAn instance of a request for the store to use to identify what to close out.If no request is passed, then the store should clear all internal caches (if any)and close out all 'open' connections.  It does not render the store unusable fromthere on, it merely cleans out any current data and resets the store to initialstate.
 * @return {void}
 */
dojo.data.api.Notification.prototype.close = function(request) {};

/**
 * Returns true if the given value is one of the values that getValues()
 * would return.
 * 
 * @param {!dojo.data.api.Item} item The item to access values on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @param {?} value The value to match as a value for the attribute.
 * @return {void}
 */
dojo.data.api.Notification.prototype.containsValue = function(item, attribute, value) {};

/**
 * Given a query and set of defined options, such as a start and count of items to return,
 * this method executes the query and makes the results available as data items.
 * The format and expectations of stores is that they operate in a generally asynchronous
 * manner, therefore callbacks are always used to return items located by the fetch parameters.
 * A Request object will always be returned and is returned immediately.
 * The basic request is nothing more than the keyword args passed to fetch and
 * an additional function attached, abort().  The returned request object may then be used
 * to cancel a fetch.  All data items returns are passed through the callbacks defined in the
 * fetch parameters and are not present on the 'request' object.
 * 
 * This does not mean that custom stores can not add methods and properties to the request object
 * returned, only that the API does not require it.  For more info about the Request API,
 * see dojo/data/api/Request
 * 
 * @param {!Object} keywordArgs The keywordArgs parameter may either be an instance ofconforming to dojo/data/api/Request or may be a simple anonymous objectthat may contain any of the following:{    query: query-object or query-string,    queryOptions: object,    onBegin: Function,    onItem: Function,    onComplete: Function,    onError: Function,    scope: object,    start: int    count: int    sort: array}All implementations should accept keywordArgs objects with any ofthe 9 standard properties: query, onBegin, onItem, onComplete, onErrorscope, sort, start, and count.  Some implementations may accept additionalproperties in the keywordArgs object as valid parameters, such as{includeOutliers:true}.The query parameterThe query may be optional in some data store implementations.The dojo/data/api/Read API does not specify the syntax or semanticsof the query itself -- each different data store implementationmay have its own notion of what a query should look like.However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.dataand dojox.data support an object structure query, where the object is a set ofname/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of thedijit widgets, such as ComboBox assume this to be the case when working with a datastorewhen they dynamically update the query.  Therefore, for maximum compatibility with dijitwidgets the recommended query parameter is a key/value object.  That does not mean that thethe datastore may not take alternative query forms, such as a simple string, a Date, a number,or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the queryformat.Further note:  In general for query objects that accept strings as attributevalue matches, the store should also support basic filtering capability, such as (match any character) and ? (match single character).  An example query that is a query objectwould be like: { attrFoo: "value"}.  Which generally means match all items where they havean attribute named attrFoo, with a value that starts with 'value'.The queryOptions parameterThe queryOptions parameter is an optional parameter used to specify options that may modifythe query in some fashion, such as doing a case insensitive search, or doing a deep searchwhere all items in a hierarchical representation of data are scanned instead of just the rootitems.  It currently defines two options that all datastores should attempt to honor if possible:{    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.    deep: boolean   // Whether or not a fetch should do a deep search of items and all child                    // items instead of just root-level items in a datastore.  Default is false.}The onBegin parameter.function(size, request);If an onBegin callback function is provided, the callback functionwill be called just once, before the first onItem callback is called.The onBegin callback function will be passed two arguments, thethe total number of items identified and the Request object.  If the total number isunknown, then size will be -1.  Note that size is not necessarily the size of thecollection of items returned from the query, as the request may have specified to return only asubset of the total set of items through the use of the start and count parameters.The onItem parameter.function(item, request);If an onItem callback function is provided, the callback functionwill be called as each item in the result is received. The callbackfunction will be passed two arguments: the item itself, and theRequest object.The onComplete parameter.function(items, request);If an onComplete callback function is provided, the callback functionwill be called just once, after the last onItem callback is called.Note that if the onItem callback is not present, then onComplete will be passedan array containing all items which matched the query and the request object.If the onItem callback is present, then onComplete is called as:onComplete(null, request).The onError parameter.function(errorData, request);If an onError callback function is provided, the callback functionwill be called if there is any sort of error while attempting toexecute the query.The onError callback function will be passed two arguments:an Error object and the Request object.The scope parameter.If a scope object is provided, all of the callback functions (onItem,onComplete, onError, etc) will be invoked in the context of the scopeobject.  In the body of the callback function, the value of the "this"keyword will be the scope object.   If no scope object is provided,the callback functions will be called in the context of dojo.global().For example, onItem.call(scope, item, request) vs.onItem.call(dojo.global(), item, request)The start parameter.If a start parameter is specified, this is a indication to the datastore toonly start returning items once the start number of items have been located andskipped.  When this parameter is paired with 'count', the store should be ableto page across queries with millions of hits by only returning subsets of thehits for each queryThe count parameter.If a count parameter is specified, this is a indication to the datastore toonly return up to that many items.  This allows a fetch call that may havemillions of item matches to be paired down to something reasonable.The sort parameter.If a sort parameter is specified, this is a indication to the datastore tosort the items in some manner before returning the items.  The array is an array ofjavascript objects that must conform to the following format to be applied to thefetching of items:{    attribute: attribute || attribute-name-string,    descending: true|false;   // Optional.  Default is false.}Note that when comparing attributes, if an item contains no value for the attribute(undefined), then it the default ascending sort logic should push it to the bottomof the list.  In the descending order case, it such items should appear at the top of the list.
 * @return {?}
 */
dojo.data.api.Notification.prototype.fetch = function(keywordArgs) {};

/**
 * Returns an array with all the attributes that this item has.  This
 * method will always return an array; if the item has no attributes
 * at all, getAttributes() will return an empty array: [].
 * 
 * @param {!dojo.data.api.Item} item The item to access attributes on.
 * @return {void}
 */
dojo.data.api.Notification.prototype.getAttributes = function(item) {};

/**
 * See dojo/data/api/Read.getFeatures()
 * 
 * @return {!Object}
 */
dojo.data.api.Notification.prototype.getFeatures = function() {};

/**
 * Method to inspect the item and return a user-readable 'label' for the item
 * that provides a general/adequate description of what the item is.
 * Method to inspect the item and return a user-readable 'label' for the item
 * that provides a general/adequate description of what the item is.  In general
 * most labels will be a specific attribute value or collection of the attribute
 * values that combine to label the item in some manner.  For example for an item
 * that represents a person it may return the label as:  "firstname lastlame" where
 * the firstname and lastname are attributes on the item.  If the store is unable
 * to determine an adequate human readable label, it should return undefined.  Users that wish
 * to customize how a store instance labels items should replace the getLabel() function on
 * their instance of the store, or extend the store and replace the function in
 * the extension class.
 * 
 * @param {!dojo.data.api.Item} item The item to return the label for.
 * @return {?}
 */
dojo.data.api.Notification.prototype.getLabel = function(item) {};

/**
 * Method to inspect the item and return an array of what attributes of the item were used
 * to generate its label, if any.
 * Method to inspect the item and return an array of what attributes of the item were used
 * to generate its label, if any.  This function is to assist UI developers in knowing what
 * attributes can be ignored out of the attributes an item has when displaying it, in cases
 * where the UI is using the label as an overall identifer should they wish to hide
 * redundant information.
 * 
 * @param {!dojo.data.api.Item} item The item to return the list of label attributes for.
 * @return {?}
 */
dojo.data.api.Notification.prototype.getLabelAttributes = function(item) {};

/**
 * Returns a single attribute value.
 * Returns defaultValue if and only if item does not have a value for attribute.
 * Returns null if and only if null was explicitly set as the attribute value.
 * Returns undefined if and only if the item does not have a value for the
 * given attribute (which is the same as saying the item does not have the attribute).
 * Saying that an "item x does not have a value for an attribute y"
 * is identical to saying that an "item x does not have attribute y".
 * It is an oxymoron to say "that attribute is present but has no values"
 * or "the item has that attribute but does not have any attribute values".
 * If store.hasAttribute(item, attribute) returns false, then
 * store.getValue(item, attribute) will return undefined.
 * 
 * @param {!dojo.data.api.Item} item The item to access values on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @param {?=} defaultValue               OptionalOptional.  A default value to use for the getValue return in the attribute does not exist or has no value.
 * @return {?}
 */
dojo.data.api.Notification.prototype.getValue = function(item, attribute, defaultValue) {};

/**
 * This getValues() method works just like the getValue() method, but getValues()
 * always returns an array rather than a single attribute value.  The array
 * may be empty, may contain a single attribute value, or may contain
 * many attribute values.
 * If the item does not have a value for the given attribute, then getValues()
 * will return an empty array: [].  (So, if store.hasAttribute(item, attribute)
 * has a return of false, then store.getValues(item, attribute) will return [].)
 * 
 * @param {!dojo.data.api.Item} item The item to access values on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @return {?}
 */
dojo.data.api.Notification.prototype.getValues = function(item, attribute) {};

/**
 * Returns true if the given item has a value for the given attribute.
 * 
 * @param {!dojo.data.api.Item} item The item to access attributes on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @return {void}
 */
dojo.data.api.Notification.prototype.hasAttribute = function(item, attribute) {};

/**
 * Returns true if something is an item and came from the store instance.
 * Returns false if something is a literal, an item from another store instance,
 * or is any object other than an item.
 * 
 * @param {?} something Can be anything.
 * @return {void}
 */
dojo.data.api.Notification.prototype.isItem = function(something) {};

/**
 * Returns false if isItem(something) is false.  Returns false if
 * if isItem(something) is true but the the item is not yet loaded
 * in local memory (for example, if the item has not yet been read
 * from the server).
 * 
 * @param {?} something Can be anything.
 * @return {void}
 */
dojo.data.api.Notification.prototype.isItemLoaded = function(something) {};

/**
 * Given an item, this method loads the item so that a subsequent call
 * to store.isItemLoaded(item) will return true.  If a call to
 * isItemLoaded() returns true before loadItem() is even called,
 * then loadItem() need not do any work at all and will not even invoke
 * the callback handlers.  So, before invoking this method, check that
 * the item has not already been loaded.
 * 
 * @param {!Object} keywordArgs An anonymous object that defines the item to load and callbacks to invoke when theload has completed.  The format of the object is as follows:{    item: object,    onItem: Function,    onError: Function,    scope: object}The item parameterThe item parameter is an object that represents the item in question that should becontained by the store.  This attribute is required.The onItem parameterFunction(item)The onItem parameter is the callback to invoke when the item has been loaded.  It takes only oneparameter, the fully loaded item.The onError parameterFunction(error)The onError parameter is the callback to invoke when the item load encountered an error.  It takes only oneparameter, the error objectThe scope parameterIf a scope object is provided, all of the callback functions (onItem,onError, etc) will be invoked in the context of the scope object.In the body of the callback function, the value of the "this"keyword will be the scope object.   If no scope object is provided,the callback functions will be called in the context of dojo.global().For example, onItem.call(scope, item, request) vs.onItem.call(dojo.global(), item, request)
 * @return {void}
 */
dojo.data.api.Notification.prototype.loadItem = function(keywordArgs) {};

/**
 * This function is called any time an item is deleted from the store.
 * It is called immediately after the store deleteItem processing has completed.
 * This function is called any time an item is deleted from the store.
 * It is called immediately after the store deleteItem processing has completed.
 * 
 * @param {!dojo.data.api.Item} deletedItem The item deleted.
 * @return {?}
 */
dojo.data.api.Notification.prototype.onDelete = function(deletedItem) {};

/**
 * This function is called any time a new item is created in the store.
 * It is called immediately after the store newItem processing has completed.
 * This function is called any time a new item is created in the store.
 * It is called immediately after the store newItem processing has completed.
 * 
 * @param {!dojo.data.api.Item} newItem The item created.
 * @param {!Object=} parentInfo               OptionalAn optional javascript object that is passed when the item created was placed in the storehierarchy as a value f another item's attribute, instead of a root level item.  Note that if thisfunction is invoked with a value for parentInfo, then onSet is not invoked stating the attribute ofthe parent item was modified.  This is to avoid getting two notification  events occurring when a new itemwith a parent is created.  The structure passed in is as follows:{    item: someItem,                         //The parent item    attribute:  "attribute-name-string",    //The attribute the new item was assigned to.    oldValue: something //Whatever was the previous value for the attribute.                //If it is a single-value attribute only, then this value will be a single value.                //If it was a multi-valued attribute, then this will be an array of all the values minus the new one.    newValue: something //The new value of the attribute.  In the case of single value calls, such as setValue, this value will be                //generally be an atomic value of some sort (string, int, etc, object).  In the case of multi-valued attributes,                //it will be an array.}
 * @return {?}
 */
dojo.data.api.Notification.prototype.onNew = function(newItem, parentInfo) {};

/**
 * This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.
 * This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.
 * Its purpose is to provide a hook point for those who wish to monitor actions on items in the store
 * in a simple manner.  The general expected usage is to dojo.connect() to the store's
 * implementation and be called after the store function is called.
 * 
 * This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.
 * This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.
 * Its purpose is to provide a hook point for those who wish to monitor actions on items in the store
 * in a simple manner.  The general expected usage is to dojo.connect() to the store's
 * implementation and be called after the store function is called.
 * 
 * This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.
 * This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.
 * Its purpose is to provide a hook point for those who wish to monitor actions on items in the store
 * in a simple manner.  The general expected usage is to dojo.connect() to the store's
 * implementation and be called after the store function is called.
 * 
 * This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.
 * This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.
 * Its purpose is to provide a hook point for those who wish to monitor actions on items in the store
 * in a simple manner.  The general expected usage is to dojo.connect() to the store's
 * implementation and be called after the store function is called.
 * 
 * @param {!dojo.data.api.Item} item The item being modified.
 * @param {!String} attribute The attribute being changed represented as a string name.
 * @param {!Object|!Array<?>} oldValue The old value of the attribute.  In the case of single value calls, such as setValue, unsetAttribute, etc,this value will be generally be an atomic value of some sort (string, int, etc, object).  In the case ofmulti-valued attributes, it will be an array.
 * @param {!Object|!Array<?>} newValue The new value of the attribute.  In the case of single value calls, such as setValue, this value will begenerally be an atomic value of some sort (string, int, etc, object).  In the case of multi-valued attributes,it will be an array.  In the case of unsetAttribute, the new value will be 'undefined'.
 * @return {?}
 */
dojo.data.api.Notification.prototype.onSet = function(item, attribute, oldValue, newValue) {};

/**
 * @constructor
 * @struct
 */
dojo.data.api.Read = function() {};

/**
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.  In general, this API
 * expects to receive as a parameter a request object returned from a fetch.
 * It will then close out anything associated with that request, such as
 * clearing any internal datastore caches and closing any 'open' connections.
 * For some store implementations, this call may be a no-op.
 * 
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.  In general, this API
 * expects to receive as a parameter a request object returned from a fetch.
 * It will then close out anything associated with that request, such as
 * clearing any internal datastore caches and closing any 'open' connections.
 * For some store implementations, this call may be a no-op.
 * 
 * @param {!dojo.data.api.Request|!Object=} request               OptionalAn instance of a request for the store to use to identify what to close out.If no request is passed, then the store should clear all internal caches (if any)and close out all 'open' connections.  It does not render the store unusable fromthere on, it merely cleans out any current data and resets the store to initialstate.
 * @return {void}
 */
dojo.data.api.Read.prototype.close = function(request) {};

/**
 * Returns true if the given value is one of the values that getValues()
 * would return.
 * 
 * @param {!dojo.data.api.Item} item The item to access values on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @param {?} value The value to match as a value for the attribute.
 * @return {void}
 */
dojo.data.api.Read.prototype.containsValue = function(item, attribute, value) {};

/**
 * Given a query and set of defined options, such as a start and count of items to return,
 * this method executes the query and makes the results available as data items.
 * The format and expectations of stores is that they operate in a generally asynchronous
 * manner, therefore callbacks are always used to return items located by the fetch parameters.
 * A Request object will always be returned and is returned immediately.
 * The basic request is nothing more than the keyword args passed to fetch and
 * an additional function attached, abort().  The returned request object may then be used
 * to cancel a fetch.  All data items returns are passed through the callbacks defined in the
 * fetch parameters and are not present on the 'request' object.
 * 
 * This does not mean that custom stores can not add methods and properties to the request object
 * returned, only that the API does not require it.  For more info about the Request API,
 * see dojo/data/api/Request
 * 
 * @param {!Object} keywordArgs The keywordArgs parameter may either be an instance ofconforming to dojo/data/api/Request or may be a simple anonymous objectthat may contain any of the following:{    query: query-object or query-string,    queryOptions: object,    onBegin: Function,    onItem: Function,    onComplete: Function,    onError: Function,    scope: object,    start: int    count: int    sort: array}All implementations should accept keywordArgs objects with any ofthe 9 standard properties: query, onBegin, onItem, onComplete, onErrorscope, sort, start, and count.  Some implementations may accept additionalproperties in the keywordArgs object as valid parameters, such as{includeOutliers:true}.The query parameterThe query may be optional in some data store implementations.The dojo/data/api/Read API does not specify the syntax or semanticsof the query itself -- each different data store implementationmay have its own notion of what a query should look like.However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.dataand dojox.data support an object structure query, where the object is a set ofname/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of thedijit widgets, such as ComboBox assume this to be the case when working with a datastorewhen they dynamically update the query.  Therefore, for maximum compatibility with dijitwidgets the recommended query parameter is a key/value object.  That does not mean that thethe datastore may not take alternative query forms, such as a simple string, a Date, a number,or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the queryformat.Further note:  In general for query objects that accept strings as attributevalue matches, the store should also support basic filtering capability, such as (match any character) and ? (match single character).  An example query that is a query objectwould be like: { attrFoo: "value"}.  Which generally means match all items where they havean attribute named attrFoo, with a value that starts with 'value'.The queryOptions parameterThe queryOptions parameter is an optional parameter used to specify options that may modifythe query in some fashion, such as doing a case insensitive search, or doing a deep searchwhere all items in a hierarchical representation of data are scanned instead of just the rootitems.  It currently defines two options that all datastores should attempt to honor if possible:{    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.    deep: boolean   // Whether or not a fetch should do a deep search of items and all child                    // items instead of just root-level items in a datastore.  Default is false.}The onBegin parameter.function(size, request);If an onBegin callback function is provided, the callback functionwill be called just once, before the first onItem callback is called.The onBegin callback function will be passed two arguments, thethe total number of items identified and the Request object.  If the total number isunknown, then size will be -1.  Note that size is not necessarily the size of thecollection of items returned from the query, as the request may have specified to return only asubset of the total set of items through the use of the start and count parameters.The onItem parameter.function(item, request);If an onItem callback function is provided, the callback functionwill be called as each item in the result is received. The callbackfunction will be passed two arguments: the item itself, and theRequest object.The onComplete parameter.function(items, request);If an onComplete callback function is provided, the callback functionwill be called just once, after the last onItem callback is called.Note that if the onItem callback is not present, then onComplete will be passedan array containing all items which matched the query and the request object.If the onItem callback is present, then onComplete is called as:onComplete(null, request).The onError parameter.function(errorData, request);If an onError callback function is provided, the callback functionwill be called if there is any sort of error while attempting toexecute the query.The onError callback function will be passed two arguments:an Error object and the Request object.The scope parameter.If a scope object is provided, all of the callback functions (onItem,onComplete, onError, etc) will be invoked in the context of the scopeobject.  In the body of the callback function, the value of the "this"keyword will be the scope object.   If no scope object is provided,the callback functions will be called in the context of dojo.global().For example, onItem.call(scope, item, request) vs.onItem.call(dojo.global(), item, request)The start parameter.If a start parameter is specified, this is a indication to the datastore toonly start returning items once the start number of items have been located andskipped.  When this parameter is paired with 'count', the store should be ableto page across queries with millions of hits by only returning subsets of thehits for each queryThe count parameter.If a count parameter is specified, this is a indication to the datastore toonly return up to that many items.  This allows a fetch call that may havemillions of item matches to be paired down to something reasonable.The sort parameter.If a sort parameter is specified, this is a indication to the datastore tosort the items in some manner before returning the items.  The array is an array ofjavascript objects that must conform to the following format to be applied to thefetching of items:{    attribute: attribute || attribute-name-string,    descending: true|false;   // Optional.  Default is false.}Note that when comparing attributes, if an item contains no value for the attribute(undefined), then it the default ascending sort logic should push it to the bottomof the list.  In the descending order case, it such items should appear at the top of the list.
 * @return {?}
 */
dojo.data.api.Read.prototype.fetch = function(keywordArgs) {};

/**
 * Returns an array with all the attributes that this item has.  This
 * method will always return an array; if the item has no attributes
 * at all, getAttributes() will return an empty array: [].
 * 
 * @param {!dojo.data.api.Item} item The item to access attributes on.
 * @return {void}
 */
dojo.data.api.Read.prototype.getAttributes = function(item) {};

/**
 * The getFeatures() method returns an simple keyword values object
 * that specifies what interface features the datastore implements.
 * A simple CsvStore may be read-only, and the only feature it
 * implements will be the 'dojo/data/api/Read' interface, so the
 * getFeatures() method will return an object like this one:
 * {'dojo.data.api.Read': true}.
 * A more sophisticated datastore might implement a variety of
 * interface features, like 'dojo.data.api.Read', 'dojo/data/api/Write',
 * 'dojo.data.api.Identity', and 'dojo/data/api/Attribution'.
 * 
 * @return {!Object}
 */
dojo.data.api.Read.prototype.getFeatures = function() {};

/**
 * Method to inspect the item and return a user-readable 'label' for the item
 * that provides a general/adequate description of what the item is.
 * Method to inspect the item and return a user-readable 'label' for the item
 * that provides a general/adequate description of what the item is.  In general
 * most labels will be a specific attribute value or collection of the attribute
 * values that combine to label the item in some manner.  For example for an item
 * that represents a person it may return the label as:  "firstname lastlame" where
 * the firstname and lastname are attributes on the item.  If the store is unable
 * to determine an adequate human readable label, it should return undefined.  Users that wish
 * to customize how a store instance labels items should replace the getLabel() function on
 * their instance of the store, or extend the store and replace the function in
 * the extension class.
 * 
 * @param {!dojo.data.api.Item} item The item to return the label for.
 * @return {?}
 */
dojo.data.api.Read.prototype.getLabel = function(item) {};

/**
 * Method to inspect the item and return an array of what attributes of the item were used
 * to generate its label, if any.
 * Method to inspect the item and return an array of what attributes of the item were used
 * to generate its label, if any.  This function is to assist UI developers in knowing what
 * attributes can be ignored out of the attributes an item has when displaying it, in cases
 * where the UI is using the label as an overall identifer should they wish to hide
 * redundant information.
 * 
 * @param {!dojo.data.api.Item} item The item to return the list of label attributes for.
 * @return {?}
 */
dojo.data.api.Read.prototype.getLabelAttributes = function(item) {};

/**
 * Returns a single attribute value.
 * Returns defaultValue if and only if item does not have a value for attribute.
 * Returns null if and only if null was explicitly set as the attribute value.
 * Returns undefined if and only if the item does not have a value for the
 * given attribute (which is the same as saying the item does not have the attribute).
 * Saying that an "item x does not have a value for an attribute y"
 * is identical to saying that an "item x does not have attribute y".
 * It is an oxymoron to say "that attribute is present but has no values"
 * or "the item has that attribute but does not have any attribute values".
 * If store.hasAttribute(item, attribute) returns false, then
 * store.getValue(item, attribute) will return undefined.
 * 
 * @param {!dojo.data.api.Item} item The item to access values on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @param {?=} defaultValue               OptionalOptional.  A default value to use for the getValue return in the attribute does not exist or has no value.
 * @return {?}
 */
dojo.data.api.Read.prototype.getValue = function(item, attribute, defaultValue) {};

/**
 * This getValues() method works just like the getValue() method, but getValues()
 * always returns an array rather than a single attribute value.  The array
 * may be empty, may contain a single attribute value, or may contain
 * many attribute values.
 * If the item does not have a value for the given attribute, then getValues()
 * will return an empty array: [].  (So, if store.hasAttribute(item, attribute)
 * has a return of false, then store.getValues(item, attribute) will return [].)
 * 
 * @param {!dojo.data.api.Item} item The item to access values on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @return {?}
 */
dojo.data.api.Read.prototype.getValues = function(item, attribute) {};

/**
 * Returns true if the given item has a value for the given attribute.
 * 
 * @param {!dojo.data.api.Item} item The item to access attributes on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @return {void}
 */
dojo.data.api.Read.prototype.hasAttribute = function(item, attribute) {};

/**
 * Returns true if something is an item and came from the store instance.
 * Returns false if something is a literal, an item from another store instance,
 * or is any object other than an item.
 * 
 * @param {?} something Can be anything.
 * @return {void}
 */
dojo.data.api.Read.prototype.isItem = function(something) {};

/**
 * Returns false if isItem(something) is false.  Returns false if
 * if isItem(something) is true but the the item is not yet loaded
 * in local memory (for example, if the item has not yet been read
 * from the server).
 * 
 * @param {?} something Can be anything.
 * @return {void}
 */
dojo.data.api.Read.prototype.isItemLoaded = function(something) {};

/**
 * Given an item, this method loads the item so that a subsequent call
 * to store.isItemLoaded(item) will return true.  If a call to
 * isItemLoaded() returns true before loadItem() is even called,
 * then loadItem() need not do any work at all and will not even invoke
 * the callback handlers.  So, before invoking this method, check that
 * the item has not already been loaded.
 * 
 * @param {!Object} keywordArgs An anonymous object that defines the item to load and callbacks to invoke when theload has completed.  The format of the object is as follows:{    item: object,    onItem: Function,    onError: Function,    scope: object}The item parameterThe item parameter is an object that represents the item in question that should becontained by the store.  This attribute is required.The onItem parameterFunction(item)The onItem parameter is the callback to invoke when the item has been loaded.  It takes only oneparameter, the fully loaded item.The onError parameterFunction(error)The onError parameter is the callback to invoke when the item load encountered an error.  It takes only oneparameter, the error objectThe scope parameterIf a scope object is provided, all of the callback functions (onItem,onError, etc) will be invoked in the context of the scope object.In the body of the callback function, the value of the "this"keyword will be the scope object.   If no scope object is provided,the callback functions will be called in the context of dojo.global().For example, onItem.call(scope, item, request) vs.onItem.call(dojo.global(), item, request)
 * @return {void}
 */
dojo.data.api.Read.prototype.loadItem = function(keywordArgs) {};

/**
 * @constructor
 * @struct
 */
dojo.data.api.Write = function() {};

/**
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.  In general, this API
 * expects to receive as a parameter a request object returned from a fetch.
 * It will then close out anything associated with that request, such as
 * clearing any internal datastore caches and closing any 'open' connections.
 * For some store implementations, this call may be a no-op.
 * 
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.
 * The close() method is intended for instructing the store to 'close' out
 * any information associated with a particular request.  In general, this API
 * expects to receive as a parameter a request object returned from a fetch.
 * It will then close out anything associated with that request, such as
 * clearing any internal datastore caches and closing any 'open' connections.
 * For some store implementations, this call may be a no-op.
 * 
 * @param {!dojo.data.api.Request|!Object=} request               OptionalAn instance of a request for the store to use to identify what to close out.If no request is passed, then the store should clear all internal caches (if any)and close out all 'open' connections.  It does not render the store unusable fromthere on, it merely cleans out any current data and resets the store to initialstate.
 * @return {void}
 */
dojo.data.api.Write.prototype.close = function(request) {};

/**
 * Returns true if the given value is one of the values that getValues()
 * would return.
 * 
 * @param {!dojo.data.api.Item} item The item to access values on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @param {?} value The value to match as a value for the attribute.
 * @return {void}
 */
dojo.data.api.Write.prototype.containsValue = function(item, attribute, value) {};

/**
 * Deletes an item from the store.
 * 
 * @param {!dojo.data.api.Item} item The item to delete.
 * @return {void}
 */
dojo.data.api.Write.prototype.deleteItem = function(item) {};

/**
 * Given a query and set of defined options, such as a start and count of items to return,
 * this method executes the query and makes the results available as data items.
 * The format and expectations of stores is that they operate in a generally asynchronous
 * manner, therefore callbacks are always used to return items located by the fetch parameters.
 * A Request object will always be returned and is returned immediately.
 * The basic request is nothing more than the keyword args passed to fetch and
 * an additional function attached, abort().  The returned request object may then be used
 * to cancel a fetch.  All data items returns are passed through the callbacks defined in the
 * fetch parameters and are not present on the 'request' object.
 * 
 * This does not mean that custom stores can not add methods and properties to the request object
 * returned, only that the API does not require it.  For more info about the Request API,
 * see dojo/data/api/Request
 * 
 * @param {!Object} keywordArgs The keywordArgs parameter may either be an instance ofconforming to dojo/data/api/Request or may be a simple anonymous objectthat may contain any of the following:{    query: query-object or query-string,    queryOptions: object,    onBegin: Function,    onItem: Function,    onComplete: Function,    onError: Function,    scope: object,    start: int    count: int    sort: array}All implementations should accept keywordArgs objects with any ofthe 9 standard properties: query, onBegin, onItem, onComplete, onErrorscope, sort, start, and count.  Some implementations may accept additionalproperties in the keywordArgs object as valid parameters, such as{includeOutliers:true}.The query parameterThe query may be optional in some data store implementations.The dojo/data/api/Read API does not specify the syntax or semanticsof the query itself -- each different data store implementationmay have its own notion of what a query should look like.However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.dataand dojox.data support an object structure query, where the object is a set ofname/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of thedijit widgets, such as ComboBox assume this to be the case when working with a datastorewhen they dynamically update the query.  Therefore, for maximum compatibility with dijitwidgets the recommended query parameter is a key/value object.  That does not mean that thethe datastore may not take alternative query forms, such as a simple string, a Date, a number,or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the queryformat.Further note:  In general for query objects that accept strings as attributevalue matches, the store should also support basic filtering capability, such as (match any character) and ? (match single character).  An example query that is a query objectwould be like: { attrFoo: "value"}.  Which generally means match all items where they havean attribute named attrFoo, with a value that starts with 'value'.The queryOptions parameterThe queryOptions parameter is an optional parameter used to specify options that may modifythe query in some fashion, such as doing a case insensitive search, or doing a deep searchwhere all items in a hierarchical representation of data are scanned instead of just the rootitems.  It currently defines two options that all datastores should attempt to honor if possible:{    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.    deep: boolean   // Whether or not a fetch should do a deep search of items and all child                    // items instead of just root-level items in a datastore.  Default is false.}The onBegin parameter.function(size, request);If an onBegin callback function is provided, the callback functionwill be called just once, before the first onItem callback is called.The onBegin callback function will be passed two arguments, thethe total number of items identified and the Request object.  If the total number isunknown, then size will be -1.  Note that size is not necessarily the size of thecollection of items returned from the query, as the request may have specified to return only asubset of the total set of items through the use of the start and count parameters.The onItem parameter.function(item, request);If an onItem callback function is provided, the callback functionwill be called as each item in the result is received. The callbackfunction will be passed two arguments: the item itself, and theRequest object.The onComplete parameter.function(items, request);If an onComplete callback function is provided, the callback functionwill be called just once, after the last onItem callback is called.Note that if the onItem callback is not present, then onComplete will be passedan array containing all items which matched the query and the request object.If the onItem callback is present, then onComplete is called as:onComplete(null, request).The onError parameter.function(errorData, request);If an onError callback function is provided, the callback functionwill be called if there is any sort of error while attempting toexecute the query.The onError callback function will be passed two arguments:an Error object and the Request object.The scope parameter.If a scope object is provided, all of the callback functions (onItem,onComplete, onError, etc) will be invoked in the context of the scopeobject.  In the body of the callback function, the value of the "this"keyword will be the scope object.   If no scope object is provided,the callback functions will be called in the context of dojo.global().For example, onItem.call(scope, item, request) vs.onItem.call(dojo.global(), item, request)The start parameter.If a start parameter is specified, this is a indication to the datastore toonly start returning items once the start number of items have been located andskipped.  When this parameter is paired with 'count', the store should be ableto page across queries with millions of hits by only returning subsets of thehits for each queryThe count parameter.If a count parameter is specified, this is a indication to the datastore toonly return up to that many items.  This allows a fetch call that may havemillions of item matches to be paired down to something reasonable.The sort parameter.If a sort parameter is specified, this is a indication to the datastore tosort the items in some manner before returning the items.  The array is an array ofjavascript objects that must conform to the following format to be applied to thefetching of items:{    attribute: attribute || attribute-name-string,    descending: true|false;   // Optional.  Default is false.}Note that when comparing attributes, if an item contains no value for the attribute(undefined), then it the default ascending sort logic should push it to the bottomof the list.  In the descending order case, it such items should appear at the top of the list.
 * @return {?}
 */
dojo.data.api.Write.prototype.fetch = function(keywordArgs) {};

/**
 * Returns an array with all the attributes that this item has.  This
 * method will always return an array; if the item has no attributes
 * at all, getAttributes() will return an empty array: [].
 * 
 * @param {!dojo.data.api.Item} item The item to access attributes on.
 * @return {void}
 */
dojo.data.api.Write.prototype.getAttributes = function(item) {};

/**
 * See dojo/data/api/Read.getFeatures()
 * 
 * @return {!Object}
 */
dojo.data.api.Write.prototype.getFeatures = function() {};

/**
 * Method to inspect the item and return a user-readable 'label' for the item
 * that provides a general/adequate description of what the item is.
 * Method to inspect the item and return a user-readable 'label' for the item
 * that provides a general/adequate description of what the item is.  In general
 * most labels will be a specific attribute value or collection of the attribute
 * values that combine to label the item in some manner.  For example for an item
 * that represents a person it may return the label as:  "firstname lastlame" where
 * the firstname and lastname are attributes on the item.  If the store is unable
 * to determine an adequate human readable label, it should return undefined.  Users that wish
 * to customize how a store instance labels items should replace the getLabel() function on
 * their instance of the store, or extend the store and replace the function in
 * the extension class.
 * 
 * @param {!dojo.data.api.Item} item The item to return the label for.
 * @return {?}
 */
dojo.data.api.Write.prototype.getLabel = function(item) {};

/**
 * Method to inspect the item and return an array of what attributes of the item were used
 * to generate its label, if any.
 * Method to inspect the item and return an array of what attributes of the item were used
 * to generate its label, if any.  This function is to assist UI developers in knowing what
 * attributes can be ignored out of the attributes an item has when displaying it, in cases
 * where the UI is using the label as an overall identifer should they wish to hide
 * redundant information.
 * 
 * @param {!dojo.data.api.Item} item The item to return the list of label attributes for.
 * @return {?}
 */
dojo.data.api.Write.prototype.getLabelAttributes = function(item) {};

/**
 * Returns a single attribute value.
 * Returns defaultValue if and only if item does not have a value for attribute.
 * Returns null if and only if null was explicitly set as the attribute value.
 * Returns undefined if and only if the item does not have a value for the
 * given attribute (which is the same as saying the item does not have the attribute).
 * Saying that an "item x does not have a value for an attribute y"
 * is identical to saying that an "item x does not have attribute y".
 * It is an oxymoron to say "that attribute is present but has no values"
 * or "the item has that attribute but does not have any attribute values".
 * If store.hasAttribute(item, attribute) returns false, then
 * store.getValue(item, attribute) will return undefined.
 * 
 * @param {!dojo.data.api.Item} item The item to access values on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @param {?=} defaultValue               OptionalOptional.  A default value to use for the getValue return in the attribute does not exist or has no value.
 * @return {?}
 */
dojo.data.api.Write.prototype.getValue = function(item, attribute, defaultValue) {};

/**
 * This getValues() method works just like the getValue() method, but getValues()
 * always returns an array rather than a single attribute value.  The array
 * may be empty, may contain a single attribute value, or may contain
 * many attribute values.
 * If the item does not have a value for the given attribute, then getValues()
 * will return an empty array: [].  (So, if store.hasAttribute(item, attribute)
 * has a return of false, then store.getValues(item, attribute) will return [].)
 * 
 * @param {!dojo.data.api.Item} item The item to access values on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @return {?}
 */
dojo.data.api.Write.prototype.getValues = function(item, attribute) {};

/**
 * Returns true if the given item has a value for the given attribute.
 * 
 * @param {!dojo.data.api.Item} item The item to access attributes on.
 * @param {!String} attribute The attribute to access represented as a string.
 * @return {void}
 */
dojo.data.api.Write.prototype.hasAttribute = function(item, attribute) {};

/**
 * Given an item, isDirty() returns true if the item has been modified
 * since the last save().  If isDirty() is called with no item argument,
 * then this function returns true if any item has been modified since
 * the last save().
 * 
 * @param {?=} item               OptionalThe item to check.
 * @return {void}
 */
dojo.data.api.Write.prototype.isDirty = function(item) {};

/**
 * Returns true if something is an item and came from the store instance.
 * Returns false if something is a literal, an item from another store instance,
 * or is any object other than an item.
 * 
 * @param {?} something Can be anything.
 * @return {void}
 */
dojo.data.api.Write.prototype.isItem = function(something) {};

/**
 * Returns false if isItem(something) is false.  Returns false if
 * if isItem(something) is true but the the item is not yet loaded
 * in local memory (for example, if the item has not yet been read
 * from the server).
 * 
 * @param {?} something Can be anything.
 * @return {void}
 */
dojo.data.api.Write.prototype.isItemLoaded = function(something) {};

/**
 * Given an item, this method loads the item so that a subsequent call
 * to store.isItemLoaded(item) will return true.  If a call to
 * isItemLoaded() returns true before loadItem() is even called,
 * then loadItem() need not do any work at all and will not even invoke
 * the callback handlers.  So, before invoking this method, check that
 * the item has not already been loaded.
 * 
 * @param {!Object} keywordArgs An anonymous object that defines the item to load and callbacks to invoke when theload has completed.  The format of the object is as follows:{    item: object,    onItem: Function,    onError: Function,    scope: object}The item parameterThe item parameter is an object that represents the item in question that should becontained by the store.  This attribute is required.The onItem parameterFunction(item)The onItem parameter is the callback to invoke when the item has been loaded.  It takes only oneparameter, the fully loaded item.The onError parameterFunction(error)The onError parameter is the callback to invoke when the item load encountered an error.  It takes only oneparameter, the error objectThe scope parameterIf a scope object is provided, all of the callback functions (onItem,onError, etc) will be invoked in the context of the scope object.In the body of the callback function, the value of the "this"keyword will be the scope object.   If no scope object is provided,the callback functions will be called in the context of dojo.global().For example, onItem.call(scope, item, request) vs.onItem.call(dojo.global(), item, request)
 * @return {void}
 */
dojo.data.api.Write.prototype.loadItem = function(keywordArgs) {};

/**
 * Returns a newly created item.  Sets the attributes of the new
 * item based on the keywordArgs provided.  In general, the attribute
 * names in the keywords become the attributes in the new item and as for
 * the attribute values in keywordArgs, they become the values of the attributes
 * in the new item.  In addition, for stores that support hierarchical item
 * creation, an optional second parameter is accepted that defines what item is the parent
 * of the new item and what attribute of that item should the new item be assigned to.
 * In general, this will assume that the attribute targeted is multi-valued and a new item
 * is appended onto the list of values for that attribute.
 * 
 * @param {!Object=} keywordArgs               OptionalA javascript object defining the initial content of the item as a set of JavaScript 'property name: value' pairs.
 * @param {!Object=} parentInfo               OptionalAn optional javascript object defining what item is the parent of this item (in a hierarchical store.  Not all stores do hierarchical items),and what attribute of that parent to assign the new item to.  If this is present, and the attribute specifiedis a multi-valued attribute, it will append this item into the array of values for that attribute.  The structureof the object is as follows:{    parent: someItem,    attribute: "attribute-name-string"}
 * @return {void}
 */
dojo.data.api.Write.prototype.newItem = function(keywordArgs, parentInfo) {};

/**
 * Discards any unsaved changes.
 * Discards any unsaved changes.
 * 
 * @return {void}
 */
dojo.data.api.Write.prototype.revert = function() {};

/**
 * Saves to the server all the changes that have been made locally.
 * The save operation may take some time and is generally performed
 * in an asynchronous fashion.  The outcome of the save action is
 * is passed into the set of supported callbacks for the save.
 * 
 * @param {!Object} keywordArgs {    onComplete: function    onError: function    scope: object} ####The *onComplete* parameter. function(); If an onComplete callback function is provided, the callback function will be called just once, after the save has completed.  No parameters are generally passed to the onComplete. ####The *onError* parameter. function(errorData); If an onError callback function is provided, the callback function will be called if there is any sort of error while attempting to execute the save.  The onError function will be based one parameter, the error. ####The *scope* parameter. If a scope object is provided, all of the callback function ( onComplete, onError, etc) will be invoked in the context of the scope object.  In the body of the callback function, the value of the "this" keyword will be the scope object.   If no scope object is provided, the callback functions will be called in the context of dojo.global. For example, onComplete.call(scope) vs. onComplete.call(dojo.global)
 * @return {?}
 */
dojo.data.api.Write.prototype.save = function(keywordArgs) {};

/**
 * Sets the value of an attribute on an item.
 * Replaces any previous value or values.
 * 
 * @param {!dojo.data.api.Item} item The item to modify.
 * @param {!String} attribute The attribute of the item to change represented as a string name.
 * @param {?} value The value to assign to the item.
 * @return {void}
 */
dojo.data.api.Write.prototype.setValue = function(item, attribute, value) {};

/**
 * Adds each value in the values array as a value of the given
 * attribute on the given item.
 * Replaces any previous value or values.
 * Calling store.setValues(x, y, []) (with values as an empty array) has
 * the same effect as calling store.unsetAttribute(x, y).
 * 
 * @param {!dojo.data.api.Item} item The item to modify.
 * @param {!String} attribute The attribute of the item to change represented as a string name.
 * @param {!Array<?>} values An array of values to assign to the attribute..
 * @return {void}
 */
dojo.data.api.Write.prototype.setValues = function(item, attribute, values) {};

/**
 * Deletes all the values of an attribute on an item.
 * 
 * @param {!dojo.data.api.Item} item The item to modify.
 * @param {!String} attribute The attribute of the item to unset represented as a string.
 * @return {void}
 */
dojo.data.api.Write.prototype.unsetAttribute = function(item, attribute) {};
/** @const */
dojo.data.util = {};
/**
 * @record
 * @struct
 */
dojo.data.util.filter = function() {};

/**
 * Helper function to convert a simple pattern to a regular expression for matching.
 * Returns a regular expression object that conforms to the defined conversion rules.
 * For example:
 * 
 * ca   -> /^ca.$/
 * ca  -> /^.ca.$/
 * c\a  -> /^.c*a.*$/
 * c\a?  -> /^.c*a..*$/
 * and so on.
 * 
 * @param {!String} pattern A simple matching pattern to convert that follows basic rules:Means match anything, so ca* means match anything starting with ca? Means match single character.  So, b?b will match to bob and bab, and so on.\ is an escape character.  So for example, * means do not treat  as a match, but literal character .To use a \ as a character in the string, it must be escaped.  So in the pattern it should berepresented by \ to be treated as an ordinary \ character instead of an escape.
 * @param {boolean=} ignoreCase               OptionalAn optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparingBy default, it is assumed case sensitive.
 * @return {?}
 */
dojo.data.util.filter.prototype.patternToRegExp = function(pattern, ignoreCase) {};
/**
 * @record
 * @struct
 */
dojo.data.util.simpleFetch = function() {};

/**
 * The error handler when there is an error fetching items.  This function should not be called
 * directly and is used by simpleFetch.fetch().
 * 
 * @param {!Object} errorData
 * @param {!Object} requestObject
 * @return {void}
 */
dojo.data.util.simpleFetch.prototype.errorHandler = function(errorData, requestObject) {};

/**
 * The simpleFetch mixin is designed to serve as a set of function(s) that can
 * be mixed into other datastore implementations to accelerate their development.
 * The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
 * call by returning an array of all the found items that matched the query.  The simpleFetch mixin
 * is not designed to work for datastores that respond to a fetch() call by incrementally
 * loading items, or sequentially loading partial batches of the result
 * set.  For datastores that mixin simpleFetch, simpleFetch
 * implements a fetch method that automatically handles eight of the fetch()
 * arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
 * The class mixing in simpleFetch should not implement fetch(),
 * but should instead implement a _fetchItems() method.  The _fetchItems()
 * method takes three arguments, the keywordArgs object that was passed
 * to fetch(), a callback function to be called when the result array is
 * available, and an error callback to be called if something goes wrong.
 * The _fetchItems() method should ignore any keywordArgs parameters for
 * start, count, onBegin, onItem, onComplete, onError, sort, and scope.
 * The _fetchItems() method needs to correctly handle any other keywordArgs
 * parameters, including the query parameter and any optional parameters
 * (such as includeChildren).  The _fetchItems() method should create an array of
 * result items and pass it to the fetchHandler along with the original request object --
 * or, the _fetchItems() method may, if it wants to, create an new request object
 * with other specifics about the request that are specific to the datastore and pass
 * that as the request object to the handler.
 * 
 * For more information on this specific function, see dojo/data/api/Read.fetch()
 * 
 * @param {!Object} request               OptionalThe keywordArgs parameter may either be an instance ofconforming to dojo/data/api/Request or may be a simple anonymous objectthat may contain any of the following:{    query: query-object or query-string,    queryOptions: object,    onBegin: Function,    onItem: Function,    onComplete: Function,    onError: Function,    scope: object,    start: int    count: int    sort: array}All implementations should accept keywordArgs objects with any ofthe 9 standard properties: query, onBegin, onItem, onComplete, onErrorscope, sort, start, and count.  Some implementations may accept additionalproperties in the keywordArgs object as valid parameters, such as{includeOutliers:true}.The query parameterThe query may be optional in some data store implementations.The dojo/data/api/Read API does not specify the syntax or semanticsof the query itself -- each different data store implementationmay have its own notion of what a query should look like.However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.dataand dojox.data support an object structure query, where the object is a set ofname/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of thedijit widgets, such as ComboBox assume this to be the case when working with a datastorewhen they dynamically update the query.  Therefore, for maximum compatibility with dijitwidgets the recommended query parameter is a key/value object.  That does not mean that thethe datastore may not take alternative query forms, such as a simple string, a Date, a number,or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the queryformat.Further note:  In general for query objects that accept strings as attributevalue matches, the store should also support basic filtering capability, such as (match any character) and ? (match single character).  An example query that is a query objectwould be like: { attrFoo: "value"}.  Which generally means match all items where they havean attribute named attrFoo, with a value that starts with 'value'.The queryOptions parameterThe queryOptions parameter is an optional parameter used to specify options that may modifythe query in some fashion, such as doing a case insensitive search, or doing a deep searchwhere all items in a hierarchical representation of data are scanned instead of just the rootitems.  It currently defines two options that all datastores should attempt to honor if possible:{    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.    deep: boolean   // Whether or not a fetch should do a deep search of items and all child                    // items instead of just root-level items in a datastore.  Default is false.}The onBegin parameter.function(size, request);If an onBegin callback function is provided, the callback functionwill be called just once, before the first onItem callback is called.The onBegin callback function will be passed two arguments, thethe total number of items identified and the Request object.  If the total number isunknown, then size will be -1.  Note that size is not necessarily the size of thecollection of items returned from the query, as the request may have specified to return only asubset of the total set of items through the use of the start and count parameters.The onItem parameter.function(item, request);If an onItem callback function is provided, the callback functionwill be called as each item in the result is received. The callbackfunction will be passed two arguments: the item itself, and theRequest object.The onComplete parameter.function(items, request);If an onComplete callback function is provided, the callback functionwill be called just once, after the last onItem callback is called.Note that if the onItem callback is not present, then onComplete will be passedan array containing all items which matched the query and the request object.If the onItem callback is present, then onComplete is called as:onComplete(null, request).The onError parameter.function(errorData, request);If an onError callback function is provided, the callback functionwill be called if there is any sort of error while attempting toexecute the query.The onError callback function will be passed two arguments:an Error object and the Request object.The scope parameter.If a scope object is provided, all of the callback functions (onItem,onComplete, onError, etc) will be invoked in the context of the scopeobject.  In the body of the callback function, the value of the "this"keyword will be the scope object.   If no scope object is provided,the callback functions will be called in the context of dojo.global().For example, onItem.call(scope, item, request) vs.onItem.call(dojo.global(), item, request)The start parameter.If a start parameter is specified, this is a indication to the datastore toonly start returning items once the start number of items have been located andskipped.  When this parameter is paired with 'count', the store should be ableto page across queries with millions of hits by only returning subsets of thehits for each queryThe count parameter.If a count parameter is specified, this is a indication to the datastore toonly return up to that many items.  This allows a fetch call that may havemillions of item matches to be paired down to something reasonable.The sort parameter.If a sort parameter is specified, this is a indication to the datastore tosort the items in some manner before returning the items.  The array is an array ofjavascript objects that must conform to the following format to be applied to thefetching of items:{    attribute: attribute || attribute-name-string,    descending: true|false;   // Optional.  Default is false.}Note that when comparing attributes, if an item contains no value for the attribute(undefined), then it the default ascending sort logic should push it to the bottomof the list.  In the descending order case, it such items should appear at the top of the list.
 * @return {void}
 */
dojo.data.util.simpleFetch.prototype.fetch = function(request) {};

/**
 * The handler when items are sucessfully fetched.  This function should not be called directly
 * and is used by simpleFetch.fetch().
 * 
 * @param {!Array<?>} items
 * @param {!Object} requestObject
 * @return {void}
 */
dojo.data.util.simpleFetch.prototype.fetchHandler = function(items, requestObject) {};
/**
 * @record
 * @struct
 */
dojo.data.util.sorter = function() {};

/**
 * Basic comparison function that compares if an item is greater or less than another item
 * returns 1 if a > b, -1 if a < b, 0 if equal.
 * 'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
 * And compared to each other, null is equivalent to undefined.
 * 
 * @param {?} a
 * @param {?} b
 * @return {number}
 */
dojo.data.util.sorter.prototype.basicComparator = function(a, b) {};

/**
 * Helper function to generate the sorting function based off the list of sort attributes.
 * The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
 * it will look in the mapping for comparisons function for the attributes.  If one is found, it will
 * use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
 * Returns the sorting function for this particular list of attributes and sorting directions.
 * 
 * @param {!Object} sortSpec A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.The objects should be formatted as follows:{    attribute: "attributeName-string" || attribute,    descending: true|false;   // Default is false.}
 * @param {!dojo.data.api.Read} store The datastore object to look up item values from.
 * @return {!Array<!String>}
 */
dojo.data.util.sorter.prototype.createSortFunction = function(sortSpec, store) {};
/** @const */
dojo.dnd = {};

/**
 * @constructor
 * @struct
 * @param {?} manager
 */
dojo.dnd.Avatar = function(manager) {};

/* TODO: PropertyDeclaration: dojo.dnd."manager" */

/**
 * constructor function;
 * it is separate so it can be (dynamically) overwritten in case of need
 * 
 * @return {void}
 */
dojo.dnd.Avatar.prototype.construct = function() {};

/**
 * destructor for the avatar; called to remove all references so it can be garbage-collected
 * 
 * @return {void}
 */
dojo.dnd.Avatar.prototype.destroy = function() {};

/**
 * updates the avatar to reflect the current DnD state
 * 
 * @return {void}
 */
dojo.dnd.Avatar.prototype.update = function() {};

/**
 * @constructor
 * @struct
 */
dojo.dnd.Manager = function() {};

/* TODO: PropertyDeclaration: dojo.dnd."OFFSET_X" */

/* TODO: PropertyDeclaration: dojo.dnd."OFFSET_Y" */

/**
 * called to notify if the current target can accept items
 * 
 * @param {?} flag
 * @return {void}
 */
dojo.dnd.Manager.prototype.canDrop = function(flag) {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.dnd.Manager.prototype.emit = function(type, event) {};

/**
 * makes the avatar; it is separate to be overwritten dynamically, if needed
 * 
 * @return {?}
 */
dojo.dnd.Manager.prototype.makeAvatar = function() {};

/**
 * Returns the current DnD manager.  Creates one if it is not created yet.
 * 
 * @return {?}
 */
dojo.dnd.Manager.prototype.manager = function() {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.dnd.Manager.prototype.on = function(type, listener) {};

/**
 * called when a source detected a mouse-out condition
 * 
 * @param {!Object} source the reporter
 * @return {void}
 */
dojo.dnd.Manager.prototype.outSource = function(source) {};

/**
 * called when a source detected a mouse-over condition
 * 
 * @param {!Object} source the reporter
 * @return {void}
 */
dojo.dnd.Manager.prototype.overSource = function(source) {};

/**
 * called to initiate the DnD operation
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @return {void}
 */
dojo.dnd.Manager.prototype.startDrag = function(source, nodes, copy) {};

/**
 * stop the DnD in progress
 * 
 * @return {void}
 */
dojo.dnd.Manager.prototype.stopDrag = function() {};

/**
 * updates the avatar; it is separate to be overwritten dynamically, if needed
 * 
 * @return {void}
 */
dojo.dnd.Manager.prototype.updateAvatar = function() {};

/**
 * event processor for onkeydown:
 * watching for CTRL for copy/move status, watching for ESCAPE to cancel the drag
 * 
 * @param {!Event} e keyboard event
 * @return {void}
 */
dojo.dnd.Manager.prototype.onKeyDown = function(e) {};

/**
 * event processor for onkeyup, watching for CTRL for copy/move status
 * 
 * @param {!Event} e keyboard event
 * @return {void}
 */
dojo.dnd.Manager.prototype.onKeyUp = function(e) {};

/**
 * event processor for onmousemove
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Manager.prototype.onMouseMove = function(e) {};

/**
 * event processor for onmouseup
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Manager.prototype.onMouseUp = function(e) {};

/**
 * @constructor
 * @struct
 * @param {!HTMLElement} node
 * @param {!Object} params
 */
dojo.dnd.Container = function(node, params) {};

/* TODO: PropertyDeclaration: dojo.dnd."allowNested" */

/* TODO: PropertyDeclaration: dojo.dnd."current" */

/* TODO: PropertyDeclaration: dojo.dnd."map" */
 /** @type {!HTMLElement} */
dojo.dnd.Container.prototype.node;

/* TODO: PropertyDeclaration: dojo.dnd."skipForm" */

/**
 * removes all data items from the map
 * 
 * @return {void}
 */
dojo.dnd.Container.prototype.clearItems = function() {};

/**
 * creator function, dummy at the moment
 * 
 * @return {void}
 */
dojo.dnd.Container.prototype.creator = function() {};

/**
 * removes a data item from the map by its key (id)
 * 
 * @param {!String} key
 * @return {void}
 */
dojo.dnd.Container.prototype.delItem = function(key) {};

/**
 * prepares this object to be garbage-collected
 * 
 * @return {void}
 */
dojo.dnd.Container.prototype.destroy = function() {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.dnd.Container.prototype.emit = function(type, event) {};

/**
 * iterates over a data map skipping members that
 * are present in the empty object (IE and/or 3rd-party libraries).
 * 
 * @param {!Function} f
 * @param {!Object} o               Optional
 * @return {!String}
 */
dojo.dnd.Container.prototype.forInItems = function(f, o) {};

/**
 * returns a list (an array) of all valid child nodes
 * 
 * @return {?}
 */
dojo.dnd.Container.prototype.getAllNodes = function() {};

/**
 * returns a data item by its key (id)
 * 
 * @param {!String} key
 * @return {?}
 */
dojo.dnd.Container.prototype.getItem = function(key) {};

/**
 * inserts an array of new nodes before/after an anchor node
 * 
 * @param {boolean=} addSelected
 * @param {!Array<?>=} data Logical representation of the object being dragged.If the drag object's type is "text" then data is a String,if it's another type then data could be a different Object,perhaps a name/value hash.
 * @param {boolean=} before insert before the anchor, if true, and after the anchor otherwise
 * @param {!HTMLElement=} anchor the anchor node to be used as a point of insertion
 * @return {!Function}
 */
dojo.dnd.Container.prototype.insertNodes = function(addSelected, data, before, anchor) {};

/**
 * Represents (one of) the source node(s) being dragged.
 * Contains (at least) the "type" and "data" attributes.
 * 
 * @return {void}
 */
dojo.dnd.Container.prototype.Item = function() {};

/**
 *
 * @param {?} params
 * @param {?} node
 * @param {?} Ctor
 * @return {?}
 */
dojo.dnd.Container.prototype.markupFactory = function(params, node, Ctor) {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.dnd.Container.prototype.on = function(type, listener) {};

/**
 * associates a data item with its key (id)
 * 
 * @param {!String} key
 * @param {?} data
 * @return {void}
 */
dojo.dnd.Container.prototype.setItem = function(key, data) {};

/**
 * collects valid child items and populate the map
 * 
 * @return {void}
 */
dojo.dnd.Container.prototype.startup = function() {};

/**
 * sync up the node list with the data map
 * 
 * @return {!Function}
 */
dojo.dnd.Container.prototype.sync = function() {};

/**
 * event processor for onmouseout
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Container.prototype.onMouseOut = function(e) {};

/**
 * event processor for onmouseover or touch, to mark that element as the current element
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Container.prototype.onMouseOver = function(e) {};

/**
 * this function is called once, when mouse is out of our container
 * 
 * @return {void}
 */
dojo.dnd.Container.prototype.onOutEvent = function() {};

/**
 * this function is called once, when mouse is over our container
 * 
 * @return {void}
 */
dojo.dnd.Container.prototype.onOverEvent = function() {};

/**
 * event processor for onselectevent and ondragevent
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Container.prototype.onSelectStart = function(e) {};

/**
 * @constructor
 * @struct
 */
dojo.dnd.Container.__ContainerArgs = function() {};

/* TODO: PropertyDeclaration: dojo.dnd.Container."dropParent" */

/* TODO: PropertyDeclaration: dojo.dnd.Container."skipForm" */

/**
 * a creator function, which takes a data item, and returns an object like that:
 * {node: newNode, data: usedData, type: arrayOfStrings}
 * 
 * @return {void}
 */
dojo.dnd.Container.__ContainerArgs.prototype.creator = function() {};

/**
 * @constructor
 * @struct
 * @param {?} node
 * @param {?} params
 */
dojo.dnd.AutoSource = function(node, params) {};

/* TODO: PropertyDeclaration: dojo.dnd."accept" */

/* TODO: PropertyDeclaration: dojo.dnd."allowNested" */

/* TODO: PropertyDeclaration: dojo.dnd."autoSync" */

/* TODO: PropertyDeclaration: dojo.dnd."copyOnly" */

/* TODO: PropertyDeclaration: dojo.dnd."current" */

/* TODO: PropertyDeclaration: dojo.dnd."delay" */

/* TODO: PropertyDeclaration: dojo.dnd."generateText" */

/* TODO: PropertyDeclaration: dojo.dnd."horizontal" */

/* TODO: PropertyDeclaration: dojo.dnd."isSource" */

/* TODO: PropertyDeclaration: dojo.dnd."map" */

/* TODO: PropertyDeclaration: dojo.dnd."selection" */

/* TODO: PropertyDeclaration: dojo.dnd."selfAccept" */

/* TODO: PropertyDeclaration: dojo.dnd."selfCopy" */

/* TODO: PropertyDeclaration: dojo.dnd."singular" */

/* TODO: PropertyDeclaration: dojo.dnd."skipForm" */

/* TODO: PropertyDeclaration: dojo.dnd."withHandles" */

/**
 * checks if the target can accept nodes from this source
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @return {boolean}
 */
dojo.dnd.AutoSource.prototype.checkAcceptance = function(source, nodes) {};

/**
 * removes all data items from the map
 * 
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.clearItems = function() {};

/**
 * Returns true if we need to copy items, false to move.
 * It is separated to be overwritten dynamically, if needed.
 * 
 * @param {boolean} keyPressed the "copy" key was pressed
 * @param {boolean=} self               Optionaloptional flag that means that we are about to drop on itself
 * @return {?}
 */
dojo.dnd.AutoSource.prototype.copyState = function(keyPressed, self) {};

/**
 * creator function, dummy at the moment
 * 
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.creator = function() {};

/**
 * deletes all selected items
 * 
 * @return {!Function}
 */
dojo.dnd.AutoSource.prototype.deleteSelectedNodes = function() {};

/**
 * removes a data item from the map by its key (id)
 * 
 * @param {!String} key
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.delItem = function(key) {};

/**
 * prepares the object to be garbage-collected
 * 
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.destroy = function() {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.dnd.AutoSource.prototype.emit = function(type, event) {};

/**
 * iterates over a data map skipping members that
 * are present in the empty object (IE and/or 3rd-party libraries).
 * 
 * @param {!Function} f
 * @param {!Object=} o               Optional
 * @return {!String}
 */
dojo.dnd.AutoSource.prototype.forInItems = function(f, o) {};

/**
 * iterates over selected items;
 * see dojo/dnd/Container.forInItems() for details
 * 
 * @param {!Function} f
 * @param {!Object=} o               Optional
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.forInSelectedItems = function(f, o) {};

/**
 * returns a list (an array) of all valid child nodes
 * 
 * @return {?}
 */
dojo.dnd.AutoSource.prototype.getAllNodes = function() {};

/**
 * returns a data item by its key (id)
 * 
 * @param {!String} key
 * @return {?}
 */
dojo.dnd.AutoSource.prototype.getItem = function(key) {};

/**
 * returns a list (an array) of selected nodes
 * 
 * @return {?}
 */
dojo.dnd.AutoSource.prototype.getSelectedNodes = function() {};

/**
 * inserts new data items (see dojo/dnd/Container.insertNodes() method for details)
 * 
 * @param {boolean} addSelected all new nodes will be added to selected items, if true, no selection change otherwise
 * @param {!Array<?>} data a list of data items, which should be processed by the creator function
 * @param {boolean} before insert before the anchor, if true, and after the anchor otherwise
 * @param {!HTMLElement} anchor the anchor node to be used as a point of insertion
 * @return {!Function}
 */
dojo.dnd.AutoSource.prototype.insertNodes = function(addSelected, data, before, anchor) {};

/**
 *
 * @param {?} params
 * @param {?} node
 * @param {?} Ctor
 * @return {?}
 */
dojo.dnd.AutoSource.prototype.markupFactory = function(params, node, Ctor) {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.dnd.AutoSource.prototype.on = function(type, listener) {};

/**
 * selects all items
 * 
 * @return {?}
 */
dojo.dnd.AutoSource.prototype.selectAll = function() {};

/**
 * unselects all items
 * 
 * @return {?}
 */
dojo.dnd.AutoSource.prototype.selectNone = function() {};

/**
 * associates a data item with its key (id)
 * 
 * @param {!String} key
 * @param {?} data
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.setItem = function(key, data) {};

/**
 * collects valid child items and populate the map
 * 
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.startup = function() {};

/**
 * sync up the node list with the data map
 * 
 * @return {!Function}
 */
dojo.dnd.AutoSource.prototype.sync = function() {};

/**
 * topic event processor for /dnd/cancel, called to cancel the DnD operation
 * 
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onDndCancel = function() {};

/**
 * topic event processor for /dnd/drop, called to finish the DnD operation
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @param {!Object} target the target which accepts items
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onDndDrop = function(source, nodes, copy, target) {};

/**
 * topic event processor for /dnd/source/over, called when detected a current source
 * 
 * @param {!Object} source the source which has the mouse over it
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onDndSourceOver = function(source) {};

/**
 * topic event processor for /dnd/start, called to initiate the DnD operation
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onDndStart = function(source, nodes, copy) {};

/**
 * called during the active DnD operation, when items
 * are dragged away from this target, and it is not disabled
 * 
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onDraggingOut = function() {};

/**
 * called during the active DnD operation, when items
 * are dragged over this target, and it is not disabled
 * 
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onDraggingOver = function() {};

/**
 * called only on the current target, when drop is performed
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onDrop = function(source, nodes, copy) {};

/**
 * called only on the current target, when drop is performed
 * from an external source
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onDropExternal = function(source, nodes, copy) {};

/**
 * called only on the current target, when drop is performed
 * from the same target/source
 * 
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onDropInternal = function(nodes, copy) {};

/**
 * event processor for onmousedown
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onMouseDown = function(e) {};

/**
 * event processor for onmousemove
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onMouseMove = function(e) {};

/**
 * event processor for onmouseout
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onMouseOut = function(e) {};

/**
 * event processor for onmouseover or touch, to mark that element as the current element
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onMouseOver = function(e) {};

/**
 * event processor for onmouseup
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onMouseUp = function(e) {};

/**
 * this function is called once, when mouse is out of our container
 * 
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onOutEvent = function() {};

/**
 * this function is called once, when mouse is over our container
 * 
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onOverEvent = function() {};

/**
 * event processor for onselectevent and ondragevent
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.AutoSource.prototype.onSelectStart = function(e) {};

/**
 * @constructor
 * @struct
 * @param {!HTMLElement} node
 * @param {!Event} e
 * @param {!Object=} host
 */
dojo.dnd.Mover = function(node, e, host) {};

/**
 * stops the move, deletes all references, so the object can be garbage-collected
 * 
 * @return {void}
 */
dojo.dnd.Mover.prototype.destroy = function() {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.dnd.Mover.prototype.emit = function(type, event) {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.dnd.Mover.prototype.on = function(type, listener) {};

/**
 * makes the node absolute; it is meant to be called only once.
 * relative and absolutely positioned nodes are assumed to use pixel units
 * 
 * @param {?} e
 * @return {void}
 */
dojo.dnd.Mover.prototype.onFirstMove = function(e) {};

/**
 * event processor for onmousemove/ontouchmove
 * 
 * @param {!Event} e mouse/touch event
 * @return {void}
 */
dojo.dnd.Mover.prototype.onMouseMove = function(e) {};

/**
 *
 * @param {?} e
 * @return {void}
 */
dojo.dnd.Mover.prototype.onMouseUp = function(e) {};

/**
 * @constructor
 * @struct
 * @param {!HTMLElement} node
 * @param {!Object=} params
 */
dojo.dnd.Moveable = function(node, params) {};

/* TODO: PropertyDeclaration: dojo.dnd."delay" */

/* TODO: PropertyDeclaration: dojo.dnd."handle" */

/* TODO: PropertyDeclaration: dojo.dnd."skip" */

/**
 * stops watching for possible move, deletes all references, so the object can be garbage-collected
 * 
 * @return {void}
 */
dojo.dnd.Moveable.prototype.destroy = function() {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.dnd.Moveable.prototype.emit = function(type, event) {};

/**
 *
 * @param {?} params
 * @param {?} node
 * @param {?} Ctor
 * @return {?}
 */
dojo.dnd.Moveable.prototype.markupFactory = function(params, node, Ctor) {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.dnd.Moveable.prototype.on = function(type, listener) {};

/**
 * called when the drag is detected;
 * responsible for creation of the mover
 * 
 * @param {!Event} e
 * @return {void}
 */
dojo.dnd.Moveable.prototype.onDragDetected = function(e) {};

/**
 * called during the very first move notification;
 * can be used to initialize coordinates, can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Event} e
 * @return {void}
 */
dojo.dnd.Moveable.prototype.onFirstMove = function(mover, e) {};

/**
 * event processor for onmousedown/ontouchstart, creates a Mover for the node
 * 
 * @param {!Event} e mouse/touch event
 * @return {void}
 */
dojo.dnd.Moveable.prototype.onMouseDown = function(e) {};

/**
 * event processor for onmousemove/ontouchmove, used only for delayed drags
 * 
 * @param {!Event} e mouse/touch event
 * @return {void}
 */
dojo.dnd.Moveable.prototype.onMouseMove = function(e) {};

/**
 * event processor for onmouseup, used only for delayed drags
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Moveable.prototype.onMouseUp = function(e) {};

/**
 * called during every move notification;
 * should actually move the node; can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @param {!Event} e
 * @return {void}
 */
dojo.dnd.Moveable.prototype.onMove = function(mover, leftTop, e) {};

/**
 * called after every incremental move; can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @return {void}
 */
dojo.dnd.Moveable.prototype.onMoved = function(mover, leftTop) {};

/**
 * called before every move operation
 * 
 * @param {!dojo.dnd.Mover} mover
 * @return {void}
 */
dojo.dnd.Moveable.prototype.onMoveStart = function(mover) {};

/**
 * called after every move operation
 * 
 * @param {!dojo.dnd.Mover} mover
 * @return {void}
 */
dojo.dnd.Moveable.prototype.onMoveStop = function(mover) {};

/**
 * called before every incremental move; can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @return {void}
 */
dojo.dnd.Moveable.prototype.onMoving = function(mover, leftTop) {};

/**
 * event processor for onselectevent and ondragevent
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Moveable.prototype.onSelectStart = function(e) {};

/**
 * @constructor
 * @struct
 */
dojo.dnd.Moveable.__MoveableArgs = function() {};

/* TODO: PropertyDeclaration: dojo.dnd.Moveable."delay" */

/* TODO: PropertyDeclaration: dojo.dnd.Moveable."handle" */

/* TODO: PropertyDeclaration: dojo.dnd.Moveable."mover" */

/* TODO: PropertyDeclaration: dojo.dnd.Moveable."skip" */

/**
 * @constructor
 * @struct
 * @param {!HTMLElement} node
 * @param {!Object=} params
 */
dojo.dnd.Selector = function(node, params) {};

/* TODO: PropertyDeclaration: dojo.dnd."allowNested" */

/* TODO: PropertyDeclaration: dojo.dnd."current" */

/* TODO: PropertyDeclaration: dojo.dnd."map" */

/* TODO: PropertyDeclaration: dojo.dnd."selection" */

/* TODO: PropertyDeclaration: dojo.dnd."singular" */

/* TODO: PropertyDeclaration: dojo.dnd."skipForm" */

/**
 * removes all data items from the map
 * 
 * @return {void}
 */
dojo.dnd.Selector.prototype.clearItems = function() {};

/**
 * creator function, dummy at the moment
 * 
 * @return {void}
 */
dojo.dnd.Selector.prototype.creator = function() {};

/**
 * deletes all selected items
 * 
 * @return {!Function}
 */
dojo.dnd.Selector.prototype.deleteSelectedNodes = function() {};

/**
 * removes a data item from the map by its key (id)
 * 
 * @param {!String} key
 * @return {void}
 */
dojo.dnd.Selector.prototype.delItem = function(key) {};

/**
 * prepares the object to be garbage-collected
 * 
 * @return {void}
 */
dojo.dnd.Selector.prototype.destroy = function() {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.dnd.Selector.prototype.emit = function(type, event) {};

/**
 * iterates over a data map skipping members that
 * are present in the empty object (IE and/or 3rd-party libraries).
 * 
 * @param {!Function} f
 * @param {!Object=} o               Optional
 * @return {!String}
 */
dojo.dnd.Selector.prototype.forInItems = function(f, o) {};

/**
 * iterates over selected items;
 * see dojo/dnd/Container.forInItems() for details
 * 
 * @param {!Function} f
 * @param {!Object=} o               Optional
 * @return {void}
 */
dojo.dnd.Selector.prototype.forInSelectedItems = function(f, o) {};

/**
 * returns a list (an array) of all valid child nodes
 * 
 * @return {?}
 */
dojo.dnd.Selector.prototype.getAllNodes = function() {};

/**
 * returns a data item by its key (id)
 * 
 * @param {!String} key
 * @return {?}
 */
dojo.dnd.Selector.prototype.getItem = function(key) {};

/**
 * returns a list (an array) of selected nodes
 * 
 * @return {?}
 */
dojo.dnd.Selector.prototype.getSelectedNodes = function() {};

/**
 * inserts new data items (see dojo/dnd/Container.insertNodes() method for details)
 * 
 * @param {boolean=} addSelected all new nodes will be added to selected items, if true, no selection change otherwise
 * @param {!Array<?>=} data a list of data items, which should be processed by the creator function
 * @param {boolean=} before insert before the anchor, if true, and after the anchor otherwise
 * @param {!HTMLElement=} anchor the anchor node to be used as a point of insertion
 * @return {!Function}
 */
dojo.dnd.Selector.prototype.insertNodes = function(addSelected, data, before, anchor) {};

/**
 *
 * @param {?} params
 * @param {?} node
 * @param {?} Ctor
 * @return {?}
 */
dojo.dnd.Selector.prototype.markupFactory = function(params, node, Ctor) {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.dnd.Selector.prototype.on = function(type, listener) {};

/**
 * selects all items
 * 
 * @return {?}
 */
dojo.dnd.Selector.prototype.selectAll = function() {};

/**
 * unselects all items
 * 
 * @return {?}
 */
dojo.dnd.Selector.prototype.selectNone = function() {};

/**
 * associates a data item with its key (id)
 * 
 * @param {!String} key
 * @param {?} data
 * @return {void}
 */
dojo.dnd.Selector.prototype.setItem = function(key, data) {};

/**
 * collects valid child items and populate the map
 * 
 * @return {void}
 */
dojo.dnd.Selector.prototype.startup = function() {};

/**
 * sync up the node list with the data map
 * 
 * @return {!Function}
 */
dojo.dnd.Selector.prototype.sync = function() {};

/**
 * event processor for onmousedown
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Selector.prototype.onMouseDown = function(e) {};

/**
 * event processor for onmousemove
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Selector.prototype.onMouseMove = function(e) {};

/**
 * event processor for onmouseout
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Selector.prototype.onMouseOut = function(e) {};

/**
 * event processor for onmouseover or touch, to mark that element as the current element
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Selector.prototype.onMouseOver = function(e) {};

/**
 * event processor for onmouseup
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Selector.prototype.onMouseUp = function(e) {};

/**
 * this function is called once, when mouse is out of our container
 * 
 * @return {void}
 */
dojo.dnd.Selector.prototype.onOutEvent = function() {};

/**
 * this function is called once, when mouse is over our container
 * 
 * @return {void}
 */
dojo.dnd.Selector.prototype.onOverEvent = function() {};

/**
 * event processor for onselectevent and ondragevent
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Selector.prototype.onSelectStart = function(e) {};

/**
 * @constructor
 * @struct
 * @param {!HTMLElement} node
 * @param {!Object} params
 */
dojo.dnd.TimedMoveable = function(node, params) {};

/* TODO: PropertyDeclaration: dojo.dnd."delay" */

/* TODO: PropertyDeclaration: dojo.dnd."handle" */

/* TODO: PropertyDeclaration: dojo.dnd."skip" */

/* TODO: PropertyDeclaration: dojo.dnd."timeout" */

/**
 * stops watching for possible move, deletes all references, so the object can be garbage-collected
 * 
 * @return {void}
 */
dojo.dnd.TimedMoveable.prototype.destroy = function() {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.dnd.TimedMoveable.prototype.emit = function(type, event) {};

/**
 *
 * @param {?} params
 * @param {?} node
 * @param {?} Ctor
 * @return {?}
 */
dojo.dnd.TimedMoveable.prototype.markupFactory = function(params, node, Ctor) {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.dnd.TimedMoveable.prototype.on = function(type, listener) {};

/**
 * called when the drag is detected;
 * responsible for creation of the mover
 * 
 * @param {!Event} e
 * @return {void}
 */
dojo.dnd.TimedMoveable.prototype.onDragDetected = function(e) {};

/**
 * called during the very first move notification;
 * can be used to initialize coordinates, can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Event} e
 * @return {void}
 */
dojo.dnd.TimedMoveable.prototype.onFirstMove = function(mover, e) {};

/**
 * event processor for onmousedown/ontouchstart, creates a Mover for the node
 * 
 * @param {!Event} e mouse/touch event
 * @return {void}
 */
dojo.dnd.TimedMoveable.prototype.onMouseDown = function(e) {};

/**
 * event processor for onmousemove/ontouchmove, used only for delayed drags
 * 
 * @param {!Event} e mouse/touch event
 * @return {void}
 */
dojo.dnd.TimedMoveable.prototype.onMouseMove = function(e) {};

/**
 * event processor for onmouseup, used only for delayed drags
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.TimedMoveable.prototype.onMouseUp = function(e) {};

/**
 *
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @return {void}
 */
dojo.dnd.TimedMoveable.prototype.onMove = function(mover, leftTop) {};

/**
 * called after every incremental move; can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @return {void}
 */
dojo.dnd.TimedMoveable.prototype.onMoved = function(mover, leftTop) {};

/**
 * called before every move operation
 * 
 * @param {!dojo.dnd.Mover} mover
 * @return {void}
 */
dojo.dnd.TimedMoveable.prototype.onMoveStart = function(mover) {};

/**
 *
 * @param {!dojo.dnd.Mover} mover
 * @return {void}
 */
dojo.dnd.TimedMoveable.prototype.onMoveStop = function(mover) {};

/**
 * called before every incremental move; can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @return {void}
 */
dojo.dnd.TimedMoveable.prototype.onMoving = function(mover, leftTop) {};

/**
 * event processor for onselectevent and ondragevent
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.TimedMoveable.prototype.onSelectStart = function(e) {};

/**
 * @constructor
 * @struct
 * @param {?} node
 * @param {?} params
 */
dojo.dnd.Target = function(node, params) {};

/* TODO: PropertyDeclaration: dojo.dnd."accept" */

/* TODO: PropertyDeclaration: dojo.dnd."allowNested" */

/* TODO: PropertyDeclaration: dojo.dnd."autoSync" */

/* TODO: PropertyDeclaration: dojo.dnd."copyOnly" */

/* TODO: PropertyDeclaration: dojo.dnd."current" */

/* TODO: PropertyDeclaration: dojo.dnd."delay" */

/* TODO: PropertyDeclaration: dojo.dnd."generateText" */

/* TODO: PropertyDeclaration: dojo.dnd."horizontal" */

/* TODO: PropertyDeclaration: dojo.dnd."isSource" */

/* TODO: PropertyDeclaration: dojo.dnd."map" */

/* TODO: PropertyDeclaration: dojo.dnd."selection" */

/* TODO: PropertyDeclaration: dojo.dnd."selfAccept" */

/* TODO: PropertyDeclaration: dojo.dnd."selfCopy" */

/* TODO: PropertyDeclaration: dojo.dnd."singular" */

/* TODO: PropertyDeclaration: dojo.dnd."skipForm" */

/* TODO: PropertyDeclaration: dojo.dnd."withHandles" */

/**
 * checks if the target can accept nodes from this source
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @return {boolean}
 */
dojo.dnd.Target.prototype.checkAcceptance = function(source, nodes) {};

/**
 * removes all data items from the map
 * 
 * @return {void}
 */
dojo.dnd.Target.prototype.clearItems = function() {};

/**
 * Returns true if we need to copy items, false to move.
 * It is separated to be overwritten dynamically, if needed.
 * 
 * @param {boolean} keyPressed the "copy" key was pressed
 * @param {boolean=} self               Optionaloptional flag that means that we are about to drop on itself
 * @return {?}
 */
dojo.dnd.Target.prototype.copyState = function(keyPressed, self) {};

/**
 * creator function, dummy at the moment
 * 
 * @return {void}
 */
dojo.dnd.Target.prototype.creator = function() {};

/**
 * deletes all selected items
 * 
 * @return {!Function}
 */
dojo.dnd.Target.prototype.deleteSelectedNodes = function() {};

/**
 * removes a data item from the map by its key (id)
 * 
 * @param {!String} key
 * @return {void}
 */
dojo.dnd.Target.prototype.delItem = function(key) {};

/**
 * prepares the object to be garbage-collected
 * 
 * @return {void}
 */
dojo.dnd.Target.prototype.destroy = function() {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.dnd.Target.prototype.emit = function(type, event) {};

/**
 * iterates over a data map skipping members that
 * are present in the empty object (IE and/or 3rd-party libraries).
 * 
 * @param {!Function} f
 * @param {!Object=} o               Optional
 * @return {!String}
 */
dojo.dnd.Target.prototype.forInItems = function(f, o) {};

/**
 * iterates over selected items;
 * see dojo/dnd/Container.forInItems() for details
 * 
 * @param {!Function} f
 * @param {!Object=} o               Optional
 * @return {void}
 */
dojo.dnd.Target.prototype.forInSelectedItems = function(f, o) {};

/**
 * returns a list (an array) of all valid child nodes
 * 
 * @return {?}
 */
dojo.dnd.Target.prototype.getAllNodes = function() {};

/**
 * returns a data item by its key (id)
 * 
 * @param {!String} key
 * @return {?}
 */
dojo.dnd.Target.prototype.getItem = function(key) {};

/**
 * returns a list (an array) of selected nodes
 * 
 * @return {?}
 */
dojo.dnd.Target.prototype.getSelectedNodes = function() {};

/**
 * inserts new data items (see dojo/dnd/Container.insertNodes() method for details)
 * 
 * @param {boolean} addSelected all new nodes will be added to selected items, if true, no selection change otherwise
 * @param {!Array<?>} data a list of data items, which should be processed by the creator function
 * @param {boolean=} before insert before the anchor, if true, and after the anchor otherwise
 * @param {!HTMLElement=} anchor the anchor node to be used as a point of insertion
 * @return {!Function}
 */
dojo.dnd.Target.prototype.insertNodes = function(addSelected, data, before, anchor) {};

/**
 *
 * @param {?} params
 * @param {?} node
 * @param {?} Ctor
 * @return {?}
 */
dojo.dnd.Target.prototype.markupFactory = function(params, node, Ctor) {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.dnd.Target.prototype.on = function(type, listener) {};

/**
 * selects all items
 * 
 * @return {?}
 */
dojo.dnd.Target.prototype.selectAll = function() {};

/**
 * unselects all items
 * 
 * @return {?}
 */
dojo.dnd.Target.prototype.selectNone = function() {};

/**
 * associates a data item with its key (id)
 * 
 * @param {!String} key
 * @param {?} data
 * @return {void}
 */
dojo.dnd.Target.prototype.setItem = function(key, data) {};

/**
 * collects valid child items and populate the map
 * 
 * @return {void}
 */
dojo.dnd.Target.prototype.startup = function() {};

/**
 * sync up the node list with the data map
 * 
 * @return {!Function}
 */
dojo.dnd.Target.prototype.sync = function() {};

/**
 * topic event processor for /dnd/cancel, called to cancel the DnD operation
 * 
 * @return {void}
 */
dojo.dnd.Target.prototype.onDndCancel = function() {};

/**
 * topic event processor for /dnd/drop, called to finish the DnD operation
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @param {!Object} target the target which accepts items
 * @return {void}
 */
dojo.dnd.Target.prototype.onDndDrop = function(source, nodes, copy, target) {};

/**
 * topic event processor for /dnd/source/over, called when detected a current source
 * 
 * @param {!Object} source the source which has the mouse over it
 * @return {void}
 */
dojo.dnd.Target.prototype.onDndSourceOver = function(source) {};

/**
 * topic event processor for /dnd/start, called to initiate the DnD operation
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @return {void}
 */
dojo.dnd.Target.prototype.onDndStart = function(source, nodes, copy) {};

/**
 * called during the active DnD operation, when items
 * are dragged away from this target, and it is not disabled
 * 
 * @return {void}
 */
dojo.dnd.Target.prototype.onDraggingOut = function() {};

/**
 * called during the active DnD operation, when items
 * are dragged over this target, and it is not disabled
 * 
 * @return {void}
 */
dojo.dnd.Target.prototype.onDraggingOver = function() {};

/**
 * called only on the current target, when drop is performed
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @return {void}
 */
dojo.dnd.Target.prototype.onDrop = function(source, nodes, copy) {};

/**
 * called only on the current target, when drop is performed
 * from an external source
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @return {void}
 */
dojo.dnd.Target.prototype.onDropExternal = function(source, nodes, copy) {};

/**
 * called only on the current target, when drop is performed
 * from the same target/source
 * 
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @return {void}
 */
dojo.dnd.Target.prototype.onDropInternal = function(nodes, copy) {};

/**
 * event processor for onmousedown
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Target.prototype.onMouseDown = function(e) {};

/**
 * event processor for onmousemove
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Target.prototype.onMouseMove = function(e) {};

/**
 * event processor for onmouseout
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Target.prototype.onMouseOut = function(e) {};

/**
 * event processor for onmouseover or touch, to mark that element as the current element
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Target.prototype.onMouseOver = function(e) {};

/**
 * event processor for onmouseup
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Target.prototype.onMouseUp = function(e) {};

/**
 * this function is called once, when mouse is out of our container
 * 
 * @return {void}
 */
dojo.dnd.Target.prototype.onOutEvent = function() {};

/**
 * this function is called once, when mouse is over our container
 * 
 * @return {void}
 */
dojo.dnd.Target.prototype.onOverEvent = function() {};

/**
 * event processor for onselectevent and ondragevent
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Target.prototype.onSelectStart = function(e) {};

/**
 * @constructor
 * @struct
 * @param {!HTMLElement} node
 * @param {!Object=} params
 */
dojo.dnd.Source = function(node, params) {};

/* TODO: PropertyDeclaration: dojo.dnd."accept" */

/* TODO: PropertyDeclaration: dojo.dnd."allowNested" */

/* TODO: PropertyDeclaration: dojo.dnd."autoSync" */

/* TODO: PropertyDeclaration: dojo.dnd."copyOnly" */

/* TODO: PropertyDeclaration: dojo.dnd."current" */

/* TODO: PropertyDeclaration: dojo.dnd."delay" */

/* TODO: PropertyDeclaration: dojo.dnd."generateText" */

/* TODO: PropertyDeclaration: dojo.dnd."horizontal" */

/* TODO: PropertyDeclaration: dojo.dnd."isSource" */

/* TODO: PropertyDeclaration: dojo.dnd."map" */

/* TODO: PropertyDeclaration: dojo.dnd."selection" */

/* TODO: PropertyDeclaration: dojo.dnd."selfAccept" */

/* TODO: PropertyDeclaration: dojo.dnd."selfCopy" */

/* TODO: PropertyDeclaration: dojo.dnd."singular" */

/* TODO: PropertyDeclaration: dojo.dnd."skipForm" */

/* TODO: PropertyDeclaration: dojo.dnd."withHandles" */

/**
 * checks if the target can accept nodes from this source
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @return {boolean}
 */
dojo.dnd.Source.prototype.checkAcceptance = function(source, nodes) {};

/**
 * removes all data items from the map
 * 
 * @return {void}
 */
dojo.dnd.Source.prototype.clearItems = function() {};

/**
 * Returns true if we need to copy items, false to move.
 * It is separated to be overwritten dynamically, if needed.
 * 
 * @param {boolean} keyPressed the "copy" key was pressed
 * @param {boolean=} self               Optionaloptional flag that means that we are about to drop on itself
 * @return {?}
 */
dojo.dnd.Source.prototype.copyState = function(keyPressed, self) {};

/**
 * creator function, dummy at the moment
 * 
 * @return {void}
 */
dojo.dnd.Source.prototype.creator = function() {};

/**
 * deletes all selected items
 * 
 * @return {!Function}
 */
dojo.dnd.Source.prototype.deleteSelectedNodes = function() {};

/**
 * removes a data item from the map by its key (id)
 * 
 * @param {!String} key
 * @return {void}
 */
dojo.dnd.Source.prototype.delItem = function(key) {};

/**
 * prepares the object to be garbage-collected
 * 
 * @return {void}
 */
dojo.dnd.Source.prototype.destroy = function() {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.dnd.Source.prototype.emit = function(type, event) {};

/**
 * iterates over a data map skipping members that
 * are present in the empty object (IE and/or 3rd-party libraries).
 * 
 * @param {!Function} f
 * @param {!Object=} o               Optional
 * @return {!String}
 */
dojo.dnd.Source.prototype.forInItems = function(f, o) {};

/**
 * iterates over selected items;
 * see dojo/dnd/Container.forInItems() for details
 * 
 * @param {!Function} f
 * @param {!Object=} o               Optional
 * @return {void}
 */
dojo.dnd.Source.prototype.forInSelectedItems = function(f, o) {};

/**
 * returns a list (an array) of all valid child nodes
 * 
 * @return {?}
 */
dojo.dnd.Source.prototype.getAllNodes = function() {};

/**
 * returns a data item by its key (id)
 * 
 * @param {!String} key
 * @return {?}
 */
dojo.dnd.Source.prototype.getItem = function(key) {};

/**
 * returns a list (an array) of selected nodes
 * 
 * @return {?}
 */
dojo.dnd.Source.prototype.getSelectedNodes = function() {};

/**
 * inserts new data items (see dojo/dnd/Container.insertNodes() method for details)
 * 
 * @param {boolean} addSelected all new nodes will be added to selected items, if true, no selection change otherwise
 * @param {!Array<?>} data a list of data items, which should be processed by the creator function
 * @param {boolean=} before insert before the anchor, if true, and after the anchor otherwise
 * @param {!HTMLElement=} anchor the anchor node to be used as a point of insertion
 * @return {!Function}
 */
dojo.dnd.Source.prototype.insertNodes = function(addSelected, data, before, anchor) {};

/**
 *
 * @param {?} params
 * @param {?} node
 * @param {?} Ctor
 * @return {?}
 */
dojo.dnd.Source.prototype.markupFactory = function(params, node, Ctor) {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.dnd.Source.prototype.on = function(type, listener) {};

/**
 * selects all items
 * 
 * @return {?}
 */
dojo.dnd.Source.prototype.selectAll = function() {};

/**
 * unselects all items
 * 
 * @return {?}
 */
dojo.dnd.Source.prototype.selectNone = function() {};

/**
 * associates a data item with its key (id)
 * 
 * @param {!String} key
 * @param {?} data
 * @return {void}
 */
dojo.dnd.Source.prototype.setItem = function(key, data) {};

/**
 * collects valid child items and populate the map
 * 
 * @return {void}
 */
dojo.dnd.Source.prototype.startup = function() {};

/**
 * sync up the node list with the data map
 * 
 * @return {!Function}
 */
dojo.dnd.Source.prototype.sync = function() {};

/**
 * topic event processor for /dnd/cancel, called to cancel the DnD operation
 * 
 * @return {void}
 */
dojo.dnd.Source.prototype.onDndCancel = function() {};

/**
 * topic event processor for /dnd/drop, called to finish the DnD operation
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @param {!Object} target the target which accepts items
 * @return {void}
 */
dojo.dnd.Source.prototype.onDndDrop = function(source, nodes, copy, target) {};

/**
 * topic event processor for /dnd/source/over, called when detected a current source
 * 
 * @param {!Object} source the source which has the mouse over it
 * @return {void}
 */
dojo.dnd.Source.prototype.onDndSourceOver = function(source) {};

/**
 * topic event processor for /dnd/start, called to initiate the DnD operation
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @return {void}
 */
dojo.dnd.Source.prototype.onDndStart = function(source, nodes, copy) {};

/**
 * called during the active DnD operation, when items
 * are dragged away from this target, and it is not disabled
 * 
 * @return {void}
 */
dojo.dnd.Source.prototype.onDraggingOut = function() {};

/**
 * called during the active DnD operation, when items
 * are dragged over this target, and it is not disabled
 * 
 * @return {void}
 */
dojo.dnd.Source.prototype.onDraggingOver = function() {};

/**
 * called only on the current target, when drop is performed
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @return {void}
 */
dojo.dnd.Source.prototype.onDrop = function(source, nodes, copy) {};

/**
 * called only on the current target, when drop is performed
 * from an external source
 * 
 * @param {!Object} source the source which provides items
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @return {void}
 */
dojo.dnd.Source.prototype.onDropExternal = function(source, nodes, copy) {};

/**
 * called only on the current target, when drop is performed
 * from the same target/source
 * 
 * @param {!Array<?>} nodes the list of transferred items
 * @param {boolean} copy copy items, if true, move items otherwise
 * @return {void}
 */
dojo.dnd.Source.prototype.onDropInternal = function(nodes, copy) {};

/**
 * event processor for onmousedown
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Source.prototype.onMouseDown = function(e) {};

/**
 * event processor for onmousemove
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Source.prototype.onMouseMove = function(e) {};

/**
 * event processor for onmouseout
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Source.prototype.onMouseOut = function(e) {};

/**
 * event processor for onmouseover or touch, to mark that element as the current element
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Source.prototype.onMouseOver = function(e) {};

/**
 * event processor for onmouseup
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Source.prototype.onMouseUp = function(e) {};

/**
 * this function is called once, when mouse is out of our container
 * 
 * @return {void}
 */
dojo.dnd.Source.prototype.onOutEvent = function() {};

/**
 * this function is called once, when mouse is over our container
 * 
 * @return {void}
 */
dojo.dnd.Source.prototype.onOverEvent = function() {};

/**
 * event processor for onselectevent and ondragevent
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.Source.prototype.onSelectStart = function(e) {};
/**
 * @record
 * @struct
 */
dojo.dnd.autoscroll = function() {};
 /** @type {number} */
dojo.dnd.autoscroll.prototype.H_AUTOSCROLL_VALUE;
 /** @type {number} */
dojo.dnd.autoscroll.prototype.H_TRIGGER_AUTOSCROLL;
 /** @type {number} */
dojo.dnd.autoscroll.prototype.V_AUTOSCROLL_VALUE;
 /** @type {number} */
dojo.dnd.autoscroll.prototype.V_TRIGGER_AUTOSCROLL;

/**
 * a handler for mousemove and touchmove events, which scrolls the window, if
 * necessary
 * 
 * @param {!Event} e mousemove/touchmove event
 * @return {void}
 */
dojo.dnd.autoscroll.prototype.autoScroll = function(e) {};

/**
 * a handler for mousemove and touchmove events, which scrolls the first available
 * Dom element, it falls back to exports.autoScroll()
 * 
 * @param {!Event} e mousemove/touchmove event
 * @return {void}
 */
dojo.dnd.autoscroll.prototype.autoScrollNodes = function(e) {};

/**
 * Called at the start of a drag.
 * 
 * @param {!HTMLDocument} d The document of the node being dragged.
 * @return {void}
 */
dojo.dnd.autoscroll.prototype.autoScrollStart = function(d) {};

/**
 * Returns the dimensions and scroll position of the viewable area of a browser window
 * 
 * @param {!HTMLDocument=} doc               Optional
 * @return {!Object}
 */
dojo.dnd.autoscroll.prototype.getViewport = function(doc) {};
/**
 * @record
 * @struct
 */
dojo.dnd.autoscroll._validOverflow = function() {};
 /** @type {number} */
dojo.dnd.autoscroll._validOverflow.prototype.auto;
 /** @type {number} */
dojo.dnd.autoscroll._validOverflow.prototype.scroll;
/**
 * @record
 * @struct
 */
dojo.dnd.autoscroll._validNodes = function() {};
 /** @type {number} */
dojo.dnd.autoscroll._validNodes.prototype.div;
 /** @type {number} */
dojo.dnd.autoscroll._validNodes.prototype.p;
 /** @type {number} */
dojo.dnd.autoscroll._validNodes.prototype.td;
/**
 * @record
 * @struct
 */
dojo.dnd.common = function() {};

/**
 *
 * @param {?} evt
 * @return {?}
 */
dojo.dnd.common.prototype.getCopyKeyState = function(evt) {};

/**
 * returns a unique string for use with any DOM element
 * 
 * @return {!String}
 */
dojo.dnd.common.prototype.getUniqueId = function() {};

/**
 * returns true if user clicked on a form element
 * 
 * @param {!Event} e
 * @return {void}
 */
dojo.dnd.common.prototype.isFormElement = function(e) {};

/**
 * Returns the current DnD manager.  Creates one if it is not created yet.
 * 
 * @return {?}
 */
dojo.dnd.common.prototype.manager = function() {};
/**
 * @record
 * @struct
 */
dojo.dnd.common._empty = function() {};
/**
 * @record
 * @struct
 */
dojo.dnd.common._defaultCreatorNodes = function() {};
 /** @type {string} */
dojo.dnd.common._defaultCreatorNodes.prototype.div;
 /** @type {string} */
dojo.dnd.common._defaultCreatorNodes.prototype.ol;
 /** @type {string} */
dojo.dnd.common._defaultCreatorNodes.prototype.p;
 /** @type {string} */
dojo.dnd.common._defaultCreatorNodes.prototype.ul;
/**
 * @record
 * @struct
 */
dojo.dnd.move = function() {};

/**
 *
 * @return {void}
 */
dojo.dnd.move.prototype.boxConstrainedMoveable = function() {};

/**
 *
 * @return {void}
 */
dojo.dnd.move.prototype.constrainedMoveable = function() {};

/**
 *
 * @return {void}
 */
dojo.dnd.move.prototype.parentConstrainedMoveable = function() {};

/**
 * @constructor
 * @struct
 * @param {!HTMLElement} node
 * @param {!Object=} params
 */
dojo.dnd.move.parentConstrainedMoveable = function(node, params) {};

/* TODO: PropertyDeclaration: dojo.dnd.move."area" */

/* TODO: PropertyDeclaration: dojo.dnd.move."delay" */

/* TODO: PropertyDeclaration: dojo.dnd.move."handle" */

/* TODO: PropertyDeclaration: dojo.dnd.move."skip" */

/* TODO: PropertyDeclaration: dojo.dnd.move."within" */

/**
 *
 * @return {void}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.constraints = function() {};

/**
 * stops watching for possible move, deletes all references, so the object can be garbage-collected
 * 
 * @return {void}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.destroy = function() {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.emit = function(type, event) {};

/**
 *
 * @param {?} params
 * @param {?} node
 * @param {?} Ctor
 * @return {?}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.markupFactory = function(params, node, Ctor) {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.on = function(type, listener) {};

/**
 * called when the drag is detected;
 * responsible for creation of the mover
 * 
 * @param {!Event} e
 * @return {void}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.onDragDetected = function(e) {};

/**
 * called during the very first move notification;
 * can be used to initialize coordinates, can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @return {void}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.onFirstMove = function(mover) {};

/**
 * event processor for onmousedown/ontouchstart, creates a Mover for the node
 * 
 * @param {!Event} e mouse/touch event
 * @return {void}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.onMouseDown = function(e) {};

/**
 * event processor for onmousemove/ontouchmove, used only for delayed drags
 * 
 * @param {!Event} e mouse/touch event
 * @return {void}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.onMouseMove = function(e) {};

/**
 * event processor for onmouseup, used only for delayed drags
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.onMouseUp = function(e) {};

/**
 * called during every move notification;
 * should actually move the node; can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @return {void}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.onMove = function(mover, leftTop) {};

/**
 * called after every incremental move; can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @return {void}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.onMoved = function(mover, leftTop) {};

/**
 * called before every move operation
 * 
 * @param {!dojo.dnd.Mover} mover
 * @return {void}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.onMoveStart = function(mover) {};

/**
 * called after every move operation
 * 
 * @param {!dojo.dnd.Mover} mover
 * @return {void}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.onMoveStop = function(mover) {};

/**
 * called before every incremental move; can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @return {void}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.onMoving = function(mover, leftTop) {};

/**
 * event processor for onselectevent and ondragevent
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.move.parentConstrainedMoveable.prototype.onSelectStart = function(e) {};

/**
 * @constructor
 * @struct
 * @param {!HTMLElement} node
 * @param {!Object=} params
 */
dojo.dnd.move.boxConstrainedMoveable = function(node, params) {};

/* TODO: PropertyDeclaration: dojo.dnd.move."box" */

/* TODO: PropertyDeclaration: dojo.dnd.move."delay" */

/* TODO: PropertyDeclaration: dojo.dnd.move."handle" */

/* TODO: PropertyDeclaration: dojo.dnd.move."skip" */

/* TODO: PropertyDeclaration: dojo.dnd.move."within" */

/**
 *
 * @return {void}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.constraints = function() {};

/**
 * stops watching for possible move, deletes all references, so the object can be garbage-collected
 * 
 * @return {void}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.destroy = function() {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.emit = function(type, event) {};

/**
 *
 * @param {?} params
 * @param {?} node
 * @param {?} Ctor
 * @return {?}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.markupFactory = function(params, node, Ctor) {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.on = function(type, listener) {};

/**
 * called when the drag is detected;
 * responsible for creation of the mover
 * 
 * @param {!Event} e
 * @return {void}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.onDragDetected = function(e) {};

/**
 * called during the very first move notification;
 * can be used to initialize coordinates, can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @return {void}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.onFirstMove = function(mover) {};

/**
 * event processor for onmousedown/ontouchstart, creates a Mover for the node
 * 
 * @param {!Event} e mouse/touch event
 * @return {void}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.onMouseDown = function(e) {};

/**
 * event processor for onmousemove/ontouchmove, used only for delayed drags
 * 
 * @param {!Event} e mouse/touch event
 * @return {void}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.onMouseMove = function(e) {};

/**
 * event processor for onmouseup, used only for delayed drags
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.onMouseUp = function(e) {};

/**
 * called during every move notification;
 * should actually move the node; can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @return {void}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.onMove = function(mover, leftTop) {};

/**
 * called after every incremental move; can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @return {void}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.onMoved = function(mover, leftTop) {};

/**
 * called before every move operation
 * 
 * @param {!dojo.dnd.Mover} mover
 * @return {void}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.onMoveStart = function(mover) {};

/**
 * called after every move operation
 * 
 * @param {!dojo.dnd.Mover} mover
 * @return {void}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.onMoveStop = function(mover) {};

/**
 * called before every incremental move; can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @return {void}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.onMoving = function(mover, leftTop) {};

/**
 * event processor for onselectevent and ondragevent
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.move.boxConstrainedMoveable.prototype.onSelectStart = function(e) {};

/**
 * @constructor
 * @struct
 * @param {!HTMLElement} node
 * @param {!Object=} params
 */
dojo.dnd.move.constrainedMoveable = function(node, params) {};

/* TODO: PropertyDeclaration: dojo.dnd.move."delay" */

/* TODO: PropertyDeclaration: dojo.dnd.move."handle" */

/* TODO: PropertyDeclaration: dojo.dnd.move."skip" */

/* TODO: PropertyDeclaration: dojo.dnd.move."within" */

/**
 *
 * @return {void}
 */
dojo.dnd.move.constrainedMoveable.prototype.constraints = function() {};

/**
 * stops watching for possible move, deletes all references, so the object can be garbage-collected
 * 
 * @return {void}
 */
dojo.dnd.move.constrainedMoveable.prototype.destroy = function() {};

/**
 *
 * @param {?} type
 * @param {?} event
 * @return {?}
 */
dojo.dnd.move.constrainedMoveable.prototype.emit = function(type, event) {};

/**
 *
 * @param {?} params
 * @param {?} node
 * @param {?} Ctor
 * @return {?}
 */
dojo.dnd.move.constrainedMoveable.prototype.markupFactory = function(params, node, Ctor) {};

/**
 *
 * @param {?} type
 * @param {?} listener
 * @return {?}
 */
dojo.dnd.move.constrainedMoveable.prototype.on = function(type, listener) {};

/**
 * called when the drag is detected;
 * responsible for creation of the mover
 * 
 * @param {!Event} e
 * @return {void}
 */
dojo.dnd.move.constrainedMoveable.prototype.onDragDetected = function(e) {};

/**
 * called during the very first move notification;
 * can be used to initialize coordinates, can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @return {void}
 */
dojo.dnd.move.constrainedMoveable.prototype.onFirstMove = function(mover) {};

/**
 * event processor for onmousedown/ontouchstart, creates a Mover for the node
 * 
 * @param {!Event} e mouse/touch event
 * @return {void}
 */
dojo.dnd.move.constrainedMoveable.prototype.onMouseDown = function(e) {};

/**
 * event processor for onmousemove/ontouchmove, used only for delayed drags
 * 
 * @param {!Event} e mouse/touch event
 * @return {void}
 */
dojo.dnd.move.constrainedMoveable.prototype.onMouseMove = function(e) {};

/**
 * event processor for onmouseup, used only for delayed drags
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.move.constrainedMoveable.prototype.onMouseUp = function(e) {};

/**
 * called during every move notification;
 * should actually move the node; can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @return {void}
 */
dojo.dnd.move.constrainedMoveable.prototype.onMove = function(mover, leftTop) {};

/**
 * called after every incremental move; can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @return {void}
 */
dojo.dnd.move.constrainedMoveable.prototype.onMoved = function(mover, leftTop) {};

/**
 * called before every move operation
 * 
 * @param {!dojo.dnd.Mover} mover
 * @return {void}
 */
dojo.dnd.move.constrainedMoveable.prototype.onMoveStart = function(mover) {};

/**
 * called after every move operation
 * 
 * @param {!dojo.dnd.Mover} mover
 * @return {void}
 */
dojo.dnd.move.constrainedMoveable.prototype.onMoveStop = function(mover) {};

/**
 * called before every incremental move; can be overwritten.
 * 
 * @param {!dojo.dnd.Mover} mover
 * @param {!Object} leftTop
 * @return {void}
 */
dojo.dnd.move.constrainedMoveable.prototype.onMoving = function(mover, leftTop) {};

/**
 * event processor for onselectevent and ondragevent
 * 
 * @param {!Event} e mouse event
 * @return {void}
 */
dojo.dnd.move.constrainedMoveable.prototype.onSelectStart = function(e) {};
/** @const */
dojo.errors = {};
/**
 * @record
 * @struct
 */
dojo.errors.create = function() {};

/* TODO: CallSignature: dojo.errors */
/**
 * @record
 * @struct
 */
dojo.errors.CancelError = function() {};

/* TODO: CallSignature: dojo.errors */
/**
 * @record
 * @struct
 */
dojo.errors.RequestError = function() {};

/* TODO: CallSignature: dojo.errors */
/**
 * @record
 * @struct
 */
dojo.errors.RequestTimeoutError = function() {};

/* TODO: CallSignature: dojo.errors */
/** @const */
dojo.io = {};
/**
 * @record
 * @struct
 */
dojo.io.iframe = function() {};

/**
 * Creates a hidden iframe in the page. Used mostly for IO
 * transports.  You do not need to call this to start a
 * dojo/io/iframe request. Just call send().
 * 
 * @param {!String} fname The name of the iframe. Used for the name attribute on theiframe.
 * @param {!String} onloadstr A string of JavaScript that will be executed when the contentin the iframe loads.
 * @param {!String} uri The value of the src attribute on the iframe element. If avalue is not given, then dojo/resources/blank.html will beused.
 * @return {void}
 */
dojo.io.iframe.prototype.create = function(fname, onloadstr, uri) {};

/**
 * Returns the document object associated with the iframe DOM Node argument.
 * 
 * @param {?} iframeNode
 * @return {void}
 */
dojo.io.iframe.prototype.doc = function(iframeNode) {};

/**
 * Sets the URL that is loaded in an IFrame. The replace parameter
 * indicates whether location.replace() should be used when
 * changing the location of the iframe.
 * 
 * @param {?} iframe
 * @param {?} src
 * @param {?} replace
 * @return {void}
 */
dojo.io.iframe.prototype.setSrc = function(iframe, src, replace) {};
/**
 * @record
 * @struct
 */
dojo.io.script = function() {};

/**
 * creates a new <script> tag pointing to the specified URL and
 * adds it to the document.
 * Attaches the script element to the DOM. Use this method if you
 * just want to attach a script to the DOM and do not care when or
 * if it loads.
 * 
 * @param {?} id
 * @param {?} url
 * @param {?} frameDocument
 * @return {void}
 */
dojo.io.script.prototype.attach = function(id, url, frameDocument) {};

/**
 * sends a get request using a dynamically created script tag.
 * 
 * @param {!Object} args An object with the following properties:callbackParamName (String): Deprecated as of Dojo 1.4 in favor of "jsonp", but still supported forlegacy code. See notes for jsonp property.jsonp (String): The URL parameter name that indicates the JSONP callback string.For instance, when using Yahoo JSONP calls it is normally,jsonp: "callback". For AOL JSONP calls it is normallyjsonp: "c".checkString (String): A string of JavaScript that when evaluated like so:"typeof(" + checkString + ") != 'undefined'"being true means that the script fetched has been loaded.Do not use this if doing a JSONP type of call (use callbackParamName instead).frameDoc (Document): The Document object for a child iframe. If this is passed in, the scriptwill be attached to that document. This can be helpful in some comet long-pollingscenarios with Firefox and Opera.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.handleAs (String, optional): Acceptable values depend on the type of IOtransport (see specific IO calls for more information).rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo.io.script.prototype.get = function(args) {};

/**
 * removes the script element with the given id, from the given frameDocument.
 * If no frameDocument is passed, the current document is used.
 * 
 * @param {?} id
 * @param {?} frameDocument
 * @return {void}
 */
dojo.io.script.prototype.remove = function(id, frameDocument) {};
/** @const */
dojo.promise = {};
/**
 * @record
 * @struct
 */
dojo.promise.all = function() {};

/* TODO: CallSignature: dojo.promise */

/* TODO: CallSignature: dojo.promise */
/**
 * @record
 * @struct
 */
dojo.promise.first = function() {};

/* TODO: CallSignature: dojo.promise */

/* TODO: CallSignature: dojo.promise */
/**
 * @record
 * @struct
 */
dojo.promise.instrumentation = function() {};

/* TODO: CallSignature: dojo.promise */
/**
 * @record
 * @struct
 */
dojo.promise.Thenable = function() {};

/**
 * @template U
 * @param {function(T): (U|!dojo.promise.Thenable<U>)=} onFulfilled
 * @param {function(!Error): (U|!dojo.promise.Thenable<U>)=} onRejected
 * @return {!dojo.promise.Thenable<U>}
 */
dojo.promise.Thenable.prototype.then = function(onFulfilled, onRejected) {};
/**
 * @record
 * @struct
 */
dojo.promise.Callback = function() {};

/* TODO: CallSignature: dojo.promise */
/**
 * @extends {dojo.promise.Thenable}
 * @record
 * @struct
 */
dojo.promise.Promise = function() {};

/**
 * Add a callback to be invoked when the promise is resolved
 * or rejected.
 * 
 * @template U
 * @param {!dojo.promise.Callback<?, U>} callbackOrErrback               OptionalA function that is used both as a callback and errback.
 * @return {!dojo.promise.Promise<U>}
 */
dojo.promise.Promise.prototype.always = function(callbackOrErrback) {};

/**
 * Inform the deferred it may cancel its asynchronous operation.
 * Inform the deferred it may cancel its asynchronous operation.
 * The deferred's (optional) canceler is invoked and the
 * deferred will be left in a rejected state. Can affect other
 * promises that originate with the same deferred.
 * 
 * @param {?} reason A message that may be sent to the deferred's canceler,explaining why it's being canceled.
 * @param {boolean=} strict               OptionalIf strict, will throw an error if the deferred has alreadybeen fulfilled and consequently cannot be canceled.
 * @return {?}
 */
dojo.promise.Promise.prototype.cancel = function(reason, strict) {};

/**
 * Checks whether the promise has been canceled.
 * 
 * @return {boolean}
 */
dojo.promise.Promise.prototype.isCanceled = function() {};

/**
 * Checks whether the promise has been resolved or rejected.
 * 
 * @return {boolean}
 */
dojo.promise.Promise.prototype.isFulfilled = function() {};

/**
 * Checks whether the promise has been rejected.
 * 
 * @return {boolean}
 */
dojo.promise.Promise.prototype.isRejected = function() {};

/**
 * Checks whether the promise has been resolved.
 * 
 * @return {boolean}
 */
dojo.promise.Promise.prototype.isResolved = function() {};

/**
 * Add new errbacks to the promise.
 * 
 * @template U
 * @param {!dojo.promise.Callback<?, U>=} errback               OptionalCallback to be invoked when the promise is rejected.
 * @return {!dojo.promise.Promise<U>}
 */
dojo.promise.Promise.prototype.otherwise = function(errback) {};

/**
 * Add new callbacks to the promise.
 * Add new callbacks to the deferred. Callbacks can be added
 * before or after the deferred is fulfilled.
 * 
 * @template U
 * @param {!dojo.promise.Callback<T, U>=} callback               OptionalCallback to be invoked when the promise is resolved.Receives the resolution value.
 * @param {!dojo.promise.Callback<?, U>=} errback               OptionalCallback to be invoked when the promise is rejected.Receives the rejection error.
 * @param {!dojo.promise.Callback<?, U>=} progback               OptionalCallback to be invoked when the promise emits a progressupdate. Receives the progress update.
 * @return {!dojo.promise.Promise<U>}
 */
dojo.promise.Promise.prototype.then = function(callback, errback, progback) {};

/**
 *
 * @return {!String}
 */
dojo.promise.Promise.prototype.toString = function() {};

/**
 * Trace the promise.
 * Tracing allows you to transparently log progress,
 * resolution and rejection of promises, without affecting the
 * promise itself. Any arguments passed to trace() are
 * emitted in trace events. See dojo/promise/tracer on how
 * to handle traces.
 * 
 * @return {!dojo.promise.Promise}
 */
dojo.promise.Promise.prototype.trace = function() {};

/**
 * Trace rejection of the promise.
 * Tracing allows you to transparently log progress,
 * resolution and rejection of promises, without affecting the
 * promise itself. Any arguments passed to trace() are
 * emitted in trace events. See dojo/promise/tracer on how
 * to handle traces.
 * 
 * @return {!dojo.promise.Promise}
 */
dojo.promise.Promise.prototype.traceRejected = function() {};
/**
 * @record
 * @struct
 */
dojo.promise.tracer = function() {};

/**
 * Subscribe to traces.
 * See dojo/Evented#on().
 * 
 * @param {!String} type resolved, rejected, or progress
 * @param {!Function} listener The listener is passed the traced value and any argumentsthat were used with the .trace() call.
 * @return {void}
 */
dojo.promise.tracer.prototype.on = function(type, listener) {};
/** @const */
dojo.rpc = {};

/**
 * @constructor
 * @struct
 * @param {?} args
 * @param {?} requiredArgs
 */
dojo.rpc.JsonpService = function(args, requiredArgs) {};

/* TODO: PropertyDeclaration: dojo.rpc."serviceUrl" */

/* TODO: PropertyDeclaration: dojo.rpc."strictArgChecks" */

/**
 * JSONP bind method. Takes remote method, parameters,
 * deferred, and a url, calls createRequest to make a JSON-RPC
 * envelope and passes that off with bind.
 * 
 * @param {!String} method The name of the method we are calling
 * @param {!dojo._base.array} parameters The parameters we are passing off to the method
 * @param {!dojo.Deferred} deferredRequestHandler The Deferred object for this particular request
 * @param {?} url
 * @return {void}
 */
dojo.rpc.JsonpService.prototype.bind = function(method, parameters, deferredRequestHandler, url) {};

/**
 * create a JSONP req
 * 
 * @param {?} parameters
 * @return {!Object}
 */
dojo.rpc.JsonpService.prototype.createRequest = function(parameters) {};

/**
 * create callback that calls the Deferred errback method
 * 
 * @param {!dojo._base.Deferred} deferredRequestHandler The deferred object handling a request.
 * @return {!Function}
 */
dojo.rpc.JsonpService.prototype.errorCallback = function(deferredRequestHandler) {};

/**
 * generate the local bind methods for the remote object
 * 
 * @param {!String} method The name of the method we are generating
 * @param {!dojo._base.array} parameters the array of parameters for this call.
 * @param {!String} url the service url for this call
 * @return {?}
 */
dojo.rpc.JsonpService.prototype.generateMethod = function(method, parameters, url) {};

/**
 * parse the results coming back from an rpc request.  this
 * base implementation, just returns the full object
 * subclasses should parse and only return the actual results
 * 
 * @param {!Object} obj Object that is the return results from an rpc request
 * @return {!Object}
 */
dojo.rpc.JsonpService.prototype.parseResults = function(obj) {};

/**
 * callback method for receipt of a smd object.  Parse the smd
 * and generate functions based on the description
 * 
 * @param {?} object smd object defining this service.
 * @return {void}
 */
dojo.rpc.JsonpService.prototype.processSmd = function(object) {};

/**
 * create callback that calls the Deferred's callback method
 * 
 * @param {!dojo._base.Deferred} deferredRequestHandler The deferred object handling a request.
 * @return {?}
 */
dojo.rpc.JsonpService.prototype.resultCallback = function(deferredRequestHandler) {};

/**
 * @constructor
 * @struct
 * @param {!Object} args
 */
dojo.rpc.JsonService = function(args) {};

/* TODO: PropertyDeclaration: dojo.rpc."bustCache" */

/* TODO: PropertyDeclaration: dojo.rpc."contentType" */

/* TODO: PropertyDeclaration: dojo.rpc."lastSubmissionId" */

/* TODO: PropertyDeclaration: dojo.rpc."serviceUrl" */

/* TODO: PropertyDeclaration: dojo.rpc."strictArgChecks" */

/**
 * JSON-RPC bind method. Takes remote method, parameters,
 * deferred, and a url, calls createRequest to make a JSON-RPC
 * envelope and passes that off with bind.
 * 
 * @param {!String} method The name of the method we are calling
 * @param {!Array<?>} parameters The parameters we are passing off to the method
 * @param {!dojo.Deferred} deferredRequestHandler The Deferred object for this particular request
 * @param {?} url
 * @return {void}
 */
dojo.rpc.JsonService.prototype.bind = function(method, parameters, deferredRequestHandler, url) {};

/**
 * call an arbitrary remote method without requiring it to be
 * predefined with SMD
 * 
 * @param {!String} method the name of the remote method you want to call.
 * @param {!Array<?>} params array of parameters to pass to method
 * @return {?}
 */
dojo.rpc.JsonService.prototype.callRemote = function(method, params) {};

/**
 * create a JSON-RPC envelope for the request
 * 
 * @param {!String} method The name of the method we are creating the request for
 * @param {!dojo._base.array} params The array of parameters for this request;
 * @return {?}
 */
dojo.rpc.JsonService.prototype.createRequest = function(method, params) {};

/**
 * create callback that calls the Deferred errback method
 * 
 * @param {!dojo._base.Deferred} deferredRequestHandler The deferred object handling a request.
 * @return {!Function}
 */
dojo.rpc.JsonService.prototype.errorCallback = function(deferredRequestHandler) {};

/**
 * generate the local bind methods for the remote object
 * 
 * @param {!String} method The name of the method we are generating
 * @param {!dojo._base.array} parameters the array of parameters for this call.
 * @param {!String} url the service url for this call
 * @return {?}
 */
dojo.rpc.JsonService.prototype.generateMethod = function(method, parameters, url) {};

/**
 * parse the result envelope and pass the results back to
 * the callback function
 * 
 * @param {!Object} obj Object containing envelope of data we receive from the server
 * @return {?}
 */
dojo.rpc.JsonService.prototype.parseResults = function(obj) {};

/**
 * callback method for receipt of a smd object.  Parse the smd
 * and generate functions based on the description
 * 
 * @param {?} object smd object defining this service.
 * @return {void}
 */
dojo.rpc.JsonService.prototype.processSmd = function(object) {};

/**
 * create callback that calls the Deferred's callback method
 * 
 * @param {!dojo._base.Deferred} deferredRequestHandler The deferred object handling a request.
 * @return {?}
 */
dojo.rpc.JsonService.prototype.resultCallback = function(deferredRequestHandler) {};

/**
 * @constructor
 * @struct
 * @param {!Object} args
 */
dojo.rpc.RpcService = function(args) {};

/* TODO: PropertyDeclaration: dojo.rpc."serviceUrl" */

/* TODO: PropertyDeclaration: dojo.rpc."strictArgChecks" */

/**
 * create callback that calls the Deferred errback method
 * 
 * @param {!dojo._base.Deferred} deferredRequestHandler The deferred object handling a request.
 * @return {!Function}
 */
dojo.rpc.RpcService.prototype.errorCallback = function(deferredRequestHandler) {};

/**
 * generate the local bind methods for the remote object
 * 
 * @param {!String} method The name of the method we are generating
 * @param {!dojo._base.array} parameters the array of parameters for this call.
 * @param {!String} url the service url for this call
 * @return {?}
 */
dojo.rpc.RpcService.prototype.generateMethod = function(method, parameters, url) {};

/**
 * parse the results coming back from an rpc request.  this
 * base implementation, just returns the full object
 * subclasses should parse and only return the actual results
 * 
 * @param {!Object} obj Object that is the return results from an rpc request
 * @return {!Object}
 */
dojo.rpc.RpcService.prototype.parseResults = function(obj) {};

/**
 * callback method for receipt of a smd object.  Parse the smd
 * and generate functions based on the description
 * 
 * @param {?} object smd object defining this service.
 * @return {void}
 */
dojo.rpc.RpcService.prototype.processSmd = function(object) {};

/**
 * create callback that calls the Deferred's callback method
 * 
 * @param {!dojo._base.Deferred} deferredRequestHandler The deferred object handling a request.
 * @return {?}
 */
dojo.rpc.RpcService.prototype.resultCallback = function(deferredRequestHandler) {};
/** @const */
dojo.selector = {};
/**
 * @record
 * @struct
 */
dojo.selector.lite = function() {};

/* TODO: CallSignature: dojo.selector */
 /** @type {!Object} */
dojo.selector.lite.prototype.match;
/**
 * @record
 * @struct
 */
dojo.selector.acme = function() {};

/* TODO: CallSignature: dojo.selector */

/* TODO: CallSignature: dojo.selector */

/**
 * function for filtering a NodeList based on a selector, optimized for simple selectors
 * 
 * function for filtering a NodeList based on a selector, optimized for simple selectors
 * 
 * @param {!Array<!HTMLElement>} nodeList
 * @param {!String} filter
 * @param {!String|!HTMLElement=} root               Optional
 * @return {void}
 */
dojo.selector.acme.prototype.filter = function(nodeList, filter, root) {};
/**
 * @record
 * @struct
 */
dojo.selector._loader = function() {};

/**
 *
 * @param {?} id
 * @param {?} parentRequire
 * @param {?} loaded
 * @param {?} config
 * @return {?}
 */
dojo.selector._loader.prototype.load = function(id, parentRequire, loaded, config) {};
/** @const */
dojo.store = {};
/**
 * @record
 * @struct
 */
dojo.store.Observable = function() {};

/* TODO: CallSignature: dojo.store */

/**
 * @constructor
 * @struct
 * @param {?} masterStore
 * @param {?} cachingStore
 * @param {!Object=} options
 */
dojo.store.Cache = function(masterStore, cachingStore, options) {};

/* TODO: PropertyDeclaration: dojo.store."idProperty" */

/**
 * If the store can be queried locally (on the client side in JS), this defines
 * the query engine to use for querying the data store.
 * This takes a query and query options and returns a function that can execute
 * the provided query on a JavaScript array. The queryEngine may be replace to
 * provide more sophisticated querying capabilities. For example:
 * 
 * var query = store.queryEngine({foo:"bar"}, {count:10});
 * query(someArray) -> filtered array
 * The returned query function may have a "matches" property that can be
 * 
 * used to determine if an object matches the query. For example:
 * 
 * query.matches({id:"some-object", foo:"bar"}) -> true
 * query.matches({id:"some-object", foo:"something else"}) -> false
 * 
 * @param {!Object} query
 * @param {!dojo.store.api.Store.QueryOptions} options
 * @return {?}
 */
dojo.store.Cache.prototype.queryEngine = function(query, options) {};

/**
 * Add the given object to the store.
 * 
 * @param {!Object} object The object to add to the store.
 * @param {?=} directives               OptionalAny additional parameters needed to describe how the add should be performed.
 * @return {number}
 */
dojo.store.Cache.prototype.add = function(object, directives) {};

/**
 * Remove the object with the given id from the underlying caching store.
 * 
 * @param {number} id The identifier for the object in question.
 * @return {void}
 */
dojo.store.Cache.prototype.evict = function(id) {};

/**
 * Get the object with the specific id.
 * 
 * @param {number} id The identifier for the object in question.
 * @param {!Object=} directives               OptionalAny additional parameters needed to describe how the get should be performed.
 * @return {!dojo.store.api.Store.QueryResults}
 */
dojo.store.Cache.prototype.get = function(id, directives) {};

/**
 * Retrieves the children of an object.
 * 
 * @param {!Object} parent The object to find the children of.
 * @param {!dojo.store.api.Store.QueryOptions=} options               OptionalAdditional options to apply to the retrieval of the children.
 * @return {!dojo.store.api.Store.QueryResults}
 */
dojo.store.Cache.prototype.getChildren = function(parent, options) {};

/**
 * Returns an object's identity
 * 
 * @param {!Object} object The object to get the identity from
 * @return {?}
 */
dojo.store.Cache.prototype.getIdentity = function(object) {};

/**
 * Returns any metadata about the object. This may include attribution,
 * cache directives, history, or version information.
 * 
 * @param {!Object} object The object to return metadata for.
 * @return {!Object}
 */
dojo.store.Cache.prototype.getMetadata = function(object) {};

/**
 * Put the object into the store (similar to an HTTP PUT).
 * 
 * @param {!Object} object The object to put to the store.
 * @param {!dojo.store.api.Store.PutDirectives=} directives               OptionalAny additional parameters needed to describe how the put should be performed.
 * @return {number}
 */
dojo.store.Cache.prototype.put = function(object, directives) {};

/**
 * Query the underlying master store and cache any results.
 * 
 * Query the underlying master store and cache any results.
 * 
 * @param {!Object|!String} query The object or string containing query information. Dependent on the query engine used.
 * @param {!dojo.store.api.Store.QueryOptions=} directives               OptionalAn optional keyword arguments object with additional parameters describing the query.
 * @return {!dojo.store.api.Store.QueryResults}
 */
dojo.store.Cache.prototype.query = function(query, directives) {};

/**
 * Remove the object with the specific id.
 * 
 * @param {number} id The identifier for the object in question.
 * @return {void}
 */
dojo.store.Cache.prototype.remove = function(id) {};

/**
 * Starts a new transaction.
 * Note that a store user might not call transaction() prior to using put,
 * delete, etc. in which case these operations effectively could be thought of
 * as "auto-commit" style actions.
 * 
 * @return {!dojo.store.api.Store.Transaction}
 */
dojo.store.Cache.prototype.transaction = function() {};

/**
 * @constructor
 * @struct
 * @param {!Object=} options
 */
dojo.store.DataStore = function(options) {};

/* TODO: PropertyDeclaration: dojo.store."idProperty" */

/* TODO: PropertyDeclaration: dojo.store."store" */

/* TODO: PropertyDeclaration: dojo.store."target" */

/**
 * Creates an object, throws an error if the object already exists
 * 
 * @param {!Object} object The object to store.
 * @param {!dojo.store.api.Store.PutDirectives} directives               OptionalAdditional directives for creating objects.
 * @return {?}
 */
dojo.store.DataStore.prototype.add = function(object, directives) {};

/**
 * Retrieves an object by it's identity. This will trigger a fetchItemByIdentity
 * 
 * @param {!Object} id               OptionalThe identity to use to lookup the object
 * @param {?=} options
 * @return {?}
 */
dojo.store.DataStore.prototype.get = function(id, options) {};

/**
 * Retrieves the children of an object.
 * 
 * @param {!Object} parent The object to find the children of.
 * @param {!dojo.store.api.Store.QueryOptions=} options               OptionalAdditional options to apply to the retrieval of the children.
 * @return {!dojo.store.api.Store.QueryResults}
 */
dojo.store.DataStore.prototype.getChildren = function(parent, options) {};

/**
 * Fetch the identity for the given object.
 * 
 * @param {!Object} object The data object to get the identity from.
 * @return {?}
 */
dojo.store.DataStore.prototype.getIdentity = function(object) {};

/**
 * Returns any metadata about the object. This may include attribution,
 * cache directives, history, or version information.
 * 
 * @param {!Object} object The object to return metadata for.
 * @return {!Object}
 */
dojo.store.DataStore.prototype.getMetadata = function(object) {};

/**
 * Stores an object by its identity.
 * 
 * @param {!Object} object The object to store.
 * @param {!Object=} options               OptionalAdditional metadata for storing the data.  Includes a reference to an idthat the object may be stored with (i.e. { id: "foo" }).
 * @return {void}
 */
dojo.store.DataStore.prototype.put = function(object, options) {};

/**
 * Queries the store for objects.
 * 
 * @param {!Object} query The query to use for retrieving objects from the store
 * @param {!Object=} options               OptionalOptional options object as used by the underlying dojo.data Store.
 * @return {?}
 */
dojo.store.DataStore.prototype.query = function(query, options) {};

/**
 * Defines the query engine to use for querying the data store
 * 
 * @param {!Object} query An object hash with fields that may match fields of items in the store.Values in the hash will be compared by normal == operator, but regular expressionsor any object that provides a test() method are also supported and can beused to match strings by more complex expressions(and then the regex's or object's test() method will be used to match values).
 * @param {!dojo.store.api.Store.QueryOptions=} options               OptionalAn object that contains optional information such as sort, start, and count.
 * @return {?}
 */
dojo.store.DataStore.prototype.queryEngine = function(query, options) {};

/**
 * Deletes an object by its identity.
 * 
 * @param {!Object} id The identity to use to delete the object
 * @return {void}
 */
dojo.store.DataStore.prototype.remove = function(id) {};

/**
 * Starts a new transaction.
 * Note that a store user might not call transaction() prior to using put,
 * delete, etc. in which case these operations effectively could be thought of
 * as "auto-commit" style actions.
 * 
 * @return {!dojo.store.api.Store.Transaction}
 */
dojo.store.DataStore.prototype.transaction = function() {};

/**
 * @constructor
 * @struct
 * @param {!dojo.store.Memory} options
 */
dojo.store.Memory = function(options) {};

/* TODO: PropertyDeclaration: dojo.store."data" */

/* TODO: PropertyDeclaration: dojo.store."idProperty" */

/* TODO: PropertyDeclaration: dojo.store."index" */

/**
 * Creates an object, throws an error if the object already exists
 * 
 * @param {!Object} object The object to store.
 * @param {!dojo.store.api.Store.PutDirectives=} options               OptionalAdditional metadata for storing the data.  Includes an "id"property if a specific id is to be used.
 * @return {?}
 */
dojo.store.Memory.prototype.add = function(object, options) {};

/**
 * Retrieves an object by its identity
 * 
 * @param {number} id The identity to use to lookup the object
 * @return {?}
 */
dojo.store.Memory.prototype.get = function(id) {};

/**
 * Retrieves the children of an object.
 * 
 * @param {!Object} parent The object to find the children of.
 * @param {!dojo.store.api.Store.QueryOptions=} options               OptionalAdditional options to apply to the retrieval of the children.
 * @return {!dojo.store.api.Store.QueryResults}
 */
dojo.store.Memory.prototype.getChildren = function(parent, options) {};

/**
 * Returns an object's identity
 * 
 * @param {!Object} object The object to get the identity from
 * @return {?}
 */
dojo.store.Memory.prototype.getIdentity = function(object) {};

/**
 * Returns any metadata about the object. This may include attribution,
 * cache directives, history, or version information.
 * 
 * @param {!Object} object The object to return metadata for.
 * @return {!Object}
 */
dojo.store.Memory.prototype.getMetadata = function(object) {};

/**
 * Stores an object
 * 
 * @param {!Object} object The object to store.
 * @param {!dojo.store.api.Store.PutDirectives=} options               OptionalAdditional metadata for storing the data.  Includes an "id"property if a specific id is to be used.
 * @return {?}
 */
dojo.store.Memory.prototype.put = function(object, options) {};

/**
 * Queries the store for objects.
 * 
 * @param {!Object} query The query to use for retrieving objects from the store.
 * @param {!dojo.store.api.Store.QueryOptions=} options               OptionalThe optional arguments to apply to the resultset.
 * @return {?}
 */
dojo.store.Memory.prototype.query = function(query, options) {};

/**
 * Defines the query engine to use for querying the data store
 * 
 * @param {!Object} query An object hash with fields that may match fields of items in the store.Values in the hash will be compared by normal == operator, but regular expressionsor any object that provides a test() method are also supported and can beused to match strings by more complex expressions(and then the regex's or object's test() method will be used to match values).
 * @param {!dojo.store.api.Store.QueryOptions=} options               OptionalAn object that contains optional information such as sort, start, and count.
 * @return {?}
 */
dojo.store.Memory.prototype.queryEngine = function(query, options) {};

/**
 * Deletes an object by its identity
 * 
 * @param {number} id The identity to use to delete the object
 * @return {?}
 */
dojo.store.Memory.prototype.remove = function(id) {};

/**
 * Sets the given data as the source for this store, and indexes it
 * 
 * @param {!Array<!Object>} data An array of objects to use as the source of data.
 * @return {void}
 */
dojo.store.Memory.prototype.setData = function(data) {};

/**
 * Starts a new transaction.
 * Note that a store user might not call transaction() prior to using put,
 * delete, etc. in which case these operations effectively could be thought of
 * as "auto-commit" style actions.
 * 
 * @return {!dojo.store.api.Store.Transaction}
 */
dojo.store.Memory.prototype.transaction = function() {};

/**
 * @constructor
 * @struct
 * @param {!dojo.store.JsonRest} options
 */
dojo.store.JsonRest = function(options) {};

/* TODO: PropertyDeclaration: dojo.store."accepts" */

/* TODO: PropertyDeclaration: dojo.store."ascendingPrefix" */

/* TODO: PropertyDeclaration: dojo.store."descendingPrefix" */

/* TODO: PropertyDeclaration: dojo.store."headers" */

/* TODO: PropertyDeclaration: dojo.store."idProperty" */

/* TODO: PropertyDeclaration: dojo.store."target" */

/**
 * If the store can be queried locally (on the client side in JS), this defines
 * the query engine to use for querying the data store.
 * This takes a query and query options and returns a function that can execute
 * the provided query on a JavaScript array. The queryEngine may be replace to
 * provide more sophisticated querying capabilities. For example:
 * 
 * var query = store.queryEngine({foo:"bar"}, {count:10});
 * query(someArray) -> filtered array
 * The returned query function may have a "matches" property that can be
 * 
 * used to determine if an object matches the query. For example:
 * 
 * query.matches({id:"some-object", foo:"bar"}) -> true
 * query.matches({id:"some-object", foo:"something else"}) -> false
 * 
 * @param {!Object} query
 * @param {!dojo.store.api.Store.QueryOptions} options
 * @return {?}
 */
dojo.store.JsonRest.prototype.queryEngine = function(query, options) {};

/**
 * Adds an object. This will trigger a PUT request to the server
 * if the object has an id, otherwise it will trigger a POST request.
 * 
 * @param {!Object} object The object to store.
 * @param {!Object=} options               OptionalAdditional metadata for storing the data.  Includes an "id"property if a specific id is to be used.
 * @return {?}
 */
dojo.store.JsonRest.prototype.add = function(object, options) {};

/**
 * Retrieves an object by its identity. This will trigger a GET request to the server using
 * the url this.target + id.
 * 
 * @param {number} id The identity to use to lookup the object
 * @param {!Object=} options               OptionalHTTP headers. For consistency with other methods, if a headers key exists on this object, it will beused to provide HTTP headers instead.
 * @return {?}
 */
dojo.store.JsonRest.prototype.get = function(id, options) {};

/**
 * Retrieves the children of an object.
 * 
 * @param {!Object} parent The object to find the children of.
 * @param {!dojo.store.api.Store.QueryOptions=} options               OptionalAdditional options to apply to the retrieval of the children.
 * @return {!dojo.store.api.Store.QueryResults}
 */
dojo.store.JsonRest.prototype.getChildren = function(parent, options) {};

/**
 * Returns an object's identity
 * 
 * @param {!Object} object The object to get the identity from
 * @return {?}
 */
dojo.store.JsonRest.prototype.getIdentity = function(object) {};

/**
 * Returns any metadata about the object. This may include attribution,
 * cache directives, history, or version information.
 * 
 * @param {!Object} object The object to return metadata for.
 * @return {!Object}
 */
dojo.store.JsonRest.prototype.getMetadata = function(object) {};

/**
 * Stores an object. This will trigger a PUT request to the server
 * if the object has an id, otherwise it will trigger a POST request.
 * 
 * @param {!Object} object The object to store.
 * @param {!Object=} options               OptionalAdditional metadata for storing the data.  Includes an "id"property if a specific id is to be used.
 * @return {?}
 */
dojo.store.JsonRest.prototype.put = function(object, options) {};

/**
 * Queries the store for objects. This will trigger a GET request to the server, with the
 * query added as a query string.
 * 
 * @param {!Object} query The query to use for retrieving objects from the store.
 * @param {!Object=} options               OptionalThe optional arguments to apply to the resultset.
 * @return {?}
 */
dojo.store.JsonRest.prototype.query = function(query, options) {};

/**
 * Deletes an object by its identity. This will trigger a DELETE request to the server.
 * 
 * @param {number} id The identity to use to delete the object
 * @param {!Object=} options               OptionalHTTP headers.
 * @return {?}
 */
dojo.store.JsonRest.prototype.remove = function(id, options) {};

/**
 * Starts a new transaction.
 * Note that a store user might not call transaction() prior to using put,
 * delete, etc. in which case these operations effectively could be thought of
 * as "auto-commit" style actions.
 * 
 * @return {!dojo.store.api.Store.Transaction}
 */
dojo.store.JsonRest.prototype.transaction = function() {};
/** @const */
dojo.store.api = {};

/**
 * @constructor
 * @struct
 */
dojo.store.api.Store = function() {};

/* TODO: PropertyDeclaration: dojo.store.api."idProperty" */

/**
 * If the store can be queried locally (on the client side in JS), this defines
 * the query engine to use for querying the data store.
 * This takes a query and query options and returns a function that can execute
 * the provided query on a JavaScript array. The queryEngine may be replace to
 * provide more sophisticated querying capabilities. For example:
 * 
 * var query = store.queryEngine({foo:"bar"}, {count:10});
 * query(someArray) -> filtered array
 * The returned query function may have a "matches" property that can be
 * 
 * used to determine if an object matches the query. For example:
 * 
 * query.matches({id:"some-object", foo:"bar"}) -> true
 * query.matches({id:"some-object", foo:"something else"}) -> false
 * 
 * @param {!Object} query
 * @param {!dojo.store.api.Store.QueryOptions} options
 * @return {?}
 */
dojo.store.api.Store.prototype.queryEngine = function(query, options) {};

/**
 * Creates an object, throws an error if the object already exists
 * 
 * @param {!Object} object The object to store.
 * @param {!dojo.store.api.Store.PutDirectives=} directives               OptionalAdditional directives for creating objects.
 * @return {?}
 */
dojo.store.api.Store.prototype.add = function(object, directives) {};

/**
 * Retrieves an object by its identity
 * 
 * @param {number} id The identity to use to lookup the object
 * @return {!Object}
 */
dojo.store.api.Store.prototype.get = function(id) {};

/**
 * Retrieves the children of an object.
 * 
 * @param {!Object} parent The object to find the children of.
 * @param {!dojo.store.api.Store.QueryOptions=} options               OptionalAdditional options to apply to the retrieval of the children.
 * @return {!dojo.store.api.Store.QueryResults}
 */
dojo.store.api.Store.prototype.getChildren = function(parent, options) {};

/**
 * Returns an object's identity
 * 
 * @param {!Object} object The object to get the identity from
 * @return {?}
 */
dojo.store.api.Store.prototype.getIdentity = function(object) {};

/**
 * Returns any metadata about the object. This may include attribution,
 * cache directives, history, or version information.
 * 
 * @param {!Object} object The object to return metadata for.
 * @return {!Object}
 */
dojo.store.api.Store.prototype.getMetadata = function(object) {};

/**
 * Stores an object
 * 
 * @param {!Object} object The object to store.
 * @param {!dojo.store.api.Store.PutDirectives=} directives               OptionalAdditional directives for storing objects.
 * @return {?}
 */
dojo.store.api.Store.prototype.put = function(object, directives) {};

/**
 *
 * @return {void}
 */
dojo.store.api.Store.prototype.PutDirectives = function() {};

/**
 * Queries the store for objects. This does not alter the store, but returns a
 * set of data from the store.
 * 
 * Queries the store for objects. This does not alter the store, but returns a
 * set of data from the store.
 * 
 * Queries the store for objects. This does not alter the store, but returns a
 * set of data from the store.
 * 
 * @param {!String|!Object|!Function} query The query to use for retrieving objects from the store.
 * @param {!dojo.store.api.Store.QueryOptions=} options The optional arguments to apply to the resultset.
 * @return {!dojo.store.api.Store.QueryResults}
 */
dojo.store.api.Store.prototype.query = function(query, options) {};

/**
 *
 * @return {void}
 */
dojo.store.api.Store.prototype.QueryOptions = function() {};

/**
 *
 * @return {void}
 */
dojo.store.api.Store.prototype.QueryResults = function() {};

/**
 * Deletes an object by its identity
 * 
 * @param {number} id The identity to use to delete the object
 * @return {void}
 */
dojo.store.api.Store.prototype.remove = function(id) {};

/**
 *
 * @return {void}
 */
dojo.store.api.Store.prototype.SortInformation = function() {};

/**
 * Starts a new transaction.
 * Note that a store user might not call transaction() prior to using put,
 * delete, etc. in which case these operations effectively could be thought of
 * as "auto-commit" style actions.
 * 
 * @return {!dojo.store.api.Store.Transaction}
 */
dojo.store.api.Store.prototype.transaction = function() {};

/**
 *
 * @return {void}
 */
dojo.store.api.Store.prototype.Transaction = function() {};

/**
 * @constructor
 * @struct
 */
dojo.store.api.Store.PutDirectives = function() {};

/* TODO: PropertyDeclaration: dojo.store.api.Store."before" */

/* TODO: PropertyDeclaration: dojo.store.api.Store."id" */

/* TODO: PropertyDeclaration: dojo.store.api.Store."overwrite" */

/* TODO: PropertyDeclaration: dojo.store.api.Store."parent" */

/**
 * @constructor
 * @struct
 */
dojo.store.api.Store.QueryOptions = function() {};

/* TODO: PropertyDeclaration: dojo.store.api.Store."count" */

/* TODO: PropertyDeclaration: dojo.store.api.Store."sort" */

/* TODO: PropertyDeclaration: dojo.store.api.Store."start" */

/**
 * @constructor
 * @struct
 */
dojo.store.api.Store.QueryResults = function() {};

/* TODO: PropertyDeclaration: dojo.store.api.Store."total" */

/**
 * Filters the query results, based on
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter.
 * Note that this may executed asynchronously. The callback may be called
 * after this function returns.
 * 
 * @param {?} callback Function that is called for each object in the query results
 * @param {?} thisObject The object to use as |this| in the callback.
 * @return {!dojo.store.api.Store.QueryResults}
 */
dojo.store.api.Store.QueryResults.prototype.filter = function(callback, thisObject) {};

/**
 * Iterates over the query results, based on
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach.
 * Note that this may executed asynchronously. The callback may be called
 * after this function returns.
 * 
 * @param {?} callback Function that is called for each object in the query results
 * @param {?} thisObject The object to use as |this| in the callback.
 * @return {void}
 */
dojo.store.api.Store.QueryResults.prototype.forEach = function(callback, thisObject) {};

/**
 * Maps the query results, based on
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map.
 * Note that this may executed asynchronously. The callback may be called
 * after this function returns.
 * 
 * @param {?} callback Function that is called for each object in the query results
 * @param {?} thisObject The object to use as |this| in the callback.
 * @return {!dojo.store.api.Store.QueryResults}
 */
dojo.store.api.Store.QueryResults.prototype.map = function(callback, thisObject) {};

/**
 * This registers a callback for notification of when data is modified in the query results.
 * This is an optional method, and is usually provided by dojo/store/Observable.
 * 
 * @param {!Function} listener The listener function is called when objects in the query results are modifiedto affect the query result. The listener function is called with the following arguments:listener(object, removedFrom, insertedInto);The object parameter indicates the object that was create, modified, or deleted.The removedFrom parameter indicates the index in the result array wherethe object used to be. If the value is -1, then the object is an addition tothis result set (due to a new object being created, or changed such that itis a part of the result set).The insertedInto parameter indicates the index in the result array wherethe object should be now. If the value is -1, then the object is a removalfrom this result set (due to an object being deleted, or changed such that itis not a part of the result set).
 * @param {?} includeAllUpdates This indicates whether or not to include object updates that do not affectthe inclusion or order of the object in the query results. By default this is false,which means that if any object is updated in such a way that it remainsin the result set and it's position in result sets is not affected, then the listenerwill not be fired.
 * @return {void}
 */
dojo.store.api.Store.QueryResults.prototype.observe = function(listener, includeAllUpdates) {};

/**
 * This registers a callback for when the query is complete, if the query is asynchronous.
 * This is an optional method, and may not be present for synchronous queries.
 * 
 * @param {?} callback This is called when the query is completed successfully, and is passed a single argumentthat is an array representing the query results.
 * @param {?} errorHandler This is called if the query failed, and is passed a single argument that is the errorfor the failure.
 * @return {void}
 */
dojo.store.api.Store.QueryResults.prototype.then = function(callback, errorHandler) {};

/**
 * @constructor
 * @struct
 */
dojo.store.api.Store.SortInformation = function() {};

/* TODO: PropertyDeclaration: dojo.store.api.Store."attribute" */

/* TODO: PropertyDeclaration: dojo.store.api.Store."descending" */

/**
 * @constructor
 * @struct
 */
dojo.store.api.Store.Transaction = function() {};

/**
 * Aborts the transaction. This may throw an error if it fails. Of if the operation
 * is asynchronous, it may return a promise that represents the eventual success
 * or failure of the abort.
 * 
 * @param {?} callback
 * @param {?} thisObject
 * @return {void}
 */
dojo.store.api.Store.Transaction.prototype.abort = function(callback, thisObject) {};

/**
 * Commits the transaction. This may throw an error if it fails. Of if the operation
 * is asynchronous, it may return a promise that represents the eventual success
 * or failure of the commit.
 * 
 * @return {void}
 */
dojo.store.api.Store.Transaction.prototype.commit = function() {};
/** @const */
dojo.store.util = {};
/**
 * @record
 * @struct
 */
dojo.store.util.QueryResults = function() {};

/* TODO: CallSignature: dojo.store.util */

/* TODO: CallSignature: dojo.store.util */
/**
 * @record
 * @struct
 */
dojo.store.util.SimpleQueryEngine = function() {};

/* TODO: CallSignature: dojo.store.util */
/**
 * @record
 * @struct
 */
dojo.date = function() {};

/**
 * Add to a Date in intervals of different size, from milliseconds to years
 * 
 * @param {!Date} date Date object to start with
 * @param {!String} interval A string representing the interval.  One of the following:"year", "month", "day", "hour", "minute", "second","millisecond", "quarter", "week", "weekday"
 * @param {number} amount How much to add to the date.
 * @return {?}
 */
dojo.date.prototype.add = function(date, interval, amount) {};

/**
 * Compare two date objects by date, time, or both.
 * Returns 0 if equal, positive if a > b, else negative.
 * 
 * @param {!Date} date1 Date object
 * @param {!Date=} date2               OptionalDate object.  If not specified, the current Date is used.
 * @param {!String=} portion               OptionalA string indicating the "date" or "time" portion of a Date object.Compares both "date" and "time" by default.  One of the following:"date", "time", "datetime"
 * @return {number}
 */
dojo.date.prototype.compare = function(date1, date2, portion) {};

/**
 * Get the difference in a specific unit of time (e.g., number of
 * months, weeks, days, etc.) between two dates, rounded to the
 * nearest integer.
 * 
 * @param {!Date} date1 Date object
 * @param {!Date=} date2               OptionalDate object.  If not specified, the current Date is used.
 * @param {!String=} interval               OptionalA string representing the interval.  One of the following:"year", "month", "day", "hour", "minute", "second","millisecond", "quarter", "week", "weekday"Defaults to "day".
 * @return {?}
 */
dojo.date.prototype.difference = function(date1, date2, interval) {};

/**
 * Returns the number of days in the month used by dateObject
 * 
 * @param {!Date} dateObject
 * @return {number}
 */
dojo.date.prototype.getDaysInMonth = function(dateObject) {};

/**
 * Get the user's time zone as provided by the browser
 * Try to get time zone info from toString or toLocaleString method of
 * the Date object -- UTC offset is not a time zone.  See
 * http://www.twinsun.com/tz/tz-link.htm Note: results may be
 * inconsistent across browsers.
 * 
 * @param {!Date} dateObject Needed because the timezone may vary with time (daylight savings)
 * @return {?}
 */
dojo.date.prototype.getTimezoneName = function(dateObject) {};

/**
 * Determines if the year of the dateObject is a leap year
 * Leap years are years with an additional day YYYY-02-29, where the
 * year number is a multiple of four with the following exception: If
 * a year is a multiple of 100, then it is only a leap year if it is
 * also a multiple of 400. For example, 1900 was not a leap year, but
 * 2000 is one.
 * 
 * @param {!Date} dateObject
 * @return {boolean}
 */
dojo.date.prototype.isLeapYear = function(dateObject) {};
/**
 * @record
 * @struct
 */
dojo.date.stamp = function() {};

/**
 * Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
 * Accepts a string formatted according to a profile of ISO8601 as defined by
 * RFC3339, except that partial input is allowed.
 * Can also process dates as specified by the W3C
 * The following combinations are valid:
 * 
 * dates only
 * yyyy
 * yyyy-MM
 * yyyy-MM-dd
 * 
 * times only, with an optional time zone appended
 * THH:mm
 * THH:mm:ss
 * THH:mm:ss.SSS
 * 
 * and "datetimes" which could be any combination of the above
 * timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
 * Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
 * input may return null.  Arguments which are out of bounds will be handled
 * by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
 * Only years between 100 and 9999 are supported.
 * 
 * @param {!String} formattedString A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
 * @param {number=} defaultTime               OptionalUsed for defaults for fields omitted in the formattedString.Uses 1970-01-01T00:00:00.0Z by default.
 * @return {?}
 */
dojo.date.stamp.prototype.fromISOString = function(formattedString, defaultTime) {};

/**
 * Format a Date object as a string according a subset of the ISO-8601 standard
 * When options.selector is omitted, output follows RFC3339
 * The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
 * Does not check bounds.  Only years between 100 and 9999 are supported.
 * 
 * @param {!Date} dateObject A Date object
 * @param {!Object=} options               OptionalAn object with the following properties:selector (String): "date" or "time" for partial formatting of the Date object.Both date and time will be formatted by default.zulu (Boolean): if true, UTC/GMT is used for a timezonemilliseconds (Boolean): if true, output milliseconds
 * @return {?}
 */
dojo.date.stamp.prototype.toISOString = function(dateObject, options) {};
/**
 * @record
 * @struct
 */
dojo.date.locale = function() {};

/**
 * Add a reference to a bundle containing localized custom formats to be
 * used by date/time formatting and parsing routines.
 * The user may add custom localized formats where the bundle has properties following the
 * same naming convention used by dojo.cldr: dateFormat-xxxx / timeFormat-xxxx
 * The pattern string should match the format used by the CLDR.
 * See dojo/date/locale.format() for details.
 * The resources must be loaded by dojo.requireLocalization() prior to use
 * 
 * @param {!String} packageName
 * @param {!String} bundleName
 * @return {void}
 */
dojo.date.locale.prototype.addCustomFormats = function(packageName, bundleName) {};

/**
 * Format a Date object as a String, using locale-specific settings.
 * Create a string from a Date object using a known localized pattern.
 * By default, this method formats both date and time from dateObject.
 * Formatting patterns are chosen appropriate to the locale.  Different
 * formatting lengths may be chosen, with "full" used by default.
 * Custom patterns may be used or registered with translations using
 * the dojo/date/locale.addCustomFormats() method.
 * Formatting patterns are implemented using the syntax described at
 * unicode.org
 * 
 * @param {!Date} dateObject the date and/or time to be formatted.  If a time only is formatted,the values in the year, month, and day fields are irrelevant.  Theopposite is true when formatting only dates.
 * @param {!Object=} options               OptionalAn object with the following properties:selector (String): choice of 'time','date' (default: date and time)formatLength (String): choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'datePattern (String): override pattern with this stringtimePattern (String): override pattern with this stringam (String): override strings for am in timespm (String): override strings for pm in timeslocale (String): override the locale used to determine formatting rulesfullYear (Boolean): (format only) use 4 digit years whenever 2 digit years are called forstrict (Boolean): (parse only) strict parsing, off by default
 * @return {?}
 */
dojo.date.locale.prototype.format = function(dateObject, options) {};

/**
 * Used to get localized strings from dojo.cldr for day or month names.
 * 
 * @param {!String} item 'months' || 'days'
 * @param {!String} type 'wide' || 'abbr' || 'narrow' (e.g. "Monday", "Mon", or "M" respectively, in English)
 * @param {!String=} context               Optional'standAlone' || 'format' (default)
 * @param {!String=} locale               Optionaloverride locale used to find the names
 * @return {?}
 */
dojo.date.locale.prototype.getNames = function(item, type, context, locale) {};

/**
 * Determines if the date falls on a weekend, according to local custom.
 * 
 * @param {!Date=} dateObject               Optional
 * @param {!String=} locale               Optional
 * @return {boolean}
 */
dojo.date.locale.prototype.isWeekend = function(dateObject, locale) {};

/**
 * Convert a properly formatted string to a primitive Date object,
 * using locale-specific settings.
 * Create a Date object from a string using a known localized pattern.
 * By default, this method parses looking for both date and time in the string.
 * Formatting patterns are chosen appropriate to the locale.  Different
 * formatting lengths may be chosen, with "full" used by default.
 * Custom patterns may be used or registered with translations using
 * the dojo/date/locale.addCustomFormats() method.
 * 
 * Formatting patterns are implemented using the syntax described at
 * unicode.org
 * When two digit years are used, a century is chosen according to a sliding
 * window of 80 years before and 20 years after present year, for both yy and yyyy patterns.
 * year < 100CE requires strict mode.
 * 
 * @param {!String} value A string representation of a date
 * @param {!Object=} options               OptionalAn object with the following properties:selector (String): choice of 'time','date' (default: date and time)formatLength (String): choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'datePattern (String): override pattern with this stringtimePattern (String): override pattern with this stringam (String): override strings for am in timespm (String): override strings for pm in timeslocale (String): override the locale used to determine formatting rulesfullYear (Boolean): (format only) use 4 digit years whenever 2 digit years are called forstrict (Boolean): (parse only) strict parsing, off by default
 * @return {?}
 */
dojo.date.locale.prototype.parse = function(value, options) {};

/**
 * Builds the regular needed to parse a localized date
 * 
 * @param {!Object=} options               OptionalAn object with the following properties:selector (String): choice of 'time','date' (default: date and time)formatLength (String): choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'datePattern (String): override pattern with this stringtimePattern (String): override pattern with this stringam (String): override strings for am in timespm (String): override strings for pm in timeslocale (String): override the locale used to determine formatting rulesfullYear (Boolean): (format only) use 4 digit years whenever 2 digit years are called forstrict (Boolean): (parse only) strict parsing, off by default
 * @return {?}
 */
dojo.date.locale.prototype.regexp = function(options) {};

/**
 * @constructor
 * @struct
 */
dojo.date.locale.__FormatOptions = function() {};

/* TODO: PropertyDeclaration: dojo.date.locale."am" */

/* TODO: PropertyDeclaration: dojo.date.locale."datePattern" */

/* TODO: PropertyDeclaration: dojo.date.locale."formatLength" */

/* TODO: PropertyDeclaration: dojo.date.locale."fullYear" */

/* TODO: PropertyDeclaration: dojo.date.locale."locale" */

/* TODO: PropertyDeclaration: dojo.date.locale."pm" */

/* TODO: PropertyDeclaration: dojo.date.locale."selector" */

/* TODO: PropertyDeclaration: dojo.date.locale."strict" */

/* TODO: PropertyDeclaration: dojo.date.locale."timePattern" */
/**
 * @record
 * @struct
 */
dojo.fx = function() {};
 /** @type {!Object} */
dojo.fx.prototype.easing;

/**
 * Chain a list of dojo/_base/fx.Animations to run in sequence
 * Return a dojo/_base/fx.Animation which will play all passed
 * dojo/_base/fx.Animation instances in sequence, firing its own
 * synthesized events simulating a single animation. (eg:
 * onEnd of this animation means the end of the chain,
 * not the individual animations within)
 * 
 * @param {!Array<!dojo._base.fx.Animation>} animations
 * @return {?}
 */
dojo.fx.prototype.chain = function(animations) {};

/**
 * Combine a list of dojo/_base/fx.Animations to run in parallel
 * Combine an array of dojo/_base/fx.Animations to run in parallel,
 * providing a new dojo/_base/fx.Animation instance encompasing each
 * animation, firing standard animation events.
 * 
 * @param {!Array<!dojo._base.fx.Animation>} animations
 * @return {?}
 */
dojo.fx.prototype.combine = function(animations) {};

/**
 * Slide a node to a new top/left position
 * Returns an animation that will slide "node"
 * defined in args Object from its current position to
 * the position defined by (args.left, args.top).
 * 
 * @param {!Object} args A hash-map of standard dojo/_base/fx.Animation constructor properties(such as easing: node: duration: and so on). Special args membersare top and left, which indicate the new position to slide to.
 * @return {?}
 */
dojo.fx.prototype.slideTo = function(args) {};

/**
 *
 * @return {void}
 */
dojo.fx.prototype.Toggler = function() {};

/**
 * Expand a node to it's natural height.
 * Returns an animation that will expand the
 * node defined in 'args' object from it's current height to
 * it's natural height (with no scrollbar).
 * Node must have no margin/border/padding.
 * 
 * @param {!Object} args A hash-map of standard dojo/_base/fx.Animation constructor properties(such as easing: node: duration: and so on)
 * @return {?}
 */
dojo.fx.prototype.wipeIn = function(args) {};

/**
 * Shrink a node to nothing and hide it.
 * Returns an animation that will shrink node defined in "args"
 * from it's current height to 1px, and then hide it.
 * 
 * @param {!Object} args A hash-map of standard dojo/_base/fx.Animation constructor properties(such as easing: node: duration: and so on)
 * @return {?}
 */
dojo.fx.prototype.wipeOut = function(args) {};

/**
 * @constructor
 * @struct
 * @param {?} args
 */
dojo.fx.Toggler = function(args) {};

/* TODO: PropertyDeclaration: dojo.fx."hideDuration" */

/* TODO: PropertyDeclaration: dojo.fx."node" */

/* TODO: PropertyDeclaration: dojo.fx."showDuration" */

/**
 * Toggle the node to hidden
 * 
 * @param {number=} delay               OptionalAmount of time to stall playing the hide animation
 * @return {?}
 */
dojo.fx.Toggler.prototype.hide = function(delay) {};

/**
 * The function that returns the dojo.Animation to hide the node
 * 
 * @param {!Object} args An object with the following properties:node (DOMNode|String): The node referenced in the animationduration (Integer, optional): Duration of the animation in milliseconds.easing (Function, optional): An easing function.
 * @return {?}
 */
dojo.fx.Toggler.prototype.hideFunc = function(args) {};

/**
 * Toggle the node to showing
 * 
 * @param {number=} delay               OptionalAmount of time to stall playing the show animation
 * @return {?}
 */
dojo.fx.Toggler.prototype.show = function(delay) {};

/**
 * The function that returns the dojo.Animation to show the node
 * 
 * @param {!Object} args An object with the following properties:node (DOMNode|String): The node referenced in the animationduration (Integer, optional): Duration of the animation in milliseconds.easing (Function, optional): An easing function.
 * @return {?}
 */
dojo.fx.Toggler.prototype.showFunc = function(args) {};
/**
 * @record
 * @struct
 */
dojo.fx.easing = function() {};

/**
 * An easing function that starts away from the target,
 * and quickly accelerates towards the end value.
 * 
 * Use caution when the easing will cause values to become
 * negative as some properties cannot be set to negative values.
 * 
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.backIn = function(n) {};

/**
 * An easing function combining the effects of backIn and backOut
 * An easing function combining the effects of backIn and backOut.
 * Use caution when the easing will cause values to become negative
 * as some properties cannot be set to negative values.
 * 
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.backInOut = function(n) {};

/**
 * An easing function that pops past the range briefly, and slowly comes back.
 * An easing function that pops past the range briefly, and slowly comes back.
 * 
 * Use caution when the easing will cause values to become negative as some
 * properties cannot be set to negative values.
 * 
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.backOut = function(n) {};

/**
 * An easing function that 'bounces' near the beginning of an Animation
 * 
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.bounceIn = function(n) {};

/**
 * An easing function that 'bounces' at the beginning and end of the Animation
 * 
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.bounceInOut = function(n) {};

/**
 * An easing function that 'bounces' near the end of an Animation
 * 
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.bounceOut = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.circIn = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.circInOut = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {?}
 */
dojo.fx.easing.prototype.circOut = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {?}
 */
dojo.fx.easing.prototype.cubicIn = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.cubicInOut = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.cubicOut = function(n) {};

/**
 * An easing function the elastically snaps from the start value
 * An easing function the elastically snaps from the start value
 * 
 * Use caution when the elasticity will cause values to become negative
 * as some properties cannot be set to negative values.
 * 
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.elasticIn = function(n) {};

/**
 * An easing function that elasticly snaps around the value, near
 * the beginning and end of the Animation.
 * An easing function that elasticly snaps around the value, near
 * the beginning and end of the Animation.
 * 
 * Use caution when the elasticity will cause values to become
 * negative as some properties cannot be set to negative values.
 * 
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.elasticInOut = function(n) {};

/**
 * An easing function that elasticly snaps around the target value,
 * near the end of the Animation
 * An easing function that elasticly snaps around the target value,
 * near the end of the Animation
 * 
 * Use caution when the elasticity will cause values to become
 * negative as some properties cannot be set to negative values.
 * 
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.elasticOut = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {?}
 */
dojo.fx.easing.prototype.expoIn = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.expoInOut = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.expoOut = function(n) {};

/**
 * A linear easing function
 * 
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.linear = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {?}
 */
dojo.fx.easing.prototype.quadIn = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.quadInOut = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.quadOut = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {?}
 */
dojo.fx.easing.prototype.quartIn = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.quartInOut = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.quartOut = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {?}
 */
dojo.fx.easing.prototype.quintIn = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.quintInOut = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.quintOut = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.sineIn = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {number}
 */
dojo.fx.easing.prototype.sineInOut = function(n) {};

/**
 *
 * @param {number=} n               Optional
 * @return {?}
 */
dojo.fx.easing.prototype.sineOut = function(n) {};
/**
 * @record
 * @struct
 */
dojo.router = function() {};

/**
 * @constructor
 * @struct
 * @param {?} kwArgs
 */
dojo.router.RouterBase = function(kwArgs) {};

/* TODO: PropertyDeclaration: dojo.router."globMatch" */

/* TODO: PropertyDeclaration: dojo.router."globReplacement" */

/* TODO: PropertyDeclaration: dojo.router."idMatch" */

/* TODO: PropertyDeclaration: dojo.router."idReplacement" */

/**
 *
 * @return {void}
 */
dojo.router.RouterBase.prototype.destroy = function() {};

/**
 * A simple pass-through to make changing the hash easy,
 * without having to require dojo/hash directly. It also
 * synchronously fires off any routes that match.
 * 
 * @param {string} path
 * @param {boolean=} replace
 * @return {?}
 */
dojo.router.RouterBase.prototype.go = function(path, replace) {};

/**
 * Registers a route to a handling callback
 * Given either a string or a regular expression, the router
 * will monitor the page's hash and respond to changes that
 * match the string or regex as provided.
 * 
 * When provided a regex for the route:
 * 
 * Matching is performed, and the resulting capture groups
 * are passed through to the callback as an array.
 * When provided a string for the route:
 * 
 * The string is parsed as a URL-like structure, like
 * "/foo/bar"
 * If any portions of that URL are prefixed with a colon
 * (:), they will be parsed out and provided to the callback
 * as properties of an object.
 * If the last piece of the URL-like structure is prefixed
 * with a star (*) instead of a colon, it will be replaced in
 * the resulting regex with a greedy (.+) match and
 * anything remaining on the hash will be provided as a
 * property on the object passed into the callback. Think of
 * it like a basic means of globbing the end of a route.
 * 
 * Registers a route to a handling callback
 * Given either a string or a regular expression, the router
 * will monitor the page's hash and respond to changes that
 * match the string or regex as provided.
 * 
 * When provided a regex for the route:
 * 
 * Matching is performed, and the resulting capture groups
 * are passed through to the callback as an array.
 * When provided a string for the route:
 * 
 * The string is parsed as a URL-like structure, like
 * "/foo/bar"
 * If any portions of that URL are prefixed with a colon
 * (:), they will be parsed out and provided to the callback
 * as properties of an object.
 * If the last piece of the URL-like structure is prefixed
 * with a star (*) instead of a colon, it will be replaced in
 * the resulting regex with a greedy (.+) match and
 * anything remaining on the hash will be provided as a
 * property on the object passed into the callback. Think of
 * it like a basic means of globbing the end of a route.
 * 
 * @param {!String|!RegExp} route A string or regular expression which will be used whenmonitoring hash changes.
 * @param {!Function} callback When the hash matches a pattern as described in the route,this callback will be executed. It will receive an eventobject that will have several properties:params: Either an array or object of properties pulledfrom the new hasholdPath: The hash in its state before the changenewPath: The new hash being shifted topreventDefault: A method that will stop hash changesfrom being actually applied to the active hash. This onlyworks if the hash change was initiated using router.go,as changes initiated more directly to the location.hashproperty will already be in placestopImmediatePropagation: When called, will stop anyfurther bound callbacks on this particular route frombeing executed. If two distinct routes are bound that aredifferent, but both happen to match the current hash insome way, this will not keep other routes from receivingnotice of the change.
 * @return {?}
 */
dojo.router.RouterBase.prototype.register = function(route, callback) {};

/**
 * Registers a route to a handling callback, except before
 * any previously registered callbacks
 * Much like the register method, registerBefore allows
 * us to register route callbacks to happen before any
 * previously registered callbacks. See the documentation for
 * register for more details and examples.
 * 
 * Registers a route to a handling callback, except before
 * any previously registered callbacks
 * Much like the register method, registerBefore allows
 * us to register route callbacks to happen before any
 * previously registered callbacks. See the documentation for
 * register for more details and examples.
 * 
 * @param {!String|!RegExp} route
 * @param {!Function} callback
 * @return {?}
 */
dojo.router.RouterBase.prototype.registerBefore = function(route, callback) {};

/**
 * This method must be called to activate the router. Until
 * startup is called, no hash changes will trigger route
 * callbacks.
 * 
 * @param {?} defaultPath
 * @return {void}
 */
dojo.router.RouterBase.prototype.startup = function(defaultPath) {};
/**
 * @record
 * @struct
 */
dojo.aspect = function() {};

/**
 * The "after" export of the aspect module is a function that can be used to attach
 * "after" advice to a method. This function will be executed after the original method
 * is executed. By default the function will be called with a single argument, the return
 * value of the original method, or the the return value of the last executed advice (if a previous one exists).
 * The fourth (optional) argument can be set to true to so the function receives the original
 * arguments (from when the original method was called) rather than the return value.
 * If there are multiple "after" advisors, they are executed in the order they were registered.
 * 
 * @param {!Object} target This is the target object
 * @param {!String} methodName This is the name of the method to attach to.
 * @param {!Function} advice This is function to be called after the original method
 * @param {boolean=} receiveArguments               OptionalIf this is set to true, the advice function receives the original arguments (from when the original mehtodwas called) rather than the return value of the original/previous method.
 * @return {?}
 */
dojo.aspect.prototype.after = function(target, methodName, advice, receiveArguments) {};

/**
 * The "around" export of the aspect module is a function that can be used to attach
 * "around" advice to a method. The advisor function is immediately executed when
 * the around() is called, is passed a single argument that is a function that can be
 * called to continue execution of the original method (or the next around advisor).
 * The advisor function should return a function, and this function will be called whenever
 * the method is called. It will be called with the arguments used to call the method.
 * Whatever this function returns will be returned as the result of the method call (unless after advise changes it).
 * 
 * @param {!Object} target This is the target object
 * @param {!String} methodName This is the name of the method to attach to.
 * @param {!Function} advice This is function to be called around the original method
 * @return {void}
 */
dojo.aspect.prototype.around = function(target, methodName, advice) {};

/**
 * The "before" export of the aspect module is a function that can be used to attach
 * "before" advice to a method. This function will be executed before the original method
 * is executed. This function will be called with the arguments used to call the method.
 * This function may optionally return an array as the new arguments to use to call
 * the original method (or the previous, next-to-execute before advice, if one exists).
 * If the before method doesn't return anything (returns undefined) the original arguments
 * will be preserved.
 * If there are multiple "before" advisors, they are executed in the reverse order they were registered.
 * 
 * @param {!Object} target This is the target object
 * @param {!String} methodName This is the name of the method to attach to.
 * @param {!Function} advice This is function to be called before the original method
 * @return {void}
 */
dojo.aspect.prototype.before = function(target, methodName, advice) {};
/**
 * @record
 * @struct
 */
dojo.back = function() {};

/**
 * adds a state object (args) to the history list.
 * To support getting back button notifications, the object
 * argument should implement a function called either "back",
 * "backButton", or "handle". The string "back" will be passed as
 * the first and only argument to this callback.
 * 
 * To support getting forward button notifications, the object
 * argument should implement a function called either "forward",
 * "forwardButton", or "handle". The string "forward" will be
 * passed as the first and only argument to this callback.
 * 
 * If you want the browser location string to change, define "changeUrl" on the object. If the
 * value of "changeUrl" is true, then a unique number will be appended to the URL as a fragment
 * identifier (http://some.domain.com/path#uniquenumber). If it is any other value that does
 * not evaluate to false, that value will be used as the fragment identifier. For example,
 * if changeUrl: 'page1', then the URL will look like: http://some.domain.com/path#page1
 * 
 * There are problems with using dojo/back with semantically-named fragment identifiers
 * ("hash values" on an URL). In most browsers it will be hard for dojo/back to know
 * distinguish a back from a forward event in those cases. For back/forward support to
 * work best, the fragment ID should always be a unique value (something using new Date().getTime()
 * for example). If you want to detect hash changes using semantic fragment IDs, then
 * consider using dojo/hash instead (in Dojo 1.4+).
 * 
 * @param {!Object} args The state object that will be added to the history list.
 * @return {void}
 */
dojo.back.prototype.addToHistory = function(args) {};

/**
 *
 * @return {?}
 */
dojo.back.prototype.getHash = function() {};

/**
 * private method. Do not call this directly.
 * 
 * @return {void}
 */
dojo.back.prototype.goBack = function() {};

/**
 * private method. Do not call this directly.
 * 
 * @return {void}
 */
dojo.back.prototype.goForward = function() {};

/**
 * Initializes the undo stack. This must be called from a
 * block that lives inside the <code>&lt;body&gt;</code> tag to prevent bugs on IE.
 * </p>
 * <p>Only call this method before the page&#39;s DOM is finished loading. Otherwise
 * it will not work. Be careful with xdomain loading or djConfig.debugAtAllCosts scenarios,
 * in order for this method to work, dojo/back will need to be part of a build layer.</p>
 * </div>
 *       </div>
 *       <div class="jsdoc-field">
 *         <div class="jsdoc-title"><a name="1_9dojo_back_setHash"></a><span class="functionIcon">setHash</span><span class="parameters">(h)</span>
 *         </div>
 *         <div class="jsdoc-inheritance">Defined by <a href="/api/1.9/dojo/back" class="jsdoc-link">dojo/back</a>
 *         </div>
 *         <div class="jsdoc-full-summary"></div>
 *         <table class="jsdoc-parameters">
 *           <tr>
 *             <th>Parameter</th>
 *             <th>Type</th>
 *             <th>Description</th>
 *           </tr>
 *           <tr>
 *             <td class="jsdoc-param-name">h</td>
 *             <td class="jsdoc-param-type">undefined</td>
 *             <td class="jsdoc-param-description">
 *             </td>
 *           </tr>
 *         </table>
 *       </div>
 *       <div class="jsdoc-field">
 *         <div class="jsdoc-title"><a name="1_9dojo_back_setInitialState"></a><span class="functionIcon">setInitialState</span><span class="parameters">(args)</span>
 *         </div>
 *         <div class="jsdoc-inheritance">Defined by <a href="/api/1.9/dojo/back" class="jsdoc-link">dojo/back</a>
 *         </div>
 *         <div class="jsdoc-full-summary"><p>Sets the state object and back callback for the very first page
 * that is loaded.
 * </p>
 * <p>It is recommended that you call this method as part of an event
 * listener that is registered via dojo/ready.</p>
 * </div>
 *         <table class="jsdoc-parameters">
 *           <tr>
 *             <th>Parameter</th>
 *             <th>Type</th>
 *             <th>Description</th>
 *           </tr>
 *           <tr>
 *             <td class="jsdoc-param-name">args</td>
 *             <td class="jsdoc-param-type">Object</td>
 *             <td class="jsdoc-param-description"><p>See the addToHistory() function for the list of valid args properties.</p>
 * 
 *             </td>
 *           </tr>
 *         </table>
 *       </div>
 *     </div>
 *   </div>
 * </div><a href="https://docs.google.com/spreadsheet/viewform?hl=en_US&amp;formkey=dFlDcHEyaHMwbEd4MFBObkNrX0E1MFE6MQ&amp;entry_0=/api/1.9/dojo/back" class="feedback">Error in the documentation? Can't find what you are looking for? Let us know!</a>
 * @return {void}
 */
dojo.back.prototype.init = function() {};
/**
 * @record
 * @struct
 */
dojo.colors = function() {};
 /** @type {!Object} */
dojo.colors.prototype.ThreeD;
/**
 * @record
 * @struct
 */
dojo.currency = function() {};

/**
 * Format a Number as a currency, using locale-specific settings
 * Create a string from a Number using a known, localized pattern.
 * Formatting patterns
 * appropriate to the locale are chosen from the CLDR
 * as well as the appropriate symbols and delimiters and number of decimal places.
 * 
 * @param {number} value the number to be formatted.
 * @param {!dojo.currency.__FormatOptions=} options               Optional
 * @return {?}
 */
dojo.currency.prototype.format = function(value, options) {};

/**
 *
 * @param {!String} expression
 * @param {!Object=} options               OptionalAn object with the following properties:type (String, optional): Should not be set.  Value is assumed to be currency.currency (String, optional): an ISO4217 currency code, a three letter sequence like "USD".For use with dojo.currency only.symbol (String, optional): localized currency symbol. The default will be looked up in table of supported currencies in dojo.cldrA ISO4217 currency code will be used if not found.places (Number, optional): fixed number of decimal places to accept.  The default is determined based on which currency is used.fractional (Boolean|Array, optional): Whether to include the fractional portion, where the number of decimal places are implied by the currencyor explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.By default for currencies, it the fractional portion is optional.pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.  Literal characters in patterns are not supported.locale (String, optional): override the locale used to determine formatting rulesstrict (Boolean, optional): strict parsing, false by default.  Strict parsing requires input as produced by the format() method.Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
 * @return {?}
 */
dojo.currency.prototype.parse = function(expression, options) {};

/**
 *
 * @param {!Object=} options               OptionalAn object with the following properties:pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.type (String, optional): choose a format type based on the locale from the following:decimal, scientific (not yet supported), percent, currency. decimal by default.locale (String, optional): override the locale used to determine formatting rulesstrict (Boolean, optional): strict parsing, false by default.  Strict parsing requires input as produced by the format() method.Non-strict is more permissive, e.g. flexible on white space, omitting thousands separatorsplaces (Number|String, optional): number of decimal places to accept: Infinity, a positive number, ora range "n,m".  Defined by pattern or Infinity if pattern not provided.
 * @return {?}
 */
dojo.currency.prototype.regexp = function(options) {};

/**
 * @constructor
 * @struct
 */
dojo.currency.__FormatOptions = function() {};

/* TODO: PropertyDeclaration: dojo.currency."currency" */

/* TODO: PropertyDeclaration: dojo.currency."fractional" */

/* TODO: PropertyDeclaration: dojo.currency."locale" */

/* TODO: PropertyDeclaration: dojo.currency."pattern" */

/* TODO: PropertyDeclaration: dojo.currency."places" */

/* TODO: PropertyDeclaration: dojo.currency."round" */

/* TODO: PropertyDeclaration: dojo.currency."symbol" */

/* TODO: PropertyDeclaration: dojo.currency."type" */

/**
 * @constructor
 * @struct
 */
dojo.currency.__ParseOptions = function() {};

/* TODO: PropertyDeclaration: dojo.currency."currency" */

/* TODO: PropertyDeclaration: dojo.currency."fractional" */

/* TODO: PropertyDeclaration: dojo.currency."locale" */

/* TODO: PropertyDeclaration: dojo.currency."pattern" */

/* TODO: PropertyDeclaration: dojo.currency."places" */

/* TODO: PropertyDeclaration: dojo.currency."strict" */

/* TODO: PropertyDeclaration: dojo.currency."symbol" */

/* TODO: PropertyDeclaration: dojo.currency."type" */
/**
 * @record
 * @struct
 */
dojo.dom = function() {};

/**
 * Returns DOM node with matching id attribute or falsy value (ex: null or undefined)
 * if not found.  If id is a DomNode, this function is a no-op.
 * 
 * Returns DOM node with matching id attribute or falsy value (ex: null or undefined)
 * if not found.  If id is a DomNode, this function is a no-op.
 * 
 * @param {!String|!HTMLElement} id A string to match an HTML id attribute or a reference to a DOM Node
 * @param {!HTMLDocument=} doc               OptionalDocument to work in. Defaults to the current value ofdojo/_base/window.doc.  Can be used to retrievenode references from other documents.
 * @return {?}
 */
dojo.dom.prototype.byId = function(id, doc) {};

/**
 * Returns true if node is a descendant of ancestor
 * 
 * Returns true if node is a descendant of ancestor
 * 
 * Returns true if node is a descendant of ancestor
 * 
 * Returns true if node is a descendant of ancestor
 * 
 * @param {!HTMLElement|!String} node string id or node reference to test
 * @param {!HTMLElement|!String} ancestor string id or node reference of potential parent to test against
 * @return {boolean}
 */
dojo.dom.prototype.isDescendant = function(node, ancestor) {};

/**
 *
 * @param {?} node
 * @param {?} selectable
 * @return {void}
 */
dojo.dom.prototype.setSelectable = function(node, selectable) {};
/**
 * @record
 * @struct
 */
dojo.dom_attr = function() {};

/**
 * Gets an attribute on an HTML element.
 * Handles normalized getting of attributes on DOM Nodes.
 * 
 * Gets an attribute on an HTML element.
 * Handles normalized getting of attributes on DOM Nodes.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to get the attribute on
 * @param {!String} name the name of the attribute to get.
 * @return {?}
 */
dojo.dom_attr.prototype.get = function(node, name) {};

/**
 * Returns an effective value of a property or an attribute.
 * 
 * Returns an effective value of a property or an attribute.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to remove the attribute from
 * @param {!String} name the name of the attribute
 * @return {?}
 */
dojo.dom_attr.prototype.getNodeProp = function(node, name) {};

/**
 * Returns true if the requested attribute is specified on the
 * given element, and false otherwise.
 * 
 * Returns true if the requested attribute is specified on the
 * given element, and false otherwise.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to check
 * @param {!String} name the name of the attribute
 * @return {boolean}
 */
dojo.dom_attr.prototype.has = function(node, name) {};

/**
 * Removes an attribute from an HTML element.
 * 
 * Removes an attribute from an HTML element.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to remove the attribute from
 * @param {!String} name the name of the attribute to remove
 * @return {void}
 */
dojo.dom_attr.prototype.remove = function(node, name) {};

/**
 * Sets an attribute on an HTML element.
 * Handles normalized setting of attributes on DOM Nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets an attribute on an HTML element.
 * Handles normalized setting of attributes on DOM Nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets an attribute on an HTML element.
 * Handles normalized setting of attributes on DOM Nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets an attribute on an HTML element.
 * Handles normalized setting of attributes on DOM Nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to set the attribute on
 * @param {!String|!Object} name the name of the attribute to set, or a hash of key-value pairs to set.
 * @param {!String=} value               Optionalthe value to set for the attribute, if the name is a string.
 * @return {?}
 */
dojo.dom_attr.prototype.set = function(node, name, value) {};
/**
 * @record
 * @struct
 */
dojo.dom_class = function() {};

/**
 * Adds the specified classes to the end of the class list on the
 * passed node. Will not re-apply duplicate classes.
 * 
 * Adds the specified classes to the end of the class list on the
 * passed node. Will not re-apply duplicate classes.
 * 
 * Adds the specified classes to the end of the class list on the
 * passed node. Will not re-apply duplicate classes.
 * 
 * Adds the specified classes to the end of the class list on the
 * passed node. Will not re-apply duplicate classes.
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to add a class string too
 * @param {!String|!Array<?>} classStr A String class name to add, or several space-separated class names,or an array of class names.
 * @return {void}
 */
dojo.dom_class.prototype.add = function(node, classStr) {};

/**
 * Returns whether or not the specified classes are a portion of the
 * class list currently applied to the node.
 * 
 * Returns whether or not the specified classes are a portion of the
 * class list currently applied to the node.
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to check the class for.
 * @param {!String} classStr A string class name to look for.
 * @return {boolean}
 */
dojo.dom_class.prototype.contains = function(node, classStr) {};

/**
 * Removes the specified classes from node. No contains()
 * check is required.
 * 
 * Removes the specified classes from node. No contains()
 * check is required.
 * 
 * Removes the specified classes from node. No contains()
 * check is required.
 * 
 * Removes the specified classes from node. No contains()
 * check is required.
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to remove the class from.
 * @param {!String|!Array<?>=} classStr               OptionalAn optional String class name to remove, or several space-separatedclass names, or an array of class names. If omitted, all class nameswill be deleted.
 * @return {void}
 */
dojo.dom_class.prototype.remove = function(node, classStr) {};

/**
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to remove the class from.
 * @param {!String|!Array<?>} addClassStr A String class name to add, or several space-separated class names,or an array of class names.
 * @param {!String|!Array<?>=} removeClassStr               OptionalA String class name to remove, or several space-separated class names,or an array of class names.
 * @return {void}
 */
dojo.dom_class.prototype.replace = function(node, addClassStr, removeClassStr) {};

/**
 * Adds a class to node if not present, or removes if present.
 * Pass a boolean condition if you want to explicitly add or remove.
 * Returns the condition that was specified directly or indirectly.
 * 
 * Adds a class to node if not present, or removes if present.
 * Pass a boolean condition if you want to explicitly add or remove.
 * Returns the condition that was specified directly or indirectly.
 * 
 * Adds a class to node if not present, or removes if present.
 * Pass a boolean condition if you want to explicitly add or remove.
 * Returns the condition that was specified directly or indirectly.
 * 
 * Adds a class to node if not present, or removes if present.
 * Pass a boolean condition if you want to explicitly add or remove.
 * Returns the condition that was specified directly or indirectly.
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to toggle a class string
 * @param {!String|!Array<?>} classStr A String class name to toggle, or several space-separated class names,or an array of class names.
 * @param {boolean=} condition               OptionalIf passed, true means to add the class, false means to remove.Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
 * @return {boolean}
 */
dojo.dom_class.prototype.toggle = function(node, classStr, condition) {};
/**
 * @record
 * @struct
 */
dojo.dom_form = function() {};

/**
 * Serialize a form field to a JavaScript object.
 * Returns the value encoded in a form field as
 * as a string or an array of strings. Disabled form elements
 * and unchecked radio and checkboxes are skipped. Multi-select
 * elements are returned as an array of string values.
 * 
 * Serialize a form field to a JavaScript object.
 * Returns the value encoded in a form field as
 * as a string or an array of strings. Disabled form elements
 * and unchecked radio and checkboxes are skipped. Multi-select
 * elements are returned as an array of string values.
 * 
 * @param {!HTMLElement|!String} inputNode
 * @return {!Object}
 */
dojo.dom_form.prototype.fieldToObject = function(inputNode) {};

/**
 * Create a serialized JSON string from a form node or string
 * ID identifying the form to serialize
 * 
 * Create a serialized JSON string from a form node or string
 * ID identifying the form to serialize
 * 
 * @param {!HTMLElement|!String} formNode
 * @param {boolean=} prettyPrint               Optional
 * @return {!String}
 */
dojo.dom_form.prototype.toJson = function(formNode, prettyPrint) {};

/**
 * Serialize a form node to a JavaScript object.
 * Returns the values encoded in an HTML form as
 * string properties in an object which it then returns. Disabled form
 * elements, buttons, and other non-value form elements are skipped.
 * Multi-select elements are returned as an array of string values.
 * 
 * Serialize a form node to a JavaScript object.
 * Returns the values encoded in an HTML form as
 * string properties in an object which it then returns. Disabled form
 * elements, buttons, and other non-value form elements are skipped.
 * Multi-select elements are returned as an array of string values.
 * 
 * @param {!HTMLElement|!String} formNode
 * @return {!Object}
 */
dojo.dom_form.prototype.toObject = function(formNode) {};

/**
 * Returns a URL-encoded string representing the form passed as either a
 * node or string ID identifying the form to serialize
 * 
 * Returns a URL-encoded string representing the form passed as either a
 * node or string ID identifying the form to serialize
 * 
 * @param {!HTMLElement|!String} formNode
 * @return {!String}
 */
dojo.dom_form.prototype.toQuery = function(formNode) {};
/**
 * @record
 * @struct
 */
dojo.dom_construct = function() {};

/**
 * Create an element, allowing for optional attribute decoration
 * and placement.
 * A DOM Element creation function. A shorthand method for creating a node or
 * a fragment, and allowing for a convenient optional attribute setting step,
 * as well as an optional DOM placement reference.
 * 
 * Attributes are set by passing the optional object through dojo.setAttr.
 * See dojo.setAttr for noted caveats and nuances, and API if applicable.
 * 
 * Placement is done via dojo.place, assuming the new node to be the action
 * node, passing along the optional reference node and position.
 * 
 * Create an element, allowing for optional attribute decoration
 * and placement.
 * A DOM Element creation function. A shorthand method for creating a node or
 * a fragment, and allowing for a convenient optional attribute setting step,
 * as well as an optional DOM placement reference.
 * 
 * Attributes are set by passing the optional object through dojo.setAttr.
 * See dojo.setAttr for noted caveats and nuances, and API if applicable.
 * 
 * Placement is done via dojo.place, assuming the new node to be the action
 * node, passing along the optional reference node and position.
 * 
 * Create an element, allowing for optional attribute decoration
 * and placement.
 * A DOM Element creation function. A shorthand method for creating a node or
 * a fragment, and allowing for a convenient optional attribute setting step,
 * as well as an optional DOM placement reference.
 * 
 * Attributes are set by passing the optional object through dojo.setAttr.
 * See dojo.setAttr for noted caveats and nuances, and API if applicable.
 * 
 * Placement is done via dojo.place, assuming the new node to be the action
 * node, passing along the optional reference node and position.
 * 
 * Create an element, allowing for optional attribute decoration
 * and placement.
 * A DOM Element creation function. A shorthand method for creating a node or
 * a fragment, and allowing for a convenient optional attribute setting step,
 * as well as an optional DOM placement reference.
 * 
 * Attributes are set by passing the optional object through dojo.setAttr.
 * See dojo.setAttr for noted caveats and nuances, and API if applicable.
 * 
 * Placement is done via dojo.place, assuming the new node to be the action
 * node, passing along the optional reference node and position.
 * 
 * @param {!HTMLElement|!String} tag A string of the element to create (eg: "div", "a", "p", "li", "script", "br"),or an existing DOM node to process.
 * @param {!Object} attrs An object-hash of attributes to set on the newly created node.Can be null, if you don't want to set any attributes/styles.See: dojo.setAttr for a description of available attributes.
 * @param {!HTMLElement|!String=} refNode               OptionalOptional reference node. Used by dojo.place to place the newly creatednode somewhere in the dom relative to refNode. Can be a DomNode referenceor String ID of a node.
 * @param {!String=} pos               OptionalOptional positional reference. Defaults to "last" by way of dojo.place,though can be set to "first","after","before","last", "replace" or "only"to further control the placement of the new node relative to the refNode.'refNode' is required if a 'pos' is specified.
 * @return {?}
 */
dojo.dom_construct.prototype.create = function(tag, attrs, refNode, pos) {};

/**
 * Removes a node from its parent, clobbering it and all of its
 * children.
 * Removes a node from its parent, clobbering it and all of its
 * children. Function only works with DomNodes, and returns nothing.
 * 
 * Removes a node from its parent, clobbering it and all of its
 * children.
 * Removes a node from its parent, clobbering it and all of its
 * children. Function only works with DomNodes, and returns nothing.
 * 
 * @param {!HTMLElement|!String} node A String ID or DomNode reference of the element to be destroyed
 * @return {void}
 */
dojo.dom_construct.prototype.destroy = function(node) {};

/**
 * safely removes all children of the node.
 * 
 * safely removes all children of the node.
 * 
 * @param {!HTMLElement|!String} node a reference to a DOM node or an id.
 * @return {void}
 */
dojo.dom_construct.prototype.empty = function(node) {};

/**
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * @param {!HTMLElement|!String} node id or node reference, or HTML fragment starting with "<" to place relative to refNode
 * @param {!HTMLElement|!String} refNode id or node reference to use as basis for placement
 * @param {!String|number=} position               Optionalstring noting the position of node relative to refNode or anumber indicating the location in the childNodes collection of refNode.Accepted string values are:beforeafterreplaceonlyfirstlast"first" and "last" indicate positions as children of refNode, "replace" replaces refNode,"only" replaces all children.  position defaults to "last" if not specified
 * @return {!HTMLElement}
 */
dojo.dom_construct.prototype.place = function(node, refNode, position) {};

/**
 * instantiates an HTML fragment returning the corresponding DOM.
 * 
 * @param {!String} frag the HTML fragment
 * @param {!HTMLDocument=} doc               Optionaloptional document to use when creating DOM nodes, defaults todojo/_base/window.doc if not specified.
 * @return {?}
 */
dojo.dom_construct.prototype.toDom = function(frag, doc) {};
/**
 * @record
 * @struct
 */
dojo.dom_prop = function() {};
 /** @type {!Object} */
dojo.dom_prop.prototype.names;

/**
 * Gets a property on an HTML element.
 * Handles normalized getting of properties on DOM nodes.
 * 
 * Gets a property on an HTML element.
 * Handles normalized getting of properties on DOM nodes.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to get the property on
 * @param {!String} name the name of the property to get.
 * @return {?}
 */
dojo.dom_prop.prototype.get = function(node, name) {};

/**
 * Sets a property on an HTML element.
 * Handles normalized setting of properties on DOM nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets a property on an HTML element.
 * Handles normalized setting of properties on DOM nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets a property on an HTML element.
 * Handles normalized setting of properties on DOM nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets a property on an HTML element.
 * Handles normalized setting of properties on DOM nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to set the property on
 * @param {!String|!Object} name the name of the property to set, or a hash object to setmultiple properties at once.
 * @param {!String=} value               OptionalThe value to set for the property
 * @return {?}
 */
dojo.dom_prop.prototype.set = function(node, name, value) {};
/**
 * @record
 * @struct
 */
dojo.dom_prop.names = function() {};
 /** @type {string} */
dojo.dom_prop.names.prototype.class;
 /** @type {string} */
dojo.dom_prop.names.prototype.colspan;
 /** @type {string} */
dojo.dom_prop.names.prototype.for;
 /** @type {string} */
dojo.dom_prop.names.prototype.frameborder;
 /** @type {string} */
dojo.dom_prop.names.prototype.readonly;
 /** @type {string} */
dojo.dom_prop.names.prototype.rowspan;
 /** @type {string} */
dojo.dom_prop.names.prototype.tabindex;
 /** @type {string} */
dojo.dom_prop.names.prototype.valuetype;
/**
 * @record
 * @struct
 */
dojo.dom_style = function() {};

/**
 *
 *
 *
 *
 * @param {!HTMLElement|!String} node
 * @param {!String|!Object} name
 * @return {?}
 */
dojo.dom_style.prototype.get = function(node, name) {};

/**
 * Returns a "computed style" object.
 * Gets a "computed style" object which can be used to gather
 * information about the current state of the rendered node.
 * 
 * Note that this may behave differently on different browsers.
 * Values may have different formats and value encodings across
 * browsers.
 * 
 * Note also that this method is expensive.  Wherever possible,
 * reuse the returned object.
 * 
 * Use the dojo/dom-style.get() method for more consistent (pixelized)
 * return values.
 * 
 * @param {!HTMLElement} node A reference to a DOM node. Does NOT support taking anID string for speed reasons.
 * @return {void}
 */
dojo.dom_style.prototype.getComputedStyle = function(node) {};

/**
 *
 *
 *
 *
 * @param {!HTMLElement|!String} node
 * @param {!String|!Object} name
 * @param {!String=} value               Optional
 * @return {?}
 */
dojo.dom_style.prototype.set = function(node, name, value) {};

/**
 * converts style value to pixels on IE or return a numeric value.
 * 
 * @param {!HTMLElement} node
 * @param {!String} value
 * @return {number}
 */
dojo.dom_style.prototype.toPixelValue = function(node, value) {};
/**
 * @record
 * @struct
 */
dojo.dom_geometry = function() {};
 /** @type {string} */
dojo.dom_geometry.prototype.boxModel;

/**
 * Returns an object with {node, x, y} with corresponding offsets.
 * 
 * @param {!HTMLDocument=} doc               OptionalOptional document to query.   If unspecified, use win.doc.
 * @return {!Object}
 */
dojo.dom_geometry.prototype.docScroll = function(doc) {};

/**
 * In RTL direction, scrollLeft should be a negative value, but IE
 * returns a positive one. All codes using documentElement.scrollLeft
 * must call this function to fix this error, otherwise the position
 * will offset to right when there is a horizontal scrollbar.
 * 
 * @param {number} scrollLeft
 * @param {!HTMLDocument=} doc               OptionalOptional document to query.   If unspecified, use win.doc.
 * @return {number}
 */
dojo.dom_geometry.prototype.fixIeBiDiScrollLeft = function(scrollLeft, doc) {};

/**
 * returns an object with properties useful for noting the border
 * dimensions.
 * l/t/r/b = the sum of left/top/right/bottom border (respectively)
 * w = the sum of the left and right border
 * h = the sum of the top and bottom border
 * The w/h are used for calculating boxes.
 * Normally application code will not need to invoke this
 * directly, and will use the ...box... functions instead.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo.dom_geometry.prototype.getBorderExtents = function(node, computedStyle) {};

/**
 * Returns an object that encodes the width, height, left and top
 * positions of the node's content box, irrespective of the
 * current box model.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo.dom_geometry.prototype.getContentBox = function(node, computedStyle) {};

/**
 * returns the offset in x and y from the document body to the
 * visual edge of the page for IE
 * The following values in IE contain an offset:
 * 
 * event.clientX
 * event.clientY
 * node.getBoundingClientRect().left
 * node.getBoundingClientRect().top
 * But other position related values do not contain this offset,
 * 
 * such as node.offsetLeft, node.offsetTop, node.style.left and
 * node.style.top. The offset is always (2, 2) in LTR direction.
 * When the body is in RTL direction, the offset counts the width
 * of left scroll bar's width.  This function computes the actual
 * offset.
 * 
 * @param {!HTMLDocument=} doc               OptionalOptional document to query.   If unspecified, use win.doc.
 * @return {!Object}
 */
dojo.dom_geometry.prototype.getIeDocumentElementOffset = function(doc) {};

/**
 * returns an object that encodes the width, height, left and top
 * positions of the node's margin box.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo.dom_geometry.prototype.getMarginBox = function(node, computedStyle) {};

/**
 * returns object with properties useful for box fitting with
 * regards to box margins (i.e., the outer-box).
 * 
 * l/t = marginLeft, marginTop, respectively
 * w = total width, margin inclusive
 * h = total height, margin inclusive
 * The w/h are used for calculating boxes.
 * Normally application code will not need to invoke this
 * directly, and will use the ...box... functions instead.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo.dom_geometry.prototype.getMarginExtents = function(node, computedStyle) {};

/**
 * returns an object that encodes the width and height of
 * the node's margin box
 * 
 * returns an object that encodes the width and height of
 * the node's margin box
 * 
 * @param {!HTMLElement|!String} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo.dom_geometry.prototype.getMarginSize = function(node, computedStyle) {};

/**
 * Returns object with properties useful for box fitting with
 * regards to padding.
 * l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
 * w = the sum of the left and right padding and border
 * h = the sum of the top and bottom padding and border
 * The w/h are used for calculating boxes.
 * Normally application code will not need to invoke this
 * directly, and will use the ...box... functions instead.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo.dom_geometry.prototype.getPadBorderExtents = function(node, computedStyle) {};

/**
 * Returns object with special values specifically useful for node
 * fitting.
 * Returns an object with w, h, l, t properties:
 * 
 * l/t/r/b = left/top/right/bottom padding (respectively)
 * w = the total of the left and right padding
 * h = the total of the top and bottom padding
 * If 'node' has position, l/t forms the origin for child nodes.
 * 
 * The w/h are used for calculating boxes.
 * Normally application code will not need to invoke this
 * directly, and will use the ...box... functions instead.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo.dom_geometry.prototype.getPadExtents = function(node, computedStyle) {};

/**
 * Returns true if the current language is left-to-right, and false otherwise.
 * 
 * @param {!HTMLDocument=} doc               OptionalOptional document to query.   If unspecified, use win.doc.
 * @return {boolean}
 */
dojo.dom_geometry.prototype.isBodyLtr = function(doc) {};

/**
 * Normalizes the geometry of a DOM event, normalizing the pageX, pageY,
 * offsetX, offsetY, layerX, and layerX properties
 * 
 * @param {!Object} event
 * @return {void}
 */
dojo.dom_geometry.prototype.normalizeEvent = function(event) {};

/**
 * Gets the position and size of the passed element relative to
 * the viewport (if includeScroll==false), or relative to the
 * document root (if includeScroll==true).
 * Returns an object of the form:
 * { x: 100, y: 300, w: 20, h: 15 }.
 * If includeScroll==true, the x and y values will include any
 * document offsets that may affect the position relative to the
 * viewport.
 * Uses the border-box model (inclusive of border and padding but
 * not margin).  Does not act as a setter.
 * 
 * Gets the position and size of the passed element relative to
 * the viewport (if includeScroll==false), or relative to the
 * document root (if includeScroll==true).
 * Returns an object of the form:
 * { x: 100, y: 300, w: 20, h: 15 }.
 * If includeScroll==true, the x and y values will include any
 * document offsets that may affect the position relative to the
 * viewport.
 * Uses the border-box model (inclusive of border and padding but
 * not margin).  Does not act as a setter.
 * 
 * @param {!HTMLElement|!String} node
 * @param {boolean=} includeScroll               Optional
 * @return {{w: number, h: number, x: number, y: number}}
 */
dojo.dom_geometry.prototype.position = function(node, includeScroll) {};

/**
 * Sets the size of the node's contents, irrespective of margins,
 * padding, or borders.
 * 
 * @param {!HTMLElement} node
 * @param {!Object} box hash with optional "w", and "h" properties for "width", and "height"respectively. All specified properties should have numeric values in whole pixels.
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {void}
 */
dojo.dom_geometry.prototype.setContentSize = function(node, box, computedStyle) {};

/**
 * sets the size of the node's margin box and placement
 * (left/top), irrespective of box model. Think of it as a
 * passthrough to setBox that handles box-model vagaries for
 * you.
 * 
 * @param {!HTMLElement} node
 * @param {!Object} box hash with optional "l", "t", "w", and "h" properties for "left", "right", "width", and "height"respectively. All specified properties should have numeric values in whole pixels.
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {void}
 */
dojo.dom_geometry.prototype.setMarginBox = function(node, box, computedStyle) {};
/**
 * @record
 * @struct
 */
dojo.gears = function() {};
 /** @type {!Object} */
dojo.gears.prototype.available;
/**
 * @record
 * @struct
 */
dojo.gears.available = function() {};
/**
 * @record
 * @struct
 */
dojo.html = function() {};

/**
 * inserts (replaces) the given content into the given node. dojo/dom-construct.place(cont, node, "only")
 * may be a better choice for simple HTML insertion.
 * Unless you need to use the params capabilities of this method, you should use
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct..place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct..place does not handle NodeList insertions
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct.place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct.place does not handle NodeList insertions
 * or the other capabilities as defined by the params object for this method.
 * 
 * inserts (replaces) the given content into the given node. dojo/dom-construct.place(cont, node, "only")
 * may be a better choice for simple HTML insertion.
 * Unless you need to use the params capabilities of this method, you should use
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct..place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct..place does not handle NodeList insertions
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct.place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct.place does not handle NodeList insertions
 * or the other capabilities as defined by the params object for this method.
 * 
 * inserts (replaces) the given content into the given node. dojo/dom-construct.place(cont, node, "only")
 * may be a better choice for simple HTML insertion.
 * Unless you need to use the params capabilities of this method, you should use
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct..place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct..place does not handle NodeList insertions
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct.place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct.place does not handle NodeList insertions
 * or the other capabilities as defined by the params object for this method.
 * 
 * @param {!HTMLElement} node the parent element that will receive the content
 * @param {!String|!HTMLElement|!dojo.NodeList} cont the content to be set on the parent element.This can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes
 * @param {!Object=} params               OptionalOptional flags/properties to configure the content-setting. See dojo/html/_ContentSetter
 * @return {?}
 */
dojo.html.prototype.set = function(node, cont, params) {};

/**
 * @constructor
 * @struct
 * @param {!Object} params
 * @param {!String} node
 */
dojo.html._ContentSetter = function(params, node) {};

/* TODO: PropertyDeclaration: dojo.html."cleanContent" */

/* TODO: PropertyDeclaration: dojo.html."content" */

/* TODO: PropertyDeclaration: dojo.html."extractContent" */

/* TODO: PropertyDeclaration: dojo.html."id" */

/* TODO: PropertyDeclaration: dojo.html."node" */

/* TODO: PropertyDeclaration: dojo.html."parseContent" */

/* TODO: PropertyDeclaration: dojo.html."parserScope" */

/* TODO: PropertyDeclaration: dojo.html."startup" */

/**
 * cleanly empty out existing content
 * 
 * @return {void}
 */
dojo.html._ContentSetter.prototype.empty = function() {};

/**
 * front-end to the set-content sequence
 * 
 * front-end to the set-content sequence
 * 
 * front-end to the set-content sequence
 * 
 * @param {!String|!HTMLElement|!dojo.NodeList} cont               OptionalAn html string, node or enumerable list of nodes for insertion into the domIf not provided, the object's content property will be used
 * @param {!Object=} params               Optional
 * @return {?}
 */
dojo.html._ContentSetter.prototype.set = function(cont, params) {};

/**
 * sets the content on the node
 * 
 * @return {void}
 */
dojo.html._ContentSetter.prototype.setContent = function() {};

/**
 * manually reset the Setter instance if its being re-used for example for another set()
 * tearDown() is not called automatically.
 * In normal use, the Setter instance properties are simply allowed to fall out of scope
 * but the tearDown method can be called to explicitly reset this instance.
 * 
 * @return {void}
 */
dojo.html._ContentSetter.prototype.tearDown = function() {};

/**
 * Called after instantiation, but before set();
 * It allows modification of any of the object properties -
 * including the node and content provided - before the set operation actually takes place
 * This default implementation checks for cleanContent and extractContent flags to
 * optionally pre-process html string content
 * 
 * @return {?}
 */
dojo.html._ContentSetter.prototype.onBegin = function() {};

/**
 *
 * @param {?} err
 * @return {!String}
 */
dojo.html._ContentSetter.prototype.onContentError = function(err) {};

/**
 * Called after set(), when the new content has been pushed into the node
 * It provides an opportunity for post-processing before handing back the node to the caller
 * This default implementation checks a parseContent flag to optionally run the dojo parser over the new content
 * 
 * @return {?}
 */
dojo.html._ContentSetter.prototype.onEnd = function() {};

/**
 *
 * @param {?} err
 * @return {!String}
 */
dojo.html._ContentSetter.prototype.onExecError = function(err) {};
/**
 * @record
 * @struct
 */
dojo.io_query = function() {};

/**
 * takes a name/value mapping object and returns a string representing
 * a URL-encoded version of that object.
 * 
 * @param {!Object} map
 * @return {?}
 */
dojo.io_query.prototype.objectToQuery = function(map) {};

/**
 * Create an object representing a de-serialized query section of a
 * URL. Query keys with multiple values are returned in an array.
 * 
 * @param {!String} str
 * @return {!Object}
 */
dojo.io_query.prototype.queryToObject = function(str) {};
/**
 * @record
 * @struct
 */
dojo.i18n = function() {};
 /** @type {!Object} */
dojo.i18n.prototype.cache;
 /** @type {boolean} */
dojo.i18n.prototype.dynamic;
 /** @type {!Array<?>} */
dojo.i18n.prototype.unitTests;

/**
 *
 * @param {?} moduleName
 * @param {?} bundleName
 * @param {?} locale
 * @return {!String}
 */
dojo.i18n.prototype.getL10nName = function(moduleName, bundleName, locale) {};

/**
 *
 * @param {?} moduleName
 * @param {?} bundleName
 * @param {?} locale
 * @return {?}
 */
dojo.i18n.prototype.getLocalization = function(moduleName, bundleName, locale) {};

/**
 * id is in one of the following formats
 * 
 * /nls/
 *  => load the bundle, localized to config.locale; load all bundles localized to
 *  config.extraLocale (if any); return the loaded bundle localized to config.locale.
 * /nls//
 *  => load then return the bundle localized to
 * preload/nls//
 *  => for config.locale and all config.extraLocale, load all bundles found
 *  in the best-matching bundle rollup. A value of 1 is returned, which
 *  is meaningless other than to say the plugin is executing the requested
 *  preloads
 * 
 * In cases 1 and 2,  is always normalized to an absolute module id upon entry; see
 * normalize. In case 3, it  is assumed to be absolute; this is arranged by the builder.
 * 
 * To load a bundle means to insert the bundle into the plugin's cache and publish the bundle
 * value to the loader. Given , , and a particular , the cache key
 * 
 * <path>/nls/<bundle>/<locale>
 * will hold the value. Similarly, then plugin will publish this value to the loader by
 * 
 * define("<path>/nls/<bundle>/<locale>", <bundle-value>);
 * Given this algorithm, other machinery can provide fast load paths be preplacing
 * values in the plugin's cache, which is public. When a load is demanded the
 * cache is inspected before starting any loading. Explicitly placing values in the plugin
 * cache is an advanced/experimental feature that should not be needed; use at your own risk.
 * 
 * For the normal AMD algorithm, the root bundle is loaded first, which instructs the
 * plugin what additional localized bundles are required for a particular locale. These
 * additional locales are loaded and a mix of the root and each progressively-specific
 * locale is returned. For example:
 * 
 * The client demands "dojo/i18n!some/path/nls/someBundle
 * The loader demands load(some/path/nls/someBundle)
 * This plugin require's "some/path/nls/someBundle", which is the root bundle.
 * Assuming config.locale is "ab-cd-ef" and the root bundle indicates that localizations
 * are available for "ab" and "ab-cd-ef" (note the missing "ab-cd", then the plugin
 * requires "some/path/nls/ab/someBundle" and "some/path/nls/ab-cd-ef/someBundle"
 * Upon receiving all required bundles, the plugin constructs the value of the bundle
 * ab-cd-ef as...
 *  mixin(mixin(mixin({}, require("some/path/nls/someBundle"),
 *      require("some/path/nls/ab/someBundle")),
 *      require("some/path/nls/ab-cd-ef/someBundle"));
 * 
 * This value is inserted into the cache and published to the loader at the
 * key/module-id some/path/nls/someBundle/ab-cd-ef.
 * 
 * The special preload signature (case 3) instructs the plugin to stop servicing all normal requests
 * (further preload requests will be serviced) until all ongoing preloading has completed.
 * 
 * The preload signature instructs the plugin that a special rollup module is available that contains
 * one or more flattened, localized bundles. The JSON array of available locales indicates which locales
 * are available. Here is an example:
 * 
 * *preload*some/path/nls/someModule*["root", "ab", "ab-cd-ef"]
 * This indicates the following rollup modules are available:
 * 
 * some/path/nls/someModule_ROOT
 * some/path/nls/someModule_ab
 * some/path/nls/someModule_ab-cd-ef
 * Each of these modules is a normal AMD module that contains one or more flattened bundles in a hash.
 * For example, assume someModule contained the bundles some/bundle/path/someBundle and
 * some/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:
 * 
 * define({
 *     some/bundle/path/someBundle:<value of someBundle, flattened with respect to locale ab>,
 *     some/bundle/path/someOtherBundle:<value of someOtherBundle, flattened with respect to locale ab>,
 * });
 * E.g., given this design, preloading for locale=="ab" can execute the following algorithm:
 * 
 * require(["some/path/nls/someModule_ab"], function(rollup){
 *     for(var p in rollup){
 *         var id = p + "/ab",
 *         cache[id] = rollup[p];
 *         define(id, rollup[p]);
 *     }
 * });
 * Similarly, if "ab-cd" is requested, the algorithm can determine that "ab" is the best available and
 * load accordingly.
 * 
 * The builder will write such rollups for every layer if a non-empty localeList  profile property is
 * provided. Further, the builder will include the following cache entry in the cache associated with
 * any layer.
 * 
 * "*now":function(r){r(['dojo/i18n!*preload*<path>/nls/<module>*<JSON array of available locales>']);}
 * The *now special cache module instructs the loader to apply the provided function to context-require
 * with respect to the particular layer being defined. This causes the plugin to hold all normal service
 * requests until all preloading is complete.
 * 
 * Notice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case
 * where the target locale has a single segment and a layer depends on a single bundle:
 * 
 * Without Preloads:
 * 
 * Layer loads root bundle.
 * bundle is demanded; plugin loads single localized bundle.
 * With Preloads:
 * 
 * Layer causes preloading of target bundle.
 * bundle is demanded; service is delayed until preloading complete; bundle is returned.
 * In each case a single transaction is required to load the target bundle. In cases where multiple bundles
 * are required and/or the locale has multiple segments, preloads still requires a single transaction whereas
 * the normal path requires an additional transaction for each additional bundle/locale-segment. However all
 * of these additional transactions can be done concurrently. Owing to this analysis, the entire preloading
 * algorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.
 * 
 * @param {?} id
 * @param {?} require
 * @param {?} load
 * @return {void}
 */
dojo.i18n.prototype.load = function(id, require, load) {};

/**
 * id may be relative.
 * preload has form *preload*<path>/nls/<module>*<flattened locales> and
 * therefore never looks like a relative
 * 
 * @param {?} id
 * @param {?} toAbsMid
 * @return {?}
 */
dojo.i18n.prototype.normalize = function(id, toAbsMid) {};

/**
 *
 * @param {?} locale
 * @return {?}
 */
dojo.i18n.prototype.normalizeLocale = function(locale) {};
/**
 * @record
 * @struct
 */
dojo.i18n.cache = function() {};
/**
 * @record
 * @struct
 */
dojo.json = function() {};

/**
 * Parses a JSON string to return a JavaScript object.
 * This function follows native JSON API
 * Throws for invalid JSON strings. This delegates to eval() if native JSON
 * support is not available. By default this will evaluate any valid JS expression.
 * With the strict parameter set to true, the parser will ensure that only
 * valid JSON strings are parsed (otherwise throwing an error). Without the strict
 * parameter, the content passed to this method must come
 * from a trusted source.
 * 
 * @param {?} str a string literal of a JSON item, for instance:'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'
 * @param {?} strict When set to true, this will ensure that only valid, secure JSON is ever parsed.Make sure this is set to true for untrusted content. Note that on browsers/engineswithout native JSON support, setting this to true will run slower.
 * @return {void}
 */
dojo.json.prototype.parse = function(str, strict) {};

/**
 * Returns a JSON serialization of an object.
 * Returns a JSON serialization of an object.
 * This function follows native JSON API
 * Note that this doesn't check for infinite recursion, so don't do that!
 * 
 * @param {?} value A value to be serialized.
 * @param {?} replacer A replacer function that is called for each value and can return a replacement
 * @param {?} spacer A spacer string to be used for pretty printing of JSON
 * @return {void}
 */
dojo.json.prototype.stringify = function(value, replacer, spacer) {};
/**
 * @record
 * @struct
 */
dojo.loadInit = function() {};
 /** @type {number} */
dojo.loadInit.prototype.dynamic;
 /** @type {!Object} */
dojo.loadInit.prototype.load;

/**
 *
 * @param {?} id
 * @return {?}
 */
dojo.loadInit.prototype.normalize = function(id) {};
/**
 * @record
 * @struct
 */
dojo.keys = function() {};
 /** @type {number} */
dojo.keys.prototype.ALT;
 /** @type {number} */
dojo.keys.prototype.BACKSPACE;
 /** @type {number} */
dojo.keys.prototype.CAPS_LOCK;
 /** @type {number} */
dojo.keys.prototype.CLEAR;
 /** @type {number} */
dojo.keys.prototype.copyKey;
 /** @type {number} */
dojo.keys.prototype.CTRL;
 /** @type {number} */
dojo.keys.prototype.DELETE;
 /** @type {number} */
dojo.keys.prototype.DOWN_ARROW;
 /** @type {number} */
dojo.keys.prototype.DOWN_DPAD;
 /** @type {number} */
dojo.keys.prototype.END;
 /** @type {number} */
dojo.keys.prototype.ENTER;
 /** @type {number} */
dojo.keys.prototype.ESCAPE;
 /** @type {number} */
dojo.keys.prototype.F1;
 /** @type {number} */
dojo.keys.prototype.F10;
 /** @type {number} */
dojo.keys.prototype.F11;
 /** @type {number} */
dojo.keys.prototype.F12;
 /** @type {number} */
dojo.keys.prototype.F13;
 /** @type {number} */
dojo.keys.prototype.F14;
 /** @type {number} */
dojo.keys.prototype.F15;
 /** @type {number} */
dojo.keys.prototype.F2;
 /** @type {number} */
dojo.keys.prototype.F3;
 /** @type {number} */
dojo.keys.prototype.F4;
 /** @type {number} */
dojo.keys.prototype.F5;
 /** @type {number} */
dojo.keys.prototype.F6;
 /** @type {number} */
dojo.keys.prototype.F7;
 /** @type {number} */
dojo.keys.prototype.F8;
 /** @type {number} */
dojo.keys.prototype.F9;
 /** @type {number} */
dojo.keys.prototype.HELP;
 /** @type {number} */
dojo.keys.prototype.HOME;
 /** @type {number} */
dojo.keys.prototype.INSERT;
 /** @type {number} */
dojo.keys.prototype.LEFT_ARROW;
 /** @type {number} */
dojo.keys.prototype.LEFT_DPAD;
 /** @type {number} */
dojo.keys.prototype.LEFT_WINDOW;
 /** @type {number} */
dojo.keys.prototype.META;
 /** @type {number} */
dojo.keys.prototype.NUM_LOCK;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_0;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_1;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_2;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_3;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_4;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_5;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_6;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_7;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_8;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_9;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_DIVIDE;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_ENTER;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_MINUS;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_MULTIPLY;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_PERIOD;
 /** @type {number} */
dojo.keys.prototype.NUMPAD_PLUS;
 /** @type {number} */
dojo.keys.prototype.PAGE_DOWN;
 /** @type {number} */
dojo.keys.prototype.PAGE_UP;
 /** @type {number} */
dojo.keys.prototype.PAUSE;
 /** @type {number} */
dojo.keys.prototype.RIGHT_ARROW;
 /** @type {number} */
dojo.keys.prototype.RIGHT_DPAD;
 /** @type {number} */
dojo.keys.prototype.RIGHT_WINDOW;
 /** @type {number} */
dojo.keys.prototype.SCROLL_LOCK;
 /** @type {number} */
dojo.keys.prototype.SELECT;
 /** @type {number} */
dojo.keys.prototype.SHIFT;
 /** @type {number} */
dojo.keys.prototype.SPACE;
 /** @type {number} */
dojo.keys.prototype.TAB;
 /** @type {number} */
dojo.keys.prototype.UP_ARROW;
 /** @type {number} */
dojo.keys.prototype.UP_DPAD;
/**
 * @record
 * @struct
 */
dojo.mouse = function() {};
 /** @type {!Object} */
dojo.mouse.prototype.enter;
 /** @type {!Object} */
dojo.mouse.prototype.leave;

/**
 * Test an event object (from a mousedown event) to see if the left button was pressed.
 * 
 * @return {void}
 */
dojo.mouse.prototype.isLeft = function() {};

/**
 * Test an event object (from a mousedown event) to see if the middle button was pressed.
 * 
 * @return {void}
 */
dojo.mouse.prototype.isMiddle = function() {};

/**
 * Test an event object (from a mousedown event) to see if the right button was pressed.
 * 
 * @return {void}
 */
dojo.mouse.prototype.isRight = function() {};

/**
 * This is an extension event for the mousewheel that non-Mozilla browsers provide,
 * emulating the behavior on Mozilla based browsers.
 * 
 * @param {?} node
 * @param {?} listener
 * @return {?}
 */
dojo.mouse.prototype.wheel = function(node, listener) {};
/**
 * @record
 * @struct
 */
dojo.node = function() {};

/**
 * Standard AMD plugin interface. See https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins
 * for information.
 * 
 * @param {!String} id
 * @param {!Function} require
 * @param {!Function} load
 * @return {void}
 */
dojo.node.prototype.load = function(id, require, load) {};

/**
 * Produces a normalized id to be used by node.  Relative ids are resolved relative to the requesting
 * module's location in the file system and will return an id with path separators appropriate for the
 * local file system.
 * 
 * @param {!String} id
 * @param {!Function} normalize
 * @return {?}
 */
dojo.node.prototype.normalize = function(id, normalize) {};
/**
 * @record
 * @struct
 */
dojo.number_ = function() {};

/**
 * Format a Number as a String, using locale-specific settings
 * Create a string from a Number using a known localized pattern.
 * Formatting patterns appropriate to the locale are chosen from the
 * Common Locale Data Repository as well as the appropriate symbols and
 * delimiters.
 * If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.
 * 
 * @param {number} value the number to be formatted
 * @param {!Object=} options               OptionalAn object with the following properties:pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.  Literal characters in patterns are not supported.type (String, optional): choose a format type based on the locale from the following:decimal, scientific (not yet supported), percent, currency. decimal by default.places (Number, optional): fixed number of decimal places to show.  This overrides anyinformation in the provided pattern.round (Number, optional): 5 rounds to nearest .5; 0 rounds to nearest whole (default). -1means do not round.locale (String, optional): override the locale used to determine formatting rulesfractional (Boolean, optional): If false, show no decimal places, overriding places and pattern settings.
 * @return {?}
 */
dojo.number_.prototype.format = function(value, options) {};

/**
 * Convert a properly formatted string to a primitive Number, using
 * locale-specific settings.
 * Create a Number from a string using a known localized pattern.
 * Formatting patterns are chosen appropriate to the locale
 * and follow the syntax described by
 * unicode.org TR35
 * Note that literal characters in patterns are not supported.
 * 
 * @param {!String} expression A string representation of a Number
 * @param {!Object=} options               OptionalAn object with the following properties:pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.  Literal characters in patterns are not supported.type (String, optional): choose a format type based on the locale from the following:decimal, scientific (not yet supported), percent, currency. decimal by default.locale (String, optional): override the locale used to determine formatting rulesstrict (Boolean, optional): strict parsing, false by default.  Strict parsing requires input as produced by the format() method.Non-strict is more permissive, e.g. flexible on white space, omitting thousands separatorsfractional (Boolean|Array, optional): Whether to include the fractional portion, where the number of decimal places are implied by patternor explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.
 * @return {number}
 */
dojo.number_.prototype.parse = function(expression, options) {};

/**
 * Builds the regular needed to parse a number
 * Returns regular expression with positive and negative match, group
 * and decimal separators
 * 
 * @param {!Object} options               OptionalAn object with the following properties:pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.type (String, optional): choose a format type based on the locale from the following:decimal, scientific (not yet supported), percent, currency. decimal by default.locale (String, optional): override the locale used to determine formatting rulesstrict (Boolean, optional): strict parsing, false by default.  Strict parsing requires input as produced by the format() method.Non-strict is more permissive, e.g. flexible on white space, omitting thousands separatorsplaces (Number|String, optional): number of decimal places to accept: Infinity, a positive number, ora range "n,m".  Defined by pattern or Infinity if pattern not provided.
 * @return {?}
 */
dojo.number_.prototype.regexp = function(options) {};

/**
 * Rounds to the nearest value with the given number of decimal places, away from zero
 * Rounds to the nearest value with the given number of decimal places, away from zero if equal.
 * Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
 * fractional increments also, such as the nearest quarter.
 * NOTE: Subject to floating point errors.  See dojox/math/round for experimental workaround.
 * 
 * @param {number} value The number to round
 * @param {number=} places               OptionalThe number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.Must be non-negative.
 * @param {number=} increment               OptionalRounds next place to nearest value of increment/10.  10 by default.
 * @return {number}
 */
dojo.number_.prototype.round = function(value, places, increment) {};

/**
 * @constructor
 * @struct
 */
dojo.number_.__FormatAbsoluteOptions = function() {};

/* TODO: PropertyDeclaration: dojo.number_."decimal" */

/* TODO: PropertyDeclaration: dojo.number_."group" */

/* TODO: PropertyDeclaration: dojo.number_."places" */

/* TODO: PropertyDeclaration: dojo.number_."round" */

/**
 * @constructor
 * @struct
 */
dojo.number_.__IntegerRegexpFlags = function() {};

/* TODO: PropertyDeclaration: dojo.number_."groupSize" */

/* TODO: PropertyDeclaration: dojo.number_."groupSize2" */

/* TODO: PropertyDeclaration: dojo.number_."separator" */

/* TODO: PropertyDeclaration: dojo.number_."signed" */

/**
 * @constructor
 * @struct
 */
dojo.number_.__FormatOptions = function() {};

/* TODO: PropertyDeclaration: dojo.number_."fractional" */

/* TODO: PropertyDeclaration: dojo.number_."locale" */

/* TODO: PropertyDeclaration: dojo.number_."pattern" */

/* TODO: PropertyDeclaration: dojo.number_."places" */

/* TODO: PropertyDeclaration: dojo.number_."round" */

/* TODO: PropertyDeclaration: dojo.number_."type" */

/**
 * @constructor
 * @struct
 */
dojo.number_.__RealNumberRegexpFlags = function() {};

/* TODO: PropertyDeclaration: dojo.number_."decimal" */

/* TODO: PropertyDeclaration: dojo.number_."eSigned" */

/* TODO: PropertyDeclaration: dojo.number_."exponent" */

/* TODO: PropertyDeclaration: dojo.number_."fractional" */

/* TODO: PropertyDeclaration: dojo.number_."places" */

/**
 * @constructor
 * @struct
 */
dojo.number_.__ParseOptions = function() {};

/* TODO: PropertyDeclaration: dojo.number_."fractional" */

/* TODO: PropertyDeclaration: dojo.number_."locale" */

/* TODO: PropertyDeclaration: dojo.number_."pattern" */

/* TODO: PropertyDeclaration: dojo.number_."strict" */

/* TODO: PropertyDeclaration: dojo.number_."type" */

/**
 * @constructor
 * @struct
 */
dojo.number_.__RegexpOptions = function() {};

/* TODO: PropertyDeclaration: dojo.number_."locale" */

/* TODO: PropertyDeclaration: dojo.number_."pattern" */

/* TODO: PropertyDeclaration: dojo.number_."places" */

/* TODO: PropertyDeclaration: dojo.number_."strict" */

/* TODO: PropertyDeclaration: dojo.number_."type" */
/**
 * @record
 * @struct
 */
dojo.parser = function() {};

/**
 * Calls new ctor(params, node), where params is the hash of parameters specified on the node,
 * excluding data-dojo-type and data-dojo-mixins.   Does not call startup().
 * 
 * @param {!Function} ctor Widget constructor.
 * @param {!HTMLElement} node This node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.
 * @param {!Object=} mixin               OptionalAttributes in this object will be passed as parameters to ctor,overriding attributes specified on the node.
 * @param {!Object=} options               OptionalAn options object used to hold kwArgs for instantiation.   See parse.options argument for details.
 * @param {!Array<!HTMLElement>=} scripts               OptionalArray of <script type="dojo//"> DOMNodes.  If not specified, will search for <script> tags inside node.
 * @param {!Object=} inherited               OptionalSettings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.
 * @return {?}
 */
dojo.parser.prototype.construct = function(ctor, node, mixin, options, scripts, inherited) {};

/**
 * Takes array of nodes, and turns them into class instances and
 * potentially calls a startup method to allow them to connect with
 * any children.
 * 
 * @param {!Array<?>} nodes Array of DOM nodes
 * @param {!Object=} mixin               OptionalAn object that will be mixed in with each node in the array.Values in the mixin will override values in the node, if theyexist.
 * @param {!Object=} options               OptionalAn object used to hold kwArgs for instantiation.See parse.options argument for details.
 * @return {?}
 */
dojo.parser.prototype.instantiate = function(nodes, mixin, options) {};

/**
 * Scan the DOM for class instances, and instantiate them.
 * Search specified node (or root node) recursively for class instances,
 * and instantiate them. Searches for either data-dojo-type="Class" or
 * dojoType="Class" where "Class" is a a fully qualified class name,
 * like dijit/form/Button
 * 
 * Using data-dojo-type:
 * Attributes using can be mixed into the parameters used to instantiate the
 * Class by using a data-dojo-props attribute on the node being converted.
 * data-dojo-props should be a string attribute to be converted from JSON.
 * 
 * Using dojoType:
 * Attributes are read from the original domNode and converted to appropriate
 * types by looking up the Class prototype values. This is the default behavior
 * from Dojo 1.0 to Dojo 1.5. dojoType support is deprecated, and will
 * go away in Dojo 2.0.
 * 
 * @param {!HTMLElement=} rootNode               OptionalA default starting root node from which to start the parsing. Can beomitted, defaulting to the entire document. If omitted, the optionsobject can be passed in this place. If the options object has arootNode member, that is used.
 * @param {!Object=} options               OptionalA hash of options.noStart: Boolean?:  when set will prevent the parser from calling .startup()  when locating the nodes.rootNode: DomNode?:  identical to the function's rootNode argument, though  allowed to be passed in via this `options object.template: Boolean:  If true, ignores ContentPane's stopParser flag and parses contents inside of  a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes  nested inside the ContentPane to work.inherited: Object:  Hash possibly containing dir and lang settings to be applied to  parsed widgets, unless there's another setting on a sub-node that overridesscope: String:  Root for attribute names to search for.   If scopeName is dojo,  will search for data-dojo-type (or dojoType).   For backwards compatibility  reasons defaults to dojo._scopeName (which is "dojo" except when  multi-version support is used, when it will be something like dojo16, dojo20, etc.)propsThis: Object:  If specified, "this" referenced from data-dojo-props will refer to propsThis.  Intended for use from the widgets-in-template feature of dijit._WidgetsInTemplateMixincontextRequire: Function:  If specified, this require is utilised for looking resolving modules instead of the  dojo/parser context require().  Intended for use from the widgets-in-template feature of  dijit._WidgetsInTemplateMixin.
 * @return {?}
 */
dojo.parser.prototype.parse = function(rootNode, options) {};

/**
 * Scan a DOM tree and return an array of objects representing the DOMNodes
 * that need to be turned into widgets.
 * Search specified node (or document root node) recursively for class instances
 * and return an array of objects that represent potential widgets to be
 * instantiated. Searches for either data-dojo-type="MID" or dojoType="MID" where
 * "MID" is a module ID like "dijit/form/Button" or a fully qualified Class name
 * like "dijit/form/Button".  If the MID is not currently available, scan will
 * attempt to require() in the module.
 * 
 * See parser.parse() for details of markup.
 * 
 * @param {!HTMLElement=} root               OptionalA default starting root node from which to start the parsing. Can beomitted, defaulting to the entire document. If omitted, the optionsobject can be passed in this place. If the options object has arootNode member, that is used.
 * @param {!Object=} options a kwArgs options object, see parse() for details
 * @return {!dojo.promise.Promise<?>}
 */
dojo.parser.prototype.scan = function(root, options) {};
/**
 * @record
 * @struct
 */
dojo.regexp = function() {};

/**
 * Builds a regular expression that groups subexpressions
 * A utility function used by some of the RE generators. The
 * subexpressions are constructed by the function, re, in the second
 * parameter.  re builds one subexpression for each elem in the array
 * a, in the first parameter. Returns a string for a regular
 * expression that groups all the subexpressions.
 * 
 * Builds a regular expression that groups subexpressions
 * A utility function used by some of the RE generators. The
 * subexpressions are constructed by the function, re, in the second
 * parameter.  re builds one subexpression for each elem in the array
 * a, in the first parameter. Returns a string for a regular
 * expression that groups all the subexpressions.
 * 
 * @param {!Object|!Array<?>} arr A single value or an array of values.
 * @param {!Function} re A function. Takes one parameter and converts it to a regularexpression.
 * @param {boolean=} nonCapture               OptionalIf true, uses non-capturing match, otherwise matches are retainedby regular expression. Defaults to false
 * @return {?}
 */
dojo.regexp.prototype.buildGroupRE = function(arr, re, nonCapture) {};

/**
 * Adds escape sequences for special characters in regular expressions
 * 
 * @param {!String} str
 * @param {!String=} except               Optionala String with special characters to be left unescaped
 * @return {?}
 */
dojo.regexp.prototype.escapeString = function(str, except) {};

/**
 * adds group match to expression
 * 
 * @param {!String} expression
 * @param {boolean=} nonCapture               OptionalIf true, uses non-capturing match, otherwise matches are retainedby regular expression.
 * @return {!String}
 */
dojo.regexp.prototype.group = function(expression, nonCapture) {};
/**
 * @record
 * @struct
 */
dojo.require = function() {};
 /** @type {number} */
dojo.require.prototype.dynamic;
 /** @type {!Object} */
dojo.require.prototype.load;

/**
 *
 * @param {?} id
 * @return {?}
 */
dojo.require.prototype.normalize = function(id) {};
/**
 * @record
 * @struct
 */
dojo.robotx = function() {};
 /** @type {!Object} */
dojo.robotx.prototype.doc;
 /** @type {number} */
dojo.robotx.prototype.mouseWheelSize;
 /** @type {!Object} */
dojo.robotx.prototype.window;

/**
 * Opens the application at the specified URL for testing, redirecting dojo to point to the application
 * environment instead of the test environment.
 * 
 * @param {!String} url URL to open. Any of the test's dojo.doc calls (e.g. dojo.byId()), and any dijit.registry calls(e.g. dijit.byId()) will point to elements and widgets inside this application.
 * @return {void}
 */
dojo.robotx.prototype.initRobot = function(url) {};

/**
 * Holds down a single key, like SHIFT or 'a'.
 * Holds down a single key, like SHIFT or 'a'.
 * 
 * @param {number} charOrCode char/JS keyCode/dojo.keys.* constant for the key you want to hold downWarning: holding down a shifted key, like 'A', can have unpredictable results.
 * @param {number=} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left: true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @return {void}
 */
dojo.robotx.prototype.keyDown = function(charOrCode, delay) {};

/**
 * Types a key combination, like SHIFT-TAB.
 * Types a key combination, like SHIFT-TAB.
 * 
 * @param {number} charOrCode char/JS keyCode/dojo.keys.* constant for the key you want to press
 * @param {number} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left: true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @param {!Object} modifiers JSON object that represents all of the modifier keys being pressed.It takes the following Boolean attributes:shiftaltctrlmeta
 * @param {boolean} asynchronous If true, the delay happens asynchronously and immediately, outside of the browser's JavaScript thread and any previous calls.This is useful for interacting with the browser's modal dialogs.
 * @return {void}
 */
dojo.robotx.prototype.keyPress = function(charOrCode, delay, modifiers, asynchronous) {};

/**
 * Releases a single key, like SHIFT or 'a'.
 * Releases a single key, like SHIFT or 'a'.
 * 
 * @param {number} charOrCode char/JS keyCode/dojo.keys.* constant for the key you want to releaseWarning: releasing a shifted key, like 'A', can have unpredictable results.
 * @param {number=} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left: true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @return {void}
 */
dojo.robotx.prototype.keyUp = function(charOrCode, delay) {};

/**
 *
 * @return {void}
 */
dojo.robotx.prototype.killRobot = function() {};

/**
 * Convenience function to do a press/release.
 * See robot.mousePress for more info.
 * Convenience function to do a press/release.
 * See robot.mousePress for more info.
 * 
 * @param {!Object} buttons
 * @param {number=} delay               Optional
 * @return {void}
 */
dojo.robotx.prototype.mouseClick = function(buttons, delay) {};

/**
 * Moves the mouse to the specified x,y offset relative to the viewport.
 * 
 * @param {number} x x offset relative to the viewport, in pixels, to move the mouse.
 * @param {number} y y offset relative to the viewport, in pixels, to move the mouse.
 * @param {number} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left: true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @param {number} duration               OptionalApproximate time Robot will spend moving the mouseThe default is 100ms. This also affects how many mousemove events willbe generated, which is the log of the duration.
 * @param {boolean} absolute Boolean indicating whether the x and y values are absolute coordinates.If false, then mouseMove expects that the x,y will be relative to the window. (clientX/Y)If true, then mouseMove expects that the x,y will be absolute. (pageX/Y)
 * @return {void}
 */
dojo.robotx.prototype.mouseMove = function(x, y, delay, duration, absolute) {};

/**
 * Moves the mouse over the specified node at the specified relative x,y offset.
 * Moves the mouse over the specified node at the specified relative x,y offset.
 * If you do not specify an offset, mouseMove will default to move to the middle of the node.
 * Example: to move the mouse over a ComboBox's down arrow node, call doh.mouseMoveAt(dijit.byId('setvaluetest').downArrowNode);
 * 
 * Moves the mouse over the specified node at the specified relative x,y offset.
 * Moves the mouse over the specified node at the specified relative x,y offset.
 * If you do not specify an offset, mouseMove will default to move to the middle of the node.
 * Example: to move the mouse over a ComboBox's down arrow node, call doh.mouseMoveAt(dijit.byId('setvaluetest').downArrowNode);
 * 
 * Moves the mouse over the specified node at the specified relative x,y offset.
 * Moves the mouse over the specified node at the specified relative x,y offset.
 * If you do not specify an offset, mouseMove will default to move to the middle of the node.
 * Example: to move the mouse over a ComboBox's down arrow node, call doh.mouseMoveAt(dijit.byId('setvaluetest').downArrowNode);
 * 
 * @param {!String|!HTMLElement|!Function} node The id of the node, or the node itself, to move the mouse to.If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.This is useful if you need to move the mouse to an node that is not yet present.
 * @param {number} delay Delay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left:true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @param {number} duration Approximate time Robot will spend moving the mouseThe default is 100ms.
 * @param {number} offsetX x offset relative to the node, in pixels, to move the mouse. The default is half the node's width.
 * @param {number} offsetY y offset relative to the node, in pixels, to move the mouse. The default is half the node's height.
 * @return {void}
 */
dojo.robotx.prototype.mouseMoveAt = function(node, delay, duration, offsetX, offsetY) {};

/**
 * Move the mouse from the current position to the specified point.
 * Delays reading contents point until queued command starts running.
 * See mouseMove() for details.
 * 
 * @param {!Object} point x, y position relative to viewport, or if absolute == true, to document
 * @param {number} delay               Optional
 * @param {number} duration               Optional
 * @param {boolean} absolute
 * @return {void}
 */
dojo.robotx.prototype.mouseMoveTo = function(point, delay, duration, absolute) {};

/**
 * Presses mouse buttons.
 * Presses the mouse buttons you pass as true.
 * Example: to press the left mouse button, pass {left: true}.
 * Mouse buttons you don't specify keep their previous pressed state.
 * 
 * @param {!Object} buttons JSON object that represents all of the mouse buttons being pressed.It takes the following Boolean attributes:leftmiddleright
 * @param {number=} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left: true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @return {void}
 */
dojo.robotx.prototype.mousePress = function(buttons, delay) {};

/**
 * Releases mouse buttons.
 * Releases the mouse buttons you pass as true.
 * Example: to release the left mouse button, pass {left: true}.
 * Mouse buttons you don't specify keep their previous pressed state.
 * See robot.mousePress for more info.
 * 
 * @param {!Object} buttons
 * @param {number=} delay               Optional
 * @return {void}
 */
dojo.robotx.prototype.mouseRelease = function(buttons, delay) {};

/**
 * Spins the mouse wheel.
 * Spins the wheel wheelAmt "notches."
 * Negative wheelAmt scrolls up/away from the user.
 * Positive wheelAmt scrolls down/toward the user.
 * Note: this will all happen in one event.
 * Warning: the size of one mouse wheel notch is an OS setting.
 * You can access this size from robot.mouseWheelSize
 * 
 * @param {number} wheelAmt Number of notches to spin the wheel.Negative wheelAmt scrolls up/away from the user.Positive wheelAmt scrolls down/toward the user.
 * @param {number=} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:    robot.mouseClick({left: true}, 100) // first call; wait 100ms    robot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @param {number=} duration               OptionalApproximate time Robot will spend moving the mouseBy default, the Robot will wheel the mouse as fast as possible.
 * @return {void}
 */
dojo.robotx.prototype.mouseWheel = function(wheelAmt, delay, duration) {};

/**
 * Scroll the passed node into view, if it is not.
 * 
 * Scroll the passed node into view, if it is not.
 * 
 * Scroll the passed node into view, if it is not.
 * 
 * @param {!String|!HTMLElement|!Function} node The id of the node, or the node itself, to move the mouse to.If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.This is useful if you need to move the mouse to an node that is not yet present.
 * @param {number} delay Delay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.
 * @return {void}
 */
dojo.robotx.prototype.scrollIntoView = function(node, delay) {};

/**
 * Defer an action by adding it to the robot's incrementally delayed queue of actions to execute.
 * 
 * @param {!Function} f A function containing actions you want to defer.  It can return a Promiseto delay further actions.
 * @param {number=} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left: true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @param {number=} duration               OptionalDelay to wait after firing.
 * @return {void}
 */
dojo.robotx.prototype.sequence = function(f, delay, duration) {};

/**
 * Set clipboard content.
 * Set data as clipboard content, overriding anything already there. The
 * data will be put to the clipboard using the given format.
 * 
 * @param {!String} data New clipboard content to set
 * @param {!String=} format               OptionalSet this to "text/html" to put richtext to the clipboard.Otherwise, data is treated as plaintext. By default, plaintextis used.
 * @return {void}
 */
dojo.robotx.prototype.setClipboard = function(data, format) {};

/**
 *
 * @return {?}
 */
dojo.robotx.prototype.startRobot = function() {};

/**
 * Types a string of characters in order, or types a dojo.keys.* constant.
 * Types a string of characters in order, or types a dojo.keys.* constant.
 * 
 * Types a string of characters in order, or types a dojo.keys.* constant.
 * Types a string of characters in order, or types a dojo.keys.* constant.
 * 
 * @param {!String|number} chars String of characters to type, or a dojo.keys.* constant
 * @param {number=} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left: true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @param {number=} duration               OptionalTime, in milliseconds, to spend pressing all of the keys.The default is (string length)*50 ms.
 * @return {void}
 */
dojo.robotx.prototype.typeKeys = function(chars, delay, duration) {};

/**
 * Notifies DOH that the doh.robot is about to make a page change in the application it is driving,
 * returning a doh.Deferred object the user should return in their runTest function as part of a DOH test.
 * 
 * @param {!Function} submitActions The doh.robot will execute the actions the test passes into the submitActions argument (like clicking the submit button),expecting these actions to create a page change (like a form submit).After these actions execute and the resulting page loads, the next test will start.
 * @return {?}
 */
dojo.robotx.prototype.waitForPageToLoad = function(submitActions) {};
/**
 * @record
 * @struct
 */
dojo.robotx._runsemaphore = function() {};
 /** @type {!Array<?>} */
dojo.robotx._runsemaphore.prototype.lock;

/**
 *
 * @return {?}
 */
dojo.robotx._runsemaphore.prototype.unlock = function() {};
/**
 * @record
 * @struct
 */
dojo.robot = function() {};
 /** @type {!Object} */
dojo.robot.prototype.doc;
 /** @type {number} */
dojo.robot.prototype.mouseWheelSize;
 /** @type {!Object} */
dojo.robot.prototype.window;

/**
 * Opens the application at the specified URL for testing, redirecting dojo to point to the application
 * environment instead of the test environment.
 * 
 * @param {!String} url URL to open. Any of the test's dojo.doc calls (e.g. dojo.byId()), and any dijit.registry calls(e.g. dijit.byId()) will point to elements and widgets inside this application.
 * @return {void}
 */
dojo.robot.prototype.initRobot = function(url) {};

/**
 * Holds down a single key, like SHIFT or 'a'.
 * Holds down a single key, like SHIFT or 'a'.
 * 
 * @param {number} charOrCode char/JS keyCode/dojo.keys.* constant for the key you want to hold downWarning: holding down a shifted key, like 'A', can have unpredictable results.
 * @param {number=} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left: true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @return {void}
 */
dojo.robot.prototype.keyDown = function(charOrCode, delay) {};

/**
 * Types a key combination, like SHIFT-TAB.
 * Types a key combination, like SHIFT-TAB.
 * 
 * @param {number} charOrCode char/JS keyCode/dojo.keys.* constant for the key you want to press
 * @param {number} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left: true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @param {!Object} modifiers JSON object that represents all of the modifier keys being pressed.It takes the following Boolean attributes:shiftaltctrlmeta
 * @param {boolean} asynchronous If true, the delay happens asynchronously and immediately, outside of the browser's JavaScript thread and any previous calls.This is useful for interacting with the browser's modal dialogs.
 * @return {void}
 */
dojo.robot.prototype.keyPress = function(charOrCode, delay, modifiers, asynchronous) {};

/**
 * Releases a single key, like SHIFT or 'a'.
 * Releases a single key, like SHIFT or 'a'.
 * 
 * @param {number} charOrCode char/JS keyCode/dojo.keys.* constant for the key you want to releaseWarning: releasing a shifted key, like 'A', can have unpredictable results.
 * @param {number=} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left: true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @return {void}
 */
dojo.robot.prototype.keyUp = function(charOrCode, delay) {};

/**
 *
 * @return {void}
 */
dojo.robot.prototype.killRobot = function() {};

/**
 * Convenience function to do a press/release.
 * See robot.mousePress for more info.
 * Convenience function to do a press/release.
 * See robot.mousePress for more info.
 * 
 * @param {!Object} buttons
 * @param {number=} delay               Optional
 * @return {void}
 */
dojo.robot.prototype.mouseClick = function(buttons, delay) {};

/**
 * Moves the mouse to the specified x,y offset relative to the viewport.
 * 
 * @param {number} x x offset relative to the viewport, in pixels, to move the mouse.
 * @param {number} y y offset relative to the viewport, in pixels, to move the mouse.
 * @param {number} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left: true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @param {number} duration               OptionalApproximate time Robot will spend moving the mouseThe default is 100ms. This also affects how many mousemove events willbe generated, which is the log of the duration.
 * @param {boolean} absolute Boolean indicating whether the x and y values are absolute coordinates.If false, then mouseMove expects that the x,y will be relative to the window. (clientX/Y)If true, then mouseMove expects that the x,y will be absolute. (pageX/Y)
 * @return {void}
 */
dojo.robot.prototype.mouseMove = function(x, y, delay, duration, absolute) {};

/**
 * Moves the mouse over the specified node at the specified relative x,y offset.
 * Moves the mouse over the specified node at the specified relative x,y offset.
 * If you do not specify an offset, mouseMove will default to move to the middle of the node.
 * Example: to move the mouse over a ComboBox's down arrow node, call doh.mouseMoveAt(dijit.byId('setvaluetest').downArrowNode);
 * 
 * Moves the mouse over the specified node at the specified relative x,y offset.
 * Moves the mouse over the specified node at the specified relative x,y offset.
 * If you do not specify an offset, mouseMove will default to move to the middle of the node.
 * Example: to move the mouse over a ComboBox's down arrow node, call doh.mouseMoveAt(dijit.byId('setvaluetest').downArrowNode);
 * 
 * Moves the mouse over the specified node at the specified relative x,y offset.
 * Moves the mouse over the specified node at the specified relative x,y offset.
 * If you do not specify an offset, mouseMove will default to move to the middle of the node.
 * Example: to move the mouse over a ComboBox's down arrow node, call doh.mouseMoveAt(dijit.byId('setvaluetest').downArrowNode);
 * 
 * @param {!String|!HTMLElement|!Function} node The id of the node, or the node itself, to move the mouse to.If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.This is useful if you need to move the mouse to an node that is not yet present.
 * @param {number} delay Delay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left:true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @param {number} duration Approximate time Robot will spend moving the mouseThe default is 100ms.
 * @param {number} offsetX x offset relative to the node, in pixels, to move the mouse. The default is half the node's width.
 * @param {number} offsetY y offset relative to the node, in pixels, to move the mouse. The default is half the node's height.
 * @return {void}
 */
dojo.robot.prototype.mouseMoveAt = function(node, delay, duration, offsetX, offsetY) {};

/**
 * Move the mouse from the current position to the specified point.
 * Delays reading contents point until queued command starts running.
 * See mouseMove() for details.
 * 
 * @param {!Object} point x, y position relative to viewport, or if absolute == true, to document
 * @param {number} delay               Optional
 * @param {number} duration               Optional
 * @param {boolean} absolute
 * @return {void}
 */
dojo.robot.prototype.mouseMoveTo = function(point, delay, duration, absolute) {};

/**
 * Presses mouse buttons.
 * Presses the mouse buttons you pass as true.
 * Example: to press the left mouse button, pass {left: true}.
 * Mouse buttons you don't specify keep their previous pressed state.
 * 
 * @param {!Object} buttons JSON object that represents all of the mouse buttons being pressed.It takes the following Boolean attributes:leftmiddleright
 * @param {number=} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left: true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @return {void}
 */
dojo.robot.prototype.mousePress = function(buttons, delay) {};

/**
 * Releases mouse buttons.
 * Releases the mouse buttons you pass as true.
 * Example: to release the left mouse button, pass {left: true}.
 * Mouse buttons you don't specify keep their previous pressed state.
 * See robot.mousePress for more info.
 * 
 * @param {!Object} buttons
 * @param {number=} delay               Optional
 * @return {void}
 */
dojo.robot.prototype.mouseRelease = function(buttons, delay) {};

/**
 * Spins the mouse wheel.
 * Spins the wheel wheelAmt "notches."
 * Negative wheelAmt scrolls up/away from the user.
 * Positive wheelAmt scrolls down/toward the user.
 * Note: this will all happen in one event.
 * Warning: the size of one mouse wheel notch is an OS setting.
 * You can access this size from robot.mouseWheelSize
 * 
 * @param {number} wheelAmt Number of notches to spin the wheel.Negative wheelAmt scrolls up/away from the user.Positive wheelAmt scrolls down/toward the user.
 * @param {number} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:    robot.mouseClick({left: true}, 100) // first call; wait 100ms    robot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @param {number} duration               OptionalApproximate time Robot will spend moving the mouseBy default, the Robot will wheel the mouse as fast as possible.
 * @return {void}
 */
dojo.robot.prototype.mouseWheel = function(wheelAmt, delay, duration) {};

/**
 * Scroll the passed node into view, if it is not.
 * 
 * Scroll the passed node into view, if it is not.
 * 
 * Scroll the passed node into view, if it is not.
 * 
 * @param {!String|!HTMLElement|!Function} node The id of the node, or the node itself, to move the mouse to.If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.This is useful if you need to move the mouse to an node that is not yet present.
 * @param {number} delay Delay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.
 * @return {void}
 */
dojo.robot.prototype.scrollIntoView = function(node, delay) {};

/**
 * Defer an action by adding it to the robot's incrementally delayed queue of actions to execute.
 * 
 * @param {!Function} f A function containing actions you want to defer.  It can return a Promiseto delay further actions.
 * @param {number=} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left: true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @param {number=} duration               OptionalDelay to wait after firing.
 * @return {void}
 */
dojo.robot.prototype.sequence = function(f, delay, duration) {};

/**
 * Set clipboard content.
 * Set data as clipboard content, overriding anything already there. The
 * data will be put to the clipboard using the given format.
 * 
 * @param {!String} data New clipboard content to set
 * @param {!String=} format               OptionalSet this to "text/html" to put richtext to the clipboard.Otherwise, data is treated as plaintext. By default, plaintextis used.
 * @return {void}
 */
dojo.robot.prototype.setClipboard = function(data, format) {};

/**
 *
 * @return {?}
 */
dojo.robot.prototype.startRobot = function() {};

/**
 * Types a string of characters in order, or types a dojo.keys.* constant.
 * Types a string of characters in order, or types a dojo.keys.* constant.
 * 
 * Types a string of characters in order, or types a dojo.keys.* constant.
 * Types a string of characters in order, or types a dojo.keys.* constant.
 * 
 * @param {!String|number} chars String of characters to type, or a dojo.keys.* constant
 * @param {number=} delay               OptionalDelay, in milliseconds, to wait before firing.The delay is a delta with respect to the previous automation call.For example, the following code ends after 600ms:robot.mouseClick({left: true}, 100) // first call; wait 100msrobot.typeKeys("dij", 500) // 500ms AFTER previous call; 600ms in all
 * @param {number=} duration               OptionalTime, in milliseconds, to spend pressing all of the keys.The default is (string length)*50 ms.
 * @return {void}
 */
dojo.robot.prototype.typeKeys = function(chars, delay, duration) {};

/**
 * Notifies DOH that the doh.robot is about to make a page change in the application it is driving,
 * returning a doh.Deferred object the user should return in their runTest function as part of a DOH test.
 * 
 * @param {!Function} submitActions The doh.robot will execute the actions the test passes into the submitActions argument (like clicking the submit button),expecting these actions to create a page change (like a form submit).After these actions execute and the resulting page loads, the next test will start.
 * @return {?}
 */
dojo.robot.prototype.waitForPageToLoad = function(submitActions) {};
/**
 * @record
 * @struct
 */
dojo.robot._runsemaphore = function() {};
 /** @type {!Array<?>} */
dojo.robot._runsemaphore.prototype.lock;

/**
 *
 * @return {?}
 */
dojo.robot._runsemaphore.prototype.unlock = function() {};
/**
 * @record
 * @struct
 */
dojo.main = function() {};
 /** @type {!Object} */
dojo.main.prototype.back;
 /** @type {string} */
dojo.main.prototype.baseUrl;
 /** @type {!Object} */
dojo.main.prototype.behavior;
 /** @type {!Object} */
dojo.main.prototype.cldr;
 /** @type {!Object} */
dojo.main.prototype.colors;
 /** @type {!Object} */
dojo.main.prototype.config;
 /** @type {!Object} */
dojo.main.prototype.connectPublisher;
 /** @type {!Object} */
dojo.main.prototype.contentHandlers;
 /** @type {!Object} */
dojo.main.prototype.currency;
 /** @type {!Object} */
dojo.main.prototype.data;
 /** @type {!Object} */
dojo.main.prototype.date;
 /** @type {!Object} */
dojo.main.prototype.dijit;
 /** @type {!Object} */
dojo.main.prototype.dnd;
 /** @type {!Object} */
dojo.main.prototype.doc;
 /** @type {!Object} */
dojo.main.prototype.dojox;
 /** @type {!Object} */
dojo.main.prototype.fx;
 /** @type {!Object} */
dojo.main.prototype.gears;
 /** @type {!Object} */
dojo.main.prototype.global;
 /** @type {!Object} */
dojo.main.prototype.html;
 /** @type {!Object} */
dojo.main.prototype.i18n;
 /** @type {!Object} */
dojo.main.prototype.io;
 /** @type {boolean} */
dojo.main.prototype.isAir;
 /** @type {number} */
dojo.main.prototype.isAndroid;
 /** @type {boolean} */
dojo.main.prototype.isAsync;
 /** @type {boolean} */
dojo.main.prototype.isBrowser;
 /** @type {number} */
dojo.main.prototype.isChrome;
 /** @type {!Object} */
dojo.main.prototype.isCopyKey;
 /** @type {!Object} */
dojo.main.prototype.isFF;
 /** @type {number} */
dojo.main.prototype.isIE;
 /** @type {number} */
dojo.main.prototype.isIos;
 /** @type {number} */
dojo.main.prototype.isKhtml;
 /** @type {boolean} */
dojo.main.prototype.isMac;
 /** @type {!Object} */
dojo.main.prototype.isMoz;
 /** @type {!Object} */
dojo.main.prototype.isMozilla;
 /** @type {number} */
dojo.main.prototype.isOpera;
 /** @type {boolean} */
dojo.main.prototype.isQuirks;
 /** @type {number} */
dojo.main.prototype.isSafari;
 /** @type {boolean} */
dojo.main.prototype.isSpidermonkey;
 /** @type {number} */
dojo.main.prototype.isWebKit;
 /** @type {boolean} */
dojo.main.prototype.isWii;
 /** @type {!Object} */
dojo.main.prototype.keys;
 /** @type {!Object} */
dojo.main.prototype.locale;
 /** @type {!Object} */
dojo.main.prototype.mouseButtons;
 /** @type {!Object} */
dojo.main.prototype.number;
 /** @type {string} */
dojo.main.prototype.parser;
 /** @type {!Object} */
dojo.main.prototype.publish;
 /** @type {!Object} */
dojo.main.prototype.query;
 /** @type {!Object} */
dojo.main.prototype.regexp;
 /** @type {!Object} */
dojo.main.prototype.rpc;
 /** @type {!Object} */
dojo.main.prototype.scopeMap;
 /** @type {!Object} */
dojo.main.prototype.store;
 /** @type {!Object} */
dojo.main.prototype.string;
 /** @type {!Object} */
dojo.main.prototype.subscribe;
 /** @type {!Object} */
dojo.main.prototype.tests;
 /** @type {string} */
dojo.main.prototype.toJsonIndentStr;
 /** @type {!Object} */
dojo.main.prototype.touch;
 /** @type {!Object} */
dojo.main.prototype.version;
 /** @type {!Object} */
dojo.main.prototype.window;

/**
 * A registry to make contextual calling/searching easier.
 * Objects of this class keep list of arrays in the form [name, check,
 * wrap, directReturn] that are used to determine what the contextual
 * result of a set of checked arguments is. All check/wrap functions
 * in this registry should be of the same arity.
 * 
 * @param {boolean} returnWrappers               Optional
 * @return {void}
 */
dojo.main.prototype.AdapterRegistry = function(returnWrappers) {};

/**
 * Adds the specified classes to the end of the class list on the
 * passed node. Will not re-apply duplicate classes.
 * 
 * Adds the specified classes to the end of the class list on the
 * passed node. Will not re-apply duplicate classes.
 * 
 * Adds the specified classes to the end of the class list on the
 * passed node. Will not re-apply duplicate classes.
 * 
 * Adds the specified classes to the end of the class list on the
 * passed node. Will not re-apply duplicate classes.
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to add a class string too
 * @param {!String|!Array<?>} classStr A String class name to add, or several space-separated class names,or an array of class names.
 * @return {void}
 */
dojo.main.prototype.addClass = function(node, classStr) {};

/**
 * Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
 * In most cases, the domReady plug-in should suffice and this method should not be needed.
 * 
 * When called in a non-browser environment, just checks that all requested modules have arrived and been
 * evaluated.
 * 
 * @param {number} priority               OptionalThe order in which to exec this callback relative to other callbacks, defaults to 1000
 * @param {?} context The context in which to run execute callback, or a callback if not using context
 * @param {!Function=} callback               OptionalThe function to execute.
 * @return {void}
 */
dojo.main.prototype.addOnLoad = function(priority, context, callback) {};

/**
 * registers a function to be triggered when the page unloads.
 * The first time that addOnUnload is called Dojo will
 * register a page listener to trigger your unload handler
 * with.
 * 
 * In a browser environment, the functions will be triggered
 * during the window.onbeforeunload event. Be careful of doing
 * too much work in an unload handler. onbeforeunload can be
 * triggered if a link to download a file is clicked, or if
 * the link is a javascript: link. In these cases, the
 * onbeforeunload event fires, but the document is not
 * actually destroyed. So be careful about doing destructive
 * operations in a dojo.addOnUnload callback.
 * 
 * Further note that calling dojo.addOnUnload will prevent
 * browsers from using a "fast back" cache to make page
 * loading via back button instantaneous.
 * 
 * registers a function to be triggered when the page unloads.
 * The first time that addOnUnload is called Dojo will
 * register a page listener to trigger your unload handler
 * with.
 * 
 * In a browser environment, the functions will be triggered
 * during the window.onbeforeunload event. Be careful of doing
 * too much work in an unload handler. onbeforeunload can be
 * triggered if a link to download a file is clicked, or if
 * the link is a javascript: link. In these cases, the
 * onbeforeunload event fires, but the document is not
 * actually destroyed. So be careful about doing destructive
 * operations in a dojo.addOnUnload callback.
 * 
 * Further note that calling dojo.addOnUnload will prevent
 * browsers from using a "fast back" cache to make page
 * loading via back button instantaneous.
 * 
 * registers a function to be triggered when the page unloads.
 * The first time that addOnUnload is called Dojo will
 * register a page listener to trigger your unload handler
 * with.
 * 
 * In a browser environment, the functions will be triggered
 * during the window.onbeforeunload event. Be careful of doing
 * too much work in an unload handler. onbeforeunload can be
 * triggered if a link to download a file is clicked, or if
 * the link is a javascript: link. In these cases, the
 * onbeforeunload event fires, but the document is not
 * actually destroyed. So be careful about doing destructive
 * operations in a dojo.addOnUnload callback.
 * 
 * Further note that calling dojo.addOnUnload will prevent
 * browsers from using a "fast back" cache to make page
 * loading via back button instantaneous.
 * 
 * registers a function to be triggered when the page unloads.
 * The first time that addOnUnload is called Dojo will
 * register a page listener to trigger your unload handler
 * with.
 * 
 * In a browser environment, the functions will be triggered
 * during the window.onbeforeunload event. Be careful of doing
 * too much work in an unload handler. onbeforeunload can be
 * triggered if a link to download a file is clicked, or if
 * the link is a javascript: link. In these cases, the
 * onbeforeunload event fires, but the document is not
 * actually destroyed. So be careful about doing destructive
 * operations in a dojo.addOnUnload callback.
 * 
 * Further note that calling dojo.addOnUnload will prevent
 * browsers from using a "fast back" cache to make page
 * loading via back button instantaneous.
 * 
 * @param {!Object|!Function=} obj               Optional
 * @param {!String|!Function=} functionName               Optional
 * @return {void}
 */
dojo.main.prototype.addOnUnload = function(obj, functionName) {};

/**
 * registers a function to be triggered when window.onunload fires.
 * Be careful trying to modify the DOM or access JavaScript properties
 * during this phase of page unloading: they may not always be available.
 * Consider dojo.addOnUnload() if you need to modify the DOM or do heavy
 * JavaScript work.
 * 
 * registers a function to be triggered when window.onunload fires.
 * Be careful trying to modify the DOM or access JavaScript properties
 * during this phase of page unloading: they may not always be available.
 * Consider dojo.addOnUnload() if you need to modify the DOM or do heavy
 * JavaScript work.
 * 
 * @param {!Object=} obj               Optional
 * @param {!String|!Function=} functionName               Optional
 * @return {void}
 */
dojo.main.prototype.addOnWindowUnload = function(obj, functionName) {};

/**
 * A simpler interface to animateProperty(), also returns
 * an instance of Animation but begins the animation
 * immediately, unlike nearly every other Dojo animation API.
 * Simpler (but somewhat less powerful) version
 * of animateProperty.  It uses defaults for many basic properties
 * and allows for positional parameters to be used in place of the
 * packed "property bag" which is used for other Dojo animation
 * methods.
 * 
 * The Animation object returned will be already playing, so
 * calling play() on it again is (usually) a no-op.
 * 
 * A simpler interface to animateProperty(), also returns
 * an instance of Animation but begins the animation
 * immediately, unlike nearly every other Dojo animation API.
 * Simpler (but somewhat less powerful) version
 * of animateProperty.  It uses defaults for many basic properties
 * and allows for positional parameters to be used in place of the
 * packed "property bag" which is used for other Dojo animation
 * methods.
 * 
 * The Animation object returned will be already playing, so
 * calling play() on it again is (usually) a no-op.
 * 
 * @param {!HTMLElement|!String} node a DOM node or the id of a node to animate CSS properties on
 * @param {!Object} properties
 * @param {number=} duration               OptionalThe number of milliseconds over which the animationshould run. Defaults to the global animation default duration(350ms).
 * @param {!Function=} easing               OptionalAn easing function over which to calculate accelerationand deceleration of the animation through its duration.A default easing algorithm is provided, but you mayplug in any you wish. A large selection of easing algorithmsare available in dojo/fx/easing.
 * @param {!Function=} onEnd               OptionalA function to be called when the animation finishesrunning.
 * @param {number=} delay               OptionalThe number of milliseconds to delay beginning theanimation by. The default is 0.
 * @return {?}
 */
dojo.main.prototype.anim = function(node, properties, duration, easing, onEnd, delay) {};

/**
 * Returns an animation that will transition the properties of
 * node defined in args depending how they are defined in
 * args.properties
 * Foundation of most dojo/_base/fx
 * animations. It takes an object of "properties" corresponding to
 * style properties, and animates them in parallel over a set
 * duration.
 * 
 * @param {!Object} args An object with the following properties:properties (Object, optional): A hash map of style properties to Objects describing the transition,such as the properties of _Line with an additional 'units' propertynode (DOMNode|String): The node referenced in the animationduration (Integer, optional): Duration of the animation in milliseconds.easing (Function, optional): An easing function.
 * @return {?}
 */
dojo.main.prototype.animateProperty = function(args) {};

/**
 * A generic animation class that fires callbacks into its handlers
 * object at various states.
 * A generic animation class that fires callbacks into its handlers
 * object at various states. Nearly all dojo animation functions
 * return an instance of this method, usually without calling the
 * .play() method beforehand. Therefore, you will likely need to
 * call .play() on instances of Animation when one is
 * returned.
 * 
 * @param {!Object} args The 'magic argument', mixing all the properties into thisanimation instance.
 * @return {void}
 */
dojo.main.prototype.Animation = function(args) {};

/**
 * Gets or sets an attribute on an HTML element.
 * Handles normalized getting and setting of attributes on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Gets or sets an attribute on an HTML element.
 * Handles normalized getting and setting of attributes on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Gets or sets an attribute on an HTML element.
 * Handles normalized getting and setting of attributes on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Gets or sets an attribute on an HTML element.
 * Handles normalized getting and setting of attributes on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to get or set the attribute on
 * @param {!String|!Object} name the name of the attribute to get or set.
 * @param {!String=} value               OptionalThe value to set for the attribute
 * @return {?}
 */
dojo.main.prototype.attr = function(node, name, value) {};

/**
 * Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
 * can reuse a previously allocated Color object for the result
 * 
 * @param {!dojo._base.Color} start
 * @param {!dojo._base.Color} end
 * @param {number} weight
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo.main.prototype.blendColors = function(start, end, weight, obj) {};

/**
 * Return the body element of the specified document or of dojo/_base/window::doc.
 * 
 * @param {!HTMLDocument=} doc               Optional
 * @return {?}
 */
dojo.main.prototype.body = function(doc) {};

/**
 * Returns DOM node with matching id attribute or falsy value (ex: null or undefined)
 * if not found.  If id is a DomNode, this function is a no-op.
 * 
 * Returns DOM node with matching id attribute or falsy value (ex: null or undefined)
 * if not found.  If id is a DomNode, this function is a no-op.
 * 
 * @param {!String|!HTMLElement} id A string to match an HTML id attribute or a reference to a DOM Node
 * @param {!HTMLDocument=} doc               OptionalDocument to work in. Defaults to the current value ofdojo/_base/window.doc.  Can be used to retrievenode references from other documents.
 * @return {?}
 */
dojo.main.prototype.byId = function(id, doc) {};

/**
 * A getter and setter for storing the string content associated with the
 * module and url arguments.
 * If module is a string that contains slashes, then it is interpretted as a fully
 * resolved path (typically a result returned by require.toUrl), and url should not be
 * provided. This is the preferred signature. If module is a string that does not
 * contain slashes, then url must also be provided and module and url are used to
 * call dojo.moduleUrl() to generate a module URL. This signature is deprecated.
 * If value is specified, the cache value for the moduleUrl will be set to
 * that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
 * in its internal cache and return that cached value for the URL. To clear
 * a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
 * the URL contents, only modules on the same domain of the page can use this capability.
 * The build system can inline the cache values though, to allow for xdomain hosting.
 * 
 * A getter and setter for storing the string content associated with the
 * module and url arguments.
 * If module is a string that contains slashes, then it is interpretted as a fully
 * resolved path (typically a result returned by require.toUrl), and url should not be
 * provided. This is the preferred signature. If module is a string that does not
 * contain slashes, then url must also be provided and module and url are used to
 * call dojo.moduleUrl() to generate a module URL. This signature is deprecated.
 * If value is specified, the cache value for the moduleUrl will be set to
 * that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
 * in its internal cache and return that cached value for the URL. To clear
 * a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
 * the URL contents, only modules on the same domain of the page can use this capability.
 * The build system can inline the cache values though, to allow for xdomain hosting.
 * 
 * A getter and setter for storing the string content associated with the
 * module and url arguments.
 * If module is a string that contains slashes, then it is interpretted as a fully
 * resolved path (typically a result returned by require.toUrl), and url should not be
 * provided. This is the preferred signature. If module is a string that does not
 * contain slashes, then url must also be provided and module and url are used to
 * call dojo.moduleUrl() to generate a module URL. This signature is deprecated.
 * If value is specified, the cache value for the moduleUrl will be set to
 * that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
 * in its internal cache and return that cached value for the URL. To clear
 * a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
 * the URL contents, only modules on the same domain of the page can use this capability.
 * The build system can inline the cache values though, to allow for xdomain hosting.
 * 
 * A getter and setter for storing the string content associated with the
 * module and url arguments.
 * If module is a string that contains slashes, then it is interpretted as a fully
 * resolved path (typically a result returned by require.toUrl), and url should not be
 * provided. This is the preferred signature. If module is a string that does not
 * contain slashes, then url must also be provided and module and url are used to
 * call dojo.moduleUrl() to generate a module URL. This signature is deprecated.
 * If value is specified, the cache value for the moduleUrl will be set to
 * that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
 * in its internal cache and return that cached value for the URL. To clear
 * a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
 * the URL contents, only modules on the same domain of the page can use this capability.
 * The build system can inline the cache values though, to allow for xdomain hosting.
 * 
 * @param {!String|!Object} module dojo/cldr/supplemental
 * @param {!String} url The rest of the path to append to the path derived from the module argument. Ifmodule is an object, then this second argument should be the "value" argument instead.
 * @param {!String|!Object=} value               OptionalIf a String, the value to use in the cache for the module/url combination.If an Object, it can have two properties: value and sanitize. The value propertyshould be the value to use in the cache, and sanitize can be set to true or false,to indicate if XML declarations should be removed from the value and if the HTMLinside a body tag in the value should be extracted as the real value. The value argumentor the value property on the value argument are usually only used by the build systemas it inlines cache content.
 * @return {?}
 */
dojo.main.prototype.cache = function(module, url, value) {};

/**
 *
 * @return {void}
 */
dojo.main.prototype.clearCache = function() {};

/**
 * Takes a named string, hex string, array of rgb or rgba values,
 * an object with r, g, b, and a properties, or another Color object
 * and creates a new Color instance to work from.
 * 
 * Takes a named string, hex string, array of rgb or rgba values,
 * an object with r, g, b, and a properties, or another Color object
 * and creates a new Color instance to work from.
 * 
 * Takes a named string, hex string, array of rgb or rgba values,
 * an object with r, g, b, and a properties, or another Color object
 * and creates a new Color instance to work from.
 * 
 * @param {!Array<?>|!String|!Object} color
 * @return {void}
 */
dojo.main.prototype.Color = function(color) {};

/**
 * Builds a Color from a 3 or 4 element array, mapping each
 * element in sequence to the rgb(a) values of the color.
 * 
 * @param {!Array<?>} a
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo.main.prototype.colorFromArray = function(a, obj) {};

/**
 * Converts a hex string with a '#' prefix to a color object.
 * Supports 12-bit #rgb shorthand. Optionally accepts a
 * Color object to update with the parsed value.
 * 
 * @param {!String} color
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo.main.prototype.colorFromHex = function(color, obj) {};

/**
 * get rgb(a) array from css-style color declarations
 * this function can handle all 4 CSS3 Color Module formats: rgb,
 * rgba, hsl, hsla, including rgb(a) with percentage values.
 * 
 * @param {!String} color
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo.main.prototype.colorFromRgb = function(color, obj) {};

/**
 * Parses str for a color value. Accepts hex, rgb, and rgba
 * style color values.
 * Acceptable input values for str may include arrays of any form
 * accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
 * rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
 * 10, 50)"
 * 
 * @param {!String} str
 * @param {!dojo._base.Color=} obj               Optional
 * @return {?}
 */
dojo.main.prototype.colorFromString = function(str, obj) {};

/**
 * dojo.connect is a deprecated event handling and delegation method in
 * Dojo. It allows one function to "listen in" on the execution of
 * any other, triggering the second whenever the first is called. Many
 * listeners may be attached to a function, and source functions may
 * be either regular function calls or DOM events.
 * Connects listeners to actions, so that after event fires, a
 * listener is called with the same arguments passed to the original
 * function.
 * 
 * Since dojo.connect allows the source of events to be either a
 * "regular" JavaScript function or a DOM event, it provides a uniform
 * interface for listening to all the types of events that an
 * application is likely to deal with though a single, unified
 * interface. DOM programmers may want to think of it as
 * "addEventListener for everything and anything".
 * 
 * When setting up a connection, the event parameter must be a
 * string that is the name of the method/event to be listened for. If
 * obj is null, kernel.global is assumed, meaning that connections
 * to global methods are supported but also that you may inadvertently
 * connect to a global by passing an incorrect object name or invalid
 * reference.
 * 
 * dojo.connect generally is forgiving. If you pass the name of a
 * function or method that does not yet exist on obj, connect will
 * not fail, but will instead set up a stub method. Similarly, null
 * arguments may simply be omitted such that fewer than 4 arguments
 * may be required to set up a connection See the examples for details.
 * 
 * The return value is a handle that is needed to
 * remove this connection with dojo.disconnect.
 * 
 * dojo.connect is a deprecated event handling and delegation method in
 * Dojo. It allows one function to "listen in" on the execution of
 * any other, triggering the second whenever the first is called. Many
 * listeners may be attached to a function, and source functions may
 * be either regular function calls or DOM events.
 * Connects listeners to actions, so that after event fires, a
 * listener is called with the same arguments passed to the original
 * function.
 * 
 * Since dojo.connect allows the source of events to be either a
 * "regular" JavaScript function or a DOM event, it provides a uniform
 * interface for listening to all the types of events that an
 * application is likely to deal with though a single, unified
 * interface. DOM programmers may want to think of it as
 * "addEventListener for everything and anything".
 * 
 * When setting up a connection, the event parameter must be a
 * string that is the name of the method/event to be listened for. If
 * obj is null, kernel.global is assumed, meaning that connections
 * to global methods are supported but also that you may inadvertently
 * connect to a global by passing an incorrect object name or invalid
 * reference.
 * 
 * dojo.connect generally is forgiving. If you pass the name of a
 * function or method that does not yet exist on obj, connect will
 * not fail, but will instead set up a stub method. Similarly, null
 * arguments may simply be omitted such that fewer than 4 arguments
 * may be required to set up a connection See the examples for details.
 * 
 * The return value is a handle that is needed to
 * remove this connection with dojo.disconnect.
 * 
 * dojo.connect is a deprecated event handling and delegation method in
 * Dojo. It allows one function to "listen in" on the execution of
 * any other, triggering the second whenever the first is called. Many
 * listeners may be attached to a function, and source functions may
 * be either regular function calls or DOM events.
 * Connects listeners to actions, so that after event fires, a
 * listener is called with the same arguments passed to the original
 * function.
 * 
 * Since dojo.connect allows the source of events to be either a
 * "regular" JavaScript function or a DOM event, it provides a uniform
 * interface for listening to all the types of events that an
 * application is likely to deal with though a single, unified
 * interface. DOM programmers may want to think of it as
 * "addEventListener for everything and anything".
 * 
 * When setting up a connection, the event parameter must be a
 * string that is the name of the method/event to be listened for. If
 * obj is null, kernel.global is assumed, meaning that connections
 * to global methods are supported but also that you may inadvertently
 * connect to a global by passing an incorrect object name or invalid
 * reference.
 * 
 * dojo.connect generally is forgiving. If you pass the name of a
 * function or method that does not yet exist on obj, connect will
 * not fail, but will instead set up a stub method. Similarly, null
 * arguments may simply be omitted such that fewer than 4 arguments
 * may be required to set up a connection See the examples for details.
 * 
 * The return value is a handle that is needed to
 * remove this connection with dojo.disconnect.
 * 
 * dojo.connect is a deprecated event handling and delegation method in
 * Dojo. It allows one function to "listen in" on the execution of
 * any other, triggering the second whenever the first is called. Many
 * listeners may be attached to a function, and source functions may
 * be either regular function calls or DOM events.
 * Connects listeners to actions, so that after event fires, a
 * listener is called with the same arguments passed to the original
 * function.
 * 
 * Since dojo.connect allows the source of events to be either a
 * "regular" JavaScript function or a DOM event, it provides a uniform
 * interface for listening to all the types of events that an
 * application is likely to deal with though a single, unified
 * interface. DOM programmers may want to think of it as
 * "addEventListener for everything and anything".
 * 
 * When setting up a connection, the event parameter must be a
 * string that is the name of the method/event to be listened for. If
 * obj is null, kernel.global is assumed, meaning that connections
 * to global methods are supported but also that you may inadvertently
 * connect to a global by passing an incorrect object name or invalid
 * reference.
 * 
 * dojo.connect generally is forgiving. If you pass the name of a
 * function or method that does not yet exist on obj, connect will
 * not fail, but will instead set up a stub method. Similarly, null
 * arguments may simply be omitted such that fewer than 4 arguments
 * may be required to set up a connection See the examples for details.
 * 
 * The return value is a handle that is needed to
 * remove this connection with dojo.disconnect.
 * 
 * @param {!Object} obj               OptionalThe source object for the event function.Defaults to kernel.global if null.If obj is a DOM node, the connection is delegatedto the DOM event manager (unless dontFix is true).
 * @param {!String} event String name of the event function in obj.I.e. identifies a property obj[event].
 * @param {!Object|?} context The object that method will receive as "this".If context is null and method is a function, then methodinherits the context of event.If method is a string then context must be the sourceobject object for method (context[method]). If context is null,kernel.global is used.
 * @param {!String|!Function} method A function reference, or name of a function in context.The function identified by method fires after event does.method receives the same arguments as the event.See context argument comments for information on method's scope.
 * @param {boolean=} dontFix               OptionalIf obj is a DOM node, set dontFix to true to prevent delegationof this connection to the DOM event manager.
 * @return {?}
 */
dojo.main.prototype.connect = function(obj, event, context, method, dontFix) {};

/**
 * Getter/setter for the content-box of node.
 * Returns an object in the expected format of box (regardless if box is passed).
 * The object might look like:
 * { l: 50, t: 200, w: 300: h: 150 }
 * for a node offset from its parent 50px to the left, 200px from
 * the top with a content width of 300px and a content-height of
 * 150px. Note that the content box may have a much larger border
 * or margin box, depending on the box model currently in use and
 * CSS values set/inherited for node.
 * While the getter will return top and left values, the
 * setter only accepts setting the width and height.
 * 
 * Getter/setter for the content-box of node.
 * Returns an object in the expected format of box (regardless if box is passed).
 * The object might look like:
 * { l: 50, t: 200, w: 300: h: 150 }
 * for a node offset from its parent 50px to the left, 200px from
 * the top with a content width of 300px and a content-height of
 * 150px. Note that the content box may have a much larger border
 * or margin box, depending on the box model currently in use and
 * CSS values set/inherited for node.
 * While the getter will return top and left values, the
 * setter only accepts setting the width and height.
 * 
 * @param {!HTMLElement|!String} node id or reference to DOM Node to get/set box for
 * @param {!Object=} box               OptionalIf passed, denotes that dojo.contentBox() shouldupdate/set the content box for node. Box is an object in theabove format, but only w (width) and h (height) are supported.All properties are optional if passed.
 * @return {?}
 */
dojo.main.prototype.contentBox = function(node, box) {};

/**
 * Get or set a cookie.
 * If one argument is passed, returns the value of the cookie
 * For two or more arguments, acts as a setter.
 * 
 * @param {!String} name Name of the cookie
 * @param {!String=} value               OptionalValue for the cookie
 * @param {!Object=} props               OptionalProperties for the cookie
 * @return {?}
 */
dojo.main.prototype.cookie = function(name, value, props) {};

/**
 * Deprecated: Use position() for border-box x/y/w/h
 * or marginBox() for margin-box w/h/l/t.
 * 
 * Returns an object that measures margin-box (w)idth/(h)eight
 * and absolute position x/y of the border-box. Also returned
 * is computed (l)eft and (t)op values in pixels from the
 * node's offsetParent as returned from marginBox().
 * Return value will be in the form:
 * 
 * { l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }
 * Does not act as a setter. If includeScroll is passed, the x and
 * 
 * y params are affected as one would expect in dojo.position().
 * 
 * Deprecated: Use position() for border-box x/y/w/h
 * or marginBox() for margin-box w/h/l/t.
 * 
 * Returns an object that measures margin-box (w)idth/(h)eight
 * and absolute position x/y of the border-box. Also returned
 * is computed (l)eft and (t)op values in pixels from the
 * node's offsetParent as returned from marginBox().
 * Return value will be in the form:
 * 
 * { l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }
 * Does not act as a setter. If includeScroll is passed, the x and
 * 
 * y params are affected as one would expect in dojo.position().
 * 
 * @param {!HTMLElement|!String} node
 * @param {boolean=} includeScroll               Optional
 * @return {?}
 */
dojo.main.prototype.coords = function(node, includeScroll) {};

/**
 * Create an element, allowing for optional attribute decoration
 * and placement.
 * A DOM Element creation function. A shorthand method for creating a node or
 * a fragment, and allowing for a convenient optional attribute setting step,
 * as well as an optional DOM placement reference.
 * 
 * Attributes are set by passing the optional object through dojo.setAttr.
 * See dojo.setAttr for noted caveats and nuances, and API if applicable.
 * 
 * Placement is done via dojo.place, assuming the new node to be the action
 * node, passing along the optional reference node and position.
 * 
 * Create an element, allowing for optional attribute decoration
 * and placement.
 * A DOM Element creation function. A shorthand method for creating a node or
 * a fragment, and allowing for a convenient optional attribute setting step,
 * as well as an optional DOM placement reference.
 * 
 * Attributes are set by passing the optional object through dojo.setAttr.
 * See dojo.setAttr for noted caveats and nuances, and API if applicable.
 * 
 * Placement is done via dojo.place, assuming the new node to be the action
 * node, passing along the optional reference node and position.
 * 
 * Create an element, allowing for optional attribute decoration
 * and placement.
 * A DOM Element creation function. A shorthand method for creating a node or
 * a fragment, and allowing for a convenient optional attribute setting step,
 * as well as an optional DOM placement reference.
 * 
 * Attributes are set by passing the optional object through dojo.setAttr.
 * See dojo.setAttr for noted caveats and nuances, and API if applicable.
 * 
 * Placement is done via dojo.place, assuming the new node to be the action
 * node, passing along the optional reference node and position.
 * 
 * Create an element, allowing for optional attribute decoration
 * and placement.
 * A DOM Element creation function. A shorthand method for creating a node or
 * a fragment, and allowing for a convenient optional attribute setting step,
 * as well as an optional DOM placement reference.
 * 
 * Attributes are set by passing the optional object through dojo.setAttr.
 * See dojo.setAttr for noted caveats and nuances, and API if applicable.
 * 
 * Placement is done via dojo.place, assuming the new node to be the action
 * node, passing along the optional reference node and position.
 * 
 * @param {!HTMLElement|!String} tag A string of the element to create (eg: "div", "a", "p", "li", "script", "br"),or an existing DOM node to process.
 * @param {!Object} attrs An object-hash of attributes to set on the newly created node.Can be null, if you don't want to set any attributes/styles.See: dojo.setAttr for a description of available attributes.
 * @param {!HTMLElement|!String=} refNode               OptionalOptional reference node. Used by dojo.place to place the newly creatednode somewhere in the dom relative to refNode. Can be a DomNode referenceor String ID of a node.
 * @param {!String=} pos               OptionalOptional positional reference. Defaults to "last" by way of dojo.place,though can be set to "first","after","before","last", "replace" or "only"to further control the placement of the new node relative to the refNode.'refNode' is required if a 'pos' is specified.
 * @return {?}
 */
dojo.main.prototype.create = function(tag, attrs, refNode, pos) {};

/**
 * Create a feature-rich constructor from compact notation.
 * Create a constructor using a compact notation for inheritance and
 * prototype extension.
 * 
 * Mixin ancestors provide a type of multiple inheritance.
 * Prototypes of mixin ancestors are copied to the new class:
 * changes to mixin prototypes will not affect classes to which
 * they have been mixed in.
 * 
 * Ancestors can be compound classes created by this version of
 * declare(). In complex cases all base classes are going to be
 * linearized according to C3 MRO algorithm
 * (see http://www.python.org/download/releases/2.3/mro/ for more
 * details).
 * 
 * "className" is cached in "declaredClass" property of the new class,
 * if it was supplied. The immediate super class will be cached in
 * "superclass" property of the new class.
 * 
 * Methods in "props" will be copied and modified: "nom" property
 * (the declared name of the method) will be added to all copied
 * functions to help identify them for the internal machinery. Be
 * very careful, while reusing methods: if you use the same
 * function under different names, it can produce errors in some
 * cases.
 * 
 * It is possible to use constructors created "manually" (without
 * declare()) as bases. They will be called as usual during the
 * creation of an instance, their methods will be chained, and even
 * called by "this.inherited()".
 * 
 * Special property "-chains-" governs how to chain methods. It is
 * a dictionary, which uses method names as keys, and hint strings
 * as values. If a hint string is "after", this method will be
 * called after methods of its base classes. If a hint string is
 * "before", this method will be called before methods of its base
 * classes.
 * 
 * If "constructor" is not mentioned in "-chains-" property, it will
 * be chained using the legacy mode: using "after" chaining,
 * calling preamble() method before each constructor, if available,
 * and calling postscript() after all constructors were executed.
 * If the hint is "after", it is chained as a regular method, but
 * postscript() will be called after the chain of constructors.
 * "constructor" cannot be chained "before", but it allows
 * a special hint string: "manual", which means that constructors
 * are not going to be chained in any way, and programmer will call
 * them manually using this.inherited(). In the latter case
 * postscript() will be called after the construction.
 * 
 * All chaining hints are "inherited" from base classes and
 * potentially can be overridden. Be very careful when overriding
 * hints! Make sure that all chained methods can work in a proposed
 * manner of chaining.
 * 
 * Once a method was chained, it is impossible to unchain it. The
 * only exception is "constructor". You don't need to define a
 * method in order to supply a chaining hint.
 * 
 * If a method is chained, it cannot use this.inherited() because
 * all other methods in the hierarchy will be called automatically.
 * 
 * Usually constructors and initializers of any kind are chained
 * using "after" and destructors of any kind are chained as
 * "before". Note that chaining assumes that chained methods do not
 * return any value: any returned value will be discarded.
 * 
 * Create a feature-rich constructor from compact notation.
 * Create a constructor using a compact notation for inheritance and
 * prototype extension.
 * 
 * Mixin ancestors provide a type of multiple inheritance.
 * Prototypes of mixin ancestors are copied to the new class:
 * changes to mixin prototypes will not affect classes to which
 * they have been mixed in.
 * 
 * Ancestors can be compound classes created by this version of
 * declare(). In complex cases all base classes are going to be
 * linearized according to C3 MRO algorithm
 * (see http://www.python.org/download/releases/2.3/mro/ for more
 * details).
 * 
 * "className" is cached in "declaredClass" property of the new class,
 * if it was supplied. The immediate super class will be cached in
 * "superclass" property of the new class.
 * 
 * Methods in "props" will be copied and modified: "nom" property
 * (the declared name of the method) will be added to all copied
 * functions to help identify them for the internal machinery. Be
 * very careful, while reusing methods: if you use the same
 * function under different names, it can produce errors in some
 * cases.
 * 
 * It is possible to use constructors created "manually" (without
 * declare()) as bases. They will be called as usual during the
 * creation of an instance, their methods will be chained, and even
 * called by "this.inherited()".
 * 
 * Special property "-chains-" governs how to chain methods. It is
 * a dictionary, which uses method names as keys, and hint strings
 * as values. If a hint string is "after", this method will be
 * called after methods of its base classes. If a hint string is
 * "before", this method will be called before methods of its base
 * classes.
 * 
 * If "constructor" is not mentioned in "-chains-" property, it will
 * be chained using the legacy mode: using "after" chaining,
 * calling preamble() method before each constructor, if available,
 * and calling postscript() after all constructors were executed.
 * If the hint is "after", it is chained as a regular method, but
 * postscript() will be called after the chain of constructors.
 * "constructor" cannot be chained "before", but it allows
 * a special hint string: "manual", which means that constructors
 * are not going to be chained in any way, and programmer will call
 * them manually using this.inherited(). In the latter case
 * postscript() will be called after the construction.
 * 
 * All chaining hints are "inherited" from base classes and
 * potentially can be overridden. Be very careful when overriding
 * hints! Make sure that all chained methods can work in a proposed
 * manner of chaining.
 * 
 * Once a method was chained, it is impossible to unchain it. The
 * only exception is "constructor". You don't need to define a
 * method in order to supply a chaining hint.
 * 
 * If a method is chained, it cannot use this.inherited() because
 * all other methods in the hierarchy will be called automatically.
 * 
 * Usually constructors and initializers of any kind are chained
 * using "after" and destructors of any kind are chained as
 * "before". Note that chaining assumes that chained methods do not
 * return any value: any returned value will be discarded.
 * 
 * @param {!String} className               OptionalThe optional name of the constructor (loosely, a "class")stored in the "declaredClass" property in the created prototype.It will be used as a global name for a created constructor.
 * @param {!Function|!Array<!Function>} superclass May be null, a Function, or an Array of Functions. This argumentspecifies a list of bases (the left-most one is the most deepestbase).
 * @param {!Object} props An object whose properties are copied to the created prototype.Add an instance-initialization function by making it a propertynamed "constructor".
 * @return {!dojo._base.declare.__DeclareCreatedObject}
 */
dojo.main.prototype.declare = function(className, superclass, props) {};

/**
 * Deprecated.   This module defines the legacy dojo/_base/Deferred API.
 * New code should use dojo/Deferred instead.
 * The Deferred API is based on the concept of promises that provide a
 * generic interface into the eventual completion of an asynchronous action.
 * The motivation for promises fundamentally is about creating a
 * separation of concerns that allows one to achieve the same type of
 * call patterns and logical data flow in asynchronous code as can be
 * achieved in synchronous code. Promises allows one
 * to be able to call a function purely with arguments needed for
 * execution, without conflating the call with concerns of whether it is
 * sync or async. One shouldn't need to alter a call's arguments if the
 * implementation switches from sync to async (or vice versa). By having
 * async functions return promises, the concerns of making the call are
 * separated from the concerns of asynchronous interaction (which are
 * handled by the promise).
 * 
 * The Deferred is a type of promise that provides methods for fulfilling the
 * promise with a successful result or an error. The most important method for
 * working with Dojo's promises is the then() method, which follows the
 * CommonJS proposed promise API. An example of using a Dojo promise:
 * 
 * var resultingPromise = someAsyncOperation.then(function(result){
 *     ... handle result ...
 * },
 * function(error){
 *     ... handle error ...
 * });
 * The .then() call returns a new promise that represents the result of the
 * execution of the callback. The callbacks will never affect the original promises value.
 * 
 * The Deferred instances also provide the following functions for backwards compatibility:
 * 
 * addCallback(handler)
 * addErrback(handler)
 * callback(result)
 * errback(result)
 * Callbacks are allowed to return promises themselves, so
 * you can build complicated sequences of events with ease.
 * 
 * The creator of the Deferred may specify a canceller.  The canceller
 * is a function that will be called if Deferred.cancel is called
 * before the Deferred fires. You can use this to implement clean
 * aborting of an XMLHttpRequest, etc. Note that cancel will fire the
 * deferred with a CancelledError (unless your canceller returns
 * another kind of error), so the errbacks should be prepared to
 * handle that error for cancellable Deferreds.
 * 
 * @param {!Function} canceller               Optional
 * @return {void}
 */
dojo.main.prototype.Deferred = function(canceller) {};

/**
 * Deprecated, use dojo/promise/all instead.
 * Provides event handling for a group of Deferred objects.
 * DeferredList takes an array of existing deferreds and returns a new deferred of its own
 * this new deferred will typically have its callback fired when all of the deferreds in
 * the given list have fired their own deferreds.  The parameters fireOnOneCallback and
 * fireOnOneErrback, will fire before all the deferreds as appropriate
 * 
 * @param {!Array<?>} list The list of deferreds to be synchronizied with this DeferredList
 * @param {boolean=} fireOnOneCallback               OptionalWill cause the DeferredLists callback to be fired as soon as anyof the deferreds in its list have been fired instead of waiting untilthe entire list has finished
 * @param {boolean=} fireOnOneErrback               Optional
 * @param {boolean=} consumeErrors               Optional
 * @param {!Function=} canceller               OptionalA deferred canceller function, see dojo.Deferred
 * @return {void}
 */
dojo.main.prototype.DeferredList = function(list, fireOnOneCallback, fireOnOneErrback, consumeErrors, canceller) {};

/**
 * Log a debug message to indicate that a behavior has been
 * deprecated.
 * 
 * @param {!String} behaviour The API or behavior being deprecated. Usually in the formof "myApp.someFunction()".
 * @param {!String=} extra               OptionalText to append to the message. Often provides advice on anew function or facility to achieve the same goal duringthe deprecation period.
 * @param {!String=} removal               OptionalText to indicate when in the future the behavior will beremoved. Usually a version number.
 * @return {void}
 */
dojo.main.prototype.deprecated = function(behaviour, extra, removal) {};

/**
 *
 * @param {?} node
 * @return {void}
 */
dojo.main.prototype.destroy = function(node) {};

/**
 * Remove a link created by dojo.connect.
 * Removes the connection between event and the method referenced by handle.
 * 
 * @param {!Object} handle the return value of the dojo.connect call that created the connection.
 * @return {void}
 */
dojo.main.prototype.disconnect = function(handle) {};

/**
 * Returns an object with {node, x, y} with corresponding offsets.
 * 
 * @param {!HTMLDocument=} doc               OptionalOptional document to query.   If unspecified, use win.doc.
 * @return {!Object}
 */
dojo.main.prototype.docScroll = function(doc) {};

/**
 *
 * @param {?} node
 * @return {void}
 */
dojo.main.prototype.empty = function(node) {};

/**
 * A legacy method created for use exclusively by internal Dojo methods. Do not use this method
 * directly unless you understand its possibly-different implications on the platforms your are targeting.
 * Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
 * that support indirect eval.
 * 
 * As usual, IE does not. On IE, the only way to implement global eval is to
 * use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
 * This implementation uses the technique of executing eval in the scope of a function that is a single scope
 * frame below the global scope; thereby coming close to the global scope. Note carefully that
 * 
 * dojo.eval("var pi = 3.14;");
 * 
 * will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
 * to define a global variable using dojo.eval, write something like
 * 
 * dojo.eval("window.pi = 3.14;")
 * 
 * @param {?} scriptText The text to evaluation.
 * @return {?}
 */
dojo.main.prototype.eval = function(scriptText) {};

/**
 * Determines whether or not every item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
 * 
 * Determines whether or not every item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
 * 
 * Determines whether or not every item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
 * 
 * Determines whether or not every item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
 * 
 * @param {!Array<?>|!String} arr the array to iterate on. If a string, operates on individual characters.
 * @param {!Function|!String} callback a function is invoked with three arguments: item, index,and array and returns true if the condition is met.
 * @param {!Object=} thisObject               Optionalmay be used to scope the call to callback
 * @return {boolean}
 */
dojo.main.prototype.every = function(arr, callback, thisObject) {};

/**
 *
 * @param {?} exitcode
 * @return {void}
 */
dojo.main.prototype.exit = function(exitcode) {};

/**
 * Marks code as experimental.
 * This can be used to mark a function, file, or module as
 * experimental.    Experimental code is not ready to be used, and the
 * APIs are subject to change without notice.  Experimental code may be
 * completed deleted without going through the normal deprecation
 * process.
 * 
 * @param {!String} moduleName The name of a module, or the name of a module file or a specificfunction
 * @param {!String=} extra               Optionalsome additional message for the user
 * @return {void}
 */
dojo.main.prototype.experimental = function(moduleName, extra) {};

/**
 * Returns an animation that will fade node defined in 'args' from
 * its current opacity to fully opaque.
 * 
 * @param {!Object} args An object with the following properties:node (DOMNode|String): The node referenced in the animationduration (Integer, optional): Duration of the animation in milliseconds.easing (Function, optional): An easing function.
 * @return {?}
 */
dojo.main.prototype.fadeIn = function(args) {};

/**
 * Returns an animation that will fade node defined in 'args'
 * from its current opacity to fully transparent.
 * 
 * @param {!Object} args An object with the following properties:node (DOMNode|String): The node referenced in the animationduration (Integer, optional): Duration of the animation in milliseconds.easing (Function, optional): An easing function.
 * @return {?}
 */
dojo.main.prototype.fadeOut = function(args) {};

/**
 * Serialize a form field to a JavaScript object.
 * Returns the value encoded in a form field as
 * as a string or an array of strings. Disabled form elements
 * and unchecked radio and checkboxes are skipped. Multi-select
 * elements are returned as an array of string values.
 * 
 * Serialize a form field to a JavaScript object.
 * Returns the value encoded in a form field as
 * as a string or an array of strings. Disabled form elements
 * and unchecked radio and checkboxes are skipped. Multi-select
 * elements are returned as an array of string values.
 * 
 * @param {!HTMLElement|!String} inputNode
 * @return {!Object}
 */
dojo.main.prototype.fieldToObject = function(inputNode) {};

/**
 * Returns a new Array with those items from arr that match the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
 * 
 * Returns a new Array with those items from arr that match the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
 * 
 * @param {!Array<?>} arr the array to iterate over.
 * @param {!Function|!String} callback a function that is invoked with three arguments (item,index, array). The return of this function is expected tobe a boolean which determines whether the passed-in itemwill be included in the returned array.
 * @param {!Object=} thisObject               Optionalmay be used to scope the call to callback
 * @return {!Array<?>}
 */
dojo.main.prototype.filter = function(arr, callback, thisObject) {};

/**
 * normalizes properties on the event object including event
 * bubbling methods, keystroke normalization, and x/y positions
 * 
 * @param {!Event} evt native event object
 * @param {!HTMLElement} sender node to treat as "currentTarget"
 * @return {!Event}
 */
dojo.main.prototype.fixEvent = function(evt, sender) {};

/**
 * In RTL direction, scrollLeft should be a negative value, but IE
 * returns a positive one. All codes using documentElement.scrollLeft
 * must call this function to fix this error, otherwise the position
 * will offset to right when there is a horizontal scrollbar.
 * 
 * @param {number} scrollLeft
 * @param {!HTMLDocument=} doc               OptionalOptional document to query.   If unspecified, use win.doc.
 * @return {number}
 */
dojo.main.prototype.fixIeBiDiScrollLeft = function(scrollLeft, doc) {};

/**
 * for every item in arr, callback is invoked. Return values are ignored.
 * If you want to break out of the loop, consider using array.every() or array.some().
 * forEach does not allow breaking out of the loop over the items in arr.
 * This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
 * 
 * for every item in arr, callback is invoked. Return values are ignored.
 * If you want to break out of the loop, consider using array.every() or array.some().
 * forEach does not allow breaking out of the loop over the items in arr.
 * This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
 * 
 * for every item in arr, callback is invoked. Return values are ignored.
 * If you want to break out of the loop, consider using array.every() or array.some().
 * forEach does not allow breaking out of the loop over the items in arr.
 * This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
 * 
 * for every item in arr, callback is invoked. Return values are ignored.
 * If you want to break out of the loop, consider using array.every() or array.some().
 * forEach does not allow breaking out of the loop over the items in arr.
 * This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
 * 
 * @param {!Array<?>|!String} arr
 * @param {!Function|!String} callback
 * @param {!Object=} thisObject               Optional
 * @return {void}
 */
dojo.main.prototype.forEach = function(arr, callback, thisObject) {};

/**
 * Create a serialized JSON string from a form node or string
 * ID identifying the form to serialize
 * 
 * Create a serialized JSON string from a form node or string
 * ID identifying the form to serialize
 * 
 * @param {!HTMLElement|!String} formNode
 * @param {boolean=} prettyPrint               Optional
 * @return {!String}
 */
dojo.main.prototype.formToJson = function(formNode, prettyPrint) {};

/**
 * Serialize a form node to a JavaScript object.
 * Returns the values encoded in an HTML form as
 * string properties in an object which it then returns. Disabled form
 * elements, buttons, and other non-value form elements are skipped.
 * Multi-select elements are returned as an array of string values.
 * 
 * Serialize a form node to a JavaScript object.
 * Returns the values encoded in an HTML form as
 * string properties in an object which it then returns. Disabled form
 * elements, buttons, and other non-value form elements are skipped.
 * Multi-select elements are returned as an array of string values.
 * 
 * @param {!HTMLElement|!String} formNode
 * @return {!Object}
 */
dojo.main.prototype.formToObject = function(formNode) {};

/**
 * Returns a URL-encoded string representing the form passed as either a
 * node or string ID identifying the form to serialize
 * 
 * Returns a URL-encoded string representing the form passed as either a
 * node or string ID identifying the form to serialize
 * 
 * @param {!HTMLElement|!String} formNode
 * @return {!String}
 */
dojo.main.prototype.formToQuery = function(formNode) {};

/**
 * Parses a JavaScript expression and returns a JavaScript value.
 * Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
 * always delegates to eval(). The content passed to this method must therefore come
 * from a trusted source.
 * It is recommend that you use dojo/json's parse function for an
 * implementation uses the (faster) native JSON parse when available.
 * 
 * @param {!String} js a string literal of a JavaScript expression, for instance:'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'
 * @return {?}
 */
dojo.main.prototype.fromJson = function(js) {};

/**
 * Gets an attribute on an HTML element.
 * Handles normalized getting of attributes on DOM Nodes.
 * 
 * Gets an attribute on an HTML element.
 * Handles normalized getting of attributes on DOM Nodes.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to get the attribute on
 * @param {!String} name the name of the attribute to get.
 * @return {?}
 */
dojo.main.prototype.getAttr = function(node, name) {};

/**
 * returns an object with properties useful for noting the border
 * dimensions.
 * l/t/r/b = the sum of left/top/right/bottom border (respectively)
 * w = the sum of the left and right border
 * h = the sum of the top and bottom border
 * The w/h are used for calculating boxes.
 * Normally application code will not need to invoke this
 * directly, and will use the ...box... functions instead.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo.main.prototype.getBorderExtents = function(node, computedStyle) {};

/**
 * Returns a "computed style" object.
 * Gets a "computed style" object which can be used to gather
 * information about the current state of the rendered node.
 * 
 * Note that this may behave differently on different browsers.
 * Values may have different formats and value encodings across
 * browsers.
 * 
 * Note also that this method is expensive.  Wherever possible,
 * reuse the returned object.
 * 
 * Use the dojo/dom-style.get() method for more consistent (pixelized)
 * return values.
 * 
 * @param {!HTMLElement} node A reference to a DOM node. Does NOT support taking anID string for speed reasons.
 * @return {void}
 */
dojo.main.prototype.getComputedStyle = function(node) {};

/**
 * Returns an object that encodes the width, height, left and top
 * positions of the node's content box, irrespective of the
 * current box model.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo.main.prototype.getContentBox = function(node, computedStyle) {};

/**
 * returns the offset in x and y from the document body to the
 * visual edge of the page for IE
 * The following values in IE contain an offset:
 * 
 * event.clientX
 * event.clientY
 * node.getBoundingClientRect().left
 * node.getBoundingClientRect().top
 * But other position related values do not contain this offset,
 * 
 * such as node.offsetLeft, node.offsetTop, node.style.left and
 * node.style.top. The offset is always (2, 2) in LTR direction.
 * When the body is in RTL direction, the offset counts the width
 * of left scroll bar's width.  This function computes the actual
 * offset.
 * 
 * @param {!HTMLDocument=} doc               OptionalOptional document to query.   If unspecified, use win.doc.
 * @return {!Object}
 */
dojo.main.prototype.getIeDocumentElementOffset = function(doc) {};

/**
 *
 * @param {?} moduleName
 * @param {?} bundleName
 * @param {?} locale
 * @return {!String}
 */
dojo.main.prototype.getL10nName = function(moduleName, bundleName, locale) {};

/**
 * returns an object that encodes the width, height, left and top
 * positions of the node's margin box.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo.main.prototype.getMarginBox = function(node, computedStyle) {};

/**
 * returns object with properties useful for box fitting with
 * regards to box margins (i.e., the outer-box).
 * 
 * l/t = marginLeft, marginTop, respectively
 * w = total width, margin inclusive
 * h = total height, margin inclusive
 * The w/h are used for calculating boxes.
 * Normally application code will not need to invoke this
 * directly, and will use the ...box... functions instead.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo.main.prototype.getMarginExtents = function(node, computedStyle) {};

/**
 * returns an object that encodes the width and height of
 * the node's margin box
 * 
 * returns an object that encodes the width and height of
 * the node's margin box
 * 
 * @param {!HTMLElement|!String} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo.main.prototype.getMarginSize = function(node, computedStyle) {};

/**
 * Returns an effective value of a property or an attribute.
 * 
 * Returns an effective value of a property or an attribute.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to remove the attribute from
 * @param {!String} name the name of the attribute
 * @return {?}
 */
dojo.main.prototype.getNodeProp = function(node, name) {};

/**
 * Returns object with properties useful for box fitting with
 * regards to padding.
 * l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
 * w = the sum of the left and right padding and border
 * h = the sum of the top and bottom padding and border
 * The w/h are used for calculating boxes.
 * Normally application code will not need to invoke this
 * directly, and will use the ...box... functions instead.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo.main.prototype.getPadBorderExtents = function(node, computedStyle) {};

/**
 * Returns object with special values specifically useful for node
 * fitting.
 * Returns an object with w, h, l, t properties:
 * 
 * l/t/r/b = left/top/right/bottom padding (respectively)
 * w = the total of the left and right padding
 * h = the total of the top and bottom padding
 * If 'node' has position, l/t forms the origin for child nodes.
 * 
 * The w/h are used for calculating boxes.
 * Normally application code will not need to invoke this
 * directly, and will use the ...box... functions instead.
 * 
 * @param {!HTMLElement} node
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {!Object}
 */
dojo.main.prototype.getPadExtents = function(node, computedStyle) {};

/**
 * Gets a property on an HTML element.
 * Handles normalized getting of properties on DOM nodes.
 * 
 * Gets a property on an HTML element.
 * Handles normalized getting of properties on DOM nodes.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to get the property on
 * @param {!String} name the name of the property to get.
 * @return {?}
 */
dojo.main.prototype.getProp = function(node, name) {};

/**
 * Accesses styles on a node.
 * Getting the style value uses the computed style for the node, so the value
 * will be a calculated value, not just the immediate node.style value.
 * Also when getting values, use specific style names,
 * like "borderBottomWidth" instead of "border" since compound values like
 * "border" are not necessarily reflected as expected.
 * If you want to get node dimensions, use dojo/dom-geometry.getMarginBox(),
 * dojo/dom-geometry.getContentBox() or dojo/dom-geometry.getPosition().
 * 
 * Accesses styles on a node.
 * Getting the style value uses the computed style for the node, so the value
 * will be a calculated value, not just the immediate node.style value.
 * Also when getting values, use specific style names,
 * like "borderBottomWidth" instead of "border" since compound values like
 * "border" are not necessarily reflected as expected.
 * If you want to get node dimensions, use dojo/dom-geometry.getMarginBox(),
 * dojo/dom-geometry.getContentBox() or dojo/dom-geometry.getPosition().
 * 
 * @param {!HTMLElement|!String} node id or reference to node to get style for
 * @param {!String=} name               Optionalthe style property to get
 * @return {?}
 */
dojo.main.prototype.getStyle = function(node, name) {};

/**
 * Returns true if the requested attribute is specified on the
 * given element, and false otherwise.
 * 
 * Returns true if the requested attribute is specified on the
 * given element, and false otherwise.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to check
 * @param {!String} name the name of the attribute
 * @return {boolean}
 */
dojo.main.prototype.hasAttr = function(node, name) {};

/**
 * Returns whether or not the specified classes are a portion of the
 * class list currently applied to the node.
 * 
 * Returns whether or not the specified classes are a portion of the
 * class list currently applied to the node.
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to check the class for.
 * @param {!String} classStr A string class name to look for.
 * @return {boolean}
 */
dojo.main.prototype.hasClass = function(node, classStr) {};

/**
 * Gets or sets the hash string in the browser URL.
 * Handles getting and setting of location.hash.
 * 
 * If no arguments are passed, acts as a getter.
 * If a string is passed, acts as a setter.
 * 
 * @param {!String=} hash               Optionalthe hash is set - #string.
 * @param {boolean=} replace               OptionalIf true, updates the hash value in the current historystate instead of creating a new history state.
 * @return {?}
 */
dojo.main.prototype.hash = function(hash, replace) {};

/**
 * locates the first index of the provided value in the
 * passed array. If the value is not found, -1 is returned.
 * This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:
 * 
 * when run over sparse arrays, the Dojo function invokes the callback for every index
 * whereas JavaScript 1.6's indexOf skips the holes in the sparse array.
 * uses equality (==) rather than strict equality (===)
 * For details on this method, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf
 * 
 * @param {!Array<?>} arr
 * @param {!Object} value
 * @param {number=} fromIndex               Optional
 * @param {boolean=} findLast               OptionalMakes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.
 * @return {number}
 */
dojo.main.prototype.indexOf = function(arr, value, fromIndex, findLast) {};

/**
 * Returns true if the current language is left-to-right, and false otherwise.
 * 
 * @param {!HTMLDocument=} doc               OptionalOptional document to query.   If unspecified, use win.doc.
 * @return {boolean}
 */
dojo.main.prototype.isBodyLtr = function(doc) {};

/**
 * Returns true if node is a descendant of ancestor
 * 
 * Returns true if node is a descendant of ancestor
 * 
 * Returns true if node is a descendant of ancestor
 * 
 * Returns true if node is a descendant of ancestor
 * 
 * @param {!HTMLElement|!String} node string id or node reference to test
 * @param {!HTMLElement|!String} ancestor string id or node reference of potential parent to test against
 * @return {boolean}
 */
dojo.main.prototype.isDescendant = function(node, ancestor) {};

/**
 * locates the last index of the provided value in the passed
 * array. If the value is not found, -1 is returned.
 * This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:
 * 
 * when run over sparse arrays, the Dojo function invokes the callback for every index
 * whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.
 * uses equality (==) rather than strict equality (===)
 * For details on this method, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf
 * 
 * @param {?} arr
 * @param {?} value
 * @param {number=} fromIndex               Optional
 * @return {number}
 */
dojo.main.prototype.lastIndexOf = function(arr, value, fromIndex) {};

/**
 *
 * @param {?} f
 * @return {void}
 */
dojo.main.prototype.loadInit = function(f) {};

/**
 * applies callback to each element of arr and returns
 * an Array with the results
 * This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
 * 
 * applies callback to each element of arr and returns
 * an Array with the results
 * This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
 * 
 * applies callback to each element of arr and returns
 * an Array with the results
 * This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
 * 
 * applies callback to each element of arr and returns
 * an Array with the results
 * This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
 * 
 * @param {!Array<?>|!String} arr the array to iterate on. If a string, operates onindividual characters.
 * @param {!Function|!String} callback a function is invoked with three arguments, (item, index,array),  and returns a value
 * @param {!Object} thisObject               Optionalmay be used to scope the call to callback
 * @param {?} Ctr
 * @return {!Array<?>}
 */
dojo.main.prototype.map = function(arr, callback, thisObject, Ctr) {};

/**
 * Getter/setter for the margin-box of node.
 * Getter/setter for the margin-box of node.
 * Returns an object in the expected format of box (regardless
 * if box is passed). The object might look like:
 * { l: 50, t: 200, w: 300: h: 150 }
 * for a node offset from its parent 50px to the left, 200px from
 * the top with a margin width of 300px and a margin-height of
 * 150px.
 * 
 * Getter/setter for the margin-box of node.
 * Getter/setter for the margin-box of node.
 * Returns an object in the expected format of box (regardless
 * if box is passed). The object might look like:
 * { l: 50, t: 200, w: 300: h: 150 }
 * for a node offset from its parent 50px to the left, 200px from
 * the top with a margin width of 300px and a margin-height of
 * 150px.
 * 
 * @param {!HTMLElement|!String} node id or reference to DOM Node to get/set box for
 * @param {!Object=} box               OptionalIf passed, denotes that dojo.marginBox() shouldupdate/set the margin box for node. Box is an object in theabove format. All properties are optional if passed.
 * @return {?}
 */
dojo.main.prototype.marginBox = function(node, box) {};

/**
 * Returns a URL relative to a module.
 * 
 * @param {!String} module dojo/dom-class
 * @param {!String=} url               Optional
 * @return {!String}
 */
dojo.main.prototype.moduleUrl = function(module, url) {};

/**
 * Array-like object which adds syntactic
 * sugar for chaining, common iteration operations, animation, and
 * node manipulation. NodeLists are most often returned as the
 * result of dojo/query() calls.
 * NodeList instances provide many utilities that reflect
 * core Dojo APIs for Array iteration and manipulation, DOM
 * manipulation, and event handling. Instead of needing to dig up
 * functions in the dojo package, NodeLists generally make the
 * full power of Dojo available for DOM manipulation tasks in a
 * simple, chainable way.
 * 
 * @param {?} array
 * @return {!Array<?>}
 */
dojo.main.prototype.NodeList = function(array) {};

/**
 * takes a name/value mapping object and returns a string representing
 * a URL-encoded version of that object.
 * 
 * @param {!Object} map
 * @return {?}
 */
dojo.main.prototype.objectToQuery = function(map) {};

/**
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * Attempt to insert node into the DOM, choosing from various positioning options.
 * Returns the first argument resolved to a DOM node.
 * 
 * @param {!HTMLElement|!String} node id or node reference, or HTML fragment starting with "<" to place relative to refNode
 * @param {!HTMLElement|!String} refNode id or node reference to use as basis for placement
 * @param {!String|number=} position               Optionalstring noting the position of node relative to refNode or anumber indicating the location in the childNodes collection of refNode.Accepted string values are:beforeafterreplaceonlyfirstlast"first" and "last" indicate positions as children of refNode, "replace" replaces refNode,"only" replaces all children.  position defaults to "last" if not specified
 * @return {!HTMLElement}
 */
dojo.main.prototype.place = function(node, refNode, position) {};

/**
 * require one or more modules based on which host environment
 * Dojo is currently operating in
 * This method takes a "map" of arrays which one can use to
 * optionally load dojo modules. The map is indexed by the
 * possible dojo.name values, with two additional values:
 * "default" and "common". The items in the "default" array will
 * be loaded if none of the other items have been choosen based on
 * dojo.name, set by your host environment. The items in the
 * "common" array will always be loaded, regardless of which
 * list is chosen.
 * 
 * @param {!Object} modMap
 * @return {void}
 */
dojo.main.prototype.platformRequire = function(modMap) {};

/**
 * If the context stack contains elements, ensure that
 * subsequent code executes in the previous context to the
 * current context. The current context set ([global,
 * document]) is returned.
 * 
 * @return {void}
 */
dojo.main.prototype.popContext = function() {};

/**
 * Gets the position and size of the passed element relative to
 * the viewport (if includeScroll==false), or relative to the
 * document root (if includeScroll==true).
 * Returns an object of the form:
 * { x: 100, y: 300, w: 20, h: 15 }.
 * If includeScroll==true, the x and y values will include any
 * document offsets that may affect the position relative to the
 * viewport.
 * Uses the border-box model (inclusive of border and padding but
 * not margin).  Does not act as a setter.
 * 
 * Gets the position and size of the passed element relative to
 * the viewport (if includeScroll==false), or relative to the
 * document root (if includeScroll==true).
 * Returns an object of the form:
 * { x: 100, y: 300, w: 20, h: 15 }.
 * If includeScroll==true, the x and y values will include any
 * document offsets that may affect the position relative to the
 * viewport.
 * Uses the border-box model (inclusive of border and padding but
 * not margin).  Does not act as a setter.
 * 
 * @param {!HTMLElement|!String} node
 * @param {boolean=} includeScroll               Optional
 * @return {!Object}
 */
dojo.main.prototype.position = function(node, includeScroll) {};

/**
 * Gets or sets a property on an HTML element.
 * Handles normalized getting and setting of properties on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Gets or sets a property on an HTML element.
 * Handles normalized getting and setting of properties on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Gets or sets a property on an HTML element.
 * Handles normalized getting and setting of properties on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Gets or sets a property on an HTML element.
 * Handles normalized getting and setting of properties on DOM
 * Nodes. If 2 arguments are passed, and a the second argument is a
 * string, acts as a getter.
 * 
 * If a third argument is passed, or if the second argument is a
 * map of attributes, acts as a setter.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to get or set the property on
 * @param {!String|!Object} name the name of the property to get or set.
 * @param {!String=} value               OptionalThe value to set for the property
 * @return {?}
 */
dojo.main.prototype.prop = function(node, name, value) {};

/**
 *
 * @param {?} mid
 * @return {void}
 */
dojo.main.prototype.provide = function(mid) {};

/**
 * causes subsequent calls to Dojo methods to assume the
 * passed object and, optionally, document as the default
 * scopes to use. A 2-element array of the previous global and
 * document are returned.
 * dojo.pushContext treats contexts as a stack. The
 * auto-detected contexts which are initially provided using
 * dojo.setContext() require authors to keep state in order to
 * "return" to a previous context, whereas the
 * dojo.pushContext and dojo.popContext methods provide a more
 * natural way to augment blocks of code to ensure that they
 * execute in a different window or frame without issue. If
 * called without any arguments, the default context (the
 * context when Dojo is first loaded) is instead pushed into
 * the stack. If only a single string is passed, a node in the
 * intitial context's document is looked up and its
 * contextWindow and contextDocument properties are used as
 * the context to push. This means that iframes can be given
 * an ID and code can be executed in the scope of the iframe's
 * document in subsequent calls easily.
 * 
 * causes subsequent calls to Dojo methods to assume the
 * passed object and, optionally, document as the default
 * scopes to use. A 2-element array of the previous global and
 * document are returned.
 * dojo.pushContext treats contexts as a stack. The
 * auto-detected contexts which are initially provided using
 * dojo.setContext() require authors to keep state in order to
 * "return" to a previous context, whereas the
 * dojo.pushContext and dojo.popContext methods provide a more
 * natural way to augment blocks of code to ensure that they
 * execute in a different window or frame without issue. If
 * called without any arguments, the default context (the
 * context when Dojo is first loaded) is instead pushed into
 * the stack. If only a single string is passed, a node in the
 * intitial context's document is looked up and its
 * contextWindow and contextDocument properties are used as
 * the context to push. This means that iframes can be given
 * an ID and code can be executed in the scope of the iframe's
 * document in subsequent calls easily.
 * 
 * @param {!Object|!String=} g               OptionalThe global context. If a string, the id of the frame tosearch for a context and document.
 * @param {!HTMLDocument=} d               OptionalThe document element to execute subsequent code with.
 * @return {void}
 */
dojo.main.prototype.pushContext = function(g, d) {};

/**
 * Create an object representing a de-serialized query section of a
 * URL. Query keys with multiple values are returned in an array.
 * 
 * @param {!String} str
 * @return {!Object}
 */
dojo.main.prototype.queryToObject = function(str) {};

/**
 * Sends an HTTP POST request to the server. In addition to the properties
 * listed for the dojo.__XhrArgs type, the following property is allowed:
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo.main.prototype.rawXhrPost = function(args) {};

/**
 * Sends an HTTP PUT request to the server. In addition to the properties
 * listed for the dojo.__XhrArgs type, the following property is allowed:
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo.main.prototype.rawXhrPut = function(args) {};

/**
 * Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
 * In most cases, the domReady plug-in should suffice and this method should not be needed.
 * 
 * When called in a non-browser environment, just checks that all requested modules have arrived and been
 * evaluated.
 * 
 * @param {number} priority               OptionalThe order in which to exec this callback relative to other callbacks, defaults to 1000
 * @param {?} context The context in which to run execute callback, or a callback if not using context
 * @param {!Function} callback               OptionalThe function to execute.
 * @return {void}
 */
dojo.main.prototype.ready = function(priority, context, callback) {};

/**
 * Maps a module name to a path
 * An unregistered module is given the default path of ../[module],
 * relative to Dojo root. For example, module acme is mapped to
 * ../acme.  If you want to use a different module name, use
 * dojo.registerModulePath.
 * 
 * @param {!String} moduleName
 * @param {!String} prefix
 * @return {void}
 */
dojo.main.prototype.registerModulePath = function(moduleName, prefix) {};

/**
 * Removes an attribute from an HTML element.
 * 
 * Removes an attribute from an HTML element.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to remove the attribute from
 * @param {!String} name the name of the attribute to remove
 * @return {void}
 */
dojo.main.prototype.removeAttr = function(node, name) {};

/**
 * Removes the specified classes from node. No contains()
 * check is required.
 * 
 * Removes the specified classes from node. No contains()
 * check is required.
 * 
 * Removes the specified classes from node. No contains()
 * check is required.
 * 
 * Removes the specified classes from node. No contains()
 * check is required.
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to remove the class from.
 * @param {!String|!Array<?>=} classStr               OptionalAn optional String class name to remove, or several space-separatedclass names, or an array of class names. If omitted, all class nameswill be deleted.
 * @return {void}
 */
dojo.main.prototype.removeClass = function(node, classStr) {};

/**
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * Replaces one or more classes on a node if not present.
 * Operates more quickly than calling dojo.removeClass and dojo.addClass
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to remove the class from.
 * @param {!String|!Array<?>} addClassStr A String class name to add, or several space-separated class names,or an array of class names.
 * @param {!String|!Array<?>=} removeClassStr               OptionalA String class name to remove, or several space-separated class names,or an array of class names.
 * @return {void}
 */
dojo.main.prototype.replaceClass = function(node, addClassStr, removeClassStr) {};

/**
 * loads a Javascript module from the appropriate URI
 * Modules are loaded via dojo.require by using one of two loaders: the normal loader
 * and the xdomain loader. The xdomain loader is used when dojo was built with a
 * custom build that specified loader=xdomain and the module lives on a modulePath
 * that is a whole URL, with protocol and a domain. The versions of Dojo that are on
 * the Google and AOL CDNs use the xdomain loader.
 * 
 * If the module is loaded via the xdomain loader, it is an asynchronous load, since
 * the module is added via a dynamically created script tag. This
 * means that dojo.require() can return before the module has loaded. However, this
 * should only happen in the case where you do dojo.require calls in the top-level
 * HTML page, or if you purposely avoid the loader checking for dojo.require
 * dependencies in your module by using a syntax like dojo["require"] to load the module.
 * 
 * Sometimes it is useful to not have the loader detect the dojo.require calls in the
 * module so that you can dynamically load the modules as a result of an action on the
 * page, instead of right at module load time.
 * 
 * Also, for script blocks in an HTML page, the loader does not pre-process them, so
 * it does not know to download the modules before the dojo.require calls occur.
 * 
 * So, in those two cases, when you want on-the-fly module loading or for script blocks
 * in the HTML page, special care must be taken if the dojo.required code is loaded
 * asynchronously. To make sure you can execute code that depends on the dojo.required
 * modules, be sure to add the code that depends on the modules in a dojo.addOnLoad()
 * callback. dojo.addOnLoad waits for all outstanding modules to finish loading before
 * executing.
 * 
 * This type of syntax works with both xdomain and normal loaders, so it is good
 * practice to always use this idiom for on-the-fly code loading and in HTML script
 * blocks. If at some point you change loaders and where the code is loaded from,
 * it will all still work.
 * 
 * More on how dojo.require
 * dojo.require("A.B") first checks to see if symbol A.B is
 * defined. If it is, it is simply returned (nothing to do).
 * 
 * If it is not defined, it will look for A/B.js in the script root
 * directory.
 * 
 * dojo.require throws an exception if it cannot find a file
 * to load, or if the symbol A.B is not defined after loading.
 * 
 * It returns the object A.B, but note the caveats above about on-the-fly loading and
 * HTML script blocks when the xdomain loader is loading a module.
 * 
 * dojo.require() does nothing about importing symbols into
 * the current namespace.  It is presumed that the caller will
 * take care of that.
 * 
 * @param {!String} moduleName module name to load, using periods for separators, e.g. "dojo.date.locale".  Module paths are de-referenced by dojo'sinternal mapping of locations to names and are disambiguated bylongest prefix. See dojo.registerModulePath() for details onregistering new modules.
 * @param {boolean=} omitModuleCheck               Optionalif true, omitModuleCheck skips the step of ensuring that theloaded file actually defines the symbol it is referenced by.For example if it called as dojo.require("a.b.c") and thefile located at a/b/c.js does not define an object a.b.c,and exception will be throws whereas no exception is raisedwhen called as dojo.require("a.b.c", true)
 * @return {?}
 */
dojo.main.prototype.require = function(moduleName, omitModuleCheck) {};

/**
 * If the condition is true then call dojo.require() for the specified
 * resource
 * 
 * @param {boolean} condition
 * @param {!String} moduleName
 * @param {boolean=} omitModuleCheck               Optional
 * @return {void}
 */
dojo.main.prototype.requireAfterIf = function(condition, moduleName, omitModuleCheck) {};

/**
 * If the condition is true then call dojo.require() for the specified
 * resource
 * 
 * @param {boolean} condition
 * @param {!String} moduleName
 * @param {boolean=} omitModuleCheck               Optional
 * @return {void}
 */
dojo.main.prototype.requireIf = function(condition, moduleName, omitModuleCheck) {};

/**
 *
 * @param {!String} moduleName
 * @param {!String} bundleName
 * @param {!String=} locale               Optional
 * @return {void}
 */
dojo.main.prototype.requireLocalization = function(moduleName, bundleName, locale) {};

/**
 * Mix in properties skipping a constructor and decorating functions
 * like it is done by declare().
 * This function is used to mix in properties like lang.mixin does,
 * but it skips a constructor property and decorates functions like
 * declare() does.
 * 
 * It is meant to be used with classes and objects produced with
 * declare. Functions mixed in with dojo.safeMixin can use
 * this.inherited() like normal methods.
 * 
 * This function is used to implement extend() method of a constructor
 * produced with declare().
 * 
 * @param {!Object} target Target object to accept new properties.
 * @param {!Object} source Source object for new properties.
 * @return {!Object}
 */
dojo.main.prototype.safeMixin = function(target, source) {};

/**
 * Sets an attribute on an HTML element.
 * Handles normalized setting of attributes on DOM Nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets an attribute on an HTML element.
 * Handles normalized setting of attributes on DOM Nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets an attribute on an HTML element.
 * Handles normalized setting of attributes on DOM Nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets an attribute on an HTML element.
 * Handles normalized setting of attributes on DOM Nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to set the attribute on
 * @param {!String|!Object} name the name of the attribute to set, or a hash of key-value pairs to set.
 * @param {!String=} value               Optionalthe value to set for the attribute, if the name is a string.
 * @return {?}
 */
dojo.main.prototype.setAttr = function(node, name, value) {};

/**
 * Sets the size of the node's contents, irrespective of margins,
 * padding, or borders.
 * 
 * @param {!HTMLElement} node
 * @param {!Object} box hash with optional "w", and "h" properties for "width", and "height"respectively. All specified properties should have numeric values in whole pixels.
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {void}
 */
dojo.main.prototype.setContentSize = function(node, box, computedStyle) {};

/**
 * changes the behavior of many core Dojo functions that deal with
 * namespace and DOM lookup, changing them to work in a new global
 * context (e.g., an iframe). The varibles dojo.global and dojo.doc
 * are modified as a result of calling this function and the result of
 * dojo.body() likewise differs.
 * 
 * @param {!Object} globalObject
 * @param {!HTMLDocument} globalDocument
 * @return {void}
 */
dojo.main.prototype.setContext = function(globalObject, globalDocument) {};

/**
 * sets the size of the node's margin box and placement
 * (left/top), irrespective of box model. Think of it as a
 * passthrough to setBox that handles box-model vagaries for
 * you.
 * 
 * @param {!HTMLElement} node
 * @param {!Object} box hash with optional "l", "t", "w", and "h" properties for "left", "right", "width", and "height"respectively. All specified properties should have numeric values in whole pixels.
 * @param {!Object=} computedStyle               OptionalThis parameter accepts computed styles object.If this parameter is omitted, the functions will calldojo/dom-style.getComputedStyle to get one. It is a better way, callingdojo/dom-style.getComputedStyle once, and then pass the reference to thiscomputedStyle parameter. Wherever possible, reuse the returnedobject of dojo/dom-style.getComputedStyle().
 * @return {void}
 */
dojo.main.prototype.setMarginBox = function(node, box, computedStyle) {};

/**
 * Sets a property on an HTML element.
 * Handles normalized setting of properties on DOM nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets a property on an HTML element.
 * Handles normalized setting of properties on DOM nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets a property on an HTML element.
 * Handles normalized setting of properties on DOM nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * Sets a property on an HTML element.
 * Handles normalized setting of properties on DOM nodes.
 * 
 * When passing functions as values, note that they will not be
 * directly assigned to slots on the node, but rather the default
 * behavior will be removed and the new behavior will be added
 * using dojo.connect(), meaning that event handler properties
 * will be normalized and that some caveats with regards to
 * non-standard behaviors for onsubmit apply. Namely that you
 * should cancel form submission using dojo.stopEvent() on the
 * passed event object instead of returning a boolean value from
 * the handler itself.
 * 
 * @param {!HTMLElement|!String} node id or reference to the element to set the property on
 * @param {!String|!Object} name the name of the property to set, or a hash object to setmultiple properties at once.
 * @param {!String=} value               OptionalThe value to set for the property
 * @return {?}
 */
dojo.main.prototype.setProp = function(node, name, value) {};

/**
 *
 * @param {?} node
 * @param {?} selectable
 * @return {void}
 */
dojo.main.prototype.setSelectable = function(node, selectable) {};

/**
 * Sets styles on a node.
 * 
 * Sets styles on a node.
 * 
 * Sets styles on a node.
 * 
 * Sets styles on a node.
 * 
 * @param {!HTMLElement|!String} node id or reference to node to set style for
 * @param {!String|!Object} name the style property to set in DOM-accessor format("borderWidth", not "border-width") or an object with key/valuepairs suitable for setting each property.
 * @param {!String=} value               OptionalIf passed, sets value on the node for style, handlingcross-browser concerns.  When setting a pixel value,be sure to include "px" in the value. For instance, top: "200px".Otherwise, in some cases, some browsers will not apply the style.
 * @return {!String}
 */
dojo.main.prototype.setStyle = function(node, name, value) {};

/**
 * Determines whether or not any item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
 * 
 * Determines whether or not any item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
 * 
 * Determines whether or not any item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
 * 
 * Determines whether or not any item in arr satisfies the
 * condition implemented by callback.
 * This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
 * run over sparse arrays, this implementation passes the "holes" in the sparse array to
 * the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
 * For more details, see:
 * https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
 * 
 * @param {!Array<?>|!String} arr the array to iterate over. If a string, operates on individual characters.
 * @param {!Function|!String} callback a function is invoked with three arguments: item, index,and array and returns true if the condition is met.
 * @param {!Object=} thisObject               Optionalmay be used to scope the call to callback
 * @return {boolean}
 */
dojo.main.prototype.some = function(arr, callback, thisObject) {};

/**
 *
 * @return {void}
 */
dojo.main.prototype.Stateful = function() {};

/**
 * prevents propagation and clobbers the default action of the
 * passed event
 * 
 * @param {!Event} evt The event object. If omitted, window.event is used on IE.
 * @return {void}
 */
dojo.main.prototype.stopEvent = function(evt) {};

/**
 * Accesses styles on a node. If 2 arguments are
 * passed, acts as a getter. If 3 arguments are passed, acts
 * as a setter.
 * Getting the style value uses the computed style for the node, so the value
 * will be a calculated value, not just the immediate node.style value.
 * Also when getting values, use specific style names,
 * like "borderBottomWidth" instead of "border" since compound values like
 * "border" are not necessarily reflected as expected.
 * If you want to get node dimensions, use dojo.marginBox(),
 * dojo.contentBox() or dojo.position().
 * 
 * Accesses styles on a node. If 2 arguments are
 * passed, acts as a getter. If 3 arguments are passed, acts
 * as a setter.
 * Getting the style value uses the computed style for the node, so the value
 * will be a calculated value, not just the immediate node.style value.
 * Also when getting values, use specific style names,
 * like "borderBottomWidth" instead of "border" since compound values like
 * "border" are not necessarily reflected as expected.
 * If you want to get node dimensions, use dojo.marginBox(),
 * dojo.contentBox() or dojo.position().
 * 
 * Accesses styles on a node. If 2 arguments are
 * passed, acts as a getter. If 3 arguments are passed, acts
 * as a setter.
 * Getting the style value uses the computed style for the node, so the value
 * will be a calculated value, not just the immediate node.style value.
 * Also when getting values, use specific style names,
 * like "borderBottomWidth" instead of "border" since compound values like
 * "border" are not necessarily reflected as expected.
 * If you want to get node dimensions, use dojo.marginBox(),
 * dojo.contentBox() or dojo.position().
 * 
 * Accesses styles on a node. If 2 arguments are
 * passed, acts as a getter. If 3 arguments are passed, acts
 * as a setter.
 * Getting the style value uses the computed style for the node, so the value
 * will be a calculated value, not just the immediate node.style value.
 * Also when getting values, use specific style names,
 * like "borderBottomWidth" instead of "border" since compound values like
 * "border" are not necessarily reflected as expected.
 * If you want to get node dimensions, use dojo.marginBox(),
 * dojo.contentBox() or dojo.position().
 * 
 * @param {!HTMLElement|!String} node id or reference to node to get/set style for
 * @param {!String|!Object=} name               Optionalthe style property to set in DOM-accessor format("borderWidth", not "border-width") or an object with key/valuepairs suitable for setting each property.
 * @param {!String=} value               OptionalIf passed, sets value on the node for style, handlingcross-browser concerns.  When setting a pixel value,be sure to include "px" in the value. For instance, top: "200px".Otherwise, in some cases, some browsers will not apply the style.
 * @return {?}
 */
dojo.main.prototype.style = function(node, name, value) {};

/**
 * instantiates an HTML fragment returning the corresponding DOM.
 * 
 * @param {!String} frag the HTML fragment
 * @param {!HTMLDocument=} doc               Optionaloptional document to use when creating DOM nodes, defaults todojo/_base/window.doc if not specified.
 * @return {?}
 */
dojo.main.prototype.toDom = function(frag, doc) {};

/**
 * Adds a class to node if not present, or removes if present.
 * Pass a boolean condition if you want to explicitly add or remove.
 * Returns the condition that was specified directly or indirectly.
 * 
 * Adds a class to node if not present, or removes if present.
 * Pass a boolean condition if you want to explicitly add or remove.
 * Returns the condition that was specified directly or indirectly.
 * 
 * Adds a class to node if not present, or removes if present.
 * Pass a boolean condition if you want to explicitly add or remove.
 * Returns the condition that was specified directly or indirectly.
 * 
 * Adds a class to node if not present, or removes if present.
 * Pass a boolean condition if you want to explicitly add or remove.
 * Returns the condition that was specified directly or indirectly.
 * 
 * @param {!String|!HTMLElement} node String ID or DomNode reference to toggle a class string
 * @param {!String|!Array<?>} classStr A String class name to toggle, or several space-separated class names,or an array of class names.
 * @param {boolean=} condition               OptionalIf passed, true means to add the class, false means to remove.Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
 * @return {boolean}
 */
dojo.main.prototype.toggleClass = function(node, classStr, condition) {};

/**
 * Returns a JSON serialization of an object.
 * Returns a JSON serialization of an object.
 * Note that this doesn't check for infinite recursion, so don't do that!
 * It is recommend that you use dojo/json's stringify function for an lighter
 * and faster implementation that matches the native JSON API and uses the
 * native JSON serializer when available.
 * 
 * @param {!Object} it an object to be serialized. Objects may define their ownserialization via a special "json" or "json" functionproperty. If a specialized serializer has been defined, it willbe used as a fallback.Note that in 1.6, toJson would serialize undefined, but this no longer supportedsince it is not supported by native JSON serializer.
 * @param {boolean=} prettyPrint               Optionalif true, we indent objects and arrays to make the output prettier.The variable dojo.toJsonIndentStr is used as the indent string --to use something other than the default (tab), change that variablebefore calling dojo.toJson().Note that if native JSON support is available, it will be used for serialization,and native implementations vary on the exact spacing used in pretty printing.
 * @return {?}
 */
dojo.main.prototype.toJson = function(it, prettyPrint) {};

/**
 * converts style value to pixels on IE or return a numeric value.
 * 
 * @param {!HTMLElement} node
 * @param {!String} value
 * @return {number}
 */
dojo.main.prototype.toPixelValue = function(node, value) {};

/**
 * Remove a topic listener.
 * 
 * @param {!Object} handle The handle returned from a call to subscribe.
 * @return {void}
 */
dojo.main.prototype.unsubscribe = function(handle) {};

/**
 * Transparently applies callbacks to values and/or promises.
 * Accepts promises but also transparently handles non-promises. If no
 * callbacks are provided returns a promise, regardless of the initial
 * value. Foreign promises are converted.
 * 
 * If callbacks are provided and the initial value is not a promise,
 * the callback is executed immediately with no error handling. Returns
 * a promise if the initial value is a promise, or the result of the
 * callback otherwise.
 * 
 * @param {?} valueOrPromise Either a regular value or an object with a then() method thatfollows the Promises/A specification.
 * @param {!Function=} callback               OptionalCallback to be invoked when the promise is resolved, or a non-promiseis received.
 * @param {!Function=} errback               OptionalCallback to be invoked when the promise is rejected.
 * @param {!Function=} progback               OptionalCallback to be invoked when the promise emits a progress update.
 * @return {!dojo.promise.Promise<?>}
 */
dojo.main.prototype.when = function(valueOrPromise, callback, errback, progback) {};

/**
 * signal fired by impending window destruction. You may use
 * dojo.addOnWIndowUnload() or dojo.connect() to this method to perform
 * page/application cleanup methods. See dojo.addOnWindowUnload for more info.
 * 
 * @return {void}
 */
dojo.main.prototype.windowUnloaded = function() {};

/**
 * Invoke callback with documentObject as dojo/_base/window::doc.
 * Invoke callback with documentObject as dojo/_base/window::doc. If provided,
 * callback will be executed in the context of object thisObject
 * When callback() returns or throws an error, the dojo/_base/window::doc will
 * be restored to its previous state.
 * 
 * @param {!HTMLDocument} documentObject
 * @param {!Function} callback
 * @param {!Object=} thisObject               Optional
 * @param {!Array<?>=} cbArguments               Optional
 * @return {?}
 */
dojo.main.prototype.withDoc = function(documentObject, callback, thisObject, cbArguments) {};

/**
 * Invoke callback with globalObject as dojo.global and
 * globalObject.document as dojo.doc.
 * Invoke callback with globalObject as dojo.global and
 * globalObject.document as dojo.doc. If provided, globalObject
 * will be executed in the context of object thisObject
 * When callback() returns or throws an error, the dojo.global
 * and dojo.doc will be restored to its previous state.
 * 
 * @param {!Object} globalObject
 * @param {!Function} callback
 * @param {!Object=} thisObject               Optional
 * @param {!Array<?>=} cbArguments               Optional
 * @return {?}
 */
dojo.main.prototype.withGlobal = function(globalObject, callback, thisObject, cbArguments) {};

/**
 *
 * @param {?} method
 * @param {?} args
 * @return {?}
 */
dojo.main.prototype.xhr = function(method, args) {};

/**
 * Sends an HTTP DELETE request to the server.
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo.main.prototype.xhrDelete = function(args) {};

/**
 * Sends an HTTP GET request to the server.
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo.main.prototype.xhrGet = function(args) {};

/**
 * Sends an HTTP POST request to the server. In addition to the properties
 * listed for the dojo.__XhrArgs type, the following property is allowed:
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo.main.prototype.xhrPost = function(args) {};

/**
 * Sends an HTTP PUT request to the server. In addition to the properties
 * listed for the dojo.__XhrArgs type, the following property is allowed:
 * 
 * @param {!Object} args An object with the following properties:handleAs (String, optional): Acceptable values are: text (default), json, json-comment-optional,json-comment-filtered, javascript, xml. See dojo/_base/xhr.contentHandlerssync (Boolean, optional): false is default. Indicates whether the request shouldbe a synchronous (blocking) request.headers (Object, optional): Additional HTTP headers to send in the request.failOk (Boolean, optional): false is default. Indicates whether a request should beallowed to fail (and therefore no console error message inthe event of a failure)contentType (String|Boolean): "application/x-www-form-urlencoded" is default. Set to false toprevent a Content-Type header from being sent, or to a stringto send a different Content-Type.load: This function will becalled on a successful HTTP response code.error: This function willbe called when the request fails due to a network or server error, the urlis invalid, etc. It will also be called if the load or handle callback throws anexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applicationsto continue to run even when a logic error happens in the callback, while makingit easier to troubleshoot while in debug mode.handle: This function willbe called at the end of every request, whether or not an error occurs.url (String): URL to server endpoint.content (Object, optional): Contains properties with string values. Theseproperties will be serialized as name1=value2 andpassed in the request.timeout (Integer, optional): Milliseconds to wait for the response. If this timepasses, the then error callbacks are called.form (DOMNode, optional): DOM node for a form. Used to extract the form valuesand send to the server.preventCache (Boolean, optional): Default is false. If true, then a"dojo.preventCache" parameter is sent in the requestwith a value that changes with each request(timestamp). Useful only with GET-type requests.rawBody (String, optional): Sets the raw body for an HTTP request. If this is used, then the contentproperty is ignored. This is mostly useful for HTTP methods that havea body to their requests, like PUT or POST. This property can be used insteadof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.ioPublish (Boolean, optional): Set this explicitly to false to prevent publishing of topics related toIO operations. Otherwise, if djConfig.ioPublish is set to true, topicswill be published via dojo/topic.publish() for different phases of an IO operation.See dojo/main.__IoPublish for a list of topics that are published.
 * @return {?}
 */
dojo.main.prototype.xhrPut = function(args) {};

/**
 * @constructor
 * @struct
 */
dojo.main.__IoArgs = function() {};

/* TODO: PropertyDeclaration: dojo.main."content" */

/* TODO: PropertyDeclaration: dojo.main."form" */

/* TODO: PropertyDeclaration: dojo.main."handleAs" */

/* TODO: PropertyDeclaration: dojo.main."ioPublish" */

/* TODO: PropertyDeclaration: dojo.main."preventCache" */

/* TODO: PropertyDeclaration: dojo.main."rawBody" */

/* TODO: PropertyDeclaration: dojo.main."timeout" */

/* TODO: PropertyDeclaration: dojo.main."url" */

/**
 * This function will
 * be called when the request fails due to a network or server error, the url
 * is invalid, etc. It will also be called if the load or handle callback throws an
 * exception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications
 * to continue to run even when a logic error happens in the callback, while making
 * it easier to troubleshoot while in debug mode.
 * 
 * @param {!Object} response The response in the format as defined with handleAs.
 * @param {!dojo.main.__IoCallbackArgs} ioArgs Provides additional information about the request.
 * @return {void}
 */
dojo.main.__IoArgs.prototype.error = function(response, ioArgs) {};

/**
 * This function will
 * be called at the end of every request, whether or not an error occurs.
 * 
 * @param {!String} loadOrError Provides a string that tells you whether this functionwas called because of success (load) or failure (error).
 * @param {!Object} response The response in the format as defined with handleAs.
 * @param {!dojo.main.__IoCallbackArgs} ioArgs Provides additional information about the request.
 * @return {void}
 */
dojo.main.__IoArgs.prototype.handle = function(loadOrError, response, ioArgs) {};

/**
 * This function will be
 * called on a successful HTTP response code.
 * 
 * @param {!Object} response The response in the format as defined with handleAs.
 * @param {!dojo.main.__IoCallbackArgs} ioArgs Provides additional information about the request.
 * @return {void}
 */
dojo.main.__IoArgs.prototype.load = function(response, ioArgs) {};

/**
 * @constructor
 * @struct
 */
dojo.main.__IoCallbackArgs = function() {};

/* TODO: PropertyDeclaration: dojo.main."args" */

/* TODO: PropertyDeclaration: dojo.main."canDelete" */

/* TODO: PropertyDeclaration: dojo.main."handleAs" */

/* TODO: PropertyDeclaration: dojo.main."id" */

/* TODO: PropertyDeclaration: dojo.main."json" */

/* TODO: PropertyDeclaration: dojo.main."query" */

/* TODO: PropertyDeclaration: dojo.main."url" */

/* TODO: PropertyDeclaration: dojo.main."xhr" */

/**
 * @constructor
 * @struct
 */
dojo.main.__IoPublish = function() {};

/* TODO: PropertyDeclaration: dojo.main."done" */

/* TODO: PropertyDeclaration: dojo.main."error" */

/* TODO: PropertyDeclaration: dojo.main."load" */

/* TODO: PropertyDeclaration: dojo.main."send" */

/* TODO: PropertyDeclaration: dojo.main."start" */

/* TODO: PropertyDeclaration: dojo.main."stop" */

/**
 * @constructor
 * @struct
 */
dojo.main.__XhrArgs = function() {};

/* TODO: PropertyDeclaration: dojo.main."content" */

/* TODO: PropertyDeclaration: dojo.main."contentType" */

/* TODO: PropertyDeclaration: dojo.main."failOk" */

/* TODO: PropertyDeclaration: dojo.main."form" */

/* TODO: PropertyDeclaration: dojo.main."handleAs" */

/* TODO: PropertyDeclaration: dojo.main."headers" */

/* TODO: PropertyDeclaration: dojo.main."ioPublish" */

/* TODO: PropertyDeclaration: dojo.main."preventCache" */

/* TODO: PropertyDeclaration: dojo.main."rawBody" */

/* TODO: PropertyDeclaration: dojo.main."sync" */

/* TODO: PropertyDeclaration: dojo.main."timeout" */

/* TODO: PropertyDeclaration: dojo.main."url" */

/**
 * This function will
 * be called when the request fails due to a network or server error, the url
 * is invalid, etc. It will also be called if the load or handle callback throws an
 * exception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications
 * to continue to run even when a logic error happens in the callback, while making
 * it easier to troubleshoot while in debug mode.
 * 
 * @param {!Object} response The response in the format as defined with handleAs.
 * @param {!dojo.main.__IoCallbackArgs} ioArgs Provides additional information about the request.
 * @return {void}
 */
dojo.main.__XhrArgs.prototype.error = function(response, ioArgs) {};

/**
 * This function will
 * be called at the end of every request, whether or not an error occurs.
 * 
 * @param {!String} loadOrError Provides a string that tells you whether this functionwas called because of success (load) or failure (error).
 * @param {!Object} response The response in the format as defined with handleAs.
 * @param {!dojo.main.__IoCallbackArgs} ioArgs Provides additional information about the request.
 * @return {void}
 */
dojo.main.__XhrArgs.prototype.handle = function(loadOrError, response, ioArgs) {};

/**
 * This function will be
 * called on a successful HTTP response code.
 * 
 * @param {!Object} response The response in the format as defined with handleAs.
 * @param {!dojo.main.__IoCallbackArgs} ioArgs Provides additional information about the request.
 * @return {void}
 */
dojo.main.__XhrArgs.prototype.load = function(response, ioArgs) {};

/**
 * @constructor
 * @struct
 */
dojo.main.Stateful = function() {};

/**
 * Get a property on a Stateful instance.
 * Get a named property on a Stateful object. The property may
 * potentially be retrieved via a getter method in subclasses. In the base class
 * this just retrieves the object's property.
 * 
 * @param {!String} name The property to get.
 * @return {?}
 */
dojo.main.Stateful.prototype.get = function(name) {};

/**
 *
 * @param {!Object=} params               Optional
 * @return {void}
 */
dojo.main.Stateful.prototype.postscript = function(params) {};

/**
 * Set a property on a Stateful instance
 * Sets named properties on a stateful object and notifies any watchers of
 * the property. A programmatic setter may be defined in subclasses.
 * 
 * @param {!String} name The property to set.
 * @param {!Object} value The value to set in the property.
 * @return {?}
 */
dojo.main.Stateful.prototype.set = function(name, value) {};

/**
 * Watches a property for changes
 * 
 * @param {string} property
 * @param {function(string, ?, ?): void} callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
 * @return {{unwatch: function(): void}}
 */
dojo.main.Stateful.prototype.watch = function(property, callback) {};
/**
 * @record
 * @struct
 */
dojo.main._hasResource = function() {};
/**
 * @record
 * @struct
 */
dojo.main._contentHandlers = function() {};

/**
 *
 * @param {?} xhr
 * @return {void}
 */
dojo.main._contentHandlers.prototype.auto = function(xhr) {};

/**
 * A contentHandler which evaluates the response data, expecting it to be valid JavaScript
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo.main._contentHandlers.prototype.javascript = function(xhr) {};

/**
 * A contentHandler which returns a JavaScript object created from the response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo.main._contentHandlers.prototype.json = function(xhr) {};

/**
 * A contentHandler which expects comment-filtered JSON.
 * A contentHandler which expects comment-filtered JSON.
 * the json-comment-filtered option was implemented to prevent
 * "JavaScript Hijacking", but it is less secure than standard JSON. Use
 * standard JSON instead. JSON prefixing can be used to subvert hijacking.
 * 
 * Will throw a notice suggesting to use application/json mimetype, as
 * json-commenting can introduce security issues. To decrease the chances of hijacking,
 * use the standard json contentHandler, and prefix your "JSON" with: {}&&
 * 
 * use djConfig.useCommentedJson = true to turn off the notice
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo.main._contentHandlers.prototype.json_comment_filtered = function(xhr) {};

/**
 * A contentHandler which checks the presence of comment-filtered JSON and
 * alternates between the json and json-comment-filtered contentHandlers.
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo.main._contentHandlers.prototype.json_comment_optional = function(xhr) {};

/**
 *
 * @param {?} xhr
 * @return {void}
 */
dojo.main._contentHandlers.prototype.olson_zoneinfo = function(xhr) {};

/**
 * A contentHandler which simply returns the plaintext response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo.main._contentHandlers.prototype.text = function(xhr) {};

/**
 * A contentHandler returning an XML Document parsed from the response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo.main._contentHandlers.prototype.xml = function(xhr) {};
/**
 * @record
 * @struct
 */
dojo.main.cldr = function() {};
 /** @type {!Object} */
dojo.main.cldr.prototype.monetary;
 /** @type {!Object} */
dojo.main.cldr.prototype.supplemental;
/**
 * @record
 * @struct
 */
dojo.main._nodeDataCache = function() {};
/**
 * @record
 * @struct
 */
dojo.main.colors = function() {};

/**
 * creates a greyscale color with an optional alpha
 * 
 * @param {number} g
 * @param {number=} a               Optional
 * @return {void}
 */
dojo.main.colors.prototype.makeGrey = function(g, a) {};
/**
 * @record
 * @struct
 */
dojo.main.back = function() {};

/**
 * adds a state object (args) to the history list.
 * To support getting back button notifications, the object
 * argument should implement a function called either "back",
 * "backButton", or "handle". The string "back" will be passed as
 * the first and only argument to this callback.
 * 
 * To support getting forward button notifications, the object
 * argument should implement a function called either "forward",
 * "forwardButton", or "handle". The string "forward" will be
 * passed as the first and only argument to this callback.
 * 
 * If you want the browser location string to change, define "changeUrl" on the object. If the
 * value of "changeUrl" is true, then a unique number will be appended to the URL as a fragment
 * identifier (http://some.domain.com/path#uniquenumber). If it is any other value that does
 * not evaluate to false, that value will be used as the fragment identifier. For example,
 * if changeUrl: 'page1', then the URL will look like: http://some.domain.com/path#page1
 * 
 * There are problems with using dojo/back with semantically-named fragment identifiers
 * ("hash values" on an URL). In most browsers it will be hard for dojo/back to know
 * distinguish a back from a forward event in those cases. For back/forward support to
 * work best, the fragment ID should always be a unique value (something using new Date().getTime()
 * for example). If you want to detect hash changes using semantic fragment IDs, then
 * consider using dojo/hash instead (in Dojo 1.4+).
 * 
 * @param {!Object} args The state object that will be added to the history list.
 * @return {void}
 */
dojo.main.back.prototype.addToHistory = function(args) {};

/**
 *
 * @return {?}
 */
dojo.main.back.prototype.getHash = function() {};

/**
 * private method. Do not call this directly.
 * 
 * @return {void}
 */
dojo.main.back.prototype.goBack = function() {};

/**
 * private method. Do not call this directly.
 * 
 * @return {void}
 */
dojo.main.back.prototype.goForward = function() {};

/**
 * Initializes the undo stack. This must be called from a
 * block that lives inside the <code>&lt;body&gt;</code> tag to prevent bugs on IE.
 * </p>
 * <p>Only call this method before the page&#39;s DOM is finished loading. Otherwise
 * it will not work. Be careful with xdomain loading or djConfig.debugAtAllCosts scenarios,
 * in order for this method to work, dojo/back will need to be part of a build layer.</p>
 * </div>
 *       </div>
 *       <div class="jsdoc-field extension-module">
 *         <div class="jsdoc-title"><a name="1_9dojo_main_back_setHash"></a><span class="functionIcon">setHash</span><span class="parameters">(h)</span>
 *         </div>
 *         <div class="jsdoc-inheritance">Defined by <a href="/api/1.9/dojo/back" class="jsdoc-link">dojo/back</a><span title="Must manually require () dojo/back to access" class="jsdoc-extension"></span>
 *         </div>
 *         <div class="jsdoc-full-summary"></div>
 *         <table class="jsdoc-parameters">
 *           <tr>
 *             <th>Parameter</th>
 *             <th>Type</th>
 *             <th>Description</th>
 *           </tr>
 *           <tr>
 *             <td class="jsdoc-param-name">h</td>
 *             <td class="jsdoc-param-type">undefined</td>
 *             <td class="jsdoc-param-description">
 *             </td>
 *           </tr>
 *         </table>
 *       </div>
 *       <div class="jsdoc-field extension-module">
 *         <div class="jsdoc-title"><a name="1_9dojo_main_back_setInitialState"></a><span class="functionIcon">setInitialState</span><span class="parameters">(args)</span>
 *         </div>
 *         <div class="jsdoc-inheritance">Defined by <a href="/api/1.9/dojo/back" class="jsdoc-link">dojo/back</a><span title="Must manually require () dojo/back to access" class="jsdoc-extension"></span>
 *         </div>
 *         <div class="jsdoc-full-summary"><p>Sets the state object and back callback for the very first page
 * that is loaded.
 * </p>
 * <p>It is recommended that you call this method as part of an event
 * listener that is registered via dojo/ready.</p>
 * </div>
 *         <table class="jsdoc-parameters">
 *           <tr>
 *             <th>Parameter</th>
 *             <th>Type</th>
 *             <th>Description</th>
 *           </tr>
 *           <tr>
 *             <td class="jsdoc-param-name">args</td>
 *             <td class="jsdoc-param-type">Object</td>
 *             <td class="jsdoc-param-description"><p>See the addToHistory() function for the list of valid args properties.</p>
 * 
 *             </td>
 *           </tr>
 *         </table>
 *       </div>
 *     </div>
 *   </div>
 * </div><a href="https://docs.google.com/spreadsheet/viewform?hl=en_US&amp;formkey=dFlDcHEyaHMwbEd4MFBObkNrX0E1MFE6MQ&amp;entry_0=/api/1.9/dojo/main.back" class="feedback">Error in the documentation? Can't find what you are looking for? Let us know!</a>
 * @return {void}
 */
dojo.main.back.prototype.init = function() {};
/**
 * @record
 * @struct
 */
dojo.main.data = function() {};
 /** @type {!Object} */
dojo.main.data.prototype.api;
 /** @type {!Object} */
dojo.main.data.prototype.util;

/**
 *
 * @return {void}
 */
dojo.main.data.prototype.ItemFileReadStore = function() {};

/**
 *
 * @return {void}
 */
dojo.main.data.prototype.ItemFileWriteStore = function() {};

/**
 *
 * @return {void}
 */
dojo.main.data.prototype.ObjectStore = function() {};
/**
 * @record
 * @struct
 */
dojo.main.config = function() {};
 /** @type {!Function} */
dojo.main.config.prototype.addOnLoad;
 /** @type {boolean} */
dojo.main.config.prototype.afterOnLoad;
 /** @type {!Object} */
dojo.main.config.prototype.baseUrl;
 /** @type {!Function} */
dojo.main.config.prototype.callback;
 /** @type {string} */
dojo.main.config.prototype.debugContainerId;
 /** @type {number} */
dojo.main.config.prototype.debugHeight;
 /** @type {number} */
dojo.main.config.prototype.defaultDuration;
 /** @type {boolean} */
dojo.main.config.prototype.deferredInstrumentation;
 /** @type {!Function} */
dojo.main.config.prototype.deps;
 /** @type {string} */
dojo.main.config.prototype.dojoBlankHtmlUrl;
 /** @type {!Array<?>} */
dojo.main.config.prototype.extraLocale;
 /** @type {!Object} */
dojo.main.config.prototype.ioPublish;
 /** @type {boolean} */
dojo.main.config.prototype.isDebug;
 /** @type {string} */
dojo.main.config.prototype.locale;
 /** @type {!Object} */
dojo.main.config.prototype.modulePaths;
 /** @type {boolean} */
dojo.main.config.prototype.parseOnLoad;
 /** @type {!Object} */
dojo.main.config.prototype.require;
 /** @type {!Array<?>} */
dojo.main.config.prototype.transparentColor;
 /** @type {string} */
dojo.main.config.prototype.urchin;
 /** @type {!Object} */
dojo.main.config.prototype.useCustomLogger;
 /** @type {boolean} */
dojo.main.config.prototype.useDeferredInstrumentation;
/**
 * @record
 * @struct
 */
dojo.main.contentHandlers = function() {};

/**
 *
 * @param {?} xhr
 * @return {void}
 */
dojo.main.contentHandlers.prototype.auto = function(xhr) {};

/**
 * A contentHandler which evaluates the response data, expecting it to be valid JavaScript
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo.main.contentHandlers.prototype.javascript = function(xhr) {};

/**
 * A contentHandler which returns a JavaScript object created from the response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo.main.contentHandlers.prototype.json = function(xhr) {};

/**
 * A contentHandler which expects comment-filtered JSON.
 * A contentHandler which expects comment-filtered JSON.
 * the json-comment-filtered option was implemented to prevent
 * "JavaScript Hijacking", but it is less secure than standard JSON. Use
 * standard JSON instead. JSON prefixing can be used to subvert hijacking.
 * 
 * Will throw a notice suggesting to use application/json mimetype, as
 * json-commenting can introduce security issues. To decrease the chances of hijacking,
 * use the standard json contentHandler, and prefix your "JSON" with: {}&&
 * 
 * use djConfig.useCommentedJson = true to turn off the notice
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo.main.contentHandlers.prototype.json_comment_filtered = function(xhr) {};

/**
 * A contentHandler which checks the presence of comment-filtered JSON and
 * alternates between the json and json-comment-filtered contentHandlers.
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo.main.contentHandlers.prototype.json_comment_optional = function(xhr) {};

/**
 *
 * @param {?} xhr
 * @return {void}
 */
dojo.main.contentHandlers.prototype.olson_zoneinfo = function(xhr) {};

/**
 * A contentHandler which simply returns the plaintext response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo.main.contentHandlers.prototype.text = function(xhr) {};

/**
 * A contentHandler returning an XML Document parsed from the response data
 * 
 * @param {?} xhr
 * @return {?}
 */
dojo.main.contentHandlers.prototype.xml = function(xhr) {};
/**
 * @record
 * @struct
 */
dojo.main.date = function() {};
 /** @type {!Object} */
dojo.main.date.prototype.stamp;

/**
 * Add to a Date in intervals of different size, from milliseconds to years
 * 
 * @param {!Date} date Date object to start with
 * @param {!String} interval A string representing the interval.  One of the following:"year", "month", "day", "hour", "minute", "second","millisecond", "quarter", "week", "weekday"
 * @param {number} amount How much to add to the date.
 * @return {?}
 */
dojo.main.date.prototype.add = function(date, interval, amount) {};

/**
 * Compare two date objects by date, time, or both.
 * Returns 0 if equal, positive if a > b, else negative.
 * 
 * @param {!Date} date1 Date object
 * @param {!Date=} date2               OptionalDate object.  If not specified, the current Date is used.
 * @param {!String=} portion               OptionalA string indicating the "date" or "time" portion of a Date object.Compares both "date" and "time" by default.  One of the following:"date", "time", "datetime"
 * @return {number}
 */
dojo.main.date.prototype.compare = function(date1, date2, portion) {};

/**
 * Get the difference in a specific unit of time (e.g., number of
 * months, weeks, days, etc.) between two dates, rounded to the
 * nearest integer.
 * 
 * @param {!Date} date1 Date object
 * @param {!Date=} date2               OptionalDate object.  If not specified, the current Date is used.
 * @param {!String=} interval               OptionalA string representing the interval.  One of the following:"year", "month", "day", "hour", "minute", "second","millisecond", "quarter", "week", "weekday"Defaults to "day".
 * @return {?}
 */
dojo.main.date.prototype.difference = function(date1, date2, interval) {};

/**
 * Returns the number of days in the month used by dateObject
 * 
 * @param {!Date} dateObject
 * @return {number}
 */
dojo.main.date.prototype.getDaysInMonth = function(dateObject) {};

/**
 * Get the user's time zone as provided by the browser
 * Try to get time zone info from toString or toLocaleString method of
 * the Date object -- UTC offset is not a time zone.  See
 * http://www.twinsun.com/tz/tz-link.htm Note: results may be
 * inconsistent across browsers.
 * 
 * @param {!Date} dateObject Needed because the timezone may vary with time (daylight savings)
 * @return {?}
 */
dojo.main.date.prototype.getTimezoneName = function(dateObject) {};

/**
 * Determines if the year of the dateObject is a leap year
 * Leap years are years with an additional day YYYY-02-29, where the
 * year number is a multiple of four with the following exception: If
 * a year is a multiple of 100, then it is only a leap year if it is
 * also a multiple of 400. For example, 1900 was not a leap year, but
 * 2000 is one.
 * 
 * @param {!Date} dateObject
 * @return {boolean}
 */
dojo.main.date.prototype.isLeapYear = function(dateObject) {};
/**
 * @record
 * @struct
 */
dojo.main.currency = function() {};

/**
 * Format a Number as a currency, using locale-specific settings
 * Create a string from a Number using a known, localized pattern.
 * Formatting patterns
 * appropriate to the locale are chosen from the CLDR
 * as well as the appropriate symbols and delimiters and number of decimal places.
 * 
 * @param {number} value the number to be formatted.
 * @param {!dojo.currency.__FormatOptions=} options               Optional
 * @return {?}
 */
dojo.main.currency.prototype.format = function(value, options) {};

/**
 *
 * @param {!String} expression
 * @param {!Object=} options               OptionalAn object with the following properties:type (String, optional): Should not be set.  Value is assumed to be currency.currency (String, optional): an ISO4217 currency code, a three letter sequence like "USD".For use with dojo.currency only.symbol (String, optional): localized currency symbol. The default will be looked up in table of supported currencies in dojo.cldrA ISO4217 currency code will be used if not found.places (Number, optional): fixed number of decimal places to accept.  The default is determined based on which currency is used.fractional (Boolean|Array, optional): Whether to include the fractional portion, where the number of decimal places are implied by the currencyor explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.By default for currencies, it the fractional portion is optional.pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.  Literal characters in patterns are not supported.locale (String, optional): override the locale used to determine formatting rulesstrict (Boolean, optional): strict parsing, false by default.  Strict parsing requires input as produced by the format() method.Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
 * @return {?}
 */
dojo.main.currency.prototype.parse = function(expression, options) {};

/**
 *
 * @param {!Object} options               OptionalAn object with the following properties:pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.type (String, optional): choose a format type based on the locale from the following:decimal, scientific (not yet supported), percent, currency. decimal by default.locale (String, optional): override the locale used to determine formatting rulesstrict (Boolean, optional): strict parsing, false by default.  Strict parsing requires input as produced by the format() method.Non-strict is more permissive, e.g. flexible on white space, omitting thousands separatorsplaces (Number|String, optional): number of decimal places to accept: Infinity, a positive number, ora range "n,m".  Defined by pattern or Infinity if pattern not provided.
 * @return {?}
 */
dojo.main.currency.prototype.regexp = function(options) {};
/**
 * @record
 * @struct
 */
dojo.main.dnd = function() {};
 /** @type {!Object} */
dojo.main.dnd.prototype.autoscroll;
 /** @type {!Object} */
dojo.main.dnd.prototype.move;

/**
 *
 * @return {void}
 */
dojo.main.dnd.prototype.AutoSource = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dnd.prototype.Avatar = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dnd.prototype.Container = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dnd.prototype.Manager = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dnd.prototype.Moveable = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dnd.prototype.Mover = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dnd.prototype.Selector = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dnd.prototype.Source = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dnd.prototype.Target = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dnd.prototype.TimedMoveable = function() {};
/**
 * @record
 * @struct
 */
dojo.main.doc = function() {};
 /** @type {!Object} */
dojo.main.doc.prototype.documentElement;
 /** @type {boolean} */
dojo.main.doc.prototype.dojoClick;
/**
 * @record
 * @struct
 */
dojo.main.gears = function() {};
 /** @type {!Object} */
dojo.main.gears.prototype.available;
/**
 * @record
 * @struct
 */
dojo.main.global = function() {};

/**
 *
 * @return {?}
 */
dojo.main.global.prototype.$ = function() {};

/**
 *
 * @param {?} start
 * @param {?} data
 * @param {?} responseCode
 * @param {?} errorMsg
 * @return {void}
 */
dojo.main.global.prototype.GoogleSearchStoreCallback_undefined_NaN = function(start, data, responseCode, errorMsg) {};

/**
 *
 * @return {?}
 */
dojo.main.global.prototype.jQuery = function() {};

/**
 *
 * @return {void}
 */
dojo.main.global.prototype.swfIsInHTML = function() {};

/**
 *
 * @return {void}
 */
dojo.main.global.prototype.undefined_onload = function() {};
/**
 * @record
 * @struct
 */
dojo.main.dijit = function() {};
 /** @type {!Object} */
dojo.main.dijit.prototype.form;
 /** @type {!Object} */
dojo.main.dijit.prototype.layout;
 /** @type {!Object} */
dojo.main.dijit.prototype.range;
 /** @type {!Object} */
dojo.main.dijit.prototype.registry;
 /** @type {!Object} */
dojo.main.dijit.prototype.tree;

/**
 *
 * @param {?} id
 * @return {?}
 */
dojo.main.dijit.prototype.byId = function(id) {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.Calendar = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.CalendarLite = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.CheckedMenuItem = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.ColorPalette = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.Declaration = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.Destroyable = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.Dialog = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.DialogUnderlay = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.DropDownMenu = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.Dye = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.Editor = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.Fieldset = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.InlineEditBox = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.Menu = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.MenuBar = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.MenuBarItem = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.MenuItem = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.MenuSeparator = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.PopupMenuBarItem = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.PopupMenuItem = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.ProgressBar = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.RadioButtonMenuItem = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.TitlePane = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.Toolbar = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.ToolbarSeparator = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.Tooltip = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.TooltipDialog = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.Tree = function() {};

/**
 *
 * @return {void}
 */
dojo.main.dijit.prototype.WidgetSet = function() {};
/**
 * @record
 * @struct
 */
dojo.main.io = function() {};
 /** @type {!Object} */
dojo.main.io.prototype.iframe;
 /** @type {!Object} */
dojo.main.io.prototype.script;
/**
 * @record
 * @struct
 */
dojo.main.fx = function() {};
 /** @type {!Object} */
dojo.main.fx.prototype.easing;

/**
 * Chain a list of dojo/_base/fx.Animations to run in sequence
 * Return a dojo/_base/fx.Animation which will play all passed
 * dojo/_base/fx.Animation instances in sequence, firing its own
 * synthesized events simulating a single animation. (eg:
 * onEnd of this animation means the end of the chain,
 * not the individual animations within)
 * 
 * @param {!Array<!dojo._base.fx.Animation>} animations
 * @return {?}
 */
dojo.main.fx.prototype.chain = function(animations) {};

/**
 * Combine a list of dojo/_base/fx.Animations to run in parallel
 * Combine an array of dojo/_base/fx.Animations to run in parallel,
 * providing a new dojo/_base/fx.Animation instance encompasing each
 * animation, firing standard animation events.
 * 
 * @param {!Array<!dojo._base.fx.Animation>} animations
 * @return {?}
 */
dojo.main.fx.prototype.combine = function(animations) {};

/**
 * Slide a node to a new top/left position
 * Returns an animation that will slide "node"
 * defined in args Object from its current position to
 * the position defined by (args.left, args.top).
 * 
 * @param {!Object} args A hash-map of standard dojo/_base/fx.Animation constructor properties(such as easing: node: duration: and so on). Special args membersare top and left, which indicate the new position to slide to.
 * @return {?}
 */
dojo.main.fx.prototype.slideTo = function(args) {};

/**
 *
 * @return {void}
 */
dojo.main.fx.prototype.Toggler = function() {};

/**
 * Expand a node to it's natural height.
 * Returns an animation that will expand the
 * node defined in 'args' object from it's current height to
 * it's natural height (with no scrollbar).
 * Node must have no margin/border/padding.
 * 
 * @param {!Object} args A hash-map of standard dojo/_base/fx.Animation constructor properties(such as easing: node: duration: and so on)
 * @return {?}
 */
dojo.main.fx.prototype.wipeIn = function(args) {};

/**
 * Shrink a node to nothing and hide it.
 * Returns an animation that will shrink node defined in "args"
 * from it's current height to 1px, and then hide it.
 * 
 * @param {!Object} args A hash-map of standard dojo/_base/fx.Animation constructor properties(such as easing: node: duration: and so on)
 * @return {?}
 */
dojo.main.fx.prototype.wipeOut = function(args) {};
/**
 * @record
 * @struct
 */
dojo.main.html = function() {};

/**
 * inserts (replaces) the given content into the given node. dojo/dom-construct.place(cont, node, "only")
 * may be a better choice for simple HTML insertion.
 * Unless you need to use the params capabilities of this method, you should use
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct..place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct..place does not handle NodeList insertions
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct.place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct.place does not handle NodeList insertions
 * or the other capabilities as defined by the params object for this method.
 * 
 * inserts (replaces) the given content into the given node. dojo/dom-construct.place(cont, node, "only")
 * may be a better choice for simple HTML insertion.
 * Unless you need to use the params capabilities of this method, you should use
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct..place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct..place does not handle NodeList insertions
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct.place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct.place does not handle NodeList insertions
 * or the other capabilities as defined by the params object for this method.
 * 
 * inserts (replaces) the given content into the given node. dojo/dom-construct.place(cont, node, "only")
 * may be a better choice for simple HTML insertion.
 * Unless you need to use the params capabilities of this method, you should use
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct..place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct..place does not handle NodeList insertions
 * dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct.place() has more robust support for injecting
 * an HTML string into the DOM, but it only handles inserting an HTML string as DOM
 * elements, or inserting a DOM node. dojo/dom-construct.place does not handle NodeList insertions
 * or the other capabilities as defined by the params object for this method.
 * 
 * @param {!HTMLElement} node the parent element that will receive the content
 * @param {!String|!HTMLElement|!dojo.NodeList} cont the content to be set on the parent element.This can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes
 * @param {!Object=} params               OptionalOptional flags/properties to configure the content-setting. See dojo/html/_ContentSetter
 * @return {?}
 */
dojo.main.html.prototype.set = function(node, cont, params) {};
/**
 * @record
 * @struct
 */
dojo.main.dojox = function() {};
 /** @type {!Object} */
dojo.main.dojox.prototype.analytics;
 /** @type {!Object} */
dojo.main.dojox.prototype.app;
 /** @type {!Object} */
dojo.main.dojox.prototype.atom;
 /** @type {!Object} */
dojo.main.dojox.prototype.av;
 /** @type {!Object} */
dojo.main.dojox.prototype.BidiComplex;
 /** @type {!Object} */
dojo.main.dojox.prototype.calc;
 /** @type {!Object} */
dojo.main.dojox.prototype.calendar;
 /** @type {!Object} */
dojo.main.dojox.prototype.charting;
 /** @type {!Object} */
dojo.main.dojox.prototype.collections;
 /** @type {!Object} */
dojo.main.dojox.prototype.color;
 /** @type {!Object} */
dojo.main.dojox.prototype.css3;
 /** @type {!Object} */
dojo.main.dojox.prototype.data;
 /** @type {!Object} */
dojo.main.dojox.prototype.date;
 /** @type {!Object} */
dojo.main.dojox.prototype.dgauges;
 /** @type {!Object} */
dojo.main.dojox.prototype.dnd;
 /** @type {!Object} */
dojo.main.dojox.prototype.drawing;
 /** @type {!Object} */
dojo.main.dojox.prototype.dtl;
 /** @type {!Object} */
dojo.main.dojox.prototype.editor;
 /** @type {!Object} */
dojo.main.dojox.prototype.embed;
 /** @type {!Object} */
dojo.main.dojox.prototype.encoding;
 /** @type {!Object} */
dojo.main.dojox.prototype.enhanced;
 /** @type {!Object} */
dojo.main.dojox.prototype.flash;
 /** @type {!Object} */
dojo.main.dojox.prototype.form;
 /** @type {!Object} */
dojo.main.dojox.prototype.fx;
 /** @type {!Object} */
dojo.main.dojox.prototype.gantt;
 /** @type {!Object} */
dojo.main.dojox.prototype.gauges;
 /** @type {!Object} */
dojo.main.dojox.prototype.geo;
 /** @type {!Object} */
dojo.main.dojox.prototype.gesture;
 /** @type {!Object} */
dojo.main.dojox.prototype.gfx;
 /** @type {!Object} */
dojo.main.dojox.prototype.gfx3d;
 /** @type {!Object} */
dojo.main.dojox.prototype.grid;
 /** @type {!Object} */
dojo.main.dojox.prototype.help;
 /** @type {!Object} */
dojo.main.dojox.prototype.highlight;
 /** @type {!Object} */
dojo.main.dojox.prototype.html;
 /** @type {!Object} */
dojo.main.dojox.prototype.image;
 /** @type {!Object} */
dojo.main.dojox.prototype.io;
 /** @type {!Object} */
dojo.main.dojox.prototype.jq;
 /** @type {!Object} */
dojo.main.dojox.prototype.json;
 /** @type {!Object} */
dojo.main.dojox.prototype.jsonPath;
 /** @type {!Object} */
dojo.main.dojox.prototype.lang;
 /** @type {!Object} */
dojo.main.dojox.prototype.layout;
 /** @type {!Object} */
dojo.main.dojox.prototype.math;
 /** @type {!Object} */
dojo.main.dojox.prototype.mdnd;
 /** @type {!Object} */
dojo.main.dojox.prototype.mobile;
 /** @type {!Object} */
dojo.main.dojox.prototype.mvc;
 /** @type {!Object} */
dojo.main.dojox.prototype.openlayers;
 /** @type {!Object} */
dojo.main.dojox.prototype.rails;
 /** @type {!Object} */
dojo.main.dojox.prototype.robot;
 /** @type {!Object} */
dojo.main.dojox.prototype.rpc;
 /** @type {!Object} */
dojo.main.dojox.prototype.secure;
 /** @type {!Object} */
dojo.main.dojox.prototype.sketch;
 /** @type {!Object} */
dojo.main.dojox.prototype.sql;
 /** @type {!Object} */
dojo.main.dojox.prototype.string;
 /** @type {!Object} */
dojo.main.dojox.prototype.testing;
 /** @type {!Object} */
dojo.main.dojox.prototype.timing;
 /** @type {!Object} */
dojo.main.dojox.prototype.treemap;
 /** @type {!Object} */
dojo.main.dojox.prototype.uuid;
 /** @type {!Object} */
dojo.main.dojox.prototype.validate;
 /** @type {!Object} */
dojo.main.dojox.prototype.widget;
 /** @type {!Object} */
dojo.main.dojox.prototype.xml;

/**
 * Provides a simple socket connection using WebSocket, or alternate
 * communication mechanisms in legacy browsers for comet-style communication. This is based
 * on the WebSocket API and returns an object that implements the WebSocket interface:
 * http://dev.w3.org/html5/websockets/#websocket
 * Provides socket connections. This can be used with virtually any Comet protocol.
 * 
 * @param {!Object} argsOrUrl This uses the same arguments as the other I/O functions in Dojo, or aURL to connect to. The URL should be a relative URL in order to properlywork with WebSockets (it can still be host relative, like //other-site.org/endpoint)
 * @return {?}
 */
dojo.main.dojox.prototype.socket = function(argsOrUrl) {};

/**
 *
 * @param {!String} format
 * @param {?} filler
 * @return {void}
 */
dojo.main.dojox.prototype.sprintf = function(format, filler) {};
/**
 * @record
 * @struct
 */
dojo.main.i18n = function() {};
 /** @type {!Object} */
dojo.main.i18n.prototype.cache;
 /** @type {boolean} */
dojo.main.i18n.prototype.dynamic;
 /** @type {!Array<?>} */
dojo.main.i18n.prototype.unitTests;

/**
 *
 * @param {?} moduleName
 * @param {?} bundleName
 * @param {?} locale
 * @return {!String}
 */
dojo.main.i18n.prototype.getL10nName = function(moduleName, bundleName, locale) {};

/**
 *
 * @param {?} moduleName
 * @param {?} bundleName
 * @param {?} locale
 * @return {?}
 */
dojo.main.i18n.prototype.getLocalization = function(moduleName, bundleName, locale) {};

/**
 * id is in one of the following formats
 * 
 * /nls/
 *  => load the bundle, localized to config.locale; load all bundles localized to
 *  config.extraLocale (if any); return the loaded bundle localized to config.locale.
 * /nls//
 *  => load then return the bundle localized to
 * preload/nls//
 *  => for config.locale and all config.extraLocale, load all bundles found
 *  in the best-matching bundle rollup. A value of 1 is returned, which
 *  is meaningless other than to say the plugin is executing the requested
 *  preloads
 * 
 * In cases 1 and 2,  is always normalized to an absolute module id upon entry; see
 * normalize. In case 3, it  is assumed to be absolute; this is arranged by the builder.
 * 
 * To load a bundle means to insert the bundle into the plugin's cache and publish the bundle
 * value to the loader. Given , , and a particular , the cache key
 * 
 * <path>/nls/<bundle>/<locale>
 * will hold the value. Similarly, then plugin will publish this value to the loader by
 * 
 * define("<path>/nls/<bundle>/<locale>", <bundle-value>);
 * Given this algorithm, other machinery can provide fast load paths be preplacing
 * values in the plugin's cache, which is public. When a load is demanded the
 * cache is inspected before starting any loading. Explicitly placing values in the plugin
 * cache is an advanced/experimental feature that should not be needed; use at your own risk.
 * 
 * For the normal AMD algorithm, the root bundle is loaded first, which instructs the
 * plugin what additional localized bundles are required for a particular locale. These
 * additional locales are loaded and a mix of the root and each progressively-specific
 * locale is returned. For example:
 * 
 * The client demands "dojo/i18n!some/path/nls/someBundle
 * The loader demands load(some/path/nls/someBundle)
 * This plugin require's "some/path/nls/someBundle", which is the root bundle.
 * Assuming config.locale is "ab-cd-ef" and the root bundle indicates that localizations
 * are available for "ab" and "ab-cd-ef" (note the missing "ab-cd", then the plugin
 * requires "some/path/nls/ab/someBundle" and "some/path/nls/ab-cd-ef/someBundle"
 * Upon receiving all required bundles, the plugin constructs the value of the bundle
 * ab-cd-ef as...
 *  mixin(mixin(mixin({}, require("some/path/nls/someBundle"),
 *      require("some/path/nls/ab/someBundle")),
 *      require("some/path/nls/ab-cd-ef/someBundle"));
 * 
 * This value is inserted into the cache and published to the loader at the
 * key/module-id some/path/nls/someBundle/ab-cd-ef.
 * 
 * The special preload signature (case 3) instructs the plugin to stop servicing all normal requests
 * (further preload requests will be serviced) until all ongoing preloading has completed.
 * 
 * The preload signature instructs the plugin that a special rollup module is available that contains
 * one or more flattened, localized bundles. The JSON array of available locales indicates which locales
 * are available. Here is an example:
 * 
 * *preload*some/path/nls/someModule*["root", "ab", "ab-cd-ef"]
 * This indicates the following rollup modules are available:
 * 
 * some/path/nls/someModule_ROOT
 * some/path/nls/someModule_ab
 * some/path/nls/someModule_ab-cd-ef
 * Each of these modules is a normal AMD module that contains one or more flattened bundles in a hash.
 * For example, assume someModule contained the bundles some/bundle/path/someBundle and
 * some/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:
 * 
 * define({
 *     some/bundle/path/someBundle:<value of someBundle, flattened with respect to locale ab>,
 *     some/bundle/path/someOtherBundle:<value of someOtherBundle, flattened with respect to locale ab>,
 * });
 * E.g., given this design, preloading for locale=="ab" can execute the following algorithm:
 * 
 * require(["some/path/nls/someModule_ab"], function(rollup){
 *     for(var p in rollup){
 *         var id = p + "/ab",
 *         cache[id] = rollup[p];
 *         define(id, rollup[p]);
 *     }
 * });
 * Similarly, if "ab-cd" is requested, the algorithm can determine that "ab" is the best available and
 * load accordingly.
 * 
 * The builder will write such rollups for every layer if a non-empty localeList  profile property is
 * provided. Further, the builder will include the following cache entry in the cache associated with
 * any layer.
 * 
 * "*now":function(r){r(['dojo/i18n!*preload*<path>/nls/<module>*<JSON array of available locales>']);}
 * The *now special cache module instructs the loader to apply the provided function to context-require
 * with respect to the particular layer being defined. This causes the plugin to hold all normal service
 * requests until all preloading is complete.
 * 
 * Notice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case
 * where the target locale has a single segment and a layer depends on a single bundle:
 * 
 * Without Preloads:
 * 
 * Layer loads root bundle.
 * bundle is demanded; plugin loads single localized bundle.
 * With Preloads:
 * 
 * Layer causes preloading of target bundle.
 * bundle is demanded; service is delayed until preloading complete; bundle is returned.
 * In each case a single transaction is required to load the target bundle. In cases where multiple bundles
 * are required and/or the locale has multiple segments, preloads still requires a single transaction whereas
 * the normal path requires an additional transaction for each additional bundle/locale-segment. However all
 * of these additional transactions can be done concurrently. Owing to this analysis, the entire preloading
 * algorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.
 * 
 * @param {?} id
 * @param {?} require
 * @param {?} load
 * @return {void}
 */
dojo.main.i18n.prototype.load = function(id, require, load) {};

/**
 * id may be relative.
 * preload has form *preload*<path>/nls/<module>*<flattened locales> and
 * therefore never looks like a relative
 * 
 * @param {?} id
 * @param {?} toAbsMid
 * @return {?}
 */
dojo.main.i18n.prototype.normalize = function(id, toAbsMid) {};

/**
 *
 * @param {?} locale
 * @return {?}
 */
dojo.main.i18n.prototype.normalizeLocale = function(locale) {};
/**
 * @record
 * @struct
 */
dojo.main.scopeMap = function() {};
 /** @type {!Array<?>} */
dojo.main.scopeMap.prototype.dijit;
 /** @type {!Array<?>} */
dojo.main.scopeMap.prototype.dojo;
 /** @type {!Array<?>} */
dojo.main.scopeMap.prototype.dojox;
/**
 * @record
 * @struct
 */
dojo.main.regexp = function() {};

/**
 * Builds a regular expression that groups subexpressions
 * A utility function used by some of the RE generators. The
 * subexpressions are constructed by the function, re, in the second
 * parameter.  re builds one subexpression for each elem in the array
 * a, in the first parameter. Returns a string for a regular
 * expression that groups all the subexpressions.
 * 
 * Builds a regular expression that groups subexpressions
 * A utility function used by some of the RE generators. The
 * subexpressions are constructed by the function, re, in the second
 * parameter.  re builds one subexpression for each elem in the array
 * a, in the first parameter. Returns a string for a regular
 * expression that groups all the subexpressions.
 * 
 * @param {!Object|!Array<?>} arr A single value or an array of values.
 * @param {!Function} re A function. Takes one parameter and converts it to a regularexpression.
 * @param {boolean=} nonCapture               OptionalIf true, uses non-capturing match, otherwise matches are retainedby regular expression. Defaults to false
 * @return {?}
 */
dojo.main.regexp.prototype.buildGroupRE = function(arr, re, nonCapture) {};

/**
 * Adds escape sequences for special characters in regular expressions
 * 
 * @param {!String} str
 * @param {!String=} except               Optionala String with special characters to be left unescaped
 * @return {?}
 */
dojo.main.regexp.prototype.escapeString = function(str, except) {};

/**
 * adds group match to expression
 * 
 * @param {!String} expression
 * @param {boolean=} nonCapture               OptionalIf true, uses non-capturing match, otherwise matches are retainedby regular expression.
 * @return {!String}
 */
dojo.main.regexp.prototype.group = function(expression, nonCapture) {};
/**
 * @record
 * @struct
 */
dojo.main.mouseButtons = function() {};
 /** @type {number} */
dojo.main.mouseButtons.prototype.LEFT;
 /** @type {number} */
dojo.main.mouseButtons.prototype.MIDDLE;
 /** @type {number} */
dojo.main.mouseButtons.prototype.RIGHT;

/**
 * Checks an event object for a pressed button
 * 
 * @param {!Event} e Event object to examine
 * @param {number} button The button value (example: dojo.mouseButton.LEFT)
 * @return {boolean}
 */
dojo.main.mouseButtons.prototype.isButton = function(e, button) {};

/**
 * Checks an event object for the pressed left button
 * 
 * @param {!Event} e Event object to examine
 * @return {boolean}
 */
dojo.main.mouseButtons.prototype.isLeft = function(e) {};

/**
 * Checks an event object for the pressed middle button
 * 
 * @param {!Event} e Event object to examine
 * @return {boolean}
 */
dojo.main.mouseButtons.prototype.isMiddle = function(e) {};

/**
 * Checks an event object for the pressed right button
 * 
 * @param {!Event} e Event object to examine
 * @return {boolean}
 */
dojo.main.mouseButtons.prototype.isRight = function(e) {};
/**
 * @record
 * @struct
 */
dojo.main.rpc = function() {};

/**
 *
 * @return {void}
 */
dojo.main.rpc.prototype.JsonpService = function() {};

/**
 *
 * @return {void}
 */
dojo.main.rpc.prototype.JsonService = function() {};

/**
 *
 * @return {void}
 */
dojo.main.rpc.prototype.RpcService = function() {};
/**
 * @record
 * @struct
 */
dojo.main.number_ = function() {};

/**
 * Format a Number as a String, using locale-specific settings
 * Create a string from a Number using a known localized pattern.
 * Formatting patterns appropriate to the locale are chosen from the
 * Common Locale Data Repository as well as the appropriate symbols and
 * delimiters.
 * If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.
 * 
 * @param {number} value the number to be formatted
 * @param {!Object=} options               OptionalAn object with the following properties:pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.  Literal characters in patterns are not supported.type (String, optional): choose a format type based on the locale from the following:decimal, scientific (not yet supported), percent, currency. decimal by default.places (Number, optional): fixed number of decimal places to show.  This overrides anyinformation in the provided pattern.round (Number, optional): 5 rounds to nearest .5; 0 rounds to nearest whole (default). -1means do not round.locale (String, optional): override the locale used to determine formatting rulesfractional (Boolean, optional): If false, show no decimal places, overriding places and pattern settings.
 * @return {?}
 */
dojo.main.number_.prototype.format = function(value, options) {};

/**
 * Convert a properly formatted string to a primitive Number, using
 * locale-specific settings.
 * Create a Number from a string using a known localized pattern.
 * Formatting patterns are chosen appropriate to the locale
 * and follow the syntax described by
 * unicode.org TR35
 * Note that literal characters in patterns are not supported.
 * 
 * @param {!String} expression A string representation of a Number
 * @param {!Object=} options               OptionalAn object with the following properties:pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.  Literal characters in patterns are not supported.type (String, optional): choose a format type based on the locale from the following:decimal, scientific (not yet supported), percent, currency. decimal by default.locale (String, optional): override the locale used to determine formatting rulesstrict (Boolean, optional): strict parsing, false by default.  Strict parsing requires input as produced by the format() method.Non-strict is more permissive, e.g. flexible on white space, omitting thousands separatorsfractional (Boolean|Array, optional): Whether to include the fractional portion, where the number of decimal places are implied by patternor explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.
 * @return {number}
 */
dojo.main.number_.prototype.parse = function(expression, options) {};

/**
 * Builds the regular needed to parse a number
 * Returns regular expression with positive and negative match, group
 * and decimal separators
 * 
 * @param {!Object=} options               OptionalAn object with the following properties:pattern (String, optional): override formatting patternwith this string.  Default value is based on locale.  Overriding this property will defeatlocalization.type (String, optional): choose a format type based on the locale from the following:decimal, scientific (not yet supported), percent, currency. decimal by default.locale (String, optional): override the locale used to determine formatting rulesstrict (Boolean, optional): strict parsing, false by default.  Strict parsing requires input as produced by the format() method.Non-strict is more permissive, e.g. flexible on white space, omitting thousands separatorsplaces (Number|String, optional): number of decimal places to accept: Infinity, a positive number, ora range "n,m".  Defined by pattern or Infinity if pattern not provided.
 * @return {?}
 */
dojo.main.number_.prototype.regexp = function(options) {};

/**
 * Rounds to the nearest value with the given number of decimal places, away from zero
 * Rounds to the nearest value with the given number of decimal places, away from zero if equal.
 * Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
 * fractional increments also, such as the nearest quarter.
 * NOTE: Subject to floating point errors.  See dojox/math/round for experimental workaround.
 * 
 * @param {number} value The number to round
 * @param {number=} places               OptionalThe number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.Must be non-negative.
 * @param {number=} increment               OptionalRounds next place to nearest value of increment/10.  10 by default.
 * @return {number}
 */
dojo.main.number_.prototype.round = function(value, places, increment) {};
/**
 * @record
 * @struct
 */
dojo.main.keys = function() {};
 /** @type {number} */
dojo.main.keys.prototype.ALT;
 /** @type {number} */
dojo.main.keys.prototype.BACKSPACE;
 /** @type {number} */
dojo.main.keys.prototype.CAPS_LOCK;
 /** @type {number} */
dojo.main.keys.prototype.CLEAR;
 /** @type {number} */
dojo.main.keys.prototype.copyKey;
 /** @type {number} */
dojo.main.keys.prototype.CTRL;
 /** @type {number} */
dojo.main.keys.prototype.DELETE;
 /** @type {number} */
dojo.main.keys.prototype.DOWN_ARROW;
 /** @type {number} */
dojo.main.keys.prototype.DOWN_DPAD;
 /** @type {number} */
dojo.main.keys.prototype.END;
 /** @type {number} */
dojo.main.keys.prototype.ENTER;
 /** @type {number} */
dojo.main.keys.prototype.ESCAPE;
 /** @type {number} */
dojo.main.keys.prototype.F1;
 /** @type {number} */
dojo.main.keys.prototype.F10;
 /** @type {number} */
dojo.main.keys.prototype.F11;
 /** @type {number} */
dojo.main.keys.prototype.F12;
 /** @type {number} */
dojo.main.keys.prototype.F13;
 /** @type {number} */
dojo.main.keys.prototype.F14;
 /** @type {number} */
dojo.main.keys.prototype.F15;
 /** @type {number} */
dojo.main.keys.prototype.F2;
 /** @type {number} */
dojo.main.keys.prototype.F3;
 /** @type {number} */
dojo.main.keys.prototype.F4;
 /** @type {number} */
dojo.main.keys.prototype.F5;
 /** @type {number} */
dojo.main.keys.prototype.F6;
 /** @type {number} */
dojo.main.keys.prototype.F7;
 /** @type {number} */
dojo.main.keys.prototype.F8;
 /** @type {number} */
dojo.main.keys.prototype.F9;
 /** @type {number} */
dojo.main.keys.prototype.HELP;
 /** @type {number} */
dojo.main.keys.prototype.HOME;
 /** @type {number} */
dojo.main.keys.prototype.INSERT;
 /** @type {number} */
dojo.main.keys.prototype.LEFT_ARROW;
 /** @type {number} */
dojo.main.keys.prototype.LEFT_DPAD;
 /** @type {number} */
dojo.main.keys.prototype.LEFT_WINDOW;
 /** @type {number} */
dojo.main.keys.prototype.META;
 /** @type {number} */
dojo.main.keys.prototype.NUM_LOCK;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_0;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_1;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_2;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_3;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_4;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_5;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_6;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_7;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_8;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_9;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_DIVIDE;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_ENTER;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_MINUS;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_MULTIPLY;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_PERIOD;
 /** @type {number} */
dojo.main.keys.prototype.NUMPAD_PLUS;
 /** @type {number} */
dojo.main.keys.prototype.PAGE_DOWN;
 /** @type {number} */
dojo.main.keys.prototype.PAGE_UP;
 /** @type {number} */
dojo.main.keys.prototype.PAUSE;
 /** @type {number} */
dojo.main.keys.prototype.RIGHT_ARROW;
 /** @type {number} */
dojo.main.keys.prototype.RIGHT_DPAD;
 /** @type {number} */
dojo.main.keys.prototype.RIGHT_WINDOW;
 /** @type {number} */
dojo.main.keys.prototype.SCROLL_LOCK;
 /** @type {number} */
dojo.main.keys.prototype.SELECT;
 /** @type {number} */
dojo.main.keys.prototype.SHIFT;
 /** @type {number} */
dojo.main.keys.prototype.SPACE;
 /** @type {number} */
dojo.main.keys.prototype.TAB;
 /** @type {number} */
dojo.main.keys.prototype.UP_ARROW;
 /** @type {number} */
dojo.main.keys.prototype.UP_DPAD;
/**
 * @record
 * @struct
 */
dojo.main.tests = function() {};
/**
 * @record
 * @struct
 */
dojo.main.version = function() {};
 /** @type {string} */
dojo.main.version.prototype.flag;
 /** @type {number} */
dojo.main.version.prototype.major;
 /** @type {number} */
dojo.main.version.prototype.minor;
 /** @type {number} */
dojo.main.version.prototype.patch;
 /** @type {number} */
dojo.main.version.prototype.revision;

/**
 *
 * @return {!String}
 */
dojo.main.version.prototype.toString = function() {};
/**
 * @record
 * @struct
 */
dojo.main.string_ = function() {};

/**
 * Pad a string to guarantee that it is at least size length by
 * filling with the character ch at either the start or end of the
 * string. Pads at the start, by default.
 * 
 * @param {!String} text the string to pad
 * @param {number} size length to provide padding
 * @param {!String=} ch               Optionalcharacter to pad, defaults to '0'
 * @param {boolean=} end               Optionaladds padding at the end if true, otherwise pads at start
 * @return {number}
 */
dojo.main.string_.prototype.pad = function(text, size, ch, end) {};

/**
 * Efficiently replicate a string n times.
 * 
 * @param {!String} str the string to replicate
 * @param {number} num number of times to replicate the string
 * @return {!String}
 */
dojo.main.string_.prototype.rep = function(str, num) {};

/**
 * Performs parameterized substitutions on a string. Throws an
 * exception if any parameter is unmatched.
 * 
 * Performs parameterized substitutions on a string. Throws an
 * exception if any parameter is unmatched.
 * 
 * @param {!String} template a string with expressions in the form ${key} to be replaced or${key:format} which specifies a format function. keys are case-sensitive.
 * @param {!Object|!Array<?>} map hash to search for substitutions
 * @param {!Function=} transform               Optionala function to process all parameters before substitution takesplace, e.g. mylib.encodeXML
 * @param {!Object=} thisObject               Optionalwhere to look for optional format function; default to the globalnamespace
 * @return {?}
 */
dojo.main.string_.prototype.substitute = function(template, map, transform, thisObject) {};

/**
 * Trims whitespace from both sides of the string
 * This version of trim() was taken from Steven Levithan's blog.
 * The short yet performant version of this function is dojo/_base/lang.trim(),
 * which is part of Dojo base.  Uses String.prototype.trim instead, if available.
 * 
 * @param {!String} str String to be trimmed
 * @return {!String}
 */
dojo.main.string_.prototype.trim = function(str) {};
/**
 * @record
 * @struct
 */
dojo.main.touch = function() {};

/**
 * Register a listener to 'touchcancel'|'mouseleave' for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.main.touch.prototype.cancel = function(node, listener) {};

/**
 * Register a listener to mouse.enter or touch equivalent for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.main.touch.prototype.enter = function(node, listener) {};

/**
 * Register a listener to mouse.leave or touch equivalent for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.main.touch.prototype.leave = function(node, listener) {};

/**
 * Register a listener that fires when the mouse cursor or a finger is dragged over the given node.
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.main.touch.prototype.move = function(node, listener) {};

/**
 * Register a listener to 'mouseout' or touch equivalent for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.main.touch.prototype.out = function(node, listener) {};

/**
 * Register a listener to 'mouseover' or touch equivalent for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.main.touch.prototype.over = function(node, listener) {};

/**
 * Register a listener to 'touchstart'|'mousedown' for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.main.touch.prototype.press = function(node, listener) {};

/**
 * Register a listener to releasing the mouse button while the cursor is over the given node
 * (i.e. "mouseup") or for removing the finger from the screen while touching the given node.
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.main.touch.prototype.release = function(node, listener) {};
/**
 * @record
 * @struct
 */
dojo.main.store = function() {};
 /** @type {!Object} */
dojo.main.store.prototype.util;

/**
 *
 * @param {?} masterStore
 * @param {?} cachingStore
 * @param {?} options
 * @return {?}
 */
dojo.main.store.prototype.Cache = function(masterStore, cachingStore, options) {};

/**
 *
 * @return {void}
 */
dojo.main.store.prototype.DataStore = function() {};

/**
 *
 * @return {void}
 */
dojo.main.store.prototype.JsonRest = function() {};

/**
 *
 * @return {void}
 */
dojo.main.store.prototype.Memory = function() {};

/**
 * The Observable store wrapper takes a store and sets an observe method on query()
 * results that can be used to monitor results for changes.
 * Observable wraps an existing store so that notifications can be made when a query
 * is performed.
 * 
 * @param {!dojo.store.api.Store} store
 * @return {?}
 */
dojo.main.store.prototype.Observable = function(store) {};
/**
 * @record
 * @struct
 */
dojo.main.window = function() {};

/**
 * Get window object associated with document doc.
 * 
 * @param {!HTMLDocument} doc The document to get the associated window for.
 * @return {?}
 */
dojo.main.window.prototype.get = function(doc) {};

/**
 * Returns the dimensions and scroll position of the viewable area of a browser window
 * 
 * @param {!HTMLDocument=} doc               Optional
 * @return {!Object}
 */
dojo.main.window.prototype.getBox = function(doc) {};

/**
 * Scroll the passed node into view using minimal movement, if it is not already.
 * 
 * @param {!HTMLElement} node
 * @param {!Object} pos               Optional
 * @return {void}
 */
dojo.main.window.prototype.scrollIntoView = function(node, pos) {};
/**
 * @record
 * @struct
 */
dojo.string_ = function() {};

/**
 * Pad a string to guarantee that it is at least size length by
 * filling with the character ch at either the start or end of the
 * string. Pads at the start, by default.
 * 
 * @param {!String} text the string to pad
 * @param {number} size length to provide padding
 * @param {!String=} ch               Optionalcharacter to pad, defaults to '0'
 * @param {boolean=} end               Optionaladds padding at the end if true, otherwise pads at start
 * @return {number}
 */
dojo.string_.prototype.pad = function(text, size, ch, end) {};

/**
 * Efficiently replicate a string n times.
 * 
 * @param {!String} str the string to replicate
 * @param {number} num number of times to replicate the string
 * @return {!String}
 */
dojo.string_.prototype.rep = function(str, num) {};

/**
 * Performs parameterized substitutions on a string. Throws an
 * exception if any parameter is unmatched.
 * 
 * Performs parameterized substitutions on a string. Throws an
 * exception if any parameter is unmatched.
 * 
 * @param {!String} template a string with expressions in the form ${key} to be replaced or${key:format} which specifies a format function. keys are case-sensitive.
 * @param {!Object|!Array<?>} map hash to search for substitutions
 * @param {!Function=} transform               Optionala function to process all parameters before substitution takesplace, e.g. mylib.encodeXML
 * @param {!Object=} thisObject               Optionalwhere to look for optional format function; default to the globalnamespace
 * @return {?}
 */
dojo.string_.prototype.substitute = function(template, map, transform, thisObject) {};

/**
 * Trims whitespace from both sides of the string
 * This version of trim() was taken from Steven Levithan's blog.
 * The short yet performant version of this function is dojo/_base/lang.trim(),
 * which is part of Dojo base.  Uses String.prototype.trim instead, if available.
 * 
 * @param {!String} str String to be trimmed
 * @return {!String}
 */
dojo.string_.prototype.trim = function(str) {};
/**
 * @record
 * @struct
 */
dojo.text = function() {};
 /** @type {boolean} */
dojo.text.prototype.dynamic;

/**
 *
 * @param {!String} id Path to the resource.
 * @param {!Function} require Object that include the function toUrl with given id returns a valid URL from which to load the text.
 * @param {!Function} load Callback function which will be called, when the loading finished.
 * @return {void}
 */
dojo.text.prototype.load = function(id, require, load) {};

/**
 *
 * @param {?} id
 * @param {?} toAbsMid
 * @return {!String}
 */
dojo.text.prototype.normalize = function(id, toAbsMid) {};
/**
 * @record
 * @struct
 */
dojo.topic = function() {};

/**
 * Publishes a message to a topic on the pub/sub hub. All arguments after
 * the first will be passed to the subscribers, so any number of arguments
 * can be provided (not just event).
 * 
 * @param {!String} topic The name of the topic to publish to
 * @param {!Object} event An event to distribute to the topic listeners
 * @return {?}
 */
dojo.topic.prototype.publish = function(topic, event) {};

/**
 * Subscribes to a topic on the pub/sub hub
 * 
 * @param {!String} topic The topic to subscribe to
 * @param {!Function} listener A function to call when a message is published to the given topic
 * @return {?}
 */
dojo.topic.prototype.subscribe = function(topic, listener) {};
/**
 * @record
 * @struct
 */
dojo.uacss = function() {};
/**
 * @record
 * @struct
 */
dojo.window = function() {};

/**
 * Get window object associated with document doc.
 * 
 * @param {!HTMLDocument} doc The document to get the associated window for.
 * @return {?}
 */
dojo.window.prototype.get = function(doc) {};

/**
 * Returns the dimensions and scroll position of the viewable area of a browser window
 * 
 * @param {!HTMLDocument=} doc               Optional
 * @return {!Object}
 */
dojo.window.prototype.getBox = function(doc) {};

/**
 * Scroll the passed node into view using minimal movement, if it is not already.
 * 
 * @param {!HTMLElement} node
 * @param {!Object} pos               Optional
 * @return {void}
 */
dojo.window.prototype.scrollIntoView = function(node, pos) {};
/**
 * @record
 * @struct
 */
dojo.touch = function() {};

/**
 * Register a listener to 'touchcancel'|'mouseleave' for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.touch.prototype.cancel = function(node, listener) {};

/**
 * Register a listener to mouse.enter or touch equivalent for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.touch.prototype.enter = function(node, listener) {};

/**
 * Register a listener to mouse.leave or touch equivalent for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.touch.prototype.leave = function(node, listener) {};

/**
 * Register a listener that fires when the mouse cursor or a finger is dragged over the given node.
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.touch.prototype.move = function(node, listener) {};

/**
 * Register a listener to 'mouseout' or touch equivalent for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.touch.prototype.out = function(node, listener) {};

/**
 * Register a listener to 'mouseover' or touch equivalent for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.touch.prototype.over = function(node, listener) {};

/**
 * Register a listener to 'touchstart'|'mousedown' for the given node
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.touch.prototype.press = function(node, listener) {};

/**
 * Register a listener to releasing the mouse button while the cursor is over the given node
 * (i.e. "mouseup") or for removing the finger from the screen while touching the given node.
 * 
 * @param {!HTMLElement} node Target node to listen to
 * @param {!Function} listener Callback function
 * @return {?}
 */
dojo.touch.prototype.release = function(node, listener) {};
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request"
/** @const */
tsickle_declare_module.dojo_request = {};
 /** @type {?} */
tsickle_declare_module.dojo_request.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request.__BaseOptions"
/** @const */
tsickle_declare_module.dojo_request____BaseOptions = {};
 /** @type {!dojo.request.__BaseOptions} */
tsickle_declare_module.dojo_request____BaseOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request____BaseOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request.__MethodOptions"
/** @const */
tsickle_declare_module.dojo_request____MethodOptions = {};
 /** @type {!dojo.request.__MethodOptions} */
tsickle_declare_module.dojo_request____MethodOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request____MethodOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request.__Options"
/** @const */
tsickle_declare_module.dojo_request____Options = {};
 /** @type {!dojo.request.__Options} */
tsickle_declare_module.dojo_request____Options.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request____Options */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request.__Promise"
/** @const */
tsickle_declare_module.dojo_request____Promise = {};
 /** @type {!dojo.request.__Promise} */
tsickle_declare_module.dojo_request____Promise.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request____Promise */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/handlers"
/** @const */
tsickle_declare_module.dojo_request_handlers = {};
 /** @type {!dojo.request.handlers} */
tsickle_declare_module.dojo_request_handlers.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_handlers */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/iframe"
/** @const */
tsickle_declare_module.dojo_request_iframe = {};
 /** @type {?} */
tsickle_declare_module.dojo_request_iframe.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_iframe */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/iframe.__MethodOptions"
/** @const */
tsickle_declare_module.dojo_request_iframe____MethodOptions = {};
 /** @type {!dojo.request.iframe.__MethodOptions} */
tsickle_declare_module.dojo_request_iframe____MethodOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_iframe____MethodOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/iframe.__BaseOptions"
/** @const */
tsickle_declare_module.dojo_request_iframe____BaseOptions = {};
 /** @type {!dojo.request.iframe.__BaseOptions} */
tsickle_declare_module.dojo_request_iframe____BaseOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_iframe____BaseOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/iframe.__Options"
/** @const */
tsickle_declare_module.dojo_request_iframe____Options = {};
 /** @type {!dojo.request.iframe.__Options} */
tsickle_declare_module.dojo_request_iframe____Options.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_iframe____Options */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/notify"
/** @const */
tsickle_declare_module.dojo_request_notify = {};
 /** @type {!dojo.request.notify} */
tsickle_declare_module.dojo_request_notify.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_notify */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/registry"
/** @const */
tsickle_declare_module.dojo_request_registry = {};
 /** @type {!dojo.request.registry} */
tsickle_declare_module.dojo_request_registry.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_registry */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/node"
/** @const */
tsickle_declare_module.dojo_request_node = {};
 /** @type {?} */
tsickle_declare_module.dojo_request_node.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_node */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/node.__MethodOptions"
/** @const */
tsickle_declare_module.dojo_request_node____MethodOptions = {};
 /** @type {!dojo.request.node.__MethodOptions} */
tsickle_declare_module.dojo_request_node____MethodOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_node____MethodOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/node.__Options"
/** @const */
tsickle_declare_module.dojo_request_node____Options = {};
 /** @type {!dojo.request.node.__Options} */
tsickle_declare_module.dojo_request_node____Options.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_node____Options */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/node.__BaseOptions"
/** @const */
tsickle_declare_module.dojo_request_node____BaseOptions = {};
 /** @type {!dojo.request.node.__BaseOptions} */
tsickle_declare_module.dojo_request_node____BaseOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_node____BaseOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/watch"
/** @const */
tsickle_declare_module.dojo_request_watch = {};
 /** @type {!dojo.request.watch} */
tsickle_declare_module.dojo_request_watch.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_watch */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/script"
/** @const */
tsickle_declare_module.dojo_request_script = {};
 /** @type {?} */
tsickle_declare_module.dojo_request_script.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_script */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/script.__MethodOptions"
/** @const */
tsickle_declare_module.dojo_request_script____MethodOptions = {};
 /** @type {!dojo.request.script.__MethodOptions} */
tsickle_declare_module.dojo_request_script____MethodOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_script____MethodOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/script.__BaseOptions"
/** @const */
tsickle_declare_module.dojo_request_script____BaseOptions = {};
 /** @type {!dojo.request.script.__BaseOptions} */
tsickle_declare_module.dojo_request_script____BaseOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_script____BaseOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/script.__Options"
/** @const */
tsickle_declare_module.dojo_request_script____Options = {};
 /** @type {!dojo.request.script.__Options} */
tsickle_declare_module.dojo_request_script____Options.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_script____Options */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/xhr"
/** @const */
tsickle_declare_module.dojo_request_xhr = {};
 /** @type {?} */
tsickle_declare_module.dojo_request_xhr.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_xhr */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/xhr.__BaseOptions"
/** @const */
tsickle_declare_module.dojo_request_xhr____BaseOptions = {};
 /** @type {!dojo.request.xhr.__BaseOptions} */
tsickle_declare_module.dojo_request_xhr____BaseOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_xhr____BaseOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/xhr.__MethodOptions"
/** @const */
tsickle_declare_module.dojo_request_xhr____MethodOptions = {};
 /** @type {!dojo.request.xhr.__MethodOptions} */
tsickle_declare_module.dojo_request_xhr____MethodOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_xhr____MethodOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/xhr.__Options"
/** @const */
tsickle_declare_module.dojo_request_xhr____Options = {};
 /** @type {!dojo.request.xhr.__Options} */
tsickle_declare_module.dojo_request_xhr____Options.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_xhr____Options */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/default"
/** @const */
tsickle_declare_module.dojo_request_default = {};
 /** @type {!dojo.request.default_} */
tsickle_declare_module.dojo_request_default.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_default */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/request/util"
/** @const */
tsickle_declare_module.dojo_request_util = {};
 /** @type {!dojo.request.util} */
tsickle_declare_module.dojo_request_util.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_request_util */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/AdapterRegistry"
/** @const */
tsickle_declare_module.dojo_AdapterRegistry = {};
 /** @type {!dojo.AdapterRegistry} */
tsickle_declare_module.dojo_AdapterRegistry.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_AdapterRegistry */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/cache"
/** @const */
tsickle_declare_module.dojo_cache = {};
 /** @type {!dojo.cache} */
tsickle_declare_module.dojo_cache.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_cache */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/cookie"
/** @const */
tsickle_declare_module.dojo_cookie = {};
 /** @type {!dojo.cookie} */
tsickle_declare_module.dojo_cookie.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_cookie */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/domReady"
/** @const */
tsickle_declare_module.dojo_domReady = {};
 /** @type {!dojo.domReady} */
tsickle_declare_module.dojo_domReady.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_domReady */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/hash"
/** @const */
tsickle_declare_module.dojo_hash = {};
 /** @type {!dojo.hash} */
tsickle_declare_module.dojo_hash.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_hash */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/has"
/** @const */
tsickle_declare_module.dojo_has = {};
 /** @type {!dojo.has} */
tsickle_declare_module.dojo_has.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_has */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/hccss"
/** @const */
tsickle_declare_module.dojo_hccss = {};
 /** @type {!dojo.hccss} */
tsickle_declare_module.dojo_hccss.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_hccss */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/NodeList-data"
/** @const */
tsickle_declare_module.dojo_NodeList_data = {};
 /** @type {!dojo.NodeList_data} */
tsickle_declare_module.dojo_NodeList_data.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_NodeList_data */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/NodeList-html"
/** @const */
tsickle_declare_module.dojo_NodeList_html = {};
 /** @type {!dojo.NodeList_html} */
tsickle_declare_module.dojo_NodeList_html.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_NodeList_html */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/NodeList-fx"
/** @const */
tsickle_declare_module.dojo_NodeList_fx = {};
 /** @type {!dojo.NodeList_fx} */
tsickle_declare_module.dojo_NodeList_fx.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_NodeList_fx */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/NodeList-dom"
/** @const */
tsickle_declare_module.dojo_NodeList_dom = {};
 /** @type {!dojo.NodeList_dom} */
tsickle_declare_module.dojo_NodeList_dom.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_NodeList_dom */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/NodeList-manipulate"
/** @const */
tsickle_declare_module.dojo_NodeList_manipulate = {};
 /** @type {!dojo.NodeList_manipulate} */
tsickle_declare_module.dojo_NodeList_manipulate.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_NodeList_manipulate */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/NodeList-traverse"
/** @const */
tsickle_declare_module.dojo_NodeList_traverse = {};
 /** @type {!dojo.NodeList_traverse} */
tsickle_declare_module.dojo_NodeList_traverse.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_NodeList_traverse */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/on"
/** @const */
tsickle_declare_module.dojo_on = {};
 /** @type {!dojo.on} */
tsickle_declare_module.dojo_on.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_on */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/query"
/** @const */
tsickle_declare_module.dojo_query = {};
 /** @type {!dojo.query} */
tsickle_declare_module.dojo_query.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_query */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/ready"
/** @const */
tsickle_declare_module.dojo_ready = {};
 /** @type {!dojo.ready} */
tsickle_declare_module.dojo_ready.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_ready */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/sniff"
/** @const */
tsickle_declare_module.dojo_sniff = {};
 /** @type {!dojo.sniff} */
tsickle_declare_module.dojo_sniff.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_sniff */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/when"
/** @const */
tsickle_declare_module.dojo_when = {};
 /** @type {!dojo.when} */
tsickle_declare_module.dojo_when.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_when */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/date"
/** @const */
tsickle_declare_module.dojo_date = {};
 /** @type {?} */
tsickle_declare_module.dojo_date.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_date */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/date/stamp"
/** @const */
tsickle_declare_module.dojo_date_stamp = {};
 /** @type {!dojo.date.stamp} */
tsickle_declare_module.dojo_date_stamp.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_date_stamp */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/date/locale"
/** @const */
tsickle_declare_module.dojo_date_locale = {};
 /** @type {?} */
tsickle_declare_module.dojo_date_locale.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_date_locale */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/date/locale.__FormatOptions"
/** @const */
tsickle_declare_module.dojo_date_locale____FormatOptions = {};
 /** @type {!dojo.date.locale.__FormatOptions} */
tsickle_declare_module.dojo_date_locale____FormatOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_date_locale____FormatOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/fx"
/** @const */
tsickle_declare_module.dojo_fx = {};
 /** @type {?} */
tsickle_declare_module.dojo_fx.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_fx */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/fx/Toggler"
/** @const */
tsickle_declare_module.dojo_fx_Toggler = {};
 /** @type {!dojo.fx.Toggler} */
tsickle_declare_module.dojo_fx_Toggler.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_fx_Toggler */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/fx/easing"
/** @const */
tsickle_declare_module.dojo_fx_easing = {};
 /** @type {!dojo.fx.easing} */
tsickle_declare_module.dojo_fx_easing.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_fx_easing */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/router"
/** @const */
tsickle_declare_module.dojo_router = {};
 /** @type {?} */
tsickle_declare_module.dojo_router.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_router */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/router/RouterBase"
/** @const */
tsickle_declare_module.dojo_router_RouterBase = {};
 /** @type {?} */
tsickle_declare_module.dojo_router_RouterBase.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_router_RouterBase */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/aspect"
/** @const */
tsickle_declare_module.dojo_aspect = {};
 /** @type {!dojo.aspect} */
tsickle_declare_module.dojo_aspect.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_aspect */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/back"
/** @const */
tsickle_declare_module.dojo_back = {};
 /** @type {!dojo.back} */
tsickle_declare_module.dojo_back.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_back */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/colors"
/** @const */
tsickle_declare_module.dojo_colors = {};
 /** @type {!dojo.colors} */
tsickle_declare_module.dojo_colors.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_colors */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/currency"
/** @const */
tsickle_declare_module.dojo_currency = {};
 /** @type {?} */
tsickle_declare_module.dojo_currency.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_currency */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/currency.__FormatOptions"
/** @const */
tsickle_declare_module.dojo_currency____FormatOptions = {};
 /** @type {!dojo.currency.__FormatOptions} */
tsickle_declare_module.dojo_currency____FormatOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_currency____FormatOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/currency.__ParseOptions"
/** @const */
tsickle_declare_module.dojo_currency____ParseOptions = {};
 /** @type {!dojo.currency.__ParseOptions} */
tsickle_declare_module.dojo_currency____ParseOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_currency____ParseOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dom"
/** @const */
tsickle_declare_module.dojo_dom = {};
 /** @type {!dojo.dom} */
tsickle_declare_module.dojo_dom.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dom */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dom-attr"
/** @const */
tsickle_declare_module.dojo_dom_attr = {};
 /** @type {!dojo.dom_attr} */
tsickle_declare_module.dojo_dom_attr.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dom_attr */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dom-class"
/** @const */
tsickle_declare_module.dojo_dom_class = {};
 /** @type {!dojo.dom_class} */
tsickle_declare_module.dojo_dom_class.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dom_class */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dom-form"
/** @const */
tsickle_declare_module.dojo_dom_form = {};
 /** @type {!dojo.dom_form} */
tsickle_declare_module.dojo_dom_form.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dom_form */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dom-construct"
/** @const */
tsickle_declare_module.dojo_dom_construct = {};
 /** @type {!dojo.dom_construct} */
tsickle_declare_module.dojo_dom_construct.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dom_construct */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dom-prop"
/** @const */
tsickle_declare_module.dojo_dom_prop = {};
 /** @type {!dojo.dom_prop} */
tsickle_declare_module.dojo_dom_prop.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dom_prop */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dom-prop.names"
/** @const */
tsickle_declare_module.dojo_dom_prop_names = {};
 /** @type {!dojo.dom_prop.names} */
tsickle_declare_module.dojo_dom_prop_names.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dom_prop_names */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dom-style"
/** @const */
tsickle_declare_module.dojo_dom_style = {};
 /** @type {!dojo.dom_style} */
tsickle_declare_module.dojo_dom_style.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dom_style */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dom-geometry"
/** @const */
tsickle_declare_module.dojo_dom_geometry = {};
 /** @type {!dojo.dom_geometry} */
tsickle_declare_module.dojo_dom_geometry.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dom_geometry */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/gears"
/** @const */
tsickle_declare_module.dojo_gears = {};
 /** @type {!dojo.gears} */
tsickle_declare_module.dojo_gears.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_gears */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/gears.available"
/** @const */
tsickle_declare_module.dojo_gears_available = {};
 /** @type {!dojo.gears.available} */
tsickle_declare_module.dojo_gears_available.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_gears_available */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/html"
/** @const */
tsickle_declare_module.dojo_html = {};
 /** @type {?} */
tsickle_declare_module.dojo_html.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_html */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/html._ContentSetter"
/** @const */
tsickle_declare_module.dojo_html___ContentSetter = {};
 /** @type {!dojo.html._ContentSetter} */
tsickle_declare_module.dojo_html___ContentSetter.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_html___ContentSetter */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/io-query"
/** @const */
tsickle_declare_module.dojo_io_query = {};
 /** @type {!dojo.io_query} */
tsickle_declare_module.dojo_io_query.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_io_query */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/i18n"
/** @const */
tsickle_declare_module.dojo_i__n = {};
 /** @type {!dojo.i18n} */
tsickle_declare_module.dojo_i__n.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_i__n */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/i18n.cache"
/** @const */
tsickle_declare_module.dojo_i__n_cache = {};
 /** @type {!dojo.i18n.cache} */
tsickle_declare_module.dojo_i__n_cache.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_i__n_cache */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/json"
/** @const */
tsickle_declare_module.dojo_json = {};
 /** @type {!dojo.json} */
tsickle_declare_module.dojo_json.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_json */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/loadInit"
/** @const */
tsickle_declare_module.dojo_loadInit = {};
 /** @type {!dojo.loadInit} */
tsickle_declare_module.dojo_loadInit.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_loadInit */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/keys"
/** @const */
tsickle_declare_module.dojo_keys = {};
 /** @type {!dojo.keys} */
tsickle_declare_module.dojo_keys.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_keys */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/mouse"
/** @const */
tsickle_declare_module.dojo_mouse = {};
 /** @type {!dojo.mouse} */
tsickle_declare_module.dojo_mouse.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_mouse */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/node"
/** @const */
tsickle_declare_module.dojo_node = {};
 /** @type {!dojo.node} */
tsickle_declare_module.dojo_node.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_node */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/number"
/** @const */
tsickle_declare_module.dojo_number = {};
 /** @type {?} */
tsickle_declare_module.dojo_number.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_number */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/number.__FormatAbsoluteOptions"
/** @const */
tsickle_declare_module.dojo_number____FormatAbsoluteOptions = {};
 /** @type {!dojo.number_.__FormatAbsoluteOptions} */
tsickle_declare_module.dojo_number____FormatAbsoluteOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_number____FormatAbsoluteOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/number.__IntegerRegexpFlags"
/** @const */
tsickle_declare_module.dojo_number____IntegerRegexpFlags = {};
 /** @type {!dojo.number_.__IntegerRegexpFlags} */
tsickle_declare_module.dojo_number____IntegerRegexpFlags.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_number____IntegerRegexpFlags */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/number.__FormatOptions"
/** @const */
tsickle_declare_module.dojo_number____FormatOptions = {};
 /** @type {!dojo.number_.__FormatOptions} */
tsickle_declare_module.dojo_number____FormatOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_number____FormatOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/number.__RealNumberRegexpFlags"
/** @const */
tsickle_declare_module.dojo_number____RealNumberRegexpFlags = {};
 /** @type {!dojo.number_.__RealNumberRegexpFlags} */
tsickle_declare_module.dojo_number____RealNumberRegexpFlags.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_number____RealNumberRegexpFlags */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/number.__ParseOptions"
/** @const */
tsickle_declare_module.dojo_number____ParseOptions = {};
 /** @type {!dojo.number_.__ParseOptions} */
tsickle_declare_module.dojo_number____ParseOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_number____ParseOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/number.__RegexpOptions"
/** @const */
tsickle_declare_module.dojo_number____RegexpOptions = {};
 /** @type {!dojo.number_.__RegexpOptions} */
tsickle_declare_module.dojo_number____RegexpOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_number____RegexpOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/parser"
/** @const */
tsickle_declare_module.dojo_parser = {};
 /** @type {!dojo.parser} */
tsickle_declare_module.dojo_parser.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_parser */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/regexp"
/** @const */
tsickle_declare_module.dojo_regexp = {};
 /** @type {!dojo.regexp} */
tsickle_declare_module.dojo_regexp.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_regexp */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/require"
/** @const */
tsickle_declare_module.dojo_require = {};
 /** @type {!dojo.require} */
tsickle_declare_module.dojo_require.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_require */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/robotx"
/** @const */
tsickle_declare_module.dojo_robotx = {};
 /** @type {!dojo.robotx} */
tsickle_declare_module.dojo_robotx.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_robotx */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/robotx._runsemaphore"
/** @const */
tsickle_declare_module.dojo_robotx___runsemaphore = {};
 /** @type {!dojo.robotx._runsemaphore} */
tsickle_declare_module.dojo_robotx___runsemaphore.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_robotx___runsemaphore */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/robot"
/** @const */
tsickle_declare_module.dojo_robot = {};
 /** @type {!dojo.robot} */
tsickle_declare_module.dojo_robot.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_robot */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/robot._runsemaphore"
/** @const */
tsickle_declare_module.dojo_robot___runsemaphore = {};
 /** @type {!dojo.robot._runsemaphore} */
tsickle_declare_module.dojo_robot___runsemaphore.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_robot___runsemaphore */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main"
/** @const */
tsickle_declare_module.dojo_main = {};
 /** @type {?} */
tsickle_declare_module.dojo_main.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.__IoArgs"
/** @const */
tsickle_declare_module.dojo_main____IoArgs = {};
 /** @type {!dojo.main.__IoArgs} */
tsickle_declare_module.dojo_main____IoArgs.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main____IoArgs */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.__IoCallbackArgs"
/** @const */
tsickle_declare_module.dojo_main____IoCallbackArgs = {};
 /** @type {!dojo.main.__IoCallbackArgs} */
tsickle_declare_module.dojo_main____IoCallbackArgs.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main____IoCallbackArgs */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.__IoPublish"
/** @const */
tsickle_declare_module.dojo_main____IoPublish = {};
 /** @type {!dojo.main.__IoPublish} */
tsickle_declare_module.dojo_main____IoPublish.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main____IoPublish */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.__XhrArgs"
/** @const */
tsickle_declare_module.dojo_main____XhrArgs = {};
 /** @type {!dojo.main.__XhrArgs} */
tsickle_declare_module.dojo_main____XhrArgs.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main____XhrArgs */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.Stateful"
/** @const */
tsickle_declare_module.dojo_main_Stateful = {};
 /** @type {!dojo.main.Stateful} */
tsickle_declare_module.dojo_main_Stateful.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_Stateful */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main._hasResource"
/** @const */
tsickle_declare_module.dojo_main___hasResource = {};
 /** @type {!dojo.main._hasResource} */
tsickle_declare_module.dojo_main___hasResource.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main___hasResource */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main._contentHandlers"
/** @const */
tsickle_declare_module.dojo_main___contentHandlers = {};
 /** @type {!dojo.main._contentHandlers} */
tsickle_declare_module.dojo_main___contentHandlers.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main___contentHandlers */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.cldr"
/** @const */
tsickle_declare_module.dojo_main_cldr = {};
 /** @type {!dojo.main.cldr} */
tsickle_declare_module.dojo_main_cldr.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_cldr */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main._nodeDataCache"
/** @const */
tsickle_declare_module.dojo_main___nodeDataCache = {};
 /** @type {!dojo.main._nodeDataCache} */
tsickle_declare_module.dojo_main___nodeDataCache.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main___nodeDataCache */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.colors"
/** @const */
tsickle_declare_module.dojo_main_colors = {};
 /** @type {!dojo.main.colors} */
tsickle_declare_module.dojo_main_colors.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_colors */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.back"
/** @const */
tsickle_declare_module.dojo_main_back = {};
 /** @type {!dojo.main.back} */
tsickle_declare_module.dojo_main_back.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_back */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.data"
/** @const */
tsickle_declare_module.dojo_main_data = {};
 /** @type {!dojo.main.data} */
tsickle_declare_module.dojo_main_data.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_data */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.config"
/** @const */
tsickle_declare_module.dojo_main_config = {};
 /** @type {!dojo.main.config} */
tsickle_declare_module.dojo_main_config.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_config */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.contentHandlers"
/** @const */
tsickle_declare_module.dojo_main_contentHandlers = {};
 /** @type {!dojo.main.contentHandlers} */
tsickle_declare_module.dojo_main_contentHandlers.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_contentHandlers */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.date"
/** @const */
tsickle_declare_module.dojo_main_date = {};
 /** @type {!dojo.main.date} */
tsickle_declare_module.dojo_main_date.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_date */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.currency"
/** @const */
tsickle_declare_module.dojo_main_currency = {};
 /** @type {!dojo.main.currency} */
tsickle_declare_module.dojo_main_currency.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_currency */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.dnd"
/** @const */
tsickle_declare_module.dojo_main_dnd = {};
 /** @type {!dojo.main.dnd} */
tsickle_declare_module.dojo_main_dnd.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_dnd */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.doc"
/** @const */
tsickle_declare_module.dojo_main_doc = {};
 /** @type {!dojo.main.doc} */
tsickle_declare_module.dojo_main_doc.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_doc */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.gears"
/** @const */
tsickle_declare_module.dojo_main_gears = {};
 /** @type {!dojo.main.gears} */
tsickle_declare_module.dojo_main_gears.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_gears */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.global"
/** @const */
tsickle_declare_module.dojo_main_global = {};
 /** @type {!dojo.main.global} */
tsickle_declare_module.dojo_main_global.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_global */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.dijit"
/** @const */
tsickle_declare_module.dojo_main_dijit = {};
 /** @type {!dojo.main.dijit} */
tsickle_declare_module.dojo_main_dijit.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_dijit */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.io"
/** @const */
tsickle_declare_module.dojo_main_io = {};
 /** @type {!dojo.main.io} */
tsickle_declare_module.dojo_main_io.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_io */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.fx"
/** @const */
tsickle_declare_module.dojo_main_fx = {};
 /** @type {!dojo.main.fx} */
tsickle_declare_module.dojo_main_fx.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_fx */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.html"
/** @const */
tsickle_declare_module.dojo_main_html = {};
 /** @type {!dojo.main.html} */
tsickle_declare_module.dojo_main_html.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_html */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.dojox"
/** @const */
tsickle_declare_module.dojo_main_dojox = {};
 /** @type {!dojo.main.dojox} */
tsickle_declare_module.dojo_main_dojox.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_dojox */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.i18n"
/** @const */
tsickle_declare_module.dojo_main_i__n = {};
 /** @type {!dojo.main.i18n} */
tsickle_declare_module.dojo_main_i__n.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_i__n */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.scopeMap"
/** @const */
tsickle_declare_module.dojo_main_scopeMap = {};
 /** @type {!dojo.main.scopeMap} */
tsickle_declare_module.dojo_main_scopeMap.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_scopeMap */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.regexp"
/** @const */
tsickle_declare_module.dojo_main_regexp = {};
 /** @type {!dojo.main.regexp} */
tsickle_declare_module.dojo_main_regexp.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_regexp */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.mouseButtons"
/** @const */
tsickle_declare_module.dojo_main_mouseButtons = {};
 /** @type {!dojo.main.mouseButtons} */
tsickle_declare_module.dojo_main_mouseButtons.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_mouseButtons */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.rpc"
/** @const */
tsickle_declare_module.dojo_main_rpc = {};
 /** @type {!dojo.main.rpc} */
tsickle_declare_module.dojo_main_rpc.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_rpc */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.number"
/** @const */
tsickle_declare_module.dojo_main_number = {};
 /** @type {!dojo.main.number_} */
tsickle_declare_module.dojo_main_number.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_number */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.keys"
/** @const */
tsickle_declare_module.dojo_main_keys = {};
 /** @type {!dojo.main.keys} */
tsickle_declare_module.dojo_main_keys.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_keys */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.tests"
/** @const */
tsickle_declare_module.dojo_main_tests = {};
 /** @type {!dojo.main.tests} */
tsickle_declare_module.dojo_main_tests.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_tests */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.version"
/** @const */
tsickle_declare_module.dojo_main_version = {};
 /** @type {!dojo.main.version} */
tsickle_declare_module.dojo_main_version.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_version */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.string"
/** @const */
tsickle_declare_module.dojo_main_string = {};
 /** @type {!dojo.main.string_} */
tsickle_declare_module.dojo_main_string.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_string */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.touch"
/** @const */
tsickle_declare_module.dojo_main_touch = {};
 /** @type {!dojo.main.touch} */
tsickle_declare_module.dojo_main_touch.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_touch */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.store"
/** @const */
tsickle_declare_module.dojo_main_store = {};
 /** @type {!dojo.main.store} */
tsickle_declare_module.dojo_main_store.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_store */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/main.window"
/** @const */
tsickle_declare_module.dojo_main_window = {};
 /** @type {!dojo.main.window} */
tsickle_declare_module.dojo_main_window.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_main_window */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/string"
/** @const */
tsickle_declare_module.dojo_string = {};
 /** @type {!dojo.string_} */
tsickle_declare_module.dojo_string.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_string */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/text"
/** @const */
tsickle_declare_module.dojo_text = {};
 /** @type {!dojo.text} */
tsickle_declare_module.dojo_text.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_text */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/topic"
/** @const */
tsickle_declare_module.dojo_topic = {};
 /** @type {!dojo.topic} */
tsickle_declare_module.dojo_topic.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_topic */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/uacss"
/** @const */
tsickle_declare_module.dojo_uacss = {};
 /** @type {!dojo.uacss} */
tsickle_declare_module.dojo_uacss.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_uacss */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/window"
/** @const */
tsickle_declare_module.dojo_window = {};
 /** @type {!dojo.window} */
tsickle_declare_module.dojo_window.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_window */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/touch"
/** @const */
tsickle_declare_module.dojo_touch = {};
 /** @type {!dojo.touch} */
tsickle_declare_module.dojo_touch.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_touch */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/DeferredList"
/** @const */
tsickle_declare_module.dojo_DeferredList = {};
 /** @type {?} */
tsickle_declare_module.dojo_DeferredList.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_DeferredList */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/Deferred"
/** @const */
tsickle_declare_module.dojo_Deferred = {};
 /** @type {?} */
tsickle_declare_module.dojo_Deferred.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_Deferred */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/Evented"
/** @const */
tsickle_declare_module.dojo_Evented = {};
 /** @type {?} */
tsickle_declare_module.dojo_Evented.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_Evented */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/NodeList"
/** @const */
tsickle_declare_module.dojo_NodeList = {};
 /** @type {?} */
tsickle_declare_module.dojo_NodeList.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_NodeList */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/NodeList._nodeDataCache"
/** @const */
tsickle_declare_module.dojo_NodeList___nodeDataCache = {};
 /** @type {!dojo.NodeList._nodeDataCache} */
tsickle_declare_module.dojo_NodeList___nodeDataCache.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_NodeList___nodeDataCache */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/Stateful"
/** @const */
tsickle_declare_module.dojo_Stateful = {};
 /** @type {?} */
tsickle_declare_module.dojo_Stateful.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_Stateful */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/declare"
/** @const */
tsickle_declare_module.dojo___base_declare = {};
 /** @type {?} */
tsickle_declare_module.dojo___base_declare.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_declare */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/declare.__DeclareCreatedObject"
/** @const */
tsickle_declare_module.dojo___base_declare___DeclareCreatedObject = {};
 /** @type {!dojo._base.declare.__DeclareCreatedObject} */
tsickle_declare_module.dojo___base_declare___DeclareCreatedObject.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_declare___DeclareCreatedObject */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/Deferred"
/** @const */
tsickle_declare_module.dojo___base_Deferred = {};
 /** @type {!dojo._base.Deferred} */
tsickle_declare_module.dojo___base_Deferred.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_Deferred */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/url"
/** @const */
tsickle_declare_module.dojo___base_url = {};
 /** @type {!dojo._base.url} */
tsickle_declare_module.dojo___base_url.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_url */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/url.authority"
/** @const */
tsickle_declare_module.dojo___base_url_authority = {};
 /** @type {!dojo._base.url.authority} */
tsickle_declare_module.dojo___base_url_authority.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_url_authority */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/url.password"
/** @const */
tsickle_declare_module.dojo___base_url_password = {};
 /** @type {!dojo._base.url.password} */
tsickle_declare_module.dojo___base_url_password.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_url_password */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/url.port"
/** @const */
tsickle_declare_module.dojo___base_url_port = {};
 /** @type {!dojo._base.url.port} */
tsickle_declare_module.dojo___base_url_port.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_url_port */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/url.fragment"
/** @const */
tsickle_declare_module.dojo___base_url_fragment = {};
 /** @type {!dojo._base.url.fragment} */
tsickle_declare_module.dojo___base_url_fragment.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_url_fragment */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/url.query"
/** @const */
tsickle_declare_module.dojo___base_url_query = {};
 /** @type {!dojo._base.url.query} */
tsickle_declare_module.dojo___base_url_query.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_url_query */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/url.user"
/** @const */
tsickle_declare_module.dojo___base_url_user = {};
 /** @type {!dojo._base.url.user} */
tsickle_declare_module.dojo___base_url_user.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_url_user */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/url.scheme"
/** @const */
tsickle_declare_module.dojo___base_url_scheme = {};
 /** @type {!dojo._base.url.scheme} */
tsickle_declare_module.dojo___base_url_scheme.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_url_scheme */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/xhr"
/** @const */
tsickle_declare_module.dojo___base_xhr = {};
 /** @type {!dojo._base.xhr} */
tsickle_declare_module.dojo___base_xhr.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_xhr */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/xhr.contentHandlers"
/** @const */
tsickle_declare_module.dojo___base_xhr_contentHandlers = {};
 /** @type {!dojo._base.xhr.contentHandlers} */
tsickle_declare_module.dojo___base_xhr_contentHandlers.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_xhr_contentHandlers */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/browser"
/** @const */
tsickle_declare_module.dojo___base_browser = {};
 /** @type {!dojo._base.browser} */
tsickle_declare_module.dojo___base_browser.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_browser */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/array"
/** @const */
tsickle_declare_module.dojo___base_array = {};
 /** @type {!dojo._base.array} */
tsickle_declare_module.dojo___base_array.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_array */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/connect"
/** @const */
tsickle_declare_module.dojo___base_connect = {};
 /** @type {!dojo._base.connect} */
tsickle_declare_module.dojo___base_connect.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_connect */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/event"
/** @const */
tsickle_declare_module.dojo___base_event = {};
 /** @type {!dojo._base.event} */
tsickle_declare_module.dojo___base_event.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_event */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/html"
/** @const */
tsickle_declare_module.dojo___base_html = {};
 /** @type {!dojo._base.html} */
tsickle_declare_module.dojo___base_html.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_html */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/json"
/** @const */
tsickle_declare_module.dojo___base_json = {};
 /** @type {!dojo._base.json} */
tsickle_declare_module.dojo___base_json.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_json */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/fx"
/** @const */
tsickle_declare_module.dojo___base_fx = {};
 /** @type {!dojo._base.fx} */
tsickle_declare_module.dojo___base_fx.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_fx */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/query"
/** @const */
tsickle_declare_module.dojo___base_query = {};
 /** @type {!dojo._base.query} */
tsickle_declare_module.dojo___base_query.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_query */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/NodeList"
/** @const */
tsickle_declare_module.dojo___base_NodeList = {};
 /** @type {!dojo._base.NodeList} */
tsickle_declare_module.dojo___base_NodeList.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_NodeList */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/sniff"
/** @const */
tsickle_declare_module.dojo___base_sniff = {};
 /** @type {!dojo._base.sniff} */
tsickle_declare_module.dojo___base_sniff.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_sniff */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/lang"
/** @const */
tsickle_declare_module.dojo___base_lang = {};
 /** @type {!dojo._base.lang} */
tsickle_declare_module.dojo___base_lang.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_lang */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/unload"
/** @const */
tsickle_declare_module.dojo___base_unload = {};
 /** @type {!dojo._base.unload} */
tsickle_declare_module.dojo___base_unload.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_unload */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/window"
/** @const */
tsickle_declare_module.dojo___base_window = {};
 /** @type {!dojo._base.window} */
tsickle_declare_module.dojo___base_window.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_window */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/window.doc"
/** @const */
tsickle_declare_module.dojo___base_window_doc = {};
 /** @type {!dojo._base.window.doc} */
tsickle_declare_module.dojo___base_window_doc.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_window_doc */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/window.global"
/** @const */
tsickle_declare_module.dojo___base_window_global = {};
 /** @type {!dojo._base.window.global} */
tsickle_declare_module.dojo___base_window_global.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_window_global */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel"
/** @const */
tsickle_declare_module.dojo___base_kernel = {};
 /** @type {?} */
tsickle_declare_module.dojo___base_kernel.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.__IoCallbackArgs"
/** @const */
tsickle_declare_module.dojo___base_kernel___IoCallbackArgs = {};
 /** @type {!dojo._base.kernel.__IoCallbackArgs} */
tsickle_declare_module.dojo___base_kernel___IoCallbackArgs.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel___IoCallbackArgs */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.__IoPublish"
/** @const */
tsickle_declare_module.dojo___base_kernel___IoPublish = {};
 /** @type {!dojo._base.kernel.__IoPublish} */
tsickle_declare_module.dojo___base_kernel___IoPublish.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel___IoPublish */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.__IoArgs"
/** @const */
tsickle_declare_module.dojo___base_kernel___IoArgs = {};
 /** @type {!dojo._base.kernel.__IoArgs} */
tsickle_declare_module.dojo___base_kernel___IoArgs.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel___IoArgs */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.__XhrArgs"
/** @const */
tsickle_declare_module.dojo___base_kernel___XhrArgs = {};
 /** @type {!dojo._base.kernel.__XhrArgs} */
tsickle_declare_module.dojo___base_kernel___XhrArgs.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel___XhrArgs */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.Stateful"
/** @const */
tsickle_declare_module.dojo___base_kernel_Stateful = {};
 /** @type {!dojo._base.kernel.Stateful} */
tsickle_declare_module.dojo___base_kernel_Stateful.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_Stateful */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel._contentHandlers"
/** @const */
tsickle_declare_module.dojo___base_kernel__contentHandlers = {};
 /** @type {!dojo._base.kernel._contentHandlers} */
tsickle_declare_module.dojo___base_kernel__contentHandlers.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel__contentHandlers */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel._hasResource"
/** @const */
tsickle_declare_module.dojo___base_kernel__hasResource = {};
 /** @type {!dojo._base.kernel._hasResource} */
tsickle_declare_module.dojo___base_kernel__hasResource.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel__hasResource */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel._nodeDataCache"
/** @const */
tsickle_declare_module.dojo___base_kernel__nodeDataCache = {};
 /** @type {!dojo._base.kernel._nodeDataCache} */
tsickle_declare_module.dojo___base_kernel__nodeDataCache.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel__nodeDataCache */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.back"
/** @const */
tsickle_declare_module.dojo___base_kernel_back = {};
 /** @type {!dojo._base.kernel.back} */
tsickle_declare_module.dojo___base_kernel_back.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_back */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.cldr"
/** @const */
tsickle_declare_module.dojo___base_kernel_cldr = {};
 /** @type {!dojo._base.kernel.cldr} */
tsickle_declare_module.dojo___base_kernel_cldr.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_cldr */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.colors"
/** @const */
tsickle_declare_module.dojo___base_kernel_colors = {};
 /** @type {!dojo._base.kernel.colors} */
tsickle_declare_module.dojo___base_kernel_colors.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_colors */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.config"
/** @const */
tsickle_declare_module.dojo___base_kernel_config = {};
 /** @type {!dojo._base.kernel.config} */
tsickle_declare_module.dojo___base_kernel_config.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_config */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.contentHandlers"
/** @const */
tsickle_declare_module.dojo___base_kernel_contentHandlers = {};
 /** @type {!dojo._base.kernel.contentHandlers} */
tsickle_declare_module.dojo___base_kernel_contentHandlers.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_contentHandlers */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.dnd"
/** @const */
tsickle_declare_module.dojo___base_kernel_dnd = {};
 /** @type {!dojo._base.kernel.dnd} */
tsickle_declare_module.dojo___base_kernel_dnd.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_dnd */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.date"
/** @const */
tsickle_declare_module.dojo___base_kernel_date = {};
 /** @type {!dojo._base.kernel.date} */
tsickle_declare_module.dojo___base_kernel_date.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_date */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.doc"
/** @const */
tsickle_declare_module.dojo___base_kernel_doc = {};
 /** @type {!dojo._base.kernel.doc} */
tsickle_declare_module.dojo___base_kernel_doc.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_doc */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.data"
/** @const */
tsickle_declare_module.dojo___base_kernel_data = {};
 /** @type {!dojo._base.kernel.data} */
tsickle_declare_module.dojo___base_kernel_data.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_data */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.currency"
/** @const */
tsickle_declare_module.dojo___base_kernel_currency = {};
 /** @type {!dojo._base.kernel.currency} */
tsickle_declare_module.dojo___base_kernel_currency.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_currency */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.dijit"
/** @const */
tsickle_declare_module.dojo___base_kernel_dijit = {};
 /** @type {!dojo._base.kernel.dijit} */
tsickle_declare_module.dojo___base_kernel_dijit.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_dijit */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.global"
/** @const */
tsickle_declare_module.dojo___base_kernel_global = {};
 /** @type {!dojo._base.kernel.global} */
tsickle_declare_module.dojo___base_kernel_global.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_global */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.gears"
/** @const */
tsickle_declare_module.dojo___base_kernel_gears = {};
 /** @type {!dojo._base.kernel.gears} */
tsickle_declare_module.dojo___base_kernel_gears.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_gears */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.fx"
/** @const */
tsickle_declare_module.dojo___base_kernel_fx = {};
 /** @type {!dojo._base.kernel.fx} */
tsickle_declare_module.dojo___base_kernel_fx.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_fx */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.html"
/** @const */
tsickle_declare_module.dojo___base_kernel_html = {};
 /** @type {!dojo._base.kernel.html} */
tsickle_declare_module.dojo___base_kernel_html.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_html */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.io"
/** @const */
tsickle_declare_module.dojo___base_kernel_io = {};
 /** @type {!dojo._base.kernel.io} */
tsickle_declare_module.dojo___base_kernel_io.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_io */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.dojox"
/** @const */
tsickle_declare_module.dojo___base_kernel_dojox = {};
 /** @type {!dojo._base.kernel.dojox} */
tsickle_declare_module.dojo___base_kernel_dojox.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_dojox */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.i18n"
/** @const */
tsickle_declare_module.dojo___base_kernel_i__n = {};
 /** @type {!dojo._base.kernel.i18n} */
tsickle_declare_module.dojo___base_kernel_i__n.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_i__n */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.mouseButtons"
/** @const */
tsickle_declare_module.dojo___base_kernel_mouseButtons = {};
 /** @type {!dojo._base.kernel.mouseButtons} */
tsickle_declare_module.dojo___base_kernel_mouseButtons.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_mouseButtons */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.rpc"
/** @const */
tsickle_declare_module.dojo___base_kernel_rpc = {};
 /** @type {!dojo._base.kernel.rpc} */
tsickle_declare_module.dojo___base_kernel_rpc.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_rpc */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.regexp"
/** @const */
tsickle_declare_module.dojo___base_kernel_regexp = {};
 /** @type {!dojo._base.kernel.regexp} */
tsickle_declare_module.dojo___base_kernel_regexp.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_regexp */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.number"
/** @const */
tsickle_declare_module.dojo___base_kernel_number = {};
 /** @type {!dojo._base.kernel.number_} */
tsickle_declare_module.dojo___base_kernel_number.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_number */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.scopeMap"
/** @const */
tsickle_declare_module.dojo___base_kernel_scopeMap = {};
 /** @type {!dojo._base.kernel.scopeMap} */
tsickle_declare_module.dojo___base_kernel_scopeMap.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_scopeMap */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.tests"
/** @const */
tsickle_declare_module.dojo___base_kernel_tests = {};
 /** @type {!dojo._base.kernel.tests} */
tsickle_declare_module.dojo___base_kernel_tests.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_tests */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.keys"
/** @const */
tsickle_declare_module.dojo___base_kernel_keys = {};
 /** @type {!dojo._base.kernel.keys} */
tsickle_declare_module.dojo___base_kernel_keys.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_keys */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.store"
/** @const */
tsickle_declare_module.dojo___base_kernel_store = {};
 /** @type {!dojo._base.kernel.store} */
tsickle_declare_module.dojo___base_kernel_store.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_store */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.string"
/** @const */
tsickle_declare_module.dojo___base_kernel_string = {};
 /** @type {!dojo._base.kernel.string_} */
tsickle_declare_module.dojo___base_kernel_string.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_string */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.version"
/** @const */
tsickle_declare_module.dojo___base_kernel_version = {};
 /** @type {!dojo._base.kernel.version} */
tsickle_declare_module.dojo___base_kernel_version.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_version */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.touch"
/** @const */
tsickle_declare_module.dojo___base_kernel_touch = {};
 /** @type {!dojo._base.kernel.touch} */
tsickle_declare_module.dojo___base_kernel_touch.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_touch */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/kernel.window"
/** @const */
tsickle_declare_module.dojo___base_kernel_window = {};
 /** @type {!dojo._base.kernel.window} */
tsickle_declare_module.dojo___base_kernel_window.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_kernel_window */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/config"
/** @const */
tsickle_declare_module.dojo___base_config = {};
 /** @type {!dojo._base.config} */
tsickle_declare_module.dojo___base_config.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_config */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/config.modulePaths"
/** @const */
tsickle_declare_module.dojo___base_config_modulePaths = {};
 /** @type {!dojo._base.config.modulePaths} */
tsickle_declare_module.dojo___base_config_modulePaths.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_config_modulePaths */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/Color"
/** @const */
tsickle_declare_module.dojo___base_Color = {};
 /** @type {?} */
tsickle_declare_module.dojo___base_Color.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_Color */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/_base/Color.named"
/** @const */
tsickle_declare_module.dojo___base_Color_named = {};
 /** @type {!dojo._base.Color.named} */
tsickle_declare_module.dojo___base_Color_named.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo___base_Color_named */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/cldr/monetary"
/** @const */
tsickle_declare_module.dojo_cldr_monetary = {};
 /** @type {!dojo.cldr.monetary} */
tsickle_declare_module.dojo_cldr_monetary.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_cldr_monetary */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/cldr/supplemental"
/** @const */
tsickle_declare_module.dojo_cldr_supplemental = {};
 /** @type {!dojo.cldr.supplemental} */
tsickle_declare_module.dojo_cldr_supplemental.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_cldr_supplemental */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/data/ItemFileReadStore"
/** @const */
tsickle_declare_module.dojo_data_ItemFileReadStore = {};
 /** @type {?} */
tsickle_declare_module.dojo_data_ItemFileReadStore.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_data_ItemFileReadStore */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/data/ObjectStore"
/** @const */
tsickle_declare_module.dojo_data_ObjectStore = {};
 /** @type {?} */
tsickle_declare_module.dojo_data_ObjectStore.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_data_ObjectStore */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/data/ItemFileWriteStore"
/** @const */
tsickle_declare_module.dojo_data_ItemFileWriteStore = {};
 /** @type {?} */
tsickle_declare_module.dojo_data_ItemFileWriteStore.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_data_ItemFileWriteStore */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/data/api/Item"
/** @const */
tsickle_declare_module.dojo_data_api_Item = {};
 /** @type {?} */
tsickle_declare_module.dojo_data_api_Item.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_data_api_Item */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/data/api/Identity"
/** @const */
tsickle_declare_module.dojo_data_api_Identity = {};
 /** @type {?} */
tsickle_declare_module.dojo_data_api_Identity.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_data_api_Identity */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/data/api/Request"
/** @const */
tsickle_declare_module.dojo_data_api_Request = {};
 /** @type {?} */
tsickle_declare_module.dojo_data_api_Request.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_data_api_Request */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/data/api/Notification"
/** @const */
tsickle_declare_module.dojo_data_api_Notification = {};
 /** @type {?} */
tsickle_declare_module.dojo_data_api_Notification.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_data_api_Notification */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/data/api/Read"
/** @const */
tsickle_declare_module.dojo_data_api_Read = {};
 /** @type {?} */
tsickle_declare_module.dojo_data_api_Read.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_data_api_Read */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/data/api/Write"
/** @const */
tsickle_declare_module.dojo_data_api_Write = {};
 /** @type {?} */
tsickle_declare_module.dojo_data_api_Write.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_data_api_Write */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/data/util/filter"
/** @const */
tsickle_declare_module.dojo_data_util_filter = {};
 /** @type {!dojo.data.util.filter} */
tsickle_declare_module.dojo_data_util_filter.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_data_util_filter */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/data/util/simpleFetch"
/** @const */
tsickle_declare_module.dojo_data_util_simpleFetch = {};
 /** @type {!dojo.data.util.simpleFetch} */
tsickle_declare_module.dojo_data_util_simpleFetch.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_data_util_simpleFetch */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/data/util/sorter"
/** @const */
tsickle_declare_module.dojo_data_util_sorter = {};
 /** @type {!dojo.data.util.sorter} */
tsickle_declare_module.dojo_data_util_sorter.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_data_util_sorter */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/autoscroll"
/** @const */
tsickle_declare_module.dojo_dnd_autoscroll = {};
 /** @type {!dojo.dnd.autoscroll} */
tsickle_declare_module.dojo_dnd_autoscroll.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_autoscroll */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/autoscroll._validOverflow"
/** @const */
tsickle_declare_module.dojo_dnd_autoscroll___validOverflow = {};
 /** @type {!dojo.dnd.autoscroll._validOverflow} */
tsickle_declare_module.dojo_dnd_autoscroll___validOverflow.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_autoscroll___validOverflow */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/autoscroll._validNodes"
/** @const */
tsickle_declare_module.dojo_dnd_autoscroll___validNodes = {};
 /** @type {!dojo.dnd.autoscroll._validNodes} */
tsickle_declare_module.dojo_dnd_autoscroll___validNodes.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_autoscroll___validNodes */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/common"
/** @const */
tsickle_declare_module.dojo_dnd_common = {};
 /** @type {!dojo.dnd.common} */
tsickle_declare_module.dojo_dnd_common.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_common */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/common._empty"
/** @const */
tsickle_declare_module.dojo_dnd_common___empty = {};
 /** @type {!dojo.dnd.common._empty} */
tsickle_declare_module.dojo_dnd_common___empty.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_common___empty */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/common._defaultCreatorNodes"
/** @const */
tsickle_declare_module.dojo_dnd_common___defaultCreatorNodes = {};
 /** @type {!dojo.dnd.common._defaultCreatorNodes} */
tsickle_declare_module.dojo_dnd_common___defaultCreatorNodes.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_common___defaultCreatorNodes */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/move"
/** @const */
tsickle_declare_module.dojo_dnd_move = {};
 /** @type {?} */
tsickle_declare_module.dojo_dnd_move.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_move */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/move.parentConstrainedMoveable"
/** @const */
tsickle_declare_module.dojo_dnd_move_parentConstrainedMoveable = {};
 /** @type {!dojo.dnd.move.parentConstrainedMoveable} */
tsickle_declare_module.dojo_dnd_move_parentConstrainedMoveable.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_move_parentConstrainedMoveable */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/move.boxConstrainedMoveable"
/** @const */
tsickle_declare_module.dojo_dnd_move_boxConstrainedMoveable = {};
 /** @type {!dojo.dnd.move.boxConstrainedMoveable} */
tsickle_declare_module.dojo_dnd_move_boxConstrainedMoveable.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_move_boxConstrainedMoveable */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/move.constrainedMoveable"
/** @const */
tsickle_declare_module.dojo_dnd_move_constrainedMoveable = {};
 /** @type {!dojo.dnd.move.constrainedMoveable} */
tsickle_declare_module.dojo_dnd_move_constrainedMoveable.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_move_constrainedMoveable */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/Avatar"
/** @const */
tsickle_declare_module.dojo_dnd_Avatar = {};
 /** @type {?} */
tsickle_declare_module.dojo_dnd_Avatar.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_Avatar */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/Manager"
/** @const */
tsickle_declare_module.dojo_dnd_Manager = {};
 /** @type {?} */
tsickle_declare_module.dojo_dnd_Manager.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_Manager */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/Container"
/** @const */
tsickle_declare_module.dojo_dnd_Container = {};
 /** @type {?} */
tsickle_declare_module.dojo_dnd_Container.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_Container */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/Container.__ContainerArgs"
/** @const */
tsickle_declare_module.dojo_dnd_Container____ContainerArgs = {};
 /** @type {!dojo.dnd.Container.__ContainerArgs} */
tsickle_declare_module.dojo_dnd_Container____ContainerArgs.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_Container____ContainerArgs */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/AutoSource"
/** @const */
tsickle_declare_module.dojo_dnd_AutoSource = {};
 /** @type {?} */
tsickle_declare_module.dojo_dnd_AutoSource.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_AutoSource */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/Mover"
/** @const */
tsickle_declare_module.dojo_dnd_Mover = {};
 /** @type {?} */
tsickle_declare_module.dojo_dnd_Mover.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_Mover */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/Moveable"
/** @const */
tsickle_declare_module.dojo_dnd_Moveable = {};
 /** @type {?} */
tsickle_declare_module.dojo_dnd_Moveable.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_Moveable */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/Moveable.__MoveableArgs"
/** @const */
tsickle_declare_module.dojo_dnd_Moveable____MoveableArgs = {};
 /** @type {?} */
tsickle_declare_module.dojo_dnd_Moveable____MoveableArgs.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_Moveable____MoveableArgs */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/Selector"
/** @const */
tsickle_declare_module.dojo_dnd_Selector = {};
 /** @type {?} */
tsickle_declare_module.dojo_dnd_Selector.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_Selector */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/TimedMoveable"
/** @const */
tsickle_declare_module.dojo_dnd_TimedMoveable = {};
 /** @type {?} */
tsickle_declare_module.dojo_dnd_TimedMoveable.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_TimedMoveable */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/Target"
/** @const */
tsickle_declare_module.dojo_dnd_Target = {};
 /** @type {?} */
tsickle_declare_module.dojo_dnd_Target.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_Target */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/dnd/Source"
/** @const */
tsickle_declare_module.dojo_dnd_Source = {};
 /** @type {?} */
tsickle_declare_module.dojo_dnd_Source.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_dnd_Source */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/errors/create"
/** @const */
tsickle_declare_module.dojo_errors_create = {};
 /** @type {!dojo.errors.create} */
tsickle_declare_module.dojo_errors_create.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_errors_create */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/errors/CancelError"
/** @const */
tsickle_declare_module.dojo_errors_CancelError = {};
 /** @type {!dojo.errors.CancelError} */
tsickle_declare_module.dojo_errors_CancelError.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_errors_CancelError */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/errors/RequestError"
/** @const */
tsickle_declare_module.dojo_errors_RequestError = {};
 /** @type {!dojo.errors.RequestError} */
tsickle_declare_module.dojo_errors_RequestError.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_errors_RequestError */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/errors/RequestTimeoutError"
/** @const */
tsickle_declare_module.dojo_errors_RequestTimeoutError = {};
 /** @type {!dojo.errors.RequestTimeoutError} */
tsickle_declare_module.dojo_errors_RequestTimeoutError.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_errors_RequestTimeoutError */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/io/iframe"
/** @const */
tsickle_declare_module.dojo_io_iframe = {};
 /** @type {!dojo.io.iframe} */
tsickle_declare_module.dojo_io_iframe.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_io_iframe */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/io/script"
/** @const */
tsickle_declare_module.dojo_io_script = {};
 /** @type {!dojo.io.script} */
tsickle_declare_module.dojo_io_script.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_io_script */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/promise/all"
/** @const */
tsickle_declare_module.dojo_promise_all = {};
 /** @type {!dojo.promise.all} */
tsickle_declare_module.dojo_promise_all.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_promise_all */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/promise/first"
/** @const */
tsickle_declare_module.dojo_promise_first = {};
 /** @type {!dojo.promise.first} */
tsickle_declare_module.dojo_promise_first.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_promise_first */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/promise/instrumentation"
/** @const */
tsickle_declare_module.dojo_promise_instrumentation = {};
 /** @type {!dojo.promise.instrumentation} */
tsickle_declare_module.dojo_promise_instrumentation.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_promise_instrumentation */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/promise/tracer"
/** @const */
tsickle_declare_module.dojo_promise_tracer = {};
 /** @type {!dojo.promise.tracer} */
tsickle_declare_module.dojo_promise_tracer.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_promise_tracer */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/promise/Promise"
/** @const */
tsickle_declare_module.dojo_promise_Promise = {};
/**
 * @extends {dojo.promise.Promise}
 * @record
 * @struct
 */
tsickle_declare_module.dojo_promise_Promise.Promise = function() {};

/* TODO: ExportAssignment in tsickle_declare_module.dojo_promise_Promise */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/promise/Thenable"
/** @const */
tsickle_declare_module.dojo_promise_Thenable = {};
/**
 * @extends {dojo.promise.Thenable}
 * @record
 * @struct
 */
tsickle_declare_module.dojo_promise_Thenable.Thenable = function() {};

/* TODO: ExportAssignment in tsickle_declare_module.dojo_promise_Thenable */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/rpc/JsonpService"
/** @const */
tsickle_declare_module.dojo_rpc_JsonpService = {};
 /** @type {?} */
tsickle_declare_module.dojo_rpc_JsonpService.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_rpc_JsonpService */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/rpc/JsonService"
/** @const */
tsickle_declare_module.dojo_rpc_JsonService = {};
 /** @type {?} */
tsickle_declare_module.dojo_rpc_JsonService.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_rpc_JsonService */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/rpc/RpcService"
/** @const */
tsickle_declare_module.dojo_rpc_RpcService = {};
 /** @type {?} */
tsickle_declare_module.dojo_rpc_RpcService.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_rpc_RpcService */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/selector/lite"
/** @const */
tsickle_declare_module.dojo_selector_lite = {};
 /** @type {!dojo.selector.lite} */
tsickle_declare_module.dojo_selector_lite.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_selector_lite */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/selector/acme"
/** @const */
tsickle_declare_module.dojo_selector_acme = {};
 /** @type {!dojo.selector.acme} */
tsickle_declare_module.dojo_selector_acme.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_selector_acme */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/selector/_loader"
/** @const */
tsickle_declare_module.dojo_selector___loader = {};
 /** @type {!dojo.selector._loader} */
tsickle_declare_module.dojo_selector___loader.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_selector___loader */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/store/Observable"
/** @const */
tsickle_declare_module.dojo_store_Observable = {};
 /** @type {!dojo.store.Observable} */
tsickle_declare_module.dojo_store_Observable.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_store_Observable */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/store/Cache"
/** @const */
tsickle_declare_module.dojo_store_Cache = {};
 /** @type {?} */
tsickle_declare_module.dojo_store_Cache.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_store_Cache */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/store/DataStore"
/** @const */
tsickle_declare_module.dojo_store_DataStore = {};
 /** @type {?} */
tsickle_declare_module.dojo_store_DataStore.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_store_DataStore */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/store/Memory"
/** @const */
tsickle_declare_module.dojo_store_Memory = {};
 /** @type {?} */
tsickle_declare_module.dojo_store_Memory.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_store_Memory */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/store/JsonRest"
/** @const */
tsickle_declare_module.dojo_store_JsonRest = {};
 /** @type {?} */
tsickle_declare_module.dojo_store_JsonRest.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_store_JsonRest */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/store/api/Store"
/** @const */
tsickle_declare_module.dojo_store_api_Store = {};
 /** @type {?} */
tsickle_declare_module.dojo_store_api_Store.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_store_api_Store */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/store/api/Store.PutDirectives"
/** @const */
tsickle_declare_module.dojo_store_api_Store_PutDirectives = {};
 /** @type {?} */
tsickle_declare_module.dojo_store_api_Store_PutDirectives.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_store_api_Store_PutDirectives */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/store/api/Store.QueryOptions"
/** @const */
tsickle_declare_module.dojo_store_api_Store_QueryOptions = {};
 /** @type {?} */
tsickle_declare_module.dojo_store_api_Store_QueryOptions.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_store_api_Store_QueryOptions */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/store/api/Store.QueryResults"
/** @const */
tsickle_declare_module.dojo_store_api_Store_QueryResults = {};
 /** @type {?} */
tsickle_declare_module.dojo_store_api_Store_QueryResults.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_store_api_Store_QueryResults */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/store/api/Store.SortInformation"
/** @const */
tsickle_declare_module.dojo_store_api_Store_SortInformation = {};
 /** @type {?} */
tsickle_declare_module.dojo_store_api_Store_SortInformation.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_store_api_Store_SortInformation */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/store/api/Store.Transaction"
/** @const */
tsickle_declare_module.dojo_store_api_Store_Transaction = {};
 /** @type {?} */
tsickle_declare_module.dojo_store_api_Store_Transaction.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_store_api_Store_Transaction */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/store/util/QueryResults"
/** @const */
tsickle_declare_module.dojo_store_util_QueryResults = {};
 /** @type {!dojo.store.util.QueryResults} */
tsickle_declare_module.dojo_store_util_QueryResults.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_store_util_QueryResults */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "dojo/store/util/SimpleQueryEngine"
/** @const */
tsickle_declare_module.dojo_store_util_SimpleQueryEngine = {};
 /** @type {!dojo.store.util.SimpleQueryEngine} */
tsickle_declare_module.dojo_store_util_SimpleQueryEngine.exp;

/* TODO: ExportAssignment in tsickle_declare_module.dojo_store_util_SimpleQueryEngine */
